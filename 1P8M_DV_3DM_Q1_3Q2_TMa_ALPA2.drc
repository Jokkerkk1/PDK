// 2019_Jan_16_12:57:03
// Note 1: This rule file is only for 14nm SF+ 0.8/1.8V Design Rules of design rules check (DRC)
// Note 2: Please properly select the design rules file from folder "/DRC/" and "Switches selection 1~10" based on your design
 
// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
// Metallization introduction
// Description of Metallization
// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
// This main DRC rules file is for metal option: 1P8M_DV_3DM_Q1_3Q2_TMa_ALPA2
// Illustration of abbreviation for xPyM_pDV_zDM_aQ1_bQ2_eB_mTMr_nUTM_ALPAu
// Where:
// P = GT layers
// M = total metal layers excluding AL pad/Al RDL
// DV = Via layers with double patterning (including V0)
// DM = Cu inter metal layers with double patterning (including M1)
// Q1 = Cu inter metal layers for 1.25xMy
// Q2 = Cu inter metal layers for 1.25xMn
// B = Cu inter metal layers for 2xMn
// TM = Cu top metal layers
// UTM = Cu ultra thick metal layer
// ALPA = Al pad/Al RDL pad
// 
// x = number of GT layers
// y = number of total metal layers excluding ALPA, where y = a+b+c+d+e
// p = number of double patterning via layers (including V0)
// z = number of double patterning metal layers (including M1)
// a = number of 1.25xMy layers
// b = number of 1.25xMn layers
// e = number of 2xMn layers
// m = number of 10xTMn/14xTMn layers
// r = type of top metal, type a for 10xTMn, type b for 14xTMn
// n = number of ultra thick metal layers (UTM layer)
// u = type of AL, type 1 for AL14.5kA, type 2 for AL28kA

//; *****************************************************************
//; Switches Selection 1: For FEOL/BEOL/DUMC Selection
//; *****************************************************************
//; Description: For FEOL/BEOL/DUMC (dummy check rule) rules DRC check selection
//; These switches will not work for the rules LU, OCCD, OCOVL
//; Available options: YES/NO
//; Default: YES
//; Set to 'NO' if not check

#DEFINE FEOL_RULES_CHECK YES			//;valid value is: {YES,NO}

#DEFINE BEOL_RULES_CHECK YES			//;valid value is: {YES,NO}

#DEFINE DUMMY_RULES_CHECK YES			//;valid value is: {YES,NO}


//; *****************************************************************
//; Switches Selection 2: For DFM/ME/TBS Design Rules Check
//; *****************************************************************
//; Description: For DFM/ME/(TBS for standard cell)/OCCD/OCOVL rules DRC check selection
//; Switch "DFM_RULES_PRIORITY_1": DFM priority-1 rules
//; Switch "DFM_RULES_PRIORITY_2": DFM priority-2 rules
//; Switch "MANUFACTURABILITY_ENHANCEMENT_RULES": ME rules
//; Switch "STANDARD_CELL_UNIQUE_PATTERN_RULES": TBS rules
//; Available options: YES/NO
//; Default: NO
//; Set to 'YES' if check

#DEFINE DFM_RULES_PRIORITY_1 NO				//;valid value is: {YES,NO}

#DEFINE DFM_RULES_PRIORITY_2 NO				//;valid value is: {YES,NO}

#DEFINE MANUFACTURABILITY_ENHANCEMENT_RULES NO		//;valid value is: {YES,NO}

#DEFINE STANDARD_CELL_UNIQUE_PATTERN_RULES NO		//;valid value is: {YES,NO}


//; *****************************************************************
//; Switches Selection 3: For OCCD/OCOVL/Chip Corner/CHIPB Design Rules Check
//; *****************************************************************
//; Description: For OCCD/OCOVL/Chip corner (CORN_?) rules DRC check selection
//; Switch "OCCD_RULES_CHECK": OCCD rules
//; Switch "OCOVL_RULES_CHECK": OCOVL rules
//; Switch "CORN_RULES_CHECK": CORN rules. Can be turn-off for IP level DRC check
//; Switch "CHIPB_RULES_CHECK": CHIPB rules (Chipb boundary) or CHIPB related rules. Can be turn-off for IP level DRC check
//; Available options: YES/NO
//; Default: YES
//; Set to 'NO' if not check

#DEFINE OCCD_RULES_CHECK YES				//;valid value is: {YES,NO}

#DEFINE OCOVL_RULES_CHECK YES				//;valid value is: {YES,NO}

#DEFINE CORN_RULES_CHECK YES				//;valid value is: {YES,NO}

#DEFINE CHIPB_RULES_CHECK YES				//;valid value is: {YES,NO}


//; *****************************************************************
//; Switches Selection 4: For Recommended Rules Check
//; *****************************************************************
//; Description: For recommended rules DRC check selection
//; Available options: YES/NO
//; Default: YES
//; Set to 'NO' if not check

#DEFINE RECOMMENDED_CHECK YES				//;valid value is: {YES,NO}


//; *****************************************************************
//; Switches Selection 5: For Latch Up Guidelines Rules Check
//; *****************************************************************
//; Description: For Latch-up (LU_?) guidelines rules DRC check selection
//; Available options: 85/125/NO
//; 1) "85" is for Latch-up (85 degree) prevention layout guidelines DRC check
//; 2) "125" is for Latch-up (85~125 degree) prevention layout guidelines DRC check
//; Default: 85
//; Set to 'NO' if not check

#DEFINE LATCH_UP_RULES_CHECK 85				//;valid value is: {85,125,NO}

//; Description: For runtime saving/checking accuracy choice of latch-up DRC check
//; Available options: ACCURATE/FAST
//; Default: ACCURATE (Default mode will cost much runtime)
//; Set to 'FAST' to save runtime, but it will sacrifice accuracy

#DEFINE LATCH_UP_CHECK_MODE ACCURATE			//;valid value is: {ACCURATE,FAST}

//; Description: control the connectivity of resistor for latch up guidelines. If resistors with RES2H, the connection is broken
//; Available options: YES/NO
//; Default: NO
//; Set to 'YES' if the connection is not broken by resistors

#DEFINE CONNECT_ALL_RESISTOR NO				//;valid value is: {YES,NO}

//; Description: For PAD identification. Default to recognize PAD with the text of all metal or metal text layers
//; Available options: ON/OFF
//; flow 1: when set to "ON", the priority is: Power text > IO text > IOMK1 > VDDMK1/VSSMK1 > N+ Pickup/P+ Pickup
//; flow 2: when set to "OFF", the priority is: IOMK1 > VDDMK1/VSSMK1 > N+ Pickup/P+ Pickup
//; Default: ON
//; Set to 'OFF' to recognize PAD by flow 2

#DEFINE DEFINE_LU_BY_TEXT ON				//;valid value is: {ON,OFF}

//; Description: Controllable variable for the POWER/GROUND/IO name setting. User can define or append new POWER/GROUND/IO text in DRC utility
//; POWER_NAME: Default POWER text name are "?VDD?", "?VCC?"
//; GROUND_NAME: Default GROUND text name are "?VSS?", "?GND?"
//; IO_NAME: Default IO text name is empty: "" (DRC default set it to a value named "please_add_user_defined_IO_name" to pass syntax)

VARIABLE POWER_NAME  "?VDD?" "?VCC?"
VARIABLE GROUND_NAME  "?VSS?" "?GND?"
VARIABLE IO_NAME  "please_add_user_defined_IO_name"


//; *****************************************************************
//; Switches Selection 6: For Double Patterning (DP) Rules Check
//; *****************************************************************
//; Description: For double patterning rules check selection
//; Warning: Do not change if you are not clearly know the function of this switch
//; Only for those who don't care about double patterning rules check
//; Available options: YES/NO
//; Default: YES
//; Set to 'NO' if not check

#DEFINE DOUBLE_PATTERNING_RULES_CHECK YES		//;valid value is: {YES,NO}

//; Description: For double patterning rules check selection
//; Available options: YES/NO
//; Default: NO
//; Set to 'YES' to only select check the double patterning related rules and therefore other rules will be forced to be turn off

#DEFINE DOUBLE_PATTERNING_RULES_CHECK_ONLY NO		//;valid value is: {YES,NO}

//; Description: To show the conflict space between two adjacent shapes that must be decomposed to different masks
//; Available options: YES/NO
//; Default: NO
//; Set to 'YES' to show the MP conflict space between two adjacent shapes

#DEFINE SHOW_DOUBLE_PATTERNING_CONFLICT_SPACE NO	//;valid value is: {YES,NO}


//; *****************************************************************
//; Switches Selection 7: For Post M1/Mxy Layout Decomposition Check
//; *****************************************************************
//; Description: For absolute value of M1.D.8, Mxy.D.8 for post M1/Mxy layout decomposition
//; Available options: YES/NO
//; Default: NO
//; Set to 'YES' if not check

#DEFINE METAL_DECOMPOSITION_RESULT NO			//;valid value is: {YES,NO}


//; *****************************************************************
//; Switches Selection 8: For Density Rules Check
//; *****************************************************************
//; Description: For minimum density and maximum empty area (eg,AA.S.13~14,GT.S.13/GT.A.2~5,SSD) DRC check selection. Can be turn-off for IP level DRC check
//; Available options: YES/NO
//; Default: YES
//; Set to 'NO' if not check

#DEFINE MINIMUM_DENSITY_CHECK YES			//;valid value is: {YES,NO}


//; *****************************************************************
//; Switches Selection 9: For Delta Voltage Rules Check
//; *****************************************************************
//; Description: Option for delta voltage rules check
//; Available options: YES/NO
//; Default: YES
//; Set to 'NO' if not check

#DEFINE Delta_Voltage_Rules_Check NO			//;valid value is: {YES,NO}


//; Description: DRC check priority for voltage-dependent rule (based on device)
//; Available options: 1/2/3
//; 1) Switch "Lower_voltage_first": lower voltage first, and P-pickup > PMOS > NMOS > VARMOS > GATE poly on the same voltage
//; 2) Switch "IO_voltage_first" on: higher voltage first, and P-pickup > PMOS > NMOS > VARMOS > GATE poly on the same voltage
//; 3) Switch "SD_voltage_first" on: higher voltage SD > lower SD > lower GATE > higher GATE and P-pickup > PMOS > NMOS > VARMOS on the same voltage
//; Notice: "a > b > ..." means "a is prior than b" for voltage check
//; Option: 1 => Lower_voltage_first
//; Option: 2 => IO_voltage_first
//; Option: 3 => SD_voltage_first
//; Default: 1
//; Errors if not set: Calibre syntax ERROR

#DEFINE Device_Voltage_Check_Priority  1		//;valid value is: {1,2,3}


//; *****************************************************************
//; Switches Selection 10: For IP level density check
//; *****************************************************************
//; Description: Option for IP level density check
//; If "IP level density check" switch is turned on, density rule will follow "IP level density check rule"
//; Available options: YES/NO
//; Default: NO
//; Set to 'YES' if check

#DEFINE IP_LEVEL_DENSITY_CHECK NO			//;valid value is: {YES,NO}


//======================================================================================================|
//|                                                                                                     |
//|     14nm Calibre Design rules file for                                                              |
//|                                                                                                     |
//|     SMIC: 14nm SF+ 0.8/1.8V Design Rules                                                            |
//|                                                                                                     |
//|     TECN No: TD-LO14-DR-2017    Doc.Rev: 2   Tech Dev.Rev : V1.0_REV1                               |
//|                                                                                                     |
//|     SMIC R&D                                                                    		        |
//|                                                                                                     |
//|     This file was automatically generated. Please do not modify                                     |
//|                                                                                                     |
//|=====================================================================================================|
//|                                                                                                     |
//|    DISCLAIMER                                                                                       |
//|                                                                                                     |
//|   SMIC hereby provides the quality information to you but makes no claims, promises or guarantees a	|
//| -bout the accuracy, completeness, or adequacy of the information herein. The information contained  |
//| herein is provided on an "AS IS" basis without any warranty, and SMIC assumes no obligation	to prov	|
//| -ide support of any kind or otherwise maintain the information.                                     |
//|                                                                                                     |
//|   SMIC disclaims any representation that the information does not infringe any intellectual	propert |
//| -y rights or proprietary rights of any third parties.SMIC makes no other warranty, whether express,	|
//| implied or statutory as to any matter whatsoever, including but not limited to the accuracy or suff	|
//| -iciency of any information or the merchantability and itness for a particular purpose. Neither SMI	|
//| -C nor any of its representatives shall be liable for any cause cause of action incurred to connect	|
//| to this service.                                                                                    |
//|                                                                                                     |
//|=====================================================================================================|
//|                                                                                                     |
//|    STATEMENT OF USE AND CONFIDENTIALITY                                                             |
//|                                                                                                     |
//|   The following/attached material contains confidential and proprietary information of SMIC. This m |
//| -aterial is based upon information which SMIC considers reliable, but SMIC neither represents nor w |
//| -arrants that such information is accurate or complete, and it must not be relied upon as such. Thi |
//| -s information was prepared for informational purposes and is for the use by SMIC's customer only.	|
//| SMIC reserves the right to make changes in the information at any time without notice.              |
//|   No part of this information may be reproduced, transmitted, transcribed, stored in a retrieval sy |
//| -stem, or translated into any human or computer language, in any form or by any means, electronic,  |
//| mechanical, magnetic, optical, chemical, manual, or otherwise, without the prior written consent of |
//| SMIC. Any unauthorized use or disclosure of this material is strictly prohibited and may be unlawfu |
//| -l. By accepting this material, the receiving party shall be deemed to have acknowledged, accepted, |
//| and agreed to be bound by the foregoing limitations and restrictions. Thank you.          	        |
//|                                                                                                     |
//|=====================================================================================================|
//|                                                                                                     |
//|   This file includes SVRF/TVF Technology under license by Mentor Graphics Corporation.     	        |
//|   \"SVRF/TVF Technology\" shall mean Mentor Graphics' Standard  Verification Rule Format (\"SVRF\") |
//| and Tcl Verification Format (\"TVF\") proprietary syntaxes for expressing process rules. You shall  |
//| not use SVRF/TVF Technology unless you are a Mentor Graphics customer with a license to use the app	|
//| -licable Mentor Graphics software. The exact terms of your obligations and rights are governed by y |
//| -our respective license. You shall not use SVRF/TVF Technology except: (a) for your internal busine |
//| -ss purposes and (b) for use with Mentor Graphics' Calibre tools. All SVRF/TVF Technology constitut |
//| -es orcontains trade secrets and confidential information of Mentor Graphics or its licensors. You 	|
//| shall not make SVRF/TVF Technology available in any form to any person other than your employees an	|
//| -d on-site contractors, excluding Mentor Graphics competitors, whose job performance requires acces |
//| -s and who are under obligations of confidentiality.                                                |
//|=====================================================================================================|

//|=====================================================================================================|
//| Validated with Calibre version 2018.2_15.10                                                         |
//|													|
//| Revision History: Please see the Release_Note for details.                                          |
//|                                                                                                     |
//|   Rev            Date          Who                               What                               |
//| -----------  ------------  ------------  -----------------------------------------------------------|
//| V1.0_REV1_0  27-Dec-2018   Houli_Zheng   Please see Release_Note				        |
//| V1.0_REV0_0  28-Oct-2018   Houli_Zheng   Please see Release_Note				        |
//| V0.6_0       26-Jun-2018   Houli_Zheng   Initial version					        |
//| ----------------------------------------------------------------------------------------------------|
//|=====================================================================================================|


//************************************
//    Calibre Severity Proposals
//************************************
SVRF MESSAGE "We recommend you run this rules file with Calibre 2018.2_15.10"

LAYOUT INPUT EXCEPTION SEVERITY PATH_NONSIMPLE 1
LAYOUT INPUT EXCEPTION SEVERITY PATH_CIRCULAR 6
LAYOUT INPUT EXCEPTION SEVERITY POLYGON_NONSIMPLE 1
LAYOUT INPUT EXCEPTION SEVERITY POLYGON_NOT_CLOSED 2
LAYOUT INPUT EXCEPTION SEVERITY PATH_ENDSEGMENT_SHORT 1
LAYOUT INPUT EXCEPTION SEVERITY PATH_ACUTE 4
LAYOUT INPUT EXCEPTION SEVERITY PATH_WIDTH_ZERO 2
LAYOUT INPUT EXCEPTION SEVERITY POLYGON_IS_RECTANGLE 2
LAYOUT INPUT EXCEPTION SEVERITY BOX_RECORD 1
LAYOUT INPUT EXCEPTION SEVERITY NODE_RECORD 1
LAYOUT INPUT EXCEPTION SEVERITY POLYGON_SPIKE 2
LAYOUT INPUT EXCEPTION SEVERITY PATH_WIDTH_ODD 2
LAYOUT INPUT EXCEPTION SEVERITY POLYGON_DEGENERATE 2
LAYOUT ERROR ON INPUT YES
LAYOUT PROCESS BOX RECORD NO
LAYOUT PROCESS NODE RECORD NO
LAYOUT ALLOW DUPLICATE CELL NO

//*************************************
//     DIRECTIVE SECTION
//*************************************
LAYOUT PRIMARY "*"
LAYOUT PATH "*.gds"
LAYOUT SYSTEM GDSII

DRC RESULTS DATABASE "drc_CAL.OUT" ASCII
DRC SUMMARY REPORT "drc_CAL.SUM" HIER

PRECISION 10000
LAYOUT PRECISION 1000
LAYOUT MAGNIFY AUTO
RESOLUTION 1

FLAG SKEW YES
FLAG ACUTE YES
FLAG OFFGRID YES
FLAG NONSIMPLE YES

LAYOUT BASE LAYER AAi GTi M0G M0i
LAYOUT CLONE ROTATED PLACEMENTS YES

DRC KEEP EMPTY YES
TEXT DEPTH PRIMARY

//************************************
//     INPUT LAYER STATEMENTS
//************************************

LAYER MAP  127  DATATYPE 2  10000
LAYER CELLBi  10000  // cell boundary

LAYER MAP  127  DATATYPE 3  10010
LAYER CHIPB  10010  // chip boundary

LAYER MAP  10  DATATYPE 0  10021
LAYER AAi  10021  // active area

LAYER MAP  12  DATATYPE 0  10022
LAYER NPAA  10022  // Planar AA reservation

LAYER MAP  13  DATATYPE 0  10023
LAYER PPAA  10023  // Pre-Fin

LAYER MAP  10  DATATYPE 1  10030
LAYER AADUMi  10030  // AA dummy layer (for dummy AA insertion)

LAYER MAP  10  DATATYPE 7  10040
LAYER AADOPi  10040  // AA dummy pattern layer for OPC engineering

LAYER MAP  10  DATATYPE 8  10050
LAYER AADMPi  10050  // Manually drawn AA dummy layer with OPC engineering

LAYER MAP  11  DATATYPE 0  10060
LAYER ARi  10060  // Fin cut layer 1

LAYER MAP  14  DATATYPE 0  10080
LAYER NW  10080  // n-well

LAYER MAP  19  DATATYPE 0  10090
LAYER DNW  10090  // Deep n-well

LAYER MAP  29  DATATYPE 0  10100
LAYER DG  10100  // 1.8V IO mark layer

LAYER MAP  29  DATATYPE 1  10110
LAYER DGV  10110  // 1.8V UD 1.2V mark layer

LAYER MAP  29  DATATYPE 3  10120
LAYER DGUD  10120  // 1.8V UD 1.5V mark layer

LAYER MAP  119  DATATYPE 0  10140
LAYER DIR  10140  // TiN resistor mask

LAYER MAP  131  DATATYPE 159  10150
LAYER DMCMK1  10150  // dummy cell marker layer

LAYER MAP  131  DATATYPE 160  10151
LAYER DMCMK2  10151  // dummy cell marker layer

LAYER MAP  134  DATATYPE 0  10160
LAYER DMPNP  10160  // BJT recognition layer

LAYER MAP  138  DATATYPE 0  10170
LAYER DSTR  10170  // Diode marker

LAYER MAP  81  DATATYPE 2  10180
LAYER EFUSE  10180  // e fuse componet mark layer

LAYER MAP  41  DATATYPE 0  10190
LAYER ESD1  10190  // ESD implant

LAYER MAP  89  DATATYPE 151  10200
LAYER ESDMK1  10200  // ESD component mark layer

LAYER MAP  133  DATATYPE 1  10210
LAYER ESD5V  10210  // Cascaded ESD component identification mark

//;LAYER MAP  89  DATATYPE 171  10211
//;LAYER FINBMK1  10211  // FIN Boundary maker layer 1 for FinFET device

LAYER MAP  11  DATATYPE 11  10220
LAYER ARDUM  10220  // AR Dummy Layer (For dummy AR insertion)

LAYER MAP  11  DATATYPE 17  10230
LAYER ARDOP  10230  // AR Dummy pattern layer is referenced in OPC engineering

LAYER MAP  11  DATATYPE 6  10232
LAYER ARDUB  10232  // AR Dummy Blockage  (For dummy AR insertion) and exclude dummy insertion

//;LAYER MAP  13  DATATYPE 1  10240
//;LAYER FINPD1  10240  // Auto fill pre fin reserve type 1
FINPD1 = 300 NOT BULK

LAYER MAP  13  DATATYPE 50  10260
LAYER FIN  10260  // FIn drawn

//;LAYER MAP  13  DATATYPE 51  10270
//;LAYER FIND1  10270  // Fin auto fill type 1

//;LAYER MAP  13  DATATYPE 57  10280
//;LAYER FIND7  10280  // Fin auto fill type 7

LAYER MAP  81  DATATYPE 0  10281
LAYER FUSE  10281  // Passivation opening for Al fuse window

LAYER MAP  30  DATATYPE 0  10290
LAYER GTi  10290  // GT GATE

LAYER MAP  30  DATATYPE 1  10300
LAYER GTDUMi  10300  // GT dummy layer (for dummy GT insertion)

LAYER MAP  30  DATATYPE 7  10310
LAYER GTDOPi  10310  // GT dummy pattern layer for OPC engineering

LAYER MAP  30  DATATYPE 8  10320
LAYER GTDMPi  10320  // Manually drawn GT dummy layer with OPC engineering

//;LAYER MAP  30  DATATYPE 11  10330
//;LAYER GTDUM2  10330  // GT dummy layer 2 (for dummy GT insertion)

//;LAYER MAP  30  DATATYPE 17  10340
//;LAYER GTDOP2  10340  //  GT dummy pattern mark layer 2

//;LAYER MAP  81  DATATYPE 1  10350
//;LAYER GTFUSE  10350  // GT E-fuse mark layer

LAYER MAP  212  DATATYPE 0  10360
LAYER INDMY  10360  // inductor mark layer

LAYER MAP  9  DATATYPE 0  10370
LAYER KV  10370  // Alignment mark clear out

LAYER MAP  216  DATATYPE 150  10380
LAYER LDBK  10380  // LDMOS mark layer

LAYER MAP  12  DATATYPE 150 10390
LAYER NLDB  10390  // N+ LDD and pocket implant blockage/prevention

LAYER MAP  5  DATATYPE 51  10410
LAYER NSRDS1  10410  // NSR dummy treat 1

//;LAYER MAP  5  DATATYPE 52  10420
//;LAYER NSRDS2  10420  // NSR dummy treat 2

//;LAYER MAP  5  DATATYPE 53  10430
//;LAYER NSRDS3  10430  // NSR dummy treat 3

//;LAYER MAP  5  DATATYPE 54  10440
//;LAYER NSRDS4  10440  // NSR dummy treat 4

//;LAYER MAP  5  DATATYPE 238  10450
//;LAYER NSRADD  10450  // SiP add in

LAYER MAP  5  DATATYPE 239  10460
LAYER NSRBL  10460  // SiP blockage

LAYER MAP  31  DATATYPE 0  10470
LAYER P2  10470  // GT GATE trim slot

LAYER MAP  31  DATATYPE 1  10480
LAYER P2DUM  10480  // P2 dummy layer (for p2 dummy insertion)

LAYER MAP  31  DATATYPE 7  10490
LAYER P2DOP  10490  // P2 dummy pattern layer is eferenced in OPC engineering

LAYER MAP  31  DATATYPE 8  10500
LAYER P2DMP  10500  // Manually drawn P2 dummy layer with OPC engineering

//;LAYER MAP  33  DATATYPE 0  10520
//;LAYER P4  10520  // HKMG PMOS WF poly remove

LAYER MAP  13  DATATYPE 150  10540
LAYER PLDB  10540  // P+ LDD and pocket implant blockage/prevention

LAYER MAP  96  DATATYPE 3  10550
LAYER PLRES  10550  // LVS and DRC mark layer for H-R resistor type 2

LAYER MAP  6  DATATYPE 51  10570
LAYER PSRDS1  10570  // PSR dummy treat 1

//;LAYER MAP  6  DATATYPE 52  10580
//;LAYER PSRDS2  10580  // PSR dummy treat 2

//;LAYER MAP  6  DATATYPE 53  10590
//;LAYER PSRDS3  10590  // PSR dummy treat 3

//;LAYER MAP  6  DATATYPE 54  10600
//;LAYER PSRDS4  10600  // PSR dummy treat 4

//;LAYER MAP  6  DATATYPE 238  10610
//;LAYER PSRADD  10610  // SiGe add in

LAYER MAP  6  DATATYPE 239  10620
LAYER PSRBL  10620  // SiGe blockage

LAYER MAP  85  DATATYPE 0  10630
LAYER PSUB  10630  // Marking layer for native device

LAYER MAP  95  DATATYPE 0  10640
LAYER RESNW  10640  // Marking layer for NW resistor

LAYER MAP  96  DATATYPE 0  10650
LAYER RESP1  10650  // LVS and DRC mark layer for H-R resistor

LAYER MAP  96  DATATYPE 2  10660
LAYER RESP2  10660  // Marking layer for H-R & Metal resistor portion

//;LAYER MAP  97  DATATYPE 0  10670
//;LAYER RESAA  10670  // Dummy Pattern for AA Resistor

LAYER MAP  181  DATATYPE 0  10680
LAYER RFDEV  10680  // Dummy layer for LVS to recognize RF Device

LAYER MAP  131  DATATYPE 153  10700
LAYER RSPMK1  10700  // Restricted Special Pattern Maker Layer 1

//;LAYER MAP  131  DATATYPE 154  10710
//;LAYER RSPMK2  10710  // Restricted Special Pattern Maker Layer 2

LAYER MAP  84  DATATYPE 239  10740
LAYER SMMK  10740  // Marking layer for area of SMT stress nitride

LAYER MAP  12  DATATYPE 138  10750
LAYER SNBL  10750  // Marking layer for blockage of N+ S/D Implant

LAYER MAP  40  DATATYPE 0  10760
LAYER SN  10760  // N+ S/D Implant

LAYER MAP  13  DATATYPE 239  10770
LAYER SPBL  10770  // Marking layer for blockage of P+ S/D Implant

LAYER MAP  43  DATATYPE 0  10780
LAYER SP  10780  // P+ S/D Implant

LAYER MAP  159  DATATYPE 158  10790
LAYER LVT_N  10790  // Marking layer for N-type low-Vt devices

LAYER MAP  159  DATATYPE 168  10800
LAYER LVT_P  10800  // Marking layer for P-type low-Vt devices

LAYER MAP  159  DATATYPE 157  10810
LAYER SVT_N  10810  // Marking layer for N-type standard-Vt devices

LAYER MAP  159  DATATYPE 167  10820
LAYER SVT_P  10820  // Marking layer for P-type standard-Vt devices

LAYER MAP  159  DATATYPE 159  10830
LAYER ULVT_N  10830  // 	Marker layer for N-type Ultra low Vth device

LAYER MAP  159  DATATYPE 169  10840
LAYER ULVT_P  10840  // 	Marker layer for p-type Ultra low Vth device

LAYER MAP  93  DATATYPE 0  10860
LAYER VARMOS  10860  // Block Layer to cover all MOS-type varactor

LAYER MAP  59  DATATYPE 0  10900
LAYER M0i  10900  // Contact on AA

LAYER MAP  59  DATATYPE 1  10910
LAYER M0DUM  10910  // Metal-0 Dummy Layer (For dummy M0 insertion)

LAYER MAP  59  DATATYPE 7  10920
LAYER M0DOP  10920  // Metal-0 dummy pattern layer is referenced in OPC engineering

LAYER MAP  59  DATATYPE 8  10930
LAYER M0DMP  10930  // Manually drawn M0 dummy layer with OPC engineering

LAYER MAP  208  DATATYPE 0  10940
LAYER M0G  10940  // M0 on GT (M0 double patterning 2nd mask)

LAYER MAP  208  DATATYPE 1  10950
LAYER M0GDUM  10950  // M0G dummy Layer (For dummy M0G insertion)

LAYER MAP  208  DATATYPE 7  10960
LAYER M0GDOP  10960  // M0G dummy pattern layer is referenced in OPC engineering

LAYER MAP  208  DATATYPE 8  10970
LAYER M0GDMP  10970  // Manually drawn M0G dummy layer with OPC engineering

LAYER MAP  246  DATATYPE 0  10980
LAYER M0C  10980  // M0 cut

LAYER MAP  246  DATATYPE 1  10990
LAYER M0CDUM  10990  // M0C Dummy Layer(For dummy M0C insertion)

LAYER MAP  246  DATATYPE 7  11000
LAYER M0CDOP  11000  // M0C Dummy pattern layer is referenced in OPC engineering

LAYER MAP  246  DATATYPE 8  11010
LAYER M0CDMP  11010  // Manually drawn M0C dummy layer with OPC engineering

LAYER MAP  245  DATATYPE 0  11020
LAYER V0i  11020  // V0

LAYER MAP  245  DATATYPE 8  11030
LAYER V0RB  11030  // Via-0 blockage layer to skip redundant via insertion

LAYER MAP  245  DATATYPE 10  11040
LAYER V0RM  11040  // Via-0 marker layer to identify redundant via

LAYER MAP  245  DATATYPE 20  11050
LAYER V0DPMK  11050  // Via-0 same color marker layer

LAYER MAP  171  DATATYPE 0  11060
LAYER V0DP  11060  // Via-0 Double Patterning 2nd Mask

LAYER MAP  171  DATATYPE 1  11070
LAYER V0DPDUM  11070  // V0DP Dummy Layer(For dummy via insertion)

//;LAYER MAP  70  DATATYPE 0  11090
//;LAYER V1i  11090  // Via-1
V1i = 370 NOT BULK

LAYER MAP  70  DATATYPE 1  11100
LAYER V1DUM  11100  // via-1 Dummy Layer

LAYER MAP  70  DATATYPE 7  11110
LAYER V1DOP  11110  // V1 dummy data type 7

LAYER MAP  70  DATATYPE 8  11120
LAYER V1RB  11120  // Via-1 blockage layer to skip redundant via insertion

LAYER MAP  70  DATATYPE 10  11130
LAYER V1RM  11130  // V1 mark layer to identify redundant via

//;LAYER MAP  70  DATATYPE 20  11140
//;LAYER V1DPMK  11140  // Via-1 same color marker layer
V1DPMK = 306 NOT BULK

LAYER MAP  70  DATATYPE 40  11150
LAYER V1_40  11150  // Via-1 Hole for data type 40 (Vy)

//;LAYER MAP  70  DATATYPE 50  11160
//;LAYER V1_50  11160  // Via-1 Hole for data type 50 (1.25xVn)
V1_50 = 1 NOT BULK

//;LAYER MAP  70  DATATYPE 60  11170
//;LAYER V1_60  11170  // Via-1 Hole for data type 60 (Vz)
V1_60 = 2 NOT BULK

//;LAYER MAP  70  DATATYPE 70  11180
//;LAYER V1_70  11180  // Via-1 Hole for data type 70 (1.4xVn)
V1_70 = 3 NOT BULK

//;LAYER MAP  172  DATATYPE 0  11190
//;LAYER V1DP  11190  // Via-1 Double Patterning 2nd Mask
V1DP = 309 NOT BULK

//;LAYER MAP  71  DATATYPE 0  11220
//;LAYER V2i  11220  // Via-2
V2i = 371 NOT BULK

LAYER MAP  71  DATATYPE 1  11230
LAYER V2DUM  11230  // via-2 Dummy Layer

LAYER MAP  71  DATATYPE 7  11240
LAYER V2DOP  11240  // V2 dummy data type 7

LAYER MAP  71  DATATYPE 8  11250
LAYER V2RB  11250  // Via-2 blockage layer to skip redundant via insertion

LAYER MAP  71  DATATYPE 10  11260
LAYER V2RM  11260  // V2 mark layer to identify redundant via

//;LAYER MAP  71  DATATYPE 20  11270
//;LAYER V2DPMK  11270  // Via-2 same color marker layer
V2DPMK = 305 NOT BULK

LAYER MAP  71  DATATYPE 40  11280
LAYER V2_40  11280  // Via-2 Hole for data type 40 (Vy)

//;LAYER MAP  71  DATATYPE 50  11290
//;LAYER V2_50  11290  // Via-2 Hole for data type 50 (1.25xVn)
V2_50 = 4 NOT BULK

//;LAYER MAP  71  DATATYPE 60  11300
//;LAYER V2_60  11300  // Via-2 Hole for data type 60
V2_60 = 5 NOT BULK

//;LAYER MAP  71  DATATYPE 70  11310
//;LAYER V2_70  11310  // Via-2 Hole for data type 70
V2_70 = 6 NOT BULK

//;LAYER MAP  173  DATATYPE 0  11320
//;LAYER V2DP  11320  // Via-2 Double Patterning 2nd Mask
V2DP = 308 NOT BULK

//;LAYER MAP  72  DATATYPE 0  11350
//;LAYER V3i  11350  // Via-3
V3i = 372 NOT BULK

LAYER MAP  72  DATATYPE 1  11360
LAYER V3DUM  11360  // via-3 Dummy Layer

LAYER MAP  72  DATATYPE 7  11370
LAYER V3DOP  11370  // V3 dummy data type 7

LAYER MAP  72  DATATYPE 8  11380
LAYER V3RB  11380  // Via-3 blockage layer to skip redundant via insertion

LAYER MAP  72  DATATYPE 10  11390
LAYER V3RM  11390  // V3 mark layer to identify redundant via

//;LAYER MAP  72  DATATYPE 20  11400
//;LAYER V3DPMK  11400  // Via-3 same color marker layer
V3DPMK = 304 NOT BULK

LAYER MAP  72  DATATYPE 40  11410
LAYER V3_40  11410  // Via-3 Hole for data type 40 (Vy)

//;LAYER MAP  72  DATATYPE 50  11420
//;LAYER V3_50  11420  // Via-3 Hole for data type 50 (1.25xVn)
V3_50 = 7 NOT BULK

//;LAYER MAP  72  DATATYPE 60  11430
//;LAYER V3_60  11430  // Via-3 Hole for data type 60
V3_60 = 8 NOT BULK

//;LAYER MAP  72  DATATYPE 70  11440
//;LAYER V3_70  11440  // Via-3 Hole for data type 70
V3_70 = 9 NOT BULK

//;LAYER MAP  174  DATATYPE 0  11450
//;LAYER V3DP  11450  // Via-3 Double Patterning 2nd Mask
V3DP = 307 NOT BULK

//;LAYER MAP  73  DATATYPE 0  11480
//;LAYER V4i  11480  // Via-4
V4i = 373 NOT BULK

LAYER MAP  73  DATATYPE 1  11490
LAYER V4DUM  11490  // via-4 Dummy Layer

LAYER MAP  73  DATATYPE 7  11500
LAYER V4DOP  11500  // V4 dummy data type 7

LAYER MAP  73  DATATYPE 8  11510
LAYER V4RB  11510  // Via-4 blockage layer to skip redundant via insertion

LAYER MAP  73  DATATYPE 10  11520
LAYER V4RM  11520  // V4 mark layer to identify redundant via

//;LAYER MAP  73  DATATYPE 40  11540
//;LAYER V4_40  11540  // Via-4 Hole for data type 40 (Vy)
V4_40 = 374 NOT BULK

LAYER MAP  73  DATATYPE 50  11550
LAYER V4_50  11550  // Via-4 Hole for data type 50 (1.25xVn)

//;LAYER MAP  73  DATATYPE 60  11560
//;LAYER V4_60  11560  // Via-4 Hole for data type 60
V4_60 = 10 NOT BULK

//;LAYER MAP  73  DATATYPE 70  11570
//;LAYER V4_70  11570  // Via-4 Hole for data type 70
V4_70 = 11 NOT BULK

//;LAYER MAP  74  DATATYPE 0  11580
//;LAYER V5i  11580  // Via-5
V5i = 375 NOT BULK

LAYER MAP  74  DATATYPE 1  11590
LAYER V5DUM  11590  // Via-5 Dummy Layer

LAYER MAP  74  DATATYPE 7  11600
LAYER V5DOP  11600  // V5 dummy data type 7

LAYER MAP  74  DATATYPE 8  11610
LAYER V5RB  11610  // Via-5 blockage layer to skip redundant via insertion

LAYER MAP  74  DATATYPE 10  11620
LAYER V5RM  11620  // V5 mark layer to identify redundant via

//;LAYER MAP  74  DATATYPE 40  11640
//;LAYER V5_40  11640  // Via-5 Hole for data type 40 (Vy)
V5_40 = 376 NOT BULK

LAYER MAP  74  DATATYPE 50  11650
LAYER V5_50  11650  // Via-5 Hole for data type 50 (1.25xVn)

//;LAYER MAP  74  DATATYPE 60  11660
//;LAYER V5_60  11660  // Via-5 Hole for data type 60
V5_60 = 12 NOT BULK

//;LAYER MAP  74  DATATYPE 70  11670
//;LAYER V5_70  11670  // Via-5 Hole for data type 70
V5_70 = 13 NOT BULK

//;LAYER MAP  75  DATATYPE 0  11680
//;LAYER V6i  11680  // Via-6
V6i = 377 NOT BULK

LAYER MAP  75  DATATYPE 1  11690
LAYER V6DUM  11690  // via-6 Dummy Layer

LAYER MAP  75  DATATYPE 7  11700
LAYER V6DOP  11700  // V6 dummy data type 7

LAYER MAP  75  DATATYPE 8  11710
LAYER V6RB  11710  // Via-6 blockage layer to skip redundant via insertion

LAYER MAP  75  DATATYPE 10  11720
LAYER V6RM  11720  // V6 mark layer to identify redundant via

//;LAYER MAP  75  DATATYPE 40  11740
//;LAYER V6_40  11740  // Via-6 Hole for data type 40 (Vy)
V6_40 = 378 NOT BULK

LAYER MAP  75  DATATYPE 50  11750
LAYER V6_50  11750  // Via-6 Hole for data type 50 (1.25xVn)

//;LAYER MAP  75  DATATYPE 60  11760
//;LAYER V6_60  11760  // Via-6 Hole for data type 60
V6_60 = 14 NOT BULK

//;LAYER MAP  75  DATATYPE 70  11770
//;LAYER V6_70  11770  // Via-6 Hole for data type 70
V6_70 = 15 NOT BULK

//;LAYER MAP  76  DATATYPE 0  11780
//;LAYER V7i  11780  // Via-7 Hole
V7i = 379 NOT BULK

LAYER MAP  76  DATATYPE 1  11790
LAYER V7DUM  11790  // via-7 Dummy Layer

LAYER MAP  76  DATATYPE 7  11800
LAYER V7DOP  11800  // V7 dummy data type 7

LAYER MAP  76  DATATYPE 8  11810
LAYER V7RB  11810  // Via-7 blockage layer to skip redundant via insertion

LAYER MAP  76  DATATYPE 10  11820
LAYER V7RM  11820  // V7 mark layer to identify redundant via

//;LAYER MAP  76  DATATYPE 40  11840
//;LAYER V7_40  11840  // Via-7 Hole for data type 40 (Vy)
V7_40 = 380 NOT BULK

LAYER MAP  76  DATATYPE 50  11850
LAYER V7_50  11850  // Via-7 Hole for data type 50 (1.25xVn)

//;LAYER MAP  76  DATATYPE 60  11860
//;LAYER V7_60  11860  // Via-7 Hole for data type 60
V7_60 = 16 NOT BULK

//;LAYER MAP  76  DATATYPE 70  11870
//;LAYER V7_70  11870  // Via-7 Hole for data type 70
V7_70 = 17 NOT BULK

//;LAYER MAP  77  DATATYPE 0  11880
//;LAYER V8i  11880  // Via-8
V8i = 18 NOT BULK

//;LAYER MAP  77  DATATYPE 1  11890
//;LAYER V8DUM  11890  // via-8 Dummy Layer
V8DUM = 19 NOT BULK

//;LAYER MAP  77  DATATYPE 7  11900
//;LAYER V8DOP  11900  // V8 dummy data type 7
V8DOP = 20 NOT BULK

//;LAYER MAP  77  DATATYPE 8  11910
//;LAYER V8RB  11910  // Via-8 blockage layer to skip redundant via insertion
V8RB = 21 NOT BULK

//;LAYER MAP  77  DATATYPE 10  11920
//;LAYER V8RM  11920  // V8 mark layer to identify redundant via
V8RM = 22 NOT BULK

//;LAYER MAP  77  DATATYPE 40  11940
//;LAYER V8_40  11940  // Via-8 Hole for data type 40 (Vy)
V8_40 = 23 NOT BULK

//;LAYER MAP  77  DATATYPE 50  11950
//;LAYER V8_50  11950  // Via-8 Hole for data type 50 (1.25xVn)
V8_50 = 24 NOT BULK

//;LAYER MAP  77  DATATYPE 60  11960
//;LAYER V8_60  11960  // Via-8 Hole for data type 60
V8_60 = 25 NOT BULK

//;LAYER MAP  77  DATATYPE 70  11970
//;LAYER V8_70  11970  // Via-8 Hole for data type 70
V8_70 = 26 NOT BULK

LAYER MAP  121  DATATYPE 0  12030
LAYER TV1i  12030  // Top Via 1

LAYER MAP  121  DATATYPE 1  12040
LAYER TV1DUM  12040  // TV-1 Dummy Layer

LAYER MAP  121  DATATYPE 8  12050
LAYER TV1RB  12050  // First top via blockage layer to skip redundant via insertion

LAYER MAP  121  DATATYPE 10  12060
LAYER TV1RM  12060  // TV1 mark layer to identify redundant via

LAYER MAP  121  DATATYPE 40  12070
LAYER TV1_40  12070  // First Top Via Hole for data type 40 (14xTV1)

LAYER MAP  123  DATATYPE 0  12080
LAYER TV2i  12080  // Top Via 2

LAYER MAP  123  DATATYPE 1  12090
LAYER TV2DUM  12090  // TV-2 Dummy Layer

LAYER MAP  123  DATATYPE 8  12100
LAYER TV2RB  12100  // Second top via blockage layer to skip redundant via insertion

LAYER MAP  123  DATATYPE 10  12110
LAYER TV2RM  12110  // TV2 mark layer to identify redundant via

LAYER MAP  123  DATATYPE 40  12120
LAYER TV2_40  12120  // Second Top Via Hole for data type 40 (14xTV2)

LAYER MAP  148  DATATYPE 0  12130
LAYER UTV  12130  // Ultra Thick Via Hole

LAYER MAP  148  DATATYPE 1  12140
LAYER UTVDUM  12140  // UTV Dummy Layer(For dummy via insertion)

LAYER MAP  148  DATATYPE 7  12150
LAYER UTVDOP  12150  // UTV dummy pattern layer is referenced in OPC engineering

LAYER MAP  148  DATATYPE 8  12160
LAYER UTVRB  12160  // UTV blockage layer to skip redundant via insertion

LAYER MAP  148  DATATYPE 10  12170
LAYER UTVRM  12170  // UTV marker layer to identify redundant via

LAYER MAP  61  DATATYPE 0  12180
LAYER MAP  61  TEXTTYPE 0  12180
LAYER M1i  12180  // Metal-1

LAYER MAP  61  DATATYPE 1  12190
LAYER M1DUM  12190  // Metal1 Dummy Layer

LAYER MAP  61  DATATYPE 7  12200
LAYER M1DOPi  12200  // Metal 1 Dummy pattern layer for OPC engineering

LAYER MAP  61  DATATYPE 20  12210
LAYER M1DPMK  12210  // M1 same color marker layer

//;LAYER MAP  61  DATATYPE 40  12220
//;LAYER MAP  61  TEXTTYPE 40  12220
//;LAYER M1_40  12220  // Metal-1 for data type 40 (1.25xMy)
M1_40 = 27 NOT BULK

//;LAYER MAP  61  DATATYPE 45  12230
//;LAYER MAP  61  TEXTTYPE 45  12230
//;LAYER M1_45  12230  // Metal-1 for data type 45 (1.25xMy)
M1_45 = 28 NOT BULK

//;LAYER MAP  61  DATATYPE 50  12240
//;LAYER MAP  61  TEXTTYPE 50  12240
//;LAYER M1_50  12240  // Metal-1 for data type 50 (1.25xMn)
M1_50 = 29 NOT BULK

//;LAYER MAP  61  DATATYPE 55  12250
//;LAYER MAP  61  TEXTTYPE 55  12250
//;LAYER M1_55  12250  // Metal-1 for data type 55 (1.25xMn)
M1_55 = 30 NOT BULK

//;LAYER MAP  61  DATATYPE 60  12260
//;LAYER MAP  61  TEXTTYPE 60  12260
//;LAYER M1_60  12260  // Metal-1 for data type 60
M1_60 = 31 NOT BULK

//;LAYER MAP  61  DATATYPE 70  12270
//;LAYER MAP  61  TEXTTYPE 70  12270
//;LAYER M1_70  12270  // Metal-1 for data type 70
M1_70 = 32 NOT BULK

LAYER MAP  61  DATATYPE 110  12280
LAYER M1CA  12280  // Marking layer for M1 color A

LAYER MAP  61  DATATYPE 120  12290
LAYER M1CB  12290  // Marking layer for M1 color B

LAYER MAP  175  DATATYPE 0  12300
LAYER M1DP  12300  // Metal-1 Double Patterning 2nd Mask

LAYER MAP  175  DATATYPE 1  12310
LAYER M1DPDUM  12310  // M1DP Dummy Layer(For dummy via insertion)

LAYER MAP  175  DATATYPE 7  12320
LAYER M1DPDOP  12320  // M1DP dummy pattern layer is referenced in OPC engineering

LAYER MAP  62  DATATYPE 0  12330
LAYER MAP  62  TEXTTYPE 0  12330
LAYER M2i  12330  // Metal-2

LAYER MAP  62  DATATYPE 1  12340
LAYER M2DUM  12340  // Metal2 Dummy Layer

LAYER MAP  62  DATATYPE 7  12350
LAYER M2DOPi  12350  // Metal 2 Dummy pattern layer for OPC engineering

LAYER MAP  62  DATATYPE 20  12360
LAYER M2DPMK  12360  // M2 same color marker layer

//;LAYER MAP  62  DATATYPE 40  12370
//;LAYER MAP  62  TEXTTYPE 40  12370
//;LAYER M2_40  12370  // Metal-2 for data type 40 (1.25xMy)
M2_40 = 33 NOT BULK

//;LAYER MAP  62  DATATYPE 45  12380
//;LAYER MAP  62  TEXTTYPE 45  12380
//;LAYER M2_45  12380  // Metal-2 for data type 45 (1.25xMy)
M2_45 = 34 NOT BULK

//;LAYER MAP  62  DATATYPE 50  12390
//;LAYER MAP  62  TEXTTYPE 50  12390
//;LAYER M2_50  12390  // Metal-2 for data type 50 (1.25xMN)
M2_50 = 35 NOT BULK

//;LAYER MAP  62  DATATYPE 55  12400
//;LAYER MAP  62  TEXTTYPE 55  12400
//;LAYER M2_55  12400  // Metal-2 for data type 55 (1.25xMN)
M2_55 = 36 NOT BULK

//;LAYER MAP  62  DATATYPE 60  12410
//;LAYER MAP  62  TEXTTYPE 60  12410
//;LAYER M2_60  12410  // Metal-2 for data type 60
M2_60 = 37 NOT BULK

//;LAYER MAP  62  DATATYPE 70  12420
//;LAYER MAP  62  TEXTTYPE 70  12420
//;LAYER M2_70  12420  // Metal-2 for data type 70
M2_70 = 38 NOT BULK

LAYER MAP  62  DATATYPE 110  12430
LAYER M2CA  12430  // Marking layer for M2 color A

LAYER MAP  62  DATATYPE 120  12440
LAYER M2CB  12440  // Marking layer for M2 color B

LAYER MAP  176  DATATYPE 0  12450
LAYER M2DP  12450  // Metal-2 Double Patterning 2nd Mask

LAYER MAP  176  DATATYPE 1  12460
LAYER M2DPDUM  12460  // M2DP Dummy Layer(For dummy via insertion) (use for 20nm and advanced tech only)

LAYER MAP  176  DATATYPE 7  12470
LAYER M2DPDOP  12470  // M2DP dummy pattern layer is referenced in OPC engineering

LAYER MAP  63  DATATYPE 0  12480
LAYER MAP  63  TEXTTYPE 0  12480
LAYER M3i  12480  // Metal-3

LAYER MAP  63  DATATYPE 1  12490
LAYER M3DUM  12490  // Metal3 Dummy Layer

LAYER MAP  63  DATATYPE 7  12500
LAYER M3DOPi  12500  // Metal-3 Double Patterning 2nd Mask

LAYER MAP  63  DATATYPE 20  12510
LAYER M3DPMK  12510  // M3 same color marker layer

//;LAYER MAP  63  DATATYPE 40  12520
//;LAYER MAP  63  TEXTTYPE 40  12520
//;LAYER M3_40  12520  // Metal-3 for data type 40 (1.25xMy)
M3_40 = 39 NOT BULK

//;LAYER MAP  63  DATATYPE 45  12530
//;LAYER MAP  63  TEXTTYPE 45  12530
//;LAYER M3_45  12530  // Metal-3 for data type 45 (1.25xMy)
M3_45 = 40 NOT BULK

//;LAYER MAP  63  DATATYPE 50  12540
//;LAYER MAP  63  TEXTTYPE 50  12540
//;LAYER M3_50  12540  // Metal-3 for data type 50 (1.25xMN)
M3_50 = 41 NOT BULK

//;LAYER MAP  63  DATATYPE 55  12550
//;LAYER MAP  63  TEXTTYPE 55  12550
//;LAYER M3_55  12550  // Metal-3 for data type 55 (1.25xMN)
M3_55 = 42 NOT BULK

//;LAYER MAP  63  DATATYPE 60  12560
//;LAYER MAP  63  TEXTTYPE 60  12560
//;LAYER M3_60  12560  // Metal-3 for data type 60
M3_60 = 43 NOT BULK

//;LAYER MAP  63  DATATYPE 70  12570
//;LAYER MAP  63  TEXTTYPE 70  12570
//;LAYER M3_70  12570  // Metal-3 for data type 70
M3_70 = 44 NOT BULK

LAYER MAP  63  DATATYPE 110  12580
LAYER M3CA  12580  // Marking layer for M3 color A

LAYER MAP  63  DATATYPE 120  12590
LAYER M3CB  12590  // Marking layer for M3 color B

LAYER MAP  177  DATATYPE 0  12600
LAYER M3DP  12600  // Metal-3 Double Patterning 2nd Mask

LAYER MAP  177  DATATYPE 1  12610
LAYER M3DPDUM  12610  // M3DP Dummy Layer(For dummy via insertion) (use for 20nm and advanced tech only)

LAYER MAP  177  DATATYPE 7  12620
LAYER M3DPDOP  12620  // M3DP dummy pattern layer is referenced in OPC engineering

//;LAYER MAP  64  DATATYPE 0  12630
//;LAYER MAP  64  TEXTTYPE 0  12630
//;LAYER M4i  12630  // Metal-4
M4i = 381 NOT BULK

LAYER MAP  64  DATATYPE 1  12640
LAYER M4DUM  12640  // Metal4 Dummy Layer

LAYER MAP  64  DATATYPE 7  12650
LAYER M4DOPi  12650  // Metal 4 Dummy pattern layer for OPC engineering

LAYER MAP  64  DATATYPE 40  12670
LAYER MAP  64  TEXTTYPE 40  12670
LAYER M4_40  12670  // Metal-4 for data type 40 (1.25xMy)

//;LAYER MAP  64  DATATYPE 45  12680
//;LAYER MAP  64  TEXTTYPE 45  12680
//;LAYER M4_45  12680  // Metal-4 for data type 45 (1.25xMy)
M4_45 = 382 NOT BULK

//;LAYER MAP  64  DATATYPE 50  12690
//;LAYER MAP  64  TEXTTYPE 50  12690
//;LAYER M4_50  12690  // Metal-4 for data type 50 (1.25xMn)
M4_50 = 383 NOT BULK

//;LAYER MAP  64  DATATYPE 55  12700
//;LAYER MAP  64  TEXTTYPE 55  12700
//;LAYER M4_55  12700  // Metal-4 for data type 55 (1.25xMn)
M4_55 = 384 NOT BULK

//;LAYER MAP  64  DATATYPE 60  12710
//;LAYER MAP  64  TEXTTYPE 60  12710
//;LAYER M4_60  12710  // Metal-4 for data type 60
M4_60 = 45 NOT BULK

//;LAYER MAP  64  DATATYPE 70  12720
//;LAYER MAP  64  TEXTTYPE 70  12720
//;LAYER M4_70  12720  // Metal-4 for data type 70
M4_70 = 46 NOT BULK

//;LAYER MAP  64  DATATYPE 110  12730
//;LAYER M4CA  12730  // Marking layer for M4 color A
M4CA = 407 NOT BULK

//;LAYER MAP  64  DATATYPE 120  12740
//;LAYER M4CB  12740  // Marking layer for M4 color B
M4CB = 408 NOT BULK

//;LAYER MAP  178  DATATYPE 0  12750
//;LAYER M4DP  12750  // Metal-4 Double Patterning 2nd Mask
M4DP = 409 NOT BULK

//;LAYER MAP  178  DATATYPE 1  12760
//;LAYER M4DPDUM  12760  // M4DP Dummy Layer(For dummy via insertion) (use for 20nm and advanced tech only)
M4DPDUM = 410 NOT BULK

//;LAYER MAP  178  DATATYPE 7  12770
//;LAYER M4DPDOP  12770  // M4DP dummy pattern layer is referenced in OPC engineering
M4DPDOP = 411 NOT BULK

//;LAYER MAP  65  DATATYPE 0  62630
//;LAYER MAP  65  TEXTTYPE 0  62630
//;LAYER M5i  62630  // Metal-5
M5i = 385 NOT BULK

LAYER MAP  65  DATATYPE 1  62640
LAYER M5DUM  62640  // Metal5 Dummy Layer

LAYER MAP  65  DATATYPE 7  62650
LAYER M5DOPi  62650  // Metal 5 Dummy pattern layer for OPC engineering

//;LAYER MAP  65  DATATYPE 40  62670
//;LAYER MAP  65  TEXTTYPE 40  62670
//;LAYER M5_40  62670  // Metal-5 for data type 40 (1.25xMy)
M5_40 = 386 NOT BULK

//;LAYER MAP  65  DATATYPE 45  62680
//;LAYER MAP  65  TEXTTYPE 45  62680
//;LAYER M5_45  62680  // Metal-5 for data type 45 (1.25xMy)
M5_45 = 387 NOT BULK

//;LAYER MAP  65  DATATYPE 50  62690
//;LAYER MAP  65  TEXTTYPE 50  62690
//;LAYER M5_50  62690  // Metal-5 for data type 50 (1.25xMn)
M5_50 = 388 NOT BULK

LAYER MAP  65  DATATYPE 55  62700
LAYER MAP  65  TEXTTYPE 55  62700
LAYER M5_55  62700  // Metal-5 for data type 55 (1.25xMn)

//;LAYER MAP  65  DATATYPE 60  62710
//;LAYER MAP  65  TEXTTYPE 60  62710
//;LAYER M5_60  62710  // Metal-5 for data type 60
M5_60 = 47 NOT BULK

//;LAYER MAP  65  DATATYPE 70  62720
//;LAYER MAP  65  TEXTTYPE 70  62720
//;LAYER M5_70  62720  // Metal-5 for data type 70
M5_70 = 48 NOT BULK

//;LAYER MAP  66  DATATYPE 0  12780
//;LAYER MAP  66  TEXTTYPE 0  12780
//;LAYER M6i  12780  // Metal-6
M6i = 389 NOT BULK

LAYER MAP  66  DATATYPE 1  12790
LAYER M6DUM  12790  // Metal6 Dummy Layer

LAYER MAP  66  DATATYPE 7  12800
LAYER M6DOPi  12800  // Metal 6 Dummy pattern layer for OPC engineering

//;LAYER MAP  66  DATATYPE 40  12810
//;LAYER MAP  66  TEXTTYPE 40  12810
//;LAYER M6_40  12810  // Metal-6 for data type 40 (1.25xMy)
M6_40 = 390 NOT BULK

//;LAYER MAP  66  DATATYPE 45  12820
//;LAYER MAP  66  TEXTTYPE 45  12820
//;LAYER M6_45  12820  // Metal-6 for data type 45 (1.25xMy)
M6_45 = 391 NOT BULK

LAYER MAP  66  DATATYPE 50  12830
LAYER MAP  66  TEXTTYPE 50  12830
LAYER M6_50  12830  // Metal-6 for data type 50 (1.25xMn)

//;LAYER MAP  66  DATATYPE 55  12840
//;LAYER MAP  66  TEXTTYPE 55  12840
//;LAYER M6_55  12840  // Metal-6 for data type 55 (1.25xMn)
M6_55 = 392 NOT BULK

//;LAYER MAP  66  DATATYPE 60  12850
//;LAYER MAP  66  TEXTTYPE 60  12850
//;LAYER M6_60  12850  // Metal-6 for data type 60
M6_60 = 49 NOT BULK

//;LAYER MAP  66  DATATYPE 70  12860
//;LAYER MAP  66  TEXTTYPE 70  12860
//;LAYER M6_70  12860  // Metal-6 for data type 70
M6_70 = 50 NOT BULK

//;LAYER MAP  67  DATATYPE 0  12870
//;LAYER MAP  67  TEXTTYPE 0  12870
//;LAYER M7i  12870  // Metal-7
M7i = 393 NOT BULK

LAYER MAP  67  DATATYPE 1  12880
LAYER M7DUM  12880  // Metal7 Dummy Layer

LAYER MAP  67  DATATYPE 7  12890
LAYER M7DOPi  12890  // Metal 7 Dummy pattern layer for OPC engineering

//;LAYER MAP  67  DATATYPE 40  12910
//;LAYER MAP  67  TEXTTYPE 40  12910
//;LAYER M7_40  12910  // Metal-7 for data type 40 (1.25xMy)
M7_40 = 394 NOT BULK

//;LAYER MAP  67  DATATYPE 45  12920
//;LAYER MAP  67  TEXTTYPE 45  12920
//;LAYER M7_45  12920  // Metal-7 for data type 45 (1.25xMy)
M7_45 = 395 NOT BULK

//;LAYER MAP  67  DATATYPE 50  12930
//;LAYER MAP  67  TEXTTYPE 50  12930
//;LAYER M7_50  12930  // Metal-7 for data type 50 (1.25xMn)
M7_50 = 396 NOT BULK

LAYER MAP  67  DATATYPE 55  12940
LAYER MAP  67  TEXTTYPE 55  12940
LAYER M7_55  12940  // Metal-7 for data type 55 (1.25xMn)

//;LAYER MAP  67  DATATYPE 60  12950
//;LAYER MAP  67  TEXTTYPE 60  12950
//;LAYER M7_60  12950  // Metal-7 for data type 60
M7_60 = 51 NOT BULK

//;LAYER MAP  67  DATATYPE 70  12960
//;LAYER MAP  67  TEXTTYPE 70  12960
//;LAYER M7_70  12960  // Metal-7 for data type 70
M7_70 = 52 NOT BULK

//;LAYER MAP  68  DATATYPE 0  12970
//;LAYER MAP  68  TEXTTYPE 0  12970
//;LAYER M8i  12970  // Metal-8
M8i = 397 NOT BULK

LAYER MAP  68  DATATYPE 1  12980
LAYER M8DUM  12980  // Metal8 Dummy Layer

LAYER MAP  68  DATATYPE 7  12990
LAYER M8DOPi  12990  // Metal 8 Dummy pattern layer for OPC engineering

//;LAYER MAP  68  DATATYPE 40  13010
//;LAYER MAP  68  TEXTTYPE 40  13010
//;LAYER M8_40  13010  // Metal-8 for data type 40 (1.25xMy)
M8_40 = 398 NOT BULK

//;LAYER MAP  68  DATATYPE 45  13020
//;LAYER MAP  68  TEXTTYPE 45  13020
//;LAYER M8_45  13020  // Metal-8 for data type 45 (1.25xMy)
M8_45 = 399 NOT BULK

LAYER MAP  68  DATATYPE 50  13030
LAYER MAP  68  TEXTTYPE 50  13030
LAYER M8_50  13030  // Metal-8 for data type 50 (1.25xMn)

//;LAYER MAP  68  DATATYPE 55  13040
//;LAYER MAP  68  TEXTTYPE 55  13040
//;LAYER M8_55  13040  // Metal-8 for data type 55 (1.25xMn)
M8_55 = 400 NOT BULK

//;LAYER MAP  68  DATATYPE 60  13050
//;LAYER MAP  68  TEXTTYPE 60  13050
//;LAYER M8_60  13050  // Metal-8 for data type 60
M8_60 = 53 NOT BULK

//;LAYER MAP  68  DATATYPE 70  13060
//;LAYER MAP  68  TEXTTYPE 70  13060
//;LAYER M8_70  13060  // Metal-8 for data type 70
M8_70 = 54 NOT BULK

//;LAYER MAP  69  DATATYPE 0  13070
//;LAYER MAP  69  TEXTTYPE 0  13070
//;LAYER M9i  13070  // Metal-9
M9i = 55 NOT BULK

//;LAYER MAP  69  DATATYPE 1  13080
//;LAYER M9DUM  13080  // Metal9 Dummy Layer
M9DUM = 56 NOT BULK

//;LAYER MAP  69  DATATYPE 7  13090
//;LAYER M9DOPi  13090  // Metal 9 Dummy pattern layer for OPC engineering
M9DOPi = 57 NOT BULK

//;LAYER MAP  69  DATATYPE 40  13110
//;LAYER MAP  69  TEXTTYPE 40  13110
//;LAYER M9_40  13110  // Metal-9 for data type 40 (1.25xMy)
M9_40 = 58 NOT BULK

//;LAYER MAP  69  DATATYPE 45  13120
//;LAYER MAP  69  TEXTTYPE 45  13120
//;LAYER M9_45  13120  // Metal-9 for data type 45 (1.25xMy)
M9_45 = 59 NOT BULK

//;LAYER MAP  69  DATATYPE 50  13130
//;LAYER MAP  69  TEXTTYPE 50  13130
//;LAYER M9_50  13130  // Metal-9 for data type 50 (1.25xMn)
M9_50 = 60 NOT BULK

//;LAYER MAP  69  DATATYPE 55  13140
//;LAYER MAP  69  TEXTTYPE 55  13140
//;LAYER M9_55  13140  // Metal-9 for data type 55 (1.25xMn)
M9_55 = 61 NOT BULK

//;LAYER MAP  69  DATATYPE 60  13150
//;LAYER MAP  69  TEXTTYPE 60  13150
//;LAYER M9_60  13150  // Metal-9 for data type 60
M9_60 = 62 NOT BULK

//;LAYER MAP  69  DATATYPE 70  13160
//;LAYER MAP  69  TEXTTYPE 70  13160
//;LAYER M9_70  13160  // Metal-9 for data type 70
M9_70 = 63 NOT BULK

LAYER MAP  120  DATATYPE 0  13210
LAYER MAP  120  TEXTTYPE 0  13210
LAYER TM1i  13210  // Top Metal 1

LAYER MAP  120  DATATYPE 1  13220
LAYER TM1DUM  13220  // TM1 Dummy Layer

LAYER MAP  120  DATATYPE 40  13230
LAYER MAP  120  TEXTTYPE 40  13230
LAYER TM1_40  13230  // First Top Metal for data type 40 (14xTM1)

LAYER MAP  122  DATATYPE 0  13240
LAYER MAP  122  TEXTTYPE 0  13240
LAYER TM2i  13240  // Top Metal 2

LAYER MAP  122  DATATYPE 1  13250
LAYER TM2DUM  13250  // TM2 Dummy Layer

LAYER MAP  122  DATATYPE 40  13260
LAYER MAP  122  TEXTTYPE 40  13260
LAYER TM2_40  13260  // Second Top Metal for data type 40 (14xTM2)

LAYER MAP  150  DATATYPE 0  13270
LAYER MAP  150  TEXTTYPE 0  13270
LAYER UTM  13270  // Ultra Thick Metal

LAYER MAP  150  DATATYPE 1  13280
LAYER UTMDUM  13280  // UTM Dummy Layer (For dummy metal insertion)

LAYER MAP  150  DATATYPE 2  13290
LAYER UTMSLOT  13290  // UTM Slot

LAYER MAP  150  DATATYPE 7  13300
LAYER UTMDOPi  13300  // UTM Dummy pattern layer is referenced in OPC engineering

LAYER MAP  159  DATATYPE 1  13310
LAYER BIPOLA  13310  // Placed over PNP emitters. It is used to generate PH and eliminate halos to improve bipolar performance

LAYER MAP  211  DATATYPE 1  13320
LAYER MOMDMY  13320  // MOM Dummy layer

LAYER MAP  81  DATATYPE 3  13330
LAYER MTFUSE  13330  // Marking layer for metal fuse function area

LAYER MAP  91  DATATYPE 4  13340
LAYER OCCD  13340  // On chip CD mark layer

LAYER MAP  91  DATATYPE 5  13350
LAYER OCOVL  13350  // On chip overlay mark layer

LAYER MAP  89  DATATYPE 160  13360
LAYER OTPMK1  13360  // OTP type 1 mark

LAYER MAP  80  DATATYPE 0  13370
LAYER PA  13370  // Passivation 1

LAYER MAP  83  DATATYPE 0  13380
LAYER MAP  83  TEXTTYPE 0  13380
LAYER ALPA  13380  // AL Bonding Pad and RDL

LAYER MAP  83  DATATYPE 11  13400
LAYER ALDUM  13400  // ALPA Dummy Layer

LAYER MAP  130  DATATYPE 0  13410
LAYER MD  13410  // Passivation 2 opening

LAYER MAP  165  DATATYPE 0  13420
LAYER BCB1  13420  // Repassivation for bump process

LAYER MAP  168  DATATYPE 0  13430
LAYER BUMP  13430  // UBM for bump

LAYER MAP  83  DATATYPE 6  13440
LAYER ALDUB  13440  // ALPA Dummy block layer for ALPA dummy fill

LAYER MAP  83  DATATYPE 1  13450
LAYER ALPAR  13450  // LVS marker layer for ALPA Resistor

LAYER MAP  83  DATATYPE 2  13451
LAYER MAP  83  TEXTTYPE 2  13451
LAYER ALPATXTi  13451  // ALPA Text Layer，label text

LAYER MAP  127  DATATYPE 0  13460
LAYER BORDER  13460  // Marking layer for chip edge

LAYER MAP  97  DATATYPE 3  13480
LAYER DIFRES  13480  // LVS mark layer for AA resistor extraction

LAYER MAP  131  DATATYPE 161  13490
LAYER DIOMK1  13490  // STI bounded diode recognized layer

LAYER MAP  131  DATATYPE 162  13500
LAYER DIOMK2  13500  // Poly bounded diode recognized layer

LAYER MAP  19  DATATYPE 2  13510
LAYER DNWTR  13510  // LVS mark layer for DNW MOS and parasitic diode extraction

LAYER MAP  191  DATATYPE 3  13520
LAYER DTDMY  13520  // Marker layer for different net AA

LAYER MAP  91  DATATYPE 0  13530
LAYER DUMBA  13530  // Block Layer for Dummy operation on AA

LAYER MAP  92  DATATYPE 0  13540
LAYER DUMBP  13540  // Block Layer for Dummy operation on GT

LAYER MAP  89  DATATYPE 156  13550
LAYER DUPMK1  13550  // Marking layer for DUP(pad with device underneath)

LAYER MAP  133  DATATYPE 0  13560
LAYER ESDIO1  13560  // Dummy layer for SMIC Internal ESD devices and protection circuits

LAYER MAP  133  DATATYPE 3  13570
LAYER ESDIO2  13570  // DRC marking layer for I/O ESD protection devices and circuits identification

LAYER MAP  13  DATATYPE 20  13580
LAYER FINAA  13580  // Fin after Fin cut

LAYER MAP  81  DATATYPE 4  13590
LAYER FUSEAD  13590  // Marking layer for fuse anode side

LAYER MAP  81  DATATYPE 152  13600
LAYER FUSEMK1  13600  // Marking layer for fuse bitcell

LAYER MAP  34  DATATYPE 239  13610
LAYER HRBL  13610  // Marking layer for blocking poly resistor implant and poly N+ doping

LAYER MAP  183  DATATYPE 0  13620
LAYER JVARDUM  13620  // Junction Varactor recognition for DRC/LVS

LAYER MAP  26  DATATYPE 0  13630
LAYER LOGO  13630  // LOGO,L mark area

LAYER MAP  190  DATATYPE 0  13640
LAYER MARKF  13640  // Fuse area mark for Fuse DRC check

LAYER MAP  189  DATATYPE 0  13650
LAYER MARKG  13650  // Guard ring mark for DRC check

LAYER MAP  189  DATATYPE 151  13660
LAYER MARKS  13660  // Seal ring (chip level) marking layer for DRC and dummy auto-filling blockage

LAYER MAP  211  DATATYPE 5  13670
LAYER MOMMES  13670  // MOM capacitor mesh LVS marking layer

LAYER MAP  211  DATATYPE 3  13680
LAYER MOMP1  13680  // MOM capacitor mesh terminal one

LAYER MAP  211  DATATYPE 4  13690
LAYER MOMP2  13690  // MOM capacitor mesh terminal one

LAYER MAP  211  DATATYPE 2  13700
LAYER MOMTEM  13700  // LVS mark layer for MOM terminal

LAYER MAP  131  DATATYPE 2  13710
LAYER MOSCKT  13710  // LVS dummy layer to distinguish bsim mos and subckt mos

LAYER MAP  93  DATATYPE 1  13720
LAYER NCAP  13720  // Mark layer for NFET in n-well capacitors

LAYER MAP  131  DATATYPE 5  13730
LAYER NFDMK  13730  // LVS marking layer for mos multiple fingers

LAYER MAP  180  DATATYPE 0  13740
LAYER NODMF  13740  // Area not to add AA/GT/Metal dummies

LAYER MAP  93  DATATYPE 2  13760
LAYER PCAP  13760  // Mark layer for PFET in p-well capacitors

LAYER MAP  131  DATATYPE 4  13770
LAYER PLDMK  13770  // LVS marking layer for device dummy poly

LAYER MAP  133  DATATYPE 2  13780
LAYER POWRING  13780  // DRC dummy layer for power ring identification

LAYER MAP  131  DATATYPE 3  13790
LAYER RESCKT  13790  // LVS dummy layer for subckt resistor

LAYER MAP  96  DATATYPE 1  13800
LAYER RESP3T  13800  // LVS Dummy layer for Poly-1 Resistor with 3 terminal

LAYER MAP  183  DATATYPE 2  13810
LAYER RF3T  13810  // DRC/LVS mark layer for RF 3 terminal devices and 3 terminal MOM

LAYER MAP  181  DATATYPE 4  13820
LAYER RFDN6T  13820  // 6-terminal RF MOS in deep NWELL for LVS,the sixth terminal is psub.

LAYER MAP  181  DATATYPE 6  13830
LAYER RFMK1  13830  // Marking layer for RF device

LAYER MAP  181  DATATYPE 3  13833
LAYER RFSD  13833  // RF MOS of even finger with S/D permute for LVS

LAYER MAP  211  DATATYPE 6  13835
LAYER RFMOM  13835  // LVS mark layer for RF MOM

LAYER MAP  182  DATATYPE 0  13840
LAYER RFMOSD  13840  // LVS mark layer for RF MOM

LAYER MAP  99  DATATYPE 0  13850
LAYER SDOP  13850  // SRAM pass gate mark layer

LAYER MAP  131  DATATYPE 1  13860
LAYER SUBD  13860  // Substrate Dummy Layer

LAYER MAP  94  DATATYPE 0  13880
LAYER VARJUN  13880  // LVS mark Layer to cover all Junction type varactor

//;LAYER MAP  159  DATATYPE 6  13890
//;LAYER ZVT  13890  // Marking layer for core zero VT native device

LAYER MAP  89  DATATYPE 16  13900
LAYER M1V12i  13900  // DRC and LVS marking layer for 1.2V M1

LAYER MAP  89  DATATYPE 17  13910
LAYER M1V15i  13910  // DRC and LVS marking layer for 1.5V M1

LAYER MAP  89  DATATYPE 11  13920
LAYER M1V18i  13920  // DRC and LVS marking layer for 1.8V M1

LAYER MAP  89  DATATYPE 12  13930
LAYER M1V25i  13930  // DRC and LVS marking layer for 2.5V M1

LAYER MAP  89  DATATYPE 13  13940
LAYER M1V33i  13940  // DRC and LVS marking layer for 3.3V M1

LAYER MAP  89  DATATYPE 15  13950
LAYER M1V50i  13950  // DRC and LVS marking layer for 5V M1

LAYER MAP  89  DATATYPE 26  13960
LAYER M2V12i  13960  // DRC and LVS marking layer for 1.2V M2

LAYER MAP  89  DATATYPE 27  13970
LAYER M2V15i  13970

LAYER MAP  89  DATATYPE 21  13980
LAYER M2V18i  13980

LAYER MAP  89  DATATYPE 22  13990
LAYER M2V25i  13990

LAYER MAP  89  DATATYPE 23  14000
LAYER M2V33i  14000

LAYER MAP  89  DATATYPE 25  14010
LAYER M2V50i  14010

LAYER MAP  89  DATATYPE 36  14020
LAYER M3V12i  14020  // DRC and LVS marking layer for 1.2V M3

LAYER MAP  89  DATATYPE 37  14030
LAYER M3V15i  14030

LAYER MAP  89  DATATYPE 31  14040
LAYER M3V18i  14040

LAYER MAP  89  DATATYPE 32  14050
LAYER M3V25i  14050

LAYER MAP  89  DATATYPE 33  14060
LAYER M3V33i  14060

LAYER MAP  89  DATATYPE 35  14070
LAYER M3V50i  14070

LAYER MAP  89  DATATYPE 46  14080
LAYER M4V12i  14080  // DRC and LVS marking layer for 1.2V M4

LAYER MAP  89  DATATYPE 47  14090
LAYER M4V15i  14090

LAYER MAP  89  DATATYPE 41  14100
LAYER M4V18i  14100

LAYER MAP  89  DATATYPE 42  14110
LAYER M4V25i  14110

LAYER MAP  89  DATATYPE 43  14120
LAYER M4V33i  14120

LAYER MAP  89  DATATYPE 45  14130
LAYER M4V50i  14130

LAYER MAP  89  DATATYPE 56  14140
LAYER M5V12i  14140  // DRC and LVS marking layer for 1.2V M5

LAYER MAP  89  DATATYPE 57  14150
LAYER M5V15i  14150

LAYER MAP  89  DATATYPE 51  14160
LAYER M5V18i  14160

LAYER MAP  89  DATATYPE 52  14170
LAYER M5V25i  14170

LAYER MAP  89  DATATYPE 53  14180
LAYER M5V33i  14180

LAYER MAP  89  DATATYPE 55  14190
LAYER M5V50i  14190

LAYER MAP  89  DATATYPE 66  14200
LAYER M6V12i  14200  // DRC and LVS marking layer for 1.2V M6

LAYER MAP  89  DATATYPE 67  14210
LAYER M6V15i  14210

LAYER MAP  89  DATATYPE 61  14220
LAYER M6V18i  14220

LAYER MAP  89  DATATYPE 62  14230
LAYER M6V25i  14230

LAYER MAP  89  DATATYPE 63  14240
LAYER M6V33i  14240

LAYER MAP  89  DATATYPE 65  14250
LAYER M6V50i  14250

LAYER MAP  89  DATATYPE 76  14300
LAYER M7V12i  14300  // DRC and LVS marking layer for 1.2V M7

LAYER MAP  89  DATATYPE 77  14310
LAYER M7V15i  14310

LAYER MAP  89  DATATYPE 71  14320
LAYER M7V18i  14320

LAYER MAP  89  DATATYPE 72  14330
LAYER M7V25i  14330

LAYER MAP  89  DATATYPE 73  14340
LAYER M7V33i  14340

LAYER MAP  89  DATATYPE 75  14350
LAYER M7V50i  14350

LAYER MAP  89  DATATYPE 86  14400
LAYER M8V12i  14400  // DRC and LVS marking layer for 1.2V M8

LAYER MAP  89  DATATYPE 87  14410
LAYER M8V15i  14410  // DRC and LVS marking layer for 1.5V M8

LAYER MAP  89  DATATYPE 81  14420
LAYER M8V18i  14420  // DRC and LVS marking layer for 1.8V M8

LAYER MAP  89  DATATYPE 82  14430
LAYER M8V25i  14430  // DRC and LVS marking layer for 2.5V M8

LAYER MAP  89  DATATYPE 83  14440
LAYER M8V33i  14440  // DRC and LVS marking layer for 3.3V M8

LAYER MAP  89  DATATYPE 85  14450
LAYER M8V50i  14450  // DRC and LVS marking layer for 5V M8

LAYER MAP  151  DATATYPE 0  14460
LAYER M1B  14460  // Metal-1 Blockage Layer(For Place & Route use)

LAYER MAP  152  DATATYPE 0  14470
LAYER M2B  14470  // Metal-2 Blockage Layer(For Place & Route use)

LAYER MAP  153  DATATYPE 0  14480
LAYER M3B  14480  // Metal-3 Blockage Layer(For Place & Route use)

LAYER MAP  154  DATATYPE 0  14490
LAYER M4B  14490  // Metal-4 Blockage Layer(For Place & Route use)

LAYER MAP  155  DATATYPE 0  14500
LAYER M5B  14500  // Metal-5 Blockage Layer(For Place & Route use)

LAYER MAP  156  DATATYPE 0  14510
LAYER M6B  14510  // Metal-6 Blockage Layer(For Place & Route use)

LAYER MAP  157  DATATYPE 0  14520
LAYER M7B  14520  // Metal-7 Blockage Layer(For Place & Route use)

LAYER MAP  158  DATATYPE 0  14530
LAYER M8B  14530  // Metal-8 Blockage Layer(For Place & Route use)

//;LAYER MAP  158  DATATYPE 50  14540
//;LAYER M9B  14540  // Metal-9 Blockage Layer(For Place & Route use)
M9B = 64 NOT BULK

LAYER MAP  193  DATATYPE 0  14560
LAYER TM1B  14560  // TM1 Blockage Layer(For Place & Route use)

LAYER MAP  194  DATATYPE 0  14570
LAYER TM2B  14570  // TM2 Blockage Layer(For Place & Route use)

LAYER MAP  181  DATATYPE 158  14580
LAYER UTMB  14580  // UTM Blockage Layer(For Place & Route use)

LAYER MAP  59  DATATYPE 6  14590
LAYER M0DUB  14590  // M0 Dummy Blockage (For dummy M0 insertion) and exclude dummy insertion

LAYER MAP  246  DATATYPE 6  14600
LAYER M0CDUB  14600  // M0C Dummy Blockage (For dummy metal insertion) and exclude dummy insertion

LAYER MAP  208  DATATYPE 6  14610
LAYER M0GDUB  14610  // M0G Dummy Blockage (For dummy M0G insertion) and exclude dummy insertion

LAYER MAP  31  DATATYPE 6  14620
LAYER P2DUB  14620  // P2 Dummy Blockage (For dummy metal insertion) and exclude dummy insertion

LAYER MAP  245  DATATYPE 6  14630
LAYER V0DUB  14630  // Via-0 Dummy Blockage

LAYER MAP  70  DATATYPE 6  14710
LAYER V1DUB  14710  // Via-1 Dummy Blockage

LAYER MAP  71  DATATYPE 6  14720
LAYER V2DUB  14720  // Via-2 Dummy Blockage

LAYER MAP  72  DATATYPE 6  14730
LAYER V3DUB  14730  // Via-3 Dummy Blockage

LAYER MAP  73  DATATYPE 6  14740
LAYER V4DUB  14740  // Via-4 Dummy Blockage

LAYER MAP  74  DATATYPE 6  14750
LAYER V5DUB  14750  // Via-5 Dummy Blockage

LAYER MAP  75  DATATYPE 6  14760
LAYER V6DUB  14760  // Via-6 Dummy Blockage

LAYER MAP  76  DATATYPE 6  14770
LAYER V7DUB  14770  // Via-7 Dummy Blockage

//;LAYER MAP  77  DATATYPE 6  14780
//;LAYER V8DUB  14780  // Via-8 Dummy Blockage
V8DUB = 65 NOT BULK

LAYER MAP  151  DATATYPE 1  14810
LAYER M1DUB  14810  // Metal-1 Dummy Block layer for M1 dummy fill

LAYER MAP  152  DATATYPE 1  15820
LAYER M2DUB  15820  // Metal-2 Dummy Block layer for M2 dummy fill

LAYER MAP  153  DATATYPE 1  14830
LAYER M3DUB  14830  // Metal-3 Dummy Block layer for M3 dummy fill

LAYER MAP  154  DATATYPE 1  14840
LAYER M4DUB  14840  // Metal-4 Dummy Block layer for M4 dummy fill

LAYER MAP  155  DATATYPE 1  14850
LAYER M5DUB  14850  // Metal-5 Dummy Block layer for M5 dummy fill

LAYER MAP  156  DATATYPE 1  14860
LAYER M6DUB  14860  // Metal-6 Dummy Block layer for M6 dummy fill

LAYER MAP  157  DATATYPE 1  14870
LAYER M7DUB  14870  // Metal-7 Dummy Block layer for M7 dummy fill

LAYER MAP  158  DATATYPE 1  14880
LAYER M8DUB  14880  // Metal-8 Dummy Block layer for M8 dummy fill

//;LAYER MAP  158  DATATYPE 51  14890
//;LAYER M9DUB  14890  // Metal-9 Dummy Block layer for M9 dummy fill
M9DUB = 66 NOT BULK

LAYER MAP  193  DATATYPE 1  14920
LAYER TM1DUB  14920  // Top Metal 1 Dummy Block layer for TM1 dummy fill

LAYER MAP  194  DATATYPE 1  14930
LAYER TM2DUB  14930  // Top Metal 2 Dummy Block layer for TM2 dummy fill

LAYER MAP  150  DATATYPE 6  14940
LAYER UTMDUB  14940  // UTM Dummy Blockage (For dummy metal insertion) and exclude dummy insertion

LAYER MAP  181  DATATYPE 161  14950
LAYER M1R  14950  // Metal-1 Resistor

LAYER MAP  181  DATATYPE 162  14960
LAYER M2R  14960  // Metal-2 Resistor

LAYER MAP  181  DATATYPE 163  14970
LAYER M3R  14970  // Metal-3 Resistor

LAYER MAP  181  DATATYPE 164  14980
LAYER M4R  14980  // Metal-4 Resistor

LAYER MAP  181  DATATYPE 165  14990
LAYER M5R  14990  // Metal-5 Resistor

LAYER MAP  181  DATATYPE 166  15000
LAYER M6R  15000  // Metal-6 Resistor

LAYER MAP  181  DATATYPE 167  15010
LAYER M7R  15010  // Metal-7 Resistor

LAYER MAP  181  DATATYPE 168  15020
LAYER M8R  15020  // Metal-8 Resistor

//;LAYER MAP  181  DATATYPE 169  15030
//;LAYER M9R  15030  // Metal-9 Resistor
M9R = 67 NOT BULK

LAYER MAP  201  DATATYPE 0  15050
LAYER TM1R  15050  // TM1 resistor layer

LAYER MAP  202  DATATYPE 0  15060
LAYER TM2R  15060  // TM2 resistor layer

LAYER MAP  194  DATATYPE 157  15070
LAYER UTMR  15070  // UTM Resistor

LAYER MAP  60  DATATYPE 0  15080
LAYER INST  15080  // Marker shape of SRAM bitcell, edge cell, strap cell or Instance Outline

LAYER MAP  60  DATATYPE  10  15110
LAYER U2SRAM  15110  // Marker shape of new type A SRAM cell

LAYER MAP  60  DATATYPE  5  15120
LAYER LRSRAM  15120  // Marker shape of HPSP 6T SRAM cell

LAYER MAP  60  DATATYPE  3  15130
LAYER UDSRAM  15130  // Marker shape of HDSP 6T type B SRAM cell

LAYER MAP  60  DATATYPE  1  15140
LAYER STSRAM  15140  // Marker shape of HDSP 6T type A SRAM cell

LAYER MAP  60  DATATYPE  11  15150
LAYER D2SRAM  15150  // Marker shape of HDDP 8T SRAM cell

LAYER MAP  60  DATATYPE  2  15160
LAYER DNSRAM  15160  // Marker shape of HCSP 6T SRAM cell

LAYER MAP  60  DATATYPE  4  15170
LAYER DPSRAM  15170  // Marker shape of HCDP 8T SRAM cell

//;LAYER MAP  60  DATATYPE  150  15180
//;LAYER HPBL 15180  // Marker shape of 8T2P4FIN type B SRAM cell

//;LAYER MAP  60  DATATYPE  14  15190
//;LAYER SRAMR1  15190  // Marker shape of 8T2P4FIN type A SRAM cell

//;LAYER MAP  60  DATATYPE  13  15200
//;LAYER TSSRAM  15200  // Marker shape of 8T2P3FIN SRAM cell

//;LAYER MAP  60  DATATYPE  12  15210
//;LAYER 2PSRAM  15210  // Marker shape of 8T2P2FIN SRAM cell

LAYER MAP  60  DATATYPE  151  15220
LAYER 6TMK  15220  // Marker shape of 6T in 8T or 10T SRAM cell

//;LAYER MAP  60  DATATYPE  9  15230
//;LAYER RFSRAM  15230  // Marker shape of 10T SRAM cell

//;LAYER MAP  131  DATATYPE  170  15240
//;LAYER LDNMK1  15240  // Marking layer of metal low density area
LDNMK1 = 68 NOT BULK

LAYER MAP  89  DATATYPE  154  15250
LAYER GTMK1i  15250  // Marking layer of edge gate 1

LAYER MAP  89  DATATYPE  168  15260
LAYER GTMK2i  15260  // Marking layer of edge gate 2

LAYER MAP  127  DATATYPE  4  15270
LAYER DMCB1  15270  // Dummy cell boundary for type 1

LAYER MAP  127  DATATYPE  5  15280
LAYER DMCB2  15280  // Dummy cell boundary for type 2

LAYER MAP  131  DATATYPE  181  15290
LAYER DMC1  15290  // Dummy cell for type 1

LAYER MAP  131  DATATYPE  182  15300
LAYER DMC2  15300  // Dummy cell for type 2

LAYER MAP  131  DATATYPE  183  15310
LAYER DMC3  15310  // Dummy cell for type 3

LAYER MAP  131  DATATYPE  184  15320
LAYER DMC4  15320  // Dummy cell for type 4

LAYER MAP  131  DATATYPE  185  15330
LAYER DMC5  15330  // Dummy cell for type 5

LAYER MAP  131  DATATYPE  186  15340
LAYER DMC6  15340  // Dummy cell for type 6

LAYER MAP  131  DATATYPE  187  15350
LAYER DMC7  15350  // Dummy cell for type 7

LAYER MAP  131  DATATYPE  188  15360
LAYER DMC8  15360  // Dummy cell for type 8

LAYER MAP  131  DATATYPE  189  15370
LAYER DMC9  15370  // Dummy cell for type 9

LAYER MAP  131  DATATYPE  190  15380
LAYER DMC10  15380  // Dummy cell for type 10

LAYER MAP  131  DATATYPE  191  15390
LAYER DMC11  15390  // Dummy cell for type 11

LAYER MAP  131  DATATYPE  192  15400
LAYER DMC12  15400  // Dummy cell for type 12

LAYER MAP  131  DATATYPE  193  15410
LAYER DMC13  15410  // Dummy cell for type 13

LAYER MAP  131  DATATYPE  194  15420
LAYER DMC14  15420  // Dummy cell for type 14

LAYER MAP  131  DATATYPE  195  15430
LAYER DMC15  15430  // Dummy cell for type 15

LAYER MAP  131  DATATYPE  196  15440
LAYER DMC16  15440  // Dummy cell for type 16

LAYER MAP  131  DATATYPE  197  15450
LAYER DMC17  15450  // Dummy cell for type 17

LAYER MAP  131  DATATYPE  198  15460
LAYER DMC18  15460  // Dummy cell for type 18

LAYER MAP  131  DATATYPE  199  15470
LAYER DMC19  15470  // Dummy cell for type 19

LAYER MAP  131  DATATYPE  200  15480
LAYER DMC20  15480  // Dummy cell for type 20

LAYER MAP  60  DATATYPE 15  15660
LAYER SRAMR2  15660  // Marker shape to allow LVS to identity 14nm 2PSRAM D138 A-type

//;LAYER MAP  60  DATATYPE 16  15670
//;LAYER SRAMR3  15670  // Marker shape to allow LVS to identity 14nm 2PSRAM D138 B-type

//;LAYER MAP  60  DATATYPE 17  15680
//;LAYER SRAMR4  15680  // Marker shape to allow LVS to identity 14nm SPSRAM D0645

//;LAYER MAP  60  DATATYPE 18  15690
//;LAYER SRAMR5  15690  // Marker shape to allow LVS to identity 14nm SPSRAM D0806

//;LAYER MAP  60  DATATYPE 19  15700
//;LAYER SRAMR6  15700  // Marker shape to allow LVS to identity 14nm DPSRAM D186

//;LAYER MAP  60  DATATYPE 20  15710
//;LAYER SRAMR7  15710  // Marker shape to allow LVS to identity 14nm 2PSRAM D137 A-type

//;LAYER MAP  60  DATATYPE 21  15720
//;LAYER SRAMR8  15720  // Marker shape to allow LVS to identity 14nm 2PSRAM D137 B-type

LAYER MAP  131  DATATYPE 30  16000
LAYER AR_Hi  16000  // AA cut layer 1

//;LAYER MAP  18  DATATYPE 0  16001
//;LAYER AR_H_c  16001  // AA cut layer 1

LAYER MAP  131  DATATYPE 31  16020
LAYER AR_Vi  16020  // AA cut layer 2

//;LAYER MAP  22  DATATYPE 0  16021
//;LAYER AR_V_c  16021  // AA cut layer 2

LAYER MAP  131  DATATYPE 151  16040
LAYER ARBL  16040  // Blocking Layer for AR_H, AR_V generation

LAYER MAP  135  DATATYPE 0  16050
LAYER BV1i  16050  // First 2X Via Hole (Only for 20nm and advanced technology)

LAYER MAP  135  DATATYPE 1  16060
LAYER BV1DUM  16060  // BV1 Dummy Layer(For dummy via insertion)

LAYER MAP  135  DATATYPE 7  16070
LAYER BV1DOP 16070  // BV1 Dummy pattern layer is referenced in OPC engineering

LAYER MAP  135  DATATYPE 8  16080
LAYER BV1RB  16080  // BV1 blockage layer to skip redundant via insertion

LAYER MAP  135  DATATYPE 10  16090
LAYER BV1RM  16090  // BV1 marker layer to identify redundant via

LAYER MAP  136  DATATYPE 0  16100
LAYER BV2i  16100  // Second 2X Via Hole (Only for 20nm and advanced technology)

LAYER MAP  136  DATATYPE 1  16110
LAYER BV2DUM  16110  // BV2 Dummy Layer(For dummy via insertion)

LAYER MAP  136  DATATYPE 7  16120
LAYER BV2DOP  16120  // BV2 Dummy pattern layer is referenced in OPC engineering

LAYER MAP  136  DATATYPE 8  16130
LAYER BV2RB  16130  // BV2 blockage layer to skip redundant via insertion

LAYER MAP  136  DATATYPE 10  16140
LAYER BV2RM  16140  // BV2 marker layer to identify redundant via

//;LAYER MAP  111  DATATYPE 0  16150
//;LAYER EV1i  16150  // First 4X Via Hole (Only for 20nm and advanced technology)
EV1i = 69 NOT BULK

//;LAYER MAP  111  DATATYPE 1  16160
//;LAYER EV1DUM  16160  // EV1 Dummy Layer(For dummy via insertion)
EV1DUM = 70 NOT BULK

//;LAYER MAP  111  DATATYPE 7  16170
//;LAYER EV1DOP  16170  // EV1 Dummy pattern layer is referenced in OPC engineering
EV1DOP = 71 NOT BULK

//;LAYER MAP  111  DATATYPE 8  16180
//;LAYER EV1RB  16180  // EV1 blockage layer to skip redundant via insertion
EV1RB = 73 NOT BULK

//;LAYER MAP  111  DATATYPE 10  16190
//;LAYER EV1RM  16190  // EV1 marker layer to identify redundant via
EV1RM = 74 NOT BULK

//;LAYER MAP  111  DATATYPE 50  16200
//;LAYER EV1_50  16200  // EV1 Hole for data type 50 (5.6xVn)
EV1_50 = 75 NOT BULK

//;LAYER MAP  112  DATATYPE 0  16210
//;LAYER EV2i  16210  // Second 4X Via Hole (Only for 20nm and advanced technology)
EV2i = 76 NOT BULK

//;LAYER MAP  112  DATATYPE 1  16220
//;LAYER EV2DUM  16220  // EV2 Dummy Layer(For dummy via insertion)
EV2DUM = 77 NOT BULK

//;LAYER MAP  112  DATATYPE 7  16230
//;LAYER EV2DOP  16230  // EV2 Dummy pattern layer is referenced in OPC engineering
EV2DOP = 78 NOT BULK

//;LAYER MAP  112  DATATYPE 8  16240
//;LAYER EV2RB  16240  // EV2 blockage layer to skip redundant via insertion
EV2RB = 79 NOT BULK

//;LAYER MAP  112  DATATYPE 10  16250
//;LAYER EV2RM  16250  // EV2 marker layer to identify redundant via
EV2RM = 80 NOT BULK

//;LAYER MAP  112  DATATYPE 50  16260
//;LAYER EV2_50  16260  // EV2 Hole for data type 50 (5.6xVn)
EV2_50 = 81 NOT BULK

//;LAYER MAP  137  DATATYPE 0  16270
//;LAYER TV3i  16270  // Third Top Via Hole (Only for 20nm and advanced technology)
TV3i = 82 NOT BULK

//;LAYER MAP  137  DATATYPE 1  16280
//;LAYER TV3DUM  16280  // TV3 Dummy Layer(For dummy via insertion) (Only for 20nm and advanced technology)
TV3DUM = 83 NOT BULK

//;LAYER MAP  137  DATATYPE 2  16290
//;LAYER TV3BAR  16290  // TV3 Rectangular via used in the chip guard ring and inductor. (Only for 20nm and advanced technology)
TV3BAR = 84 NOT BULK

//;LAYER MAP  137  DATATYPE 7  16300
//;LAYER TV3DOP  16300  // TV3 Dummy pattern layer is referenced in OPC engineering
TV3DOP = 85 NOT BULK

//;LAYER MAP  137  DATATYPE 8  16310
//;LAYER TV3RB  16310  // TV3 blockage layer to skip redundant via insertion
TV3RB = 86 NOT BULK

//;LAYER MAP  137  DATATYPE 10  16320
//;LAYER TV3RM  16320  // TV3 marker layer to identify redundant via
TV3RM = 87 NOT BULK

//;LAYER MAP  137  DATATYPE 40  16330
//;LAYER TV3_40  16330  // TV3 hole for data type 40 (14xTV3)
TV3_40 = 88 NOT BULK

//;LAYER MAP  61  DATATYPE 72  16340
//;LAYER M1DOP_CA  16340  // M1 OPC dummy layer for double patterning mask1

//;LAYER MAP  61  DATATYPE 73  16350
//;LAYER M1DOP_CB  16350  // M1 OPC dummy layer for double patterning mask2

//;LAYER MAP  61  DATATYPE 78  16360
//;LAYER M1DUM_CA  16360  // M1 dummy layer for double patterning mask1

//;LAYER MAP  61  DATATYPE 79  16370
//;LAYER M1DUM_CB  16370  // M1 dummy layer for double patterning mask2

//;LAYER MAP  62  DATATYPE 72  16380
//;LAYER M2DOP_CA  16380  // M2 OPC dummy layer for double patterning mask1

//;LAYER MAP  62  DATATYPE 73  16390
//;LAYER M2DOP_CB  16390  // M2 OPC dummy layer for double patterning mask2

//;LAYER MAP  62  DATATYPE 78  16400
//;LAYER M2DUM_CA  16400  // M2 dummy layer for double patterning mask1

//;LAYER MAP  62  DATATYPE 79  16410
//;LAYER M2DUM_CB  16410  // M2 dummy layer for double patterning mask2

//;LAYER MAP  63  DATATYPE 72  16420
//;LAYER M3DOP_CA  16420  // M3 OPC dummy layer for double patterning mask1

//;LAYER MAP  63  DATATYPE 73  16430
//;LAYER M3DOP_CB  16430  // M3 OPC dummy layer for double patterning mask2

//;LAYER MAP  63  DATATYPE 78  16440
//;LAYER M3DUM_CA  16440  // M3 dummy layer for double patterning mask1

//;LAYER MAP  63  DATATYPE 79  16450
//;LAYER M3DUM_CB  16450  // M3 dummy layer for double patterning mask2

//;LAYER MAP  64  DATATYPE 72  16460
//;LAYER M4DOP_CA  16460  // M4 OPC dummy layer for double patterning mask1

//;LAYER MAP  64  DATATYPE 73  16470
//;LAYER M4DOP_CB  16470  // M4 OPC dummy layer for double patterning mask2

//;LAYER MAP  64  DATATYPE 78  16480
//;LAYER M4DUM_CA  16480  // M4 dummy layer for double patterning mask1

//;LAYER MAP  64  DATATYPE 79  16490
//;LAYER M4DUM_CB  16490  // M4 dummy layer for double patterning mask2

LAYER MAP  141  DATATYPE 0  16500
LAYER MAP  141  TEXTTYPE 0  16500
LAYER B1i  16500  // First-level 2x metal line in the ultralow-k dielectric # 2x Metal-1

LAYER MAP  141  DATATYPE 1  16510
LAYER B1DUM  16510  // 2x Metal-1 Dummy Layer

LAYER MAP  141  DATATYPE 2  16520
LAYER B1SLOT  16520  // B1 Slot

LAYER MAP  141  DATATYPE 7  16530
LAYER B1DOP  16530  // 2x Metal-1 Dummy Layer for OPC engineering (Only for 32nm and below technology use)

LAYER MAP  142  DATATYPE 0  16540
LAYER MAP  142  TEXTTYPE 0  16540
LAYER B2i  16540  // Second-level 2x metal line in the ultralow-k dielectric # 2x Metal-2

LAYER MAP  142  DATATYPE 1  16550
LAYER B2DUM  16550  // 2x Metal-2 Dummy Layer

LAYER MAP  142  DATATYPE 2  16560
LAYER B2SLOT  16560  // B2 Slot

LAYER MAP  142  DATATYPE 7  16570
LAYER B2DOP  16570  // 2x Metal-2 Dummy Layer for OPC engineering (Only for 32nm and below technology use)

//;LAYER MAP  144  DATATYPE 0  16580
//;LAYER MAP  144  TEXTTYPE 0  16580
//;LAYER E1i  16580  // First layer 4X metal in LK # 4x Metal-1
E1i = 91 NOT BULK

//;LAYER MAP  144  DATATYPE 1  16590
//;LAYER E1DUM  16590  // 4x Metal-1 Dummy Layer
E1DUM = 92 NOT BULK

//;LAYER MAP  144  DATATYPE 2  16600
//;LAYER E1SLOT  16600  // E1 Slot
E1SLOT = 93 NOT BULK

//;LAYER MAP  144  DATATYPE 7  16610
//;LAYER E1DOP  16610  // E1 Dummy Layer for OPC engineering
E1DOP = 94 NOT BULK

//;LAYER MAP  144  DATATYPE 50  16620
//;LAYER MAP  144  TEXTTYPE 50  16620
//;LAYER E1_50  16620  // E1 for data type 50 (5.6xMn)
E1_50 = 95 NOT BULK

//;LAYER MAP  145  DATATYPE 0  16630
//;LAYER MAP  145  TEXTTYPE 0  16630
//;LAYER E2i  16630  // Second layer 4X metal in LK # 4x Metal-2
E2i = 96 NOT BULK

//;LAYER MAP  145  DATATYPE 1  16640
//;LAYER E2DUM  16640  // 4x Metal-2 Dummy Layer
E2DUM = 97 NOT BULK

//;LAYER MAP  145  DATATYPE 2  16650
//;LAYER E2SLOT  16650  // E2 Slot
E2SLOT = 98 NOT BULK

//;LAYER MAP  145  DATATYPE 7  16660
//;LAYER E2DOP  16660  // E2 Dummy Layer for OPC engineering
E2DOP = 99 NOT BULK

//;LAYER MAP  145  DATATYPE 50  16670
//;LAYER MAP  145  TEXTTYPE 50  16670
//;LAYER E2_50  16670  // E2 for data type 50 (5.6xMn)
E2_50 = 100 NOT BULK

//;LAYER MAP  140  DATATYPE 0  16680
//;LAYER MAP  140  TEXTTYPE 0  16680
//;LAYER TM3i  16680  // Third Top Metal (Only for 20nm and advanced technology)
TM3i = 101 NOT BULK

//;LAYER MAP  140  DATATYPE 1  16690
//;LAYER TM3DUM  16690  // TM3 Dummy Layer (For dummy metal insertion)
TM3DUM = 102 NOT BULK

//;LAYER MAP  140  DATATYPE 2  16700
//;LAYER TM3SLOT 16700  // TM3 Slot
TM3SLOT = 103 NOT BULK

//;LAYER MAP  140  DATATYPE 7  16710
//;LAYER TM3DOPi  16710  // TM3 Dummy pattern layer is referenced in OPC engineering
TM3DOPi = 104 NOT BULK

//;LAYER MAP  140  DATATYPE 40  16720
//;LAYER MAP  140  TEXTTYPE 40  16720
//;LAYER TM3_40  16720  // TM3 for data type 40 (14xTM2)
TM3_40 = 105 NOT BULK

LAYER MAP  89  DATATYPE 194  16730
LAYER GT_P96  16730  // Marking layer of 96nm poly pitch

LAYER MAP  61  DATATYPE 200  16740
LAYER M1_0Vi  16740  // DRC and LVS marking layer for 0.0V M1

LAYER MAP  61  DATATYPE 201  16750
LAYER M1_0d1V  16750  // DRC and LVS marking layer for 0.1V M1

LAYER MAP  61  DATATYPE 202  16760
LAYER M1_0d2V  16760  // DRC and LVS marking layer for 0.2V M1

LAYER MAP  61  DATATYPE 203  16770
LAYER M1_0d3V  16770  // DRC and LVS marking layer for 0.3V M1

LAYER MAP  61  DATATYPE 204  16780
LAYER M1_0d4V  16780  // DRC and LVS marking layer for 0.4V M1

LAYER MAP  61  DATATYPE 205  16790
LAYER M1_0d5V  16790  // DRC and LVS marking layer for 0.5V M1

LAYER MAP  61  DATATYPE 206  16800
LAYER M1_0d6V  16800  // DRC and LVS marking layer for 0.6V M1

LAYER MAP  61  DATATYPE 207  16810
LAYER M1_0d7V  16810  // DRC and LVS marking layer for 0.7V M1

LAYER MAP  61  DATATYPE 208  16820
LAYER M1_0d8V  16820  // DRC and LVS marking layer for 0.8V M1

LAYER MAP  61  DATATYPE 209  16830
LAYER M1_0d9V  16830  // DRC and LVS marking layer for 0.9V M1

LAYER MAP  61  DATATYPE 210  16840
LAYER M1_1d0V  16840  // DRC and LVS marking layer for 1.0V M1

LAYER MAP  61  DATATYPE 211  16850
LAYER M1_1d1V  16850  // DRC and LVS marking layer for 1.1V M1

LAYER MAP  61  DATATYPE 213  16860
LAYER M1_1d3V  16860  // DRC and LVS marking layer for 1.3V M1

LAYER MAP  61  DATATYPE 214  16870
LAYER M1_1d4V  16870  // DRC and LVS marking layer for 1.4V M1

LAYER MAP  61  DATATYPE 216  16880
LAYER M1_1d6V  16880  // DRC and LVS marking layer for 1.6V M1

LAYER MAP  61  DATATYPE 217  16890
LAYER M1_1d7V  16890  // DRC and LVS marking layer for 1.7V M1

LAYER MAP  61  TEXTTYPE 230  16900
LAYER M1_V_Hi  16900  // DRC and LVS marking layer for Highest voltage M1

LAYER MAP  61  TEXTTYPE 231  16910
LAYER M1_V_Lo  16910  // DRC and LVS marking layer for Lowest voltage M1

LAYER MAP  62  DATATYPE 200  16920
LAYER M2_0Vi  16920  // DRC and LVS marking layer for 0.0V M2

LAYER MAP  62  DATATYPE 201  16930
LAYER M2_0d1V  16930  // DRC and LVS marking layer for 0.1V M2

LAYER MAP  62  DATATYPE 202  16940
LAYER M2_0d2V  16940  // DRC and LVS marking layer for 0.2V M2

LAYER MAP  62  DATATYPE 203  16950
LAYER M2_0d3V  16950  // DRC and LVS marking layer for 0.3V M2

LAYER MAP  62  DATATYPE 204  16960
LAYER M2_0d4V  16960  // DRC and LVS marking layer for 0.4V M2

LAYER MAP  62  DATATYPE 205  16970
LAYER M2_0d5V  16970  // DRC and LVS marking layer for 0.5V M2

LAYER MAP  62  DATATYPE 206  16980
LAYER M2_0d6V  16980  // DRC and LVS marking layer for 0.6V M2

LAYER MAP  62  DATATYPE 207  16990
LAYER M2_0d7V  16990  // DRC and LVS marking layer for 0.7V M2

LAYER MAP  62  DATATYPE 208  17000
LAYER M2_0d8V  17000  // DRC and LVS marking layer for 0.8V M2

LAYER MAP  62  DATATYPE 209  17010
LAYER M2_0d9V  17010  // DRC and LVS marking layer for 0.9V M2

LAYER MAP  62  DATATYPE 210  17020
LAYER M2_1d0V  17020  // DRC and LVS marking layer for 1.0V M2

LAYER MAP  62  DATATYPE 211  17030
LAYER M2_1d1V  17030  // DRC and LVS marking layer for 1.1V M2

LAYER MAP  62  DATATYPE 213  17031
LAYER M2_1d3V  17031  // DRC and LVS marking layer for 1.23V M2

LAYER MAP  62  DATATYPE 214  17040
LAYER M2_1d4V  17040  // DRC and LVS marking layer for 1.4V M2

LAYER MAP  62  DATATYPE 216  17050
LAYER M2_1d6V  17050  // DRC and LVS marking layer for 1.6V M2

LAYER MAP  62  DATATYPE 217  17060
LAYER M2_1d7V  17060  // DRC and LVS marking layer for 1.7V M2

LAYER MAP  62  TEXTTYPE 230  17070
LAYER M2_V_Hi  17070  // DRC and LVS marking layer for Highest voltage M2

LAYER MAP  62  TEXTTYPE 231  17080
LAYER M2_V_Lo  17080  // DRC and LVS marking layer for Lowest voltage M2

LAYER MAP  63  DATATYPE 200  17090
LAYER M3_0Vi  17090  // DRC and LVS marking layer for 0.0V M3

LAYER MAP  63  DATATYPE 201  17100
LAYER M3_0d1V  17100  // DRC and LVS marking layer for 0.1V M3

LAYER MAP  63  DATATYPE 202  17110
LAYER M3_0d2V  17110  // DRC and LVS marking layer for 0.2V M3

LAYER MAP  63  DATATYPE 203  17120
LAYER M3_0d3V  17120  // DRC and LVS marking layer for 0.3V M3

LAYER MAP  63  DATATYPE 204  17130
LAYER M3_0d4V  17130  // DRC and LVS marking layer for 0.4V M3

LAYER MAP  63  DATATYPE 205  17140
LAYER M3_0d5V  17140  // DRC and LVS marking layer for 0.5V M3

LAYER MAP  63  DATATYPE 206  17150
LAYER M3_0d6V 17150  // DRC and LVS marking layer for 0.6V M3

LAYER MAP  63  DATATYPE 207  17160
LAYER M3_0d7V  17160  // DRC and LVS marking layer for 0.7V M3

LAYER MAP  63  DATATYPE 208  17170
LAYER M3_0d8V  17170  // DRC and LVS marking layer for 0.8V M3

LAYER MAP  63  DATATYPE 209  17180
LAYER M3_0d9V  17180  // DRC and LVS marking layer for 0.9V M3

LAYER MAP  63  DATATYPE 210  17190
LAYER M3_1d0V  17190  // DRC and LVS marking layer for 1.0V M3

LAYER MAP  63  DATATYPE 211  17200
LAYER M3_1d1V  17200  // DRC and LVS marking layer for 1.1V M3

LAYER MAP  63  DATATYPE 213  17210
LAYER M3_1d3V  17210  // DRC and LVS marking layer for 1.3V M3

LAYER MAP  63  DATATYPE 214  17220
LAYER M3_1d4V  17220  // DRC and LVS marking layer for 1.4V M3

LAYER MAP  63  DATATYPE 216  17230
LAYER M3_1d6V  17230  // DRC and LVS marking layer for 1.6V M3

LAYER MAP  63  DATATYPE 217  17240
LAYER M3_1d7V  17240  // DRC and LVS marking layer for 1.7V M3

LAYER MAP  63  TEXTTYPE 230  17250
LAYER M3_V_Hi  17250  // DRC and LVS marking layer for Highest voltage M3

LAYER MAP  63  TEXTTYPE 231  17260
LAYER M3_V_Lo  17260  // DRC and LVS marking layer for Lowest voltage M3

LAYER MAP  64  DATATYPE 200  17270
LAYER M4_0Vi  17270  // DRC and LVS marking layer for 0.0V M4

LAYER MAP  64  DATATYPE 201  17280
LAYER M4_0d1V  17280  // DRC and LVS marking layer for 0.1V M4

LAYER MAP  64  DATATYPE 202  17290
LAYER M4_0d2V  17290  // DRC and LVS marking layer for 0.2V M4

LAYER MAP  64  DATATYPE 203  17300
LAYER M4_0d3V  17300  // DRC and LVS marking layer for 0.3V M4

LAYER MAP  64  DATATYPE 204  17310
LAYER M4_0d4V  17310  // DRC and LVS marking layer for 0.4V M4

LAYER MAP  64  DATATYPE 205  17320
LAYER M4_0d5V  17320  // DRC and LVS marking layer for 0.5V M4

LAYER MAP  64  DATATYPE 206  17330
LAYER M4_0d6V  17330  // DRC and LVS marking layer for 0.6V M4

LAYER MAP  64  DATATYPE 207  17340
LAYER M4_0d7V  17340  // DRC and LVS marking layer for 0.7V M4

LAYER MAP  64  DATATYPE 208  17350
LAYER M4_0d8V  17350  // DRC and LVS marking layer for 0.8V M4

LAYER MAP  64  DATATYPE 209  17360
LAYER M4_0d9V  17360  // DRC and LVS marking layer for 0.9V M4

LAYER MAP  64  DATATYPE 210  17370
LAYER M4_1d0V  17370  // DRC and LVS marking layer for 1.0V M4

LAYER MAP  64  DATATYPE 211  17380
LAYER M4_1d1V  17380  // DRC and LVS marking layer for 1.1V M4

LAYER MAP  64  DATATYPE 213  17390
LAYER M4_1d3V  17390  // DRC and LVS marking layer for 1.3V M4

LAYER MAP  64  DATATYPE 214  17400
LAYER M4_1d4V  17400  // DRC and LVS marking layer for 1.4V M4

LAYER MAP  64  DATATYPE 216  17410
LAYER M4_1d6V  17410  // DRC and LVS marking layer for 1.6V M4

LAYER MAP  64  DATATYPE 217  17420
LAYER M4_1d7V  17420  // DRC and LVS marking layer for 1.7V M4

LAYER MAP  64  TEXTTYPE 230  17430
LAYER M4_V_Hi  17430  // DRC and LVS marking layer for Highest voltage M4

LAYER MAP  64  TEXTTYPE 231  17440
LAYER M4_V_Lo  17440  // DRC and LVS marking layer for Lowest voltage M4

LAYER MAP  65  DATATYPE 200  17450
LAYER M5_0Vi  17450  // DRC and LVS marking layer for 0.0V M5

LAYER MAP  65  DATATYPE 201  17460
LAYER M5_0d1V  17460  // DRC and LVS marking layer for 0.1V M5

LAYER MAP  65  DATATYPE 202  17470
LAYER M5_0d2V  17470  // DRC and LVS marking layer for 0.2V M5

LAYER MAP  65  DATATYPE 203  17480
LAYER M5_0d3V  17480  // DRC and LVS marking layer for 0.3V M5

LAYER MAP  65  DATATYPE 204  17490
LAYER M5_0d4V  17490  // DRC and LVS marking layer for 0.4V M5

LAYER MAP  65  DATATYPE 205  17500
LAYER M5_0d5V  17500  // DRC and LVS marking layer for 0.5V M5

LAYER MAP  65  DATATYPE 206  17510
LAYER M5_0d6V  17510  // DRC and LVS marking layer for 0.6V M5

LAYER MAP  65  DATATYPE 207  17520
LAYER M5_0d7V  17520  // DRC and LVS marking layer for 0.7V M5

LAYER MAP  65  DATATYPE 208  17530
LAYER M5_0d8V  17530  // DRC and LVS marking layer for 0.8V M5

LAYER MAP  65  DATATYPE 209  17540
LAYER M5_0d9V  17540  // DRC and LVS marking layer for 0.9V M5

LAYER MAP  65  DATATYPE 210  17550
LAYER M5_1d0V  17550  // DRC and LVS marking layer for 1.0V M5

LAYER MAP  65  DATATYPE 211  17560
LAYER M5_1d1V  17560  // DRC and LVS marking layer for 1.1V M5

LAYER MAP  65  DATATYPE 213  17570
LAYER M5_1d3V  17570  // DRC and LVS marking layer for 1.3V M5

LAYER MAP  65  DATATYPE 214  17580
LAYER M5_1d4V  17580  // DRC and LVS marking layer for 1.4V M5

LAYER MAP  65  DATATYPE 216  17590
LAYER M5_1d6V  17590  // DRC and LVS marking layer for 1.6V M5

LAYER MAP  65  DATATYPE 217  17600
LAYER M5_1d7V  17600  // DRC and LVS marking layer for 1.7V M5

LAYER MAP  65  TEXTTYPE 230  17610
LAYER M5_V_Hi 17610  // DRC and LVS marking layer for Highest voltage M5

LAYER MAP  65  TEXTTYPE 231  17620
LAYER M5_V_Lo  17620  // DRC and LVS marking layer for Lowest voltage M5

LAYER MAP  66  DATATYPE 200  17630
LAYER M6_0Vi  17630  // DRC and LVS marking layer for 0.0V M6

LAYER MAP  66  DATATYPE 201  17640
LAYER M6_0d1V  17640  // DRC and LVS marking layer for 0.1V M6

LAYER MAP  66  DATATYPE 202  17650
LAYER M6_0d2V  17650  // DRC and LVS marking layer for 0.2V M6

LAYER MAP  66  DATATYPE 203  17660
LAYER M6_0d3V  17660  // DRC and LVS marking layer for 0.3V M6

LAYER MAP  66  DATATYPE 204  17670
LAYER M6_0d4V  17670  // DRC and LVS marking layer for 0.4V M6

LAYER MAP  66  DATATYPE 205  17680
LAYER M6_0d5V  17680  // DRC and LVS marking layer for 0.5V M6

LAYER MAP  66  DATATYPE 206  17690
LAYER M6_0d6V  17690  // DRC and LVS marking layer for 0.6V M6

LAYER MAP  66  DATATYPE 207  17700
LAYER M6_0d7V  17700  // DRC and LVS marking layer for 0.7V M6

LAYER MAP  66  DATATYPE 208  17710
LAYER M6_0d8V  17710  // DRC and LVS marking layer for 0.8V M6

LAYER MAP  66  DATATYPE 209  17720
LAYER M6_0d9V  17720  // DRC and LVS marking layer for 0.9V M6

LAYER MAP  66  DATATYPE 210  17730
LAYER M6_1d0V  17730  // DRC and LVS marking layer for 1.0V M6

LAYER MAP  66  DATATYPE 211  17740
LAYER M6_1d1V  17740  // DRC and LVS marking layer for 1.1V M6

LAYER MAP  66  DATATYPE 213  17750
LAYER M6_1d3V  17750  // DRC and LVS marking layer for 1.3V M6

LAYER MAP  66  DATATYPE 214  17760
LAYER M6_1d4V  17760  // DRC and LVS marking layer for 1.4V M6

LAYER MAP  66  DATATYPE 216  17770
LAYER M6_1d6V  17770  // DRC and LVS marking layer for 1.6V M6

LAYER MAP  66  DATATYPE 217  17780
LAYER M6_1d7V  17780  // DRC and LVS marking layer for 1.7V M6

LAYER MAP  66  TEXTTYPE 230  17790
LAYER M6_V_Hi  17790  // DRC and LVS marking layer for Highest voltage M6

LAYER MAP  66  TEXTTYPE 231  17800
LAYER M6_V_Lo  17800  // DRC and LVS marking layer for Lowest voltage M6

LAYER MAP  67  DATATYPE 200  17810
LAYER M7_0Vi  17810  // DRC and LVS marking layer for 0.0V M7

LAYER MAP  67  DATATYPE 201  17820
LAYER M7_0d1V  17820  // DRC and LVS marking layer for 0.1V M7

LAYER MAP  67  DATATYPE 202  17830
LAYER M7_0d2V  17830  // DRC and LVS marking layer for 0.2V M7

LAYER MAP  67  DATATYPE 203  17840
LAYER M7_0d3V  17840  // DRC and LVS marking layer for 0.3V M7

LAYER MAP  67  DATATYPE 204  17850
LAYER M7_0d4V  17850  // DRC and LVS marking layer for 0.4V M7

LAYER MAP  67  DATATYPE 205  17860
LAYER M7_0d5V  17860  // DRC and LVS marking layer for 0.5V M7

LAYER MAP  67  DATATYPE 206  17870
LAYER M7_0d6V  17870  // DRC and LVS marking layer for 0.6V M7

LAYER MAP  67  DATATYPE 207  17880
LAYER M7_0d7V  17880  // DRC and LVS marking layer for 0.7V M7

LAYER MAP  67  DATATYPE 208  17890
LAYER M7_0d8V  17890  // DRC and LVS marking layer for 0.8V M7

LAYER MAP  67  DATATYPE 209  17900
LAYER M7_0d9V  17900  // DRC and LVS marking layer for 0.9V M7

LAYER MAP  67  DATATYPE 210  17910
LAYER M7_1d0V  17910  // DRC and LVS marking layer for 1.0V M7

LAYER MAP  67  DATATYPE 211  17920
LAYER M7_1d1V  17920  // DRC and LVS marking layer for 1.1V M7

LAYER MAP  67  DATATYPE 213  17930
LAYER M7_1d3V  17930  // DRC and LVS marking layer for 1.3V M7

LAYER MAP  67  DATATYPE 214  17940
LAYER M7_1d4V  17940  // DRC and LVS marking layer for 1.4V M7

LAYER MAP  67  DATATYPE 216  17950
LAYER M7_1d6V  17950  // DRC and LVS marking layer for 1.6V M7

LAYER MAP  67  DATATYPE 217  17960
LAYER M7_1d7V  17960  // DRC and LVS marking layer for 1.7V M7

LAYER MAP  67  TEXTTYPE 230  17970
LAYER M7_V_Hi  17970  // DRC and LVS marking layer for Highest voltage M7

LAYER MAP  67  TEXTTYPE 231  17980
LAYER M7_V_Lo  17980  // DRC and LVS marking layer for Lowest voltage M7

LAYER MAP  68  DATATYPE 200  17990
LAYER M8_0Vi  17990  // DRC and LVS marking layer for 0.0V M8

LAYER MAP  68  DATATYPE 201  18000
LAYER M8_0d1V  18000  // DRC and LVS marking layer for 0.1V M8

LAYER MAP  68  DATATYPE 202  18010
LAYER M8_0d2V  18010  // DRC and LVS marking layer for 0.2V M8

LAYER MAP  68  DATATYPE 203  18020
LAYER M8_0d3V  18020  // DRC and LVS marking layer for 0.3V M8

LAYER MAP  68  DATATYPE 204  18030
LAYER M8_0d4V  18030  // DRC and LVS marking layer for 0.4V M8

LAYER MAP  68  DATATYPE 205  18040
LAYER M8_0d5V  18040  // DRC and LVS marking layer for 0.5V M8

LAYER MAP  68  DATATYPE 206  18050
LAYER M8_0d6V  18050  // DRC and LVS marking layer for 0.6V M8

LAYER MAP  68  DATATYPE 207  18060
LAYER M8_0d7V  18060  // DRC and LVS marking layer for 0.7V M8

LAYER MAP  68  DATATYPE 208  18070
LAYER M8_0d8V  18070  // DRC and LVS marking layer for 0.8V M8

LAYER MAP  68  DATATYPE 209  18080
LAYER M8_0d9V  18080  // DRC and LVS marking layer for 0.9V M8

LAYER MAP  68  DATATYPE 210  18090
LAYER M8_1d0V  18090  // DRC and LVS marking layer for 1.0V M8

LAYER MAP  68  DATATYPE 211  18100
LAYER M8_1d1V  18100  // DRC and LVS marking layer for 1.1V M8

LAYER MAP  68  DATATYPE 213  18110
LAYER M8_1d3V  18110  // DRC and LVS marking layer for 1.3V M8

LAYER MAP  68  DATATYPE 214  18120
LAYER M8_1d4V  18120  // DRC and LVS marking layer for 1.4V M8

LAYER MAP  68  DATATYPE 216  18130
LAYER M8_1d6V  18130  // DRC and LVS marking layer for 1.6V M8

LAYER MAP  68  DATATYPE 217  18140
LAYER M8_1d7V  18140  // DRC and LVS marking layer for 1.7V M8

LAYER MAP  68  TEXTTYPE 230  18150
LAYER M8_V_Hi  18150  // DRC and LVS marking layer for Highest voltage M8

LAYER MAP  68  TEXTTYPE 231  18160
LAYER M8_V_Lo  18160  // DRC and LVS marking layer for Lowest voltage M8

//;LAYER MAP  89  DATATYPE 111  18170
//;LAYER M9V18i  18170  // DRC and LVS marking layer for 1.8V M9
M9V18i = 140 NOT BULK

//;LAYER MAP  89  DATATYPE 112  18180
//;LAYER M9V25i  18180  // DRC and LVS marking layer for 2.5V M9
M9V25i = 141 NOT BULK

//;LAYER MAP  89  DATATYPE 113  18190
//;LAYER M9V33i  18190  // DRC and LVS marking layer for 3.3V M9
M9V33i = 142 NOT BULK

//;LAYER MAP  89  DATATYPE 114  18200
//;LAYER M9V42i  18200  // DRC and LVS marking layer for 4.2V M9
M9V42i = 143 NOT BULK

//;LAYER MAP  89  DATATYPE 115  18210
//;LAYER M9V50i  18210  // DRC and LVS marking layer for 5V M9
M9V50i = 144 NOT BULK

//;LAYER MAP  89  DATATYPE 116  18220
//;LAYER M9V12i  18220  // DRC and LVS marking layer for 1.2V M9
M9V12i = 145 NOT BULK

//;LAYER MAP  89  DATATYPE 117  18230
//;LAYER M9V15i  18230  // DRC and LVS marking layer for 1.5V M9
M9V15i = 146 NOT BULK

LAYER MAP  89  DATATYPE 91  18240
LAYER B1V18i  18240  // DRC and LVS marking layer for 1.8V B1

LAYER MAP  89  DATATYPE 92  18250
LAYER B1V25i  18250  // DRC and LVS marking layer for 2.5V B1

LAYER MAP  89  DATATYPE 93  18260
LAYER B1V33i  18260  // DRC and LVS marking layer for 3.3V B1

//;LAYER MAP  89  DATATYPE 94  18270
//;LAYER B1V42i  18270  // DRC and LVS marking layer for 4.2V B1
B1V42i = 147 NOT BULK

LAYER MAP  89  DATATYPE 95  18280
LAYER B1V50i  18280  // DRC and LVS marking layer for 5V B1

LAYER MAP  89  DATATYPE 96  18290
LAYER B1V12i  18290  // DRC and LVS marking layer for 1.2V B1

LAYER MAP  89  DATATYPE 97  18300
LAYER B1V15i  18300  // DRC and LVS marking layer for 1.5V B1

LAYER MAP  89  DATATYPE 101  18310
LAYER B2V18i  18310  // DRC and LVS marking layer for 1.8V B2

LAYER MAP  89  DATATYPE 102  18320
LAYER B2V25i  18320  // DRC and LVS marking layer for 2.5V B2

LAYER MAP  89  DATATYPE 103  18330
LAYER B2V33i  18330  // DRC and LVS marking layer for 3.3V B2

//;LAYER MAP  89  DATATYPE 104  18340
//;LAYER B2V42i  18340  // DRC and LVS marking layer for 4.2V B2
B2V42i = 148 NOT BULK

LAYER MAP  89  DATATYPE 105  18350
LAYER B2V50i  18350  // DRC and LVS marking layer for 5V B2

LAYER MAP  89  DATATYPE 106  18360
LAYER B2V12i  18360  // DRC and LVS marking layer for 1.2V B2

LAYER MAP  89  DATATYPE 107  18370
LAYER B2V15i  18370  // DRC and LVS marking layer for 1.5V B2

//;LAYER MAP  89  DATATYPE 121  18380
//;LAYER E1V18i  18380  // DRC and LVS marking layer for 1.8V E1
E1V18i = 149 NOT BULK

//;LAYER MAP  89  DATATYPE 122  18390
//;LAYER E1V25i  18390  // DRC and LVS marking layer for 2.5V E1
E1V25i = 150 NOT BULK

//;LAYER MAP  89  DATATYPE 123  18400
//;LAYER E1V33i  18400  // DRC and LVS marking layer for 3.3V E1
E1V33i = 151 NOT BULK

//;LAYER MAP  89  DATATYPE 124  18410
//;LAYER E1V42i  18410  // DRC and LVS marking layer for 4.2V E1
E1V42i = 152 NOT BULK

//;LAYER MAP  89  DATATYPE 125  18420
//;LAYER E1V50i  18420  // DRC and LVS marking layer for 5V E1
E1V50i = 153 NOT BULK

//;LAYER MAP  89  DATATYPE 126  18430
//;LAYER E1V12i  18430  // DRC and LVS marking layer for 1.2V E1
E1V12i = 154 NOT BULK

//;LAYER MAP  89  DATATYPE 127  18440
//;LAYER E1V15i  18440  // DRC and LVS marking layer for 1.5V E1
E1V15i = 155 NOT BULK

//;LAYER MAP  89  DATATYPE 131  18450
//;LAYER E2V18i  18450  // DRC and LVS marking layer for 1.8V E2
E2V18i = 156 NOT BULK

//;LAYER MAP  89  DATATYPE 132  18460
//;LAYER E2V25i  18460  // DRC and LVS marking layer for 2.5V E2
E2V25i = 157 NOT BULK

//;LAYER MAP  89  DATATYPE 133  18470
//;LAYER E2V33i  18470  // DRC and LVS marking layer for 3.3V E2
E2V33i = 158 NOT BULK

//;LAYER MAP  89  DATATYPE 134  18480
//;LAYER E2V42i  18480  // DRC and LVS marking layer for 4.2V E2
E2V42i = 159 NOT BULK

//;LAYER MAP  89  DATATYPE 135  18490
//;LAYER E2V50i  18490  // DRC and LVS marking layer for 5V E2
E2V50i = 160 NOT BULK

//;LAYER MAP  89  DATATYPE 136  18500
//;LAYER E2V12i  18500  // DRC and LVS marking layer for 1.2V E2
E2V12i = 161 NOT BULK

//;LAYER MAP  89  DATATYPE 137  18510
//;LAYER E2V15i  18510  // DRC and LVS marking layer for 1.5V E2
E2V15i = 162 NOT BULK

LAYER MAP  141  DATATYPE 6  18770
LAYER B1DUB  18770  // Optional level placed over specific areas of the chip at the customer's discregion to prevent the generation of B1FILL shapes.

LAYER MAP  142  DATATYPE 6  18780
LAYER B2DUB  18780  // Optional level placed over specific areas of the chip at the customer's discregion to prevent the generation of B2FILL shapes.

//;LAYER MAP  144  DATATYPE 6  18790
//;LAYER E1DUB  18790  // 4x Metal-1 dummy block layer
E1DUB = 163 NOT BULK

//;LAYER MAP  145  DATATYPE 6  18800
//;LAYER E2DUB  18800  // E2 dummy block layer
E2DUB = 164 NOT BULK

//;LAYER MAP  194  DATATYPE 11  18810
//;LAYER TM3DUB  18810  // TM3 Dummy Blockage(For dummy metal inserdion)and exclude dummy insertion
TM3DUB = 165 NOT BULK

LAYER MAP  194  DATATYPE 154  18820
LAYER B1R  18820  // 2xmetal 1 resistor layer

LAYER MAP  194  DATATYPE 155  18830
LAYER B2R  18830  // 2xmetal 2 resistor layer

//;LAYER MAP  194  DATATYPE 144  18840
//;LAYER E1R  18840  // E1_Resistor
E1R = 166 NOT BULK

//;LAYER MAP  194  DATATYPE 145  18850
//;LAYER E2R  18850  // E2_Resistor
E2R = 167 NOT BULK

//;LAYER MAP  181  DATATYPE 103  18860
//;LAYER TM3R  18860  // TM3_Resistor
TM3R = 168 NOT BULK

LAYER MAP  58  DATATYPE 0  18870
LAYER MIM  18870  // Top Plate of MIM Capacitor

LAYER MAP  222  DATATYPE 0  18880
LAYER CTOP  18880  // Top Plate of MIM Capacitor. Bottom Plate of MIM Capacitor for 32nm and below technology

LAYER MAP  49  DATATYPE 0  18900
LAYER IDT  18900  // Inductor Trench/Inbuilt Deep Trench

LAYER MAP  211  DATATYPE 0  18930
LAYER MIMDMY  18930  // MIM Dummy Layer

LAYER MAP  245  DATATYPE 2  18960
LAYER V0_B0  18960  // Butted V0 marking layer type1

//;LAYER MAP  245  DATATYPE 3  18970
//;LAYER V0_B1  18970  // Butted V0 marking layer type2

//;LAYER MAP  245  DATATYPE 4  18980
//;LAYER V0_B2  18980  // Butted V0 marking layer type3

LAYER MAP  59  DATATYPE 13  18990
LAYER M0_B1  18990  // Butted M0 marking layer type1

LAYER MAP  59  DATATYPE 14  19000
LAYER M0_B2  19000  // Butted M0 marking layer type2

LAYER MAP  245  DATATYPE 110  19010
LAYER V0CA  19010  // Marking layer for V0 color A

LAYER MAP  245  DATATYPE 120  19020
LAYER V0CB  19020  // Marking layer for V0 color B

LAYER MAP  10  DATATYPE 30  19090
LAYER AAOPM  19090  // AA OPC marking layer

LAYER MAP  29  DATATYPE 30  19100
LAYER DGOPM  19100  // DG OPC marking layer

LAYER MAP  29  DATATYPE 31  19110
LAYER DGLOM  19110  // DG marking layer for special logic operation

LAYER MAP  41  DATATYPE 2  19120
LAYER ESDCLP  19120  // Placed over ESD RC-triggered power clamp structures connected to a power supply pad and used for checking

LAYER MAP  30  DATATYPE 30  19130
LAYER GTOPM  19130  // GT OPC marking layer

LAYER MAP  59  DATATYPE 250  19140
LAYER MAP  59  TEXTTYPE 250  19140
LAYER M0TXT  19140  // M0 Text Layer

LAYER MAP  33  DATATYPE 30  19150
LAYER P4OPM  19150  // P4 OPC marking layer

LAYER MAP  33  DATATYPE 31  19160
LAYER P4LOM  19160  // P4 marking layer for special logic operation

LAYER MAP  59  DATATYPE 30  19170
LAYER M0OPM  19170  // M0 OPC marking layer

LAYER MAP  59  DATATYPE 31  19180
LAYER M0LOM  19180  // M0 marking layer for special logic operation

LAYER MAP  246  DATATYPE 30  19190
LAYER M0COPM  19190  // M0C OPC marking layer

LAYER MAP  246  DATATYPE 31  19200
LAYER M0CLOM  19200  // M0C marking layer for special logic operation

LAYER MAP  208  DATATYPE 30  19210
LAYER M0GOPM  19210  // M0G OPC marking layer

LAYER MAP  208  DATATYPE 31  19220
LAYER M0GLOM  19220  // M0G marking layer for special logic operation

LAYER MAP  133  DATATYPE 10  19250
LAYER DBESD  19250  // Marking layer for drain ballasted ESD MOS

LAYER MAP  133  DATATYPE 11  19260
LAYER DBESD2  19260  // Marking layer for the identificationdrain of drain side of drain ballasted ESD MOS

LAYER MAP  35  DATATYPE 10  19270
LAYER NLLLOM  19270  // NLL marking layer for special logic operation

LAYER MAP  5  DATATYPE 10  19280
LAYER NSRLOM  19280  // NSR marking layer for special logic operation

LAYER MAP  38  DATATYPE 10  19290
LAYER PLLLOM  19290  // PLL marking layer for special logic operation

LAYER MAP  13  DATATYPE 10  19300
LAYER PPAALOM  19300  // PPAA marking layer for special logic operation

LAYER MAP  13  DATATYPE 60  19310
LAYER PPAADB  19310  // Pre Fin PPAA reserve, auto PPAA blockage

LAYER MAP  6  DATATYPE 10  19320
LAYER PSRLOM  19320  // PSR marking layer for special logic operation

LAYER MAP  40  DATATYPE 10  19330
LAYER SNLOM  19330  // SN marking layer for special logic operation

LAYER MAP  43  DATATYPE 10  19340
LAYER SPLOM  19340  // SP marking layer for special logic operation

LAYER MAP  61  DATATYPE 111  19350
LAYER M1CAOPRT  19350  // M1CA retargeting marker layer

LAYER MAP  61  DATATYPE 121  19360
LAYER M1CBOPRT  19360  // M1CB retargeting marker layer

LAYER MAP  62  DATATYPE 111  19370
LAYER M2CAOPRT  19370  // M2CA retargeting marker layer

LAYER MAP  62  DATATYPE 121  19380
LAYER M2CBOPRT  19380  // M2CB retargeting marker layer

LAYER MAP  63  DATATYPE 111  19390
LAYER M3CAOPRT  19390  // M3CA retargeting marker layer

LAYER MAP  63  DATATYPE 121  19400
LAYER M3CBOPRT  19400  // M3CB retargeting marker layer

LAYER MAP  64  DATATYPE 111  19410
LAYER M4CAOPRT  19410  // M4CA retargeting marker layer

LAYER MAP  64  DATATYPE 121  19420
LAYER M4CBOPRT  19420  // M4CB retargeting marker layer

LAYER MAP  245  DATATYPE 111  19430
LAYER V0CAOPRT  19430  // V0CA retargeting marker layer

LAYER MAP  245  DATATYPE 121  19440
LAYER V0CBOPRT  19440  // V0CB retargeting marker layer

//;LAYER MAP  14  DATATYPE 1  19510
//;LAYER NWDUM  19510  // NW dummy layer

LAYER MAP  40  DATATYPE 1  19520
LAYER SNDUM  19520  // SN dummy layer

LAYER MAP  43  DATATYPE 1  19530
LAYER SPDUM  19530  // SP dummy layer

LAYER MAP  211  DATATYPE 11  19540
LAYER MOMMK1  19540  // Marking layer for M1 MOM

LAYER MAP  211  DATATYPE 12  19550
LAYER MOMMK2  19550  // Marking layer for M2 MOM

LAYER MAP  211  DATATYPE 13  19560
LAYER MOMMK3  19560  // Marking layer for M3 MOM

LAYER MAP  211  DATATYPE 14  19570
LAYER MOMMK4  19570  // Marking layer for M4 MOM

LAYER MAP  211  DATATYPE 15  19580
LAYER MOMMK5  19580  // Marking layer for M5 MOM

LAYER MAP  211  DATATYPE 16  19600
LAYER MOMMK6  19600  // Marking layer for M6 MOM

LAYER MAP  211  DATATYPE 17  19610
LAYER MOMMK7  19610  // Marking layer for M7 MOM

LAYER MAP  91  DATATYPE 11  19640
LAYER OCCDM1  19640  // Marker layer of BEOL M1 OCCD cell

LAYER MAP  91  DATATYPE 12  19650
LAYER OCCDM2  19650  // Marker layer of BEOL M2 OCCD cell

LAYER MAP  91  DATATYPE 13  19660
LAYER OCCDM3  19660  // Marker layer of BEOL M3 OCCD cell

LAYER MAP  91  DATATYPE 14  19670
LAYER OCCDM4  19670  // Marker layer of BEOL M4 OCCD cell

LAYER MAP  91  DATATYPE 15  19680
LAYER OCCDM5  19680  // Marker layer of BEOL M5 OCCD cell

LAYER MAP  91  DATATYPE 16  19690
LAYER OCCDM6  19690  // Marker layer of BEOL M6 OCCD cell

LAYER MAP  91  DATATYPE 17  19700
LAYER OCCDM7  19700  // Marker layer of BEOL M7 OCCD cell

LAYER MAP  91  DATATYPE 18  19710
LAYER OCCDM8  19710  // Marker layer of BEOL M8 OCCD cell

LAYER MAP  61  DATATYPE 250  50000
LAYER M1TXTi_drawing  50000  // Metal-1 Text drawing Layer

LAYER MAP  62  DATATYPE 250  50001
LAYER M2TXTi_drawing  50001  // Metal-2 Text drawing Layer

LAYER MAP  63  DATATYPE 250  50002
LAYER M3TXTi_drawing  50002  // Metal-3 Text drawing Layer

LAYER MAP  64  DATATYPE 250  50003
LAYER M4TXTi_drawing  50003  // Metal-4 Text drawing Layer

LAYER MAP  65  DATATYPE 250  50004
LAYER M5TXTi_drawing  50004  // Metal-5 Text drawing Layer

LAYER MAP  66  DATATYPE 250  50005
LAYER M6TXTi_drawing  50005  // Metal-6 Text drawing Layer

LAYER MAP  67  DATATYPE 250  50006
LAYER M7TXTi_drawing  50006  // Metal-7 Text drawing Layer

LAYER MAP  68  DATATYPE 250  50007
LAYER M8TXTi_drawing  50007  // Metal-8 Text drawing Layer

//;LAYER MAP  69  DATATYPE 250  50008
//;LAYER M9TXTi_drawing  50008  // Metal-9 Text drawing Layer
M9TXTi_drawing = 169 NOT BULK

LAYER MAP  141  DATATYPE 250  50009
LAYER B1TXTi_drawing  50009  // 2xmetal 1 text drawing Layer

LAYER MAP  142  DATATYPE 250  50010
LAYER B2TXTi_drawing  50010  // 2xmetal 2 text drawing Layer

//;LAYER MAP  144  DATATYPE 250  50011
//;LAYER E1TXTi_drawing  50011  // E1 text drawing layer
E1TXTi_drawing = 170 NOT BULK

//;LAYER MAP  145  DATATYPE 250  50012
//;LAYER E2TXTi_drawing  50012  // E2 text drawing layer
E2TXTi_drawing = 171 NOT BULK

LAYER MAP  120  DATATYPE 3  50013
LAYER TM1TXTi_drawing  50013  // Top metal 1 Text drawing Layer

LAYER MAP  122  DATATYPE 3  50014
LAYER TM2TXTi_drawing  50014  // Top metal 2 Text drawing Layer

LAYER MAP  150  DATATYPE 250  50016
LAYER UTMTXTi_drawing  50016  // Ultra Thick Metal Text drawing Layer

LAYER MAP  61  TEXTTYPE==250  20000
LAYER M1TXTi  20000  // Metal-1 Text Layer

LAYER MAP  62  TEXTTYPE==250  20010
LAYER M2TXTi  20010  // Metal-2 Text Layer

LAYER MAP  63  TEXTTYPE==250  20020
LAYER M3TXTi  20020  // Metal-3 Text Layer

LAYER MAP  64  TEXTTYPE==250  20030
LAYER M4TXTi  20030  // Metal-4 Text Layer

LAYER MAP  65  TEXTTYPE==250  20040
LAYER M5TXTi  20040  // Metal-5 Text Layer

LAYER MAP  66  TEXTTYPE==250  20050
LAYER M6TXTi  20050  // Metal-6 Text Layer

LAYER MAP  67  TEXTTYPE==250  20060
LAYER M7TXTi  20060  // Metal-7 Text Layer

LAYER MAP  68  TEXTTYPE==250  20070
LAYER M8TXTi  20070  // Metal-8 Text Layer

//;LAYER MAP  69  TEXTTYPE==250  20080
//;LAYER M9TXTi  20080  // Metal-9 Text Layer
M9TXTi = 172 NOT BULK

LAYER MAP  141  TEXTTYPE==250  20090
LAYER B1TXTi  20090  // 2xmetal 1 text Layer, label text

LAYER MAP  142  TEXTTYPE==250  20100
LAYER B2TXTi  20100  // 2xmetal 2 text Layer, label text

//;LAYER MAP  144  TEXTTYPE==250  20110
//;LAYER E1TXTi  20110  // E1 text layer
E1TXTi = 173 NOT BULK

//;LAYER MAP  145  TEXTTYPE==250  20120
//;LAYER E2TXTi  20120  // E2 text layer
E2TXTi = 174 NOT BULK

LAYER MAP  120  TEXTTYPE==3  20130
LAYER TM1TXTi  20130  // Top metal 1 Text Layer，label text

LAYER MAP  122  TEXTTYPE==3  20140
LAYER TM2TXTi  20140  // Top metal 2 Text Layer，label text

LAYER MAP  150  TEXTTYPE==250  20160
LAYER UTMTXTi  20160  // Ultra Thick Metal Text Layer

LAYER MAP  61  DATATYPE 251  20170
LAYER M1PINi  20170  // Metal-1 pin layer

LAYER MAP  62  DATATYPE 251  20180
LAYER M2PINi  20180  // Metal-2 pin layer

LAYER MAP  63  DATATYPE 251  20190
LAYER M3PINi  20190  // Metal-3 pin layer

LAYER MAP  64  DATATYPE 251  20200
LAYER M4PINi  20200  // Metal-4 pin layer

LAYER MAP  65  DATATYPE 251  20210
LAYER M5PINi  20210  // Metal-5 pin layer

LAYER MAP  66  DATATYPE 251  20220
LAYER M6PINi  20220  // Metal-6 pin layer

LAYER MAP  67  DATATYPE 251  20230
LAYER M7PINi  20230  // Metal-7 pin layer

LAYER MAP  68  DATATYPE 251  20240
LAYER M8PINi  20240  // Metal-8 pin layer

//;LAYER MAP  69  DATATYPE 251  20250
//;LAYER M9PINi  20250  // Metal-9 pin layer
M9PINi = 128 NOT BULK

LAYER MAP  141  DATATYPE 251  20260
LAYER B1PINi  20260  // B1 pin layer

LAYER MAP  142  DATATYPE 251  20270
LAYER B2PINi  20270  // B2 pin layer

//;LAYER MAP  144  DATATYPE 251  20280
//;LAYER E1PINi  20280  // E1 pin layer
E1PINi = 129 NOT BULK

//;LAYER MAP  145  DATATYPE 251  20290
//;LAYER E2PINi  20290  // E2 pin layer
E2PINi = 130 NOT BULK

LAYER MAP  120  DATATYPE 251  20300
LAYER TM1PINi  20300  // TM-1 pin layer

LAYER MAP  122  DATATYPE 251  20310
LAYER TM2PINi  20310  // TM-2 pin layer

LAYER MAP  150  DATATYPE 251  20330
LAYER UTMPINi  20330  // UTM pin layer

LAYER MAP  61  DATATYPE 254  20340
LAYER M1LABELi  20340  // Metal-1 label layer

LAYER MAP  62  DATATYPE 254  20350
LAYER M2LABELi  20350  // Metal-2 label layer

LAYER MAP  63  DATATYPE 254  20360
LAYER M3LABELi  20360  // Metal-3 label layer

LAYER MAP  64  DATATYPE 254  20370
LAYER M4LABELi  20370  // Metal-4 label layer

LAYER MAP  65  DATATYPE 254  20380
LAYER M5LABELi  20380  // Metal-5 label layer

LAYER MAP  66  DATATYPE 254  20390
LAYER M6LABELi  20390  // Metal-6 label layer

LAYER MAP  67  DATATYPE 254  20400
LAYER M7LABELi  20400  // Metal-7 label layer

LAYER MAP  68  DATATYPE 254  20410
LAYER M8LABELi  20410  // Metal-8 label layer

//;LAYER MAP  69  DATATYPE 254  20420
//;LAYER M9LABELi  20420  // Metal-9 label layer
M9LABELi = 175 NOT BULK

LAYER MAP  141  DATATYPE 254  20430
LAYER B1LABELi  20430  // B1 label layer

LAYER MAP  142  DATATYPE 254  20440
LAYER B2LABELi  20440  // B2 label layer

//;LAYER MAP  144  DATATYPE 254  20450
//;LAYER E1LABELi  20450  // E1 label layer
E1LABELi = 176 NOT BULK

//;LAYER MAP  145  DATATYPE 254  20460
//;LAYER E2LABELi  20460  // E2 label layer
E2LABELi = 177 NOT BULK

LAYER MAP  120  DATATYPE 254  20470
LAYER TM1LABELi  20470  // TM-1 label layer

LAYER MAP  122  DATATYPE 254  20480
LAYER TM2LABELi  20480  // TM-2 label layer

LAYER MAP  150  DATATYPE 254  20500
LAYER UTMLABELi  20500  // UTM label layer

LAYER MAP  159  DATATYPE 156  20520
LAYER HVT_N  20520  // Marking layer for N-type high-Vt devices

LAYER MAP  159  DATATYPE 166  20530
LAYER HVT_P  20530  // Marking layer for P-type high-Vt devices

LAYER MAP  131  DATATYPE  175  20567  // Marking layer for Power (Vdd) PAD for DRC use
LAYER VDDMK1  20567

LAYER MAP  131  DATATYPE  176  20568  // Marking layer for Power (Vss) PAD for DRC use
LAYER VSSMK1  20568

LAYER MAP  131  DATATYPE  177  20569  // dummy layer for designer to waive LU.1~LU.3 violation
LAYER LUWMK1  20569

LAYER MAP  131  DATATYPE  178  20570
LAYER RES2H  20570  // DRC marking layer to identify resistor with resistance larger than 200ohm

LAYER MAP  131  DATATYPE  179  20571
LAYER RESH  20571  // DRC marking layer to identify resistor with resistance less than 200ohm

LAYER MAP  139  DATATYPE  0  24000
LAYER DCTY  24000

LAYER MAP  239  DATATYPE  1  24001
LAYER EXDFM  24001  // DFM erorrs waive

LAYER MAP  239  DATATYPE  2  24002
LAYER EXLFD  24002  // LFD erorrs waive

LAYER MAP  212  DATATYPE  1  24003
LAYER INDR  24003  // LVS mark layer for inductor radius calculation

LAYER MAP  63  DATATYPE  63  24004
LAYER VSIA  24004  // VSIA tagging layer(Text Only)

LAYER MAP  88  DATATYPE  0  24005
LAYER MAP  88  TEXTTYPE  0  24005
LAYER BTXT  24005  // Text for Block

LAYER MAP  89  DATATYPE  0  24006
LAYER MAP  89  TEXTTYPE  0  24006
LAYER CTXT  24006  // Text for Cell

LAYER MAP  163  DATATYPE  0  24007
LAYER MAP  163  TEXTTYPE  0  24007
LAYER DIFTXT  24007  // Diffusion Pin Text Layer

LAYER MAP  164  DATATYPE  0  24008
LAYER MAP  164  TEXTTYPE  0  24008
LAYER POLYTXT  24008  // Poly Pin Text Layer

LAYER MAP  161  DATATYPE  0  24009
LAYER MAP  161  TEXTTYPE  0  24009
LAYER SUBTXT  24009  // Substrate Pin Text Layer

LAYER MAP  87  DATATYPE  0  24010
LAYER MAP  87  TEXTTYPE  0  24010
LAYER TTXT  24010  // Text for Top Structure

LAYER MAP  162  DATATYPE  0  24011
LAYER MAP  162  TEXTTYPE  0  24011
LAYER WELTXT  24011  // Wells Pin Text Layer

LAYER MAP  120  DATATYPE 200  21600
LAYER TM1_0Vi  21600  // DRC and LVS marking layer for 0V TM1

LAYER MAP  120  DATATYPE 201  21601
LAYER TM1_0d1V  21601  // DRC and LVS marking layer for 0.1V TM1

LAYER MAP  120  DATATYPE 202  21602
LAYER TM1_0d2V  21602  // DRC and LVS marking layer for 0.2V TM1

LAYER MAP  120  DATATYPE 203  21603
LAYER TM1_0d3V  21603  // DRC and LVS marking layer for 0.3V TM1

LAYER MAP  120  DATATYPE 204  21604
LAYER TM1_0d4V  21604  // DRC and LVS marking layer for 0.4V TM1

LAYER MAP  120  DATATYPE 205  21605
LAYER TM1_0d5V  21605  // DRC and LVS marking layer for 0.5V TM1

LAYER MAP  120  DATATYPE 206  21606
LAYER TM1_0d6V  21606  // DRC and LVS marking layer for 0.6V TM1

LAYER MAP  120  DATATYPE 207  21607
LAYER TM1_0d7V  21607  // DRC and LVS marking layer for 0.7V TM1

LAYER MAP  120  DATATYPE 208  21608
LAYER TM1_0d8V  21608  // DRC and LVS marking layer for 0.8V TM1

LAYER MAP  120  DATATYPE 209  21609
LAYER TM1_0d9V  21609  // DRC and LVS marking layer for 0.9V TM1

LAYER MAP  120  DATATYPE 210  21610
LAYER TM1_1d0V  21610  // DRC and LVS marking layer for 1.0V TM1

LAYER MAP  120  DATATYPE 211  21611
LAYER TM1_1d1V  21611  // DRC and LVS marking layer for 1.1V TM1

LAYER MAP  120  DATATYPE 213  21613
LAYER TM1_1d3V  21613  // DRC and LVS marking layer for 1.3V TM1

LAYER MAP  120  DATATYPE 214  21614
LAYER TM1_1d4V  21614  // DRC and LVS marking layer for 1.4V TM1

LAYER MAP  120  DATATYPE 216  21615
LAYER TM1_1d6V  21615  // DRC and LVS marking layer for 1.6V TM1

LAYER MAP  120  DATATYPE 217  21616
LAYER TM1_1d7V  21616  // DRC and LVS marking layer for 1.7V TM1

LAYER MAP  120  DATATYPE 212  22059
LAYER TM1V12i  22059  // DRC and LVS marking layer for 1.2V TM1

LAYER MAP  120  DATATYPE 215  22060
LAYER TM1V15i  22060  // DRC and LVS marking layer for 1.5V TM1

LAYER MAP  120  DATATYPE 218  22061
LAYER TM1V18i  22061  // DRC and LVS marking layer for 1.8V TM1

LAYER MAP  120  DATATYPE 225  22062
LAYER TM1V25i  22062  // DRC and LVS marking layer for 2.5V TM1

LAYER MAP  120  DATATYPE 226  22063
LAYER TM1V33i  22063  // DRC and LVS marking layer for 3.3V TM1

LAYER MAP  120  DATATYPE 227  22065
LAYER TM1V50i  22065  // DRC and LVS marking layer for 5.0V TM1

LAYER MAP  120  DATATYPE 228  22066
LAYER TM1V70i  22066  // DRC and LVS marking layer for 7.0V TM1

LAYER MAP  122  DATATYPE 200  22200
LAYER TM2_0Vi  22200  // DRC and LVS marking layer for 0V TM2

LAYER MAP  122  DATATYPE 201  22201
LAYER TM2_0d1V  22201  // DRC and LVS marking layer for 0.1V TM2

LAYER MAP  122  DATATYPE 202  22202
LAYER TM2_0d2V  22202  // DRC and LVS marking layer for 0.2V TM2

LAYER MAP  122  DATATYPE 203  22203
LAYER TM2_0d3V  22203  // DRC and LVS marking layer for 0.3V TM2

LAYER MAP  122  DATATYPE 204  22204
LAYER TM2_0d4V  22204  // DRC and LVS marking layer for 0.4V TM2

LAYER MAP  122  DATATYPE 205  22205
LAYER TM2_0d5V  22205  // DRC and LVS marking layer for 0.5V TM2

LAYER MAP  122  DATATYPE 206  22206
LAYER TM2_0d6V  22206  // DRC and LVS marking layer for 0.6V TM2

LAYER MAP  122  DATATYPE 207  22207
LAYER TM2_0d7V  22207  // DRC and LVS marking layer for 0.7V TM2

LAYER MAP  122  DATATYPE 208  22208
LAYER TM2_0d8V  22208  // DRC and LVS marking layer for 0.8V TM2

LAYER MAP  122  DATATYPE 209  22209
LAYER TM2_0d9V  22209  // DRC and LVS marking layer for 0.9V TM2

LAYER MAP  122  DATATYPE 210  22210
LAYER TM2_1d0V  22210  // DRC and LVS marking layer for 1.0V TM2

LAYER MAP  122  DATATYPE 211  22211
LAYER TM2_1d1V  22211  // DRC and LVS marking layer for 1.1V TM2

LAYER MAP  122  DATATYPE 213  22213
LAYER TM2_1d3V  22213  // DRC and LVS marking layer for 1.3V TM2

LAYER MAP  122  DATATYPE 214  22214
LAYER TM2_1d4V  22214  // DRC and LVS marking layer for 1.4V TM2

LAYER MAP  122  DATATYPE 216  22215
LAYER TM2_1d6V  22215  // DRC and LVS marking layer for 1.6V TM2

LAYER MAP  122  DATATYPE 217  22216
LAYER TM2_1d7V  22216  // DRC and LVS marking layer for 1.7V TM2

LAYER MAP  122  DATATYPE 212  22159
LAYER TM2V12i  22159  // DRC and LVS marking layer for 1.2V TM2

LAYER MAP  122  DATATYPE 215  22160
LAYER TM2V15i  22160  // DRC and LVS marking layer for 1.5V TM2

LAYER MAP  122  DATATYPE 218  22161
LAYER TM2V18i  22161  // DRC and LVS marking layer for 1.8V TM2

LAYER MAP  122  DATATYPE 225  22162
LAYER TM2V25i  22162  // DRC and LVS marking layer for 2.5V TM2

LAYER MAP  122  DATATYPE 226  22163
LAYER TM2V33i  22163  // DRC and LVS marking layer for 3.3V TM2

LAYER MAP  122  DATATYPE 227  22165
LAYER TM2V50i  22165  // DRC and LVS marking layer for 5.0V TM2

LAYER MAP  122  DATATYPE 228  22166
LAYER TM2V70i  22166  // DRC and LVS marking layer for 7.0V TM2

//;LAYER MAP  140  DATATYPE 200  22300
//;LAYER TM3_0Vi  22300  // DRC and LVS marking layer for 0V TM3
TM3_0Vi = 180 NOT BULK

//;LAYER MAP  140  DATATYPE 201  22301
//;LAYER TM3_0d1V  22301  // DRC and LVS marking layer for 0.1V TM3
TM3_0d1V = 181 NOT BULK

//;LAYER MAP  140  DATATYPE 202  22302
//;LAYER TM3_0d2V  22302  // DRC and LVS marking layer for 0.2V TM3
TM3_0d2V = 182 NOT BULK

//;LAYER MAP  140  DATATYPE 203  22303
//;LAYER TM3_0d3V  22303  // DRC and LVS marking layer for 0.3V TM3
TM3_0d3V = 183 NOT BULK

//;LAYER MAP  140  DATATYPE 204  22304
//;LAYER TM3_0d4V  22304  // DRC and LVS marking layer for 0.4V TM3
TM3_0d4V = 184 NOT BULK

//;LAYER MAP  140  DATATYPE 205  22305
//;LAYER TM3_0d5V  22305  // DRC and LVS marking layer for 0.5V TM3
TM3_0d5V = 185 NOT BULK

//;LAYER MAP  140  DATATYPE 206  22306
//;LAYER TM3_0d6V  22306  // DRC and LVS marking layer for 0.6V TM3
TM3_0d6V = 186 NOT BULK

//;LAYER MAP  140  DATATYPE 207  22307
//;LAYER TM3_0d7V  22307  // DRC and LVS marking layer for 0.7V TM3
TM3_0d7V = 187 NOT BULK

//;LAYER MAP  140  DATATYPE 208  22308
//;LAYER TM3_0d8V  22308  // DRC and LVS marking layer for 0.8V TM3
TM3_0d8V = 188 NOT BULK

//;LAYER MAP  140  DATATYPE 209  22309
//;LAYER TM3_0d9V  22309  // DRC and LVS marking layer for 0.9V TM3
TM3_0d9V = 189 NOT BULK

//;LAYER MAP  140  DATATYPE 210  22310
//;LAYER TM3_1d0V  22310  // DRC and LVS marking layer for 1.0V TM3
TM3_1d0V = 190 NOT BULK

//;LAYER MAP  140  DATATYPE 211  22311
//;LAYER TM3_1d1V  22311  // DRC and LVS marking layer for 1.1V TM3
TM3_1d1V = 191 NOT BULK

//;LAYER MAP  140  DATATYPE 213  22313
//;LAYER TM3_1d3V  22313  // DRC and LVS marking layer for 1.3V TM3
TM3_1d3V = 192 NOT BULK

//;LAYER MAP  140  DATATYPE 214  22314
//;LAYER TM3_1d4V  22314  // DRC and LVS marking layer for 1.4V TM3
TM3_1d4V = 193 NOT BULK

//;LAYER MAP  140  DATATYPE 216  22315
//;LAYER TM3_1d6V  22315  // DRC and LVS marking layer for 1.6V TM3
TM3_1d6V = 194 NOT BULK

//;LAYER MAP  140  DATATYPE 217  22316
//;LAYER TM3_1d7V  22316  // DRC and LVS marking layer for 1.7V TM3
TM3_1d7V = 195 NOT BULK

//;LAYER MAP  140  DATATYPE 212  22259
//;LAYER TM3V12i  22259  // DRC and LVS marking layer for 1.2V TM3
TM3V12i = 196 NOT BULK

//;LAYER MAP  140  DATATYPE 215  22260
//;LAYER TM3V15i  22260  // DRC and LVS marking layer for 1.5V TM3
TM3V15i = 197 NOT BULK

//;LAYER MAP  140  DATATYPE 218  22261
//;LAYER TM3V18i  22261  // DRC and LVS marking layer for 1.8V TM3
TM3V18i = 198 NOT BULK

//;LAYER MAP  140  DATATYPE 225  22262
//;LAYER TM3V25i  22262  // DRC and LVS marking layer for 2.5V TM3
TM3V25i = 199 NOT BULK

//;LAYER MAP  140  DATATYPE 226  22263
//;LAYER TM3V33i  22263  // DRC and LVS marking layer for 3.3V TM3
TM3V33i = 200 NOT BULK

//;LAYER MAP  140  DATATYPE 227  22265
//;LAYER TM3V50i  22265  // DRC and LVS marking layer for 5.0V TM3
TM3V50i = 201 NOT BULK

//;LAYER MAP  140  DATATYPE 228  22266
//;LAYER TM3V70i  22266  // DRC and LVS marking layer for 7.0V TM3
TM3V70i = 202 NOT BULK

LAYER MAP  141  DATATYPE 200  22600
LAYER B1_0d0V  22600  // DRC and LVS marking layer for 0V B1

LAYER MAP  141  DATATYPE 201  22601
LAYER B1_0d1V  22601  // DRC and LVS marking layer for 0.1V B1

LAYER MAP  141  DATATYPE 202  22602
LAYER B1_0d2V  22602  // DRC and LVS marking layer for 0.2V B1

LAYER MAP  141  DATATYPE 203  22603
LAYER B1_0d3V  22603  // DRC and LVS marking layer for 0.3V B1

LAYER MAP  141  DATATYPE 204  22604
LAYER B1_0d4V  22604  // DRC and LVS marking layer for 0.4V B1

LAYER MAP  141  DATATYPE 205  22605
LAYER B1_0d5V  22605  // DRC and LVS marking layer for 0.5V B1

LAYER MAP  141  DATATYPE 206  22606
LAYER B1_0d6V  22606  // DRC and LVS marking layer for 0.6V B1

LAYER MAP  141  DATATYPE 207  22607
LAYER B1_0d7V  22607  // DRC and LVS marking layer for 0.7V B1

LAYER MAP  141  DATATYPE 208  22608
LAYER B1_0d8V  22608  // DRC and LVS marking layer for 0.8V B1

LAYER MAP  141  DATATYPE 209  22609
LAYER B1_0d9V  22609  // DRC and LVS marking layer for 0.9V B1

LAYER MAP  141  DATATYPE 210  22610
LAYER B1_1d0V  22610  // DRC and LVS marking layer for 1.0V B1

LAYER MAP  141  DATATYPE 211  22611
LAYER B1_1d1V  22611  // DRC and LVS marking layer for 1.1V B1

LAYER MAP  141  DATATYPE 213  22613
LAYER B1_1d3V  22613  // DRC and LVS marking layer for 1.3V B1

LAYER MAP  141  DATATYPE 214  22614
LAYER B1_1d4V  22614  // DRC and LVS marking layer for 1.4V B1

LAYER MAP  141  DATATYPE 216  22615
LAYER B1_1d6V  22615  // DRC and LVS marking layer for 1.6V B1

LAYER MAP  141  DATATYPE 217  22616
LAYER B1_1d7V  22616  // DRC and LVS marking layer for 1.7V B1

LAYER MAP  142  DATATYPE 200  22700
LAYER B2_0d0V  22700  // DRC and LVS marking layer for 0V B2

LAYER MAP  142  DATATYPE 201  22701
LAYER B2_0d1V  22701  // DRC and LVS marking layer for 0.1V B2

LAYER MAP  142  DATATYPE 202  22702
LAYER B2_0d2V  22702  // DRC and LVS marking layer for 0.2V B2

LAYER MAP  142  DATATYPE 203  22703
LAYER B2_0d3V  22703  // DRC and LVS marking layer for 0.3V B2

LAYER MAP  142  DATATYPE 204  22704
LAYER B2_0d4V  22704  // DRC and LVS marking layer for 0.4V B2

LAYER MAP  142  DATATYPE 205  22705
LAYER B2_0d5V  22705  // DRC and LVS marking layer for 0.5V B2

LAYER MAP  142  DATATYPE 206  22706
LAYER B2_0d6V  22706  // DRC and LVS marking layer for 0.6V B2

LAYER MAP  142  DATATYPE 207  22707
LAYER B2_0d7V  22707  // DRC and LVS marking layer for 0.7V B2

LAYER MAP  142  DATATYPE 208  22708
LAYER B2_0d8V  22708  // DRC and LVS marking layer for 0.8V B2

LAYER MAP  142  DATATYPE 209  22709
LAYER B2_0d9V  22709  // DRC and LVS marking layer for 0.9V B2

LAYER MAP  142  DATATYPE 210  22710
LAYER B2_1d0V  22710  // DRC and LVS marking layer for 1.0V B2

LAYER MAP  142  DATATYPE 211  22711
LAYER B2_1d1V  22711  // DRC and LVS marking layer for 1.1V B2

LAYER MAP  142  DATATYPE 213  22713
LAYER B2_1d3V  22713  // DRC and LVS marking layer for 1.3V B2

LAYER MAP  142  DATATYPE 214  22714
LAYER B2_1d4V  22714  // DRC and LVS marking layer for 1.4V B2

LAYER MAP  142  DATATYPE 216  22715
LAYER B2_1d6V  22715  // DRC and LVS marking layer for 1.6V B2

LAYER MAP  142  DATATYPE 217  22716
LAYER B2_1d7V  22716  // DRC and LVS marking layer for 1.7V B2

//;LAYER MAP  144  DATATYPE 200  22800
//;LAYER E1_0d0V  22800  // DRC and LVS marking layer for 0V E1
E1_0d0V = 203 NOT BULK

//;LAYER MAP  144  DATATYPE 201  22801
//;LAYER E1_0d1V  22801  // DRC and LVS marking layer for 0.1V E1
E1_0d1V = 204 NOT BULK

//;LAYER MAP  144  DATATYPE 202  22802
//;LAYER E1_0d2V  22802  // DRC and LVS marking layer for 0.2V E1
E1_0d2V = 205 NOT BULK

//;LAYER MAP  144  DATATYPE 203  22803
//;LAYER E1_0d3V  22803  // DRC and LVS marking layer for 0.3V E1
E1_0d3V = 206 NOT BULK

//;LAYER MAP  144  DATATYPE 204  22804
//;LAYER E1_0d4V  22804  // DRC and LVS marking layer for 0.4V E1
E1_0d4V = 207 NOT BULK

//;LAYER MAP  144  DATATYPE 205  22805
//;LAYER E1_0d5V  22805  // DRC and LVS marking layer for 0.5V E1
E1_0d5V = 208 NOT BULK

//;LAYER MAP  144  DATATYPE 206  22806
//;LAYER E1_0d6V  22806  // DRC and LVS marking layer for 0.6V E1
E1_0d6V = 209 NOT BULK

//;LAYER MAP  144  DATATYPE 207  22807
//;LAYER E1_0d7V  22807  // DRC and LVS marking layer for 0.7V E1
E1_0d7V = 210 NOT BULK

//;LAYER MAP  144  DATATYPE 208  22808
//;LAYER E1_0d8V  22808  // DRC and LVS marking layer for 0.8V E1
E1_0d8V = 211 NOT BULK

//;LAYER MAP  144  DATATYPE 209  22809
//;LAYER E1_0d9V  22809  // DRC and LVS marking layer for 0.9V E1
E1_0d9V = 212 NOT BULK

//;LAYER MAP  144  DATATYPE 210  22810
//;LAYER E1_1d0V  22810  // DRC and LVS marking layer for 1.0V E1
E1_1d0V = 213 NOT BULK

//;LAYER MAP  144  DATATYPE 211  22811
//;LAYER E1_1d1V  22811  // DRC and LVS marking layer for 1.1V E1
E1_1d1V = 214 NOT BULK

//;LAYER MAP  144  DATATYPE 213  22813
//;LAYER E1_1d3V  22813  // DRC and LVS marking layer for 1.3V E1
E1_1d3V = 215 NOT BULK

//;LAYER MAP  144  DATATYPE 214  22814
//;LAYER E1_1d4V  22814  // DRC and LVS marking layer for 1.4V E1
E1_1d4V = 216 NOT BULK

//;LAYER MAP  144  DATATYPE 216  22815
//;LAYER E1_1d6V  22815  // DRC and LVS marking layer for 1.6V E1
E1_1d6V = 217 NOT BULK

//;LAYER MAP  144  DATATYPE 217  22816
//;LAYER E1_1d7V  22816  // DRC and LVS marking layer for 1.7V E1
E1_1d7V = 218 NOT BULK

//;LAYER MAP  145  DATATYPE 200  22900
//;LAYER E2_0d0V  22900  // DRC and LVS marking layer for 0V E2
E2_0d0V = 219 NOT BULK

//;LAYER MAP  145  DATATYPE 201  22901
//;LAYER E2_0d1V  22901  // DRC and LVS marking layer for 0.1V E2
E2_0d1V = 220 NOT BULK

//;LAYER MAP  145  DATATYPE 202  22902
//;LAYER E2_0d2V  22902  // DRC and LVS marking layer for 0.2V E2
E2_0d2V = 221 NOT BULK

//;LAYER MAP  145  DATATYPE 203  22903
//;LAYER E2_0d3V  22903  // DRC and LVS marking layer for 0.3V E2
E2_0d3V = 222 NOT BULK

//;LAYER MAP  145  DATATYPE 204  22904
//;LAYER E2_0d4V  22904  // DRC and LVS marking layer for 0.4V E2
E2_0d4V = 223 NOT BULK

//;LAYER MAP  145  DATATYPE 205  22905
//;LAYER E2_0d5V  22905  // DRC and LVS marking layer for 0.5V E2
E2_0d5V = 224 NOT BULK

//;LAYER MAP  145  DATATYPE 206  22906
//;LAYER E2_0d6V  22906  // DRC and LVS marking layer for 0.6V E2
E2_0d6V = 225 NOT BULK

//;LAYER MAP  145  DATATYPE 207  22907
//;LAYER E2_0d7V  22907  // DRC and LVS marking layer for 0.7V E2
E2_0d7V = 226 NOT BULK

//;LAYER MAP  145  DATATYPE 208  22908
//;LAYER E2_0d8V  22908  // DRC and LVS marking layer for 0.8V E2
E2_0d8V = 227 NOT BULK

//;LAYER MAP  145  DATATYPE 209  22909
//;LAYER E2_0d9V  22909  // DRC and LVS marking layer for 0.9V E2
E2_0d9V = 228 NOT BULK

//;LAYER MAP  145  DATATYPE 210  22910
//;LAYER E2_1d0V  22910  // DRC and LVS marking layer for 1.0V E2
E2_1d0V = 229 NOT BULK

//;LAYER MAP  145  DATATYPE 211  22911
//;LAYER E2_1d1V  22911  // DRC and LVS marking layer for 1.1V E2
E2_1d1V = 230 NOT BULK

//;LAYER MAP  145  DATATYPE 213  22913
//;LAYER E2_1d3V  22913  // DRC and LVS marking layer for 1.3V E2
E2_1d3V = 231 NOT BULK

//;LAYER MAP  145  DATATYPE 214  22914
//;LAYER E2_1d4V  22914  // DRC and LVS marking layer for 1.4V E2
E2_1d4V = 232 NOT BULK

//;LAYER MAP  145  DATATYPE 216  22915
//;LAYER E2_1d6V  22915  // DRC and LVS marking layer for 1.6V E2
E2_1d6V = 233 NOT BULK

//;LAYER MAP  145  DATATYPE 217  22916
//;LAYER E2_1d7V  22916  // DRC and LVS marking layer for 1.7V E2
E2_1d7V = 234 NOT BULK

//;LAYER MAP  69  DATATYPE 200  28900
//;LAYER M9_0Vi  28900  // DRC and LVS marking layer for 0V M9
M9_0Vi = 235 NOT BULK

//;LAYER MAP  69  DATATYPE 201  28901
//;LAYER M9_0d1V  28901  // DRC and LVS marking layer for 0.1V M9
M9_0d1V = 236 NOT BULK

//;LAYER MAP  69  DATATYPE 202  28902
//;LAYER M9_0d2V  28902  // DRC and LVS marking layer for 0.2V M9
M9_0d2V = 237 NOT BULK

//;LAYER MAP  69  DATATYPE 203  28903
//;LAYER M9_0d3V  28903  // DRC and LVS marking layer for 0.3V M9
M9_0d3V = 238 NOT BULK

//;LAYER MAP  69  DATATYPE 204  28904
//;LAYER M9_0d4V  28904  // DRC and LVS marking layer for 0.4V M9
M9_0d4V = 239 NOT BULK

//;LAYER MAP  69  DATATYPE 205  28905
//;LAYER M9_0d5V  28905  // DRC and LVS marking layer for 0.5V M9
M9_0d5V = 240 NOT BULK

//;LAYER MAP  69  DATATYPE 206  28906
//;LAYER M9_0d6V  28906  // DRC and LVS marking layer for 0.6V M9
M9_0d6V = 241 NOT BULK

//;LAYER MAP  69  DATATYPE 207  28907
//;LAYER M9_0d7V  28907  // DRC and LVS marking layer for 0.7V M9
M9_0d7V = 242 NOT BULK

//;LAYER MAP  69  DATATYPE 208  28908
//;LAYER M9_0d8V  28908  // DRC and LVS marking layer for 0.8V M9
M9_0d8V = 243 NOT BULK

//;LAYER MAP  69  DATATYPE 209  28909
//;LAYER M9_0d9V  28909  // DRC and LVS marking layer for 0.9V M9
M9_0d9V = 244 NOT BULK

//;LAYER MAP  69  DATATYPE 210  28910
//;LAYER M9_1d0V  28910  // DRC and LVS marking layer for 1.0V M9
M9_1d0V = 245 NOT BULK

//;LAYER MAP  69  DATATYPE 211  28911
//;LAYER M9_1d1V  28911  // DRC and LVS marking layer for 1.1V M9
M9_1d1V = 246 NOT BULK

//;LAYER MAP  69  DATATYPE 213  28913
//;LAYER M9_1d3V  28913  // DRC and LVS marking layer for 1.3V M9
M9_1d3V = 247 NOT BULK

//;LAYER MAP  69  DATATYPE 214  28914
//;LAYER M9_1d4V  28914  // DRC and LVS marking layer for 1.4V M9
M9_1d4V = 248 NOT BULK

//;LAYER MAP  69  DATATYPE 216  28915
//;LAYER M9_1d6V  28915  // DRC and LVS marking layer for 1.6V M9
M9_1d6V = 249 NOT BULK

//;LAYER MAP  69  DATATYPE 217  28916
//;LAYER M9_1d7V  28916  // DRC and LVS marking layer for 1.7V M9
M9_1d7V = 250 NOT BULK

LAYER MAP  61  DATATYPE 228  20580
LAYER M1V70i  20580  // DRC and LVS marking layer for 7V M1

LAYER MAP  62  DATATYPE 228  20581
LAYER M2V70i  20581

LAYER MAP  63  DATATYPE 228  20582
LAYER M3V70i  20582

LAYER MAP  64  DATATYPE 228  20583
LAYER M4V70i  20583

LAYER MAP  65  DATATYPE 228  20584
LAYER M5V70i  20584

LAYER MAP  66  DATATYPE 228  20585
LAYER M6V70i  20585

LAYER MAP  67  DATATYPE 228  20586
LAYER M7V70i  20586

LAYER MAP  68  DATATYPE 228  20587
LAYER M8V70i  20587

//;LAYER MAP  69  DATATYPE 228  20588
//;LAYER M9V70i  20588
M9V70i = 251 NOT BULK

LAYER MAP  141  DATATYPE 228  20589
LAYER B1V70i  20589  // DRC and LVS marking layer for 7V B1

LAYER MAP  142  DATATYPE 228  20590
LAYER B2V70i  20590  // DRC and LVS marking layer for 7V B2

//;LAYER MAP  144  DATATYPE 228  20591
//;LAYER E1V70i  20591  // DRC and LVS marking layer for 7V E1
E1V70i = 252 NOT BULK

//;LAYER MAP  145  DATATYPE 228  20592
//;LAYER E2V70i  20592  // DRC and LVS marking layer for 7V E2
E2V70i = 253 NOT BULK

LAYER MAP  61  DATATYPE 234  20600
LAYER M1_SYNC  20600  // DRC and LVS marking layer for sync M1

LAYER MAP  62  DATATYPE 234  20601
LAYER M2_SYNC  20601

LAYER MAP  63  DATATYPE 234  20602
LAYER M3_SYNC  20602

LAYER MAP  64  DATATYPE 234  20603
LAYER M4_SYNC  20603

LAYER MAP  65  DATATYPE 234  20604
LAYER M5_SYNC  20604

LAYER MAP  66  DATATYPE 234  20605
LAYER M6_SYNC  20605

LAYER MAP  67  DATATYPE 234  20606
LAYER M7_SYNC  20606

LAYER MAP  68  DATATYPE 234  20607
LAYER M8_SYNC  20607

//;LAYER MAP  69  DATATYPE 234  20608
//;LAYER M9_SYNC  20608
M9_SYNC = 254 NOT BULK

LAYER MAP  141  DATATYPE 234  20609
LAYER B1_SYNC  20609

LAYER MAP  142  DATATYPE 234  20610
LAYER B2_SYNC  20610

//;LAYER MAP  144  DATATYPE 234  20611
//;LAYER E1_SYNC  20611
E1_SYNC = 255 NOT BULK

//;LAYER MAP  145  DATATYPE 234  20612
//;LAYER E2_SYNC  20612
E2_SYNC = 256 NOT BULK

LAYER MAP  120  DATATYPE 234  20613
LAYER TM1_SYNC  20613

LAYER MAP  122  DATATYPE 234  20614
LAYER TM2_SYNC  20614

//;LAYER MAP  140  DATATYPE 234  20615
//;LAYER TM3_SYNC  20615
TM3_SYNC = 257 NOT BULK

LAYER MAP  83  DATATYPE 234  20616
LAYER ALPA_SYNC  20616

//;LAYER MAP  69  TEXTTYPE 231  20708
//;LAYER M9_V_Lo  20708
M9_V_Lo = 258 NOT BULK

LAYER MAP  141  TEXTTYPE 231  20709
LAYER B1_V_Lo  20709

LAYER MAP  142  TEXTTYPE 231  20710
LAYER B2_V_Lo  20710

//;LAYER MAP  144  TEXTTYPE 231  20711
//;LAYER E1_V_Lo  20711
E1_V_Lo = 259 NOT BULK

//;LAYER MAP  145  TEXTTYPE 231  20712
//;LAYER E2_V_Lo  20712
E2_V_Lo = 260 NOT BULK

LAYER MAP  120  TEXTTYPE 231  20713
LAYER TM1_V_Lo  20713

LAYER MAP  122  TEXTTYPE 231  20714
LAYER TM2_V_Lo  20714

LAYER MAP  14000  TEXTTYPE 231  20720
LAYER UTM_V_Lo  20720

LAYER MAP  83  TEXTTYPE 231  20715
LAYER ALPA_V_Lo  20715

LAYER MAP  10  TEXTTYPE 231  20716
LAYER AA_V_Lo  20716

LAYER MAP  30  TEXTTYPE 231  20717
LAYER GT_V_Lo  20717

LAYER MAP  208  TEXTTYPE 231  20718
LAYER M0G_V_Lo  20718

LAYER MAP  59  TEXTTYPE 231  20719
LAYER M0_V_Lo  20719

//;LAYER MAP  69  TEXTTYPE 230  20808
//;LAYER M9_V_Hi  20808
M9_V_Hi = 102 NOT BULK

LAYER MAP  141  TEXTTYPE 230  20809
LAYER B1_V_Hi  20809

LAYER MAP  142  TEXTTYPE 230  20810
LAYER B2_V_Hi  20810

//;LAYER MAP  144  TEXTTYPE 230  20811
//;LAYER E1_V_Hi  20811
E1_V_Hi = 101 NOT BULK

//;LAYER MAP  145  TEXTTYPE 230  20812
//;LAYER E2_V_Hi  20812
E2_V_Hi = 100 NOT BULK

LAYER MAP  120  TEXTTYPE 230  20813
LAYER TM1_V_Hi  20813

LAYER MAP  122  TEXTTYPE 230  20814
LAYER TM2_V_Hi  20814

LAYER MAP  14000  TEXTTYPE 230  20815
LAYER UTM_V_Hi  20815

LAYER MAP  83  TEXTTYPE 230  20816
LAYER ALPA_V_Hi  20816

LAYER MAP  10  TEXTTYPE 230  20817
LAYER AA_V_Hi  20817

LAYER MAP  30  TEXTTYPE 230  20818
LAYER GT_V_Hi  20818

LAYER MAP  208  TEXTTYPE 230  20819
LAYER M0G_V_Hi  20819

LAYER MAP  59  TEXTTYPE 230  20820
LAYER M0_V_Hi  20820

LAYER MAP  61  TEXTTYPE 233  20900
LAYER M1_V_Lo_TOP  20900  // M1 low voltage top text layer

LAYER MAP  62  TEXTTYPE 233  20901
LAYER M2_V_Lo_TOP  20901

LAYER MAP  63  TEXTTYPE 233  20902
LAYER M3_V_Lo_TOP  20902

LAYER MAP  64  TEXTTYPE 233  20903
LAYER M4_V_Lo_TOP  20903

LAYER MAP  65  TEXTTYPE 233  20904
LAYER M5_V_Lo_TOP  20904

LAYER MAP  66  TEXTTYPE 233  20905
LAYER M6_V_Lo_TOP  20905

LAYER MAP  67  TEXTTYPE 233  20906
LAYER M7_V_Lo_TOP  20906

LAYER MAP  68  TEXTTYPE 233  20907
LAYER M8_V_Lo_TOP  20907

//;LAYER MAP  69  TEXTTYPE 233  20908
//;LAYER M9_V_Lo_TOP  20908
M9_V_Lo_TOP = 98 NOT BULK

LAYER MAP  141  TEXTTYPE 233  20909
LAYER B1_V_Lo_TOP  20909

LAYER MAP  142  TEXTTYPE 233  20910
LAYER B2_V_Lo_TOP  20910

//;LAYER MAP  144  TEXTTYPE 233  20911
//;LAYER E1_V_Lo_TOP  20911
E1_V_Lo_TOP = 97 NOT BULK

//;LAYER MAP  145  TEXTTYPE 233  20912
//;LAYER E2_V_Lo_TOP  20912
E2_V_Lo_TOP = 96 NOT BULK

LAYER MAP  120  TEXTTYPE 233  20913
LAYER TM1_V_Lo_TOP  20913

LAYER MAP  122  TEXTTYPE 233  20914
LAYER TM2_V_Lo_TOP  20914

LAYER MAP  14000  TEXTTYPE 233  20915
LAYER UTM_V_Lo_TOP  20915  //; empty layer for syntax

LAYER MAP  83  TEXTTYPE 233  20916
LAYER ALPA_V_Lo_TOP  20916

LAYER MAP  61  TEXTTYPE 232  21000
LAYER M1_V_Hi_TOP  21000  // M1 high voltage top text layer

LAYER MAP  62  TEXTTYPE 232  21001
LAYER M2_V_Hi_TOP  21001

LAYER MAP  63  TEXTTYPE 232  21002
LAYER M3_V_Hi_TOP  21002

LAYER MAP  64  TEXTTYPE 232  21003
LAYER M4_V_Hi_TOP  21003

LAYER MAP  65  TEXTTYPE 232  21004
LAYER M5_V_Hi_TOP  21004

LAYER MAP  66  TEXTTYPE 232  21005
LAYER M6_V_Hi_TOP  21005

LAYER MAP  67  TEXTTYPE 232  21006
LAYER M7_V_Hi_TOP  21006

LAYER MAP  68  TEXTTYPE 232  21007
LAYER M8_V_Hi_TOP  21007

//;LAYER MAP  69  TEXTTYPE 232  21008
//;LAYER M9_V_Hi_TOP  21008
M9_V_Hi_TOP = 261 NOT BULK

LAYER MAP  141  TEXTTYPE 232  21009
LAYER B1_V_Hi_TOP  21009

LAYER MAP  142  TEXTTYPE 232  21010
LAYER B2_V_Hi_TOP  21010

//;LAYER MAP  144  TEXTTYPE 232  21011
//;LAYER E1_V_Hi_TOP  21011
E1_V_Hi_TOP = 262 NOT BULK

//;LAYER MAP  145  TEXTTYPE 232  21012
//;LAYER E2_V_Hi_TOP  21012
E2_V_Hi_TOP = 263 NOT BULK

LAYER MAP  120  TEXTTYPE 232  21013
LAYER TM1_V_Hi_TOP  21013

LAYER MAP  122  TEXTTYPE 232  21014
LAYER TM2_V_Hi_TOP  21014

LAYER MAP  14000  TEXTTYPE 232  21015
LAYER UTM_V_Hi_TOP  21015

LAYER MAP  83  TEXTTYPE 232  21016
LAYER ALPA_V_Hi_TOP  21016

//;LAYER MAP  2900  DATATYPE 500  21106
//;LAYER UD  21106  // empty layer
UD = 264 NOT BULK

//;LAYER MAP  2900  DATATYPE 600  21107
//;LAYER UDV  21107  // empty layer
UDV = 265 NOT BULK

//;LAYER MAP  2900  DATATYPE 700  21108
//;LAYER UDDG  21108  // empty layer
UDDG = 266 NOT BULK

//;LAYER MAP  29  DATATYPE 2  13470
//;LAYER DGOD  13470  // 1.8V OD 2.5V mark layer
DGOD = 267 NOT BULK

//;LAYER MAP  29  DATATYPE 4  10130
//;LAYER DGOD2  10130  // empty layer
DGOD2 = 268 NOT BULK

//;virtual 4.2V inner metal net voltage maker for delta voltage DRC check
//;LAYER MAP  10001  DATATYPE 13  20551
//;LAYER M1V42ii  20551  // Empty layer
M1V42ii = 269 NOT BULK

//;LAYER MAP  10002  DATATYPE 13  20552
//;LAYER M2V42ii  20552  // Empty layer
M2V42ii = 270 NOT BULK

//;LAYER MAP  10003  DATATYPE 13  20553
//;LAYER M3V42ii  20553  // Empty layer
M3V42ii = 271 NOT BULK

//;LAYER MAP  10004  DATATYPE 13  20554
//;LAYER M4V42ii  20554  // Empty layer
M4V42ii = 272 NOT BULK

//;LAYER MAP  10005  DATATYPE 13  20555
//;LAYER M5V42ii  20555  // Empty layer
M5V42ii = 273 NOT BULK

//;LAYER MAP  10006  DATATYPE 13  20556
//;LAYER M6V42ii  20556  // Empty layer
M6V42ii = 274 NOT BULK

//;LAYER MAP  10007  DATATYPE 13  20557
//;LAYER M7V42ii  20557  // Empty layer
M7V42ii = 275 NOT BULK

//;LAYER MAP  10008  DATATYPE 13  20558
//;LAYER M8V42ii  20558  // Empty layer
M8V42ii = 276 NOT BULK

//;LAYER MAP  12000  DATATYPE 13  22064
//;LAYER TM1V42ii  22064  // Empty layer
TM1V42ii = 277 NOT BULK

//;LAYER MAP  12222  DATATYPE 13  22164
//;LAYER TM2V42ii  22164  // Empty layer
TM2V42ii = 278 NOT BULK

//;LAYER MAP  10029  DATATYPE 13  22264
//;LAYER TM3V42ii  22264  // Empty layer
TM3V42ii = 279 NOT BULK

//;virtual for DRC check
//;LAYER MAP  17900  DATATYPE 110  62730
//;LAYER M5CA  62730  // Marking layer for M5 color A (not defined in DRM)
M5CA = 280 NOT BULK

//;LAYER MAP  17900  DATATYPE 120  62740
//;LAYER M5CB  62740  // Marking layer for M5 color B (not defined in DRM)
M5CB = 281 NOT BULK

//;LAYER MAP  17900  DATATYPE 0  62750
//;LAYER M5DP  62750  // Metal-5 Double Patterning 2nd Mask (not defined in DRM)
M5DP = 282 NOT BULK

//;LAYER MAP  17900  DATATYPE 1  62760
//;LAYER M5DPDUM  62760  // M5DP Dummy Layer(For dummy via insertion) (not defined in DRM)
M5DPDUM = 283 NOT BULK

//;LAYER MAP  17900  DATATYPE 7  62770
//;LAYER M5DPDOP  62770  // M5DP dummy pattern layer is referenced in OPC engineering (not defined in DRM)
M5DPDOP = 284 NOT BULK

//;LAYER MAP  17900  DATATYPE 20  62620  // not defined in DR
//;LAYER M5DPMK  62620  // M5 same color marker layer
M5DPMK = 285 NOT BULK

LAYER MAP  131  DATATYPE 230  14781
LAYER ANMK0  14781  // Marking layer for analog normal level mismatching requirement

LAYER MAP  131  DATATYPE 172  14782
LAYER ANMK1  14782  // Marking layer for analog medium level mismatching requirement

LAYER MAP  131  DATATYPE 173  14783
LAYER ANMK2  14783  // Marking layer for analog high level mismatching requirement

LAYER MAP  89  DATATYPE 166  14785
LAYER ACMK1  14785

LAYER MAP  131 DATATYPE 164  14786
LAYER IOMK1  14786

LAYER MAP  131 DATATYPE 163  14787
LAYER LUAREA1  14787  // Marking layer for Area I/O latch up

LAYER MAP  119 DATATYPE 8  14788
LAYER DIRDMP  14788  // DRC marking layer for TiN resistor manual drawn dummy

LAYER MAP  127 DATATYPE 1  14789
LAYER PRBOUN  14789  // PR Boundary layer

LAYER MAP  11 DATATYPE 200  14790
LAYER DDBTBS_empty  14790  // DRC marking layer for double diffusion break(DDB) STDcell

LAYER MAP  11 DATATYPE 201  14791
LAYER SDBTBS_empty  14791  // DRC marking layer for single diffusion break(SDB) STDcell

LAYER MAP  131 DATATYPE 27  14793
LAYER AR_HDOP  14793  //

LAYER MAP  131 DATATYPE 37  14794
LAYER AR_VDOP  14794  //

LAYER MAP  245 DATATYPE 1  14795
LAYER V0DUM  14795  //

//;LAYER MAP  245 DATATYPE 78  14796
//;LAYER V0DUM_CA  14796  //

//;LAYER MAP  245 DATATYPE 79  14797
//;LAYER V0DUM_CB  14797  //

//;LAYER MAP  89 DATATYPE 198  14798
//;LAYER MXY_14SHK  14798  // Marking layer for M2 shrinkage

//;LAYER MAP  117 DATATYPE 0  14799
//;LAYER CCT  14799  // M0G Double Patterning 2nd mask layer

//;LAYER MAP  117 DATATYPE 1  14800
//;LAYER CCTDUM  14800  // M0GDP dummy pattern layer without OPC engineering

//;LAYER MAP  117 DATATYPE 7  14801
//;LAYER CCTDOP 14801  // M0GDP dummy pattern layer is referenced in OPC engineering

LAYER MAP  135 DATATYPE 6  14802
LAYER BV1DUB 14802  // 2x Via dummy Blockage

LAYER MAP  136 DATATYPE 6  14803
LAYER BV2DUB 14803  // Second 2x Via dummy Blockage

//;LAYER MAP  89 DATATYPE 199  14805
//;LAYER MXY_14SHK1  14805  // Marking layer for M3 shrinkage

LAYER MAP  159 DATATYPE 160  14806
LAYER LFN_N  14806  //

LAYER MAP  159 DATATYPE 170  14807
LAYER LFN_P  14807  //

LAYER MAP  91 DATATYPE 6  14808
LAYER OCCDFH  14808  //

LAYER MAP  91 DATATYPE 10  14809
LAYER OCCDB  14809  //

LAYER MAP  91 DATATYPE 21  15810
LAYER OCCDB1  15810  // Marker layer of BEOL 2xB1 OCCD cell

LAYER MAP  91 DATATYPE 22  14811
LAYER OCCDB2  14811  // Marker layer of BEOL 2xB2 OCCD cell

LAYER MAP  91 DATATYPE 31  14812
LAYER OCOVLAR  14812  // Mark layer for AR-to-PPAA OCOVL

LAYER MAP  91 DATATYPE 32  14813
LAYER OCOVLARH  14813  // Mark layer for ARH-to-PPAA OCOVL

LAYER MAP  91 DATATYPE 33  14814
LAYER OCOVLARV  14814  // Mark layer for ARV-to-PPAA OCOVL

LAYER MAP  91 DATATYPE 34  14815
LAYER OCOVLGT1  14815  // Mark layer for GT-to-PPAA OCOVL

LAYER MAP  91 DATATYPE 35  14816
LAYER OCOVLGT2  14816  // Mark layer for GT-to-AR OCOVL

LAYER MAP  91 DATATYPE 36  14817
LAYER OCOVLP2A  14817  // Mark layer for P2-to-PPAA OCOVL

LAYER MAP  91 DATATYPE 37  14818
LAYER OCOVLP2B  14818  // Mark layer for P2-to-GT OCOVL

LAYER MAP  91 DATATYPE 38  14819
LAYER OCOVLM0C  14819  // Mark layer for M0C-to-GT OCOVL

LAYER MAP  91 DATATYPE 39  14820
LAYER OCOVLM0  14820  // Mark layer for M0-to-GT OCOVL

LAYER MAP  91 DATATYPE 40  14821
LAYER OCOVLM0G1  14821  // Mark layer for M0G-to-GT OCOVL

LAYER MAP  91 DATATYPE 41  14822
LAYER OCOVLM0G2	 14822  // Mark layer for M0G-to-M0C OCOVL

LAYER MAP  91 DATATYPE 44  14825
LAYER OCOVLM1CA  14825  // Mark layer for M1-to-M0 OCOVL

LAYER MAP  91 DATATYPE 45  14826
LAYER OCOVLM1CB  14826  // Mark layer for M1CB-to-M1CA OCOVL

LAYER MAP  91 DATATYPE 46  14827
LAYER OCOVLM2CA  14827  // Mark layer for M2-to-M1 OCOVL

LAYER MAP  91 DATATYPE 47  14828
LAYER OCOVLM4  14828  // Mark layer for M4-to-M3 OCOVL

LAYER MAP  91 DATATYPE 48  14829
LAYER OCOVLV0  14829  // Mark layer for V0-to-M1 OCOVL

//;LAYER MAP  208 DATATYPE 32  14831
//;LAYER M0GCA  14831  //

//;LAYER MAP  208 DATATYPE 33  14832
//;LAYER M0GCB  14832  //

LAYER MAP  58 DATATYPE 11  22000
LAYER MIMDUM  22000  //

LAYER MAP  222 DATATYPE 11  22001
LAYER CTOPDUM  22001  //

LAYER MAP  80 DATATYPE 4  22002
LAYER WTPMK  22002  //

LAYER MAP  131 DATATYPE 202  22003
LAYER MFDMY  22003  //

LAYER MAP  211 DATATYPE 34  22004
LAYER MOMNW  22004  //

LAYER MAP  211 DATATYPE 35  22005
LAYER MOMPW  22005  //

LAYER MAP  211 DATATYPE 36  22006
LAYER MOMSHD1  22006  //

LAYER MAP  211 DATATYPE 37  22007
LAYER MOMSHD2  22007  //

LAYER MAP  211 DATATYPE 38  22008
LAYER MOMSHD3  22008  //

LAYER MAP  211 DATATYPE 39  22009
LAYER MOMSHD4  22009  //

LAYER MAP  211 DATATYPE 40  22010
LAYER MOMSHD5  22010  //

LAYER MAP  211 DATATYPE 41  22011
LAYER MOMSHD6  22011  //

LAYER MAP  211 DATATYPE 42  22012
LAYER MOMSHD7  22012  //

LAYER MAP  58 DATATYPE 6  22013
LAYER MIMDUB  22013  //

LAYER MAP  222 DATATYPE 6  22014
LAYER CTOPDUB  22014  //

LAYER MAP  60 DATATYPE 105  22015
LAYER TRCMK  22015  //

LAYER MAP  211 DATATYPE 53  22016
LAYER MOMM1  22016  //

LAYER MAP  211 DATATYPE 54  22017
LAYER MOMM2  22017  //

//; operation for virtual layer
M1V42i = M1V42ii NOT DRC:1
M2V42i = M2V42ii NOT DRC:1
M3V42i = M3V42ii NOT DRC:1
M4V42i = M4V42ii NOT DRC:1
M5V42i = M5V42ii NOT DRC:1
M6V42i = M6V42ii NOT DRC:1
M7V42i = M7V42ii NOT DRC:1
M8V42i = M8V42ii NOT DRC:1
TM1V42i = TM1V42ii NOT DRC:1
TM2V42i = TM2V42ii NOT DRC:1
TM3V42i = TM3V42ii NOT DRC:1

M1EMPTY9696 = 368 NOT BULK
M2EMPTY9696 = 367 NOT BULK
M3EMPTY9696 = 366 NOT BULK
M4EMPTY9696 = 365 NOT BULK
M5EMPTY9696 = 364 NOT BULK
M6EMPTY9696 = 363 NOT BULK
M7EMPTY9696 = 362 NOT BULK
M8EMPTY9696 = 361 NOT BULK
M9EMPTY9696 = 360 NOT BULK

//*************************************
//     METAL OPTION SETTING CONTROL
//*************************************
//;Vaild metal option setting control
//;Please don't modify below setting

//; *****************************************************************
//; Switches Selection 8: For Guideline Rules Check
//; *****************************************************************
//; Description: For ESD guidelines rules DRC check selection
//; Available options: YES/NO
//; Default: YES
//; Set to 'NO' if not check

//#DEFINE ESD_RULES_CHECK YES				//;valid value is: {YES,NO}

//; Description: For seal ring (SRC_?) guideline rules DRC check selection
//; Available options: YES/NO
//; Default: YES
//; Set to 'NO' if not check

//#DEFINE SEAL_RING_RULES_CHECK YES			//;valid value is: {YES,NO}

//; Description: For EFUSE guideline rules DRC check selection
//; Available options: YES/NO
//; Default: YES
//; Set to 'NO' if not check

//#DEFINE EFUSE_RULES_CHECK YES				//;valid value is: {YES,NO}

//; *****************************************************************
//; Switches Selection 12: For Special Rules Check
//; *****************************************************************
//; Description: For GT.R.13 floating gate rules check. Can be turn-off for IP level DRC check
//; Available options: YES/NO
//; Default: YES
//; Set to 'NO' if not check

//#DEFINE GT_R_13_FLOATING_GATE_CHECK YES			//;valid value is: {YES,NO}

GROUP GDEVICE GHR GRESNW GDSTR GGATED GBJT GVAR
GROUP GFEOL GCELLB GFIN GAA GAR GDNW GNW GDNW GPSUB GVT GDG GGT GEGATE GGT_P96 GGTDMP GP2 GSN GSP GM0 GM0DMP GM0C GM0G GM0GDMP GV0 GRV0 GRSPMK1 GBM0 GBV0 GINST GDEVICE
#IFDEF LATCH_UP_RULES_CHECK NO
GROUP GBEOL GM1 GM2 GM3 Vy? RVy? 125xmy? 125xm? 125xv? 125xRv? GPA GALPA GWBPAD GMD GMOM GMIM GCTOP GEFU GBEOL_2X_10X_14X_UTM
#ELSE
GROUP GBEOL GM1 GM2 GM3 Vy? RVy? 125xmy? 125xm? 125xv? 125xRv? GPA GALPA GWBPAD GMD GMOM GMIM GCTOP GEFU GBEOL_2X_10X_14X_UTM GLU
#ENDIF
#IFDEF FEOL_RULES_CHECK NO
DRC UNSELECT CHECK GFEOL
#ENDIF
#IFDEF BEOL_RULES_CHECK NO
DRC UNSELECT CHECK GBEOL
#ENDIF
#IFDEF DUMMY_RULES_CHECK NO
DRC UNSELECT CHECK GDUMC
#ENDIF

// 8 0 40 0 40 0 40 40 50 55 50 50 50 55 NO NO NO NO NO NO NO NO NO 10 NO 1P8M_DV_3DM_Q1_3Q2_TMa
GROUP GBEOL_2X_10X_14X_UTM 10xTV? 10xTM?
 
// ############################################
// metal stack configuration control
// ############################################
// ---------------------------------------------------------------------------------------------
// generate the layer list for all metal and via
// --------------metal-1~metal-9 selection------------------------------------------------------
 
M1 = COPY M1i
M1DOP = COPY M1DOPi
M1RES = COPY M1R
DUM_M1 = OR M1DUM M1DOP M1DPDUM M1DPDOP
M1_all = (M1 OR (M1DUM OR M1DOP)) OR (M1DP OR (M1DPDUM OR M1DPDOP))
M1V00 = COPY M1_0Vi
M1V01 = COPY M1_0d1V
M1V02 = COPY M1_0d2V
M1V03 = COPY M1_0d3V
M1V04 = COPY M1_0d4V
M1V05 = COPY M1_0d5V
M1V06 = COPY M1_0d6V
M1V07 = COPY M1_0d7V
M1V08 = COPY M1_0d8V
M1V09 = COPY M1_0d9V
M1V10 = COPY M1_1d0V
M1V11 = COPY M1_1d1V
M1V13 = COPY M1_1d3V
M1V14 = COPY M1_1d4V
M1V16 = COPY M1_1d6V
M1V17 = COPY M1_1d7V
M1V12 = COPY M1V12i
M1V15 = COPY M1V15i
M1V18 = COPY M1V18i
M1V25 = COPY M1V25i
M1V33 = COPY M1V33i
M1V42 = COPY M1V42i
M1V50 = COPY M1V50i
M1V70 = COPY M1V70i
M1V_H = COPY M1_V_Hi
M1V_L = COPY M1_V_Lo
M1V_H_TOP = COPY M1_V_Hi_TOP
M1V_L_TOP = COPY M1_V_Lo_TOP
M1V_SYNCH = COPY M1_SYNC
 
M2 = COPY M2i
M2DOP = COPY M2DOPi
M2RES = COPY M2R
DUM_M2 = OR M2DUM M2DOP M2DPDUM M2DPDOP
M2_all = (M2 OR (M2DUM OR M2DOP)) OR (M2DP OR (M2DPDUM OR M2DPDOP))
M2V00 = COPY M2_0Vi
M2V01 = COPY M2_0d1V
M2V02 = COPY M2_0d2V
M2V03 = COPY M2_0d3V
M2V04 = COPY M2_0d4V
M2V05 = COPY M2_0d5V
M2V06 = COPY M2_0d6V
M2V07 = COPY M2_0d7V
M2V08 = COPY M2_0d8V
M2V09 = COPY M2_0d9V
M2V10 = COPY M2_1d0V
M2V11 = COPY M2_1d1V
M2V13 = COPY M2_1d3V
M2V14 = COPY M2_1d4V
M2V16 = COPY M2_1d6V
M2V17 = COPY M2_1d7V
M2V12 = COPY M2V12i
M2V15 = COPY M2V15i
M2V18 = COPY M2V18i
M2V25 = COPY M2V25i
M2V33 = COPY M2V33i
M2V42 = COPY M2V42i
M2V50 = COPY M2V50i
M2V70 = COPY M2V70i
M2V_H = COPY M2_V_Hi
M2V_L = COPY M2_V_Lo
M2V_H_TOP = COPY M2_V_Hi_TOP
M2V_L_TOP = COPY M2_V_Lo_TOP
M2V_SYNCH = COPY M2_SYNC
 
M3 = COPY M3i
M3DOP = COPY M3DOPi
M3RES = COPY M3R
DUM_M3 = OR M3DUM M3DOP M3DPDUM M3DPDOP
M3_all = (M3 OR (M3DUM OR M3DOP)) OR (M3DP OR (M3DPDUM OR M3DPDOP))
M3V00 = COPY M3_0Vi
M3V01 = COPY M3_0d1V
M3V02 = COPY M3_0d2V
M3V03 = COPY M3_0d3V
M3V04 = COPY M3_0d4V
M3V05 = COPY M3_0d5V
M3V06 = COPY M3_0d6V
M3V07 = COPY M3_0d7V
M3V08 = COPY M3_0d8V
M3V09 = COPY M3_0d9V
M3V10 = COPY M3_1d0V
M3V11 = COPY M3_1d1V
M3V13 = COPY M3_1d3V
M3V14 = COPY M3_1d4V
M3V16 = COPY M3_1d6V
M3V17 = COPY M3_1d7V
M3V12 = COPY M3V12i
M3V15 = COPY M3V15i
M3V18 = COPY M3V18i
M3V25 = COPY M3V25i
M3V33 = COPY M3V33i
M3V42 = COPY M3V42i
M3V50 = COPY M3V50i
M3V70 = COPY M3V70i
M3V_H = COPY M3_V_Hi
M3V_L = COPY M3_V_Lo
M3V_H_TOP = COPY M3_V_Hi_TOP
M3V_L_TOP = COPY M3_V_Lo_TOP
M3V_SYNCH = COPY M3_SYNC
 
M4 = COPY M4_40
M4DOP = COPY M4DOPi
M4RES = COPY M4R
DUM_M4 = OR M4DUM M4DOP
M4_all = M4 OR (M4DUM OR M4DOP)
M4V00 = COPY M4_0Vi
M4V01 = COPY M4_0d1V
M4V02 = COPY M4_0d2V
M4V03 = COPY M4_0d3V
M4V04 = COPY M4_0d4V
M4V05 = COPY M4_0d5V
M4V06 = COPY M4_0d6V
M4V07 = COPY M4_0d7V
M4V08 = COPY M4_0d8V
M4V09 = COPY M4_0d9V
M4V10 = COPY M4_1d0V
M4V11 = COPY M4_1d1V
M4V13 = COPY M4_1d3V
M4V14 = COPY M4_1d4V
M4V16 = COPY M4_1d6V
M4V17 = COPY M4_1d7V
M4V12 = COPY M4V12i
M4V15 = COPY M4V15i
M4V18 = COPY M4V18i
M4V25 = COPY M4V25i
M4V33 = COPY M4V33i
M4V42 = COPY M4V42i
M4V50 = COPY M4V50i
M4V70 = COPY M4V70i
M4V_H = COPY M4_V_Hi
M4V_L = COPY M4_V_Lo
M4V_H_TOP = COPY M4_V_Hi_TOP
M4V_L_TOP = COPY M4_V_Lo_TOP
M4V_SYNCH = COPY M4_SYNC
 
M5 = COPY M5_55
M5DOP = COPY M5DOPi
M5RES = COPY M5R
DUM_M5 = OR M5DUM M5DOP
M5_all = M5 OR (M5DUM OR M5DOP)
M5V00 = COPY M5_0Vi
M5V01 = COPY M5_0d1V
M5V02 = COPY M5_0d2V
M5V03 = COPY M5_0d3V
M5V04 = COPY M5_0d4V
M5V05 = COPY M5_0d5V
M5V06 = COPY M5_0d6V
M5V07 = COPY M5_0d7V
M5V08 = COPY M5_0d8V
M5V09 = COPY M5_0d9V
M5V10 = COPY M5_1d0V
M5V11 = COPY M5_1d1V
M5V13 = COPY M5_1d3V
M5V14 = COPY M5_1d4V
M5V16 = COPY M5_1d6V
M5V17 = COPY M5_1d7V
M5V12 = COPY M5V12i
M5V15 = COPY M5V15i
M5V18 = COPY M5V18i
M5V25 = COPY M5V25i
M5V33 = COPY M5V33i
M5V42 = COPY M5V42i
M5V50 = COPY M5V50i
M5V70 = COPY M5V70i
M5V_H = COPY M5_V_Hi
M5V_L = COPY M5_V_Lo
M5V_H_TOP = COPY M5_V_Hi_TOP
M5V_L_TOP = COPY M5_V_Lo_TOP
M5V_SYNCH = COPY M5_SYNC
 
M6 = COPY M6_50
M6DOP = COPY M6DOPi
M6RES = COPY M6R
DUM_M6 = OR M6DUM M6DOP
M6_all = M6 OR (M6DUM OR M6DOP)
M6V00 = COPY M6_0Vi
M6V01 = COPY M6_0d1V
M6V02 = COPY M6_0d2V
M6V03 = COPY M6_0d3V
M6V04 = COPY M6_0d4V
M6V05 = COPY M6_0d5V
M6V06 = COPY M6_0d6V
M6V07 = COPY M6_0d7V
M6V08 = COPY M6_0d8V
M6V09 = COPY M6_0d9V
M6V10 = COPY M6_1d0V
M6V11 = COPY M6_1d1V
M6V13 = COPY M6_1d3V
M6V14 = COPY M6_1d4V
M6V16 = COPY M6_1d6V
M6V17 = COPY M6_1d7V
M6V12 = COPY M6V12i
M6V15 = COPY M6V15i
M6V18 = COPY M6V18i
M6V25 = COPY M6V25i
M6V33 = COPY M6V33i
M6V42 = COPY M6V42i
M6V50 = COPY M6V50i
M6V70 = COPY M6V70i
M6V_H = COPY M6_V_Hi
M6V_L = COPY M6_V_Lo
M6V_H_TOP = COPY M6_V_Hi_TOP
M6V_L_TOP = COPY M6_V_Lo_TOP
M6V_SYNCH = COPY M6_SYNC
 
M7 = COPY M7_55
M7DOP = COPY M7DOPi
M7RES = COPY M7R
DUM_M7 = OR M7DUM M7DOP
M7_all = M7 OR (M7DUM OR M7DOP)
M7V00 = COPY M7_0Vi
M7V01 = COPY M7_0d1V
M7V02 = COPY M7_0d2V
M7V03 = COPY M7_0d3V
M7V04 = COPY M7_0d4V
M7V05 = COPY M7_0d5V
M7V06 = COPY M7_0d6V
M7V07 = COPY M7_0d7V
M7V08 = COPY M7_0d8V
M7V09 = COPY M7_0d9V
M7V10 = COPY M7_1d0V
M7V11 = COPY M7_1d1V
M7V13 = COPY M7_1d3V
M7V14 = COPY M7_1d4V
M7V16 = COPY M7_1d6V
M7V17 = COPY M7_1d7V
M7V12 = COPY M7V12i
M7V15 = COPY M7V15i
M7V18 = COPY M7V18i
M7V25 = COPY M7V25i
M7V33 = COPY M7V33i
M7V42 = COPY M7V42i
M7V50 = COPY M7V50i
M7V70 = COPY M7V70i
M7V_H = COPY M7_V_Hi
M7V_L = COPY M7_V_Lo
M7V_H_TOP = COPY M7_V_Hi_TOP
M7V_L_TOP = COPY M7_V_Lo_TOP
M7V_SYNCH = COPY M7_SYNC
 
 
M1DUM_all = M1DUM OR M1DPDUM
M1DOP_all = M1DOPi OR M1DPDOP
M2DUM_all = M2DUM OR M2DPDUM
M2DOP_all = M2DOPi OR M2DPDOP
M3DUM_all = M3DUM OR M3DPDUM
M3DOP_all = M3DOPi OR M3DPDOP
 
M4DUM_all = COPY M4DUM
M4DOP_all = COPY M4DOPi
M5DUM_all = COPY M5DUM
M5DOP_all = COPY M5DOPi
M6DUM_all = COPY M6DUM
M6DOP_all = COPY M6DOPi
M7DUM_all = COPY M7DUM
M7DOP_all = COPY M7DOPi
M8DUM_all = COPY M8DUM
M8DOP_all = COPY M8DOPi
M9DUM_all = COPY M9DUM
M9DOP_all = COPY M9DOPi
 
V1 = COPY V1_40
V1_all = V1 OR (V1DUM OR V1DOP)
V2 = COPY V2_40
V2_all = V2 OR (V2DUM OR V2DOP)
V3 = COPY V3_40
V3_all = V3 OR (V3DUM OR V3DOP)
V4 = COPY V4_50
V4_all = V4 OR (V4DUM OR V4DOP)
V5 = COPY V5_50
V5_all = V5 OR (V5DUM OR V5DOP)
V6 = COPY V6_50
V6_all = V6 OR (V6DUM OR V6DOP)
 
V1DUM_all = COPY V1DUM
// OR V1DPDUM
V1DOP_all = COPY V1DOP
// OR V1DPDOP
V2DUM_all = COPY V2DUM
// OR V2DPDUM
V2DOP_all = COPY V2DOP
// OR V2DPDOP
V3DUM_all = COPY V3DUM
// OR V3DPDUM
V3DOP_all = COPY V3DOP
// OR V3DPDOP
V4DUM_all = COPY V4DUM
V4DOP_all = COPY V4DOP
V5DUM_all = COPY V5DUM
V5DOP_all = COPY V5DOP
V6DUM_all = COPY V6DUM
V6DOP_all = COPY V6DOP
V7DUM_all = COPY V7DUM
V7DOP_all = COPY V7DOP
V8DUM_all = COPY V8DUM
V8DOP_all = COPY V8DOP
 
TV2 = COPY TV2i
TM2 = COPY TM2i
TM2RES = COPY TM2R
TV2_all = TV2 OR TV2DUM
TM2_all = TM2 OR TM2DUM
TM2V00 = COPY TM2_0Vi
TM2V01 = COPY TM2_0d1V
TM2V02 = COPY TM2_0d2V
TM2V03 = COPY TM2_0d3V
TM2V04 = COPY TM2_0d4V
TM2V05 = COPY TM2_0d5V
TM2V06 = COPY TM2_0d6V
TM2V07 = COPY TM2_0d7V
TM2V08 = COPY TM2_0d8V
TM2V09 = COPY TM2_0d9V
TM2V10 = COPY TM2_1d0V
TM2V11 = COPY TM2_1d1V
TM2V13 = COPY TM2_1d3V
TM2V14 = COPY TM2_1d4V
TM2V16 = COPY TM2_1d6V
TM2V17 = COPY TM2_1d7V
TM2V12 = COPY TM2V12i
TM2V15 = COPY TM2V15i
TM2V18 = COPY TM2V18i
TM2V25 = COPY TM2V25i
TM2V33 = COPY TM2V33i
TM2V42 = COPY TM2V42i
TM2V50 = COPY TM2V50i
TM2V70 = COPY TM2V70i
TM2V_H = COPY TM2_V_Hi
TM2V_L = COPY TM2_V_Lo
TM2V_H_TOP = COPY TM2_V_Hi_TOP
TM2V_L_TOP = COPY TM2_V_Lo_TOP
TM2V_SYNCH = COPY TM2_SYNC

ALPAV_H_TOP = COPY ALPA_V_Hi_TOP
ALPAV_L_TOP = COPY ALPA_V_Lo_TOP
ALPAV_H = COPY ALPA_V_Hi
ALPAV_L = COPY ALPA_V_Lo
ALPAV_SYNCH = COPY ALPA_SYNC

AAV_H = COPY AA_V_Hi
AAV_L = COPY AA_V_Lo
GTV_H = COPY GT_V_Hi
GTV_L = COPY GT_V_Lo

M0GV_H = COPY M0G_V_Hi
M0GV_L = COPY M0G_V_Lo
M0V_H = COPY M0_V_Hi
M0V_L = COPY M0_V_Lo

M8 = COPY TM2
V7 = COPY TV2
M8_all = COPY TM2_all
V7_all = COPY TV2_all
V7_SR = COPY TV2_SR
DVK_V7_SR = COPY DVK_TV2_SR
DVK_V7_SQ = COPY DVK_TV2_SQ
DVK_V7_RE = COPY DVK_TV2_RE
M8V12 = COPY TM2V12
M8V15 = COPY TM2V15
M8V18 = COPY TM2V18
M8V25 = COPY TM2V25
M8V33 = COPY TM2V33
M8V42 = COPY TM2V42
M8V50 = COPY TM2V50
M8V70 = COPY TM2V70
M8V00 = COPY TM2V00
M8V01 = COPY TM2V01
M8V02 = COPY TM2V02
M8V03 = COPY TM2V03
M8V04 = COPY TM2V04
M8V05 = COPY TM2V05
M8V06 = COPY TM2V06
M8V07 = COPY TM2V07
M8V08 = COPY TM2V08
M8V09 = COPY TM2V09
M8V10 = COPY TM2V10
M8V11 = COPY TM2V11
M8V13 = COPY TM2V13
M8V14 = COPY TM2V14
M8V16 = COPY TM2V16
M8V17 = COPY TM2V17
M8V_H = COPY TM2V_H
M8V_L = COPY TM2V_L
M8V_H_TOP = COPY TM2V_H_TOP
M8V_L_TOP = COPY TM2V_L_TOP
M8V_SYNCH = COPY TM2V_SYNCH
M8RES = COPY TM2RES
 
// --------------------------------Top via/metal,Top-1 via/metal------------------------
TM_no_mapping = COPY TM2
TV_no_mapping = COPY TV2
TM_1_no_mapping = COPY M7
TV_1_no_mapping = COPY V6
TM = COPY M8
TV = COPY V7
TM_1 = COPY M7
TV_1 = COPY V6
// Special hints for users
 
// ============================
// Global Variables For DRC
// ============================
// Variables relate to design value

VARIABLE GLOBAL_TOLERANCE 0.001  //;Tolerance for DRC check

VARIABLE AA_MiniWidth 0.09
VARIABLE GT_MiniWidth 0.016
VARIABLE P2_MiniWidth 0.048
VARIABLE NW_MiniWidth 0.214
VARIABLE SN_MiniWidth 0.192
VARIABLE SP_MiniWidth 0.192
VARIABLE M0_MiniWidth 0.040
VARIABLE M0G_MiniWidth 0.032
VARIABLE M0C_MiniWidth 0.048
VARIABLE V0_MiniWidth 0.032
VARIABLE V1_MiniWidth 0.024
VARIABLE M1_MiniWidth 0.032
VARIABLE M1_MiniSpace 0.032

VARIABLE FIN_PITCH 0.048
VARIABLE FIN_WIDTH 0.010
VARIABLE FIN_SPACE FIN_PITCH - FIN_WIDTH
VARIABLE FIN_ENCLOSED_CELLB 0.019
VARIABLE FIN_ENCLOSED_AA 0.019

VARIABLE P2_MaxiWidth 0.130
VARIABLE GT_MaxiWidth 0.242
VARIABLE GT_MaxiWidth_PLUS GT_MaxiWidth+0.01
VARIABLE AR_MaxiWidth 0.020
VARIABLE AR_MaxiWidth_PLUS AR_MaxiWidth+0.001

VARIABLE NW_MiniArea 0.32
VARIABLE SN_MiniArea 0.087
VARIABLE SP_MiniArea 0.087
VARIABLE VT_MiniArea 0.085

VARIABLE M0C_VerSpace_inPowerRail 0.014

// ============================
// AA transform
// ============================
AA = COPY AAi
AR = COPY ARi
GT = COPY GTi

AADUM = COPY AADUMi
AADOP = COPY AADOPi
AADMP = COPY AADMPi

GTDUM = COPY GTDUMi
GTDOP = COPY GTDOPi
GTDMP = COPY GTDMPi

GTMK1 = COPY GTMK1i
GTMK2 = COPY GTMK2i
CELLB = COPY CELLBi

// ============================
// V0 and butted V0 derivations
// ============================
V0N_raw = RECTANGLE V0i == 0.032 BY == 0.032
RV0_raw = RECTANGLE V0i == 0.032 BY == 0.080
V0_B0_both_side_with_V0 = V0_B0 INTERACT V0N_raw == 2
//;V0_B1_both_side_with_V0 = V0_B1 INTERACT V0N_raw == 2
//;V0_B2_both_side_with_V0 = V0_B2 INTERACT V0N_raw == 2

butted_V0 = copy V0_B0_both_side_with_V0 //;V0_B1_both_side_with_V0 V0_B2_both_side_with_V0
non_butted_V0 = V0i NOT INTERACT butted_V0
V0 = OR butted_V0 non_butted_V0

// ============================
// M0 and butted M0 derivations
// ============================
M0_040_raw = M0i WITH WIDTH == 0.040
M0_042_raw = M0i WITH WIDTH == 0.042
M0_054_raw = M0i WITH WIDTH == 0.054
butted_M0_B1 = M0_B1 INTERACT M0_040_raw == 2
butted_M0_B2 = M0_B2 INTERACT M0_040_raw == 2
butted_M0_B1_B2 = OR butted_M0_B1 butted_M0_B2
butted_M0_B1_B2_NOT_M0 = butted_M0_B1_B2 NOT M0i
butted_M0_B1_B2_NOT_M0_NOT_M0C = butted_M0_B1_B2_NOT_M0 NOT M0C

butted_M0_TMP = M0_040_raw INTERACT butted_M0_B1_B2
butted_M0 = OR butted_M0_TMP butted_M0_B1_B2
non_butted_M0 = M0i NOT INTERACT butted_M0_B1_B2
M0 = OR butted_M0 non_butted_M0

// ============================
// Common derivations
// ============================
DOP_AA = AADOP OR AADMP
//;DOP_AA = COPY AADMP
AOP_AA = AA OR DOP_AA
DUM_AA = OR AADUM DOP_AA AADOP  // AA dummy
ALL_AA = AA OR DUM_AA
DMP_AA = AA OR AADMP

DOP_GT = GTDOP OR GTDMP
//;DOP_GT = COPY GTDMP
AOP_GT = GT OR DOP_GT
DUM_GT = OR GTDUM DOP_GT GTDOP  // GT dummy
ALL_GT = GT OR DUM_GT
DMP_GT = GT OR GTDMP

DOP_P2 = P2DOP OR P2DMP
//;DOP_P2 = COPY P2DMP
AOP_P2 = P2 OR DOP_P2
DUM_P2 = OR P2DUM DOP_P2 P2DOP  // P2 dummy
ALL_P2 = P2 OR DUM_P2
DMP_P2 = P2 OR P2DMP

DOP_M0 = M0DOP OR M0DMP
//;DOP_M0 = COPY M0DMP
AOP_M0 = M0 OR DOP_M0
DUM_M0 = OR M0DUM DOP_M0 M0DOP  // M0 dummy
ALL_M0 = M0 OR DUM_M0
DMP_M0 = M0 OR M0DMP

DOP_M0C = M0CDOP OR M0CDMP
//;DOP_M0C = COPY M0CDMP
AOP_M0C = M0C OR DOP_M0C
DUM_M0C = OR M0CDUM DOP_M0C M0CDOP  // M0C dummy
ALL_M0C = M0C OR DUM_M0C
DMP_M0C = M0C OR M0CDMP

DOP_M0G = M0GDOP OR M0GDMP
//;DOP_M0G = COPY M0GDMP
AOP_M0G = M0G OR DOP_M0G
DUM_M0G = OR M0GDUM DOP_M0G M0GDOP  // M0G dummy
ALL_M0G = M0G OR DUM_M0G
DMP_M0G = M0G OR M0GDMP

DUM_AR = ARDUM OR ARDOP
AR_ARDOP = OR AR ARDOP
AR_H = COPY AR_Hi
AR_V = COPY AR_Vi
ALL_AR = OR AR_ARDOP ARDUM
ALL_AR_H = AR_Hi OR AR_HDOP
ALL_AR_V = AR_Vi OR AR_VDOP
ALL_AR_H_V = OR ALL_AR_H ALL_AR_V

DUM_V0 = OR V0DUM V0DPDUM
DUM_V1 = OR V1DUM_all V1DOP_all
DUM_V2 = OR V2DUM_all V2DOP_all
DUM_V3 = OR V3DUM_all V3DOP_all

DUM_B1i = B1DUM OR B1DOP
DUM_B2i = B2DUM OR B2DOP

ALL_SN_SP = SN OR SP
ALL_GTMK12 = GTMK1 OR GTMK2

MIM_final = copy MIM
CTOP_final = copy CTOP

Dummy_Cell_WO_IMP = DMCB1 NOT DMC1
Dummy_Cell_WI_IMP = DMCB1 AND DMC1


// ============================
// Vertical/Horizontal Edges
// ============================ 
 
GT_h_edges = ANGLE GT == 0
GT_v_edges = ANGLE GT == 90
 
GTDMP_h_edges = ANGLE GTDMP == 0
GTDMP_v_edges = ANGLE GTDMP == 90
 
DMP_GT_h_edges = ANGLE DMP_GT == 0
DMP_GT_v_edges = ANGLE DMP_GT == 90
 
DOP_GT_h_edges = ANGLE DOP_GT == 0
DOP_GT_v_edges = ANGLE DOP_GT == 90
 
AOP_GT_h_edges = ANGLE AOP_GT == 0
AOP_GT_v_edges = ANGLE AOP_GT == 90
 
ALL_GT_h_edges = ANGLE ALL_GT == 0
ALL_GT_v_edges = ANGLE ALL_GT == 90
 
AA_h_edges = ANGLE AA == 0
AA_v_edges = ANGLE AA == 90
 
AADMP_h_edges = ANGLE AADMP == 0
AADMP_v_edges = ANGLE AADMP == 90
 
DMP_AA_h_edges = ANGLE DMP_AA == 0
DMP_AA_v_edges = ANGLE DMP_AA == 90
 
DOP_AA_h_edges = ANGLE DOP_AA == 0
DOP_AA_v_edges = ANGLE DOP_AA == 90
 
AOP_AA_h_edges = ANGLE AOP_AA == 0
AOP_AA_v_edges = ANGLE AOP_AA == 90
 
DUM_AA_h_edges = ANGLE DUM_AA == 0
DUM_AA_v_edges = ANGLE DUM_AA == 90
 
ALL_AA_h_edges = ANGLE ALL_AA == 0
ALL_AA_v_edges = ANGLE ALL_AA == 90
 
P2_h_edges = ANGLE P2 == 0
P2_v_edges = ANGLE P2 == 90
 
CHIPB_h_edges = ANGLE CHIPB == 0
CHIPB_v_edges = ANGLE CHIPB == 90
 
CELLB_h_edges = ANGLE CELLB == 0
CELLB_v_edges = ANGLE CELLB == 90
 
DMCB1_h_edges = ANGLE DMCB1 == 0
DMCB1_v_edges = ANGLE DMCB1 == 90
 
FIN_h_edges = ANGLE FIN == 0
FIN_v_edges = ANGLE FIN == 90
 
AR_h_edges = ANGLE AR == 0
AR_v_edges = ANGLE AR == 90
 
INST_h_edges = ANGLE INST == 0
INST_v_edges = ANGLE INST == 90
 
DG_h_edges = ANGLE DG == 0
DG_v_edges = ANGLE DG == 90
 
M0_h_edges = ANGLE M0 == 0
M0_v_edges = ANGLE M0 == 90
 
M0DMP_h_edges = ANGLE M0DMP == 0
M0DMP_v_edges = ANGLE M0DMP == 90
 
DMP_M0_h_edges = ANGLE DMP_M0 == 0
DMP_M0_v_edges = ANGLE DMP_M0 == 90
 
DOP_M0_h_edges = ANGLE DOP_M0 == 0
DOP_M0_v_edges = ANGLE DOP_M0 == 90
 
AOP_M0_h_edges = ANGLE AOP_M0 == 0
AOP_M0_v_edges = ANGLE AOP_M0 == 90
 
ALL_M0_h_edges = ANGLE ALL_M0 == 0
ALL_M0_v_edges = ANGLE ALL_M0 == 90
 
M0C_h_edges = ANGLE M0C == 0
M0C_v_edges = ANGLE M0C == 90
 
M0_NOT_M0C_h_edges = ANGLE M0_NOT_M0C == 0
M0_NOT_M0C_v_edges = ANGLE M0_NOT_M0C == 90
 
M0CDMP_h_edges = ANGLE M0CDMP == 0
M0CDMP_v_edges = ANGLE M0CDMP == 90
 
DMP_M0C_h_edges = ANGLE DMP_M0C == 0
DMP_M0C_v_edges = ANGLE DMP_M0C == 90
 
DOP_M0C_h_edges = ANGLE DOP_M0C == 0
DOP_M0C_v_edges = ANGLE DOP_M0C == 90
 
AOP_M0C_h_edges = ANGLE AOP_M0C == 0
AOP_M0C_v_edges = ANGLE AOP_M0C == 90
 
M0G_h_edges = ANGLE M0G == 0
M0G_v_edges = ANGLE M0G == 90
 
M0GDMP_h_edges = ANGLE M0GDMP == 0
M0GDMP_v_edges = ANGLE M0GDMP == 90
 
DMP_M0G_h_edges = ANGLE DMP_M0G == 0
DMP_M0G_v_edges = ANGLE DMP_M0G == 90
 
DOP_M0G_h_edges = ANGLE DOP_M0G == 0
DOP_M0G_v_edges = ANGLE DOP_M0G == 90
 
AOP_M0G_h_edges = ANGLE AOP_M0G == 0
AOP_M0G_v_edges = ANGLE AOP_M0G == 90
 
ALL_M0G_h_edges = ANGLE ALL_M0G == 0
ALL_M0G_v_edges = ANGLE ALL_M0G == 90
 
ALL_M0C_h_edges = ANGLE ALL_M0C == 0
ALL_M0C_v_edges = ANGLE ALL_M0C == 90
 
V0_h_edges = ANGLE V0 == 0
V0_v_edges = ANGLE V0 == 90
 
DMPNP_h_edges = ANGLE DMPNP == 0
DMPNP_v_edges = ANGLE DMPNP == 90
 
M0_B1_h_edges = ANGLE M0_B1 == 0
M0_B1_v_edges = ANGLE M0_B1 == 90
 
M0_B2_h_edges = ANGLE M0_B2 == 0
M0_B2_v_edges = ANGLE M0_B2 == 90
 
NODMF_h_edges = ANGLE NODMF == 0
NODMF_v_edges = ANGLE NODMF == 90
 
DIR_h_edges = ANGLE DIR == 0
DIR_v_edges = ANGLE DIR == 90
 
DIRDMP_h_edges = ANGLE DIRDMP == 0
DIRDMP_v_edges = ANGLE DIRDMP == 90
 
PPAA_h_edges = ANGLE PPAA == 0
PPAA_v_edges = ANGLE PPAA == 90
 
RSPMK1_h_edges = ANGLE RSPMK1 == 0
RSPMK1_v_edges = ANGLE RSPMK1 == 90
 
OCCD_h_edges = ANGLE OCCD == 0
OCCD_v_edges = ANGLE OCCD == 90
 
OCCDFH_h_edges = ANGLE OCCDFH == 0
OCCDFH_v_edges = ANGLE OCCDFH == 90
 
M1_h_edges = ANGLE M1 == 0
M1_v_edges = ANGLE M1 == 90
 
M2_h_edges = ANGLE M2 == 0
M2_v_edges = ANGLE M2 == 90
 
M3_h_edges = ANGLE M3 == 0
M3_v_edges = ANGLE M3 == 90
 
M4_h_edges = ANGLE M4 == 0
M4_v_edges = ANGLE M4 == 90
 
M5_h_edges = ANGLE M5 == 0
M5_v_edges = ANGLE M5 == 90
 
M6_h_edges = ANGLE M6 == 0
M6_v_edges = ANGLE M6 == 90
 
M7_h_edges = ANGLE M7 == 0
M7_v_edges = ANGLE M7 == 90
 
M8_h_edges = ANGLE M8 == 0
M8_v_edges = ANGLE M8 == 90
 
V1_h_edges = ANGLE V1 == 0
V1_v_edges = ANGLE V1 == 90
 
V2_h_edges = ANGLE V2 == 0
V2_v_edges = ANGLE V2 == 90
 
V3_h_edges = ANGLE V3 == 0
V3_v_edges = ANGLE V3 == 90
 
V4_h_edges = ANGLE V4 == 0
V4_v_edges = ANGLE V4 == 90
 
V5_h_edges = ANGLE V5 == 0
V5_v_edges = ANGLE V5 == 90
 
V6_h_edges = ANGLE V6 == 0
V6_v_edges = ANGLE V6 == 90
 
V7_h_edges = ANGLE V7 == 0
V7_v_edges = ANGLE V7 == 90

// ============================
// For IP level density rule
// ============================
VARIABLE step_number 8

// ============================
// Chip / Extent
// ============================
DRC:1 = EXTENT DRAWN ORIGINAL
BULK = SIZE DRC:1 BY 1.0
PW = (BULK NOT NW) NOT PSUB

CHIP_NOT_ALL_AA = DRC:1 NOT ALL_AA
CHIP_NOT_MARKS = DRC:1 NOT MARKS

NODMF_SIZE_0.4 = SIZE NODMF BY 0.4
NODMF_SIZE_1 = SIZE NODMF BY 1
MARKS_SIZE_1 = SIZE MARKS BY 1
LDNMK1_SIZE_DOWN_3.6 = SIZE LDNMK1 BY -3.6
LDNMK1_NOT_SIZE_36 = LDNMK1 NOT LDNMK1_SIZE_DOWN_3.6

ESDIO_ALL = OR ESDIO1 ESDIO2
ESD_LDBK = OR ESDIO_ALL LDBK
ESD_DG_P96 = OR ESDIO_ALL DG GT_P96
ESD_DG = OR ESDIO_ALL DG

DMCMK1_EFUSE = OR DMCMK1 EFUSE
DMCMK1_MARKS = OR DMCMK1 MARKS
DMCMK2_MARKS = OR DMCMK2 MARKS

OCCD_MARKS = OR MARKS OCCD
OCCD_MARKS_INST = OR OCCD_MARKS INST
OCCD_MARKS_GT_P96 = OR OCCD_MARKS GT_P96

MARKS_INST = OR MARKS INST
MARKS_LDBK = OR MARKS LDBK
MARKS_DMCB1 = OR MARKS DMCB1
MARKS_MARKG = OR MARKS MARKG
MARKS_DMCMK1 = OR MARKS DMCMK1
MARKS_GT_P96 = OR MARKS GT_P96
MARKS_DUM_Cell_WO_IMP = OR MARKS Dummy_Cell_WO_IMP
MARKS_ESDIO_all = OR MARKS ESDIO_ALL
MARKS_LUWMK1 = OR MARKS LUWMK1
MARKS_OCOVL = OR MARKS OCOVL
MARKS_LOGO = OR MARKS LOGO
OCOVL_LOGO = OR OCOVL LOGO

INST_LDBK = OR INST LDBK
INST_OCCD = OR INST OCCD
INST_OCOVL = OR INST OCOVL
INST_DMCB1 = OR DMCB1 INST
INST_DIOMK2 = OR DIOMK2 INST

DRC:1_NOT_INST = SIZE (DRC:1 NOT INST) BY - 0.001
DG_RESNW = OR DG RESNW
MFUSE_rvs_001 = SIZE (DRC:1 NOT MTFUSE) BY - 0.001  //;for DFM check

RSPMK_ALL = copy RSPMK1
SealR_NOT_BULK = MARKS NOT BULK

// ============================
// Diode/BJT/VAR/IND derivation
// ============================
PTAP_in_RWDIO = (PTAP AND DSTR) INSIDE RW  //;inner PTAP inject of rwdio
NTAP_in_NWDIO = NTAP INSIDE DSTR  //;inner NTAP inject of nwdio
PTAP_in_PVART = PTAP AND VARMOS
NTAP_in_NVART = NTAP AND VARMOS
DIODE_BJT_GATED = OR DSTR DMPNP DIOMK1 DIOMK2
DIODE_VAR = OR DSTR VARMOS

NTAP_no_NWR_DIO_VAR = NTAP NOT INTERACT (OR NWR VARMOS NTAP_in_NWDIO)
PTAP_no_RWDIODE_VAR = PTAP NOT INTERACT (OR NWR VARMOS PTAP_in_RWDIO)

INDMY_144 = SIZE INDMY BY 14.4
INDMY_198 = SIZE INDMY BY 19.8

// ============================
// Resistor derivation
// ============================
//;AAR = AA INTERACT RESAA
GTR = GT INTERACT RESP2
NWR = NW INTERACT RESNW
NWRN = NW NOT INTERACT RESNW
NW_0 = NW NOT RESNW
NWDNW = NW INTERACT DNW
RW = ((HOLES NWDNW) NOT NWDNW) INSIDE DNW  //;inner AA of rwdio, base AA & emitter AA of NPN BJT

NWR_BODY = NW AND RESNW
AA_NWR = AA INTERACT NWR
AA_INTERACT_RESNW = AA INTERACT RESNW
ALL_GT_NWR = ALL_GT INTERACT AA_NWR
AA_NWR_T = AA_NWR INTERACT NWR_BODY

// ============================
// S/D derivation
// ============================
AA_0 = AA NOT AR  //;remove fin cut layer
AA_1 = AA AND AR

GATE_raw = GT AND edge_gate_AA_all
GATE = (GT NOT GTMK1) AND AA_0  //;gate
TRGATE = COPY GATE
NGATE = GATE AND SN  //;n+ gate
PGATE = GATE AND SP  //;p+ gate

PAA = AA AND SP
NAA = AA AND SN
PNAA = OR PAA NAA
Ntype_injector = NAA NOT ALL_GT
Ptype_injector = PAA NOT ALL_GT

//;active AA
NACT = NAA NOT NW  //;N+AA
PACT = PAA AND NW  //;P+AA
ACT = NACT OR PACT  //;ACTIVE

//;source/drain/active AA for connection
PSD = PACT NOT ALL_GT
NSD = NACT NOT ALL_GT
SD = PSD OR NSD

real_PSD = PSD INTERACT PGATE
real_NSD = NSD INTERACT NGATE
real_SD = OR real_PSD real_NSD

P_inject = (PACT NOT INTERACT PGATE) NOT GTi
N_inject = (NACT NOT INTERACT NGATE) NOT GTi

//;pick-up AA
SPECIAL_GT_on_TAP_TERMINALS = OR GATED_DIODE_ESD_GATE (GATE_raw INTERACT AA_NWR_T)
NTAPi = (NAA AND NW) NOT SPECIAL_GT_on_TAP_TERMINALS
NTAP = (NAA AND NW_0) NOT SPECIAL_GT_on_TAP_TERMINALS   //;n+ pick-up AA, connection is cutted by RESNW
PTAP = (PAA NOT NW) NOT SPECIAL_GT_on_TAP_TERMINALS   //;p+ pick-up AA
TAP = PTAP OR NTAPi

NTAPi_RAW = NAA AND NW
NTAP_RAW = NAA AND NW_0  //;n+ pick-up AA, connection is cutted by RESNW
PTAP_RAW = PAA NOT NW  //;p+ pick-up AA
TAP_RAW = PTAP OR NTAPi

AA_c = OR PSD NSD NTAP NTAPi PTAP real_PSD real_NSD P_inject N_inject  //;for all AA connect(SD,TAP,resistor terminal)
HR_c = (DIR INTERACT RESP2) NOT RESP2
HR_0 = (DIR INTERACT RESP2) INTERACT RESP1
NWRT = AA_c AND NWR

// ============================
// Standard cell derivation
// ============================
//;Unique Pattern Design Rules for Logic Standard cells
//;1.Logic Standard cells PowerRail Definition:
//;1) M1 width = 0.09um in GATE poly direction
//;2) M1 (width = 0.09um) centerline space = 0.576um for 9T design/0.480um for 7.5T design
//;3) M1 interact with RSPMK1
//;2.DDB design Definition: [The region between two (Logic Standard cells PowerRail)] NOT INTERCACT AR
//;3.SDB design Definition: [The region between two (Logic Standard cells PowerRail)] INTERCACT AR

M1_PowerRail = RSPMK1 INTERACT M1
M1_PowerRail_90_EDGE = DFM SPACE [M1_PowerRail] == 0.09 BY INT VERTICAL
M1_PowerRail_90_AREA = DFM COPY (DFM SPACE M1_PowerRail == 0.09 BY INT VERTICAL) REGION
M1_PowerRail_90T = EXT M1_PowerRail_90_EDGE == 0.576-0.09 OPPOSITE REGION
M1_PowerRail_75T = EXT M1_PowerRail_90_EDGE == 0.480-0.09 OPPOSITE REGION
M1_PowerRail_all = OR M1_PowerRail_90T M1_PowerRail_75T

PowerRail_Area_90T= OR M1_PowerRail_90T (M1_PowerRail_90_AREA AND (EXPAND EDGE (M1_PowerRail_90T COIN EDGE M1_PowerRail_90_EDGE) OUTSIDE BY 0.090))
PowerRail_Area_75T= OR M1_PowerRail_75T (M1_PowerRail_90_AREA AND (EXPAND EDGE (M1_PowerRail_75T COIN EDGE M1_PowerRail_90_EDGE) OUTSIDE BY 0.090))
PowerRail_Area = OR PowerRail_Area_90T PowerRail_Area_75T
PowerRail_Area_BusLine = M1_PowerRail AND PowerRail_Area

PowerRail_centerline_90T = (DFM COPY (DFM SPACE M1_PowerRail == 0.09 BY INT VERTICAL) CENTERLINE) INSIDE EDGE PowerRail_Area_90T
PowerRail_centerline_75T = (DFM COPY (DFM SPACE M1_PowerRail == 0.09 BY INT VERTICAL) CENTERLINE) INSIDE EDGE PowerRail_Area_75T
PowerRail_centerline = (DFM COPY (DFM SPACE M1_PowerRail == 0.09 BY INT VERTICAL) CENTERLINE) INSIDE EDGE PowerRail_Area
PowerRail_centerline_002 = EXPAND EDGE PowerRail_centerline INSIDE BY 0.001 OUTSIDE BY 0.001

VARIABLE PowerRail_grid 0.001
VARIABLE PowerRail_width 0.09
VARIABLE PowerRail_width_half 0.045

SDBTBS_real = (PowerRail_Area INTERACT AR) OR SDBTBS_empty
DDBTBS_real = (PowerRail_Area NOT INTERACT AR) OR DDBTBS_empty

STDB_all = OR DDBTBS_real SDBTBS_real PowerRail_Area

// ============================
// Building Common Connection
// ============================
//;pw for connectivity
PW_0 = BULK NOT NW

// interconnect poly for connectivity
GT_0 = GT NOT P2
GT_i = GT_0 NOT RESP2  //;connection is cutted by RESP2 (HR resistor)

//;local interconnect metal
M0_NOT_M0C_raw = M0 NOT M0C
M0_NOT_M0C_TMP = (butted_M0_B1_B2_NOT_M0_NOT_M0C TOUCH M0C == 2) INSIDE RSPMK_ALL  //;exclude RSPMK1 M0_NOT_M0C in the M0i connection region
M0_NOT_M0C = M0_NOT_M0C_raw NOT M0_NOT_M0C_TMP
M0_0 = M0_NOT_M0C OR M0G

//;MIM derivation for BEOL connection
CTOP_NOT_MIM_final = CTOP_final NOT MIM_final
TV_AND_MIM_no_mapping = TV_no_mapping AND MIM_final
TV_AND_MIM_mapping = TV AND MIM_final
TV_AND_CTOP_no_mapping = TV_no_mapping AND CTOP_NOT_MIM_final
TV_AND_CTOP_mapping = TV AND CTOP_NOT_MIM_final
TV_NOT_MIM_CTOP_no_mapping = TV_no_mapping NOT (MIM_final OR CTOP_NOT_MIM_final)
TV_NOT_MIM_CTOP_mapping = TV NOT (MIM_final OR CTOP_NOT_MIM_final)

// --------------------------------------------------------------
// Beginning of the FEOL/BEOL connection for global DRC check
// --------------------------------------------------------------
CONNECT M0_0 M1 BY V0
CONNECT M0_NOT_M0C M1 BY V0
CONNECT M0G M1 BY V0

CONNECT M0_0 NTAP
CONNECT M0_0 PTAP
CONNECT M0_0 real_PSD
CONNECT M0_0 real_NSD
CONNECT M0_0 P_inject
CONNECT M0_0 N_inject
CONNECT M0_0 PSD
CONNECT M0_0 NSD
CONNECT M0_0 GT_0
CONNECT M0_0 M0_NOT_M0C
CONNECT M0_0 M0G

CONNECT M0_NOT_M0C M0G
CONNECT M0_NOT_M0C NTAP
CONNECT M0_NOT_M0C PTAP
CONNECT M0_NOT_M0C real_PSD
CONNECT M0_NOT_M0C real_NSD
CONNECT M0_NOT_M0C P_inject
CONNECT M0_NOT_M0C N_inject
CONNECT M0_NOT_M0C PSD
CONNECT M0_NOT_M0C NSD
CONNECT M0_NOT_M0C GT_0
CONNECT M0_NOT_M0C NWRT
CONNECT M0G NTAP
CONNECT M0G PTAP
CONNECT M0G real_PSD
CONNECT M0G real_NSD
CONNECT M0G P_inject
CONNECT M0G N_inject
CONNECT M0G PSD
CONNECT M0G NSD
CONNECT M0G GT_0
CONNECT M0G HR_c
CONNECT M0G NWRT

CONNECT AA_c NTAP
CONNECT AA_c PTAP
CONNECT AA_c PSD
CONNECT AA_c NSD
CONNECT AA_c NWRT  // connect NWR terminal
CONNECT real_PSD PSD // pass connectivity from P+ACTIVE to real_PSD
CONNECT real_NSD NSD
CONNECT P_inject PSD // pass connectivity from P+ACTIVE to P_inject
CONNECT N_inject NSD

CONNECT DNW NW
CONNECT NTAP NW
CONNECT PTAP RW
CONNECT PTAP PW_0  // SCONNECT or CONNECT

//; For BEOL mapping layers connection 
CONNECT M1 M2 BY V1
CONNECT M2 M3 BY V2
CONNECT M3 M4 BY V3
CONNECT M4 M5 BY V4
CONNECT M5 M6 BY V5
CONNECT M6 M7 BY V6
CONNECT M7 M8 BY TV_NOT_MIM_CTOP_mapping
CONNECT M8 MIM_final BY TV_AND_MIM_mapping
CONNECT M8 CTOP_final BY TV_AND_CTOP_mapping
CONNECT M8 ALPA BY PA
CONNECT TM_1 TM BY TV_NOT_MIM_CTOP_mapping
CONNECT TM MIM_final BY TV_AND_MIM_mapping
CONNECT TM CTOP_final BY TV_AND_CTOP_mapping
CONNECT TM ALPA BY PA
CONNECT TM PA
CONNECT ALPA MD

//; For top via/metal self-connection
CONNECT TV UTV
CONNECT TM UTM
CONNECT TV TV_AND_MIM_mapping
CONNECT TV TV_AND_CTOP_mapping
CONNECT TV TV_NOT_MIM_CTOP_mapping
CONNECT TV V7
CONNECT TM_1 M7
CONNECT TM M8
CONNECT CTOP_NOT_MIM_final CTOP_final // for MIM check

//; For all via/metal self-connection
CONNECT TM2 M8
CONNECT TV2 V7
// --------------------------------------------------------------
// End of the FEOL/BEOL connection for global DRC check
// --------------------------------------------------------------
 
VIRTUAL CONNECT NAME ?VDD? ?VCC? ?VSS? ?GND?
VIRTUAL CONNECT COLON YES

// ========================
// Virtual connection of dummy layer
// ========================
// For delta voltage rule
#IFDEF Delta_Voltage_Rules_Check YES
CONNECT DOP_M0
CONNECT delta_DOP_M0
CONNECT DOP_M0G
CONNECT DOP_AA
CONNECT DOP_AA_dv
CONNECT DOP_GT
CONNECT DOP_GT_NOT_P2
CONNECT DIRDMP
#ENDIF

// =======================
// NW derivation
// =======================
LVNW = NW NOT DG
HVNW = NW AND DG

DG_or_NW = DG OR NW
DG_not_NW = DG NOT NW
DG_and_NW = DG AND NW
NW_18_volt = NW INTERACT DG

// =======================
// GATE derivation
// =======================
AAEIGT = AA INSIDE EDGE GT
GTEIAA = GT NOT OUTSIDE EDGE AA

AA_OR_GT = AA OR GT
GATE_in_DG = GATE INSIDE DG
GATE_CORE = GATE NOT DG
GATE_IO = GATE AND DG
GATE_noESD = GATE NOT INSIDE ESDIO_ALL
GATE_GT_P96 = GATE INSIDE GT_P96

GATE_WE = GATE COIN EDGE GT     //; channel width
GATE_LE = ((GATE INTERACT (AA_0 NOT GATE) >= 2) COIN EDGE AA) NOT COIN EDGE GTMK1  //; channel length
GATE_LE_14 = GATE WITH EDGE (LENGTH GATE_LE == 0.014)
GATE_LE_16 = GATE WITH EDGE (LENGTH GATE_LE == 0.016)
GATE_LE_18 = GATE WITH EDGE (LENGTH GATE_LE == 0.018)
GATE_LE_20 = GATE WITH EDGE (LENGTH GATE_LE == 0.020)
GATE_LE_22 = GATE WITH EDGE (LENGTH GATE_LE == 0.022)
GATE_LE_24 = GATE WITH EDGE (LENGTH GATE_LE == 0.024)
GATE_LE_32 = GATE WITH EDGE (LENGTH GATE_LE == 0.032)
GATE_LE_34 = GATE WITH EDGE (LENGTH GATE_LE == 0.034)
GATE_LE_36 = GATE WITH EDGE (LENGTH GATE_LE == 0.036)
GATE_LE_GT_70 = GATE WITH EDGE (LENGTH GATE_LE >= 0.070)
GATE_LE_GT_72 = GATE WITH EDGE (LENGTH GATE_LE >= 0.072)

TRGATE_WE = TRGATE COIN EDGE GT  //; channel width
TRGATE_LE = ((TRGATE INTERACT (AA_0 NOT TRGATE) >= 2) COIN EDGE AA) NOT COIN EDGE GTMK1  //; channel length
TRGATE_LE_14 = TRGATE WITH EDGE (LENGTH TRGATE_LE == 0.014)
TRGATE_LE_16 = TRGATE WITH EDGE (LENGTH TRGATE_LE == 0.016)
TRGATE_LE_18 = TRGATE WITH EDGE (LENGTH TRGATE_LE == 0.018)
TRGATE_LE_20 = TRGATE WITH EDGE (LENGTH TRGATE_LE == 0.020)
TRGATE_LE_22 = TRGATE WITH EDGE (LENGTH TRGATE_LE == 0.022)
TRGATE_LE_24 = TRGATE WITH EDGE (LENGTH TRGATE_LE == 0.024)
TRGATE_LE_32 = TRGATE WITH EDGE (LENGTH TRGATE_LE == 0.032)
TRGATE_LE_34 = TRGATE WITH EDGE (LENGTH TRGATE_LE == 0.034)
TRGATE_LE_36 = TRGATE WITH EDGE (LENGTH TRGATE_LE == 0.036)
TRGATE_LE_72 = TRGATE WITH EDGE (LENGTH TRGATE_LE == 0.072)
TRGATE_LE_80 = TRGATE WITH EDGE (LENGTH TRGATE_LE == 0.080)
TRGATE_LE_86 = TRGATE WITH EDGE (LENGTH TRGATE_LE == 0.086)
TRGATE_LE_134 = TRGATE WITH EDGE (LENGTH TRGATE_LE == 0.134)
TRGATE_LE_135 = TRGATE WITH EDGE (LENGTH TRGATE_LE == 0.135)
TRGATE_LE_LT_20 = TRGATE WITH EDGE (LENGTH TRGATE_LE <= 0.020)
TRGATE_LE_LT_24 = TRGATE WITH EDGE (LENGTH TRGATE_LE <= 0.024)
TRGATE_LE_GT_70 = TRGATE WITH EDGE (LENGTH TRGATE_LE >= 0.070)
TRGATE_LE_GT_72 = TRGATE WITH EDGE (LENGTH TRGATE_LE >= 0.072)
TRGATE_LE_LT_36 = TRGATE WITH EDGE (LENGTH TRGATE_LE <= 0.036)
TRGATE_LE_86_134 = OR TRGATE_LE_86 TRGATE_LE_134
TRGATE_LE_80_86_134 = OR TRGATE_LE_80 TRGATE_LE_86 TRGATE_LE_134

//; based on device table
DG_12 = DG AND DGV  //;1.2V UD
DG_15 = DG AND DGUD  //;1.5V UD
DG_18 = DG NOT (OR DGV DGUD DGOD DGOD2)  //;1.8V device
DG_25 = DG AND DGOD  //;2.5V empty layer
DG_33 = DG AND DGOD2  //;3.3V empty layer

GATE_08 = GATE NOT DG
GATE_12 = GATE AND DG_12
GATE_15 = GATE AND DG_15
GATE_18 = GATE AND DG_18
GATE_25 = GATE AND DG_25
GATE_33 = GATE AND DG_33  //;3.3V empty layer

AA_12V = AA AND DG_12
AA_15V = AA AND DG_15
AA_18V = AA AND DG_18
AA_25V = AA AND DG_25
AA_33V = AA AND DG_33

edge_gate = GATE_raw INTERACT AA_v_edges_exp001

// ========================
// GT derivation
// ========================
GT_WL_edges_a = DFM PROPERTY GT GT_h_edges GT_v_edges OVERLAP ABUT ALSO MULTI [h_v_ratio = LENGTH(GT_h_edges) - LENGTH(GT_v_edges)] >= 0
GT_WL_edges_b = DFM PROPERTY GT GT_h_edges GT_v_edges OVERLAP ABUT ALSO MULTI [h_v_ratio = LENGTH(GT_v_edges) - LENGTH(GT_h_edges)] >= 0
GT_W_edges = (GT_v_edges COIN EDGE GT_WL_edges_a) OR EDGE (GT_h_edges COIN EDGE GT_WL_edges_b)
GT_L_edges = (GT_h_edges COIN EDGE GT_WL_edges_a) OR EDGE (GT_v_edges COIN EDGE GT_WL_edges_b)

AOP_GT_WL_edges_a = DFM PROPERTY AOP_GT AOP_GT_h_edges AOP_GT_v_edges OVERLAP ABUT ALSO MULTI [h_v_ratio = LENGTH(AOP_GT_h_edges) - LENGTH(AOP_GT_v_edges)] >= 0
AOP_GT_WL_edges_b = DFM PROPERTY AOP_GT AOP_GT_h_edges AOP_GT_v_edges OVERLAP ABUT ALSO MULTI [h_v_ratio = LENGTH(AOP_GT_v_edges) - LENGTH(AOP_GT_h_edges)] >= 0
AOP_GT_W_edges = (AOP_GT_v_edges COIN EDGE AOP_GT_WL_edges_a) OR EDGE (AOP_GT_h_edges COIN EDGE AOP_GT_WL_edges_b)
AOP_GT_L_edges = (AOP_GT_h_edges COIN EDGE AOP_GT_WL_edges_a) OR EDGE (AOP_GT_v_edges COIN EDGE AOP_GT_WL_edges_b)

channel_width_GT_edge = GT TOUCH EDGE GTEIAA

AOP_GT_noESD = AOP_GT NOT INSIDE ESDIO_ALL
AOP_GT_noESD_SRAM = AOP_GT_noESD NOT INSIDE INST
AOP_GT_noESD_noLAA = AOP_GT_noESD NOT INTERACT L_shape_AA
AOP_GT_in_GT_P96 = AOP_GT INTERACT GT_P96
ALL_GT_NOT_P2_ALL = ALL_GT NOT ALL_P2
ALL_FINAL_GT = ALL_GT NOT ALL_P2
ALL_GT_NOT_P2 = ALL_GT NOT P2
AOP_GT_NOT_P2 = AOP_GT NOT P2
DOP_GT_NOT_P2 = DOP_GT NOT P2
DUM_GT_NOT_P2 = DUM_GT NOT P2

L_SHAPE_AA_EDGE1 = EXT (AA INTERACT GATE) < 0.005 ABUT==90 INTERSECTING ONLY
L_SHAPE_AA_EDGE2 = DFM COPY L_SHAPE_AA_EDGE1 EDGE
L_shape_AA = AA WITH EDGE L_SHAPE_AA_EDGE2

ALL_GT_rect_sides = LENGTH (RECTANGLE ALL_GT) >= 0.001
GT_ALL_rect_short = DFM PROPERTY ALL_GT_rect_sides ALL_GT OVERLAP ABUT ALSO MULTI [-= LENGTH(ALL_GT_rect_sides)/(PERIM(ALL_GT)/4.0)] < 1.0
GT_ALL_rect_long = DFM PROPERTY ALL_GT_rect_sides ALL_GT OVERLAP ABUT ALSO MULTI [-= LENGTH(ALL_GT_rect_sides)/(PERIM(ALL_GT)/4.0)] > 1.0
ALL_GT_line_end = OR EDGE (CONVEX EDGE ALL_GT ANGLE1 == 90 ANGLE2 == 90 WITH LENGTH <= 0.080) GT_ALL_rect_short
ALL_GT_line_end_neighbor_region = INT (ALL_GT COIN EDGE ALL_GT_line_end) ALL_GT <= 0.003 ABUT==90 REGION
ALL_GT_line_end_neighbor = (ALL_GT TOUCH EDGE ALL_GT_line_end_neighbor_region) NOT TOUCH EDGE ALL_GT_line_end

GT_convex_equal_one_edge = CONVEX EDGE GT == 1
GT_convex_equal_two_edge = CONVEX EDGE GT == 2
GT_convex_90_90_edge = CONVEX EDGE GT ANGLE1 == 90 ANGLE2 == 90
GT_convex_90_270_edge = CONVEX EDGE GT ANGLE1 == 90 ANGLE2 == 270
GT_convex_270_270_edge = CONVEX EDGE GT ANGLE1 == 270 ANGLE2 == 270
AOP_GT_convex_equal_one_edge = CONVEX EDGE AOP_GT == 1
AOP_GT_convex_equal_two_edge = CONVEX EDGE AOP_GT == 2
AOP_GT_convex_90_90_edge = CONVEX EDGE AOP_GT ANGLE1 == 90 ANGLE2 == 90
AOP_GT_convex_90_270_edge = CONVEX EDGE AOP_GT ANGLE1 == 90 ANGLE2 == 270
AOP_GT_convex_270_270_edge = CONVEX EDGE AOP_GT ANGLE1 == 270 ANGLE2 == 270
ALL_GT_convex_equal_one_edge = CONVEX EDGE ALL_GT == 1
ALL_GT_convex_equal_two_edge = CONVEX EDGE ALL_GT == 2
ALL_GT_convex_90_90_edge = CONVEX EDGE ALL_GT ANGLE1 == 90 ANGLE2 == 90
ALL_GT_convex_90_270_edge = CONVEX EDGE ALL_GT ANGLE1 == 90 ANGLE2 == 270
ALL_GT_convex_270_270_edge = CONVEX EDGE ALL_GT ANGLE1 == 270 ANGLE2 == 270

AOP_GT_jog_lteq_002 = CONVEX EDGE AOP_GT == 1 WITH LENGTH <= 0.002
AOP_GT_jog_lteq_003 = CONVEX EDGE AOP_GT == 1 WITH LENGTH <= 0.003
AOP_GT_jog_lteq_004 = CONVEX EDGE AOP_GT == 1 WITH LENGTH <= 0.004
AOP_GT_jog_lteq_005 = CONVEX EDGE AOP_GT == 1 WITH LENGTH <= 0.005
ALL_GT_NOT_P2_jog_lteq_002 = CONVEX EDGE ALL_GT_NOT_P2 == 1 WITH LENGTH <= 0.002
ALL_GT_NOT_P2_jog_lteq_003 = CONVEX EDGE ALL_GT_NOT_P2 == 1 WITH LENGTH <= 0.003
ALL_GT_NOT_P2_jog_lteq_004 = CONVEX EDGE ALL_GT_NOT_P2 == 1 WITH LENGTH <= 0.004
ALL_GT_NOT_P2_jog_lteq_005 = CONVEX EDGE ALL_GT_NOT_P2 == 1 WITH LENGTH <= 0.005

//;poly width derivations
GT_015 = GT WITH WIDTH == 0.015
GT_017 = GT WITH WIDTH == 0.017
GT_019 = GT WITH WIDTH == 0.019
GT_021 = GT WITH WIDTH == 0.021
GT_022 = GT WITH WIDTH == 0.022
GT_023 = GT WITH WIDTH == 0.023
GT_014 = GT WITH WIDTH == 0.014
GT_016 = GT WITH WIDTH == 0.016
GT_018 = GT WITH WIDTH == 0.018
GT_020 = GT WITH WIDTH == 0.020
GT_024 = GT WITH WIDTH == 0.024
GT_026 = GT WITH WIDTH == 0.026 //;For sram only
GT_032 = GT WITH WIDTH == 0.032
GT_034 = GT WITH WIDTH == 0.034
GT_036 = GT WITH WIDTH == 0.036
GT_072 = GT WITH WIDTH == 0.072

GT_eqgt_020 = GT WITH WIDTH >= 0.020
GT_eqgt_024 = GT_eqgt_020 WITH WIDTH >= 0.024
GT_eqgt_032 = GT_eqgt_024 WITH WIDTH >= 0.032
GT_eqgt_034 = GT_eqgt_032 WITH WIDTH >= 0.034
GT_eqgt_035 = GT_eqgt_032 WITH WIDTH >= 0.035
GT_eqgt_036 = GT_eqgt_032 WITH WIDTH >= 0.036
GT_eqgt_070 = GT_eqgt_036 WITH WIDTH >= 0.070
GT_eqgt_072 = GT_eqgt_036 WITH WIDTH >= 0.072

GT_eqlt_072 = GT WITH WIDTH <= 0.072
GT_eqlt_036 = GT_eqlt_072 WITH WIDTH <= 0.036
GT_eqlt_032 = GT_eqlt_072 WITH WIDTH <= 0.032
GT_eqlt_024 = GT_eqlt_036 WITH WIDTH <= 0.024
GT_eqlt_020 = GT_eqlt_024 WITH WIDTH <= 0.020
GT_lt_024 = GT WITH WIDTH < 0.024

GT_gt_014 = GT WITH WIDTH > 0.014
GT_gt_015 = GT_gt_014 WITH WIDTH > 0.015
GT_gt_016 = GT_gt_014 WITH WIDTH > 0.016
GT_gt_017 = GT_gt_016 WITH WIDTH > 0.017
GT_gt_018 = GT_gt_016 WITH WIDTH > 0.018
GT_gt_019 = GT_gt_018 WITH WIDTH > 0.019
GT_gt_020 = GT_gt_018 WITH WIDTH > 0.020
GT_gt_021 = GT_gt_020 WITH WIDTH > 0.021
GT_gt_022 = GT_gt_020 WITH WIDTH > 0.022
GT_gt_023 = GT_gt_022 WITH WIDTH > 0.023
GT_gt_024 = GT_gt_022 WITH WIDTH > 0.024

DOP_GT_017 = DOP_GT WITH WIDTH == 0.017
DOP_GT_019 = DOP_GT WITH WIDTH == 0.019
DOP_GT_021 = DOP_GT WITH WIDTH == 0.021
DOP_GT_022 = DOP_GT WITH WIDTH == 0.022
DOP_GT_023 = DOP_GT WITH WIDTH == 0.023
DOP_GT_014 = DOP_GT WITH WIDTH == 0.014
DOP_GT_016 = DOP_GT WITH WIDTH == 0.016
DOP_GT_018 = DOP_GT WITH WIDTH == 0.018
DOP_GT_020 = DOP_GT WITH WIDTH == 0.020
DOP_GT_024 = DOP_GT WITH WIDTH == 0.024
DOP_GT_032 = DOP_GT WITH WIDTH == 0.032
DOP_GT_034 = DOP_GT WITH WIDTH == 0.034
DOP_GT_036 = DOP_GT WITH WIDTH == 0.036
DOP_GT_eqgt_024 = DOP_GT WITH WIDTH >= 0.024
DOP_GT_eqgt_036 = DOP_GT_eqgt_024 WITH WIDTH >= 0.036
DOP_GT_eqgt_070 = DOP_GT_eqgt_036 WITH WIDTH >= 0.070
DOP_GT_eqgt_072 = DOP_GT_eqgt_036 WITH WIDTH >= 0.072
DOP_GT_eqlt_072 = DOP_GT WITH WIDTH <= 0.072
DOP_GT_eqlt_036 = DOP_GT WITH WIDTH <= 0.036
DOP_GT_eqlt_024 = DOP_GT WITH WIDTH <= 0.024

GTDMP_017 = GTDMP WITH WIDTH == 0.017
GTDMP_019 = GTDMP WITH WIDTH == 0.019
GTDMP_021 = GTDMP WITH WIDTH == 0.021
GTDMP_022 = GTDMP WITH WIDTH == 0.022
GTDMP_023 = GTDMP WITH WIDTH == 0.023
GTDMP_014 = GTDMP WITH WIDTH == 0.014
GTDMP_016 = GTDMP WITH WIDTH == 0.016
GTDMP_018 = GTDMP WITH WIDTH == 0.018
GTDMP_020 = GTDMP WITH WIDTH == 0.020
GTDMP_024 = GTDMP WITH WIDTH == 0.024
GTDMP_032 = GTDMP WITH WIDTH == 0.032
GTDMP_036 = GTDMP WITH WIDTH == 0.036
GTDMP_eqgt_024 = GTDMP WITH WIDTH >= 0.024
GTDMP_eqgt_036 = GTDMP_eqgt_024 WITH WIDTH >= 0.036
GTDMP_eqgt_070 = GTDMP_eqgt_036 WITH WIDTH >= 0.070
GTDMP_eqgt_072 = GTDMP_eqgt_036 WITH WIDTH >= 0.072
GTDMP_eqlt_072 = GTDMP WITH WIDTH <= 0.072
GTDMP_eqlt_036 = GTDMP WITH WIDTH <= 0.036
GTDMP_eqlt_032 = GTDMP WITH WIDTH <= 0.032
GTDMP_eqlt_024 = GTDMP WITH WIDTH <= 0.024

AOP_GT_017 = GT_017 OR DOP_GT_017
AOP_GT_019 = GT_019 OR DOP_GT_019
AOP_GT_021 = GT_021 OR DOP_GT_021
AOP_GT_022 = GT_022 OR DOP_GT_022
AOP_GT_023 = GT_023 OR DOP_GT_023
AOP_GT_014 = GT_014 OR DOP_GT_014
AOP_GT_016 = GT_016 OR DOP_GT_016
AOP_GT_018 = GT_018 OR DOP_GT_018
AOP_GT_020 = GT_020 OR DOP_GT_020
AOP_GT_024 = GT_024 OR DOP_GT_024
AOP_GT_026 = AOP_GT WITH WIDTH == 0.026  //;SRAM
AOP_GT_032 = GT_032 OR DOP_GT_032
AOP_GT_034 = GT_034 OR DOP_GT_034
AOP_GT_036 = GT_036 OR DOP_GT_036
AOP_GT_eq_070 = AOP_GT WITH WIDTH == 0.070
AOP_GT_eq_072 = AOP_GT WITH WIDTH == 0.072
AOP_GT_lt_070 = AOP_GT WITH WIDTH < 0.07
AOP_GT_eqgt_070 = GT_eqgt_070 OR DOP_GT_eqgt_070
AOP_GT_eqgt_072 = GT_eqgt_072 OR DOP_GT_eqgt_072
AOP_GT_eqlt_072 = GT_eqlt_072 OR DOP_GT_eqlt_072
AOP_GT_eqgt_036 = GT_eqgt_036 OR DOP_GT_eqgt_036
AOP_GT_eqlt_036 = GT_eqlt_036 OR DOP_GT_eqlt_036
AOP_GT_eqgt_020 = AOP_GT WITH WIDTH >= 0.020
AOP_GT_eqlt_020 = AOP_GT WITH WIDTH <= 0.020
AOP_GT_gt_020 = AOP_GT WITH WIDTH > 0.020
AOP_GT_lt_020 = AOP_GT WITH WIDTH < 0.020
AOP_GT_eqgt_022 = AOP_GT_eqgt_020 WITH WIDTH >= 0.022
AOP_GT_eqlt_022 = AOP_GT WITH WIDTH <= 0.022
AOP_GT_gt_022 = AOP_GT_gt_020 WITH WIDTH > 0.022
AOP_GT_lt_022 = AOP_GT WITH WIDTH < 0.022
AOP_GT_eqgt_024 = AOP_GT_eqgt_022 WITH WIDTH >= 0.024
AOP_GT_eqlt_024 = AOP_GT WITH WIDTH <= 0.024
AOP_GT_gt_024 = AOP_GT_eqgt_022 WITH WIDTH > 0.024
AOP_GT_lt_024 = AOP_GT WITH WIDTH < 0.024
AOP_GT_gt_032 = AOP_GT_eqgt_024 WITH WIDTH > 0.032
AOP_GT_lt_032 = AOP_GT WITH WIDTH < 0.032
AOP_GT_eqgt_032 = AOP_GT_eqgt_024 WITH WIDTH >= 0.032
AOP_GT_eqlt_032 = AOP_GT WITH WIDTH <= 0.032

ALL_GT_017 = (GTDUM WITH WIDTH == 0.017) OR AOP_GT_014
ALL_GT_019 = (GTDUM WITH WIDTH == 0.019) OR AOP_GT_019
ALL_GT_021 = (GTDUM WITH WIDTH == 0.021) OR AOP_GT_021
ALL_GT_022 = (GTDUM WITH WIDTH == 0.022) OR AOP_GT_022
ALL_GT_023 = (GTDUM WITH WIDTH == 0.023) OR AOP_GT_023
ALL_GT_014 = (GTDUM WITH WIDTH == 0.014) OR AOP_GT_014
ALL_GT_016 = (GTDUM WITH WIDTH == 0.016) OR AOP_GT_016
ALL_GT_018 = (GTDUM WITH WIDTH == 0.018) OR AOP_GT_018
ALL_GT_020 = (GTDUM WITH WIDTH == 0.020) OR AOP_GT_020
ALL_GT_024 = (GTDUM WITH WIDTH == 0.024) OR AOP_GT_024
ALL_GT_032 = (GTDUM WITH WIDTH == 0.032) OR AOP_GT_032
ALL_GT_034 = (GTDUM WITH WIDTH == 0.034) OR AOP_GT_034
ALL_GT_036 = (GTDUM WITH WIDTH == 0.036) OR AOP_GT_036
ALL_GT_eq_070 = (GTDUM WITH WIDTH == 0.070) OR AOP_GT_eq_070
ALL_GT_eq_072 = (GTDUM WITH WIDTH == 0.072) OR AOP_GT_eq_072
ALL_GT_eqgt_070 = (GTDUM WITH WIDTH >= 0.070) OR AOP_GT_eqgt_070
ALL_GT_eqgt_072 = (GTDUM WITH WIDTH >= 0.072) OR AOP_GT_eqgt_072
ALL_GT_eqlt_072 = (GTDUM WITH WIDTH <= 0.072) OR AOP_GT_eqlt_072
ALL_GT_eqgt_036 = (GTDUM WITH WIDTH >= 0.036) OR AOP_GT_eqgt_036
ALL_GT_eqlt_036 = (GTDUM WITH WIDTH <= 0.036) OR AOP_GT_eqlt_036
ALL_GT_eqgt_032 = (GTDUM WITH WIDTH >= 0.032) OR AOP_GT_eqgt_032
ALL_GT_eqlt_032 = (GTDUM WITH WIDTH <= 0.032) OR AOP_GT_eqlt_032
ALL_GT_eqgt_022 = ALL_GT WITH WIDTH >= 0.022
ALL_GT_eqgt_024 = ALL_GT_eqgt_022 WITH WIDTH >= 0.024
ALL_GT_gt_022 = ALL_GT WITH WIDTH > 0.022
ALL_GT_gt_024 = ALL_GT_gt_022 WITH WIDTH > 0.024
ALL_GT_gt_090 = ALL_GT_gt_024 WITH WIDTH > 0.090
ALL_GT_lt_022 = ALL_GT WITH WIDTH < 0.022
ALL_GT_lt_032 = ALL_GT WITH WIDTH < 0.032
ALL_GT_lt_024 = ALL_GT WITH WIDTH < 0.024
ALL_GT_lt_072 = ALL_GT WITH WIDTH < 0.072
ALL_GT_eqlt_022 = ALL_GT WITH WIDTH <= 0.022
ALL_GT_eqlt_024 = ALL_GT WITH WIDTH <= 0.024

ALL_GT_017_v_edges = INT [ALL_GT_017] == 0.017 OPPOSITE
ALL_GT_019_v_edges = INT [ALL_GT_019] == 0.019 OPPOSITE
ALL_GT_021_v_edges = INT [ALL_GT_021] == 0.021 OPPOSITE
ALL_GT_022_v_edges = INT [ALL_GT_022] == 0.022 OPPOSITE
ALL_GT_023_v_edges = INT [ALL_GT_023] == 0.023 OPPOSITE
ALL_GT_014_v_edges = INT [ALL_GT_014] == 0.014 OPPOSITE
ALL_GT_016_v_edges = INT [ALL_GT_016] == 0.016 OPPOSITE
ALL_GT_018_v_edges = INT [ALL_GT_018] == 0.018 OPPOSITE
ALL_GT_020_v_edges = INT [ALL_GT_020] == 0.020 OPPOSITE
ALL_GT_024_v_edges = INT [ALL_GT_024] == 0.024 OPPOSITE
ALL_GT_032_v_edges = INT [ALL_GT_032] == 0.032 OPPOSITE
ALL_GT_036_v_edges = INT [ALL_GT_036] == 0.036 OPPOSITE

AOP_GT_017_v_edges = INT [AOP_GT_017] == 0.017 OPPOSITE
AOP_GT_019_v_edges = INT [AOP_GT_019] == 0.019 OPPOSITE
AOP_GT_021_v_edges = INT [AOP_GT_021] == 0.021 OPPOSITE
AOP_GT_022_v_edges = INT [AOP_GT_022] == 0.022 OPPOSITE
AOP_GT_023_v_edges = INT [AOP_GT_023] == 0.023 OPPOSITE
AOP_GT_014_v_edges = INT [AOP_GT_014] == 0.014 OPPOSITE
AOP_GT_016_v_edges = INT [AOP_GT_016] == 0.016 OPPOSITE
AOP_GT_018_v_edges = INT [AOP_GT_018] == 0.018 OPPOSITE
AOP_GT_020_v_edges = INT [AOP_GT_020] == 0.020 OPPOSITE
AOP_GT_024_v_edges = INT [AOP_GT_024] == 0.024 OPPOSITE
AOP_GT_026_v_edges = INT [AOP_GT_026] == 0.026 OPPOSITE
AOP_GT_032_v_edges = INT [AOP_GT_032] == 0.032 OPPOSITE
AOP_GT_034_v_edges = INT [AOP_GT_034] == 0.034 OPPOSITE
AOP_GT_036_v_edges = INT [AOP_GT_036] == 0.036 OPPOSITE
AOP_GT_022_024_v_edges = OR EDGE AOP_GT_022_v_edges AOP_GT_024_v_edges
AOP_GT_032_036_v_edges = INT [AOP_GT] >= 0.032 <= 0.036 OPPOSITE
ALL_GT_eqlt_036_edges = INT [ALL_GT_eqlt_036] <= 0.036 ABUT<90 OPPOSITE
ALL_GT_eqlt_032_edges = INT [ALL_GT_eqlt_032] <= 0.032 ABUT<90 OPPOSITE
ALL_GT_eqlt_024_edges = INT [ALL_GT_eqlt_024] <= 0.024 ABUT<90 OPPOSITE

AOP_GT_NOT_P2_eqlt_090 = AOP_GT_NOT_P2 WITH WIDTH <= 0.090
AOP_GT_NOT_P2_lt_096 = AOP_GT_NOT_P2 WITH WIDTH < 0.096
ALL_GT_NOT_P2_gt_090 = ALL_GT_gt_090 NOT P2
ALL_GT_NOT_P2_eqgt_070 = ALL_GT_eqgt_070 NOT P2
ALL_GT_NOT_P2_eqgt_072 = ALL_GT_eqgt_072 NOT P2
ALL_GT_with_P2_core = (ALL_GT INTERACT P2) NOT DG

// ========================
// AA derivation
// ========================
ALL_AA_IO = ALL_AA NOT OUTSIDE DG
ALL_AA_CORE = ALL_AA NOT INSIDE DG
ALL_AA_NOT_MARKS = ALL_AA NOT MARKS
ALL_AA_NOT_AR = ALL_AA NOT AR
ALL_AA_INTERACT_GT_eqgt_032 = ALL_AA INTERACT GT_eqgt_032
ALL_AA_INTERACT_GT_eqgt_034 = ALL_AA INTERACT GT_eqgt_034
ALL_AA_INTERACT_GT_eqgt_035 = ALL_AA INTERACT GT_eqgt_035
ALL_AA_INTERACT_GT_eqgt_036 = ALL_AA INTERACT GT_eqgt_036

AA_INTERACT_GT = AA INTERACT GT
AA_NOT_TAP = AA NOT TAP_RAW
AA_RECTANGLE = RECTANGLE AA
AA_SD_all = AA NOT GT
TAP_NOT_VARMOS = TAP_RAW NOT VARMOS

AR_overlap_AA = AR AND AA
AR_with_AA = AR INTERACT AA
AA_convex_equal_one_edge = CONVEX EDGE AA == 1
AA_convex_equal_two_edge = CONVEX EDGE AA == 2
AA_convex_90_90_edge = CONVEX EDGE AA ANGLE1 == 90 ANGLE2 == 90
AA_convex_90_270_edge = CONVEX EDGE AA ANGLE1 == 90 ANGLE2 == 270
AA_convex_270_270_edge = CONVEX EDGE AA ANGLE1 == 270 ANGLE2 == 270
ALL_AA_convex_equal_one_edge = CONVEX EDGE ALL_AA == 1
ALL_AA_convex_equal_two_edge = CONVEX EDGE ALL_AA == 2
ALL_AA_convex_90_90_edge = CONVEX EDGE ALL_AA ANGLE1 == 90 ANGLE2 == 90
ALL_AA_convex_90_270_edge = CONVEX EDGE ALL_AA ANGLE1 == 90 ANGLE2 == 270
ALL_AA_convex_270_270_edge = CONVEX EDGE ALL_AA ANGLE1 == 270 ANGLE2 == 270

AA_048 = AA WITH WIDTH == 0.048
AOP_AA_048 = AOP_AA WITH WIDTH == 0.048
ALL_AA_048 = ALL_AA WITH WIDTH == 0.048
ALL_AA_096 = ALL_AA WITH WIDTH == 0.096

AA_v_edges_exp001 = EXPAND EDGE AA_v_edges INSIDE BY 0.001
AA_048_h_edges = INT [AA_h_edges] == 0.048 ABUT<90 OPPOSITE
ALL_AA_048_h_edges = ALL_AA_048 COIN EDGE ALL_AA_h_edges

AACT_MOS_contact = M0_0 ENCLOSE V0
AACT_MOS_area = ACT INTERACT TRGATE
AACT_MOS_dummy = AACT_MOS_area NOT INTERACT AACT_MOS_contact
AACT_Non_MOS_area = ACT NOT INTERACT TRGATE
AACT_MOS_floating = AACT_MOS_dummy NOT INTERACT (GT_0 INTERACT AACT_MOS_contact)
AACT_DIO_floating = AACT_Non_MOS_area NOT INTERACT AACT_MOS_contact

//;AA on edge gate for drc check
edge_gate_dopAA = ENC DOP_AA_v_edges DOP_GT <= 0.15 ABUT>0<90 OPPOSITE REGION EXCLUDE SHIELDED
edge_gate_dumAA = ENC DUM_AA_v_edges DUM_GT <= 0.15 ABUT>0<90 OPPOSITE REGION EXCLUDE SHIELDED
edge_gate_dopAA_all = OR DOP_AA edge_gate_dopAA
edge_gate_dumAA_all = OR DUM_AA edge_gate_dumAA
edge_gate_aopAA_all = OR edge_gate_dopAA_all edge_gate_AA_all

edge_gate_AA_uGT = ENC AA_v_edges GT <= 0.15 ABUT>0<90 OPPOSITE REGION EXCLUDE SHIELDED
edge_gate_AA_uAA = INT AA_v_edges GT <= 0.15 ABUT>0<90 OPPOSITE REGION EXCLUDE SHIELDED
edge_gate_AA_all = OR AA edge_gate_AA_uGT
edge_gate_AA_act = OR ACT (edge_gate_AA_uGT INTERACT ACT)
edge_gate_AA_tap = OR TAP_RAW (edge_gate_AA_uGT INTERACT TAP_RAW)

edge_gate_AA_nact = OR NACT (edge_gate_AA_act INTERACT NACT)
edge_gate_AA_pact = OR PACT (edge_gate_AA_act INTERACT PACT)
edge_gate_AA_ntap = OR NTAP_RAW (edge_gate_AA_tap INTERACT NTAP_RAW)
edge_gate_AA_ptap = OR PTAP_RAW (edge_gate_AA_tap INTERACT PTAP_RAW)

edge_gate_AA_all_h_edges = ANGLE edge_gate_AA_all == 0
edge_gate_AA_all_v_edges = ANGLE edge_gate_AA_all == 90

// ========================
// AR_V/AR_H derivation
// ========================
ALL_AR_VH = ANGLE ALL_AR_V == 0
ALL_AR_VV = ANGLE ALL_AR_V == 90
ALL_AR_HH = ANGLE ALL_AR_H == 0
ALL_AR_HV = ANGLE ALL_AR_H == 90
gtmk1_or_ar = GTMK1 OR AR

// ========================
// M0 derivation
// ========================
M0_W_edges = ((LENGTH M0 == 0.040) OR EDGE (LENGTH M0 == 0.042)) OR EDGE (LENGTH M0 == 0.054)
M0_L_edges = M0 NOT COIN EDGE M0_W_edges
M0_NOT_M0C_L_edges = M0_NOT_M0C COIN EDGE M0_L_edges
M0_NOT_M0C_W_edges = M0_NOT_M0C NOT COIN EDGE M0_NOT_M0C_L_edges

AOP_M0_WL_edges_a = DFM PROPERTY AOP_M0 AOP_M0_h_edges AOP_M0_v_edges OVERLAP ABUT ALSO MULTI [h_v_ratio = LENGTH(AOP_M0_h_edges) - LENGTH(AOP_M0_v_edges)] >= 0
AOP_M0_WL_edges_b = DFM PROPERTY AOP_M0 AOP_M0_h_edges AOP_M0_v_edges OVERLAP ABUT ALSO MULTI [h_v_ratio = LENGTH(AOP_M0_v_edges) - LENGTH(AOP_M0_h_edges)] >= 0
AOP_M0_W_edges = (AOP_M0_v_edges COIN EDGE AOP_M0_WL_edges_a) OR EDGE (AOP_M0_h_edges COIN EDGE AOP_M0_WL_edges_b)
AOP_M0_L_edges = (AOP_M0_h_edges COIN EDGE AOP_M0_WL_edges_a) OR EDGE (AOP_M0_v_edges COIN EDGE AOP_M0_WL_edges_b)

ALL_M0_WL_edges_a = DFM PROPERTY ALL_M0 ALL_M0_h_edges ALL_M0_v_edges OVERLAP ABUT ALSO MULTI [h_v_ratio = LENGTH(ALL_M0_h_edges) - LENGTH(ALL_M0_v_edges)] >= 0
ALL_M0_WL_edges_b = DFM PROPERTY ALL_M0 ALL_M0_h_edges ALL_M0_v_edges OVERLAP ABUT ALSO MULTI [h_v_ratio = LENGTH(ALL_M0_v_edges) - LENGTH(ALL_M0_h_edges)] >= 0
ALL_M0_W_edges = (ALL_M0_v_edges COIN EDGE ALL_M0_WL_edges_a) OR EDGE (ALL_M0_h_edges COIN EDGE ALL_M0_WL_edges_b)
ALL_M0_L_edges = (ALL_M0_h_edges COIN EDGE ALL_M0_WL_edges_a) OR EDGE (ALL_M0_v_edges COIN EDGE ALL_M0_WL_edges_b)

M0_normal_shape = M0 WITH EDGE (OR EDGE M0_v_edges M0_h_edges)
DOP_M0_normal_shape = DOP_M0 WITH EDGE (OR EDGE DOP_M0_v_edges DOP_M0_h_edges)
AOP_M0_normal_shape = AOP_M0 WITH EDGE (OR EDGE AOP_M0_v_edges AOP_M0_h_edges)
ALL_M0_normal_shape = ALL_M0 WITH EDGE (OR EDGE ALL_M0_v_edges ALL_M0_h_edges)

M0_040 = M0_normal_shape WITH WIDTH == 0.040
M0_042 = M0_normal_shape WITH WIDTH == 0.042
M0_054 = M0_normal_shape WITH WIDTH == 0.054
M0_NOT_M0C_040 = M0_NOT_M0C AND M0_040
M0_NOT_M0C_042 = M0_NOT_M0C AND M0_042
M0_NOT_M0C_054 = M0_NOT_M0C AND M0_054
M0_040_042 = OR M0_040 M0_042
M0_NOT_M0C_040_042 = OR M0_NOT_M0C_040 M0_NOT_M0C_042

M0_NOT_M0C_040_W_edges = LENGTH M0_NOT_M0C_040 == 0.04
M0_NOT_M0C_042_W_edges = LENGTH M0_NOT_M0C_042 == 0.042
M0_NOT_M0C_054_W_edges = LENGTH M0_NOT_M0C_054 == 0.054
M0_NOT_M0C_040_L_edges = INT [M0_NOT_M0C] == 0.040 ABUT<90 OPPOSITE
M0_NOT_M0C_042_L_edges = INT [M0_NOT_M0C] == 0.042 ABUT<90 OPPOSITE
M0_NOT_M0C_054_L_edges = INT [M0_NOT_M0C] == 0.054 ABUT<90 OPPOSITE
M0_NOT_M0C_040_042_W_edges = OR EDGE M0_NOT_M0C_040_W_edges M0_NOT_M0C_042_W_edges

DOP_M0_040 = WITH WIDTH DOP_M0_normal_shape == 0.040
DOP_M0_042 = WITH WIDTH DOP_M0_normal_shape == 0.042
DOP_M0_054 = WITH WIDTH DOP_M0_normal_shape == 0.054
AOP_M0_040 = AOP_M0_normal_shape WITH WIDTH == 0.040
AOP_M0_042 = AOP_M0_normal_shape WITH WIDTH == 0.042
AOP_M0_054 = AOP_M0_normal_shape WITH WIDTH == 0.054
ALL_M0_040 = ALL_M0_normal_shape WITH WIDTH == 0.040
ALL_M0_042 = ALL_M0_normal_shape WITH WIDTH == 0.042
ALL_M0_054 = ALL_M0_normal_shape WITH WIDTH == 0.054
AOP_M0_040_042 = OR AOP_M0_040 AOP_M0_042
ALL_M0_040_042 = OR ALL_M0_040 ALL_M0_042

M0_NOT_AOP_M0C = M0_NOT_M0C NOT AOP_M0C  //;please do not use the operation like "M0 NOT AOP_M0C" here!
AOP_M0_NOT_M0C = (M0_NOT_M0C NOT M0C) OR (DOP_M0 NOT M0C)
AOP_M0_NOT_AOP_M0C = M0_NOT_M0C OR (DOP_M0 NOT DOP_M0C)
ALL_M0_NOT_ALL_M0C = ALL_M0 NOT ALL_M0C
ALL_M0_NOT_M0C_OR_M0G = ALL_M0_NOT_ALL_M0C OR ALL_M0G
M0_AND_AA = M0 AND AA

AOP_M0_040_W_edges = LENGTH AOP_M0_040 == 0.040
AOP_M0_040_L_edges = LENGTH AOP_M0_040 > 0.040
AOP_M0_042_W_edges = LENGTH AOP_M0_042 == 0.042
AOP_M0_042_L_edges = LENGTH AOP_M0_042 > 0.042
AOP_M0_054_W_edges = LENGTH AOP_M0_054 == 0.054
AOP_M0_054_L_edges = LENGTH AOP_M0_054 > 0.054
AOP_M0_040_042_W_edges = OR EDGE AOP_M0_040_W_edges AOP_M0_042_W_edges

M0_W040_with_M0C = M0_NOT_M0C_040_W_edges COIN OUTSIDE EDGE M0C
M0_W040_without_M0C = M0_NOT_M0C_040_W_edges COIN EDGE M0

M0_convex_90_90_edges = CONVEX EDGE M0 ANGLE1 == 90 ANGLE2 == 90
M0_NOT_M0C_convex_90_90_length_lt_0.08 = CONVEX EDGE M0_NOT_M0C ANGLE1 == 90 ANGLE2 == 90 WITH LENGTH < 0.08

AOP_M0_GT_P96 = AOP_M0 INTERACT GT_P96

//;For delta voltage
delta_DOP_M0 = DOP_M0 NOT DMP_M0C
delta_M0 = (M0_NOT_M0C NOT DMP_M0C) OR delta_DOP_M0

// ========================
// M0C derivation
// ========================
M0C_WL_edges_a = DFM PROPERTY M0C M0C_h_edges M0C_v_edges OVERLAP ABUT ALSO MULTI [h_v_ratio = LENGTH(M0C_h_edges) - LENGTH(M0C_v_edges)] >= 0
M0C_WL_edges_b = DFM PROPERTY M0C M0C_h_edges M0C_v_edges OVERLAP ABUT ALSO MULTI [h_v_ratio = LENGTH(M0C_v_edges) - LENGTH(M0C_h_edges)] >= 0
M0C_W_edges = (M0C_v_edges COIN EDGE M0C_WL_edges_a) OR EDGE (M0C_h_edges COIN EDGE M0C_WL_edges_b)
M0C_L_edges = (M0C_h_edges COIN EDGE M0C_WL_edges_a) OR EDGE (M0C_v_edges COIN EDGE M0C_WL_edges_b)

AOP_M0C_WL_edges_a = DFM PROPERTY AOP_M0C AOP_M0C_h_edges AOP_M0C_v_edges OVERLAP ABUT ALSO MULTI [h_v_ratio = LENGTH(AOP_M0C_h_edges) - LENGTH(AOP_M0C_v_edges)] >= 0
AOP_M0C_WL_edges_b = DFM PROPERTY AOP_M0C AOP_M0C_h_edges AOP_M0C_v_edges OVERLAP ABUT ALSO MULTI [h_v_ratio = LENGTH(AOP_M0C_v_edges) - LENGTH(AOP_M0C_h_edges)] >= 0
AOP_M0C_W_edges = (AOP_M0C_v_edges COIN EDGE AOP_M0C_WL_edges_a) OR EDGE (AOP_M0C_h_edges COIN EDGE AOP_M0C_WL_edges_b)
AOP_M0C_L_edges = (AOP_M0C_h_edges COIN EDGE AOP_M0C_WL_edges_a) OR EDGE (AOP_M0C_v_edges COIN EDGE AOP_M0C_WL_edges_b)

M0C_042 = INT M0C_h_edges == 0.042 OPPOSITE REGION
M0C_048 = INT M0C_h_edges == 0.048 OPPOSITE REGION
M0C_051 = INT M0C_h_edges == 0.051 OPPOSITE REGION
M0C_052 = INT M0C_h_edges == 0.052 OPPOSITE REGION
M0C_054 = INT M0C_h_edges == 0.054 OPPOSITE REGION
M0C_060 = INT M0C_h_edges == 0.060 OPPOSITE REGION
M0C_076 = INT M0C_h_edges == 0.076 OPPOSITE REGION
M0C_082 = INT M0C_h_edges == 0.082 OPPOSITE REGION
M0C_090 = INT M0C_h_edges == 0.090 OPPOSITE REGION
M0C_108 = INT M0C_h_edges == 0.108 OPPOSITE REGION
M0C_110 = INT M0C_h_edges == 0.110 OPPOSITE REGION
M0C_112 = INT M0C_h_edges == 0.112 OPPOSITE REGION
M0C_114 = INT M0C_h_edges == 0.114 OPPOSITE REGION
M0C_156 = INT M0C_h_edges == 0.156 OPPOSITE REGION

DOP_M0C_042 = INT DOP_M0C_h_edges == 0.042 OPPOSITE REGION
DOP_M0C_048 = INT DOP_M0C_h_edges == 0.048 OPPOSITE REGION
DOP_M0C_051 = INT DOP_M0C_h_edges == 0.051 OPPOSITE REGION
DOP_M0C_052 = INT DOP_M0C_h_edges == 0.052 OPPOSITE REGION
DOP_M0C_054 = INT DOP_M0C_h_edges == 0.054 OPPOSITE REGION
DOP_M0C_060 = INT DOP_M0C_h_edges == 0.060 OPPOSITE REGION
DOP_M0C_076 = INT DOP_M0C_h_edges == 0.076 OPPOSITE REGION
DOP_M0C_082 = INT DOP_M0C_h_edges == 0.082 OPPOSITE REGION
DOP_M0C_090 = INT DOP_M0C_h_edges == 0.090 OPPOSITE REGION
DOP_M0C_108 = INT DOP_M0C_h_edges == 0.108 OPPOSITE REGION
DOP_M0C_110 = INT DOP_M0C_h_edges == 0.110 OPPOSITE REGION
DOP_M0C_112 = INT DOP_M0C_h_edges == 0.112 OPPOSITE REGION
DOP_M0C_114 = INT DOP_M0C_h_edges == 0.114 OPPOSITE REGION
DOP_M0C_156 = INT DOP_M0C_h_edges == 0.156 OPPOSITE REGION
DOP_M0C_360 = INT DOP_M0C_h_edges == 0.360 OPPOSITE REGION
DOP_M0C_400 = INT DOP_M0C_h_edges == 0.400 OPPOSITE REGION

AOP_M0C_042 = OR M0C_042 DOP_M0C_042
AOP_M0C_048 = OR M0C_048 DOP_M0C_048
AOP_M0C_051 = OR M0C_051 DOP_M0C_051
AOP_M0C_052 = OR M0C_052 DOP_M0C_052
AOP_M0C_054 = OR M0C_054 DOP_M0C_054
AOP_M0C_060 = OR M0C_060 DOP_M0C_060
AOP_M0C_076 = OR M0C_076 DOP_M0C_076
AOP_M0C_082 = OR M0C_082 DOP_M0C_082
AOP_M0C_108 = OR M0C_108 DOP_M0C_108
AOP_M0C_110 = OR M0C_110 DOP_M0C_110
AOP_M0C_112 = OR M0C_112 DOP_M0C_112
AOP_M0C_156 = OR M0C_156 DOP_M0C_156

M0C_048_052 = OR M0C_048 M0C_052
M0C_048_054 = OR M0C_048 M0C_054
M0C_108_156 = OR M0C_108 M0C_156
M0C_110_156 = OR M0C_110 M0C_156

AOP_M0C_GT_P96 = AOP_M0C NOT OUTSIDE GT_P96
DOP_M0C_GT_P96 = DOP_M0C NOT OUTSIDE GT_P96
M0C_GT_P96 = M0C NOT OUTSIDE GT_P96

AOP_M0C_with_AOP_M0 = AOP_M0C INTERACT AOP_M0
DOP_M0C_with_DOP_M0 = DOP_M0C INTERACT DOP_M0
M0C_with_M0 = M0C INTERACT M0

// ========================
// M0G derivation
// ========================
M0G_WL_edges_a = DFM PROPERTY M0G M0G_h_edges M0G_v_edges OVERLAP ABUT ALSO MULTI [h_v_ratio = LENGTH(M0G_h_edges) - LENGTH(M0G_v_edges)] >= 0
M0G_WL_edges_b = DFM PROPERTY M0G M0G_h_edges M0G_v_edges OVERLAP ABUT ALSO MULTI [h_v_ratio = LENGTH(M0G_v_edges) - LENGTH(M0G_h_edges)] >= 0
M0G_W_edges = (M0G_v_edges COIN EDGE M0G_WL_edges_a) OR EDGE (M0G_h_edges COIN EDGE M0G_WL_edges_b)
M0G_L_edges = (M0G_h_edges COIN EDGE M0G_WL_edges_a) OR EDGE (M0G_v_edges COIN EDGE M0G_WL_edges_b)

AOP_M0G_WL_edges_a = DFM PROPERTY AOP_M0G AOP_M0G_h_edges AOP_M0G_v_edges OVERLAP ABUT ALSO MULTI [h_v_ratio = LENGTH(AOP_M0G_h_edges) - LENGTH(AOP_M0G_v_edges)] >= 0
AOP_M0G_WL_edges_b = DFM PROPERTY AOP_M0G AOP_M0G_h_edges AOP_M0G_v_edges OVERLAP ABUT ALSO MULTI [h_v_ratio = LENGTH(AOP_M0G_v_edges) - LENGTH(AOP_M0G_h_edges)] >= 0
AOP_M0G_W_edges = (AOP_M0G_v_edges COIN EDGE AOP_M0G_WL_edges_a) OR EDGE (AOP_M0G_h_edges COIN EDGE AOP_M0G_WL_edges_b)
AOP_M0G_L_edges = (AOP_M0G_h_edges COIN EDGE AOP_M0G_WL_edges_a) OR EDGE (AOP_M0G_v_edges COIN EDGE AOP_M0G_WL_edges_b)

M0G_WIDTH_032 = M0G WITH WIDTH == 0.032
M0G_WIDTH_040 = M0G WITH WIDTH == 0.040
M0G_WIDTH_050 = M0G WITH WIDTH == 0.050
M0G_WIDTH_051 = M0G WITH WIDTH == 0.051
M0G_WIDTH_052 = M0G WITH WIDTH == 0.052
M0G_WIDTH_053 = M0G WITH WIDTH == 0.053
M0G_WIDTH_054 = M0G WITH WIDTH == 0.054
M0G_WIDTH_055 = M0G WITH WIDTH == 0.055
M0G_WIDTH_060 = M0G WITH WIDTH == 0.060
M0G_WIDTH_088 = M0G WITH WIDTH == 0.088
M0G_WIDTH_090 = M0G WITH WIDTH == 0.090
M0G_WIDTH_140 = M0G WITH WIDTH == 0.140  //; Forbidden width in M0G rule
M0G_WIDTH_050_To_055 = OR M0G_WIDTH_050 M0G_WIDTH_051 M0G_WIDTH_052 M0G_WIDTH_053 M0G_WIDTH_054 M0G_WIDTH_055
M0G_WIDTH_051_To_055 = OR M0G_WIDTH_051 M0G_WIDTH_052 M0G_WIDTH_053 M0G_WIDTH_054 M0G_WIDTH_055

M0G_W040_L050 = RECTANGLE M0G == 0.040 BY == 0.05 //;SRAM
M0G_W050_L050 = RECTANGLE M0G == 0.050 BY == 0.05
M0G_W050_L057 = M0G_WIDTH_050 WITH EDGE (LENGTH M0G == 0.057)
M0G_W050_L058 = M0G_WIDTH_050 WITH EDGE (LENGTH M0G == 0.058)
M0G_W050_L060 = M0G_WIDTH_050 WITH EDGE (LENGTH M0G == 0.060)
M0G_W050_L061 = M0G_WIDTH_050 WITH EDGE (LENGTH M0G == 0.061)
M0G_W051_L088 = M0G_WIDTH_051 WITH EDGE (LENGTH M0G == 0.088)
M0G_W052_L088 = M0G_WIDTH_052 WITH EDGE (LENGTH M0G == 0.088)
M0G_W053_L088 = M0G_WIDTH_053 WITH EDGE (LENGTH M0G == 0.088)
M0G_W054_L088 = M0G_WIDTH_054 WITH EDGE (LENGTH M0G == 0.088)
M0G_W055_L088 = M0G_WIDTH_055 WITH EDGE (LENGTH M0G == 0.088)
M0G_W051_L090 = M0G_WIDTH_051 WITH EDGE (LENGTH M0G == 0.090)
M0G_W052_L090 = M0G_WIDTH_052 WITH EDGE (LENGTH M0G == 0.090)
M0G_W053_L090 = M0G_WIDTH_053 WITH EDGE (LENGTH M0G == 0.090)
M0G_W054_L090 = M0G_WIDTH_054 WITH EDGE (LENGTH M0G == 0.090)
M0G_W055_L090 = M0G_WIDTH_055 WITH EDGE (LENGTH M0G == 0.090)
M0G_W050_L057_L058 = OR M0G_W050_L057 M0G_W050_L058
M0G_W050_L060_L061 = OR M0G_W050_L060 M0G_W050_L061

M0G_W060_L095 = M0G_WIDTH_060 WITH EDGE (LENGTH M0G == 0.095)
M0G_W060_L096 = M0G_WIDTH_060 WITH EDGE (LENGTH M0G == 0.096)
M0G_W088_L102 = M0G_WIDTH_088 WITH EDGE (LENGTH M0G == 0.102)
M0G_W088_L108 = M0G_WIDTH_088 WITH EDGE (LENGTH M0G == 0.108)
M0G_W090_L102 = M0G_WIDTH_090 WITH EDGE (LENGTH M0G == 0.102)
M0G_W090_L108 = M0G_WIDTH_090 WITH EDGE (LENGTH M0G == 0.108)
M0G_W088_L102_To_L104 = M0G_WIDTH_088 WITH EDGE (LENGTH M0G >= 0.102 <= 0.104)
M0G_W088_L108_To_L110 = M0G_WIDTH_088 WITH EDGE (LENGTH M0G >= 0.108 <= 0.110)
M0G_W090_L102_To_L104 = M0G_WIDTH_090 WITH EDGE (LENGTH M0G >= 0.102 <= 0.104)
M0G_W090_L108_To_L110 = M0G_WIDTH_090 WITH EDGE (LENGTH M0G >= 0.108 <= 0.110)
M0G_W060_L095_L096 = OR M0G_W060_L095 M0G_W060_L096

M0G_032_VERTICAL = INT M0G_h_edges == 0.032 OPPOSITE REGION
M0G_040_VERTICAL = INT M0G_h_edges == 0.040 OPPOSITE REGION
M0G_050_VERTICAL = INT M0G_h_edges == 0.050 OPPOSITE REGION
M0G_051_VERTICAL = INT M0G_h_edges == 0.051 OPPOSITE REGION
M0G_052_VERTICAL = INT M0G_h_edges == 0.052 OPPOSITE REGION
M0G_053_VERTICAL = INT M0G_h_edges == 0.053 OPPOSITE REGION
M0G_054_VERTICAL = INT M0G_h_edges == 0.054 OPPOSITE REGION
M0G_055_VERTICAL = INT M0G_h_edges == 0.055 OPPOSITE REGION
M0G_060_VERTICAL = INT M0G_h_edges == 0.060 OPPOSITE REGION
M0G_088_VERTICAL = INT M0G_h_edges == 0.088 OPPOSITE REGION
M0G_090_VERTICAL = INT M0G_h_edges == 0.090 OPPOSITE REGION
M0G_051_HORIZONTAL = INT M0G_v_edges == 0.051 OPPOSITE REGION
M0G_052_HORIZONTAL = INT M0G_v_edges == 0.052 OPPOSITE REGION
M0G_053_HORIZONTAL = INT M0G_v_edges == 0.053 OPPOSITE REGION
M0G_054_HORIZONTAL = INT M0G_v_edges == 0.054 OPPOSITE REGION
M0G_055_HORIZONTAL = INT M0G_v_edges == 0.055 OPPOSITE REGION
M0G_060_HORIZONTAL = INT M0G_v_edges == 0.060 OPPOSITE REGION

M0G_032 = OR (M0G INTERACT M0G_032_VERTICAL) M0G_WIDTH_032
M0G_040 = OR (M0G INTERACT M0G_040_VERTICAL) M0G_WIDTH_040
M0G_050 = OR (M0G INTERACT M0G_050_VERTICAL) M0G_WIDTH_050
M0G_051 = OR (M0G INTERACT M0G_051_HORIZONTAL) M0G_WIDTH_051
M0G_052 = OR (M0G INTERACT M0G_052_HORIZONTAL) M0G_WIDTH_052
M0G_053 = OR (M0G INTERACT M0G_053_HORIZONTAL) M0G_WIDTH_053
M0G_054 = OR (M0G INTERACT M0G_054_HORIZONTAL) M0G_WIDTH_054
M0G_055 = OR (M0G INTERACT M0G_055_HORIZONTAL) M0G_WIDTH_055
M0G_060 = COPY M0G_WIDTH_060
M0G_088 = COPY M0G_WIDTH_088
M0G_090 = COPY M0G_WIDTH_090

M0G_040_050 = M0G_040 OR M0G_050
M0G_040_060 = M0G_040 OR M0G_060
AOP_M0G_040_060 = AOP_M0G_040 OR AOP_M0G_060
//; Above derivations are for the M0G width in S/D direction

DOP_M0G_032 = DOP_M0G WITH WIDTH == 0.032
DOP_M0G_040 = DOP_M0G WITH WIDTH == 0.040
DOP_M0G_050 = DOP_M0G WITH WIDTH == 0.050
DOP_M0G_051 = DOP_M0G WITH WIDTH == 0.051
DOP_M0G_052 = DOP_M0G WITH WIDTH == 0.052
DOP_M0G_053 = DOP_M0G WITH WIDTH == 0.053
DOP_M0G_054 = DOP_M0G WITH WIDTH == 0.054
DOP_M0G_055 = DOP_M0G WITH WIDTH == 0.055
DOP_M0G_060 = DOP_M0G WITH WIDTH == 0.060
DOP_M0G_088 = DOP_M0G WITH WIDTH == 0.088
DOP_M0G_090 = DOP_M0G WITH WIDTH == 0.090

AOP_M0G_WIDTH_040 = DOP_M0G_040 OR M0G_WIDTH_040
AOP_M0G_WIDTH_060 = DOP_M0G_060 OR M0G_WIDTH_060
AOP_M0G_032 = DOP_M0G_032 OR M0G_032
AOP_M0G_040 = DOP_M0G_040 OR M0G_040
AOP_M0G_050 = DOP_M0G_050 OR M0G_050
AOP_M0G_051 = DOP_M0G_051 OR M0G_051
AOP_M0G_052 = DOP_M0G_052 OR M0G_052
AOP_M0G_053 = DOP_M0G_053 OR M0G_053
AOP_M0G_054 = DOP_M0G_054 OR M0G_054
AOP_M0G_055 = DOP_M0G_055 OR M0G_055
AOP_M0G_060 = DOP_M0G_060 OR M0G_060
AOP_M0G_088 = DOP_M0G_088 OR M0G_088
AOP_M0G_090 = DOP_M0G_090 OR M0G_090
AOP_M0G_W060_L096 = AOP_M0G_060 WITH EDGE (LENGTH AOP_M0G_060 == 0.096)
AOP_M0G_W060_L095_L096 = AOP_M0G_060 WITH EDGE (LENGTH AOP_M0G_060 >= 0.095 <= 0.096)

M0G_040_L_edges = LENGTH M0G_040 > 0.040
M0G_060_L_edges = LENGTH M0G_060 > 0.060
M0G_088_L_edges = LENGTH M0G_088 > 0.088
M0G_090_L_edges = LENGTH M0G_090 > 0.090
M0G_040_eq_040_edges = LENGTH M0G_040 == 0.040
M0G_050_eq_050_edges = LENGTH M0G_050 == 0.050
M0G_051_eq_051_edges = LENGTH M0G_051 == 0.051
M0G_054_eq_054_edges = LENGTH M0G_054 == 0.054
M0G_060_eq_060_edges = LENGTH M0G_060 == 0.060
M0G_090_eq_090_edges = LENGTH M0G_090 == 0.090

AOP_M0G_040_W_edges = LENGTH AOP_M0G_040 == 0.040
AOP_M0G_060_W_edges = LENGTH AOP_M0G_060 == 0.060
AOP_M0G_040_L_edges = LENGTH AOP_M0G_040 > 0.040
AOP_M0G_060_L_edges = LENGTH AOP_M0G_060 > 0.060

AOP_M0G_040_eq_040_edges = LENGTH AOP_M0G_040 == 0.040
AOP_M0G_050_eq_050_edges = LENGTH AOP_M0G_050 == 0.050

M0G_040_v_edges = M0G_040 COIN EDGE M0G_v_edges
M0G_040_h_edges = M0G_040 COIN EDGE M0G_h_edges
M0G_060_v_edges = M0G_060 COIN EDGE M0G_v_edges
M0G_060_h_edges = M0G_060 COIN EDGE M0G_h_edges

M0G_051_054_090 = OR M0G_051 M0G_054 M0G_090
M0G_051_054_090_v_edges = ANGLE M0G_051_054_090 == 90
M0G_051_054_090_h_edges = ANGLE M0G_051_054_090 == 0

M0G_051_To_055 = M0G WITH WIDTH >= 0.051 <= 0.055
M0G_051_To_055_088 = OR M0G_051_To_055 M0G_088 M0G_WIDTH_088
M0G_051_To_055_088_v_edges = ANGLE M0G_051_To_055_088 == 90
M0G_051_To_055_088_h_edges = ANGLE M0G_051_To_055_088 == 0

AOP_M0G_051_To_055 = AOP_M0G WITH WIDTH >= 0.051 <= 0.055
AOP_M0G_051_To_055_088 = OR AOP_M0G_051_To_055 AOP_M0G_088
AOP_M0G_032_050 = OR AOP_M0G_032 AOP_M0G_050
AOP_M0G_AND_AOP_AA = AOP_M0G AND AOP_AA
M0G_AND_AOP_AA = M0G AND AOP_AA
M0G_050_ALL = M0G_WIDTH_050 OR M0G_050
M0G_060_ALL = M0G_WIDTH_060 OR M0G_060
ALL_GT_with_M0G = ALL_GT INTERACT M0G

// ========================
// P2 derivation
// ========================
P2_W_036_edges = INT [P2_h_edges] == 0.036 OPPOSITE //;SRAM
P2_W_036 = INT P2_h_edges == 0.036 OPPOSITE REGION //;SRAM
P2_W_048_edges = INT [P2_h_edges] == 0.048 OPPOSITE
P2_W_048 = INT P2_h_edges == 0.048 OPPOSITE REGION
P2_W_066_edges = INT [P2_h_edges] == 0.066 OPPOSITE
P2_W_066 = INT P2_h_edges == 0.066 OPPOSITE REGION
P2_W_068_edges = INT [P2_h_edges] == 0.068 OPPOSITE
P2_W_068 = INT P2_h_edges == 0.068 OPPOSITE REGION
P2_W_082_edges = INT [P2_h_edges] == 0.082 OPPOSITE
P2_W_082 = INT P2_h_edges == 0.082 OPPOSITE REGION
P2_W_108_edges = INT [P2_h_edges] == 0.108 OPPOSITE
P2_W_108 = INT P2_h_edges == 0.108 OPPOSITE REGION
P2_W_110_edges = INT [P2_h_edges] == 0.110 OPPOSITE
P2_W_110 = INT P2_h_edges == 0.110 OPPOSITE REGION
P2_W_130_edges = INT [P2_h_edges] == 0.130 OPPOSITE
P2_W_130 = INT P2_h_edges == 0.130 OPPOSITE REGION

P2_W_eqgt_108_edges = INT (P2_h_edges) < 0.108 OPPOSITE

P2_eqgt_108 = P2 WITH WIDTH >= 0.108
P2_eqgt_110 = P2_eqgt_108 WITH WIDTH >= 0.11

P2_convex_90_90_edge = CONVEX EDGE P2 ANGLE1 == 90 ANGLE2 == 90
P2_convex_90_270_edge = CONVEX EDGE P2 ANGLE1 == 90 ANGLE2 == 270
P2_convex_270_270_edge = CONVEX EDGE P2 ANGLE1 == 270 ANGLE2 == 270

// ========================
// Via derivation
// ========================
V0N = RECTANGLE V0 == 0.032 BY == 0.032 //; square V0 with width and length = 0.032
RV0 = RECTANGLE V0 == 0.032 BY == 0.08 //; rectangular V0 with width= 0.032/length= 0.08
V0_SR = V0N OR RV0
RV0_W = LENGTH RV0 == 0.032  //; long edges of rectangular V0 with length = 0.032
RV0_L = LENGTH RV0 > 0.032  //; long edges of rectangular V0 with length = 0.080
DVK_V0_SR = V0 RECTANGLE ORTHOGONAL ONLY
DVK_V0_SQ = V0 RECTANGLE ORTHOGONAL ONLY ASPECT == 1
DVK_V0_RE = V0 RECTANGLE ORTHOGONAL ONLY ASPECT > 1
V0N_Seal_Ring = (RECTANGLE V0 == 0.09 BY == 0.09) INSIDE MARKS
V0_BAR_100 = V0 WITH WIDTH == 0.10
V0_BAR_100_all = V0 INTERACT V0_BAR_100
V0_BAR_140 = V0 WITH WIDTH == 0.14   //; select all the via bar (only the orthogonal part) with width = 0.14. Only for V0.W.2
V0_BAR_140_all = V0 INTERACT V0_BAR_140   //; select all the via bar (include orthogonal and non-orthogonal via) with width = 0.14
V0_BAR_360 = V0 WITH WIDTH == 0.36
V0_BAR_360_all = V0 INTERACT V0_BAR_360

 
 //via type is Vy 
2XV1N = RECTANGLE V1 == 0.064 BY == 0.064
1XV1N = RECTANGLE V1 == 0.032 BY == 0.032
V1N = 1XV1N OR 2XV1N
V1_SR = V1N OR RV1
DVK_V1_SR = V1 RECTANGLE ORTHOGONAL ONLY
DVK_V1_SQ = V1 RECTANGLE ORTHOGONAL ONLY ASPECT == 1
DVK_V1_RE = V1 RECTANGLE ORTHOGONAL ONLY ASPECT > 1
RV1 = RECTANGLE V1 == 0.032 BY == 0.08
RV1_W = LENGTH RV1 == 0.032
RV1_L = LENGTH RV1 == 0.080
V1N_Seal_Ring = (RECTANGLE V1 == 0.09 BY == 0.09) INSIDE MARKS
V1_BAR_140 = V1 WITH WIDTH == 0.14 // select all the via bar (only the orthogonal part) with width = 0.14
V1_BAR_450 = V1 WITH WIDTH == 0.45 // select all the via bar (only the orthogonal part) with width = 0.45
V1_BAR_140_all = V1 INTERACT V1_BAR_140 // select all the via bar (include orthogonal and non-orthogonal via) with width = 0.14
V1_BAR_450_all = V1 INTERACT V1_BAR_450 // select all the via bar (include orthogonal and non-orthogonal via) with width = 0.45
V1_BAR_100 = V1 WITH WIDTH == 0.10
V1_BAR_100_all = V1 INTERACT V1_BAR_100
V1_BAR_360 = V1 WITH WIDTH == 0.36
V1_BAR_360_all = V1 INTERACT V1_BAR_360
 
 //via type is Vy 
2XV2N = RECTANGLE V2 == 0.064 BY == 0.064
1XV2N = RECTANGLE V2 == 0.032 BY == 0.032
V2N = 1XV2N OR 2XV2N
V2_SR = V2N OR RV2
DVK_V2_SR = V2 RECTANGLE ORTHOGONAL ONLY
DVK_V2_SQ = V2 RECTANGLE ORTHOGONAL ONLY ASPECT == 1
DVK_V2_RE = V2 RECTANGLE ORTHOGONAL ONLY ASPECT > 1
RV2 = RECTANGLE V2 == 0.032 BY == 0.08
RV2_W = LENGTH RV2 == 0.032
RV2_L = LENGTH RV2 == 0.080
V2N_Seal_Ring = (RECTANGLE V2 == 0.09 BY == 0.09) INSIDE MARKS
V2_BAR_140 = V2 WITH WIDTH == 0.14 // select all the via bar (only the orthogonal part) with width = 0.14
V2_BAR_450 = V2 WITH WIDTH == 0.45 // select all the via bar (only the orthogonal part) with width = 0.45
V2_BAR_140_all = V2 INTERACT V2_BAR_140 // select all the via bar (include orthogonal and non-orthogonal via) with width = 0.14
V2_BAR_450_all = V2 INTERACT V2_BAR_450 // select all the via bar (include orthogonal and non-orthogonal via) with width = 0.45
V2_BAR_100 = V2 WITH WIDTH == 0.10
V2_BAR_100_all = V2 INTERACT V2_BAR_100
V2_BAR_360 = V2 WITH WIDTH == 0.36
V2_BAR_360_all = V2 INTERACT V2_BAR_360
 
 //via type is Vy 
2XV3N = RECTANGLE V3 == 0.064 BY == 0.064
1XV3N = RECTANGLE V3 == 0.032 BY == 0.032
V3N = 1XV3N OR 2XV3N
V3_SR = V3N OR RV3
DVK_V3_SR = V3 RECTANGLE ORTHOGONAL ONLY
DVK_V3_SQ = V3 RECTANGLE ORTHOGONAL ONLY ASPECT == 1
DVK_V3_RE = V3 RECTANGLE ORTHOGONAL ONLY ASPECT > 1
RV3 = RECTANGLE V3 == 0.032 BY == 0.08
RV3_W = LENGTH RV3 == 0.032
RV3_L = LENGTH RV3 == 0.080
V3N_Seal_Ring = (RECTANGLE V3 == 0.09 BY == 0.09) INSIDE MARKS
V3_BAR_140 = V3 WITH WIDTH == 0.14 // select all the via bar (only the orthogonal part) with width = 0.14
V3_BAR_450 = V3 WITH WIDTH == 0.45 // select all the via bar (only the orthogonal part) with width = 0.45
V3_BAR_140_all = V3 INTERACT V3_BAR_140 // select all the via bar (include orthogonal and non-orthogonal via) with width = 0.14
V3_BAR_450_all = V3 INTERACT V3_BAR_450 // select all the via bar (include orthogonal and non-orthogonal via) with width = 0.45
V3_BAR_100 = V3 WITH WIDTH == 0.10
V3_BAR_100_all = V3 INTERACT V3_BAR_100
V3_BAR_360 = V3 WITH WIDTH == 0.36
V3_BAR_360_all = V3 INTERACT V3_BAR_360
 
 //via type is 1.25xVn 
V4N = RECTANGLE V4 == 0.04 BY == 0.04
RV4 = RECTANGLE V4 == 0.04 BY == 0.1
V4_SR = V4N OR RV4
RV4_W = LENGTH RV4 == 0.04
RV4_L = LENGTH RV4 == 0.10
DVK_V4_SR = V4 RECTANGLE ORTHOGONAL ONLY
DVK_V4_SQ = V4 RECTANGLE ORTHOGONAL ONLY ASPECT == 1
DVK_V4_RE = V4 RECTANGLE ORTHOGONAL ONLY ASPECT > 1
V4N_Seal_Ring = (RECTANGLE V4 == 0.09 BY == 0.09) INSIDE MARKS
V4_BAR_140 = V4 WITH WIDTH == 0.14 // select all the via bar (only the orthogonal part) with width = 0.14
V4_BAR_450 = V4 WITH WIDTH == 0.45 // select all the via bar (only the orthogonal part) with width = 0.45
V4_BAR_140_all = V4 INTERACT V4_BAR_140 // select all the via bar (include orthogonal and non-orthogonal via) with width = 0.14
V4_BAR_450_all = V4 INTERACT V4_BAR_450 // select all the via bar (include orthogonal and non-orthogonal via) with width = 0.45
V4_BAR_100 = V4 WITH WIDTH == 0.10
V4_BAR_100_all = V4 INTERACT V4_BAR_100
V4_BAR_360 = V4 WITH WIDTH == 0.36
V4_BAR_360_all = V4 INTERACT V4_BAR_360
 
 //via type is 1.25xVn 
V5N = RECTANGLE V5 == 0.04 BY == 0.04
RV5 = RECTANGLE V5 == 0.04 BY == 0.1
V5_SR = V5N OR RV5
RV5_W = LENGTH RV5 == 0.04
RV5_L = LENGTH RV5 == 0.10
DVK_V5_SR = V5 RECTANGLE ORTHOGONAL ONLY
DVK_V5_SQ = V5 RECTANGLE ORTHOGONAL ONLY ASPECT == 1
DVK_V5_RE = V5 RECTANGLE ORTHOGONAL ONLY ASPECT > 1
V5N_Seal_Ring = (RECTANGLE V5 == 0.09 BY == 0.09) INSIDE MARKS
V5_BAR_140 = V5 WITH WIDTH == 0.14 // select all the via bar (only the orthogonal part) with width = 0.14
V5_BAR_450 = V5 WITH WIDTH == 0.45 // select all the via bar (only the orthogonal part) with width = 0.45
V5_BAR_140_all = V5 INTERACT V5_BAR_140 // select all the via bar (include orthogonal and non-orthogonal via) with width = 0.14
V5_BAR_450_all = V5 INTERACT V5_BAR_450 // select all the via bar (include orthogonal and non-orthogonal via) with width = 0.45
V5_BAR_100 = V5 WITH WIDTH == 0.10
V5_BAR_100_all = V5 INTERACT V5_BAR_100
V5_BAR_360 = V5 WITH WIDTH == 0.36
V5_BAR_360_all = V5 INTERACT V5_BAR_360
 
 //via type is 1.25xVn 
V6N = RECTANGLE V6 == 0.04 BY == 0.04
RV6 = RECTANGLE V6 == 0.04 BY == 0.1
V6_SR = V6N OR RV6
RV6_W = LENGTH RV6 == 0.04
RV6_L = LENGTH RV6 == 0.10
DVK_V6_SR = V6 RECTANGLE ORTHOGONAL ONLY
DVK_V6_SQ = V6 RECTANGLE ORTHOGONAL ONLY ASPECT == 1
DVK_V6_RE = V6 RECTANGLE ORTHOGONAL ONLY ASPECT > 1
V6N_Seal_Ring = (RECTANGLE V6 == 0.09 BY == 0.09) INSIDE MARKS
V6_BAR_140 = V6 WITH WIDTH == 0.14 // select all the via bar (only the orthogonal part) with width = 0.14
V6_BAR_450 = V6 WITH WIDTH == 0.45 // select all the via bar (only the orthogonal part) with width = 0.45
V6_BAR_140_all = V6 INTERACT V6_BAR_140 // select all the via bar (include orthogonal and non-orthogonal via) with width = 0.14
V6_BAR_450_all = V6 INTERACT V6_BAR_450 // select all the via bar (include orthogonal and non-orthogonal via) with width = 0.45
V6_BAR_100 = V6 WITH WIDTH == 0.10
V6_BAR_100_all = V6 INTERACT V6_BAR_100
V6_BAR_360 = V6 WITH WIDTH == 0.36
V6_BAR_360_all = V6 INTERACT V6_BAR_360
 
TV2N = RECTANGLE TV2 == 0.324 BY == 0.324
TV2_SR = COPY TV2N
DVK_TV2_SR = TV2 RECTANGLE ORTHOGONAL ONLY
DVK_TV2_SQ = TV2 RECTANGLE ORTHOGONAL ONLY ASPECT == 1
DVK_TV2_RE = TV2 RECTANGLE ORTHOGONAL ONLY ASPECT > 1
TV2N_Seal_Ring = (RECTANGLE TV2 == 0.36 BY == 0.36) INSIDE MARKS

// ========================
// Line/Line End derivation
// ========================
GT_R = RECTANGLE GT ASPECT > 1
GT_lend_R = GT_R COIN EDGE GT_W_edges
GT_line_R = LENGTH (GT_R COIN EDGE GT_L_edges) <= 0.08
GT_end_non_R = (CONVEX EDGE GT ANGLE1==90 ANGLE2==90 WITH LENGTH <= 0.08) NOT COIN EDGE GT_line_R
GT_end = GT_lend_R OR EDGE GT_end_non_R
GT_line = LENGTH (GT NOT COIN EDGE GT_lend_R) > 0.08

AOP_GT_R = RECTANGLE AOP_GT ASPECT > 1
AOP_GT_lend_R = AOP_GT_R COIN EDGE AOP_GT_W_edges
AOP_GT_line_R = LENGTH (AOP_GT_R COIN EDGE AOP_GT_L_edges) <= 0.08
AOP_GT_end_non_R = (CONVEX EDGE AOP_GT ANGLE1==90 ANGLE2==90 WITH LENGTH <= 0.08) NOT COIN EDGE AOP_GT_line_R
AOP_GT_end = AOP_GT_lend_R OR EDGE AOP_GT_end_non_R
AOP_GT_line = LENGTH (AOP_GT NOT COIN EDGE AOP_GT_lend_R) > 0.08

M1_WL_edges_a = DFM PROPERTY M1 M1_h_edges M1_v_edges OVERLAP ABUT ALSO MULTI [h_v_ratio = LENGTH(M1_h_edges) - LENGTH(M1_v_edges)] >= 0
M1_WL_edges_b = DFM PROPERTY M1 M1_h_edges M1_v_edges OVERLAP ABUT ALSO MULTI [h_v_ratio = LENGTH(M1_v_edges) - LENGTH(M1_h_edges)] >= 0
M1_W_edges = (M1_v_edges COIN EDGE M1_WL_edges_a) OR EDGE (M1_h_edges COIN EDGE M1_WL_edges_b)
M1_L_edges = (M1_h_edges COIN EDGE M1_WL_edges_a) OR EDGE (M1_v_edges COIN EDGE M1_WL_edges_b)
M2_WL_edges_a = DFM PROPERTY M2 M2_h_edges M2_v_edges OVERLAP ABUT ALSO MULTI [h_v_ratio = LENGTH(M2_h_edges) - LENGTH(M2_v_edges)] >= 0
M2_WL_edges_b = DFM PROPERTY M2 M2_h_edges M2_v_edges OVERLAP ABUT ALSO MULTI [h_v_ratio = LENGTH(M2_v_edges) - LENGTH(M2_h_edges)] >= 0
M2_W_edges = (M2_v_edges COIN EDGE M2_WL_edges_a) OR EDGE (M2_h_edges COIN EDGE M2_WL_edges_b)
M2_L_edges = (M2_h_edges COIN EDGE M2_WL_edges_a) OR EDGE (M2_v_edges COIN EDGE M2_WL_edges_b)
M3_WL_edges_a = DFM PROPERTY M3 M3_h_edges M3_v_edges OVERLAP ABUT ALSO MULTI [h_v_ratio = LENGTH(M3_h_edges) - LENGTH(M3_v_edges)] >= 0
M3_WL_edges_b = DFM PROPERTY M3 M3_h_edges M3_v_edges OVERLAP ABUT ALSO MULTI [h_v_ratio = LENGTH(M3_v_edges) - LENGTH(M3_h_edges)] >= 0
M3_W_edges = (M3_v_edges COIN EDGE M3_WL_edges_a) OR EDGE (M3_h_edges COIN EDGE M3_WL_edges_b)
M3_L_edges = (M3_h_edges COIN EDGE M3_WL_edges_a) OR EDGE (M3_v_edges COIN EDGE M3_WL_edges_b)
M4_WL_edges_a = DFM PROPERTY M4 M4_h_edges M4_v_edges OVERLAP ABUT ALSO MULTI [h_v_ratio = LENGTH(M4_h_edges) - LENGTH(M4_v_edges)] >= 0
M4_WL_edges_b = DFM PROPERTY M4 M4_h_edges M4_v_edges OVERLAP ABUT ALSO MULTI [h_v_ratio = LENGTH(M4_v_edges) - LENGTH(M4_h_edges)] >= 0
M4_W_edges = (M4_v_edges COIN EDGE M4_WL_edges_a) OR EDGE (M4_h_edges COIN EDGE M4_WL_edges_b)
M4_L_edges = (M4_h_edges COIN EDGE M4_WL_edges_a) OR EDGE (M4_v_edges COIN EDGE M4_WL_edges_b)
M5_WL_edges_a = DFM PROPERTY M5 M5_h_edges M5_v_edges OVERLAP ABUT ALSO MULTI [h_v_ratio = LENGTH(M5_h_edges) - LENGTH(M5_v_edges)] >= 0
M5_WL_edges_b = DFM PROPERTY M5 M5_h_edges M5_v_edges OVERLAP ABUT ALSO MULTI [h_v_ratio = LENGTH(M5_v_edges) - LENGTH(M5_h_edges)] >= 0
M5_W_edges = (M5_v_edges COIN EDGE M5_WL_edges_a) OR EDGE (M5_h_edges COIN EDGE M5_WL_edges_b)
M5_L_edges = (M5_h_edges COIN EDGE M5_WL_edges_a) OR EDGE (M5_v_edges COIN EDGE M5_WL_edges_b)
M6_WL_edges_a = DFM PROPERTY M6 M6_h_edges M6_v_edges OVERLAP ABUT ALSO MULTI [h_v_ratio = LENGTH(M6_h_edges) - LENGTH(M6_v_edges)] >= 0
M6_WL_edges_b = DFM PROPERTY M6 M6_h_edges M6_v_edges OVERLAP ABUT ALSO MULTI [h_v_ratio = LENGTH(M6_v_edges) - LENGTH(M6_h_edges)] >= 0
M6_W_edges = (M6_v_edges COIN EDGE M6_WL_edges_a) OR EDGE (M6_h_edges COIN EDGE M6_WL_edges_b)
M6_L_edges = (M6_h_edges COIN EDGE M6_WL_edges_a) OR EDGE (M6_v_edges COIN EDGE M6_WL_edges_b)
M7_WL_edges_a = DFM PROPERTY M7 M7_h_edges M7_v_edges OVERLAP ABUT ALSO MULTI [h_v_ratio = LENGTH(M7_h_edges) - LENGTH(M7_v_edges)] >= 0
M7_WL_edges_b = DFM PROPERTY M7 M7_h_edges M7_v_edges OVERLAP ABUT ALSO MULTI [h_v_ratio = LENGTH(M7_v_edges) - LENGTH(M7_h_edges)] >= 0
M7_W_edges = (M7_v_edges COIN EDGE M7_WL_edges_a) OR EDGE (M7_h_edges COIN EDGE M7_WL_edges_b)
M7_L_edges = (M7_h_edges COIN EDGE M7_WL_edges_a) OR EDGE (M7_v_edges COIN EDGE M7_WL_edges_b)
M8_WL_edges_a = DFM PROPERTY M8 M8_h_edges M8_v_edges OVERLAP ABUT ALSO MULTI [h_v_ratio = LENGTH(M8_h_edges) - LENGTH(M8_v_edges)] >= 0
M8_WL_edges_b = DFM PROPERTY M8 M8_h_edges M8_v_edges OVERLAP ABUT ALSO MULTI [h_v_ratio = LENGTH(M8_v_edges) - LENGTH(M8_h_edges)] >= 0
M8_W_edges = (M8_v_edges COIN EDGE M8_WL_edges_a) OR EDGE (M8_h_edges COIN EDGE M8_WL_edges_b)
M8_L_edges = (M8_h_edges COIN EDGE M8_WL_edges_a) OR EDGE (M8_v_edges COIN EDGE M8_WL_edges_b)
 
M1_R = RECTANGLE M1 ASPECT > 1
M1_lend_R = M1_R COIN EDGE M1_W_edges
M1_line_R = LENGTH (M1_R COIN EDGE M1_L_edges) <= 0.08
M1_end_non_R = (CONVEX EDGE M1 ANGLE1==90 ANGLE2==90 WITH LENGTH <= 0.08) NOT COIN EDGE M1_line_R
M1_end = M1_lend_R OR EDGE M1_end_non_R
M1_line = COPY M1
 
M2_R = RECTANGLE M2 ASPECT > 1
M2_lend_R = M2_R COIN EDGE M2_W_edges
M2_line_R = LENGTH (M2_R COIN EDGE M2_L_edges) <= 0.08
M2_end_non_R = (CONVEX EDGE M2 ANGLE1==90 ANGLE2==90 WITH LENGTH <= 0.08) NOT COIN EDGE M2_line_R
M2_end = M2_lend_R OR EDGE M2_end_non_R
M2_line = COPY M2
 
M3_R = RECTANGLE M3 ASPECT > 1
M3_lend_R = M3_R COIN EDGE M3_W_edges
M3_line_R = LENGTH (M3_R COIN EDGE M3_L_edges) <= 0.08
M3_end_non_R = (CONVEX EDGE M3 ANGLE1==90 ANGLE2==90 WITH LENGTH <= 0.08) NOT COIN EDGE M3_line_R
M3_end = M3_lend_R OR EDGE M3_end_non_R
M3_line = COPY M3
 
M4_R = RECTANGLE M4 ASPECT > 1
M4_lend_R = M4_R COIN EDGE M4_W_edges
M4_line_R = LENGTH (M4_R COIN EDGE M4_L_edges) <= 0.08
M4_end_non_R = (CONVEX EDGE M4 ANGLE1==90 ANGLE2==90 WITH LENGTH <= 0.08) NOT COIN EDGE M4_line_R
M4_end = M4_lend_R OR EDGE M4_end_non_R
M4_line = COPY M4
 
M5_R = RECTANGLE M5 ASPECT > 1
M5_lend_R = M5_R COIN EDGE M5_W_edges
M5_line_R = LENGTH (M5_R COIN EDGE M5_L_edges) <= 0.08
M5_end_non_R = (CONVEX EDGE M5 ANGLE1==90 ANGLE2==90 WITH LENGTH <= 0.08) NOT COIN EDGE M5_line_R
M5_end = M5_lend_R OR EDGE M5_end_non_R
M5_line = COPY M5
 
M6_R = RECTANGLE M6 ASPECT > 1
M6_lend_R = M6_R COIN EDGE M6_W_edges
M6_line_R = LENGTH (M6_R COIN EDGE M6_L_edges) <= 0.08
M6_end_non_R = (CONVEX EDGE M6 ANGLE1==90 ANGLE2==90 WITH LENGTH <= 0.08) NOT COIN EDGE M6_line_R
M6_end = M6_lend_R OR EDGE M6_end_non_R
M6_line = COPY M6
 
M7_R = RECTANGLE M7 ASPECT > 1
M7_lend_R = M7_R COIN EDGE M7_W_edges
M7_line_R = LENGTH (M7_R COIN EDGE M7_L_edges) <= 0.08
M7_end_non_R = (CONVEX EDGE M7 ANGLE1==90 ANGLE2==90 WITH LENGTH <= 0.08) NOT COIN EDGE M7_line_R
M7_end = M7_lend_R OR EDGE M7_end_non_R
M7_line = COPY M7
 
M8_R = RECTANGLE M8 ASPECT > 1
M8_lend_R = M8_R COIN EDGE M8_W_edges
M8_line_R = LENGTH (M8_R COIN EDGE M8_L_edges) <= 0.08
M8_end_non_R = (CONVEX EDGE M8 ANGLE1==90 ANGLE2==90 WITH LENGTH <= 0.08) NOT COIN EDGE M8_line_R
M8_end = M8_lend_R OR EDGE M8_end_non_R
M8_line = COPY M8
 
M1_convex_270_270_edges = CONVEX EDGE M1 ANGLE1==270 ANGLE2==270
M1_convex_270_90_edges = CONVEX EDGE M1 ANGLE1==270 ANGLE2==90
M1_convex_90_90_edges = CONVEX EDGE M1 ANGLE1==90 ANGLE2==90
M1_convex_eq_two_edges = CONVEX EDGE M1 == 2
M1_convex_lt_two_edges = CONVEX EDGE M1 <= 1
M1_convex_eq_one_edges = CONVEX EDGE M1 == 1
M1_convex_gt_one_edges = CONVEX EDGE M1 >= 1
 
M2_convex_270_270_edges = CONVEX EDGE M2 ANGLE1==270 ANGLE2==270
M2_convex_270_90_edges = CONVEX EDGE M2 ANGLE1==270 ANGLE2==90
M2_convex_90_90_edges = CONVEX EDGE M2 ANGLE1==90 ANGLE2==90
M2_convex_eq_two_edges = CONVEX EDGE M2 == 2
M2_convex_lt_two_edges = CONVEX EDGE M2 <= 1
M2_convex_eq_one_edges = CONVEX EDGE M2 == 1
M2_convex_gt_one_edges = CONVEX EDGE M2 >= 1
 
M3_convex_270_270_edges = CONVEX EDGE M3 ANGLE1==270 ANGLE2==270
M3_convex_270_90_edges = CONVEX EDGE M3 ANGLE1==270 ANGLE2==90
M3_convex_90_90_edges = CONVEX EDGE M3 ANGLE1==90 ANGLE2==90
M3_convex_eq_two_edges = CONVEX EDGE M3 == 2
M3_convex_lt_two_edges = CONVEX EDGE M3 <= 1
M3_convex_eq_one_edges = CONVEX EDGE M3 == 1
M3_convex_gt_one_edges = CONVEX EDGE M3 >= 1
 
M4_convex_270_270_edges = CONVEX EDGE M4 ANGLE1==270 ANGLE2==270
M4_convex_270_90_edges = CONVEX EDGE M4 ANGLE1==270 ANGLE2==90
M4_convex_90_90_edges = CONVEX EDGE M4 ANGLE1==90 ANGLE2==90
M4_convex_eq_two_edges = CONVEX EDGE M4 == 2
M4_convex_lt_two_edges = CONVEX EDGE M4 <= 1
M4_convex_eq_one_edges = CONVEX EDGE M4 == 1
M4_convex_gt_one_edges = CONVEX EDGE M4 >= 1
 
M5_convex_270_270_edges = CONVEX EDGE M5 ANGLE1==270 ANGLE2==270
M5_convex_270_90_edges = CONVEX EDGE M5 ANGLE1==270 ANGLE2==90
M5_convex_90_90_edges = CONVEX EDGE M5 ANGLE1==90 ANGLE2==90
M5_convex_eq_two_edges = CONVEX EDGE M5 == 2
M5_convex_lt_two_edges = CONVEX EDGE M5 <= 1
M5_convex_eq_one_edges = CONVEX EDGE M5 == 1
M5_convex_gt_one_edges = CONVEX EDGE M5 >= 1
 
M6_convex_270_270_edges = CONVEX EDGE M6 ANGLE1==270 ANGLE2==270
M6_convex_270_90_edges = CONVEX EDGE M6 ANGLE1==270 ANGLE2==90
M6_convex_90_90_edges = CONVEX EDGE M6 ANGLE1==90 ANGLE2==90
M6_convex_eq_two_edges = CONVEX EDGE M6 == 2
M6_convex_lt_two_edges = CONVEX EDGE M6 <= 1
M6_convex_eq_one_edges = CONVEX EDGE M6 == 1
M6_convex_gt_one_edges = CONVEX EDGE M6 >= 1
 
M7_convex_270_270_edges = CONVEX EDGE M7 ANGLE1==270 ANGLE2==270
M7_convex_270_90_edges = CONVEX EDGE M7 ANGLE1==270 ANGLE2==90
M7_convex_90_90_edges = CONVEX EDGE M7 ANGLE1==90 ANGLE2==90
M7_convex_eq_two_edges = CONVEX EDGE M7 == 2
M7_convex_lt_two_edges = CONVEX EDGE M7 <= 1
M7_convex_eq_one_edges = CONVEX EDGE M7 == 1
M7_convex_gt_one_edges = CONVEX EDGE M7 >= 1
 
M8_convex_270_270_edges = CONVEX EDGE M8 ANGLE1==270 ANGLE2==270
M8_convex_270_90_edges = CONVEX EDGE M8 ANGLE1==270 ANGLE2==90
M8_convex_90_90_edges = CONVEX EDGE M8 ANGLE1==90 ANGLE2==90
M8_convex_eq_two_edges = CONVEX EDGE M8 == 2
M8_convex_lt_two_edges = CONVEX EDGE M8 <= 1
M8_convex_eq_one_edges = CONVEX EDGE M8 == 1
M8_convex_gt_one_edges = CONVEX EDGE M8 >= 1
 
M1_45_skew_edges = ANGLE M1 > 44.5 < 45.5
M2_45_skew_edges = ANGLE M2 > 44.5 < 45.5
M3_45_skew_edges = ANGLE M3 > 44.5 < 45.5
M4_45_skew_edges = ANGLE M4 > 44.5 < 45.5
M5_45_skew_edges = ANGLE M5 > 44.5 < 45.5
M6_45_skew_edges = ANGLE M6 > 44.5 < 45.5
M7_45_skew_edges = ANGLE M7 > 44.5 < 45.5
M8_45_skew_edges = ANGLE M8 > 44.5 < 45.5
 
M1_end_080 = LENGTH M1_convex_eq_two_edges < 0.080
M1_end_085 = LENGTH M1_convex_eq_two_edges < 0.085
M1_end_072 = LENGTH M1_convex_eq_two_edges < 0.072
M1_end_060 = LENGTH M1_convex_90_90_edges < 0.060
M2_end_080 = LENGTH M2_convex_eq_two_edges < 0.080
M2_end_085 = LENGTH M2_convex_eq_two_edges < 0.085
M2_end_072 = LENGTH M2_convex_eq_two_edges < 0.072
M2_end_060 = LENGTH M2_convex_90_90_edges < 0.060
M3_end_080 = LENGTH M3_convex_eq_two_edges < 0.080
M3_end_085 = LENGTH M3_convex_eq_two_edges < 0.085
M3_end_072 = LENGTH M3_convex_eq_two_edges < 0.072
M3_end_060 = LENGTH M3_convex_90_90_edges < 0.060
M4_end_080 = LENGTH M4_convex_eq_two_edges < 0.080
M4_end_085 = LENGTH M4_convex_eq_two_edges < 0.085
M4_end_072 = LENGTH M4_convex_eq_two_edges < 0.072
M4_end_060 = LENGTH M4_convex_90_90_edges < 0.060
M5_end_080 = LENGTH M5_convex_eq_two_edges < 0.080
M5_end_085 = LENGTH M5_convex_eq_two_edges < 0.085
M5_end_072 = LENGTH M5_convex_eq_two_edges < 0.072
M5_end_060 = LENGTH M5_convex_90_90_edges < 0.060
M6_end_080 = LENGTH M6_convex_eq_two_edges < 0.080
M6_end_085 = LENGTH M6_convex_eq_two_edges < 0.085
M6_end_072 = LENGTH M6_convex_eq_two_edges < 0.072
M6_end_060 = LENGTH M6_convex_90_90_edges < 0.060
M7_end_080 = LENGTH M7_convex_eq_two_edges < 0.080
M7_end_085 = LENGTH M7_convex_eq_two_edges < 0.085
M7_end_072 = LENGTH M7_convex_eq_two_edges < 0.072
M7_end_060 = LENGTH M7_convex_90_90_edges < 0.060
M8_end_080 = LENGTH M8_convex_eq_two_edges < 0.080
M8_end_085 = LENGTH M8_convex_eq_two_edges < 0.085
M8_end_072 = LENGTH M8_convex_eq_two_edges < 0.072
M8_end_060 = LENGTH M8_convex_90_90_edges < 0.060
 
// =======================================================================================
// Common Procedures For Calling Of The Similar Rule
// =======================================================================================
// old_code:20170406
// old_code:20170406
// old code 20170406
// old code (V0.6 version: only works when both design value&neighboring side enclosure < 0.04um)

// =======================================================
// Design requirements
// =======================================================

GROUP GGR GR_?
 
GR_1_2_M1 {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID M1 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_V1 {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID V1 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_M2 {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID M2 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_V2 {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID V2 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_M3 {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID M3 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_V3 {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID V3 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_M4 {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID M4 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_V4 {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID V4 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_M5 {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID M5 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_V5 {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID V5 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_M6 {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID M6 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_V6 {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID V6 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_M7 {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID M7 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_TV2 {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID TV2 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_TM2 {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID TM2 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_SVT_N {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID SVT_N 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_SVT_P {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID SVT_P 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_LVT_N {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID LVT_N 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_LVT_P {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID LVT_P 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_HVT_N {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID HVT_N 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_HVT_P {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID HVT_P 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_ULVT_N {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID ULVT_N 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_ULVT_P {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID ULVT_P 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_LFN_N {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID LFN_N 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_LFN_P {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID LFN_P 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_AAi {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID AAi 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_AADOPi {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID AADOPi 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_AADUMi {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID AADUMi 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_AADMPi {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID AADMPi 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_AR {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID AR 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_ARDOP {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID ARDOP 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_ARDUM {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID ARDUM 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_GT {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID GT 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_GTDUM {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID GTDUM 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_GTDOP {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID GTDOP 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_GTDMP {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID GTDMP 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_P2 {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID P2 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_P2DUM {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID P2DUM 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_P2DOP {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID P2DOP 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_P2DMP {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID P2DMP 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_V0i {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID V0i 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_M0i {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID M0i 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_M0DUM {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID M0DUM 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_M0DOP {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID M0DOP 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_M0DMP {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID M0DMP 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_M0G {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID M0G 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_M0GDUM {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID M0GDUM 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_M0GDOP {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID M0GDOP 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_M0GDMP {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID M0GDMP 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_M0C {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID M0C 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_M0CDUM {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID M0CDUM 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_M0CDOP {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID M0CDOP 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_M0CDMP {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID M0CDMP 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_PA {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID PA 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_MD {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID MD 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_CELLB {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID CELLB 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_CHIPB {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID CHIPB 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_AR_Hi {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID AR_Hi 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_AR_HDOP {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID AR_HDOP 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_AR_Vi {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID AR_Vi 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_AR_VDOP {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID AR_VDOP 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_SN {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID SN 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_SP {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID SP 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_NPAA {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID NPAA 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_PPAA {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID PPAA 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_PSUB {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID PSUB 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_NW {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID NW 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_DNW {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID DNW 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_GTMK1 {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID GTMK1 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_GTMK2 {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID GTMK2 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_RESNW {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID RESNW 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_RESP1 {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID RESP1 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_RESP2 {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID RESP2 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_VARMOS {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID VARMOS 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_GT_P96 {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID GT_P96 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_DG {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID DG 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_DGV {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID DGV 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_DGUD {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID DGUD 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_INDMY {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID INDMY 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_LDBK {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID LDBK 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_BIPOLA {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID BIPOLA 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_OCCD {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID OCCD 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_OCOVL {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID OCOVL 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_ALPA {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID ALPA 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_ALDUM {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID ALDUM 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_DUMBA {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID DUMBA 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_DUPMK1 {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID DUPMK1 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_LOGO {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID LOGO 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_MARKF {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID MARKF 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_MARKS {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID MARKS 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_INST {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID INST 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_NODMF {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID NODMF 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_ARBL {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID ARBL 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_IDT {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID IDT 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_MOMDMY {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID MOMDMY 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_MTFUSE {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID MTFUSE 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_DIR {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID DIR 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_DIRDMP {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID DIRDMP 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_DSTR {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID DSTR 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_DMPNP {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID DMPNP 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_DMCMK1 {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID DMCMK1 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_MIM {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID MIM 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_CTOP {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID CTOP 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_DIOMK1 {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID DIOMK1 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_DIOMK2 {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID DIOMK2 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_DMCB1 {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID DMCB1 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_DMC1 {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID DMC1 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_ESDIO1 {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID ESDIO1 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_ESDIO2 {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID ESDIO2 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_M0_B1 {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID M0_B1 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_M0_B2 {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID M0_B2 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_V0_B0 {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID V0_B0 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_V1DUM {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID V1DUM 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_V1DOP {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID V1DOP 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_V2DUM {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID V2DUM 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_V2DOP {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID V2DOP 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_V3DUM {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID V3DUM 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_V3DOP {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID V3DOP 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_V4DUM {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID V4DUM 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_V4DOP {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID V4DOP 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_V5DUM {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID V5DUM 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_V5DOP {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID V5DOP 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_V6DUM {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID V6DUM 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_V6DOP {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID V6DOP 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_V7DUM {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID V7DUM 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_V7DOP {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID V7DOP 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_TV1DUM {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID TV1DUM 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_TV2DUM {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID TV2DUM 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_UTVDUM {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID UTVDUM 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_UTVDOP {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID UTVDOP 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_V0DP {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID V0DP 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_V0CA {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID V0CA 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_V0CB {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID V0CB 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_V0DPDUM {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID V0DPDUM 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_M1DP {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID M1DP 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_M1CA {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID M1CA 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_M1CB {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID M1CB 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_M2DP {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID M2DP 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_M2CA {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID M2CA 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_M2CB {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID M2CB 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_M3DP {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID M3DP 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_M3CA {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID M3CA 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_M3CB {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID M3CB 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_B1DOP {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID B1DOP 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_B1DUM {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID B1DUM 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_B2DOP {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID B2DOP 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_B2DUM {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID B2DUM 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_M1DUM {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID M1DUM 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_M1DOPi {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID M1DOPi 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_M2DUM {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID M2DUM 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_M2DOPi {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID M2DOPi 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_M3DUM {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID M3DUM 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_M3DOPi {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID M3DOPi 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_M4DUM {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID M4DUM 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_M4DOPi {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID M4DOPi 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_M5DUM {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID M5DUM 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_M5DOPi {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID M5DOPi 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_M6DUM {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID M6DUM 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_M6DOPi {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID M6DOPi 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_M7DUM {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID M7DUM 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_M7DOPi {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID M7DOPi 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_M8DUM {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID M8DUM 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_M8DOPi {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID M8DOPi 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_TM1DUM {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID TM1DUM 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_TM2DUM {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID TM2DUM 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_UTMDUM {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID UTMDUM 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
GR_1_2_UTMDOPi {
@ All the geometry design must be an integer multiple of 0.001um. 0.001um deviation is allowed for 45-degree polygon dimensions.
@ Design shape geometry all vertices and intersections of 45-degree polygon must be on an integer multiple of 0.001um.
 err1 = DFM COPY (OFFGRID UTMDOPi 10) EDGE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

GR_3_4 {
@ Only shapes of geometry that are orthogonal or 45-degree angle are allowed
@ Shapes with acute angles between line segments are not allowed
 err1 = DFM COPY (DRAWN SKEW) EDGE
//; err1 = chk_edge NOT COIN EDGE (ANGLE chk_edge > 44.8 < 45.2)
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

GR_16_AA {
@ It is not allowed that AA, GT, P2, NW, SN, SP, M0, M0G, M0C, M1, Mxy, 1.25xMy, 1.25xMn, 2xMn, 10xTMn, 14xTMn and UTM have one edge length < 1x minimum width and another adjencent edge length < 1x minimum width (except DMCMK1 and EFUSE region)
 AA_length_le_minwidth = LENGTH AA < AA_MiniWidth
 AA_length_le_minwidth_expand = EXPAND EDGE AA_length_le_minwidth INSIDE BY 0.001 OUTSIDE BY 0.001
 AA_length_le_minwidth_convex = CONVEX EDGE AA_length_le_minwidth_expand < 2
 err1 = AA_length_le_minwidth_expand WITH EDGE AA_length_le_minwidth_convex
 err1 NOT INSIDE DMCMK1_EFUSE
}

GR_16_GT {
@ It is not allowed that AA, GT, P2, NW, SN, SP, M0, M0G, M0C, M1, Mxy, 1.25xMy, 1.25xMn, 2xMn, 10xTMn, 14xTMn and UTM have one edge length < 1x minimum width and another adjencent edge length < 1x minimum width (except DMCMK1 and EFUSE region)
 GT_length_le_minwidth = LENGTH GT < GT_MiniWidth
 GT_length_le_minwidth_expand = EXPAND EDGE GT_length_le_minwidth INSIDE BY 0.001 OUTSIDE BY 0.001
 GT_length_le_minwidth_convex = CONVEX EDGE GT_length_le_minwidth_expand < 2
 err1 = GT_length_le_minwidth_expand WITH EDGE GT_length_le_minwidth_convex
 err1 NOT INSIDE DMCMK1_EFUSE
}

GR_16_P2 {
@ It is not allowed that AA, GT, P2, NW, SN, SP, M0, M0G, M0C, M1, Mxy, 1.25xMy, 1.25xMn, 2xMn, 10xTMn, 14xTMn and UTM have one edge length < 1x minimum width and another adjencent edge length < 1x minimum width (except DMCMK1 and EFUSE region)
 P2_length_le_minwidth = LENGTH P2 < P2_MiniWidth
 P2_length_le_minwidth_expand = EXPAND EDGE P2_length_le_minwidth INSIDE BY 0.001 OUTSIDE BY 0.001
 P2_length_le_minwidth_convex = CONVEX EDGE P2_length_le_minwidth_expand < 2
 err1 = P2_length_le_minwidth_expand WITH EDGE P2_length_le_minwidth_convex
 err1 NOT INSIDE DMCMK1_EFUSE
}

GR_16_NW {
@ It is not allowed that AA, GT, P2, NW, SN, SP, M0, M0G, M0C, M1, Mxy, 1.25xMy, 1.25xMn, 2xMn, 10xTMn, 14xTMn and UTM have one edge length < 1x minimum width and another adjencent edge length < 1x minimum width (except DMCMK1 and EFUSE region)
 NW_length_le_minwidth = LENGTH NW < NW_MiniWidth
 NW_length_le_minwidth_expand = EXPAND EDGE NW_length_le_minwidth INSIDE BY 0.001 OUTSIDE BY 0.001
 NW_length_le_minwidth_convex = CONVEX EDGE NW_length_le_minwidth_expand < 2
 err1 = NW_length_le_minwidth_expand WITH EDGE NW_length_le_minwidth_convex
 err1 NOT INSIDE DMCMK1_EFUSE
}

GR_16_SN {
@ It is not allowed that AA, GT, P2, NW, SN, SP, M0, M0G, M0C, M1, Mxy, 1.25xMy, 1.25xMn, 2xMn, 10xTMn, 14xTMn and UTM have one edge length < 1x minimum width and another adjencent edge length < 1x minimum width (except DMCMK1 and EFUSE region)
 SN_length_le_minwidth = LENGTH SN < SN_MiniWidth
 SN_length_le_minwidth_expand = EXPAND EDGE SN_length_le_minwidth INSIDE BY 0.001 OUTSIDE BY 0.001
 SN_length_le_minwidth_convex = CONVEX EDGE SN_length_le_minwidth_expand < 2
 err1 = SN_length_le_minwidth_expand WITH EDGE SN_length_le_minwidth_convex
 err1 NOT INSIDE DMCMK1_EFUSE
}

GR_16_SP {
@ It is not allowed that AA, GT, P2, NW, SN, SP, M0, M0G, M0C, M1, Mxy, 1.25xMy, 1.25xMn, 2xMn, 10xTMn, 14xTMn and UTM have one edge length < 1x minimum width and another adjencent edge length < 1x minimum width (except DMCMK1 and EFUSE region)
 SP_length_le_minwidth = LENGTH SP < SP_MiniWidth
 SP_length_le_minwidth_expand = EXPAND EDGE SP_length_le_minwidth INSIDE BY 0.001 OUTSIDE BY 0.001
 SP_length_le_minwidth_convex = CONVEX EDGE SP_length_le_minwidth_expand < 2
 err1 = SP_length_le_minwidth_expand WITH EDGE SP_length_le_minwidth_convex
 err1 NOT INSIDE DMCMK1_EFUSE
}

GR_16_M0 {
@ It is not allowed that AA, GT, P2, NW, SN, SP, M0, M0G, M0C, M1, Mxy, 1.25xMy, 1.25xMn, 2xMn, 10xTMn, 14xTMn and UTM have one edge length < 1x minimum width and another adjencent edge length < 1x minimum width (except DMCMK1 and EFUSE region)
 M0_length_le_minwidth = LENGTH M0 < M0_MiniWidth
 M0_length_le_minwidth_expand = EXPAND EDGE M0_length_le_minwidth INSIDE BY 0.001 OUTSIDE BY 0.001
 M0_length_le_minwidth_convex = CONVEX EDGE M0_length_le_minwidth_expand < 2
 err1 = M0_length_le_minwidth_expand WITH EDGE M0_length_le_minwidth_convex
 err1 NOT INSIDE DMCMK1_EFUSE
}

GR_16_M0G {
@ It is not allowed that AA, GT, P2, NW, SN, SP, M0, M0G, M0C, M1, Mxy, 1.25xMy, 1.25xMn, 2xMn, 10xTMn, 14xTMn and UTM have one edge length < 1x minimum width and another adjencent edge length < 1x minimum width (except DMCMK1 and EFUSE region)
 M0G_length_le_minwidth = LENGTH M0G < M0G_MiniWidth
 M0G_length_le_minwidth_expand = EXPAND EDGE M0G_length_le_minwidth INSIDE BY 0.001 OUTSIDE BY 0.001
 M0G_length_le_minwidth_convex = CONVEX EDGE M0G_length_le_minwidth_expand < 2
 err1 = M0G_length_le_minwidth_expand WITH EDGE M0G_length_le_minwidth_convex
 err1 NOT INSIDE DMCMK1_EFUSE
}

GR_16_M0C {
@ It is not allowed that AA, GT, P2, NW, SN, SP, M0, M0G, M0C, M1, Mxy, 1.25xMy, 1.25xMn, 2xMn, 10xTMn, 14xTMn and UTM have one edge length < 1x minimum width and another adjencent edge length < 1x minimum width (except DMCMK1 and EFUSE region)
 M0C_length_le_minwidth = LENGTH M0C < M0C_MiniWidth
 M0C_length_le_minwidth_expand = EXPAND EDGE M0C_length_le_minwidth INSIDE BY 0.001 OUTSIDE BY 0.001
 M0C_length_le_minwidth_convex = CONVEX EDGE M0C_length_le_minwidth_expand < 2
 err1 = M0C_length_le_minwidth_expand WITH EDGE M0C_length_le_minwidth_convex
 err1 NOT INSIDE DMCMK1_EFUSE
}
// drm remove M9i, M1_40, M2_40, M3_40, M9_40, M1_45, M2_45, M3_45, M9_45, M1_50, M2_50, M3_50, M9_50, M1_55, M2_55, M3_55, M9_55, TM3i, TM3_40, V0_B1, V0_B2, V1DP, V8DUM, V8DOP, M9DUM, M9DOPi. DIRDOP
 
GR_16_M1i {
@ It is not allowed that AA, GT, P2, NW, SN, SP, M0, M0G, M0C, M1, Mxy, 1.25xMy, 1.25xMn, 2xMn, 10xTMn, 14xTMn and UTM have one edge length < 1x minimum width and another adjencent edge length < 1x minimum width (except DMCMK1 and EFUSE region)
@ For 1xMn metal layer (M1/Mxy)
 M1i_length_le_minwidth = LENGTH M1i < 0.032
 M1i_length_le_minwidth_expand = EXPAND EDGE M1i_length_le_minwidth INSIDE BY 0.001 OUTSIDE BY 0.001
 M1i_length_le_minwidth_convex = CONVEX EDGE M1i_length_le_minwidth_expand < 2
 errM1i = M1i_length_le_minwidth_expand WITH EDGE M1i_length_le_minwidth_convex
 errM1i NOT INSIDE DMCMK1_EFUSE
}
 
GR_16_M2i {
@ It is not allowed that AA, GT, P2, NW, SN, SP, M0, M0G, M0C, M1, Mxy, 1.25xMy, 1.25xMn, 2xMn, 10xTMn, 14xTMn and UTM have one edge length < 1x minimum width and another adjencent edge length < 1x minimum width (except DMCMK1 and EFUSE region)
@ For 1xMn metal layer (M1/Mxy)
 M2i_length_le_minwidth = LENGTH M2i < 0.032
 M2i_length_le_minwidth_expand = EXPAND EDGE M2i_length_le_minwidth INSIDE BY 0.001 OUTSIDE BY 0.001
 M2i_length_le_minwidth_convex = CONVEX EDGE M2i_length_le_minwidth_expand < 2
 errM2i = M2i_length_le_minwidth_expand WITH EDGE M2i_length_le_minwidth_convex
 errM2i NOT INSIDE DMCMK1_EFUSE
}
 
GR_16_M3i {
@ It is not allowed that AA, GT, P2, NW, SN, SP, M0, M0G, M0C, M1, Mxy, 1.25xMy, 1.25xMn, 2xMn, 10xTMn, 14xTMn and UTM have one edge length < 1x minimum width and another adjencent edge length < 1x minimum width (except DMCMK1 and EFUSE region)
@ For 1xMn metal layer (M1/Mxy)
 M3i_length_le_minwidth = LENGTH M3i < 0.032
 M3i_length_le_minwidth_expand = EXPAND EDGE M3i_length_le_minwidth INSIDE BY 0.001 OUTSIDE BY 0.001
 M3i_length_le_minwidth_convex = CONVEX EDGE M3i_length_le_minwidth_expand < 2
 errM3i = M3i_length_le_minwidth_expand WITH EDGE M3i_length_le_minwidth_convex
 errM3i NOT INSIDE DMCMK1_EFUSE
}
 
GR_16_M4_40 {
@ It is not allowed that AA, GT, P2, NW, SN, SP, M0, M0G, M0C, M1, Mxy, 1.25xMy, 1.25xMn, 2xMn, 10xTMn, 14xTMn and UTM have one edge length < 1x minimum width and another adjencent edge length < 1x minimum width (except DMCMK1 and EFUSE region)
@ For 125xMy/125xMn metal layer
 M4_40_length_le_minwidth = LENGTH M4_40 < 0.040
 M4_40_length_le_minwidth_expand = EXPAND EDGE M4_40_length_le_minwidth INSIDE BY 0.001 OUTSIDE BY 0.001
 M4_40_length_le_minwidth_convex = CONVEX EDGE M4_40_length_le_minwidth_expand < 2
 errM4_40 = M4_40_length_le_minwidth_expand WITH EDGE M4_40_length_le_minwidth_convex
 errM4_40 NOT INSIDE DMCMK1_EFUSE
}
 
GR_16_M6_50 {
@ It is not allowed that AA, GT, P2, NW, SN, SP, M0, M0G, M0C, M1, Mxy, 1.25xMy, 1.25xMn, 2xMn, 10xTMn, 14xTMn and UTM have one edge length < 1x minimum width and another adjencent edge length < 1x minimum width (except DMCMK1 and EFUSE region)
@ For 125xMy/125xMn metal layer
 M6_50_length_le_minwidth = LENGTH M6_50 < 0.040
 M6_50_length_le_minwidth_expand = EXPAND EDGE M6_50_length_le_minwidth INSIDE BY 0.001 OUTSIDE BY 0.001
 M6_50_length_le_minwidth_convex = CONVEX EDGE M6_50_length_le_minwidth_expand < 2
 errM6_50 = M6_50_length_le_minwidth_expand WITH EDGE M6_50_length_le_minwidth_convex
 errM6_50 NOT INSIDE DMCMK1_EFUSE
}
 
GR_16_M8_50 {
@ It is not allowed that AA, GT, P2, NW, SN, SP, M0, M0G, M0C, M1, Mxy, 1.25xMy, 1.25xMn, 2xMn, 10xTMn, 14xTMn and UTM have one edge length < 1x minimum width and another adjencent edge length < 1x minimum width (except DMCMK1 and EFUSE region)
@ For 125xMy/125xMn metal layer
 M8_50_length_le_minwidth = LENGTH M8_50 < 0.040
 M8_50_length_le_minwidth_expand = EXPAND EDGE M8_50_length_le_minwidth INSIDE BY 0.001 OUTSIDE BY 0.001
 M8_50_length_le_minwidth_convex = CONVEX EDGE M8_50_length_le_minwidth_expand < 2
 errM8_50 = M8_50_length_le_minwidth_expand WITH EDGE M8_50_length_le_minwidth_convex
 errM8_50 NOT INSIDE DMCMK1_EFUSE
}
 
GR_16_M5_55 {
@ It is not allowed that AA, GT, P2, NW, SN, SP, M0, M0G, M0C, M1, Mxy, 1.25xMy, 1.25xMn, 2xMn, 10xTMn, 14xTMn and UTM have one edge length < 1x minimum width and another adjencent edge length < 1x minimum width (except DMCMK1 and EFUSE region)
@ For 125xMy/125xMn metal layer
 M5_55_length_le_minwidth = LENGTH M5_55 < 0.040
 M5_55_length_le_minwidth_expand = EXPAND EDGE M5_55_length_le_minwidth INSIDE BY 0.001 OUTSIDE BY 0.001
 M5_55_length_le_minwidth_convex = CONVEX EDGE M5_55_length_le_minwidth_expand < 2
 errM5_55 = M5_55_length_le_minwidth_expand WITH EDGE M5_55_length_le_minwidth_convex
 errM5_55 NOT INSIDE DMCMK1_EFUSE
}
 
GR_16_M7_55 {
@ It is not allowed that AA, GT, P2, NW, SN, SP, M0, M0G, M0C, M1, Mxy, 1.25xMy, 1.25xMn, 2xMn, 10xTMn, 14xTMn and UTM have one edge length < 1x minimum width and another adjencent edge length < 1x minimum width (except DMCMK1 and EFUSE region)
@ For 125xMy/125xMn metal layer
 M7_55_length_le_minwidth = LENGTH M7_55 < 0.040
 M7_55_length_le_minwidth_expand = EXPAND EDGE M7_55_length_le_minwidth INSIDE BY 0.001 OUTSIDE BY 0.001
 M7_55_length_le_minwidth_convex = CONVEX EDGE M7_55_length_le_minwidth_expand < 2
 errM7_55 = M7_55_length_le_minwidth_expand WITH EDGE M7_55_length_le_minwidth_convex
 errM7_55 NOT INSIDE DMCMK1_EFUSE
}
 
GR_16_B1i {
@ It is not allowed that AA, GT, P2, NW, SN, SP, M0, M0G, M0C, M1, Mxy, 1.25xMy, 1.25xMn, 2xMn, 10xTMn, 14xTMn and UTM have one edge length < 1x minimum width and another adjencent edge length < 1x minimum width (except DMCMK1 and EFUSE region)
@ For 2xMn metal layer
 B1i_length_le_minwidth = LENGTH B1i < 0.062
 B1i_length_le_minwidth_expand = EXPAND EDGE B1i_length_le_minwidth INSIDE BY 0.001 OUTSIDE BY 0.001
 B1i_length_le_minwidth_convex = CONVEX EDGE B1i_length_le_minwidth_expand < 2
 errB1i = B1i_length_le_minwidth_expand WITH EDGE B1i_length_le_minwidth_convex
 errB1i NOT INSIDE DMCMK1_EFUSE
}
 
GR_16_B2i {
@ It is not allowed that AA, GT, P2, NW, SN, SP, M0, M0G, M0C, M1, Mxy, 1.25xMy, 1.25xMn, 2xMn, 10xTMn, 14xTMn and UTM have one edge length < 1x minimum width and another adjencent edge length < 1x minimum width (except DMCMK1 and EFUSE region)
@ For 2xMn metal layer
 B2i_length_le_minwidth = LENGTH B2i < 0.062
 B2i_length_le_minwidth_expand = EXPAND EDGE B2i_length_le_minwidth INSIDE BY 0.001 OUTSIDE BY 0.001
 B2i_length_le_minwidth_convex = CONVEX EDGE B2i_length_le_minwidth_expand < 2
 errB2i = B2i_length_le_minwidth_expand WITH EDGE B2i_length_le_minwidth_convex
 errB2i NOT INSIDE DMCMK1_EFUSE
}
 
GR_16_TM1i {
@ It is not allowed that AA, GT, P2, NW, SN, SP, M0, M0G, M0C, M1, Mxy, 1.25xMy, 1.25xMn, 2xMn, 10xTMn, 14xTMn and UTM have one edge length < 1x minimum width and another adjencent edge length < 1x minimum width (except DMCMK1 and EFUSE region)
@ For 10xTMn metal layer
 TM1i_length_le_minwidth = LENGTH TM1i < 0.360
 TM1i_length_le_minwidth_expand = EXPAND EDGE TM1i_length_le_minwidth INSIDE BY 0.001 OUTSIDE BY 0.001
 TM1i_length_le_minwidth_convex = CONVEX EDGE TM1i_length_le_minwidth_expand < 2
 errTM1i = TM1i_length_le_minwidth_expand WITH EDGE TM1i_length_le_minwidth_convex
 errTM1i NOT INSIDE DMCMK1_EFUSE
}
 
GR_16_TM2i {
@ It is not allowed that AA, GT, P2, NW, SN, SP, M0, M0G, M0C, M1, Mxy, 1.25xMy, 1.25xMn, 2xMn, 10xTMn, 14xTMn and UTM have one edge length < 1x minimum width and another adjencent edge length < 1x minimum width (except DMCMK1 and EFUSE region)
@ For 10xTMn metal layer
 TM2i_length_le_minwidth = LENGTH TM2i < 0.360
 TM2i_length_le_minwidth_expand = EXPAND EDGE TM2i_length_le_minwidth INSIDE BY 0.001 OUTSIDE BY 0.001
 TM2i_length_le_minwidth_convex = CONVEX EDGE TM2i_length_le_minwidth_expand < 2
 errTM2i = TM2i_length_le_minwidth_expand WITH EDGE TM2i_length_le_minwidth_convex
 errTM2i NOT INSIDE DMCMK1_EFUSE
}
 
GR_16_TM1_40 {
@ It is not allowed that AA, GT, P2, NW, SN, SP, M0, M0G, M0C, M1, Mxy, 1.25xMy, 1.25xMn, 2xMn, 10xTMn, 14xTMn and UTM have one edge length < 1x minimum width and another adjencent edge length < 1x minimum width (except DMCMK1 and EFUSE region)
@ For 14xTMn metal layer
 TM1_40_length_le_minwidth = LENGTH TM1_40 < 0.450
 TM1_40_length_le_minwidth_expand = EXPAND EDGE TM1_40_length_le_minwidth INSIDE BY 0.001 OUTSIDE BY 0.001
 TM1_40_length_le_minwidth_convex = CONVEX EDGE TM1_40_length_le_minwidth_expand < 2
 errTM1_40 = TM1_40_length_le_minwidth_expand WITH EDGE TM1_40_length_le_minwidth_convex
 errTM1_40 NOT INSIDE DMCMK1_EFUSE
}
 
GR_16_TM2_40 {
@ It is not allowed that AA, GT, P2, NW, SN, SP, M0, M0G, M0C, M1, Mxy, 1.25xMy, 1.25xMn, 2xMn, 10xTMn, 14xTMn and UTM have one edge length < 1x minimum width and another adjencent edge length < 1x minimum width (except DMCMK1 and EFUSE region)
@ For 14xTMn metal layer
 TM2_40_length_le_minwidth = LENGTH TM2_40 < 0.450
 TM2_40_length_le_minwidth_expand = EXPAND EDGE TM2_40_length_le_minwidth INSIDE BY 0.001 OUTSIDE BY 0.001
 TM2_40_length_le_minwidth_convex = CONVEX EDGE TM2_40_length_le_minwidth_expand < 2
 errTM2_40 = TM2_40_length_le_minwidth_expand WITH EDGE TM2_40_length_le_minwidth_convex
 errTM2_40 NOT INSIDE DMCMK1_EFUSE
}
 
GR_16_UTM {
@ It is not allowed that AA, GT, P2, NW, SN, SP, M0, M0G, M0C, M1, Mxy, 1.25xMy, 1.25xMn, 2xMn, 10xTMn, 14xTMn and UTM have one edge length < 1x minimum width and another adjencent edge length < 1x minimum width (except DMCMK1 and EFUSE region)
@ For UTM metal layer
 UTM_length_le_minwidth = LENGTH UTM < 1.800
 UTM_length_le_minwidth_expand = EXPAND EDGE UTM_length_le_minwidth INSIDE BY 0.001 OUTSIDE BY 0.001
 UTM_length_le_minwidth_convex = CONVEX EDGE UTM_length_le_minwidth_expand < 2
 errTM2_40 = UTM_length_le_minwidth_expand WITH EDGE UTM_length_le_minwidth_convex
 errTM2_40 NOT INSIDE DMCMK1_EFUSE
}
 
GR_17_SVT_N {
@ It is not allowed that LVT_N, LVT_P, SVT_N, SVT_P, ULVT_N, ULVT_P, HVT_N, HVT_P, LFN_N, LFN_P have one edge length < 1x minimum width and another adjencent edge length < 1x minimum width (except 0.18um edge adjacent to <= 0.048um edge, 0.135/0.144um edge adjacent to 0.002um edge)
 SVT_N_length_le_minwidth = LENGTH SVT_N < 0.192
 errSVT_N_TMP = (INT SVT_N_length_le_minwidth < 0.002 ABUT INTERSECTING ONLY REGION) OR (EXT SVT_N_length_le_minwidth < 0.002 ABUT INTERSECTING ONLY REGION)
 errSVT_N_WAIVE_180 = (errSVT_N_TMP WITH EDGE (LENGTH SVT_N == 0.180)) WITH EDGE (LENGTH SVT_N <= 0.048)
 errSVT_N_WAIVE_135 = (errSVT_N_TMP WITH EDGE (LENGTH SVT_N == 0.135)) WITH EDGE (LENGTH SVT_N == 0.002)
 errSVT_N_WAIVE_144 = (errSVT_N_TMP WITH EDGE (LENGTH SVT_N == 0.144)) WITH EDGE (LENGTH SVT_N == 0.002)
 errSVT_N = errSVT_N_TMP NOT (OR errSVT_N_WAIVE_180 errSVT_N_WAIVE_135 errSVT_N_WAIVE_144)
 errSVT_N NOT INSIDE SealR_NOT_BULK
}
 
GR_17_SVT_P {
@ It is not allowed that LVT_N, LVT_P, SVT_N, SVT_P, ULVT_N, ULVT_P, HVT_N, HVT_P, LFN_N, LFN_P have one edge length < 1x minimum width and another adjencent edge length < 1x minimum width (except 0.18um edge adjacent to <= 0.048um edge, 0.135/0.144um edge adjacent to 0.002um edge)
 SVT_P_length_le_minwidth = LENGTH SVT_P < 0.192
 errSVT_P_TMP = (INT SVT_P_length_le_minwidth < 0.002 ABUT INTERSECTING ONLY REGION) OR (EXT SVT_P_length_le_minwidth < 0.002 ABUT INTERSECTING ONLY REGION)
 errSVT_P_WAIVE_180 = (errSVT_P_TMP WITH EDGE (LENGTH SVT_P == 0.180)) WITH EDGE (LENGTH SVT_P <= 0.048)
 errSVT_P_WAIVE_135 = (errSVT_P_TMP WITH EDGE (LENGTH SVT_P == 0.135)) WITH EDGE (LENGTH SVT_P == 0.002)
 errSVT_P_WAIVE_144 = (errSVT_P_TMP WITH EDGE (LENGTH SVT_P == 0.144)) WITH EDGE (LENGTH SVT_P == 0.002)
 errSVT_P = errSVT_P_TMP NOT (OR errSVT_P_WAIVE_180 errSVT_P_WAIVE_135 errSVT_P_WAIVE_144)
 errSVT_P NOT INSIDE SealR_NOT_BULK
}
 
GR_17_LVT_N {
@ It is not allowed that LVT_N, LVT_P, SVT_N, SVT_P, ULVT_N, ULVT_P, HVT_N, HVT_P, LFN_N, LFN_P have one edge length < 1x minimum width and another adjencent edge length < 1x minimum width (except 0.18um edge adjacent to <= 0.048um edge, 0.135/0.144um edge adjacent to 0.002um edge)
 LVT_N_length_le_minwidth = LENGTH LVT_N < 0.192
 errLVT_N_TMP = (INT LVT_N_length_le_minwidth < 0.002 ABUT INTERSECTING ONLY REGION) OR (EXT LVT_N_length_le_minwidth < 0.002 ABUT INTERSECTING ONLY REGION)
 errLVT_N_WAIVE_180 = (errLVT_N_TMP WITH EDGE (LENGTH LVT_N == 0.180)) WITH EDGE (LENGTH LVT_N <= 0.048)
 errLVT_N_WAIVE_135 = (errLVT_N_TMP WITH EDGE (LENGTH LVT_N == 0.135)) WITH EDGE (LENGTH LVT_N == 0.002)
 errLVT_N_WAIVE_144 = (errLVT_N_TMP WITH EDGE (LENGTH LVT_N == 0.144)) WITH EDGE (LENGTH LVT_N == 0.002)
 errLVT_N = errLVT_N_TMP NOT (OR errLVT_N_WAIVE_180 errLVT_N_WAIVE_135 errLVT_N_WAIVE_144)
 errLVT_N NOT INSIDE SealR_NOT_BULK
}
 
GR_17_LVT_P {
@ It is not allowed that LVT_N, LVT_P, SVT_N, SVT_P, ULVT_N, ULVT_P, HVT_N, HVT_P, LFN_N, LFN_P have one edge length < 1x minimum width and another adjencent edge length < 1x minimum width (except 0.18um edge adjacent to <= 0.048um edge, 0.135/0.144um edge adjacent to 0.002um edge)
 LVT_P_length_le_minwidth = LENGTH LVT_P < 0.192
 errLVT_P_TMP = (INT LVT_P_length_le_minwidth < 0.002 ABUT INTERSECTING ONLY REGION) OR (EXT LVT_P_length_le_minwidth < 0.002 ABUT INTERSECTING ONLY REGION)
 errLVT_P_WAIVE_180 = (errLVT_P_TMP WITH EDGE (LENGTH LVT_P == 0.180)) WITH EDGE (LENGTH LVT_P <= 0.048)
 errLVT_P_WAIVE_135 = (errLVT_P_TMP WITH EDGE (LENGTH LVT_P == 0.135)) WITH EDGE (LENGTH LVT_P == 0.002)
 errLVT_P_WAIVE_144 = (errLVT_P_TMP WITH EDGE (LENGTH LVT_P == 0.144)) WITH EDGE (LENGTH LVT_P == 0.002)
 errLVT_P = errLVT_P_TMP NOT (OR errLVT_P_WAIVE_180 errLVT_P_WAIVE_135 errLVT_P_WAIVE_144)
 errLVT_P NOT INSIDE SealR_NOT_BULK
}
 
GR_17_HVT_N {
@ It is not allowed that LVT_N, LVT_P, SVT_N, SVT_P, ULVT_N, ULVT_P, HVT_N, HVT_P, LFN_N, LFN_P have one edge length < 1x minimum width and another adjencent edge length < 1x minimum width (except 0.18um edge adjacent to <= 0.048um edge, 0.135/0.144um edge adjacent to 0.002um edge)
 HVT_N_length_le_minwidth = LENGTH HVT_N < 0.192
 errHVT_N_TMP = (INT HVT_N_length_le_minwidth < 0.002 ABUT INTERSECTING ONLY REGION) OR (EXT HVT_N_length_le_minwidth < 0.002 ABUT INTERSECTING ONLY REGION)
 errHVT_N_WAIVE_180 = (errHVT_N_TMP WITH EDGE (LENGTH HVT_N == 0.180)) WITH EDGE (LENGTH HVT_N <= 0.048)
 errHVT_N_WAIVE_135 = (errHVT_N_TMP WITH EDGE (LENGTH HVT_N == 0.135)) WITH EDGE (LENGTH HVT_N == 0.002)
 errHVT_N_WAIVE_144 = (errHVT_N_TMP WITH EDGE (LENGTH HVT_N == 0.144)) WITH EDGE (LENGTH HVT_N == 0.002)
 errHVT_N = errHVT_N_TMP NOT (OR errHVT_N_WAIVE_180 errHVT_N_WAIVE_135 errHVT_N_WAIVE_144)
 errHVT_N NOT INSIDE SealR_NOT_BULK
}
 
GR_17_HVT_P {
@ It is not allowed that LVT_N, LVT_P, SVT_N, SVT_P, ULVT_N, ULVT_P, HVT_N, HVT_P, LFN_N, LFN_P have one edge length < 1x minimum width and another adjencent edge length < 1x minimum width (except 0.18um edge adjacent to <= 0.048um edge, 0.135/0.144um edge adjacent to 0.002um edge)
 HVT_P_length_le_minwidth = LENGTH HVT_P < 0.192
 errHVT_P_TMP = (INT HVT_P_length_le_minwidth < 0.002 ABUT INTERSECTING ONLY REGION) OR (EXT HVT_P_length_le_minwidth < 0.002 ABUT INTERSECTING ONLY REGION)
 errHVT_P_WAIVE_180 = (errHVT_P_TMP WITH EDGE (LENGTH HVT_P == 0.180)) WITH EDGE (LENGTH HVT_P <= 0.048)
 errHVT_P_WAIVE_135 = (errHVT_P_TMP WITH EDGE (LENGTH HVT_P == 0.135)) WITH EDGE (LENGTH HVT_P == 0.002)
 errHVT_P_WAIVE_144 = (errHVT_P_TMP WITH EDGE (LENGTH HVT_P == 0.144)) WITH EDGE (LENGTH HVT_P == 0.002)
 errHVT_P = errHVT_P_TMP NOT (OR errHVT_P_WAIVE_180 errHVT_P_WAIVE_135 errHVT_P_WAIVE_144)
 errHVT_P NOT INSIDE SealR_NOT_BULK
}
 
GR_17_ULVT_N {
@ It is not allowed that LVT_N, LVT_P, SVT_N, SVT_P, ULVT_N, ULVT_P, HVT_N, HVT_P, LFN_N, LFN_P have one edge length < 1x minimum width and another adjencent edge length < 1x minimum width (except 0.18um edge adjacent to <= 0.048um edge, 0.135/0.144um edge adjacent to 0.002um edge)
 ULVT_N_length_le_minwidth = LENGTH ULVT_N < 0.192
 errULVT_N_TMP = (INT ULVT_N_length_le_minwidth < 0.002 ABUT INTERSECTING ONLY REGION) OR (EXT ULVT_N_length_le_minwidth < 0.002 ABUT INTERSECTING ONLY REGION)
 errULVT_N_WAIVE_180 = (errULVT_N_TMP WITH EDGE (LENGTH ULVT_N == 0.180)) WITH EDGE (LENGTH ULVT_N <= 0.048)
 errULVT_N_WAIVE_135 = (errULVT_N_TMP WITH EDGE (LENGTH ULVT_N == 0.135)) WITH EDGE (LENGTH ULVT_N == 0.002)
 errULVT_N_WAIVE_144 = (errULVT_N_TMP WITH EDGE (LENGTH ULVT_N == 0.144)) WITH EDGE (LENGTH ULVT_N == 0.002)
 errULVT_N = errULVT_N_TMP NOT (OR errULVT_N_WAIVE_180 errULVT_N_WAIVE_135 errULVT_N_WAIVE_144)
 errULVT_N NOT INSIDE SealR_NOT_BULK
}
 
GR_17_ULVT_P {
@ It is not allowed that LVT_N, LVT_P, SVT_N, SVT_P, ULVT_N, ULVT_P, HVT_N, HVT_P, LFN_N, LFN_P have one edge length < 1x minimum width and another adjencent edge length < 1x minimum width (except 0.18um edge adjacent to <= 0.048um edge, 0.135/0.144um edge adjacent to 0.002um edge)
 ULVT_P_length_le_minwidth = LENGTH ULVT_P < 0.192
 errULVT_P_TMP = (INT ULVT_P_length_le_minwidth < 0.002 ABUT INTERSECTING ONLY REGION) OR (EXT ULVT_P_length_le_minwidth < 0.002 ABUT INTERSECTING ONLY REGION)
 errULVT_P_WAIVE_180 = (errULVT_P_TMP WITH EDGE (LENGTH ULVT_P == 0.180)) WITH EDGE (LENGTH ULVT_P <= 0.048)
 errULVT_P_WAIVE_135 = (errULVT_P_TMP WITH EDGE (LENGTH ULVT_P == 0.135)) WITH EDGE (LENGTH ULVT_P == 0.002)
 errULVT_P_WAIVE_144 = (errULVT_P_TMP WITH EDGE (LENGTH ULVT_P == 0.144)) WITH EDGE (LENGTH ULVT_P == 0.002)
 errULVT_P = errULVT_P_TMP NOT (OR errULVT_P_WAIVE_180 errULVT_P_WAIVE_135 errULVT_P_WAIVE_144)
 errULVT_P NOT INSIDE SealR_NOT_BULK
}
 
GR_17_LFN_N {
@ It is not allowed that LVT_N, LVT_P, SVT_N, SVT_P, ULVT_N, ULVT_P, HVT_N, HVT_P, LFN_N, LFN_P have one edge length < 1x minimum width and another adjencent edge length < 1x minimum width (except 0.18um edge adjacent to <= 0.048um edge, 0.135/0.144um edge adjacent to 0.002um edge)
 LFN_N_length_le_minwidth = LENGTH LFN_N < 0.192
 errLFN_N_TMP = (INT LFN_N_length_le_minwidth < 0.002 ABUT INTERSECTING ONLY REGION) OR (EXT LFN_N_length_le_minwidth < 0.002 ABUT INTERSECTING ONLY REGION)
 errLFN_N_WAIVE_180 = (errLFN_N_TMP WITH EDGE (LENGTH LFN_N == 0.180)) WITH EDGE (LENGTH LFN_N <= 0.048)
 errLFN_N_WAIVE_135 = (errLFN_N_TMP WITH EDGE (LENGTH LFN_N == 0.135)) WITH EDGE (LENGTH LFN_N == 0.002)
 errLFN_N_WAIVE_144 = (errLFN_N_TMP WITH EDGE (LENGTH LFN_N == 0.144)) WITH EDGE (LENGTH LFN_N == 0.002)
 errLFN_N = errLFN_N_TMP NOT (OR errLFN_N_WAIVE_180 errLFN_N_WAIVE_135 errLFN_N_WAIVE_144)
 errLFN_N NOT INSIDE SealR_NOT_BULK
}
 
GR_17_LFN_P {
@ It is not allowed that LVT_N, LVT_P, SVT_N, SVT_P, ULVT_N, ULVT_P, HVT_N, HVT_P, LFN_N, LFN_P have one edge length < 1x minimum width and another adjencent edge length < 1x minimum width (except 0.18um edge adjacent to <= 0.048um edge, 0.135/0.144um edge adjacent to 0.002um edge)
 LFN_P_length_le_minwidth = LENGTH LFN_P < 0.192
 errLFN_P_TMP = (INT LFN_P_length_le_minwidth < 0.002 ABUT INTERSECTING ONLY REGION) OR (EXT LFN_P_length_le_minwidth < 0.002 ABUT INTERSECTING ONLY REGION)
 errLFN_P_WAIVE_180 = (errLFN_P_TMP WITH EDGE (LENGTH LFN_P == 0.180)) WITH EDGE (LENGTH LFN_P <= 0.048)
 errLFN_P_WAIVE_135 = (errLFN_P_TMP WITH EDGE (LENGTH LFN_P == 0.135)) WITH EDGE (LENGTH LFN_P == 0.002)
 errLFN_P_WAIVE_144 = (errLFN_P_TMP WITH EDGE (LENGTH LFN_P == 0.144)) WITH EDGE (LENGTH LFN_P == 0.002)
 errLFN_P = errLFN_P_TMP NOT (OR errLFN_P_WAIVE_180 errLFN_P_WAIVE_135 errLFN_P_WAIVE_144)
 errLFN_P NOT INSIDE SealR_NOT_BULK
}
 
GR_18a_AADOP {
@ AADOP/AADUM/ARDOP/ARDUM/AR_HDOP/AR_VDOP/GTDOP/GTDUM/P2DOP/P2DUM/SNDUM/SPDUM/M0DOP/M0DUM/M0CDOP/M0CDUM/M0GDOP/M0GDUM/V0DUM/V0DPDUM layers in chip design is not allowed, except DMCMK1 and MARKS regions.
@ These layers are dedicated for SMIC FEOL and MEOL dummy auto-insertion utility usage, can't be used for manually drawn purpose
 AADOP NOT INSIDE DMCMK1_MARKS
}
 
GR_18a_AADUM {
@ AADOP/AADUM/ARDOP/ARDUM/AR_HDOP/AR_VDOP/GTDOP/GTDUM/P2DOP/P2DUM/SNDUM/SPDUM/M0DOP/M0DUM/M0CDOP/M0CDUM/M0GDOP/M0GDUM/V0DUM/V0DPDUM layers in chip design is not allowed, except DMCMK1 and MARKS regions.
@ These layers are dedicated for SMIC FEOL and MEOL dummy auto-insertion utility usage, can't be used for manually drawn purpose
 AADUM NOT INSIDE DMCMK1_MARKS
}
 
GR_18a_ARDOP {
@ AADOP/AADUM/ARDOP/ARDUM/AR_HDOP/AR_VDOP/GTDOP/GTDUM/P2DOP/P2DUM/SNDUM/SPDUM/M0DOP/M0DUM/M0CDOP/M0CDUM/M0GDOP/M0GDUM/V0DUM/V0DPDUM layers in chip design is not allowed, except DMCMK1 and MARKS regions.
@ These layers are dedicated for SMIC FEOL and MEOL dummy auto-insertion utility usage, can't be used for manually drawn purpose
 ARDOP NOT INSIDE DMCMK1_MARKS
}
 
GR_18a_ARDUM {
@ AADOP/AADUM/ARDOP/ARDUM/AR_HDOP/AR_VDOP/GTDOP/GTDUM/P2DOP/P2DUM/SNDUM/SPDUM/M0DOP/M0DUM/M0CDOP/M0CDUM/M0GDOP/M0GDUM/V0DUM/V0DPDUM layers in chip design is not allowed, except DMCMK1 and MARKS regions.
@ These layers are dedicated for SMIC FEOL and MEOL dummy auto-insertion utility usage, can't be used for manually drawn purpose
 ARDUM NOT INSIDE DMCMK1_MARKS
}
 
GR_18a_AR_HDOP {
@ AADOP/AADUM/ARDOP/ARDUM/AR_HDOP/AR_VDOP/GTDOP/GTDUM/P2DOP/P2DUM/SNDUM/SPDUM/M0DOP/M0DUM/M0CDOP/M0CDUM/M0GDOP/M0GDUM/V0DUM/V0DPDUM layers in chip design is not allowed, except DMCMK1 and MARKS regions.
@ These layers are dedicated for SMIC FEOL and MEOL dummy auto-insertion utility usage, can't be used for manually drawn purpose
 AR_HDOP NOT INSIDE DMCMK1_MARKS
}
 
GR_18a_AR_VDOP {
@ AADOP/AADUM/ARDOP/ARDUM/AR_HDOP/AR_VDOP/GTDOP/GTDUM/P2DOP/P2DUM/SNDUM/SPDUM/M0DOP/M0DUM/M0CDOP/M0CDUM/M0GDOP/M0GDUM/V0DUM/V0DPDUM layers in chip design is not allowed, except DMCMK1 and MARKS regions.
@ These layers are dedicated for SMIC FEOL and MEOL dummy auto-insertion utility usage, can't be used for manually drawn purpose
 AR_VDOP NOT INSIDE DMCMK1_MARKS
}
 
GR_18a_GTDOP {
@ AADOP/AADUM/ARDOP/ARDUM/AR_HDOP/AR_VDOP/GTDOP/GTDUM/P2DOP/P2DUM/SNDUM/SPDUM/M0DOP/M0DUM/M0CDOP/M0CDUM/M0GDOP/M0GDUM/V0DUM/V0DPDUM layers in chip design is not allowed, except DMCMK1 and MARKS regions.
@ These layers are dedicated for SMIC FEOL and MEOL dummy auto-insertion utility usage, can't be used for manually drawn purpose
 GTDOP NOT INSIDE DMCMK1_MARKS
}
 
GR_18a_GTDUM {
@ AADOP/AADUM/ARDOP/ARDUM/AR_HDOP/AR_VDOP/GTDOP/GTDUM/P2DOP/P2DUM/SNDUM/SPDUM/M0DOP/M0DUM/M0CDOP/M0CDUM/M0GDOP/M0GDUM/V0DUM/V0DPDUM layers in chip design is not allowed, except DMCMK1 and MARKS regions.
@ These layers are dedicated for SMIC FEOL and MEOL dummy auto-insertion utility usage, can't be used for manually drawn purpose
 GTDUM NOT INSIDE DMCMK1_MARKS
}
 
GR_18a_P2DOP {
@ AADOP/AADUM/ARDOP/ARDUM/AR_HDOP/AR_VDOP/GTDOP/GTDUM/P2DOP/P2DUM/SNDUM/SPDUM/M0DOP/M0DUM/M0CDOP/M0CDUM/M0GDOP/M0GDUM/V0DUM/V0DPDUM layers in chip design is not allowed, except DMCMK1 and MARKS regions.
@ These layers are dedicated for SMIC FEOL and MEOL dummy auto-insertion utility usage, can't be used for manually drawn purpose
 P2DOP NOT INSIDE DMCMK1_MARKS
}
 
GR_18a_P2DUM {
@ AADOP/AADUM/ARDOP/ARDUM/AR_HDOP/AR_VDOP/GTDOP/GTDUM/P2DOP/P2DUM/SNDUM/SPDUM/M0DOP/M0DUM/M0CDOP/M0CDUM/M0GDOP/M0GDUM/V0DUM/V0DPDUM layers in chip design is not allowed, except DMCMK1 and MARKS regions.
@ These layers are dedicated for SMIC FEOL and MEOL dummy auto-insertion utility usage, can't be used for manually drawn purpose
 P2DUM NOT INSIDE DMCMK1_MARKS
}
 
GR_18a_SNDUM {
@ AADOP/AADUM/ARDOP/ARDUM/AR_HDOP/AR_VDOP/GTDOP/GTDUM/P2DOP/P2DUM/SNDUM/SPDUM/M0DOP/M0DUM/M0CDOP/M0CDUM/M0GDOP/M0GDUM/V0DUM/V0DPDUM layers in chip design is not allowed, except DMCMK1 and MARKS regions.
@ These layers are dedicated for SMIC FEOL and MEOL dummy auto-insertion utility usage, can't be used for manually drawn purpose
 SNDUM NOT INSIDE DMCMK1_MARKS
}
 
GR_18a_SPDUM {
@ AADOP/AADUM/ARDOP/ARDUM/AR_HDOP/AR_VDOP/GTDOP/GTDUM/P2DOP/P2DUM/SNDUM/SPDUM/M0DOP/M0DUM/M0CDOP/M0CDUM/M0GDOP/M0GDUM/V0DUM/V0DPDUM layers in chip design is not allowed, except DMCMK1 and MARKS regions.
@ These layers are dedicated for SMIC FEOL and MEOL dummy auto-insertion utility usage, can't be used for manually drawn purpose
 SPDUM NOT INSIDE DMCMK1_MARKS
}
 
GR_18a_M0DOP {
@ AADOP/AADUM/ARDOP/ARDUM/AR_HDOP/AR_VDOP/GTDOP/GTDUM/P2DOP/P2DUM/SNDUM/SPDUM/M0DOP/M0DUM/M0CDOP/M0CDUM/M0GDOP/M0GDUM/V0DUM/V0DPDUM layers in chip design is not allowed, except DMCMK1 and MARKS regions.
@ These layers are dedicated for SMIC FEOL and MEOL dummy auto-insertion utility usage, can't be used for manually drawn purpose
 M0DOP NOT INSIDE DMCMK1_MARKS
}
 
GR_18a_M0DUM {
@ AADOP/AADUM/ARDOP/ARDUM/AR_HDOP/AR_VDOP/GTDOP/GTDUM/P2DOP/P2DUM/SNDUM/SPDUM/M0DOP/M0DUM/M0CDOP/M0CDUM/M0GDOP/M0GDUM/V0DUM/V0DPDUM layers in chip design is not allowed, except DMCMK1 and MARKS regions.
@ These layers are dedicated for SMIC FEOL and MEOL dummy auto-insertion utility usage, can't be used for manually drawn purpose
 M0DUM NOT INSIDE DMCMK1_MARKS
}
 
GR_18a_M0CDOP {
@ AADOP/AADUM/ARDOP/ARDUM/AR_HDOP/AR_VDOP/GTDOP/GTDUM/P2DOP/P2DUM/SNDUM/SPDUM/M0DOP/M0DUM/M0CDOP/M0CDUM/M0GDOP/M0GDUM/V0DUM/V0DPDUM layers in chip design is not allowed, except DMCMK1 and MARKS regions.
@ These layers are dedicated for SMIC FEOL and MEOL dummy auto-insertion utility usage, can't be used for manually drawn purpose
 M0CDOP NOT INSIDE DMCMK1_MARKS
}
 
GR_18a_M0CDUM {
@ AADOP/AADUM/ARDOP/ARDUM/AR_HDOP/AR_VDOP/GTDOP/GTDUM/P2DOP/P2DUM/SNDUM/SPDUM/M0DOP/M0DUM/M0CDOP/M0CDUM/M0GDOP/M0GDUM/V0DUM/V0DPDUM layers in chip design is not allowed, except DMCMK1 and MARKS regions.
@ These layers are dedicated for SMIC FEOL and MEOL dummy auto-insertion utility usage, can't be used for manually drawn purpose
 M0CDUM NOT INSIDE DMCMK1_MARKS
}
 
GR_18a_M0GDOP {
@ AADOP/AADUM/ARDOP/ARDUM/AR_HDOP/AR_VDOP/GTDOP/GTDUM/P2DOP/P2DUM/SNDUM/SPDUM/M0DOP/M0DUM/M0CDOP/M0CDUM/M0GDOP/M0GDUM/V0DUM/V0DPDUM layers in chip design is not allowed, except DMCMK1 and MARKS regions.
@ These layers are dedicated for SMIC FEOL and MEOL dummy auto-insertion utility usage, can't be used for manually drawn purpose
 M0GDOP NOT INSIDE DMCMK1_MARKS
}
 
GR_18a_M0GDUM {
@ AADOP/AADUM/ARDOP/ARDUM/AR_HDOP/AR_VDOP/GTDOP/GTDUM/P2DOP/P2DUM/SNDUM/SPDUM/M0DOP/M0DUM/M0CDOP/M0CDUM/M0GDOP/M0GDUM/V0DUM/V0DPDUM layers in chip design is not allowed, except DMCMK1 and MARKS regions.
@ These layers are dedicated for SMIC FEOL and MEOL dummy auto-insertion utility usage, can't be used for manually drawn purpose
 M0GDUM NOT INSIDE DMCMK1_MARKS
}
 
GR_18a_V0DUM {
@ AADOP/AADUM/ARDOP/ARDUM/AR_HDOP/AR_VDOP/GTDOP/GTDUM/P2DOP/P2DUM/SNDUM/SPDUM/M0DOP/M0DUM/M0CDOP/M0CDUM/M0GDOP/M0GDUM/V0DUM/V0DPDUM layers in chip design is not allowed, except DMCMK1 and MARKS regions.
@ These layers are dedicated for SMIC FEOL and MEOL dummy auto-insertion utility usage, can't be used for manually drawn purpose
 V0DUM NOT INSIDE DMCMK1_MARKS
}
 
GR_18a_V0DPDUM {
@ AADOP/AADUM/ARDOP/ARDUM/AR_HDOP/AR_VDOP/GTDOP/GTDUM/P2DOP/P2DUM/SNDUM/SPDUM/M0DOP/M0DUM/M0CDOP/M0CDUM/M0GDOP/M0GDUM/V0DUM/V0DPDUM layers in chip design is not allowed, except DMCMK1 and MARKS regions.
@ These layers are dedicated for SMIC FEOL and MEOL dummy auto-insertion utility usage, can't be used for manually drawn purpose
 V0DPDUM NOT INSIDE DMCMK1_MARKS
}
 
GR_18b_M1DOP {
@ M1DOP/M1DUM/M1DP/M1DPDOP/M1DPDUM/M2DUM/M2DOP/M2DP/M2DPDUM/M2DPDOP/M3DUM/M3DOP/M3DP/M3DPDUM/M3DPDOP/M4DUM/M4DOP/M5DUM/M6DUM/M7DUM/V1DUM/V2DUM/V3DUM/V4DUM/V5DUM/V6DUM/BV1DUM/BV2DUM/B1DUM/B1DOP/B2DUM/B2DOP/UTMDUM/TM1DUM/TM2DUM/ALDUM layers in chip design is not allowed except DMCMK2 and MARKS region
@ These layers are dedicated for SMIC BEOL dummy auto-insertion utility usage, can't be used for manually drawn purpose
 M1DOP NOT INSIDE DMCMK2_MARKS
}
 
GR_18b_M1DUM {
@ M1DOP/M1DUM/M1DP/M1DPDOP/M1DPDUM/M2DUM/M2DOP/M2DP/M2DPDUM/M2DPDOP/M3DUM/M3DOP/M3DP/M3DPDUM/M3DPDOP/M4DUM/M4DOP/M5DUM/M6DUM/M7DUM/V1DUM/V2DUM/V3DUM/V4DUM/V5DUM/V6DUM/BV1DUM/BV2DUM/B1DUM/B1DOP/B2DUM/B2DOP/UTMDUM/TM1DUM/TM2DUM/ALDUM layers in chip design is not allowed except DMCMK2 and MARKS region
@ These layers are dedicated for SMIC BEOL dummy auto-insertion utility usage, can't be used for manually drawn purpose
 M1DUM NOT INSIDE DMCMK2_MARKS
}
 
GR_18b_M1DP {
@ M1DOP/M1DUM/M1DP/M1DPDOP/M1DPDUM/M2DUM/M2DOP/M2DP/M2DPDUM/M2DPDOP/M3DUM/M3DOP/M3DP/M3DPDUM/M3DPDOP/M4DUM/M4DOP/M5DUM/M6DUM/M7DUM/V1DUM/V2DUM/V3DUM/V4DUM/V5DUM/V6DUM/BV1DUM/BV2DUM/B1DUM/B1DOP/B2DUM/B2DOP/UTMDUM/TM1DUM/TM2DUM/ALDUM layers in chip design is not allowed except DMCMK2 and MARKS region
@ These layers are dedicated for SMIC BEOL dummy auto-insertion utility usage, can't be used for manually drawn purpose
 M1DP NOT INSIDE DMCMK2_MARKS
}
 
GR_18b_M1DPDOP {
@ M1DOP/M1DUM/M1DP/M1DPDOP/M1DPDUM/M2DUM/M2DOP/M2DP/M2DPDUM/M2DPDOP/M3DUM/M3DOP/M3DP/M3DPDUM/M3DPDOP/M4DUM/M4DOP/M5DUM/M6DUM/M7DUM/V1DUM/V2DUM/V3DUM/V4DUM/V5DUM/V6DUM/BV1DUM/BV2DUM/B1DUM/B1DOP/B2DUM/B2DOP/UTMDUM/TM1DUM/TM2DUM/ALDUM layers in chip design is not allowed except DMCMK2 and MARKS region
@ These layers are dedicated for SMIC BEOL dummy auto-insertion utility usage, can't be used for manually drawn purpose
 M1DPDOP NOT INSIDE DMCMK2_MARKS
}
 
GR_18b_M1DPDUM {
@ M1DOP/M1DUM/M1DP/M1DPDOP/M1DPDUM/M2DUM/M2DOP/M2DP/M2DPDUM/M2DPDOP/M3DUM/M3DOP/M3DP/M3DPDUM/M3DPDOP/M4DUM/M4DOP/M5DUM/M6DUM/M7DUM/V1DUM/V2DUM/V3DUM/V4DUM/V5DUM/V6DUM/BV1DUM/BV2DUM/B1DUM/B1DOP/B2DUM/B2DOP/UTMDUM/TM1DUM/TM2DUM/ALDUM layers in chip design is not allowed except DMCMK2 and MARKS region
@ These layers are dedicated for SMIC BEOL dummy auto-insertion utility usage, can't be used for manually drawn purpose
 M1DPDUM NOT INSIDE DMCMK2_MARKS
}
 
GR_18b_M2DUM {
@ M1DOP/M1DUM/M1DP/M1DPDOP/M1DPDUM/M2DUM/M2DOP/M2DP/M2DPDUM/M2DPDOP/M3DUM/M3DOP/M3DP/M3DPDUM/M3DPDOP/M4DUM/M4DOP/M5DUM/M6DUM/M7DUM/V1DUM/V2DUM/V3DUM/V4DUM/V5DUM/V6DUM/BV1DUM/BV2DUM/B1DUM/B1DOP/B2DUM/B2DOP/UTMDUM/TM1DUM/TM2DUM/ALDUM layers in chip design is not allowed except DMCMK2 and MARKS region
@ These layers are dedicated for SMIC BEOL dummy auto-insertion utility usage, can't be used for manually drawn purpose
 M2DUM NOT INSIDE DMCMK2_MARKS
}
 
GR_18b_M2DOP {
@ M1DOP/M1DUM/M1DP/M1DPDOP/M1DPDUM/M2DUM/M2DOP/M2DP/M2DPDUM/M2DPDOP/M3DUM/M3DOP/M3DP/M3DPDUM/M3DPDOP/M4DUM/M4DOP/M5DUM/M6DUM/M7DUM/V1DUM/V2DUM/V3DUM/V4DUM/V5DUM/V6DUM/BV1DUM/BV2DUM/B1DUM/B1DOP/B2DUM/B2DOP/UTMDUM/TM1DUM/TM2DUM/ALDUM layers in chip design is not allowed except DMCMK2 and MARKS region
@ These layers are dedicated for SMIC BEOL dummy auto-insertion utility usage, can't be used for manually drawn purpose
 M2DOP NOT INSIDE DMCMK2_MARKS
}
 
GR_18b_M2DP {
@ M1DOP/M1DUM/M1DP/M1DPDOP/M1DPDUM/M2DUM/M2DOP/M2DP/M2DPDUM/M2DPDOP/M3DUM/M3DOP/M3DP/M3DPDUM/M3DPDOP/M4DUM/M4DOP/M5DUM/M6DUM/M7DUM/V1DUM/V2DUM/V3DUM/V4DUM/V5DUM/V6DUM/BV1DUM/BV2DUM/B1DUM/B1DOP/B2DUM/B2DOP/UTMDUM/TM1DUM/TM2DUM/ALDUM layers in chip design is not allowed except DMCMK2 and MARKS region
@ These layers are dedicated for SMIC BEOL dummy auto-insertion utility usage, can't be used for manually drawn purpose
 M2DP NOT INSIDE DMCMK2_MARKS
}
 
GR_18b_M2DPDUM {
@ M1DOP/M1DUM/M1DP/M1DPDOP/M1DPDUM/M2DUM/M2DOP/M2DP/M2DPDUM/M2DPDOP/M3DUM/M3DOP/M3DP/M3DPDUM/M3DPDOP/M4DUM/M4DOP/M5DUM/M6DUM/M7DUM/V1DUM/V2DUM/V3DUM/V4DUM/V5DUM/V6DUM/BV1DUM/BV2DUM/B1DUM/B1DOP/B2DUM/B2DOP/UTMDUM/TM1DUM/TM2DUM/ALDUM layers in chip design is not allowed except DMCMK2 and MARKS region
@ These layers are dedicated for SMIC BEOL dummy auto-insertion utility usage, can't be used for manually drawn purpose
 M2DPDUM NOT INSIDE DMCMK2_MARKS
}
 
GR_18b_M2DPDOP {
@ M1DOP/M1DUM/M1DP/M1DPDOP/M1DPDUM/M2DUM/M2DOP/M2DP/M2DPDUM/M2DPDOP/M3DUM/M3DOP/M3DP/M3DPDUM/M3DPDOP/M4DUM/M4DOP/M5DUM/M6DUM/M7DUM/V1DUM/V2DUM/V3DUM/V4DUM/V5DUM/V6DUM/BV1DUM/BV2DUM/B1DUM/B1DOP/B2DUM/B2DOP/UTMDUM/TM1DUM/TM2DUM/ALDUM layers in chip design is not allowed except DMCMK2 and MARKS region
@ These layers are dedicated for SMIC BEOL dummy auto-insertion utility usage, can't be used for manually drawn purpose
 M2DPDOP NOT INSIDE DMCMK2_MARKS
}
 
GR_18b_M3DUM {
@ M1DOP/M1DUM/M1DP/M1DPDOP/M1DPDUM/M2DUM/M2DOP/M2DP/M2DPDUM/M2DPDOP/M3DUM/M3DOP/M3DP/M3DPDUM/M3DPDOP/M4DUM/M4DOP/M5DUM/M6DUM/M7DUM/V1DUM/V2DUM/V3DUM/V4DUM/V5DUM/V6DUM/BV1DUM/BV2DUM/B1DUM/B1DOP/B2DUM/B2DOP/UTMDUM/TM1DUM/TM2DUM/ALDUM layers in chip design is not allowed except DMCMK2 and MARKS region
@ These layers are dedicated for SMIC BEOL dummy auto-insertion utility usage, can't be used for manually drawn purpose
 M3DUM NOT INSIDE DMCMK2_MARKS
}
 
GR_18b_M3DOP {
@ M1DOP/M1DUM/M1DP/M1DPDOP/M1DPDUM/M2DUM/M2DOP/M2DP/M2DPDUM/M2DPDOP/M3DUM/M3DOP/M3DP/M3DPDUM/M3DPDOP/M4DUM/M4DOP/M5DUM/M6DUM/M7DUM/V1DUM/V2DUM/V3DUM/V4DUM/V5DUM/V6DUM/BV1DUM/BV2DUM/B1DUM/B1DOP/B2DUM/B2DOP/UTMDUM/TM1DUM/TM2DUM/ALDUM layers in chip design is not allowed except DMCMK2 and MARKS region
@ These layers are dedicated for SMIC BEOL dummy auto-insertion utility usage, can't be used for manually drawn purpose
 M3DOP NOT INSIDE DMCMK2_MARKS
}
 
GR_18b_M3DP {
@ M1DOP/M1DUM/M1DP/M1DPDOP/M1DPDUM/M2DUM/M2DOP/M2DP/M2DPDUM/M2DPDOP/M3DUM/M3DOP/M3DP/M3DPDUM/M3DPDOP/M4DUM/M4DOP/M5DUM/M6DUM/M7DUM/V1DUM/V2DUM/V3DUM/V4DUM/V5DUM/V6DUM/BV1DUM/BV2DUM/B1DUM/B1DOP/B2DUM/B2DOP/UTMDUM/TM1DUM/TM2DUM/ALDUM layers in chip design is not allowed except DMCMK2 and MARKS region
@ These layers are dedicated for SMIC BEOL dummy auto-insertion utility usage, can't be used for manually drawn purpose
 M3DP NOT INSIDE DMCMK2_MARKS
}
 
GR_18b_M3DPDUM {
@ M1DOP/M1DUM/M1DP/M1DPDOP/M1DPDUM/M2DUM/M2DOP/M2DP/M2DPDUM/M2DPDOP/M3DUM/M3DOP/M3DP/M3DPDUM/M3DPDOP/M4DUM/M4DOP/M5DUM/M6DUM/M7DUM/V1DUM/V2DUM/V3DUM/V4DUM/V5DUM/V6DUM/BV1DUM/BV2DUM/B1DUM/B1DOP/B2DUM/B2DOP/UTMDUM/TM1DUM/TM2DUM/ALDUM layers in chip design is not allowed except DMCMK2 and MARKS region
@ These layers are dedicated for SMIC BEOL dummy auto-insertion utility usage, can't be used for manually drawn purpose
 M3DPDUM NOT INSIDE DMCMK2_MARKS
}
 
GR_18b_M3DPDOP {
@ M1DOP/M1DUM/M1DP/M1DPDOP/M1DPDUM/M2DUM/M2DOP/M2DP/M2DPDUM/M2DPDOP/M3DUM/M3DOP/M3DP/M3DPDUM/M3DPDOP/M4DUM/M4DOP/M5DUM/M6DUM/M7DUM/V1DUM/V2DUM/V3DUM/V4DUM/V5DUM/V6DUM/BV1DUM/BV2DUM/B1DUM/B1DOP/B2DUM/B2DOP/UTMDUM/TM1DUM/TM2DUM/ALDUM layers in chip design is not allowed except DMCMK2 and MARKS region
@ These layers are dedicated for SMIC BEOL dummy auto-insertion utility usage, can't be used for manually drawn purpose
 M3DPDOP NOT INSIDE DMCMK2_MARKS
}
 
GR_18b_M4DUM {
@ M1DOP/M1DUM/M1DP/M1DPDOP/M1DPDUM/M2DUM/M2DOP/M2DP/M2DPDUM/M2DPDOP/M3DUM/M3DOP/M3DP/M3DPDUM/M3DPDOP/M4DUM/M4DOP/M5DUM/M6DUM/M7DUM/V1DUM/V2DUM/V3DUM/V4DUM/V5DUM/V6DUM/BV1DUM/BV2DUM/B1DUM/B1DOP/B2DUM/B2DOP/UTMDUM/TM1DUM/TM2DUM/ALDUM layers in chip design is not allowed except DMCMK2 and MARKS region
@ These layers are dedicated for SMIC BEOL dummy auto-insertion utility usage, can't be used for manually drawn purpose
 M4DUM NOT INSIDE DMCMK2_MARKS
}
 
GR_18b_M4DOP {
@ M1DOP/M1DUM/M1DP/M1DPDOP/M1DPDUM/M2DUM/M2DOP/M2DP/M2DPDUM/M2DPDOP/M3DUM/M3DOP/M3DP/M3DPDUM/M3DPDOP/M4DUM/M4DOP/M5DUM/M6DUM/M7DUM/V1DUM/V2DUM/V3DUM/V4DUM/V5DUM/V6DUM/BV1DUM/BV2DUM/B1DUM/B1DOP/B2DUM/B2DOP/UTMDUM/TM1DUM/TM2DUM/ALDUM layers in chip design is not allowed except DMCMK2 and MARKS region
@ These layers are dedicated for SMIC BEOL dummy auto-insertion utility usage, can't be used for manually drawn purpose
 M4DOP NOT INSIDE DMCMK2_MARKS
}
 
GR_18b_M5DUM {
@ M1DOP/M1DUM/M1DP/M1DPDOP/M1DPDUM/M2DUM/M2DOP/M2DP/M2DPDUM/M2DPDOP/M3DUM/M3DOP/M3DP/M3DPDUM/M3DPDOP/M4DUM/M4DOP/M5DUM/M6DUM/M7DUM/V1DUM/V2DUM/V3DUM/V4DUM/V5DUM/V6DUM/BV1DUM/BV2DUM/B1DUM/B1DOP/B2DUM/B2DOP/UTMDUM/TM1DUM/TM2DUM/ALDUM layers in chip design is not allowed except DMCMK2 and MARKS region
@ These layers are dedicated for SMIC BEOL dummy auto-insertion utility usage, can't be used for manually drawn purpose
 M5DUM NOT INSIDE DMCMK2_MARKS
}
 
GR_18b_M6DUM {
@ M1DOP/M1DUM/M1DP/M1DPDOP/M1DPDUM/M2DUM/M2DOP/M2DP/M2DPDUM/M2DPDOP/M3DUM/M3DOP/M3DP/M3DPDUM/M3DPDOP/M4DUM/M4DOP/M5DUM/M6DUM/M7DUM/V1DUM/V2DUM/V3DUM/V4DUM/V5DUM/V6DUM/BV1DUM/BV2DUM/B1DUM/B1DOP/B2DUM/B2DOP/UTMDUM/TM1DUM/TM2DUM/ALDUM layers in chip design is not allowed except DMCMK2 and MARKS region
@ These layers are dedicated for SMIC BEOL dummy auto-insertion utility usage, can't be used for manually drawn purpose
 M6DUM NOT INSIDE DMCMK2_MARKS
}
 
GR_18b_M7DUM {
@ M1DOP/M1DUM/M1DP/M1DPDOP/M1DPDUM/M2DUM/M2DOP/M2DP/M2DPDUM/M2DPDOP/M3DUM/M3DOP/M3DP/M3DPDUM/M3DPDOP/M4DUM/M4DOP/M5DUM/M6DUM/M7DUM/V1DUM/V2DUM/V3DUM/V4DUM/V5DUM/V6DUM/BV1DUM/BV2DUM/B1DUM/B1DOP/B2DUM/B2DOP/UTMDUM/TM1DUM/TM2DUM/ALDUM layers in chip design is not allowed except DMCMK2 and MARKS region
@ These layers are dedicated for SMIC BEOL dummy auto-insertion utility usage, can't be used for manually drawn purpose
 M7DUM NOT INSIDE DMCMK2_MARKS
}
 
GR_18b_V1DUM {
@ M1DOP/M1DUM/M1DP/M1DPDOP/M1DPDUM/M2DUM/M2DOP/M2DP/M2DPDUM/M2DPDOP/M3DUM/M3DOP/M3DP/M3DPDUM/M3DPDOP/M4DUM/M4DOP/M5DUM/M6DUM/M7DUM/V1DUM/V2DUM/V3DUM/V4DUM/V5DUM/V6DUM/BV1DUM/BV2DUM/B1DUM/B1DOP/B2DUM/B2DOP/UTMDUM/TM1DUM/TM2DUM/ALDUM layers in chip design is not allowed except DMCMK2 and MARKS region
@ These layers are dedicated for SMIC BEOL dummy auto-insertion utility usage, can't be used for manually drawn purpose
 V1DUM NOT INSIDE DMCMK2_MARKS
}
 
GR_18b_V2DUM {
@ M1DOP/M1DUM/M1DP/M1DPDOP/M1DPDUM/M2DUM/M2DOP/M2DP/M2DPDUM/M2DPDOP/M3DUM/M3DOP/M3DP/M3DPDUM/M3DPDOP/M4DUM/M4DOP/M5DUM/M6DUM/M7DUM/V1DUM/V2DUM/V3DUM/V4DUM/V5DUM/V6DUM/BV1DUM/BV2DUM/B1DUM/B1DOP/B2DUM/B2DOP/UTMDUM/TM1DUM/TM2DUM/ALDUM layers in chip design is not allowed except DMCMK2 and MARKS region
@ These layers are dedicated for SMIC BEOL dummy auto-insertion utility usage, can't be used for manually drawn purpose
 V2DUM NOT INSIDE DMCMK2_MARKS
}
 
GR_18b_V3DUM {
@ M1DOP/M1DUM/M1DP/M1DPDOP/M1DPDUM/M2DUM/M2DOP/M2DP/M2DPDUM/M2DPDOP/M3DUM/M3DOP/M3DP/M3DPDUM/M3DPDOP/M4DUM/M4DOP/M5DUM/M6DUM/M7DUM/V1DUM/V2DUM/V3DUM/V4DUM/V5DUM/V6DUM/BV1DUM/BV2DUM/B1DUM/B1DOP/B2DUM/B2DOP/UTMDUM/TM1DUM/TM2DUM/ALDUM layers in chip design is not allowed except DMCMK2 and MARKS region
@ These layers are dedicated for SMIC BEOL dummy auto-insertion utility usage, can't be used for manually drawn purpose
 V3DUM NOT INSIDE DMCMK2_MARKS
}
 
GR_18b_V4DUM {
@ M1DOP/M1DUM/M1DP/M1DPDOP/M1DPDUM/M2DUM/M2DOP/M2DP/M2DPDUM/M2DPDOP/M3DUM/M3DOP/M3DP/M3DPDUM/M3DPDOP/M4DUM/M4DOP/M5DUM/M6DUM/M7DUM/V1DUM/V2DUM/V3DUM/V4DUM/V5DUM/V6DUM/BV1DUM/BV2DUM/B1DUM/B1DOP/B2DUM/B2DOP/UTMDUM/TM1DUM/TM2DUM/ALDUM layers in chip design is not allowed except DMCMK2 and MARKS region
@ These layers are dedicated for SMIC BEOL dummy auto-insertion utility usage, can't be used for manually drawn purpose
 V4DUM NOT INSIDE DMCMK2_MARKS
}
 
GR_18b_V5DUM {
@ M1DOP/M1DUM/M1DP/M1DPDOP/M1DPDUM/M2DUM/M2DOP/M2DP/M2DPDUM/M2DPDOP/M3DUM/M3DOP/M3DP/M3DPDUM/M3DPDOP/M4DUM/M4DOP/M5DUM/M6DUM/M7DUM/V1DUM/V2DUM/V3DUM/V4DUM/V5DUM/V6DUM/BV1DUM/BV2DUM/B1DUM/B1DOP/B2DUM/B2DOP/UTMDUM/TM1DUM/TM2DUM/ALDUM layers in chip design is not allowed except DMCMK2 and MARKS region
@ These layers are dedicated for SMIC BEOL dummy auto-insertion utility usage, can't be used for manually drawn purpose
 V5DUM NOT INSIDE DMCMK2_MARKS
}
 
GR_18b_V6DUM {
@ M1DOP/M1DUM/M1DP/M1DPDOP/M1DPDUM/M2DUM/M2DOP/M2DP/M2DPDUM/M2DPDOP/M3DUM/M3DOP/M3DP/M3DPDUM/M3DPDOP/M4DUM/M4DOP/M5DUM/M6DUM/M7DUM/V1DUM/V2DUM/V3DUM/V4DUM/V5DUM/V6DUM/BV1DUM/BV2DUM/B1DUM/B1DOP/B2DUM/B2DOP/UTMDUM/TM1DUM/TM2DUM/ALDUM layers in chip design is not allowed except DMCMK2 and MARKS region
@ These layers are dedicated for SMIC BEOL dummy auto-insertion utility usage, can't be used for manually drawn purpose
 V6DUM NOT INSIDE DMCMK2_MARKS
}
 
GR_18b_BV1DUM {
@ M1DOP/M1DUM/M1DP/M1DPDOP/M1DPDUM/M2DUM/M2DOP/M2DP/M2DPDUM/M2DPDOP/M3DUM/M3DOP/M3DP/M3DPDUM/M3DPDOP/M4DUM/M4DOP/M5DUM/M6DUM/M7DUM/V1DUM/V2DUM/V3DUM/V4DUM/V5DUM/V6DUM/BV1DUM/BV2DUM/B1DUM/B1DOP/B2DUM/B2DOP/UTMDUM/TM1DUM/TM2DUM/ALDUM layers in chip design is not allowed except DMCMK2 and MARKS region
@ These layers are dedicated for SMIC BEOL dummy auto-insertion utility usage, can't be used for manually drawn purpose
 BV1DUM NOT INSIDE DMCMK2_MARKS
}
 
GR_18b_BV2DUM {
@ M1DOP/M1DUM/M1DP/M1DPDOP/M1DPDUM/M2DUM/M2DOP/M2DP/M2DPDUM/M2DPDOP/M3DUM/M3DOP/M3DP/M3DPDUM/M3DPDOP/M4DUM/M4DOP/M5DUM/M6DUM/M7DUM/V1DUM/V2DUM/V3DUM/V4DUM/V5DUM/V6DUM/BV1DUM/BV2DUM/B1DUM/B1DOP/B2DUM/B2DOP/UTMDUM/TM1DUM/TM2DUM/ALDUM layers in chip design is not allowed except DMCMK2 and MARKS region
@ These layers are dedicated for SMIC BEOL dummy auto-insertion utility usage, can't be used for manually drawn purpose
 BV2DUM NOT INSIDE DMCMK2_MARKS
}
 
GR_18b_B1DUM {
@ M1DOP/M1DUM/M1DP/M1DPDOP/M1DPDUM/M2DUM/M2DOP/M2DP/M2DPDUM/M2DPDOP/M3DUM/M3DOP/M3DP/M3DPDUM/M3DPDOP/M4DUM/M4DOP/M5DUM/M6DUM/M7DUM/V1DUM/V2DUM/V3DUM/V4DUM/V5DUM/V6DUM/BV1DUM/BV2DUM/B1DUM/B1DOP/B2DUM/B2DOP/UTMDUM/TM1DUM/TM2DUM/ALDUM layers in chip design is not allowed except DMCMK2 and MARKS region
@ These layers are dedicated for SMIC BEOL dummy auto-insertion utility usage, can't be used for manually drawn purpose
 B1DUM NOT INSIDE DMCMK2_MARKS
}
 
GR_18b_B1DOP {
@ M1DOP/M1DUM/M1DP/M1DPDOP/M1DPDUM/M2DUM/M2DOP/M2DP/M2DPDUM/M2DPDOP/M3DUM/M3DOP/M3DP/M3DPDUM/M3DPDOP/M4DUM/M4DOP/M5DUM/M6DUM/M7DUM/V1DUM/V2DUM/V3DUM/V4DUM/V5DUM/V6DUM/BV1DUM/BV2DUM/B1DUM/B1DOP/B2DUM/B2DOP/UTMDUM/TM1DUM/TM2DUM/ALDUM layers in chip design is not allowed except DMCMK2 and MARKS region
@ These layers are dedicated for SMIC BEOL dummy auto-insertion utility usage, can't be used for manually drawn purpose
 B1DOP NOT INSIDE DMCMK2_MARKS
}
 
GR_18b_B2DUM {
@ M1DOP/M1DUM/M1DP/M1DPDOP/M1DPDUM/M2DUM/M2DOP/M2DP/M2DPDUM/M2DPDOP/M3DUM/M3DOP/M3DP/M3DPDUM/M3DPDOP/M4DUM/M4DOP/M5DUM/M6DUM/M7DUM/V1DUM/V2DUM/V3DUM/V4DUM/V5DUM/V6DUM/BV1DUM/BV2DUM/B1DUM/B1DOP/B2DUM/B2DOP/UTMDUM/TM1DUM/TM2DUM/ALDUM layers in chip design is not allowed except DMCMK2 and MARKS region
@ These layers are dedicated for SMIC BEOL dummy auto-insertion utility usage, can't be used for manually drawn purpose
 B2DUM NOT INSIDE DMCMK2_MARKS
}
 
GR_18b_B2DOP {
@ M1DOP/M1DUM/M1DP/M1DPDOP/M1DPDUM/M2DUM/M2DOP/M2DP/M2DPDUM/M2DPDOP/M3DUM/M3DOP/M3DP/M3DPDUM/M3DPDOP/M4DUM/M4DOP/M5DUM/M6DUM/M7DUM/V1DUM/V2DUM/V3DUM/V4DUM/V5DUM/V6DUM/BV1DUM/BV2DUM/B1DUM/B1DOP/B2DUM/B2DOP/UTMDUM/TM1DUM/TM2DUM/ALDUM layers in chip design is not allowed except DMCMK2 and MARKS region
@ These layers are dedicated for SMIC BEOL dummy auto-insertion utility usage, can't be used for manually drawn purpose
 B2DOP NOT INSIDE DMCMK2_MARKS
}
 
GR_18b_UTMDUM {
@ M1DOP/M1DUM/M1DP/M1DPDOP/M1DPDUM/M2DUM/M2DOP/M2DP/M2DPDUM/M2DPDOP/M3DUM/M3DOP/M3DP/M3DPDUM/M3DPDOP/M4DUM/M4DOP/M5DUM/M6DUM/M7DUM/V1DUM/V2DUM/V3DUM/V4DUM/V5DUM/V6DUM/BV1DUM/BV2DUM/B1DUM/B1DOP/B2DUM/B2DOP/UTMDUM/TM1DUM/TM2DUM/ALDUM layers in chip design is not allowed except DMCMK2 and MARKS region
@ These layers are dedicated for SMIC BEOL dummy auto-insertion utility usage, can't be used for manually drawn purpose
 UTMDUM NOT INSIDE DMCMK2_MARKS
}
 
GR_18b_TM1DUM {
@ M1DOP/M1DUM/M1DP/M1DPDOP/M1DPDUM/M2DUM/M2DOP/M2DP/M2DPDUM/M2DPDOP/M3DUM/M3DOP/M3DP/M3DPDUM/M3DPDOP/M4DUM/M4DOP/M5DUM/M6DUM/M7DUM/V1DUM/V2DUM/V3DUM/V4DUM/V5DUM/V6DUM/BV1DUM/BV2DUM/B1DUM/B1DOP/B2DUM/B2DOP/UTMDUM/TM1DUM/TM2DUM/ALDUM layers in chip design is not allowed except DMCMK2 and MARKS region
@ These layers are dedicated for SMIC BEOL dummy auto-insertion utility usage, can't be used for manually drawn purpose
 TM1DUM NOT INSIDE DMCMK2_MARKS
}
 
GR_18b_TM2DUM {
@ M1DOP/M1DUM/M1DP/M1DPDOP/M1DPDUM/M2DUM/M2DOP/M2DP/M2DPDUM/M2DPDOP/M3DUM/M3DOP/M3DP/M3DPDUM/M3DPDOP/M4DUM/M4DOP/M5DUM/M6DUM/M7DUM/V1DUM/V2DUM/V3DUM/V4DUM/V5DUM/V6DUM/BV1DUM/BV2DUM/B1DUM/B1DOP/B2DUM/B2DOP/UTMDUM/TM1DUM/TM2DUM/ALDUM layers in chip design is not allowed except DMCMK2 and MARKS region
@ These layers are dedicated for SMIC BEOL dummy auto-insertion utility usage, can't be used for manually drawn purpose
 TM2DUM NOT INSIDE DMCMK2_MARKS
}
 
GR_18b_ALDUM {
@ M1DOP/M1DUM/M1DP/M1DPDOP/M1DPDUM/M2DUM/M2DOP/M2DP/M2DPDUM/M2DPDOP/M3DUM/M3DOP/M3DP/M3DPDUM/M3DPDOP/M4DUM/M4DOP/M5DUM/M6DUM/M7DUM/V1DUM/V2DUM/V3DUM/V4DUM/V5DUM/V6DUM/BV1DUM/BV2DUM/B1DUM/B1DOP/B2DUM/B2DOP/UTMDUM/TM1DUM/TM2DUM/ALDUM layers in chip design is not allowed except DMCMK2 and MARKS region
@ These layers are dedicated for SMIC BEOL dummy auto-insertion utility usage, can't be used for manually drawn purpose
 ALDUM NOT INSIDE DMCMK2_MARKS
}
 
GR_19_ALL_AA {
@ ALL_AA, CELLB, AR, DNW, NW, PSUB, SVT_N, SVT_P, HVT_N, HVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, DG, DGV, DGUD, ALL_GT, GTMK1, GTMK2, ALL_P2, SN, SP, ALL_M0, ALL_M0C, ALL_M0G, V0, CHIPB, DIR, DIRDMP, RESP2, RESP1, MIM, CTOP must be orthogonal to grid
@ DRC waive SP/GT/M0 in the MARKS region
 err1 = DFM COPY (OFFGRID ALL_AA 10) REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
GR_19_CELLB {
@ ALL_AA, CELLB, AR, DNW, NW, PSUB, SVT_N, SVT_P, HVT_N, HVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, DG, DGV, DGUD, ALL_GT, GTMK1, GTMK2, ALL_P2, SN, SP, ALL_M0, ALL_M0C, ALL_M0G, V0, CHIPB, DIR, DIRDMP, RESP2, RESP1, MIM, CTOP must be orthogonal to grid
@ DRC waive SP/GT/M0 in the MARKS region
 err1 = DFM COPY (OFFGRID CELLB 10) REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
GR_19_AR {
@ ALL_AA, CELLB, AR, DNW, NW, PSUB, SVT_N, SVT_P, HVT_N, HVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, DG, DGV, DGUD, ALL_GT, GTMK1, GTMK2, ALL_P2, SN, SP, ALL_M0, ALL_M0C, ALL_M0G, V0, CHIPB, DIR, DIRDMP, RESP2, RESP1, MIM, CTOP must be orthogonal to grid
@ DRC waive SP/GT/M0 in the MARKS region
 err1 = DFM COPY (OFFGRID AR 10) REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
GR_19_DNW {
@ ALL_AA, CELLB, AR, DNW, NW, PSUB, SVT_N, SVT_P, HVT_N, HVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, DG, DGV, DGUD, ALL_GT, GTMK1, GTMK2, ALL_P2, SN, SP, ALL_M0, ALL_M0C, ALL_M0G, V0, CHIPB, DIR, DIRDMP, RESP2, RESP1, MIM, CTOP must be orthogonal to grid
@ DRC waive SP/GT/M0 in the MARKS region
 err1 = DFM COPY (OFFGRID DNW 10) REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
GR_19_NW {
@ ALL_AA, CELLB, AR, DNW, NW, PSUB, SVT_N, SVT_P, HVT_N, HVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, DG, DGV, DGUD, ALL_GT, GTMK1, GTMK2, ALL_P2, SN, SP, ALL_M0, ALL_M0C, ALL_M0G, V0, CHIPB, DIR, DIRDMP, RESP2, RESP1, MIM, CTOP must be orthogonal to grid
@ DRC waive SP/GT/M0 in the MARKS region
 err1 = DFM COPY (OFFGRID NW 10) REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
GR_19_PSUB {
@ ALL_AA, CELLB, AR, DNW, NW, PSUB, SVT_N, SVT_P, HVT_N, HVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, DG, DGV, DGUD, ALL_GT, GTMK1, GTMK2, ALL_P2, SN, SP, ALL_M0, ALL_M0C, ALL_M0G, V0, CHIPB, DIR, DIRDMP, RESP2, RESP1, MIM, CTOP must be orthogonal to grid
@ DRC waive SP/GT/M0 in the MARKS region
 err1 = DFM COPY (OFFGRID PSUB 10) REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
GR_19_SVT_N {
@ ALL_AA, CELLB, AR, DNW, NW, PSUB, SVT_N, SVT_P, HVT_N, HVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, DG, DGV, DGUD, ALL_GT, GTMK1, GTMK2, ALL_P2, SN, SP, ALL_M0, ALL_M0C, ALL_M0G, V0, CHIPB, DIR, DIRDMP, RESP2, RESP1, MIM, CTOP must be orthogonal to grid
@ DRC waive SP/GT/M0 in the MARKS region
 err1 = DFM COPY (OFFGRID SVT_N 10) REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
GR_19_SVT_P {
@ ALL_AA, CELLB, AR, DNW, NW, PSUB, SVT_N, SVT_P, HVT_N, HVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, DG, DGV, DGUD, ALL_GT, GTMK1, GTMK2, ALL_P2, SN, SP, ALL_M0, ALL_M0C, ALL_M0G, V0, CHIPB, DIR, DIRDMP, RESP2, RESP1, MIM, CTOP must be orthogonal to grid
@ DRC waive SP/GT/M0 in the MARKS region
 err1 = DFM COPY (OFFGRID SVT_P 10) REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
GR_19_HVT_N {
@ ALL_AA, CELLB, AR, DNW, NW, PSUB, SVT_N, SVT_P, HVT_N, HVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, DG, DGV, DGUD, ALL_GT, GTMK1, GTMK2, ALL_P2, SN, SP, ALL_M0, ALL_M0C, ALL_M0G, V0, CHIPB, DIR, DIRDMP, RESP2, RESP1, MIM, CTOP must be orthogonal to grid
@ DRC waive SP/GT/M0 in the MARKS region
 err1 = DFM COPY (OFFGRID HVT_N 10) REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
GR_19_HVT_P {
@ ALL_AA, CELLB, AR, DNW, NW, PSUB, SVT_N, SVT_P, HVT_N, HVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, DG, DGV, DGUD, ALL_GT, GTMK1, GTMK2, ALL_P2, SN, SP, ALL_M0, ALL_M0C, ALL_M0G, V0, CHIPB, DIR, DIRDMP, RESP2, RESP1, MIM, CTOP must be orthogonal to grid
@ DRC waive SP/GT/M0 in the MARKS region
 err1 = DFM COPY (OFFGRID HVT_P 10) REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
GR_19_LVT_N {
@ ALL_AA, CELLB, AR, DNW, NW, PSUB, SVT_N, SVT_P, HVT_N, HVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, DG, DGV, DGUD, ALL_GT, GTMK1, GTMK2, ALL_P2, SN, SP, ALL_M0, ALL_M0C, ALL_M0G, V0, CHIPB, DIR, DIRDMP, RESP2, RESP1, MIM, CTOP must be orthogonal to grid
@ DRC waive SP/GT/M0 in the MARKS region
 err1 = DFM COPY (OFFGRID LVT_N 10) REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
GR_19_LVT_P {
@ ALL_AA, CELLB, AR, DNW, NW, PSUB, SVT_N, SVT_P, HVT_N, HVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, DG, DGV, DGUD, ALL_GT, GTMK1, GTMK2, ALL_P2, SN, SP, ALL_M0, ALL_M0C, ALL_M0G, V0, CHIPB, DIR, DIRDMP, RESP2, RESP1, MIM, CTOP must be orthogonal to grid
@ DRC waive SP/GT/M0 in the MARKS region
 err1 = DFM COPY (OFFGRID LVT_P 10) REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
GR_19_ULVT_N {
@ ALL_AA, CELLB, AR, DNW, NW, PSUB, SVT_N, SVT_P, HVT_N, HVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, DG, DGV, DGUD, ALL_GT, GTMK1, GTMK2, ALL_P2, SN, SP, ALL_M0, ALL_M0C, ALL_M0G, V0, CHIPB, DIR, DIRDMP, RESP2, RESP1, MIM, CTOP must be orthogonal to grid
@ DRC waive SP/GT/M0 in the MARKS region
 err1 = DFM COPY (OFFGRID ULVT_N 10) REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
GR_19_ULVT_P {
@ ALL_AA, CELLB, AR, DNW, NW, PSUB, SVT_N, SVT_P, HVT_N, HVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, DG, DGV, DGUD, ALL_GT, GTMK1, GTMK2, ALL_P2, SN, SP, ALL_M0, ALL_M0C, ALL_M0G, V0, CHIPB, DIR, DIRDMP, RESP2, RESP1, MIM, CTOP must be orthogonal to grid
@ DRC waive SP/GT/M0 in the MARKS region
 err1 = DFM COPY (OFFGRID ULVT_P 10) REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
GR_19_LFN_N {
@ ALL_AA, CELLB, AR, DNW, NW, PSUB, SVT_N, SVT_P, HVT_N, HVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, DG, DGV, DGUD, ALL_GT, GTMK1, GTMK2, ALL_P2, SN, SP, ALL_M0, ALL_M0C, ALL_M0G, V0, CHIPB, DIR, DIRDMP, RESP2, RESP1, MIM, CTOP must be orthogonal to grid
@ DRC waive SP/GT/M0 in the MARKS region
 err1 = DFM COPY (OFFGRID LFN_N 10) REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
GR_19_LFN_P {
@ ALL_AA, CELLB, AR, DNW, NW, PSUB, SVT_N, SVT_P, HVT_N, HVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, DG, DGV, DGUD, ALL_GT, GTMK1, GTMK2, ALL_P2, SN, SP, ALL_M0, ALL_M0C, ALL_M0G, V0, CHIPB, DIR, DIRDMP, RESP2, RESP1, MIM, CTOP must be orthogonal to grid
@ DRC waive SP/GT/M0 in the MARKS region
 err1 = DFM COPY (OFFGRID LFN_P 10) REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
GR_19_DG {
@ ALL_AA, CELLB, AR, DNW, NW, PSUB, SVT_N, SVT_P, HVT_N, HVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, DG, DGV, DGUD, ALL_GT, GTMK1, GTMK2, ALL_P2, SN, SP, ALL_M0, ALL_M0C, ALL_M0G, V0, CHIPB, DIR, DIRDMP, RESP2, RESP1, MIM, CTOP must be orthogonal to grid
@ DRC waive SP/GT/M0 in the MARKS region
 err1 = DFM COPY (OFFGRID DG 10) REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
GR_19_DGV {
@ ALL_AA, CELLB, AR, DNW, NW, PSUB, SVT_N, SVT_P, HVT_N, HVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, DG, DGV, DGUD, ALL_GT, GTMK1, GTMK2, ALL_P2, SN, SP, ALL_M0, ALL_M0C, ALL_M0G, V0, CHIPB, DIR, DIRDMP, RESP2, RESP1, MIM, CTOP must be orthogonal to grid
@ DRC waive SP/GT/M0 in the MARKS region
 err1 = DFM COPY (OFFGRID DGV 10) REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
GR_19_DGUD {
@ ALL_AA, CELLB, AR, DNW, NW, PSUB, SVT_N, SVT_P, HVT_N, HVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, DG, DGV, DGUD, ALL_GT, GTMK1, GTMK2, ALL_P2, SN, SP, ALL_M0, ALL_M0C, ALL_M0G, V0, CHIPB, DIR, DIRDMP, RESP2, RESP1, MIM, CTOP must be orthogonal to grid
@ DRC waive SP/GT/M0 in the MARKS region
 err1 = DFM COPY (OFFGRID DGUD 10) REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
GR_19_DUM_GT {
@ ALL_AA, CELLB, AR, DNW, NW, PSUB, SVT_N, SVT_P, HVT_N, HVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, DG, DGV, DGUD, ALL_GT, GTMK1, GTMK2, ALL_P2, SN, SP, ALL_M0, ALL_M0C, ALL_M0G, V0, CHIPB, DIR, DIRDMP, RESP2, RESP1, MIM, CTOP must be orthogonal to grid
@ DRC waive SP/GT/M0 in the MARKS region
 err1 = DFM COPY (OFFGRID DUM_GT 10) REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
GR_19_GTMK1 {
@ ALL_AA, CELLB, AR, DNW, NW, PSUB, SVT_N, SVT_P, HVT_N, HVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, DG, DGV, DGUD, ALL_GT, GTMK1, GTMK2, ALL_P2, SN, SP, ALL_M0, ALL_M0C, ALL_M0G, V0, CHIPB, DIR, DIRDMP, RESP2, RESP1, MIM, CTOP must be orthogonal to grid
@ DRC waive SP/GT/M0 in the MARKS region
 err1 = DFM COPY (OFFGRID GTMK1 10) REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
GR_19_GTMK2 {
@ ALL_AA, CELLB, AR, DNW, NW, PSUB, SVT_N, SVT_P, HVT_N, HVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, DG, DGV, DGUD, ALL_GT, GTMK1, GTMK2, ALL_P2, SN, SP, ALL_M0, ALL_M0C, ALL_M0G, V0, CHIPB, DIR, DIRDMP, RESP2, RESP1, MIM, CTOP must be orthogonal to grid
@ DRC waive SP/GT/M0 in the MARKS region
 err1 = DFM COPY (OFFGRID GTMK2 10) REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
GR_19_ALL_P2 {
@ ALL_AA, CELLB, AR, DNW, NW, PSUB, SVT_N, SVT_P, HVT_N, HVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, DG, DGV, DGUD, ALL_GT, GTMK1, GTMK2, ALL_P2, SN, SP, ALL_M0, ALL_M0C, ALL_M0G, V0, CHIPB, DIR, DIRDMP, RESP2, RESP1, MIM, CTOP must be orthogonal to grid
@ DRC waive SP/GT/M0 in the MARKS region
 err1 = DFM COPY (OFFGRID ALL_P2 10) REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
GR_19_DUM_M0 {
@ ALL_AA, CELLB, AR, DNW, NW, PSUB, SVT_N, SVT_P, HVT_N, HVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, DG, DGV, DGUD, ALL_GT, GTMK1, GTMK2, ALL_P2, SN, SP, ALL_M0, ALL_M0C, ALL_M0G, V0, CHIPB, DIR, DIRDMP, RESP2, RESP1, MIM, CTOP must be orthogonal to grid
@ DRC waive SP/GT/M0 in the MARKS region
 err1 = DFM COPY (OFFGRID DUM_M0 10) REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
GR_19_ALL_M0C {
@ ALL_AA, CELLB, AR, DNW, NW, PSUB, SVT_N, SVT_P, HVT_N, HVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, DG, DGV, DGUD, ALL_GT, GTMK1, GTMK2, ALL_P2, SN, SP, ALL_M0, ALL_M0C, ALL_M0G, V0, CHIPB, DIR, DIRDMP, RESP2, RESP1, MIM, CTOP must be orthogonal to grid
@ DRC waive SP/GT/M0 in the MARKS region
 err1 = DFM COPY (OFFGRID ALL_M0C 10) REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
GR_19_ALL_M0G {
@ ALL_AA, CELLB, AR, DNW, NW, PSUB, SVT_N, SVT_P, HVT_N, HVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, DG, DGV, DGUD, ALL_GT, GTMK1, GTMK2, ALL_P2, SN, SP, ALL_M0, ALL_M0C, ALL_M0G, V0, CHIPB, DIR, DIRDMP, RESP2, RESP1, MIM, CTOP must be orthogonal to grid
@ DRC waive SP/GT/M0 in the MARKS region
 err1 = DFM COPY (OFFGRID ALL_M0G 10) REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
GR_19_V0 {
@ ALL_AA, CELLB, AR, DNW, NW, PSUB, SVT_N, SVT_P, HVT_N, HVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, DG, DGV, DGUD, ALL_GT, GTMK1, GTMK2, ALL_P2, SN, SP, ALL_M0, ALL_M0C, ALL_M0G, V0, CHIPB, DIR, DIRDMP, RESP2, RESP1, MIM, CTOP must be orthogonal to grid
@ DRC waive SP/GT/M0 in the MARKS region
 err1 = DFM COPY (OFFGRID V0 10) REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
GR_19_CHIPB {
@ ALL_AA, CELLB, AR, DNW, NW, PSUB, SVT_N, SVT_P, HVT_N, HVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, DG, DGV, DGUD, ALL_GT, GTMK1, GTMK2, ALL_P2, SN, SP, ALL_M0, ALL_M0C, ALL_M0G, V0, CHIPB, DIR, DIRDMP, RESP2, RESP1, MIM, CTOP must be orthogonal to grid
@ DRC waive SP/GT/M0 in the MARKS region
 err1 = DFM COPY (OFFGRID CHIPB 10) REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
GR_19_DIR {
@ ALL_AA, CELLB, AR, DNW, NW, PSUB, SVT_N, SVT_P, HVT_N, HVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, DG, DGV, DGUD, ALL_GT, GTMK1, GTMK2, ALL_P2, SN, SP, ALL_M0, ALL_M0C, ALL_M0G, V0, CHIPB, DIR, DIRDMP, RESP2, RESP1, MIM, CTOP must be orthogonal to grid
@ DRC waive SP/GT/M0 in the MARKS region
 err1 = DFM COPY (OFFGRID DIR 10) REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
GR_19_DIRDMP {
@ ALL_AA, CELLB, AR, DNW, NW, PSUB, SVT_N, SVT_P, HVT_N, HVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, DG, DGV, DGUD, ALL_GT, GTMK1, GTMK2, ALL_P2, SN, SP, ALL_M0, ALL_M0C, ALL_M0G, V0, CHIPB, DIR, DIRDMP, RESP2, RESP1, MIM, CTOP must be orthogonal to grid
@ DRC waive SP/GT/M0 in the MARKS region
 err1 = DFM COPY (OFFGRID DIRDMP 10) REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
GR_19_RESP2 {
@ ALL_AA, CELLB, AR, DNW, NW, PSUB, SVT_N, SVT_P, HVT_N, HVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, DG, DGV, DGUD, ALL_GT, GTMK1, GTMK2, ALL_P2, SN, SP, ALL_M0, ALL_M0C, ALL_M0G, V0, CHIPB, DIR, DIRDMP, RESP2, RESP1, MIM, CTOP must be orthogonal to grid
@ DRC waive SP/GT/M0 in the MARKS region
 err1 = DFM COPY (OFFGRID RESP2 10) REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
GR_19_RESP1 {
@ ALL_AA, CELLB, AR, DNW, NW, PSUB, SVT_N, SVT_P, HVT_N, HVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, DG, DGV, DGUD, ALL_GT, GTMK1, GTMK2, ALL_P2, SN, SP, ALL_M0, ALL_M0C, ALL_M0G, V0, CHIPB, DIR, DIRDMP, RESP2, RESP1, MIM, CTOP must be orthogonal to grid
@ DRC waive SP/GT/M0 in the MARKS region
 err1 = DFM COPY (OFFGRID RESP1 10) REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
GR_19_MIM {
@ ALL_AA, CELLB, AR, DNW, NW, PSUB, SVT_N, SVT_P, HVT_N, HVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, DG, DGV, DGUD, ALL_GT, GTMK1, GTMK2, ALL_P2, SN, SP, ALL_M0, ALL_M0C, ALL_M0G, V0, CHIPB, DIR, DIRDMP, RESP2, RESP1, MIM, CTOP must be orthogonal to grid
@ DRC waive SP/GT/M0 in the MARKS region
 err1 = DFM COPY (OFFGRID MIM 10) REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
GR_19_CTOP {
@ ALL_AA, CELLB, AR, DNW, NW, PSUB, SVT_N, SVT_P, HVT_N, HVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, DG, DGV, DGUD, ALL_GT, GTMK1, GTMK2, ALL_P2, SN, SP, ALL_M0, ALL_M0C, ALL_M0G, V0, CHIPB, DIR, DIRDMP, RESP2, RESP1, MIM, CTOP must be orthogonal to grid
@ DRC waive SP/GT/M0 in the MARKS region
 err1 = DFM COPY (OFFGRID CTOP 10) REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

GR_19_SP {
@ ALL_AA, CELLB, AR, DNW, NW, PSUB, SVT_N, SVT_P, HVT_N, HVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, DG, DGV, DGUD, ALL_GT, GTMK1, GTMK2, ALL_P2, SN, SP, ALL_M0, ALL_M0C, ALL_M0G, V0, CHIPB, DIR, DIRDMP, RESP2, RESP1, MIM, CTOP must be orthogonal to grid
@ DRC waive SP/GT/M0 in the MARKS region
 err1 = EXPAND EDGE (DFM COPY (OFFGRID SP 10) EDGE) BY 0.0001
 err1 NOT INSIDE MARKS
}

GR_19_GT {
@ ALL_AA, CELLB, AR, DNW, NW, PSUB, SVT_N, SVT_P, HVT_N, HVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, DG, DGV, DGUD, ALL_GT, GTMK1, GTMK2, ALL_P2, SN, SP, ALL_M0, ALL_M0C, ALL_M0G, V0, CHIPB, DIR, DIRDMP, RESP2, RESP1, MIM, CTOP must be orthogonal to grid
@ DRC waive SP/GT/M0 in the MARKS region
 err1 = EXPAND EDGE (DFM COPY (OFFGRID GT 10) EDGE) BY 0.0001
 err1 NOT INSIDE MARKS
}

GR_19_M0 {
@ ALL_AA, CELLB, AR, DNW, NW, PSUB, SVT_N, SVT_P, HVT_N, HVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, DG, DGV, DGUD, ALL_GT, GTMK1, GTMK2, ALL_P2, SN, SP, ALL_M0, ALL_M0C, ALL_M0G, V0, CHIPB, DIR, DIRDMP, RESP2, RESP1, MIM, CTOP must be orthogonal to grid
@ DRC waive SP/GT/M0 in the MARKS region
 err1 = DFM COPY (OFFGRID M0 10) EDGE
 err1 NOT INSIDE EDGE MARKS
}

GR_20 {
@ PPAA/AR_H/AR_V/PPAADB/ARBL layers in chip design is not allowed, except INST, OCOVL, DMCMK1 and MARKS regions
 WAIVE_AREA = OR DMCMK1 OCOVL MARKS_INST
 err1 = ((OR PPAA AR_H AR_V PPAADB ARBL) NOT WAIVE_AREA) INTERACT DRC:1
 err1 NOT INSIDE WAIVE_AREA
}
 
GR_21_ESDIO1 {
@ (AA OR DOP_AA) enclosure by ESDIO1, ESDIO2, DBESD, DBESD2, LDBK, DSTR, DMPNP, DIOMK1, DIOMK2, VARMOS and DNW must be <= 3um
 chk_aa = OR AA DOP_AA
 chk_aa_sizing_3 = EXTENTS (SIZE (chk_aa AND ESDIO1) BY 3)
 err1 = (ESDIO1 INTERACT chk_aa) NOT chk_aa_sizing_3
 err1 NOT INSIDE SealR_NOT_BULK
}
 
GR_21_ESDIO2 {
@ (AA OR DOP_AA) enclosure by ESDIO1, ESDIO2, DBESD, DBESD2, LDBK, DSTR, DMPNP, DIOMK1, DIOMK2, VARMOS and DNW must be <= 3um
 chk_aa = OR AA DOP_AA
 chk_aa_sizing_3 = EXTENTS (SIZE (chk_aa AND ESDIO2) BY 3)
 err1 = (ESDIO2 INTERACT chk_aa) NOT chk_aa_sizing_3
 err1 NOT INSIDE SealR_NOT_BULK
}
 
GR_21_DBESD {
@ (AA OR DOP_AA) enclosure by ESDIO1, ESDIO2, DBESD, DBESD2, LDBK, DSTR, DMPNP, DIOMK1, DIOMK2, VARMOS and DNW must be <= 3um
 chk_aa = OR AA DOP_AA
 chk_aa_sizing_3 = EXTENTS (SIZE (chk_aa AND DBESD) BY 3)
 err1 = (DBESD INTERACT chk_aa) NOT chk_aa_sizing_3
 err1 NOT INSIDE SealR_NOT_BULK
}
 
GR_21_DBESD2 {
@ (AA OR DOP_AA) enclosure by ESDIO1, ESDIO2, DBESD, DBESD2, LDBK, DSTR, DMPNP, DIOMK1, DIOMK2, VARMOS and DNW must be <= 3um
 chk_aa = OR AA DOP_AA
 chk_aa_sizing_3 = EXTENTS (SIZE (chk_aa AND DBESD2) BY 3)
 err1 = (DBESD2 INTERACT chk_aa) NOT chk_aa_sizing_3
 err1 NOT INSIDE SealR_NOT_BULK
}
 
GR_21_LDBK {
@ (AA OR DOP_AA) enclosure by ESDIO1, ESDIO2, DBESD, DBESD2, LDBK, DSTR, DMPNP, DIOMK1, DIOMK2, VARMOS and DNW must be <= 3um
 chk_aa = OR AA DOP_AA
 chk_aa_sizing_3 = EXTENTS (SIZE (chk_aa AND LDBK) BY 3)
 err1 = (LDBK INTERACT chk_aa) NOT chk_aa_sizing_3
 err1 NOT INSIDE SealR_NOT_BULK
}
 
GR_21_DSTR {
@ (AA OR DOP_AA) enclosure by ESDIO1, ESDIO2, DBESD, DBESD2, LDBK, DSTR, DMPNP, DIOMK1, DIOMK2, VARMOS and DNW must be <= 3um
 chk_aa = OR AA DOP_AA
 chk_aa_sizing_3 = EXTENTS (SIZE (chk_aa AND DSTR) BY 3)
 err1 = (DSTR INTERACT chk_aa) NOT chk_aa_sizing_3
 err1 NOT INSIDE SealR_NOT_BULK
}
 
GR_21_DMPNP {
@ (AA OR DOP_AA) enclosure by ESDIO1, ESDIO2, DBESD, DBESD2, LDBK, DSTR, DMPNP, DIOMK1, DIOMK2, VARMOS and DNW must be <= 3um
 chk_aa = OR AA DOP_AA
 chk_aa_sizing_3 = EXTENTS (SIZE (chk_aa AND DMPNP) BY 3)
 err1 = (DMPNP INTERACT chk_aa) NOT chk_aa_sizing_3
 err1 NOT INSIDE SealR_NOT_BULK
}
 
GR_21_DIOMK1 {
@ (AA OR DOP_AA) enclosure by ESDIO1, ESDIO2, DBESD, DBESD2, LDBK, DSTR, DMPNP, DIOMK1, DIOMK2, VARMOS and DNW must be <= 3um
 chk_aa = OR AA DOP_AA
 chk_aa_sizing_3 = EXTENTS (SIZE (chk_aa AND DIOMK1) BY 3)
 err1 = (DIOMK1 INTERACT chk_aa) NOT chk_aa_sizing_3
 err1 NOT INSIDE SealR_NOT_BULK
}
 
GR_21_DIOMK2 {
@ (AA OR DOP_AA) enclosure by ESDIO1, ESDIO2, DBESD, DBESD2, LDBK, DSTR, DMPNP, DIOMK1, DIOMK2, VARMOS and DNW must be <= 3um
 chk_aa = OR AA DOP_AA
 chk_aa_sizing_3 = EXTENTS (SIZE (chk_aa AND DIOMK2) BY 3)
 err1 = (DIOMK2 INTERACT chk_aa) NOT chk_aa_sizing_3
 err1 NOT INSIDE SealR_NOT_BULK
}
 
GR_21_VARMOS {
@ (AA OR DOP_AA) enclosure by ESDIO1, ESDIO2, DBESD, DBESD2, LDBK, DSTR, DMPNP, DIOMK1, DIOMK2, VARMOS and DNW must be <= 3um
 chk_aa = OR AA DOP_AA
 chk_aa_sizing_3 = EXTENTS (SIZE (chk_aa AND VARMOS) BY 3)
 err1 = (VARMOS INTERACT chk_aa) NOT chk_aa_sizing_3
 err1 NOT INSIDE SealR_NOT_BULK
}
 
GR_21_DNW {
@ (AA OR DOP_AA) enclosure by ESDIO1, ESDIO2, DBESD, DBESD2, LDBK, DSTR, DMPNP, DIOMK1, DIOMK2, VARMOS and DNW must be <= 3um
 chk_aa = OR AA DOP_AA
 chk_aa_sizing_3 = EXTENTS (SIZE (chk_aa AND DNW) BY 3)
 err1 = (DNW INTERACT chk_aa) NOT chk_aa_sizing_3
 err1 NOT INSIDE SealR_NOT_BULK
}

//;GR_21_NW {
//;@ (AA OR DOP_AA) enclosure by ESDIO1, ESDIO2, DBESD, DBESD2, LDBK, DSTR, DMPNP, DIOMK1, DIOMK2, VARMOS and DNW must be <= 3um
//; chk_aa = OR AA DOP_AA
//; chk_aa_sizing_3 = EXTENTS (SIZE (chk_aa AND (NW NOT RESNW)) BY 3)
//; err1 = ((NW NOT RESNW) INTERACT chk_aa) NOT chk_aa_sizing_3
//; err1 NOT INSIDE SealR_NOT_BULK
//;}

GR_22 {
@ O-shape AA is not allowed
 err1 = HOLES AA SINGULAR ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}





// =======================================================
// CELLB: Cell boundary design rules
// =======================================================

GROUP GFIN FIN_?
GROUP GCELLB CELLB_?

CELLB_ALL = CELLB OR DMCB1
CELLB_ALL_h_edges = ANGLE CELLB_ALL == 0
CELLB_ALL_v_edges = ANGLE CELLB_ALL == 90
CELLB_convex_eq_two_edges = CONVEX EDGE CELLB == 2

FIN_in_SRAM = FIN INTERACT INST
FIN_ouT_SRAM = FIN NOT INSIDE INST
FIN_and_CELLB = FIN AND CELLB
FIN_merge_all = SIZE (FIN INTERACT CELLB) BY FIN_SPACE/2 OVERUNDER

FIN_sides_space_ne_FinS = EXT (FIN_and_CELLB) == FIN_SPACE ABUT<90 OPPOSITE
FIN_out_sides_enc_CELLB = ENC [FIN_and_CELLB] CELLB == FIN_ENCLOSED_CELLB ABUT<90 OPPOSITE

FIN_and_CELLB_merge = SIZE FIN_and_CELLB BY 0.1 OVERUNDER
FIN_in_CELLB_vertex = INT (FIN_v_edges INSIDE EDGE CELLB) FIN < 0.001 ABUT INTERSECTING ONLY REGION

FIN_W_1 {
@ FIN width in GATE poly direction = 0.01um
 err1 = INT (FIN_h_edges) == FIN_WIDTH ABUT<90 OPPOSITE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

FIN_S_1 {
@ FIN exact space in CELLB region along GATE poly direction, FIN veritcal edge must align with CELLB = 0.038um
@ DRC Hints: all FIN vertical sides should be butted with CELLB
 err1 = ((FIN_sides_space_ne_FinS NOT COIN EDGE FIN_out_sides_enc_CELLB) NOT COIN EDGE FIN_v_edges) NOT COIN EDGE FIN_and_CELLB_merge
 err1 NOT INSIDE EDGE SealR_NOT_BULK

 err2 = EXT FIN_and_CELLB < FIN_SPACE ABUT<90 OPPOSITE REGION
 err2 NOT INSIDE SealR_NOT_BULK

 err3 = FIN_merge_all INTERACT (CELLB INTERACT FIN_merge_all > 1)
 err3 NOT INSIDE SealR_NOT_BULK

 err4 = FIN_in_CELLB_vertex NOT WITH EDGE (FIN_in_CELLB_vertex COIN EDGE CELLB_v_edges)  //;recover from FIN.R.2 in Old V0.1 to control FIN layer
 err4 NOT INSIDE SealR_NOT_BULK
}

FIN_R_1 {
@ FIN must be an orthogonal rectangle
 err1 = NOT RECTANGLE FIN ORTHOGONAL ONLY
 err1 NOT INSIDE SealR_NOT_BULK

 err2 = INT FIN < 0.001 ABUT<90 SINGULAR REGION
 err2 NOT INSIDE SealR_NOT_BULK
}

FIN_R_2 {
@ FIN must inside CELLB, except INST region
 err1 = FIN_ouT_SRAM NOT CELLB
 err1 NOT INSIDE INST
}

CELLB_W_1 {
@ CELLB width in S/D direction >= 0.43um
 err1 = LENGTH (ANGLE CELLB_convex_eq_two_edges == 0) < 0.43
 err1 NOT INSIDE EDGE SealR_NOT_BULK

 err2 = INT CELLB_v_edges < 0.43 ABUT<90 OPPOSITE REGION
 err2 NOT INSIDE SealR_NOT_BULK
}

CELLB_W_2 {
@ CELLB width in GATE poly direction = 0.288+0.048*num
 chk_CELLB = ANGLE CELLB_convex_eq_two_edges == 90
 err1 = DFM PROPERTY chk_CELLB [-= ABS(REMAINDER((LENGTH(chk_CELLB) - 0.288),0.048))] > 0
 err1 NOT INSIDE EDGE SealR_NOT_BULK

 err2 = INT CELLB_h_edges < 0.288 ABUT<90 OPPOSITE REGION
 err2 NOT INSIDE SealR_NOT_BULK
}

CELLB_W_3 {
@ DMCB1 width in GATE poly direction = 0.288+0.048*num
 chk_DMCB1 = ANGLE (CONVEX EDGE DMCB1 == 2) == 90
 err1 = DFM PROPERTY chk_DMCB1 [-= ABS(REMAINDER((LENGTH(chk_DMCB1) - 0.288),0.048))] > 0
 err1 NOT INSIDE EDGE SealR_NOT_BULK

 err2 = INT DMCB1_h_edges < 0.288 ABUT<90 OPPOSITE REGION
 err2 NOT INSIDE SealR_NOT_BULK
}

CELLB_W_4 {
@ DMCB1 horizontal edge length >= 0.388um
 err1 = LENGTH DMCB1_h_edges < 0.388
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

CELLB_S_1 {
@ CELLB space in S/D direction when PRL > -0.096um. >= 0.11um
 err1 = EXT CELLB_v_edges < 0.11 ABUT<90 OPPOSITE EXTENDED 0.096 REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

CELLB_S_2 {
@ CELLB space in GATE poly direction when PRL > -0.11um. = 0.096+0.048*num
@ DRC hint: When violation found, please check the relative coordinate between CELLB and CHIPB or the outermost boundary of all CELLB layers
 err1 = EXT CELLB_h_edges < 0.096 ABUT<90 OPPOSITE EXTENDED 0.11 REGION
 err1 NOT INSIDE SealR_NOT_BULK

 cellb_v_exp = EXPAND EDGE CELLB_v_edges OUTSIDE BY 0.11/2
 cellb_h_chk = ANGLE (CELLB OR cellb_v_exp) == 0
 err2 = DFM COPY (OFFGRID cellb_h_chk 1 480 INSIDE OF LAYER CHIPB ABSOLUTE) REGION
 err2 NOT INSIDE SealR_NOT_BULK

 cellb_boundary = EXTENT CELLB
 err3 = DFM COPY (OFFGRID CELLB_h_edges 1 480 OFFSET 0 480 INSIDE OF LAYER cellb_boundary ABSOLUTE) REGION
 err3 NOT INSIDE SealR_NOT_BULK
}

CELLB_L_1 {
@ (CELLB OR DMCB1) vertical edge length = 0.048+0.048*num
 err1 = LENGTH CELLB_ALL_v_edges < 0.048
 err1 NOT INSIDE EDGE SealR_NOT_BULK

 err2 = DFM PROPERTY CELLB_ALL_v_edges [-= ABS(REMAINDER((LENGTH(CELLB_ALL_v_edges) - 0.048),0.048))] > 0
 err2 NOT INSIDE EDGE SealR_NOT_BULK
}

CELLB_EN_1 {
@ CELLB enclosure of ALL_AA in S/D direction, except DMCB1 region >= 0.08um
 err1 = ENC (ALL_AA AND CELLB) CELLB_v_edges < 0.08 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE DMCB1
}

CELLB_EN_2 {
@ CELLB enclosure of ALL_AA in GATE poly direction, except DMCB1 region = 0.048+0.048*num
 err1 = ENC ALL_AA_h_edges CELLB < 0.048 ABUT<90 OPPOSITE REGION  //;ouside AA covered by CELLB.R.1
 err1 NOT INSIDE DMCB1

 err2 = DFM COPY (OFFGRID (ALL_AA_h_edges NOT INSIDE EDGE DMCB1) 1 480 OFFSET 0 480 INSIDE OF LAYER CELLB ABSOLUTE) REGION
 err2 NOT INSIDE DMCB1
}

CELLB_EN_3 {
@ CELLB enclosure of the outmost FIN within CELLB in GATE poly direction = 0.019um
@ DRC Hints: all FIN vertical sides should be butted with CELLB
 CELLB_inside_shrink = ANGLE ((EXPAND EDGE CELLB_h_edges INSIDE BY 0.019) INSIDE EDGE CELLB) == 0
 err1 = CELLB_inside_shrink NOT COIN EDGE FIN
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

CELLB_R_1 {
@ ALL_AA must be fully covered by CELLB, except DMCMK1, INST and MARKS regions
 err1 = ((ALL_AA NOT CELLB) NOT INSIDE DMCMK1) NOT INSIDE MARKS_INST
 err1 NOT INSIDE SealR_NOT_BULK
}

CELLB_R_2 {
@ CELLB interact with INST is not allowed
 err1 = CELLB NOT OUTSIDE EDGE INST
 err2 = INST NOT OUTSIDE EDGE CELLB
 err1 NOT INSIDE EDGE SealR_NOT_BULK
 err2 NOT INSIDE EDGE SealR_NOT_BULK
}

CELLB_R_3 {
@ CELLB edge must be orthogonal to grid, and 45-degree bent CELLB is not allowed
 err1 = ANGLE CELLB > 0 < 90
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

// =======================================================
// AA: Active Area design rules
// =======================================================

GROUP GAA AA_?

AA_W_1 {
@ ALL_AA width, except INST region >= 0.09um
 err1 = INT ALL_AA < 0.09 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE INST
}

AA_W_2 {
@ ALL_AA width for I/O region, except DMC7 region >= 0.144um
 err1 = (INT ALL_AA_IO < 0.144 ABUT<90 SINGULAR REGION) AND DG
 err1 NOT INSIDE DMC7
}

AA_W_3a {
@ ALL_AA width in GATE poly direction, except INST region = 0.096+0.048*num
 err1 = INT ALL_AA_h_edges < 0.096 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE INST

 err2_EDGE = ANGLE ALL_AA_convex_equal_two_edge == 90
 err2_TMP = DFM PROPERTY err2_EDGE [-= ABS(REMAINDER((LENGTH(err2_EDGE) - 0.048), 0.048))] > 0
 err2 = err2_TMP NOT INSIDE EDGE INST
 err2 NOT INSIDE EDGE SealR_NOT_BULK
}

ALL_AA_convex_equal_two_v_edges = ANGLE ALL_AA_convex_equal_two_edge == 90

AA_W_3b {
@ ALL_AA width in GATE poly direction for I/O region, except DMC7 region = 0.144+0.048*num
 err1 = (DFM COPY (DFM SPACE ALL_AA_IO < 0.144 BY INT VERTICAL) REGION) NOT INSIDE DMC7
 err1 NOT INSIDE SealR_NOT_BULK

 err2_EDGE = ALL_AA_convex_equal_two_v_edges TOUCH EDGE ALL_AA_IO
 err2_TMP = DFM PROPERTY err2_EDGE [-= ABS(REMAINDER((LENGTH(err2_EDGE) - 0.144), 0.048))] > 0
 err2 = ((DFM COPY err2_TMP) INSIDE EDGE DG) NOT INSIDE EDGE DMC7
 err2 NOT INSIDE EDGE SealR_NOT_BULK
}

AA_W_4a {
@ Channel width of core device, except DMPNP, ESDIO1, ESDIO2, INST regions = 0.096+0.048*num
 except_area = OR DMPNP ESDIO_ALL INST
 err1 = GATE_CORE NOT WITH EDGE (LENGTH GATE_WE >= 0.096)
 err1 NOT INSIDE except_area

 core_DEV = GATE_CORE NOT INSIDE except_area
 core_DEV_WE = GATE_WE COIN EDGE core_DEV
 core_DEV_WE_CHK = (CONVEX EDGE GATE_CORE == 2) COIN EDGE core_DEV_WE
 err2 = DFM PROPERTY core_DEV_WE_CHK core_DEV OVERLAP ABUT ALSO MULTI [-= ABS(REMAINDER((LENGTH(core_DEV_WE_CHK) - 0.096), 0.048))] > 0
 err2 NOT INSIDE EDGE except_area
}

AA_W_4b {
@ Channel width of I/O device, except (pick-up NOT VARMOS) = 0.192+0.048*num
 err1 = (GATE_IO NOT WITH EDGE (LENGTH GATE_WE >= 0.192)) NOT INSIDE TAP_NOT_VARMOS
 err1 NOT INSIDE SealR_NOT_BULK

 io_DEV = GATE_IO NOT INSIDE TAP_NOT_VARMOS
 io_DEV_WE = GATE_WE COIN EDGE io_DEV
 io_DEV_WE_CHK = ((CONVEX EDGE GATE_IO == 2) COIN EDGE io_DEV_WE) NOT INSIDE EDGE SealR_NOT_BULK
 err2 = DFM PROPERTY io_DEV_WE_CHK io_DEV OVERLAP ABUT ALSO MULTI [-= ABS(REMAINDER((LENGTH(io_DEV_WE_CHK) - 0.192), 0.048))] > 0
 err2 NOT INSIDE EDGE TAP_NOT_VARMOS
}

AA_W_5 {
@ ALL_AA width in GATE poly direction, except INST region <= 0.96um
 err1 = INT (ALL_AA_h_edges) <= 0.96 ABUT<90 OPPOSITE EXCLUDE SHIELDED
 err1 NOT INSIDE EDGE INST
}

//;AA.L.1: purposely blank

AA_L_2 {
@ (AOP_AA AND FIN) length in S/D direction = 0.09~105um
 err1 = LENGTH AOP_AA_h_edges < 0.09
 err2 = LENGTH AOP_AA_h_edges > 105
 err3 = (AOP_AA AND FIN) ENCLOSE RECTANGLE 0.001 105+GLOBAL_TOLERANCE ORTHOGONAL ONLY
 err1 NOT INSIDE EDGE SealR_NOT_BULK
 err2 NOT INSIDE EDGE SealR_NOT_BULK
 err3 NOT INSIDE EDGE SealR_NOT_BULK
}

AA_L_3 {
@ (DOP_AA AND FIN) length in S/D direction = 0.09~11um
 err1 = LENGTH (DOP_AA COIN EDGE AOP_AA_h_edges) < 0.09
 err2 = LENGTH (DOP_AA COIN EDGE AOP_AA_h_edges) > 11
 err3 = (DOP_AA AND FIN) ENCLOSE RECTANGLE 0.001 11+GLOBAL_TOLERANCE ORTHOGONAL ONLY
 err1 NOT INSIDE EDGE SealR_NOT_BULK
 err2 NOT INSIDE EDGE SealR_NOT_BULK
 err3 NOT INSIDE EDGE SealR_NOT_BULK
}

AA_048_rectangle = AA_RECTANGLE AND AA_048
AA_048_rectangle_h_edges = ANGLE AA_048_rectangle == 0

AA_L_4 {
@ AA horizontal edge length between two consecutive 90-270 degree corners >= 0.27um
 err1 = LENGTH (ANGLE AA_convex_90_270_edge == 0) < 0.27
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

AA_L_5 {
@ AA vertical edge length between two consecutive 270-90 degree corners <= 0.384um
 err1 = LENGTH (ANGLE AA_convex_90_270_edge == 90) > 0.384
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

AA_L_6 {
@ AA horizontal edge length between two consecutive 270-270 degree corners >= 0.27um
 err1 = LENGTH (ANGLE AA_convex_270_270_edge == 0) < 0.27
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

AA_L_7 {
@ Non-rectangle AA horizontal edge length between two consecutive 90-90 degree corners, except LDBK region >= 0.18um
 err1_RAW = LENGTH (ANGLE AA_convex_90_90_edge == 0) < 0.18
 err1 = (EXPAND EDGE err1_RAW INSIDE BY 0.001) WITH EDGE AA_convex_90_270_edge
 err1 NOT INSIDE LDBK
}

AA_S_1 {
@ Space between ALL_AA, except INST region >= 0.09um
 err1 = EXT ALL_AA < 0.09 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE INST
}

AA_S_2 {
@ Space between ALL_AA for I/O region (including core to I/O) >= 0.192um
 err1_TMP = EXT ALL_AA_IO ALL_AA < 0.192 ABUT<90 SINGULAR REGION
 err1 = err1_TMP NOT OUTSIDE DG
 err1 NOT INSIDE SealR_NOT_BULK
}

AA_S_2a {
@ Space between ALL_AA (AA vertical edge extend 1/2 GT width) for I/O region in S/D direction >= 0.117um
 err1_TMP = EXT (ANGLE (OR edge_gate_AA_all edge_gate_dumAA_all) == 90) < 0.117 ABUT<90 OPPOSITE REGION
 err1 = err1_TMP NOT OUTSIDE DG
 err1 NOT INSIDE SealR_NOT_BULK
}

AA_S_3a {
@ Space between ALL_AA in GATE poly direction when PRL > -0.09um, except INST region = 0.096+0.048*num
@ Notice: CELLB must be drawn for AA on-grid check
 err1 = EXT ALL_AA_h_edges < 0.096 ABUT<90 OPPOSITE EXTENDED 0.09 REGION
 err1 NOT INSIDE INST

 check_AREA = (EXPAND EDGE ALL_AA_v_edges OUTSIDE BY 0.09/2) OR ALL_AA
 check_EDGE = (ANGLE check_AREA == 0) NOT INSIDE EDGE INST
 err2 = DFM COPY (OFFGRID check_EDGE 1 480 OFFSET 0 960 INSIDE OF LAYER CELLB ABSOLUTE) REGION
 err2 NOT INSIDE SealR_NOT_BULK
}

AA_S_3b {
@ Space between ALL_AA in GATE poly direction for I/O region when PRL > -0.198um. = 0.192+0.048*num
@ Notice: CELLB must be drawn for AA on-grid check
 check_AREA = (EXPAND EDGE (ANGLE ALL_AA_IO == 90) OUTSIDE BY 0.198/2) OR ALL_AA_IO
 check_EDGE = ANGLE check_AREA == 0
 err1_TMP = EXT check_EDGE < 0.192 ABUT<90 OPPOSITE REGION
 err1 = err1_TMP AND DG
 err1 NOT INSIDE SealR_NOT_BULK

 err2_TMP = (check_EDGE NOT OUTSIDE EDGE DG) NOT INSIDE EDGE SealR_NOT_BULK
 err2 = DFM COPY (OFFGRID err2_TMP 1 480 OFFSET 0 1920 INSIDE OF LAYER CELLB ABSOLUTE) REGION
 err2 NOT INSIDE SealR_NOT_BULK
}

AA_S_4 {
@ Space between ALL_AA in GATE poly direction when at least one side ALL_AA horizontal edge length = 0.09um and PRL > -0.09um. = 0.096, = 0.288+0.048*num
@ Notice: CELLB must be drawn for AA on-grid check
 check_AA = ALL_AA WITH EDGE (LENGTH ALL_AA_h_edges == 0.09)
 check_AREA = (EXPAND EDGE (ANGLE check_AA == 90) OUTSIDE BY 0.045) OR check_AA
 check_EDGE = ANGLE check_AREA == 0
 err1 = EXT check_AA ALL_AA_h_edges < 0.096 ABUT<90 OPPOSITE EXTENDED 0.09 REGION
 err2 = EXT check_AA ALL_AA_h_edges > 0.096 < 0.288 ABUT<90 OPPOSITE EXTENDED 0.09 REGION
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK

 err3_TMP = check_EDGE NOT INSIDE EDGE SealR_NOT_BULK
 err3 = DFM COPY (OFFGRID err3_TMP 1 480 OFFSET 0 2880 INSIDE OF LAYER CELLB ABSOLUTE) REGION
 err3 NOT INSIDE SealR_NOT_BULK
}

AA_S_5a {
@ Space between NW and N+AA in PW, except INST and DIOMK2 regions >= 0.048um
 err1 = EXT NACT NWRN < 0.048 ABUT<90 REGION  //;exclude NW resistor
 err2 = NACT INTERACT NW SINGULAR ONLY
 err3 = NWRN INSIDE EDGE NAA

 err1 NOT INSIDE INST_DIOMK2
 err2 NOT INSIDE INST_DIOMK2   //; singular interacting
 err3 NOT INSIDE EDGE INST_DIOMK2
}

AA_S_5b {
@ Space between NW and N+AA (AA vertical edge extend 1/2 GT width) in PW in S/D direction, except INST and DIOMK2 regions >= 0.065um
 err1 = EXT NACT_v_edges_ov NWRN < 0.065 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE INST_DIOMK2
}

AA_S_6a {
@ Space between NW and P+ pick-up AA, except INST and DIOMK2 regions >= 0.048um
 err1 = EXT PTAP_RAW NW < 0.048 ABUT<90 REGION
 err2 = PTAP_RAW INTERACT NW SINGULAR ONLY
 err3 = NWRN INSIDE EDGE PAA

 err1 NOT INSIDE INST_DIOMK2
 err2 NOT INSIDE INST_DIOMK2   //; singular interacting
 err3 NOT INSIDE EDGE INST_DIOMK2
}

AA_S_6b {
@ Space between NW and P+ pick-up AA (AA vertical edge extend 1/2 GT width) in S/D direction, except INST and DIOMK2 regions >= 0.065um
 err1 = EXT NW_v_edges edge_gate_AA_ptap < 0.065 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE INST_DIOMK2
}

AA_S_7a {
@ Space between NW and N+AA in I/O area, except DIOMK2 region >= 0.144um
 nact_CHK = (NACT NOT OUTSIDE DG) NOT COIN EDGE (NTAP_RAW INTERACT NTAPi)
 err1 = (EXT nact_CHK NW < 0.144 ABUT<90 REGION MEASURE ALL) NOT OUTSIDE DG
 err1 NOT INSIDE DIOMK2
}

AA_S_7b {
@ Space between NW and N+AA (AA vertical edge extend 1/2 GT width) in I/O area in S/D direction, except DIOMK2 region >= 0.162um
 err1 = EXT NW_v_edges (edge_gate_AA_nact NOT OUTSIDE DG) < 0.162 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE DIOMK2
}

NWRN_chk_edges = LENGTH NWRN >= 0.001
NWRN_convex_corner = INT [NWRN_chk_edges] < 0.002 ABUT==90 INTERSECTING ONLY
pact_convex_corner_aa = INT [PACT] < 0.002 ABUT==90 INTERSECTING ONLY
nact_convex_corner_aa = INT [NACT] < 0.002 ABUT==90 INTERSECTING ONLY

NWRN_concave_corner = EXT [NWRN_chk_edges] < 0.002 ABUT==90 INTERSECTING ONLY
pact_concave_corner_aa = EXT [PACT] < 0.002 ABUT==90 INTERSECTING ONLY
nact_concave_corner_aa = EXT [NACT] < 0.002 ABUT==90 INTERSECTING ONLY

NACT_h_edges = ANGLE NACT == 0
NACT_v_edges = ANGLE NACT == 90
PACT_h_edges = ANGLE PACT == 0
PACT_v_edges = ANGLE PACT == 90

NACT_ov = NACT OR edge_gate_AA_nact
PACT_ov = PACT OR edge_gate_AA_pact

pact_convex_corner_aa_ov = INT [PACT_ov] < 0.002 ABUT==90 INTERSECTING ONLY
nact_convex_corner_aa_ov = INT [NACT_ov] < 0.002 ABUT==90 INTERSECTING ONLY

pact_concave_corner_aa_ov = EXT [PACT_ov] < 0.002 ABUT==90 INTERSECTING ONLY
nact_concave_corner_aa_ov = EXT [NACT_ov] < 0.002 ABUT==90 INTERSECTING ONLY

NACT_h_edges_ov = ANGLE NACT_ov == 0
NACT_v_edges_ov = ANGLE NACT_ov == 90
PACT_h_edges_ov = ANGLE PACT_ov == 0
PACT_v_edges_ov = ANGLE PACT_ov == 90

VARIABLE AA_S_8a_val_ver 0.061
VARIABLE AA_S_8a_val_hor 0.079

AA_S_8a {
@ Space between NW and N+AA (AA vertical edge extend 1/2 GT width) in GATE poly direction, when space in S/D direction < 0.079um at PW corner, except resistor NW and LDBK region >= 0.061um
 y1 = (EXT [NACT_v_edges_ov] NWRN < AA_S_8a_val_hor ABUT<90 OPPOSITE EXTENDED AA_S_8a_val_ver) OR EDGE 
   (EXT [NACT_h_edges_ov] NWRN < AA_S_8a_val_ver ABUT<90 OPPOSITE EXTENDED AA_S_8a_val_hor)
 y2 = (EXT NACT_v_edges_ov [NWRN] < AA_S_8a_val_hor ABUT<90 OPPOSITE EXTENDED AA_S_8a_val_ver) OR EDGE 
   (EXT NACT_h_edges_ov [NWRN] < AA_S_8a_val_ver ABUT<90 OPPOSITE EXTENDED AA_S_8a_val_hor)
 y3 = EXT nact_convex_corner_aa_ov NWRN_concave_corner < AA_S_8a_val_hor ABUT<90 OPPOSITE EXTENDED AA_S_8a_val_hor
 y4 = EXT nact_concave_corner_aa_ov NWRN_convex_corner < AA_S_8a_val_hor ABUT<90 OPPOSITE EXTENDED AA_S_8a_val_hor
 err1_a = INT y1 < 0.001 ABUT==90 INTERSECTING ONLY
 err1_b = EXT y2 < 0.001 ABUT==90 INTERSECTING ONLY
 err2_a = INT y2 < 0.001 ABUT==90 INTERSECTING ONLY
 err2_b = EXT y1 < 0.001 ABUT==90 INTERSECTING ONLY

 err1_c = DFM PROPERTY y3 err1_a err1_b ABUT ALSO OVERLAP MULTI [-= (count(err1_a) > 0 && count(err1_b) > 0) ? 1 : 0] > 0
 err2_c = DFM PROPERTY y4 err2_a err2_b ABUT ALSO OVERLAP MULTI [-= (count(err2_a) > 0 && count(err2_b) > 0) ? 1 : 0] > 0
 err1 = DFM COPY err1_c REGION
 err2 = DFM COPY err2_c REGION
 err1 NOT INSIDE LDBK
 err2 NOT INSIDE LDBK
}

VARIABLE AA_S_8b_val_ver 0.061
VARIABLE AA_S_8b_val_hor 0.079

AA_S_8b {
@ Space between NW and AA (AA vertical edge extend 1/2 GT width) in S/D direction, when space in GATE poly direction < 0.061um at PW corner, except resistor NW and LDBK region >= 0.079um
 y1 = (EXT [NACT_v_edges_ov] NWRN < AA_S_8b_val_hor ABUT<90 OPPOSITE EXTENDED AA_S_8b_val_ver) OR EDGE 
   (EXT [NACT_h_edges_ov] NWRN < AA_S_8b_val_ver ABUT<90 OPPOSITE EXTENDED AA_S_8b_val_hor)
 y2 = (EXT NACT_v_edges_ov [NWRN] < AA_S_8b_val_hor ABUT<90 OPPOSITE EXTENDED AA_S_8b_val_ver) OR EDGE 
   (EXT NACT_h_edges_ov [NWRN] < AA_S_8b_val_ver ABUT<90 OPPOSITE EXTENDED AA_S_8b_val_hor)
 y3 = EXT nact_convex_corner_aa_ov NWRN_concave_corner < AA_S_8b_val_hor ABUT<90 OPPOSITE EXTENDED AA_S_8b_val_hor
 y4 = EXT nact_concave_corner_aa_ov NWRN_convex_corner < AA_S_8b_val_hor ABUT<90 OPPOSITE EXTENDED AA_S_8b_val_hor
 err1_a = INT y1 < 0.001 ABUT==90 INTERSECTING ONLY
 err1_b = EXT y2 < 0.001 ABUT==90 INTERSECTING ONLY
 err2_a = INT y2 < 0.001 ABUT==90 INTERSECTING ONLY
 err2_b = EXT y1 < 0.001 ABUT==90 INTERSECTING ONLY

 err1_c = DFM PROPERTY y3 err1_a err1_b ABUT ALSO OVERLAP MULTI [-= (count(err1_a) > 0 && count(err1_b) > 0) ? 1 : 0] > 0
 err2_c = DFM PROPERTY y4 err2_a err2_b ABUT ALSO OVERLAP MULTI [-= (count(err2_a) > 0 && count(err2_b) > 0) ? 1 : 0] > 0
 err1 = DFM COPY err1_c REGION
 err2 = DFM COPY err2_c REGION
 err1 NOT INSIDE LDBK
 err2 NOT INSIDE LDBK
}

AA_S_9 {
@ Space between NW vertical edge (edge length <= 0.296um between two concave corners with both sides length >= 0.09um) and AA (AA vertical edge extend 1/2 GT width) in S/D direction >= 0.079um
 EDGE_RAW = CONVEX EDGE NW ANGLE1 == 270 LENGTH1 >= 0.09 ANGLE2 == 270 LENGTH2 >= 0.09 WITH LENGTH <= 0.296
 EDGE_CHK = ANGLE EDGE_RAW == 90
 err1 = EXT EDGE_CHK edge_gate_AA_all < 0.079 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

NW_chk_edges = LENGTH NW >= 0.001
NW_convex_corner = INT [NW_chk_edges] < 0.002 ABUT==90 INTERSECTING ONLY
NW_concave_corner = EXT [NW_chk_edges] < 0.002 ABUT==90 INTERSECTING ONLY
NW_v_U_end = ANGLE (CONVEX EDGE NW ANGLE1 == 270 LENGTH1 >= 0.09 ANGLE2 == 270 LENGTH2 >= 0.09 WITH LENGTH < 0.24) == 90
NW_v_N_end = ANGLE (CONVEX EDGE NW ANGLE1 == 90 LENGTH1 >= 0.09 ANGLE2 == 90 LENGTH2 >= 0.09 WITH LENGTH < 0.24) == 90

AA_concave_corner_aa_ov = EXT [edge_gate_AA_all] < 0.002 ABUT==90 INTERSECTING ONLY
AA_convex_corner_aa_ov = INT [edge_gate_AA_all] < 0.002 ABUT==90 INTERSECTING ONLY
AA_v_lend = ANGLE (CONVEX EDGE edge_gate_AA_all ANGLE1 == 90 ANGLE2 == 90 WITH LENGTH <= 0.096) == 90

VARIABLE AA_S_9a_val_ver 0.071
VARIABLE AA_S_9a_val_hor 0.140+GLOBAL_TOLERANCE

AA_S_9a {
@ Space between AA line-end (AA vertical edge extend 1/2 GT width) and NW space-end in GATE poly direction when space in S/D direction <= 0.14um, except INST region. >= 0.071um
@ NW space-end: vertical space < 0.24um between two consecutive 270-270 degree corners with both sides length >= 0.09um
@ AA line-end: vertical width <= 0.096um between two consecutive 90-90 degree corners
 y1 = (EXT [edge_gate_AA_all_v_edges] NW_v_U_end < AA_S_9a_val_hor ABUT<90 OPPOSITE EXTENDED AA_S_9a_val_ver) OR EDGE 
   (EXT [edge_gate_AA_all_h_edges] NW < AA_S_9a_val_ver ABUT<90 OPPOSITE EXTENDED AA_S_9a_val_hor)
 y2 = (EXT edge_gate_AA_all_v_edges [NW_v_U_end] < AA_S_9a_val_hor ABUT<90 OPPOSITE EXTENDED AA_S_9a_val_ver) OR EDGE 
   (EXT edge_gate_AA_all_h_edges [NW] < AA_S_9a_val_ver ABUT<90 OPPOSITE EXTENDED AA_S_9a_val_hor)
 y3 = EXT AA_convex_corner_aa_ov NW_concave_corner < AA_S_9a_val_hor ABUT<90 OPPOSITE EXTENDED AA_S_9a_val_hor
 err1_a = INT y1 < 0.001 ABUT==90 INTERSECTING ONLY
 err1_b = EXT y2 < 0.001 ABUT==90 INTERSECTING ONLY
 err1_c = DFM PROPERTY y3 err1_a err1_b NW_v_U_end AA_v_lend ABUT ALSO OVERLAP MULTI [-= (count(err1_a) > 0 && count(err1_b) > 0 && count(NW_v_U_end) > 0 && count(AA_v_lend) > 0) ? 1 : 0] > 0
 err1 = DFM COPY err1_c REGION
 err1 NOT INSIDE INST
}

VARIABLE AA_S_9b_val_ver 0.061+GLOBAL_TOLERANCE
VARIABLE AA_S_9b_val_hor 0.088

AA_S_9b {
@ Space between AA line-end (AA vertical edge extend 1/2 GT width) and NW space-end in S/D direction when space in GATE poly direction <= 0.061um, except INST region. >= 0.088um
@ NW space-end: vertical space < 0.24um between two consecutive 270-270 degree corners with both sides length >= 0.09um
@ AA line-end: vertical width <= 0.096um between two consecutive 90-90 degree corners
 y1 = (EXT [edge_gate_AA_all_v_edges] NW_v_U_end < AA_S_9b_val_hor ABUT<90 OPPOSITE EXTENDED AA_S_9b_val_ver) OR EDGE 
   (EXT [edge_gate_AA_all_h_edges] NW < AA_S_9b_val_ver ABUT<90 OPPOSITE EXTENDED AA_S_9b_val_hor)
 y2 = (EXT edge_gate_AA_all_v_edges [NW_v_U_end] < AA_S_9b_val_hor ABUT<90 OPPOSITE EXTENDED AA_S_9b_val_ver) OR EDGE 
   (EXT edge_gate_AA_all_h_edges [NW] < AA_S_9b_val_ver ABUT<90 OPPOSITE EXTENDED AA_S_9b_val_hor)
 y3 = EXT AA_convex_corner_aa_ov NW_concave_corner < AA_S_9b_val_hor ABUT<90 OPPOSITE EXTENDED AA_S_9b_val_hor
 err1_a = INT y1 < 0.001 ABUT==90 INTERSECTING ONLY
 err1_b = EXT y2 < 0.001 ABUT==90 INTERSECTING ONLY
 err1_c = DFM PROPERTY y3 err1_a err1_b NW_v_U_end AA_v_lend ABUT ALSO OVERLAP MULTI [-= (count(err1_a) > 0 && count(err1_b) > 0 && count(NW_v_U_end) > 0 && count(AA_v_lend) > 0) ? 1 : 0] > 0
 err1 = DFM COPY err1_c REGION
 err1 NOT INSIDE INST
}

AA_S_10 {
@ Space between ACTIVE AA and pick-up AA in S/D direction, except DSTR and INST regions >= 0.18um
 chk_pick_up = ((TAP_RAW NOT DSTR) NOT COIN EDGE ACT) COIN EDGE AA_v_edges
 err1 = EXT ACT chk_pick_up < 0.180 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE (OR DSTR INST)
}

#IFDEF MINIMUM_DENSITY_CHECK YES
AA_S_13 {
@ Empty ALL_AA space, except RESNW, RESP1, OCOVL, (NODMF su 1um) and LOGO regions <= 2.1um
@ This rule is a local density related rule
@ DRC flags if (((Chip NOT ALL_AA) sd 1.05um) su 1.05um) region greater than 2.1*2.1um
 waive_AREA = OR RESNW RESP1 MARKS OCOVL NODMF_SIZE_1 LOGO
 check_AREA = CHIP_NOT_ALL_AA NOT waive_AREA
 err1 = SIZE check_AREA BY 2.1/2 UNDEROVER
 err1 NOT INSIDE SealR_NOT_BULK
}

AA_S_14 {
@ Empty ALL_AA space in RESNW and RESP1 regions <= 5.1um
@ This rule is a local density related rule
@ DRC flags if (((Chip NOT ALL_AA) sd 2.55um) su 2.55um) region greater than 5.1*5.1um
 chk_real = OR RESNW RESP1
 chk_area = CHIP_NOT_ALL_AA NOT MARKS
 err1 = (SIZE chk_area BY 5.1/2 UNDEROVER) NOT OUTSIDE chk_real
 err1 NOT INSIDE SealR_NOT_BULK
}
#ENDIF

AA_S_15 {
@ Space between NPAA and AA (overlap is not allowed)
@ (NPAA in chip is not allowed, this rule only for SMIC internal test structure usage) >= 0.5um
 err1 = EXT NPAA AA < 0.5 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

AA_convex_L1_048_L2_048_270_270_edges = CONVEX EDGE AA ANGLE1 == 270 LENGTH1 == 0.048 ANGLE2 == 270 LENGTH2 == 0.048
AA_convex_L1_048_L2_096_270_270_edges = CONVEX EDGE AA ANGLE1 == 270 LENGTH1 == 0.048 ANGLE2 == 270 LENGTH2 == 0.096
AA_convex_L1_048_L2_144_270_270_edges = CONVEX EDGE AA ANGLE1 == 270 LENGTH1 == 0.048 ANGLE2 == 270 LENGTH2 == 0.144

AA_convex_L1_096_L2_096_270_270_edges = CONVEX EDGE AA ANGLE1 == 270 LENGTH1 == 0.096 ANGLE2 == 270 LENGTH2 == 0.096
AA_convex_L1_096_L2_144_270_270_edges = CONVEX EDGE AA ANGLE1 == 270 LENGTH1 == 0.096 ANGLE2 == 270 LENGTH2 == 0.144
AA_convex_L1_144_L2_144_270_270_edges = CONVEX EDGE AA ANGLE1 == 270 LENGTH1 == 0.144 ANGLE2 == 270 LENGTH2 == 0.144

//;-----------------------------------------------------------------------------------------------------------------------------
AA_048_to_ALL_AA_extend_090_space_eq_096_AA_048_h_edges = EXT [AA_048_h_edges] ALL_AA == 0.096 ABUT<90 OPPOSITE EXTENDED 0.09
AA_048_to_ALL_AA_extend_090_space_eq_192_AA_048_h_edges = EXT [AA_048_h_edges] ALL_AA == 0.192 ABUT<90 OPPOSITE EXTENDED 0.09

AA_048_to_ALL_AA_extend_090_space_lt_192_AA_048_h_edges = EXT [AA_048_h_edges] ALL_AA < 0.192 ABUT<90 OPPOSITE EXTENDED 0.09
AA_048_to_ALL_AA_extend_090_space_lt_240_AA_048_h_edges = EXT [AA_048_h_edges] ALL_AA < 0.240 ABUT<90 OPPOSITE EXTENDED 0.09
AA_048_to_ALL_AA_extend_090_space_lt_192_not_AA_048_h_edges = EXT (AA_048_h_edges) ALL_AA < 0.192 ABUT<90 OPPOSITE EXTENDED 0.09
AA_048_to_ALL_AA_extend_090_space_lt_240_not_AA_048_h_edges = EXT (AA_048_h_edges) ALL_AA < 0.240 ABUT<90 OPPOSITE EXTENDED 0.09

AA_048_v_region = INT AA_h_edges == 0.048 ABUT<90 OPPOSITE REGION
AA_convex_90_270_OR_270_270_edges = AA_convex_90_270_edge OR EDGE AA_convex_270_270_edge
//;-----------------------------------------------------------------------------------------------------------------------------

AA_S_16 {
@ Space between AA vertical edge (edge length <= 0.144um between two consecutive 270-90 degree corners) when 0 < PRL <= 0.048um. >= 0.18um
 err1_e = ANGLE (LENGTH AA_convex_90_270_edge <= 0.144) == 90
 err1_s = EXT err1_e < 0.18 ABUT<90 OPPOSITE
 err1_TMP = DFM PROPERTY err1_s [-= EC(err1_s)] > 0 <= 0.048
 err1 = DFM COPY err1_TMP REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

AA_S_17 {
@ Forbidden space between ALL_AA (width = 0.096um) at both side and ALL_AA in GATE poly direction = 0.144um
 err1_e = ANGLE ALL_AA_096 == 0
 err1_s = EXT [err1_e] ALL_AA == 0.144 ABUT<90 OPPOSITE
 err1 = INT (err1_e COIN EDGE err1_s) == 0.096 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

/*
AA_S_18 {
@ Forbidden space between (ALL_AA sizing over-under 0.048um in S/D direction) in GATE poly direction when both two adjacent space = 0.144um, and PRL of the forbidden space > 0.096 < 0.27. = 0.192um
 AA_EXP_MERGED = SHRINK (GROW AA LEFT BY 0.048 RIGHT BY 0.048) LEFT BY 0.048 RIGHT BY 0.048
 AA_EXP_FORBIDDEN_SPACE_TEMP_A = EXT (ANGLE AA_EXP_MERGED == 0) == 0.192 ABUT<90 OPPOSITE REGION
 AA_EXP_FORBIDDEN_SPACE_TEMP_H = ANGLE AA_EXP_FORBIDDEN_SPACE_TEMP_A == 0
 AA_EXP_FORBIDDEN_SPACE_TEMP = DFM PROPERTY AA_EXP_FORBIDDEN_SPACE_TEMP_A AA_EXP_FORBIDDEN_SPACE_TEMP_H OVERLAP ABUT ALSO MULTI [-= LENGTH(AA_EXP_FORBIDDEN_SPACE_TEMP_H)/2] > 0.096 < 0.27
 AA_EXP_ADJACENT_SPACE_TEMP = EXT (ANGLE AA_EXP_MERGED == 0) == 0.144 ABUT<90 OPPOSITE REGION

 err1 = AA_EXP_FORBIDDEN_SPACE_TEMP TOUCH AA_EXP_ADJACENT_SPACE_TEMP == 2
 err1 NOT INSIDE SealR_NOT_BULK
}
*/

/*
AA_S_18 {
@ Space between two AA convex corners on vertical edges between 90-270 corners (after AA sizing over-under 0.048um in S/D direction, edge length <= 0.144um) when -0.144 <= PRL <= -0.096. >= 0.27um
 AA_EXP_MERGED = SHRINK (GROW AA LEFT BY 0.048 RIGHT BY 0.048) LEFT BY 0.048 RIGHT BY 0.048
 AA_EXP_MERGED_CHK1 = ANGLE (CONVEX EDGE AA_EXP_MERGED ANGLE1==90 ANGLE2==270 WITH LENGTH <= 0.144) == 90
 AA_EXP_MERGED_CHK2 = ANGLE (CONVEX EDGE AA_EXP_MERGED ANGLE1==90 ANGLE2==270) == 90
 AA_EXP_MERGED_NOCHK1 = ANGLE (CONVEX EDGE AA_EXP_MERGED ANGLE1==90 ANGLE2==270 WITH LENGTH > 0.144) == 90
 AA_EXP_MERGED_NOCHK2 = ANGLE (CONVEX EDGE AA_EXP_MERGED ANGLE1==90 ANGLE2==90) == 90
 AA_EXP_MERGED_CORNER_ERROR = EXT AA_EXP_MERGED_CHK1 AA_EXP_MERGED_CHK2 < 0.27 OPPOSITE EXTENDED 0.144+GLOBAL_TOLERANCE NOT PROJ EXCLUDE SHIELDED
 err1_TMP = DFM COPY (DFM PROPERTY AA_EXP_MERGED_CORNER_ERROR AA_EXP_MERGED_NOCHK1 AA_EXP_MERGED_NOCHK2 OVERLAP ABUT ALSO MULTI 
  [-= (EWXP(AA_EXP_MERGED_CORNER_ERROR) < 0.27 && EWYP(AA_EXP_MERGED_CORNER_ERROR) >= 0.096 && COUNT(AA_EXP_MERGED_NOCHK1) == 0 && COUNT(AA_EXP_MERGED_NOCHK2) == 0) ? 1 : 0] > 0) REGION
 err1 = err1_TMP NOT INTERACT (err1_TMP AND AA_EXP_MERGED)
 err1 NOT INSIDE SealR_NOT_BULK
}
*/

AA_S_19 {
@ Forbidden space between (ALL_AA vertical edge expand 0.089um) in GATE poly direction when both two adjacent space = 0.096um, and the space between two 0.096um space region is 0.048um in GATE poly direction = 0.24um
 AA_EXP_HOR = EXPAND EDGE ALL_AA_v_edges OUTSIDE BY 0.089
 AA_EXP_ALL = (AA_EXP_HOR OR ALL_AA) INTERACT AA_EXP_HOR
 AA_EXP_ALL_h_edges = ANGLE AA_EXP_ALL == 0
 ADJACENT_SPACE_096 = EXT AA_EXP_ALL_h_edges == 0.096 ABUT<90 OPPOSITE REGION

 FORBIDDEN_SPACE_240_RAW = EXT AA_EXP_ALL_h_edges == 0.240 ABUT<90 OPPOSITE REGION EXCLUDE SHIELDED
 FORBIDDEN_SPACE_240_TMP = FORBIDDEN_SPACE_240_RAW TOUCH ADJACENT_SPACE_096 == 2
 FORBIDDEN_SPACE_240_TMP_SIDES_COIN = FORBIDDEN_SPACE_240_TMP COIN OUTSIDE EDGE ADJACENT_SPACE_096
 FORBIDDEN_SPACE_240_TMP_SIDES_ANTI = (FORBIDDEN_SPACE_240_TMP TOUCH EDGE FORBIDDEN_SPACE_240_TMP_SIDES_COIN) NOT COIN EDGE ADJACENT_SPACE_096
 FORBIDDEN_SPACE_240_TMP_FILTER = FORBIDDEN_SPACE_240_TMP WITH EDGE FORBIDDEN_SPACE_240_TMP_SIDES_ANTI == 2
 FORBIDDEN_SPACE_240_TMP_SIDES_TOP = (GROW FORBIDDEN_SPACE_240_TMP_FILTER TOP BY 0.0005) NOT FORBIDDEN_SPACE_240_TMP_FILTER
 FORBIDDEN_SPACE_240_TMP_SIDES_BOTTOM = (GROW FORBIDDEN_SPACE_240_TMP_FILTER BOTTOM BY 0.0005) NOT FORBIDDEN_SPACE_240_TMP_FILTER

 FORBIDDEN_SPACE_240_TMP_SIDES_ANTI_LEGS = EXPAND EDGE FORBIDDEN_SPACE_240_TMP_SIDES_ANTI INSIDE BY 0.0001
 FORBIDDEN_SPACE_240_TMP_SIDES_ANTI_TOP = FORBIDDEN_SPACE_240_TMP_SIDES_ANTI_LEGS INTERACT FORBIDDEN_SPACE_240_TMP_SIDES_TOP
 FORBIDDEN_SPACE_240_TMP_SIDES_ANTI_BOTTOM = FORBIDDEN_SPACE_240_TMP_SIDES_ANTI_LEGS INTERACT FORBIDDEN_SPACE_240_TMP_SIDES_BOTTOM
 err1 = ((FORBIDDEN_SPACE_240_TMP_FILTER INTERACT FORBIDDEN_SPACE_240_TMP_SIDES_ANTI_LEGS == 2) INTERACT FORBIDDEN_SPACE_240_TMP_SIDES_ANTI_TOP) INTERACT FORBIDDEN_SPACE_240_TMP_SIDES_ANTI_BOTTOM
 err1 NOT INSIDE SealR_NOT_BULK
}

AA_EN_1a {
@ P+AA enclosure by NW, except INST and DIOMK2 regions >= 0.048um
 err1 = ENC (PAA AND NW) NW < 0.048 ABUT<90 REGION
 err1 NOT INSIDE INST_DIOMK2
}

AA_EN_1b {
@ N+ pick-up AA enclosure by NW, except INST and DIOMK2 regions >= 0.048um
 err1 = ENC (NAA AND NW) NWRN < 0.048 ABUT<90 REGION  //;exclude RESNW, NW straddle on NACT/NTAP in NW resistor
 err1 NOT INSIDE INST_DIOMK2
}

AA_EN_1c {
@ P+AA (AA vertical edge extend 1/2 GT width) enclosure by NW in S/D direction, except INST and DIOMK2 regions >= 0.065um
 err1 = ENC (edge_gate_AA_pact AND NW) NW_v_edges < 0.065 ABUT<90 OPPOSITE REGION EXCLUDE SHIELDED
 err1 NOT INSIDE INST_DIOMK2
}

AA_EN_1d {
@ N+ pick-up AA (AA vertical edge extend 1/2 GT width) enclosure by NW in S/D direction, except INST and DIOMK2 regions >= 0.065um
 err1 = ENC (edge_gate_AA_ntap AND NW) (ANGLE NWRN > 88 <= 90) < 0.065 ABUT<90 OPPOSITE REGION  //;exclude RESNW, NW straddle on NACT/NTAP in NW resistor
 err1 NOT INSIDE INST_DIOMK2
}

AA_EN_1f {
@ P+AA enclosure by NW in I/O region, except DIOMK2 region >= 0.144um
 chk_pact = (PACT NOT OUTSIDE DG) NOT COIN EDGE PTAP_RAW
 err1 = (ENC chk_pact NW < 0.144 ABUT<90 REGION) NOT OUTSIDE DG
 err1 NOT INSIDE DIOMK2
}

AA_EN_1g {
@ P+AA (AA vertical edge extend 1/2 GT width) enclosure by NW in I/O region in S/D direction, except DIOMK2 region >= 0.162um
 err1 = ENC (edge_gate_AA_pact NOT OUTSIDE DG) NW_v_edges < 0.162 ABUT<90 OPPOSITE REGION EXCLUDE SHIELDED
 err1 NOT INSIDE DIOMK2
}

AA_EN_2 {
@ The outmost FIN enclosure by ALL_AA in GATE poly direction, except LDBK, DMCMK1, INST and MARKS regions = 0.019um
 WAIVE_AREA = OR INST_LDBK DMCMK1 MARKS
 chk_EDGE = ANGLE ((EXPAND EDGE ALL_AA_h_edges INSIDE BY 0.019) NOT COIN EDGE ALL_AA) == 0
 err1 = chk_EDGE NOT COIN EDGE FIN
 err1 NOT INSIDE EDGE WAIVE_AREA

 err2 = ALL_AA_h_edges NOT OUTSIDE EDGE FIN
 err2 NOT INSIDE EDGE WAIVE_AREA
}

VARIABLE AA_EN_2a_val_ver 0.061
VARIABLE AA_EN_2a_val_hor 0.079

AA_EN_2a {
@ P+AA (AA vertical edge extend 1/2 GT width) enclosure by NW corner in GATE poly direction when enclosure in S/D direction < 0.079um. >= 0.061um
 y1 = (ENC [PACT_v_edges_ov] NWRN < AA_EN_2a_val_hor ABUT<90 OPPOSITE EXTENDED AA_EN_2a_val_ver) OR EDGE 
   (ENC [PACT_h_edges_ov] NWRN < AA_EN_2a_val_ver ABUT<90 OPPOSITE EXTENDED AA_EN_2a_val_hor)
 y2 = (ENC PACT_v_edges_ov [NWRN] < AA_EN_2a_val_hor ABUT<90 OPPOSITE EXTENDED AA_EN_2a_val_ver) OR EDGE 
   (ENC PACT_h_edges_ov [NWRN] < AA_EN_2a_val_ver ABUT<90 OPPOSITE EXTENDED AA_EN_2a_val_hor)
 y3 = ENC pact_convex_corner_aa_ov NWRN_convex_corner < AA_EN_2a_val_hor ABUT<90 OPPOSITE EXTENDED AA_EN_2a_val_hor
 y4 = ENC pact_concave_corner_aa_ov NWRN_concave_corner < AA_EN_2a_val_hor ABUT<90 OPPOSITE EXTENDED AA_EN_2a_val_hor
 err1_a = INT y1 < 0.001 ABUT==90 INTERSECTING ONLY
 err1_b = INT y2 < 0.001 ABUT==90 INTERSECTING ONLY
 err2_a = EXT y1 < 0.001 ABUT==90 INTERSECTING ONLY
 err2_b = EXT y2 < 0.001 ABUT==90 INTERSECTING ONLY

 err1_c = DFM PROPERTY y3 err1_a err1_b ABUT ALSO OVERLAP MULTI [-= (count(err1_a) > 0 && count(err1_b) > 0) ? 1 : 0] > 0
 err2_c = DFM PROPERTY y4 err2_a err2_b ABUT ALSO OVERLAP MULTI [-= (count(err2_a) > 0 && count(err2_b) > 0) ? 1 : 0] > 0
 err1 = DFM COPY err1_c REGION
 err2 = DFM COPY err2_c REGION
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

VARIABLE AA_EN_2b_val_ver 0.061
VARIABLE AA_EN_2b_val_hor 0.079

AA_EN_2b {
@ P+AA (AA vertical edge extend 1/2 GT width) enclosure by NW corner in S/D direction when enclosure in GATE poly direction < 0.061um. >= 0.079um
 y1 = (ENC [PACT_v_edges_ov] NWRN < AA_EN_2b_val_hor ABUT<90 OPPOSITE EXTENDED AA_EN_2a_val_ver) OR EDGE 
   (ENC [PACT_h_edges_ov] NWRN < AA_EN_2a_val_ver ABUT<90 OPPOSITE EXTENDED AA_EN_2b_val_hor)
 y2 = (ENC PACT_v_edges_ov [NWRN] < AA_EN_2b_val_hor ABUT<90 OPPOSITE EXTENDED AA_EN_2a_val_ver) OR EDGE 
   (ENC PACT_h_edges_ov [NWRN] < AA_EN_2a_val_ver ABUT<90 OPPOSITE EXTENDED AA_EN_2b_val_hor)
 y3 = ENC pact_convex_corner_aa_ov NWRN_convex_corner < AA_EN_2b_val_hor ABUT<90 OPPOSITE EXTENDED AA_EN_2b_val_hor
 y4 = ENC pact_concave_corner_aa_ov NWRN_concave_corner < AA_EN_2b_val_hor ABUT<90 OPPOSITE EXTENDED AA_EN_2b_val_hor
 err1_a = INT y1 < 0.001 ABUT==90 INTERSECTING ONLY
 err1_b = INT y2 < 0.001 ABUT==90 INTERSECTING ONLY
 err2_a = EXT y1 < 0.001 ABUT==90 INTERSECTING ONLY
 err2_b = EXT y2 < 0.001 ABUT==90 INTERSECTING ONLY

 err1_c = DFM PROPERTY y3 err1_a err1_b ABUT ALSO OVERLAP MULTI [-= (count(err1_a) > 0 && count(err1_b) > 0) ? 1 : 0] > 0
 err2_c = DFM PROPERTY y4 err2_a err2_b ABUT ALSO OVERLAP MULTI [-= (count(err2_a) > 0 && count(err2_b) > 0) ? 1 : 0] > 0
 err1 = DFM COPY err1_c REGION
 err2 = DFM COPY err2_c REGION
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

AA_EN_2c {
@ AA (AA vertical edge extend 1/2 GT width) enclosure by NW line-end in S/D direction (line-end vertical width <= 0.296um between two consecutive 90-90 degree corners with both sides length >= 0.09um) >= 0.079um
 chk_nw = CONVEX EDGE NW ANGLE1 == 90 LENGTH1 >= 0.09 ANGLE2 == 90 LENGTH2 >= 0.09 WITH LENGTH <= 0.296
 err1 = ENC edge_gate_AA_all_v_edges chk_nw < 0.079 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

VARIABLE AA_EN_2d_val_ver 0.071
VARIABLE AA_EN_2d_val_hor 0.140+GLOBAL_TOLERANCE

AA_EN_2d {
@ AA line-end (AA vertical edge extend 1/2 GT width) enclosure by NW line-end in GATE poly direction when enclosure in S/D direction <= 0.14um, except INST region. >= 0.071um
@ NW line-end: vertical width < 0.24um between two consecutive 90-90 degree corners with both sides length >= 0.09um
@ AA line-end: vertical width <= 0.096um between two consecutive 90-90 degree corners
 y1 = (ENC [edge_gate_AA_all_v_edges] NW_v_N_end < AA_EN_2d_val_hor ABUT<90 OPPOSITE EXTENDED AA_EN_2d_val_ver) OR EDGE 
   (ENC [edge_gate_AA_all_h_edges] NW < AA_EN_2d_val_ver ABUT<90 OPPOSITE EXTENDED AA_EN_2d_val_hor)
 y2 = (ENC edge_gate_AA_all_v_edges [NW_v_N_end] < AA_EN_2d_val_hor ABUT<90 OPPOSITE EXTENDED AA_EN_2d_val_ver) OR EDGE 
   (ENC edge_gate_AA_all_h_edges [NW] < AA_EN_2d_val_ver ABUT<90 OPPOSITE EXTENDED AA_EN_2d_val_hor)
 y3 = ENC AA_convex_corner_aa_ov NW_convex_corner < AA_EN_2d_val_hor ABUT<90 OPPOSITE EXTENDED AA_EN_2d_val_hor
 err1_a = INT y1 < 0.001 ABUT==90 INTERSECTING ONLY
 err1_b = INT y2 < 0.001 ABUT==90 INTERSECTING ONLY
 err1_c = DFM PROPERTY y3 err1_a err1_b NW_v_N_end AA_v_lend ABUT ALSO OVERLAP MULTI [-= (count(err1_a) > 0 && count(err1_b) > 0 && count(NW_v_N_end) > 0 && count(AA_v_lend) > 0) ? 1 : 0] > 0
 err1 = DFM COPY err1_c REGION
 err1 NOT INSIDE INST
}

VARIABLE AA_EN_2e_val_ver 0.061+GLOBAL_TOLERANCE
VARIABLE AA_EN_2e_val_hor 0.088

AA_EN_2e {
@ AA line-end (AA vertical edge extend 1/2 GT width) enclosure by NW line-end in S/D direction when enclosure in GATE poly direction <= 0.061um, except INST region. >= 0.088um
@ NW line-end: vertical width < 0.24um between two consecutive 90-90 degree corners with both sides length >= 0.09um
@ AA line-end: vertical width <= 0.096um between two consecutive 90-90 degree corners
 y1 = (ENC [edge_gate_AA_all_v_edges] NW_v_N_end < AA_EN_2e_val_hor ABUT<90 OPPOSITE EXTENDED AA_EN_2e_val_ver) OR EDGE 
   (ENC [edge_gate_AA_all_h_edges] NW < AA_EN_2e_val_ver ABUT<90 OPPOSITE EXTENDED AA_EN_2e_val_hor)
 y2 = (ENC edge_gate_AA_all_v_edges [NW_v_N_end] < AA_EN_2e_val_hor ABUT<90 OPPOSITE EXTENDED AA_EN_2e_val_ver) OR EDGE 
   (ENC edge_gate_AA_all_h_edges [NW] < AA_EN_2e_val_ver ABUT<90 OPPOSITE EXTENDED AA_EN_2e_val_hor)
 y3 = ENC AA_convex_corner_aa_ov NW_convex_corner < AA_EN_2e_val_hor ABUT<90 OPPOSITE EXTENDED AA_EN_2e_val_hor
 err1_a = INT y1 < 0.001 ABUT==90 INTERSECTING ONLY
 err1_b = INT y2 < 0.001 ABUT==90 INTERSECTING ONLY
 err1_c = DFM PROPERTY y3 err1_a err1_b NW_v_N_end AA_v_lend ABUT ALSO OVERLAP MULTI [-= (count(err1_a) > 0 && count(err1_b) > 0 && count(NW_v_N_end) > 0 && count(AA_v_lend) > 0) ? 1 : 0] > 0
 err1 = DFM COPY err1_c REGION
 err1 NOT INSIDE INST
}

#IFDEF Delta_Voltage_Rules_Check YES
VARIABLE AA_EN_3a_val 0.144
VARIABLE AA_EN_3b_val 0.162

AA_EN_3a {
@ NW enclosure of P+ ACTIVE (Maximum delta V > 3.63V, 3.3V+10%) >= 0.144um
 err1 = DFM DV PSD PW_0 < AA_EN_3a_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 3.63 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err1
}

AA_EN_3b {
@ NW enclosure of P+ ACTIVE (AA vertical edge extend 1/2 GT width) in S/D direction (Maximum delta V > 3.63V, 3.3V+10%) >= 0.162um
 PSD_c_all = AA_c_all TOUCH EDGE (ANGLE (AA_c_all INTERACT PSD) == 90)
 err1 = DFM DV PSD_c_all PW_0 < AA_EN_3b_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 3.63 ANNOTATE NOT CONNECTED OPPOSITE MEASURE ALL
 DFM COPY err1
}
#ENDIF

AA_A_1 {
@ AOP_AA area, except INST region >= 0.0138um2
 err1 = AREA AOP_AA < 0.0138
 err1 NOT INSIDE INST
}

AA_A_2 {
@ AOP_AA area in I/O region, except DMC7 region >= 0.0285um2
 err1 = AREA (AOP_AA NOT OUTSIDE DG) < 0.0285
 err1 NOT INSIDE DMC7
}

AA_A_3 {
@ AOP_AA area (length = 0.09um in S/D direction) >= 0.0172um2
 err1 = AREA (AOP_AA WITH EDGE (LENGTH AOP_AA_h_edges == 0.09)) < 0.0172
 err1 NOT INSIDE SealR_NOT_BULK
}

AA_A_4 {
@ Total area of ((ACTIVE INTERACT GT) NOT GT) in the same AA for NMOS or PMOS device <= 100um2
 AA_SUM = (ACT INTERACT GT) NOT GT
 err1 = DFM PROPERTY (AA INTERACT AA_SUM) AA_SUM OVERLAP ABUT ALSO MULTI [-= AREA(AA_SUM)] > 100
 err1 NOT INSIDE SealR_NOT_BULK
}

#IFDEF IP_LEVEL_DENSITY_CHECK YES
#IFDEF MINIMUM_DENSITY_CHECK YES
AA_D_1 {
@ Full chip ALL_AA density >= 25%
 DENSITY ALL_AA_NOT_MARKS CHIP_NOT_MARKS [AREA(ALL_AA_NOT_MARKS)/AREA(CHIP_NOT_MARKS)] < 0.25 PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_AA_D_1.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_AA_D_1.rdb"
}
#ENDIF

AA_D_2 {
@ Full chip ALL_AA density <= 60%
 DENSITY ALL_AA_NOT_MARKS CHIP_NOT_MARKS [AREA(ALL_AA_NOT_MARKS)/AREA(CHIP_NOT_MARKS)] > 0.60 PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_AA_D_2.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_AA_D_2.rdb"
}

#IFDEF MINIMUM_DENSITY_CHECK YES
VARIABLE AA_D_3_val 12.4
VARIABLE AA_D_3_window 18

AA_D_3 {
@ ALL_AA density (window 18um*18um, stepping 18um/step_number), except LOGO, OCOVL, (NODMF su 1um) region >= 12.4%
 check_region = DRC:1 NOT (OR MARKS_LOGO OCOVL NODMF_SIZE_1)
 check_pattern = ALL_AA AND check_region

 check_window1 = check_region WITH WIDTH >= AA_D_3_window/4
 err1_TMP1 = DENSITY check_pattern check_window1 check_region [!AREA(check_window1) + !!AREA(check_window1)*AREA(check_pattern)/AREA(check_region)] < AA_D_3_val/100 WINDOW AA_D_3_window STEP AA_D_3_window/step_number BACKUP INSIDE OF LAYER DRC:1 BY POLYGON

 check_window2 = WITH WIDTH (check_region AND err1_TMP1) >= AA_D_3_window/4
 err1_TMP2 = DENSITY check_pattern check_window2 check_region [!AREA(check_window2) + !!AREA(check_window2)*AREA(check_pattern)/AREA(check_region)] < AA_D_3_val/100 WINDOW AA_D_3_window STEP AA_D_3_window/step_number BACKUP INSIDE OF LAYER err1_TMP1 BY POLYGON

 check_window3 = WITH WIDTH (check_region AND err1_TMP2) >= AA_D_3_window/4
 DENSITY check_pattern check_window3 check_region [!AREA(check_window3) + !!AREA(check_window3)*AREA(check_pattern)/AREA(check_region)] < AA_D_3_val/100 WINDOW AA_D_3_window STEP AA_D_3_window/step_number BACKUP INSIDE OF LAYER err1_TMP2 BY POLYGON PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_AA_D_3.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_AA_D_3.rdb"
}

AA_D_4 {
@ ALL_AA density in ((RESP1 su 10um) NOT RESP1) >= 20%
 check_region = (SIZE RESP1 BY 10) NOT RESP1
 check_pattern = ALL_AA AND check_region
 err1 = DFM PROPERTY check_region check_pattern OVERLAP [-= AREA(check_pattern)/AREA(check_region)] < 0.20

 DFM RDB err1 "./SMIC_14SFPLUS_DRC_logFile/density_report_AA_D_4.rdb"
 COPY err1
}
#ENDIF

VARIABLE AA_D_5_val 66.5
VARIABLE AA_D_5_window 100

AA_D_5 {
@ Maximum ALL_AA density in core region (window 100um*100um, stepping 100um/step_number) <= 66.5%
 check_region = CHIP_NOT_MARKS NOT DG
 check_pattern = ALL_AA AND check_region

 check_window1 = check_region WITH WIDTH >= AA_D_5_window/4
 err1_TMP1 = DENSITY check_pattern check_window1 check_region [!!AREA(check_window1)*AREA(check_pattern)/AREA(check_region)] > AA_D_5_val/100 WINDOW AA_D_5_window STEP AA_D_5_window/step_number BACKUP INSIDE OF LAYER DRC:1 BY POLYGON

 check_window2 = WITH WIDTH (check_region AND err1_TMP1) >= AA_D_5_window/4
 err1_TMP2 = DENSITY check_pattern check_window2 check_region [!!AREA(check_window2)*AREA(check_pattern)/AREA(check_region)] > AA_D_5_val/100 WINDOW AA_D_5_window STEP AA_D_5_window/step_number BACKUP INSIDE OF LAYER err1_TMP1 BY POLYGON

 check_window3 = WITH WIDTH (check_region AND err1_TMP2) >= AA_D_5_window/4
 DENSITY check_pattern check_window3 check_region [!!AREA(check_window3)*AREA(check_pattern)/AREA(check_region)] > AA_D_5_val/100 WINDOW AA_D_5_window STEP AA_D_5_window/step_number BACKUP INSIDE OF LAYER err1_TMP2 BY POLYGON PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_AA_D_5.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_AA_D_5.rdb"
}

VARIABLE AA_D_6_val 76
VARIABLE AA_D_6_window 100

AA_D_6 {
@ Maximum ALL_AA density in I/O region (window 100um*100um, stepping 100um/step_number) <= 76%
 check_region = DG NOT MARKS
 check_pattern = ALL_AA AND check_region

 check_window1 = check_region WITH WIDTH >= AA_D_6_window/4
 err1_TMP1 = DENSITY check_pattern check_window1 check_region [!!AREA(check_window1)*AREA(check_pattern)/AREA(check_region)] > AA_D_6_val/100 WINDOW AA_D_6_window STEP AA_D_6_window/step_number BACKUP INSIDE OF LAYER DRC:1 BY POLYGON

 check_window2 = WITH WIDTH (check_region AND err1_TMP1) >= AA_D_6_window/4
 err1_TMP2 = DENSITY check_pattern check_window2 check_region [!!AREA(check_window2)*AREA(check_pattern)/AREA(check_region)] > AA_D_6_val/100 WINDOW AA_D_6_window STEP AA_D_6_window/step_number BACKUP INSIDE OF LAYER err1_TMP1 BY POLYGON

 check_window3 = WITH WIDTH (check_region AND err1_TMP2) >= AA_D_6_window/4
 DENSITY check_pattern check_window3 check_region [!!AREA(check_window3)*AREA(check_pattern)/AREA(check_region)] > AA_D_6_val/100 WINDOW AA_D_6_window STEP AA_D_6_window/step_number BACKUP INSIDE OF LAYER err1_TMP2 BY POLYGON PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_AA_D_6.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_AA_D_6.rdb"
}
#ELSE

#IFDEF MINIMUM_DENSITY_CHECK YES
AA_D_1 {
@ Full chip ALL_AA density >= 25%
 DENSITY ALL_AA_NOT_MARKS CHIP_NOT_MARKS [AREA(ALL_AA_NOT_MARKS)/AREA(CHIP_NOT_MARKS)] < 0.25 PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_AA_D_1.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_AA_D_1.rdb"
}
#ENDIF

AA_D_2 {
@ Full chip ALL_AA density <= 60%
 DENSITY ALL_AA_NOT_MARKS CHIP_NOT_MARKS [AREA(ALL_AA_NOT_MARKS)/AREA(CHIP_NOT_MARKS)] > 0.60 PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_AA_D_2.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_AA_D_2.rdb"
}

#IFDEF MINIMUM_DENSITY_CHECK YES
VARIABLE AA_D_3_val 11.8
VARIABLE AA_D_3_window 18

AA_D_3 {
@ ALL_AA density (window 18um*18um, stepping 9um), except LOGO, OCOVL, (NODMF su 1um) region >= 11.8%
 check_region = DRC:1 NOT (OR MARKS_LOGO OCOVL NODMF_SIZE_1)
 check_pattern = ALL_AA AND check_region

 check_window1 = check_region WITH WIDTH >= AA_D_3_window/4
 err1_TMP1 = DENSITY check_pattern check_window1 check_region [!AREA(check_window1) + !!AREA(check_window1)*AREA(check_pattern)/AREA(check_region)] < AA_D_3_val/100 WINDOW AA_D_3_window STEP AA_D_3_window/2 BACKUP INSIDE OF LAYER DRC:1 BY POLYGON

 check_window2 = WITH WIDTH (check_region AND err1_TMP1) >= AA_D_3_window/4
 err1_TMP2 = DENSITY check_pattern check_window2 check_region [!AREA(check_window2) + !!AREA(check_window2)*AREA(check_pattern)/AREA(check_region)] < AA_D_3_val/100 WINDOW AA_D_3_window STEP AA_D_3_window/2 BACKUP INSIDE OF LAYER err1_TMP1 BY POLYGON

 check_window3 = WITH WIDTH (check_region AND err1_TMP2) >= AA_D_3_window/4
 DENSITY check_pattern check_window3 check_region [!AREA(check_window3) + !!AREA(check_window3)*AREA(check_pattern)/AREA(check_region)] < AA_D_3_val/100 WINDOW AA_D_3_window STEP AA_D_3_window/2 BACKUP INSIDE OF LAYER err1_TMP2 BY POLYGON PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_AA_D_3.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_AA_D_3.rdb"
}

AA_D_4 {
@ ALL_AA density in ((RESP1 su 10um) NOT RESP1) >= 20%
 check_region = (SIZE RESP1 BY 10) NOT RESP1
 check_pattern = ALL_AA AND check_region
 err1 = DFM PROPERTY check_region check_pattern OVERLAP [-= AREA(check_pattern)/AREA(check_region)] < 0.20

 DFM RDB err1 "./SMIC_14SFPLUS_DRC_logFile/density_report_AA_D_4.rdb"
 COPY err1
}
#ENDIF

VARIABLE AA_D_5_val 70
VARIABLE AA_D_5_window 100

AA_D_5 {
@ Maximum ALL_AA density in core region (window 100um*100um, stepping 50um) <= 70%
 check_region = CHIP_NOT_MARKS NOT DG
 check_pattern = ALL_AA AND check_region

 check_window1 = check_region WITH WIDTH >= AA_D_5_window/4
 err1_TMP1 = DENSITY check_pattern check_window1 check_region [!!AREA(check_window1)*AREA(check_pattern)/AREA(check_region)] > AA_D_5_val/100 WINDOW AA_D_5_window STEP AA_D_5_window/2 BACKUP INSIDE OF LAYER DRC:1 BY POLYGON

 check_window2 = WITH WIDTH (check_region AND err1_TMP1) >= AA_D_5_window/4
 err1_TMP2 = DENSITY check_pattern check_window2 check_region [!!AREA(check_window2)*AREA(check_pattern)/AREA(check_region)] > AA_D_5_val/100 WINDOW AA_D_5_window STEP AA_D_5_window/2 BACKUP INSIDE OF LAYER err1_TMP1 BY POLYGON

 check_window3 = WITH WIDTH (check_region AND err1_TMP2) >= AA_D_5_window/4
 DENSITY check_pattern check_window3 check_region [!!AREA(check_window3)*AREA(check_pattern)/AREA(check_region)] > AA_D_5_val/100 WINDOW AA_D_5_window STEP AA_D_5_window/2 BACKUP INSIDE OF LAYER err1_TMP2 BY POLYGON PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_AA_D_5.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_AA_D_5.rdb"
}

VARIABLE AA_D_6_val 80
VARIABLE AA_D_6_window 100

AA_D_6 {
@ Maximum ALL_AA density in I/O region (window 100um*100um, stepping 50um) <= 80%
 check_region = DG NOT MARKS
 check_pattern = ALL_AA AND check_region

 check_window1 = check_region WITH WIDTH >= AA_D_6_window/4
 err1_TMP1 = DENSITY check_pattern check_window1 check_region [!!AREA(check_window1)*AREA(check_pattern)/AREA(check_region)] > AA_D_6_val/100 WINDOW AA_D_6_window STEP AA_D_6_window/2 BACKUP INSIDE OF LAYER DRC:1 BY POLYGON

 check_window2 = WITH WIDTH (check_region AND err1_TMP1) >= AA_D_6_window/4
 err1_TMP2 = DENSITY check_pattern check_window2 check_region [!!AREA(check_window2)*AREA(check_pattern)/AREA(check_region)] > AA_D_6_val/100 WINDOW AA_D_6_window STEP AA_D_6_window/2 BACKUP INSIDE OF LAYER err1_TMP1 BY POLYGON

 check_window3 = WITH WIDTH (check_region AND err1_TMP2) >= AA_D_6_window/4
 DENSITY check_pattern check_window3 check_region [!!AREA(check_window3)*AREA(check_pattern)/AREA(check_region)] > AA_D_6_val/100 WINDOW AA_D_6_window STEP AA_D_6_window/2 BACKUP INSIDE OF LAYER err1_TMP2 BY POLYGON PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_AA_D_6.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_AA_D_6.rdb"
}
#ENDIF

/*
#IFDEF MINIMUM_DENSITY_CHECK YES
AA_D_7 {
@ Minimum ALL_AA density inside ((((((AA OR GT) INTERACT (AA AND GT)) SIZING 3um) NOT ((AA OR GT) su 0.2um))) NOT INST) NOT DG) >= 10%
@ except VARMOS, ESDIO1, ESDIO2 and MARKS region
 STEP_1 = SIZE AA_OR_GT BY 0.2
 STEP_2 = GATE_raw NOT (OR VARMOS MARKS_ESDIO_all)
 STEP_3 = SIZE (((AA_OR_GT INTERACT STEP_2) NOT INST) NOT DG) BY 3
 check_region = ((STEP_3 NOT STEP_1) NOT INST) NOT DG
 check_pattern = ALL_AA AND check_region

 err1 = DFM PROPERTY check_region check_pattern OVERLAP [ratio = AREA(check_pattern)/AREA(check_region)] < 0.1
 DFM RDB err1 "./SMIC_14SFPLUS_DRC_logFile/density_report_AA_D_7.rdb"
 COPY err1
}
#ENDIF
*/

AA_R_1 {
@ ALL_AA must be fully covered by (SN OR SP), except DMCMK1 and MARKS regions
 err1 = ALL_AA NOT ALL_SN_SP
 err1 NOT INSIDE DMCMK1_MARKS
}

AA_R_2 {
@ NPAA in chip design is not allowed
 err1 = NPAA INTERACT DRC:1
 err1 NOT INSIDE SealR_NOT_BULK
}

AA_R_3 {
@ DOP_AA overlap AA, GT is not allowed
 err1 = DOP_AA AND AA_OR_GT
 err1 NOT INSIDE SealR_NOT_BULK
}

single_R_AA = AA RECTANGLE ORTHOGONAL ONLY
single_L_AA = ((VERTEX AA == 6) WITH EDGE AA_convex_90_90_edge == 4) WITH EDGE AA_convex_90_270_edge == 2
single_U_AA = (((VERTEX AA == 8) WITH EDGE AA_convex_90_90_edge == 5) WITH EDGE AA_convex_90_270_edge == 2) WITH EDGE (ANGLE AA_convex_270_270_edge == 0) == 1

single_T_AA_TMP = ((VERTEX AA == 8) WITH EDGE AA_convex_90_90_edge == 4) WITH EDGE AA_convex_90_270_edge == 4
single_T_AA_LEFT = (ANGLE AA_convex_90_270_edge == 90) TOUCH EDGE ((GROW single_T_AA_TMP LEFT BY 0.0005) NOT single_T_AA_TMP)
single_T_AA_RIGHT = (ANGLE AA_convex_90_270_edge == 90) TOUCH EDGE ((GROW single_T_AA_TMP RIGHT BY 0.0005) NOT single_T_AA_TMP)
single_T_AA_TOP = (ANGLE AA_convex_90_90_edge == 0) TOUCH EDGE ((EXPAND EDGE (ANGLE AA_convex_90_90_edge == 0) INSIDE BY 0.001) WITH EDGE AA_convex_90_270_edge == 2)
single_T_AA = ((single_T_AA_TMP WITH EDGE single_T_AA_LEFT) WITH EDGE single_T_AA_RIGHT) WITH EDGE single_T_AA_TOP

AA_special_waive_TMP = ((AA VERTEX == 10) WITH EDGE AA_convex_90_90_edge == 4) WITH EDGE AA_convex_90_270_edge == 6
AA_special_waive_LEFT_1 = LENGTH (((GROW AA_special_waive_TMP LEFT BY 0.0005) NOT AA_special_waive_TMP) COIN EDGE AA_convex_90_90_edge) == 0.144 + 0.096 + 0.058 - 0.048
AA_special_waive_LEFT_2 = LENGTH (((GROW AA_special_waive_TMP LEFT BY 0.0005) NOT AA_special_waive_TMP) COIN EDGE AA_convex_90_270_edge) == 0.048
AA_special_waive_RIGHT_1 = LENGTH (((GROW AA_special_waive_TMP RIGHT BY 0.0005) NOT AA_special_waive_TMP) COIN EDGE AA_convex_90_90_edge) == 0.058
AA_special_waive_RIGHT_2 = LENGTH (((GROW AA_special_waive_TMP RIGHT BY 0.0005) NOT AA_special_waive_TMP) COIN EDGE AA_convex_90_270_edge) == 0.144
AA_special_waive_RIGHT_3 = LENGTH (((GROW AA_special_waive_TMP RIGHT BY 0.0005) NOT AA_special_waive_TMP) COIN EDGE AA_convex_90_270_edge) == 0.096

AA_special_waive_TOP = LENGTH (((GROW AA_special_waive_TMP TOP BY 0.0005) NOT AA_special_waive_TMP) COIN EDGE AA_convex_90_90_edge) == 0.810 + 0.270 + 0.270 + 0.360
AA_special_waive_BOTTOM_1 = LENGTH (((GROW AA_special_waive_TMP BOTTOM BY 0.0005) NOT AA_special_waive_TMP) COIN EDGE AA_convex_90_90_edge) == 0.270
AA_special_waive_BOTTOM_2 = LENGTH (((GROW AA_special_waive_TMP BOTTOM BY 0.0005) NOT AA_special_waive_TMP) COIN EDGE AA_convex_90_270_edge) == 0.810
AA_special_waive_BOTTOM_3 = LENGTH (((GROW AA_special_waive_TMP BOTTOM BY 0.0005) NOT AA_special_waive_TMP) COIN EDGE AA_convex_90_270_edge) == 0.270
AA_special_waive_BOTTOM_4 = LENGTH (((GROW AA_special_waive_TMP BOTTOM BY 0.0005) NOT AA_special_waive_TMP) COIN EDGE AA_convex_90_270_edge) == 0.360
AA_special_waive = (((((((((AA_special_waive_TMP WITH EDGE AA_special_waive_LEFT_1) WITH EDGE AA_special_waive_LEFT_2) WITH EDGE AA_special_waive_RIGHT_1) WITH EDGE AA_special_waive_RIGHT_2) WITH EDGE AA_special_waive_RIGHT_3) WITH EDGE AA_special_waive_TOP) WITH EDGE AA_special_waive_BOTTOM_1) WITH EDGE AA_special_waive_BOTTOM_2) WITH EDGE AA_special_waive_BOTTOM_3) WITH EDGE AA_special_waive_BOTTOM_4
AA_special_waive_D0691_D0734 = AA_special_waive INSIDE (DRC:1 INTERACT (OR D0691_SRAM D0734_SRAM))

//;D0691/D0734
//;-------------1.170--------------------------------------------------------------------------------
//; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
//; ;;											;;
//; ;;								<-------0.36----------->;;0.058
//; ;;								;;;;;;;;;;;;;;;;;;;;;;;;;;
//; ;;0.288							;;
//; ;;						<-----0.27----->;;0.096
//; ;;						;;;;;;;;;;;;;;;;;;
//; ;;<----------0.81------------>		;;
//; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;		;;
//; 				;;		;;
//; 			   0.048;;<----0.27---->;;0.144
//; 				;;;;;;;;;;;;;;;;;;
//;-------------------------------------------------------------------------------------------------

AA_907_CHK = AA INSIDE (DRC:1 INTERACT D0907_SRAM)
AA_907_waive_A_TMP = ((((((AA VERTEX == 8) WITH EDGE AA_convex_90_90_edge == 4) WITH EDGE AA_convex_90_270_edge == 4) WITH EDGE (LENGTH AA_convex_90_90_edge == 1.170)) WITH EDGE (LENGTH AA_convex_90_90_edge == 0.63)) WITH EDGE (ANGLE (LENGTH AA_convex_90_90_edge == 0.384) == 90)) WITH EDGE (ANGLE (LENGTH AA_convex_90_90_edge == 0.096) == 90)
AA_907_waive_A_LEFT = ANGLE (CONVEX EDGE AA_907_CHK ANGLE1==90 LENGTH1==0.63 ANGLE2==90 LENGTH2==1.170 WITH LENGTH == 0.384) == 90
AA_907_waive_A_RIGHT = ANGLE (CONVEX EDGE AA_907_CHK ANGLE1==90 LENGTH1==0.27 ANGLE2==90 LENGTH2==1.170 WITH LENGTH == 0.096) == 90
AA_907_waive_A_BOTTOM = ANGLE (CONVEX EDGE AA_907_CHK ANGLE1==90 LENGTH1==0.096 ANGLE2==90 LENGTH2==0.384 WITH LENGTH == 0.63) == 0
AA_907_waive_A_SAW_sideA = ANGLE (CONVEX EDGE AA_907_CHK ANGLE1==270 LENGTH1==0.096 ANGLE2==90 LENGTH2==0.192 WITH LENGTH == 0.270) == 0
AA_907_waive_A_SAW_sideB = ANGLE (CONVEX EDGE AA_907_CHK ANGLE1==270 LENGTH1==0.192 ANGLE2==90 LENGTH2==0.096 WITH LENGTH == 0.270) == 0
AA_907_waive_A_SAW_sideC = ANGLE (CONVEX EDGE AA_907_CHK ANGLE1==270 LENGTH1==0.270 ANGLE2==90 LENGTH2==0.270 WITH LENGTH == 0.192) == 90
AA_907_waive_A_SAW_sideD = ANGLE (CONVEX EDGE AA_907_CHK ANGLE1==270 LENGTH1==0.270 ANGLE2==90 LENGTH2==0.630 WITH LENGTH == 0.096) == 90
AA_907_waive_A = ((((((AA_907_waive_A_TMP WITH EDGE AA_907_waive_A_LEFT) WITH EDGE AA_907_waive_A_RIGHT) WITH EDGE AA_907_waive_A_BOTTOM) WITH EDGE AA_907_waive_A_SAW_sideA) WITH EDGE AA_907_waive_A_SAW_sideB) WITH EDGE AA_907_waive_A_SAW_sideC) WITH EDGE AA_907_waive_A_SAW_sideD

AA_907_waive_B_TMP = ((((((AA VERTEX == 10) WITH EDGE AA_convex_90_90_edge == 4) WITH EDGE AA_convex_90_270_edge == 6) WITH EDGE (LENGTH AA_convex_90_90_edge == 1.350)) WITH EDGE (LENGTH AA_convex_90_90_edge == 0.180)) WITH EDGE (ANGLE (LENGTH AA_convex_90_90_edge == 0.576) == 90)) WITH EDGE (ANGLE (LENGTH AA_convex_90_90_edge == 0.096) == 90)
AA_907_waive_B_LEFT = ANGLE (CONVEX EDGE AA_907_CHK ANGLE1==90 LENGTH1==0.18 ANGLE2==90 LENGTH2==1.350 WITH LENGTH == 0.576) == 90
AA_907_waive_B_RIGHT = ANGLE (CONVEX EDGE AA_907_CHK ANGLE1==90 LENGTH1==0.27 ANGLE2==90 LENGTH2==1.350 WITH LENGTH == 0.096) == 90
AA_907_waive_B_BOTTOM = ANGLE (CONVEX EDGE AA_907_CHK ANGLE1==90 LENGTH1==0.192 ANGLE2==90 LENGTH2==0.576 WITH LENGTH == 0.18) == 0
AA_907_waive_B_SAW_sideA = ANGLE (CONVEX EDGE AA_907_CHK ANGLE1==270 LENGTH1==0.096 ANGLE2==90 LENGTH2==0.192 WITH LENGTH == 0.270) == 0
AA_907_waive_B_SAW_sideB = ANGLE (CONVEX EDGE AA_907_CHK ANGLE1==270 LENGTH1==0.192 ANGLE2==90 LENGTH2==0.096 WITH LENGTH == 0.270) == 0
AA_907_waive_B_SAW_sideC = ANGLE (CONVEX EDGE AA_907_CHK ANGLE1==270 LENGTH1==0.192 ANGLE2==90 LENGTH2==0.096 WITH LENGTH == 0.630) == 0
AA_907_waive_B_SAW_sideD = ANGLE (CONVEX EDGE AA_907_CHK ANGLE1==270 LENGTH1==0.270 ANGLE2==90 LENGTH2==0.270 WITH LENGTH == 0.192) == 90
AA_907_waive_B_SAW_sideE = ANGLE (CONVEX EDGE AA_907_CHK ANGLE1==270 LENGTH1==0.270 ANGLE2==90 LENGTH2==0.630 WITH LENGTH == 0.096) == 90
AA_907_waive_B_SAW_sideF = ANGLE (CONVEX EDGE AA_907_CHK ANGLE1==270 LENGTH1==0.630 ANGLE2==90 LENGTH2==0.180 WITH LENGTH == 0.192) == 90
AA_907_waive_B = ((((((((AA_907_waive_B_TMP WITH EDGE AA_907_waive_B_LEFT) WITH EDGE AA_907_waive_B_RIGHT) WITH EDGE AA_907_waive_B_BOTTOM) WITH EDGE AA_907_waive_B_SAW_sideA) WITH EDGE AA_907_waive_B_SAW_sideB) WITH EDGE AA_907_waive_B_SAW_sideC) WITH EDGE AA_907_waive_B_SAW_sideD) WITH EDGE AA_907_waive_B_SAW_sideE) WITH EDGE AA_907_waive_B_SAW_sideF
AA_907_waive = (OR AA_907_waive_A AA_907_waive_B) INSIDE (DRC:1 INTERACT D0907_SRAM)
AA_special_waive_D0691_D0734_D907 = OR AA_special_waive_D0691_D0734 AA_907_waive

//;D907/A
//;--------------1.170------------------------------------------------------------------------------
//; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
//; ;;											;;
//; ;;								<-------0.27----------->;;0.096
//; ;;								;;;;;;;;;;;;;;;;;;;;;;;;;;
//; ;;0.384							;;
//; ;;						<-----0.27----->;;0.192
//; ;;						;;;;;;;;;;;;;;;;;;
//; ;;<----------0.63-------------------------->;;
//; ;; 						;;0.096
//; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
//;D907/B
//;--------------1.350------------------------------------------------------------------------------
//; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
//; ;;											;;
//; ;;								<-------0.27----------->;;0.096
//; ;;								;;;;;;;;;;;;;;;;;;;;;;;;;;
//; ;;0.576							;;
//; ;;						<-----0.27----->;;0.192
//; ;;						;;;;;;;;;;;;;;;;;;
//; ;;		<----------0.63---------------->;;
//; ;; 						;;0.096
//; ;;		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
//; ;;		;;
//; ;;		;;0.192
//; ;;;;;;;;;;;;;;
//; <---0.180--->
//;-------------------------------------------------------------------------------------------------

/*
AA_R_5 {
@ AA edge must be orthogonal or single L-, T-, U-shape
@ DRC waive condition:
@ 1) Special pattern with two L-shape abutted in SRAM periphery region of D0691 (UDSRAM) and D0734 (STSRAM).
@ 2) Special patter like T-shape in SRAM periphery region of D0734 (STSRAM).
@ 3) Special patter with two L-shape abutted or L-shape/rectangular abutted in SRAM periphery region of 907 MC (DNSRAM)
 err1 = ANGLE AA > 0 < 90
 err1 NOT INSIDE EDGE SealR_NOT_BULK

 err2 = AA NOT (OR single_R_AA single_L_AA single_T_AA single_U_AA AA_special_waive_D0691_D0734_D907)
 err2 NOT INSIDE SealR_NOT_BULK
}
*/

AA_R_5 {
@ AA must be orthogonal to grid (Single Z-shape AA is not allowed)
 err1 = ANGLE AA > 0 < 90
 err1 NOT INSIDE EDGE SealR_NOT_BULK

 single_z_shape_TMP = ((AA VERTEX == 8) WITH EDGE AA_convex_90_90_edge == 4) WITH EDGE AA_convex_90_270_edge == 4
 single_z_shape_TOP = (ANGLE AA_convex_90_270_edge == 0) TOUCH EDGE (((GROW single_z_shape_TMP TOP BY 0.0001) NOT AA) WITH EDGE AA_convex_90_270_edge == 2)
 single_z_shape_BOTTOM = (ANGLE AA_convex_90_270_edge == 0) TOUCH EDGE (((GROW single_z_shape_TMP BOTTOM BY 0.0001) NOT AA) WITH EDGE AA_convex_90_270_edge == 2)
 err2 = (single_z_shape_TMP WITH EDGE single_z_shape_TOP) WITH EDGE single_z_shape_BOTTOM
 err2 NOT INSIDE SealR_NOT_BULK
}

AA_R_6 {
@ AA interact with GT (width >= 0.032um) must be rectangular
 err1 = NOT RECTANGLE (AA INTERACT GT_eqgt_032) ORTHOGONAL ONLY
 err1 NOT INSIDE SealR_NOT_BULK
}

AA_R_7 {
@ DUM_AA must be rectangle
 err1 = NOT RECTANGLE DUM_AA ORTHOGONAL ONLY
 err1 NOT INSIDE SealR_NOT_BULK
}

// =======================================================
// AR: AA cut design rules
// =======================================================

GROUP GAR AR_?

AR_ARDOP_NOT_MARKS = AR_ARDOP NOT MARKS
AR_DUM_AR_NOT_MARKS = (OR AR ARDOP ARDUM) NOT MARKS
AR_v_edges_outer_AA = AR_v_edges COIN EDGE ((AR NOT AA) TOUCH AA)

AR_W_1 {
@ AR width in S/D direction, except OCOVL region = 0.02um
 err1 = INT (AR_v_edges) == 0.020 ABUT<90 OPPOSITE  //;AR.R.6 based on this
 err1 NOT INSIDE EDGE OCOVL
}

AR_S_1 {
@ AR pitch in S/D direction >= 0.09um
 CHK_018_sides = INT [AR_v_edges] == 0.018 ABUT<90 OPPOSITE
 CHK_020_sides = INT [AR_v_edges] == 0.020 ABUT<90 OPPOSITE
 err1 = EXT CHK_018_sides < 0.09-0.018 ABUT<90 OPPOSITE REGION
 err2 = EXT CHK_020_sides < 0.09-0.020 ABUT<90 OPPOSITE REGION
 err3 = EXT CHK_018_sides CHK_020_sides < 0.09-0.019 ABUT<90 OPPOSITE REGION  //; 0.019 = (0.02+0.018)/2
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
}

AR_S_2 {
@ Space between AR and ALL_AA >= 0.048um
 err1 = EXT AR ALL_AA < 0.048 ABUT<90 SINGULAR REGION MEASURE ALL
 err1 NOT INSIDE SealR_NOT_BULK
}

AR_S_3 {
@ Space between AR in GATE poly direction >= 0.144um
 err1 = OR (EXT AR_h_edges < 0.144 ABUT<90 OPPOSITE REGION) (EXT AR < 0.001 ABUT<90 SINGULAR REGION)
 err1 NOT INSIDE SealR_NOT_BULK
}

AR_EX_1 {
@ AR extension outside of AA in GATE poly direction (extension <= 0 is not allowed) = 0.048+0.048*num
 chk_AR = AR_v_edges_outer_AA OUTSIDE EDGE AA  //;AR whole edge on STI besides the edge GATE will also be checked (not need to exclude it based on FIN pitch)
 err1 = DFM PROPERTY chk_AR [-= ABS(REMAINDER((LENGTH(chk_AR) - 0.048),0.048))] > 0
 err1 NOT INSIDE EDGE SealR_NOT_BULK

 err2 = ENC AA AR_h_edges < 0.048 ABUT<90 OPPOSITE REGION INSIDE ALSO
 err2 NOT INSIDE SealR_NOT_BULK
}

AR_EX_2 {
@ AA extension outside of AR in S/D direction = -0.01, >= 0.17um
//;AA edges inside edge of AR but not abut AR centerline is not allowed based on AR.O.1
 chk_AA = AA OR (EXPAND EDGE AA_v_edges OUTSIDE BY 0.01)
 err1 = ENC AR_v_edges chk_AA < 0.170+0.01 ABUT>0<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

AR_O_1 {
@ AA overlap AR in S/D direction = 0.01, 0.02um
//;space = 0 covered by AR.S.1.1
 err1 = DFM COPY (DFM SPACE AA AR < 0.01 BY INT HORIZONTAL) REGION
 err2 = DFM COPY (DFM SPACE AA AR > 0.01 < 0.02 BY INT HORIZONTAL) REGION
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

AR_L_1 {
@ AR length in GATE poly direction, except OCOVL region >= 0.24um
 err1 = LENGTH AR_v_edges < 0.240
 err1 NOT INSIDE EDGE OCOVL
}

AR_L_2 {
@ Length of (ALL_AR AND ((ALL_AA with vertical edge extend 1/2 GT width) horizontal edge extend 0.12um)) in GATE poly direction <= 52um
 check_AREA = (EXPAND EDGE ALL_AA_h_edges OUTSIDE BY 0.12 EXTEND BY 0.010) OR ALL_AA
 err1 = (ALL_AR AND check_AREA) ENCLOSE RECTANGLE 0.0001 52+GLOBAL_TOLERANCE ORTHOGONAL ONLY
 err1 NOT INSIDE SealR_NOT_BULK
}

AR_A_1 {
@ AR area >= 0.0048um2
 err1 = AREA AR < 0.0048
 err1 NOT INSIDE SealR_NOT_BULK
}

ARDUM_sd_0.2 = SIZE ARDUM BY -0.02
AR_DUM_AR_NOT_MARKS_0.2 = (OR AR ARDUM_sd_0.2 ARDOP) NOT MARKS

#IFDEF IP_LEVEL_DENSITY_CHECK YES
#IFDEF MINIMUM_DENSITY_CHECK YES
AR_DN_1 {
@ Full chip ((AR OR (ARDUM sd 0.02um)) OR ARDOP) density >= 5%
 DENSITY AR_DUM_AR_NOT_MARKS_0.2 CHIP_NOT_MARKS [!AREA(AR_DUM_AR_NOT_MARKS_0.2) + !!AREA(AR_DUM_AR_NOT_MARKS_0.2)*AREA(AR_DUM_AR_NOT_MARKS_0.2)/AREA(CHIP_NOT_MARKS)] < 0.05 PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_AR_DN_1.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_AR_DN_1.rdb"
}
#ENDIF

AR_DN_2 {
@ Full chip ((AR OR (ARDUM sd 0.02um)) OR ARDOP) density <= 10%
 DENSITY AR_DUM_AR_NOT_MARKS_0.2 CHIP_NOT_MARKS [AREA(AR_DUM_AR_NOT_MARKS_0.2)/AREA(CHIP_NOT_MARKS)] > 0.1 PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_AR_DN_2.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_AR_DN_2.rdb"
}

#IFDEF MINIMUM_DENSITY_CHECK YES
VARIABLE AR_DN_3_val 14.3
VARIABLE AR_DN_3_window 18

AR_DN_3 {
@ ((AR OR (ARDUM sd 0.02um)) OR ARDOP) density (window 18umx18um, stepping 18um/step_number), except OCOVL region <= 14.3%
 check_region = DRC:1 NOT MARKS_OCOVL
 check_pattern = (AR_DUM_AR_NOT_MARKS_0.2 NOT MARKS_OCOVL) AND check_region

 check_window1 = check_region WITH WIDTH >= AR_DN_3_window/4
 err1_TMP1 = DENSITY check_pattern check_window1 check_region [!!AREA(check_window1)*AREA(check_pattern)/AREA(check_region)] > AR_DN_3_val/100 WINDOW AR_DN_3_window STEP AR_DN_3_window/step_number BACKUP INSIDE OF LAYER DRC:1 BY POLYGON

 check_window2 = WITH WIDTH (check_region AND err1_TMP1) >= AR_DN_3_window/4
 err1_TMP2 = DENSITY check_pattern check_window2 check_region [!!AREA(check_window2)*AREA(check_pattern)/AREA(check_region)] > AR_DN_3_val/100 WINDOW AR_DN_3_window STEP AR_DN_3_window/step_number BACKUP INSIDE OF LAYER err1_TMP1 BY POLYGON

 check_window3 = WITH WIDTH (check_region AND err1_TMP2) >= AR_DN_3_window/4
 DENSITY check_pattern check_window3 check_region [!!AREA(check_window3)*AREA(check_pattern)/AREA(check_region)] > AR_DN_3_val/100 WINDOW AR_DN_3_window STEP AR_DN_3_window/step_number BACKUP INSIDE OF LAYER err1_TMP2 BY POLYGON PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_AR_DN_3.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_AR_DN_3.rdb"
}
#ENDIF

#ELSE

#IFDEF MINIMUM_DENSITY_CHECK YES
AR_DN_1 {
@ Full chip ((AR OR (ARDUM sd 0.02um)) OR ARDOP) density >= 5%
 DENSITY AR_DUM_AR_NOT_MARKS_0.2 CHIP_NOT_MARKS [!AREA(AR_DUM_AR_NOT_MARKS_0.2) + !!AREA(AR_DUM_AR_NOT_MARKS_0.2)*AREA(AR_DUM_AR_NOT_MARKS_0.2)/AREA(CHIP_NOT_MARKS)] < 0.05 PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_AR_DN_1.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_AR_DN_1.rdb"
}
#ENDIF

AR_DN_2 {
@ Full chip ((AR OR (ARDUM sd 0.02um)) OR ARDOP) density <= 10%
 DENSITY AR_DUM_AR_NOT_MARKS_0.2 CHIP_NOT_MARKS [AREA(AR_DUM_AR_NOT_MARKS_0.2)/AREA(CHIP_NOT_MARKS)] > 0.1 PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_AR_DN_2.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_AR_DN_2.rdb"
}

#IFDEF MINIMUM_DENSITY_CHECK YES
VARIABLE AR_DN_3_val 15
VARIABLE AR_DN_3_window 18

AR_DN_3 {
@ ((AR OR (ARDUM sd 0.02um)) OR ARDOP) density (window 18umx18um, stepping 9um), except OCOVL region <= 15%
 check_region = DRC:1 NOT MARKS_OCOVL
 check_pattern = (AR_DUM_AR_NOT_MARKS_0.2 NOT MARKS_OCOVL) AND check_region

 check_window1 = check_region WITH WIDTH >= AR_DN_3_window/4
 err1_TMP1 = DENSITY check_pattern check_window1 check_region [!!AREA(check_window1)*AREA(check_pattern)/AREA(check_region)] > AR_DN_3_val/100 WINDOW AR_DN_3_window STEP AR_DN_3_window/2 BACKUP INSIDE OF LAYER DRC:1 BY POLYGON

 check_window2 = WITH WIDTH (check_region AND err1_TMP1) >= AR_DN_3_window/4
 err1_TMP2 = DENSITY check_pattern check_window2 check_region [!!AREA(check_window2)*AREA(check_pattern)/AREA(check_region)] > AR_DN_3_val/100 WINDOW AR_DN_3_window STEP AR_DN_3_window/2 BACKUP INSIDE OF LAYER err1_TMP1 BY POLYGON

 check_window3 = WITH WIDTH (check_region AND err1_TMP2) >= AR_DN_3_window/4
 DENSITY check_pattern check_window3 check_region [!!AREA(check_window3)*AREA(check_pattern)/AREA(check_region)] > AR_DN_3_val/100 WINDOW AR_DN_3_window STEP AR_DN_3_window/2 BACKUP INSIDE OF LAYER err1_TMP2 BY POLYGON PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_AR_DN_3.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_AR_DN_3.rdb"
}
#ENDIF
#ENDIF

GT_center_region = DFM SPACE GT < GT_MaxiWidth_PLUS BY INT HORIZONTAL
GT_center_odd = DFM COPY (DFM PROPERTY GT_center_region [-= ABS(REMAINDER(EW(GT_center_region), 0.002))] > 0) CENTERLINE
GT_center_even = DFM COPY (DFM PROPERTY GT_center_region [-= ABS(REMAINDER(EW(GT_center_region), 0.002))] == 0) CENTERLINE

AOP_GT_center_region = DFM SPACE AOP_GT < GT_MaxiWidth_PLUS BY INT HORIZONTAL
AOP_GT_center_odd = DFM COPY (DFM PROPERTY AOP_GT_center_region [-= ABS(REMAINDER(EW(AOP_GT_center_region), 0.002))] > 0) CENTERLINE
AOP_GT_center_even = DFM COPY (DFM PROPERTY AOP_GT_center_region [-= ABS(REMAINDER(EW(AOP_GT_center_region), 0.002))] == 0) CENTERLINE
AOP_GT_center_odd_waive = EXPAND EDGE (AOP_GT_center_odd INSIDE EDGE AOP_GT) BY 0.001

/*
AR_R_1 {
@ AR centerline must coincide with centerline of GT
@ DRC waive if AR extension outside of GT in GATE poly direction
 AR_expand = AR AND (OR GT (EXPAND EDGE GT_v_edges OUTSIDE BY AR_MaxiWidth_PLUS)) //;based on AR.W.1/AR.R.7
 AR_center_line = DFM COPY (DFM SPACE AR_expand < AR_MaxiWidth_PLUS BY INT HORIZONTAL) CENTERLINE  //;based on AR.W.1
 err1 = AR_center_line NOT COIN EDGE GT_center_even
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
*/

AR_R_1 {
@ AR vertical edge must align with GT, except small GT jog <= 0.004um, except OCOVL region
//; WAIVE_AREA = OR EDGE (ENC GT [AR_v_edges] <= 0.004 OPPOSITE) (ENC [AR_v_edges] GT <= 0.004 OPPOSITE)
 err1 = AR_v_edges NOT TOUCH INSIDE EDGE GT  //;) NOT COIN EDGE WAIVE_AREA
 err1 NOT INSIDE EDGE OCOVL
}

AR_R_2 {
@ M0G overlap ((GT NOT P2) INTERACT AR) is not allowed
 err1 = (GT_0 INTERACT AR) AND M0G
 err1 NOT INSIDE SealR_NOT_BULK
}

AR_R_3 {
@ AR must inside CELLB, except OCOVL region
 err1 = AR NOT CELLB
 err1 NOT INSIDE OCOVL
}

AR_R_4 {
@ AR interact pick-up AA, DSTR, DMCMK1, DG or INST is not allowed
 err1 = AR INTERACT (OR TAP_RAW DSTR DMCMK1 DG INST)
 err1 NOT INSIDE SealR_NOT_BULK
}

AR_R_5 {
@ AR must be vertical rectangle
 err1 = AR NOT RECTANGLE ORTHOGONAL ONLY
 err2 = INT AR_h_edges <= 0.02 ABUT<90 OPPOSITE REGION //;based on AR.W.1
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

#IFDEF Delta_Voltage_Rules_Check YES
AR_R_6 {
@ Maximum delta V > 1.15V between two S/D active beside AR is not allowed
 err1_TMP = DFM DV (AA_c INTERACT AR) < AR_MaxiWidth_PLUS DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 1.15 ANNOTATE NOT CONNECTED SINGULAR
 err1 = (DFM COPY err1_TMP REGION) AND AR
 err1 NOT INSIDE SealR_NOT_BULK
}
#ENDIF

AR_R_7 {
@ AR must overlap AOP_GT, except OCOVL region
 err1 = AR NOT INTERACT (AR AND AOP_GT)
 err1 NOT INSIDE OCOVL
}

// =======================================================
// DNW: Deep N-Well design rules
// =======================================================

GROUP GDNW DNW_?

HOLES_NW = HOLES NW
HOLES_NW_INNER = HOLES NW INNER
DNW_in_NW_hole = DNW INTERACT HOLES_NW
HOLES_NW_in_DNW = HOLES_NW INSIDE DNW
PW_and_HOLES_NW_in_DNW = PW AND HOLES_NW_in_DNW

DNW_W_1 {
@ DNW width >= 1.49um
 err1 = INT DNW < 1.49 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

DNW_S_1 {
@ Space between two DNWs >= 3.1um
 err1 = EXT DNW < 3.1 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

DNW_S_2 {
@ Space between DNW and N+AA (N+AA outside of DNW or NW) >= 1.48um
 err1 = EXT DNW (NACT OUTSIDE DNW) < 1.48 ABUT<90 REGION
 err2 = EXT DNW (NACT OUTSIDE NW) < 1.48 ABUT<90 REGION
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

DNW_S_3 {
@ Space between DNW and NW at different net >= 1.49um
 err1 = EXT DNW NW < 1.49 ABUT<90 MEASURE ALL REGION NOT CONNECTED
 err1 NOT INSIDE SealR_NOT_BULK
}

DNW_S_4 {
@ Space between (NW hole in DNW) and ((NW hole in DNW) OR PW) at different net >= 0.52um
 err1 = EXT PW_and_HOLES_NW_in_DNW < 0.52 ABUT<90 REGION NOT CONNECTED
 err2 = EXT PW_and_HOLES_NW_in_DNW PW < 0.52 ABUT<90 REGION NOT CONNECTED
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK

 rw_raw = HOLES_NW_INNER INSIDE DNW
 rw_chk = PW AND rw_raw
 err3 = EXT rw_chk < 0.52 ABUT<90 REGION NOT CONNECTED
 err4 = EXT rw_chk PW < 0.52 ABUT<90 REGION NOT CONNECTED
 err3 NOT INSIDE SealR_NOT_BULK
 err4 NOT INSIDE SealR_NOT_BULK
}

DNW_S_5 {
@ Space between (NW hole in DNW) and (((NW hole in DNW) OR PW) INTERACT DG) at different net >= 0.896um
 err1 = EXT PW_and_HOLES_NW_in_DNW (PW_and_HOLES_NW_in_DNW INTERACT DG) < 0.896 ABUT<90 REGION NOT CONNECTED
 err2 = EXT PW_and_HOLES_NW_in_DNW (PW INTERACT DG) < 0.896 ABUT<90 REGION NOT CONNECTED
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK

 rw_raw = HOLES_NW_INNER INSIDE DNW
 rw_chk = PW AND rw_raw
 rw_chk_IO = rw_chk INTERACT DG
 err3 = EXT rw_chk rw_chk_IO < 0.896 ABUT<90 REGION NOT CONNECTED
 err4 = EXT rw_chk (PW INTERACT DG) < 0.896 ABUT<90 REGION NOT CONNECTED
 err3 NOT INSIDE SealR_NOT_BULK
 err4 NOT INSIDE SealR_NOT_BULK
}

DNW_EN_1 {
@ N+AA enclosure by DNW >= 0.42um
 err1 = ENC NACT DNW < 0.42 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

DNW_O_1 {
@ Overlap of NW and DNW >= 0.358um
 err1 = INT NW DNW_in_NW_hole < 0.358 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK

 err2 = DNW_in_NW_hole NOT INSIDE EDGE NW
 err2 NOT INSIDE EDGE SealR_NOT_BULK

 err3 = INT NW (DNW NOT DNW_in_NW_hole) < 0.358 ABUT<90 SINGULAR REGION
 err3 NOT INSIDE SealR_NOT_BULK
}

DNW_R_1 {
@ N+AA cut DNW is not allowed
 err1 = DNW INSIDE EDGE NACT
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

//;DNW_R_2_NC {
//;@ Floating NW hole in DNW is not recommended to avoid unstable device performance
//; err1 = HOLES_NW AND DNW
//; err2 = HOLES_NW_INNER AND DNW
//; err1 NOT INSIDE MARKS
//; err2 NOT INSIDE MARKS
//;}

VARIABLE DNW_R_3_val 5

#IFDEF Delta_Voltage_Rules_Check YES
DNW_R_3_DNW_2_DNW {
@ Maximum delta V >= 5.6V is not allowed, when:
@ 1. Space between DNW and DNW/NW is < 5um
@ 2. Space between RW and RW/PW is < 5um
 err1 = DFM DV DNW < DNW_R_3_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" >= 5.6 ANNOTATE NOT CONNECTED SINGULAR
 DFM COPY err1
}

DNW_R_3_DNW_2_NW {
@ Maximum delta V >= 5.6V is not allowed, when:
@ 1. Space between DNW and DNW/NW is < 5um
@ 2. Space between RW and RW/PW is < 5um
 err1 = DFM DV DNW NW < DNW_R_3_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" >= 5.6 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err1
}

DNW_R_3_RW_2_RW {
@ Maximum delta V >= 5.6V is not allowed, when:
@ 1. Space between DNW and DNW/NW is < 5um
@ 2. Space between RW and RW/PW is < 5um
 err1 = DFM DV RW < DNW_R_3_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" >= 5.6 ANNOTATE NOT CONNECTED SINGULAR
 DFM COPY err1
}

DNW_R_3_RW_2_PW {
@ Maximum delta V >= 5.6V is not allowed, when:
@ 1. Space between DNW and DNW/NW is < 5um
@ 2. Space between RW and RW/PW is < 5um
 err1 = DFM DV PW_0 RW < DNW_R_3_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" >= 5.6 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err1
}
#ENDIF


// =======================================================
// NW: N-Well design rules
// =======================================================

GROUP GNW NW_?

IO_NW = NW AND DG
IO_PW = DG NOT NW
Core_NW = NW NOT DG
Core_PW = DRC:1 NOT (DG OR NW)
NW_v_edges = ANGLE NW > 88 <= 90

NW_W_1 {
@ NW width, except INST region >= 0.214um
 err1 = INT NW < NW_MiniWidth ABUT<90 SINGULAR REGION
 err1 NOT INSIDE INST
}

NW_W_2 {
@ IO_NW width >= 0.214um
 err1 = INT IO_NW < 0.214 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

NW_W_2a {
@ IO_PW width, except INST region >= 0.238um
 err1 = INT IO_PW < 0.238 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE INST
}

NW_W_3_1 {
@ Core_NW width, except INST region >= 0.214um
 err1 = INT core_NW < 0.214 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE INST
}

NW_W_3_2 {
@ (NW OR DG) width, except INST region >= 0.214um
 err1 = INT DG_or_NW < 0.214 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE INST
}

NW_W_4a {
@ NW width, when the space <= 0.235um, except INST region <= 0.365um
 nw_meet_sps_sides = EXT [NW] <= 0.235 ABUT<90 OPPOSITE
 nw_meet_sps_block = NW WITH EDGE nw_meet_sps_sides
 err1 = (INT (nw_meet_sps_block) <= 0.365 ABUT<90 OPPOSITE) COIN EDGE nw_meet_sps_sides
 err2 = (nw_meet_sps_block WITH WIDTH > 0.365) WITH EDGE nw_meet_sps_sides
 err1 NOT INSIDE EDGE INST
 err2 NOT INSIDE INST
}

NW_W_4b {
@ Core_NW width, when the space <= 0.235um, except INST region <= 0.365um
 nw_meet_sps_sides = EXT [core_NW] <= 0.235 ABUT<90 OPPOSITE
 nw_meet_sps_block = core_NW WITH EDGE nw_meet_sps_sides
 err1 = (INT (nw_meet_sps_block) <= 0.365 ABUT<90 OPPOSITE) COIN EDGE nw_meet_sps_sides
 err2 = (nw_meet_sps_block WITH WIDTH > 0.365) WITH EDGE nw_meet_sps_sides
 err1 NOT INSIDE EDGE INST
 err2 NOT INSIDE INST
}

NW_W_4d {
@ IO_NW width, when the space <= 0.235um, except INST region <= 0.365um
 nw_meet_sps_sides = EXT [IO_NW] <= 0.235 ABUT<90 OPPOSITE
 nw_meet_sps_block = IO_NW WITH EDGE nw_meet_sps_sides
 err1 = (INT (nw_meet_sps_block) <= 0.365 ABUT<90 OPPOSITE) COIN EDGE nw_meet_sps_sides
 err2 = (nw_meet_sps_block WITH WIDTH > 0.365) WITH EDGE nw_meet_sps_sides
 err1 NOT INSIDE EDGE INST
 err2 NOT INSIDE INST
}

NW_W_4e {
@ IO_PW width, when the space <= 0.235um, except INST region <= 0.365um
 nw_meet_sps_sides = EXT [IO_PW] <= 0.235 ABUT<90 OPPOSITE
 nw_meet_sps_block = IO_PW WITH EDGE nw_meet_sps_sides
 err1 = (INT (nw_meet_sps_block) <= 0.365 ABUT<90 OPPOSITE) COIN EDGE nw_meet_sps_sides
//; err2 = (nw_meet_sps_block WITH WIDTH > 0.365) WITH EDGE nw_meet_sps_sides  //; cause confused output
 err1 NOT INSIDE EDGE INST
//; err2 NOT INSIDE SealR_NOT_BULK
}

NW_W_5 {
@ (NW OR DG) width, when the space <= 0.235um. <= 0.365um
 nw_meet_sps_sides = EXT [DG_or_NW] <= 0.235 ABUT<90 OPPOSITE
 nw_meet_sps_block = DG_or_NW WITH EDGE nw_meet_sps_sides
 err1 = (INT (nw_meet_sps_block) <= 0.365 ABUT<90 OPPOSITE) COIN EDGE nw_meet_sps_sides
 err2 = (nw_meet_sps_block WITH WIDTH > 0.365) WITH EDGE nw_meet_sps_sides
 err1 NOT INSIDE EDGE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

NW_S_1 {
@ NW space, except INST region >= 0.214um
 err1 = EXT NW < 0.214 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE INST
}

NW_S_1a_1 {
@ (NW OR DG) space, except INST region >= 0.214um
 err1 = EXT DG_or_NW < 0.214 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE INST
}

NW_S_1a_2 {
@ Core_NW space, except INST region >= 0.214um
 err1 = EXT core_NW < 0.214 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE INST
}

NW_S_1a_3 {
@ IO_PW space, except INST region >= 0.214um
 err1 = EXT IO_PW < 0.214 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE INST
}

NW_S_1b {
@ IO_NW space >= 0.238um
 err1 = EXT IO_NW < 0.238 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

NW_S_2a_1 {
@ IO_NW space, when the width <= 0.235um. <= 0.365um
 nw_meet_wid_sides = INT [IO_NW] <= 0.235 ABUT<90 OPPOSITE
 nw_meet_sps_sides = EXT [IO_NW] <= 0.365 ABUT<90 OPPOSITE
 nw_errs_sps_sides = EXT (IO_NW) <= 0.365 ABUT<90 OPPOSITE
 err1 = INT (nw_meet_wid_sides NOT COIN EDGE nw_meet_sps_sides) nw_errs_sps_sides <= 0.235 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

NW_S_2a_2 {
@ IO_PW space, when the width <= 0.235um. <= 0.365um
 nw_meet_wid_sides = INT [IO_PW] <= 0.235 ABUT<90 OPPOSITE
 nw_meet_sps_sides = EXT [IO_PW] <= 0.365 ABUT<90 OPPOSITE
 nw_errs_sps_sides = EXT (IO_PW) <= 0.365 ABUT<90 OPPOSITE
 err1 = INT (nw_meet_wid_sides NOT COIN EDGE nw_meet_sps_sides) nw_errs_sps_sides <= 0.235 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

NW_S_2_d {
@ NW space, when the width <= 0.235um, expect INST region <= 0.365um
 nw_meet_wid_sides = INT [NW] <= 0.235 ABUT<90 OPPOSITE
 nw_meet_sps_sides = EXT [NW] <= 0.365 ABUT<90 OPPOSITE
 nw_errs_sps_sides = EXT (NW) <= 0.365 ABUT<90 OPPOSITE
 err1 = INT (nw_meet_wid_sides NOT COIN EDGE nw_meet_sps_sides) nw_errs_sps_sides <= 0.235 OPPOSITE REGION
 err1 NOT INSIDE INST
}

NW_S_2_e {
@ Core_NW space, when the width <= 0.235um, expect INST region <= 0.365um
 nw_meet_wid_sides = INT [core_NW] <= 0.235 ABUT<90 OPPOSITE
 nw_meet_sps_sides = EXT [core_NW] <= 0.365 ABUT<90 OPPOSITE
 nw_errs_sps_sides = EXT (core_NW) <= 0.365 ABUT<90 OPPOSITE
 err1 = INT (nw_meet_wid_sides NOT COIN EDGE nw_meet_sps_sides) nw_errs_sps_sides <= 0.235 OPPOSITE REGION
 err1 NOT INSIDE INST
}

NW_S_2_f {
@ (NW OR DG) space, when the width <= 0.235um, expect INST region <= 0.365um
 nw_meet_wid_sides = INT [DG_or_NW] <= 0.235 ABUT<90 OPPOSITE
 nw_meet_sps_sides = EXT [DG_or_NW] <= 0.365 ABUT<90 OPPOSITE
 nw_errs_sps_sides = EXT (DG_or_NW) <= 0.365 ABUT<90 OPPOSITE
 err1 = INT (nw_meet_wid_sides NOT COIN EDGE nw_meet_sps_sides) nw_errs_sps_sides <= 0.235 OPPOSITE REGION
 err1 NOT INSIDE INST
}

VARIABLE NW_S_3a_val 0.248
VARIABLE NW_S_3a_PRL 0.255-GLOBAL_TOLERANCE

NW_S_3a {
@ Space between NWs when PRL >= 0.255um, except INST region >= 0.248um
 nw_err_RAW = EXT [NW] < NW_S_3a_val ABUT<90 OPPOSITE
 nw_jog_ALL = (CONVEX EDGE NW == 1) NOT COIN EDGE nw_err_RAW
 nw_jog_EXP_a = EXPAND EDGE nw_jog_ALL INSIDE BY 0.0005
 nw_jog_EXP_b = EXPAND EDGE nw_jog_ALL OUTSIDE BY 0.0005
 nw_jog_TMP = (nw_jog_ALL COIN EDGE (nw_jog_EXP_a WITH EDGE nw_err_RAW)) COIN EDGE (nw_jog_EXP_b WITH EDGE nw_err_RAW)
 nw_jog_EXP = ((VERTEX (EXPAND EDGE nw_jog_TMP OUTSIDE BY 0.001 EXTEND BY 0.001) == 4) OR (EXPAND EDGE nw_err_RAW OUTSIDE BY 0.001)) NOT NW
 nw_err_PRL = DFM PROPERTY nw_jog_EXP nw_err_RAW OVERLAP ABUT ALSO MULTI [-= LENGTH(nw_err_RAW)] > NW_S_3a_PRL
 err1 = EXT (nw_err_RAW TOUCH EDGE nw_err_PRL) NW < NW_S_3a_val ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE INST
}

NW_S_4a {
@ Space between core NWs at different net, except INST region >= 0.38um
 err1 = EXT LVNW < 0.38 ABUT<90 SINGULAR REGION NOT CONNECTED
 err1 NOT INSIDE INST
}

VARIABLE NW_S_4b_val 0.475
VARIABLE NW_S_4b_PRL 0.365-GLOBAL_TOLERANCE

NW_S_4b {
@ Space between core NWs at different net when PRL >= 0.365um. >= 0.475um
 err1_TMP_a = EXT (NW INTERACT LVNW) < NW_S_4b_val NOT CONNECTED OPPOSITE
 err1_TMP_b = EXT (NW INTERACT LVNW) < NW_S_4b_val NOT CONNECTED OPPOSITE REGION
//; err1 = DFM PROPERTY err1_TMP_b err1_TMP_a OVERLAP ABUT ALSO MULTI [-= EC(err1_TMP_a)] > NW_S_4b_PRL

 nw_wid_all = NW INTERACT LVNW
 nw_err_RAW = EXT [nw_wid_all] < NW_S_4b_val ABUT<90 NOT CONNECTED OPPOSITE
 nw_jog_ALL = (CONVEX EDGE nw_wid_all == 1) NOT COIN EDGE nw_err_RAW
 nw_jog_EXP_a = EXPAND EDGE nw_jog_ALL INSIDE BY 0.0005
 nw_jog_EXP_b = EXPAND EDGE nw_jog_ALL OUTSIDE BY 0.0005
 nw_jog_TMP = (nw_jog_ALL COIN EDGE (nw_jog_EXP_a WITH EDGE nw_err_RAW)) COIN EDGE (nw_jog_EXP_b WITH EDGE nw_err_RAW)
 nw_jog_EXP = ((VERTEX (EXPAND EDGE nw_jog_TMP OUTSIDE BY 0.001 EXTEND BY 0.001) == 4) OR (EXPAND EDGE nw_err_RAW OUTSIDE BY 0.001)) NOT nw_wid_all
 nw_err_PRL = DFM PROPERTY nw_jog_EXP nw_err_RAW OVERLAP ABUT ALSO MULTI [-= LENGTH(nw_err_RAW)] > NW_S_4b_PRL
 err1 = EXT (nw_err_RAW TOUCH EDGE nw_err_PRL) nw_wid_all < NW_S_4b_val ABUT<90 NOT CONNECTED OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

NW_S_4c {
@ Space between core NW and IO_NW at different net >= 0.896um
 err1 = EXT LVNW HVNW < 0.896 ABUT<90 SINGULAR REGION NOT CONNECTED
 err1 NOT INSIDE SealR_NOT_BULK
}

NW_S_4d {
@ Space between IO_NWs at different net >= 0.896um
 err1 = EXT HVNW < 0.896 ABUT<90 SINGULAR REGION NOT CONNECTED
 err1 NOT INSIDE SealR_NOT_BULK
}

NW_S_6a {
@ Space between NW and DOP_AA (DOP_AA CUT NW is not allowed), except ((DOP_AA INSIDE DMCB1) NOT DMC1) >= 0.048um
 chk_DOP_AA = DOP_AA NOT ((DOP_AA INSIDE DMCB1) NOT DMC1)
 err1 = EXT NW chk_DOP_AA < 0.048 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK

 err2 = NW INSIDE EDGE DOP_AA
 err2 NOT INSIDE EDGE SealR_NOT_BULK
}

NW_S_6b {
@ Space between NW and DOP_AA (AA vertical edge extend 1/2 GT width) in S/D direction (DOP_AA CUT NW is not allowed), except ((DOP_AA INSIDE DMCB1) NOT DMC1) >= 0.065um
 chk_DOP_AA = edge_gate_dopAA_all NOT ((edge_gate_dopAA_all INSIDE DMCB1) NOT DMC1)
 err1 = EXT NW_v_edges chk_DOP_AA < 0.065 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK

 err2 = NW INSIDE EDGE edge_gate_dopAA_all
 err2 NOT INSIDE EDGE SealR_NOT_BULK
}

NW_EN_1 {
@ NW enclosure of DOP_AA (Except Dummy_Cell_WO_IMP) >= 0.048um
 err1 = ENC (DOP_AA AND NW) NW < 0.048 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE Dummy_Cell_WO_IMP
}

NW_EN_1a {
@ NW enclosure of DOP_AA (AA vertical edge extend 1/2 GT width) in S/D direction, except Dummy_Cell_WO_IMP >= 0.065um
 err1 = ENC (edge_gate_dopAA_all AND NW) NW_v_edges < 0.065 ABUT<90 OPPOSITE REGION EXCLUDE SHIELDED
 err1 NOT INSIDE Dummy_Cell_WO_IMP
}

NW_A_1 {
@ NW area, except 1.546um*0.196um NW in INST region >= 0.32um2
 WAIVE_AREA = (NW INSIDE INST) RECTANGLE == 0.196 BY == 1.546
 err1 = AREA (NW NOT WAIVE_AREA) < NW_MiniArea
 err1 NOT INSIDE SealR_NOT_BULK
}

NW_A_2 {
@ Area of Core_NW, Core_PW, IO_NW, IO_PW, except 1.546um*0.196um Core_NW in INST region >= 0.32um2
 WAIVE_AREA = (Core_NW INSIDE INST) RECTANGLE == 0.196 BY == 1.546
 err1 = AREA (Core_NW NOT WAIVE_AREA) < NW_MiniArea
 err2 = AREA Core_PW < NW_MiniArea
 err3 = AREA IO_NW < NW_MiniArea
 err4 = AREA IO_PW < NW_MiniArea

 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
 err4 NOT INSIDE SealR_NOT_BULK
}

NW_A_3 {
@ NW enclosed area >= 0.32um2
 err1 = AREA ((HOLES NW INNER) NOT NW) < NW_MiniArea
 err1 NOT INSIDE SealR_NOT_BULK
}

NW_A_4 {
@ Enclosed area of Core_NW, Core_PW, IO_NW, IO_PW, except Core_PW enclosed area is 1.546um*0.196um in INST region >= 0.32um2
 WAIVE_AREA = (((HOLES Core_PW INNER) NOT Core_PW) INSIDE INST) RECTANGLE == 0.196 BY == 1.546
 err1 = AREA ((HOLES Core_NW INNER) NOT Core_NW) < NW_MiniArea
 err2 = AREA (((HOLES Core_PW INNER) NOT Core_PW) NOT WAIVE_AREA) < NW_MiniArea
 err3 = AREA ((HOLES IO_NW INNER) NOT IO_NW) < NW_MiniArea
 err4 = AREA ((HOLES IO_PW INNER) NOT IO_PW) < NW_MiniArea

 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
 err4 NOT INSIDE SealR_NOT_BULK
}

//;NW.R.1.NC: Unintentional floating well is not recommend to avoid unstable device performance

VARIABLE NW_S_5_val 1.75
VARIABLE NW_R_2_NW_2_NW_val 1.8
VARIABLE NW_R_2_NW_2_pickup_val 1.65
VARIABLE NW_R_2_PW_2_pickup_val 1.65

#IFDEF Delta_Voltage_Rules_Check YES
NW_S_5 {
@ Space between NWs (maximum delta V > 3.63V, 3.3V+10%) >= 1.75um
 err1 = DFM DV NW < NW_S_5_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 3.63 ANNOTATE NOT CONNECTED SINGULAR
 DFM COPY err1
}

NW_R_2_NW_2_NW {
@ Maximum delta V >= 5.6V is not allowed, When:
@ 1. Space between NWs is < 1.8um
@ 2. Space between NW and N+AA/P+ pick-up AA is < 1.65um
@ 3. Space between PW and P+AA/N+ pick-up AA is < 1.65um
 err1 = DFM DV NW < NW_R_2_NW_2_NW_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" >= 5.6 ANNOTATE NOT CONNECTED SINGULAR
 DFM COPY err1
}

NW_R_2_NW_2_pickup {
@ Maximum delta V >= 5.6V is not allowed, When:
@ 1. Space between NWs is < 1.8um
@ 2. Space between NW and N+AA/P+ pick-up AA is < 1.65um
@ 3. Space between PW and P+AA/N+ pick-up AA is < 1.65um
 err1 = DFM DV NSD NW < NW_R_2_NW_2_pickup_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" >= 5.6 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 err2 = DFM DV PTAP NW < NW_R_2_NW_2_pickup_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" >= 5.6 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err1 err2
}

NW_R_2_PW_2_pickup {
@ Maximum delta V >= 5.6V is not allowed, When:
@ 1. Space between NWs is < 1.8um
@ 2. Space between NW and N+AA/P+ pick-up AA is < 1.65um
@ 3. Space between PW and P+AA/N+ pick-up AA is < 1.65um
 err1 = DFM DV NTAP PW_0 < NW_R_2_PW_2_pickup_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" >= 5.6 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 err2 = DFM DV PSD PW_0 < NW_R_2_PW_2_pickup_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" >= 5.6 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err1 err2
}
#ENDIF


// =======================================================
// PSUB: P-substrate design rules
// =======================================================

GROUP GPSUB PSUB_?

PSUB_W_1 {
@ PSUB width >= 0.214um
 err1 = INT PSUB < 0.214 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

PSUB_S_1 {
@ Space between two PSUBs >= 0.214um
 err1 = EXT PSUB < 0.214 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

PSUB_S_2 {
@ Space between PSUB and AA >= 0.34um
 err1 = EXT PSUB AA < 0.34 ABUT<90 SINGULAR REGION MEASURE ALL
 err1 NOT INSIDE SealR_NOT_BULK
}

PSUB_S_3 {
@ Space between PSUB and NW >= 0.718um
 err1 = EXT PSUB NW < 0.718 ABUT<90 SINGULAR REGION MEASURE ALL
 err1 NOT INSIDE SealR_NOT_BULK
}

PSUB_A_1 {
@ PSUB area >= 0.32um2
 err1 = AREA PSUB < 0.32
 err1 NOT INSIDE SealR_NOT_BULK
}

PSUB_A_2 {
@ PSUB enclosed area >= 0.32um2
 err1 = AREA ((HOLES PSUB INNER) NOT PSUB) < 0.32
 err1 NOT INSIDE SealR_NOT_BULK
}

PSUB_R_1 {
@ PSUB overlap (NW OR DNW) is not allowed
 err1 = PSUB AND (NW OR DNW)
 err1 NOT INSIDE SealR_NOT_BULK
}

PSUB_R_2 {
@ PSUB overlap (GATE NOT GTMK2) is not allowed, except ESD region
 err1 = (PSUB AND (GATE NOT GTMK2)) NOT INSIDE ESDIO_all
 err1 NOT INSIDE SealR_NOT_BULK
}

PSUB_R_3 {
@ AA cut PSUB is not allowed
 err1 = PSUB INSIDE EDGE AA
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

// =======================================================
// VT_N/P: N/P-type Vt MOS procedures
// =======================================================
//;Layer derivations for VT rules

ALL_GT_NOT_P2_not_jog_lteq_002 = ALL_GT_NOT_P2 NOT COIN EDGE ALL_GT_NOT_P2_jog_lteq_002
ALL_GT_NOT_P2_not_jog_lteq_003 = ALL_GT_NOT_P2 NOT COIN EDGE ALL_GT_NOT_P2_jog_lteq_003
ALL_GT_NOT_P2_not_jog_lteq_004 = ALL_GT_NOT_P2 NOT COIN EDGE ALL_GT_NOT_P2_jog_lteq_004
GATE_GT_P96_Lg = GATE_GT_P96 COIN EDGE AA

ALL_SVT = SVT_N OR SVT_P
ALL_LVT = LVT_N OR LVT_P
ALL_HVT = HVT_N OR HVT_P
ALL_LFN = LFN_N OR LFN_P
ALL_ULVT = ULVT_N OR ULVT_P
ALL_VT_N_IMP = OR SVT_N LVT_N HVT_N ULVT_N LFN_N
ALL_VT_P_IMP = OR SVT_P LVT_P HVT_P ULVT_P LFN_P
ALL_VT_IMP = OR ALL_VT_N_IMP ALL_VT_P_IMP

ALL_SVT_HVT = OR SVT_N SVT_P HVT_N HVT_P
ALL_HVT_N_SVT_N = OR HVT_N SVT_N

//;derivation of orthogonal VT corners
SVT_N_convex_corner = INT SVT_N <= 0.001 ABUT==90 INTERSECTING ONLY REGION
SVT_P_convex_corner = INT SVT_P <= 0.001 ABUT==90 INTERSECTING ONLY REGION
LVT_N_convex_corner = INT LVT_N <= 0.001 ABUT==90 INTERSECTING ONLY REGION
LVT_P_convex_corner = INT LVT_P <= 0.001 ABUT==90 INTERSECTING ONLY REGION
HVT_N_convex_corner = INT HVT_N <= 0.001 ABUT==90 INTERSECTING ONLY REGION
HVT_P_convex_corner = INT HVT_P <= 0.001 ABUT==90 INTERSECTING ONLY REGION
LFN_N_convex_corner = INT LFN_N <= 0.001 ABUT==90 INTERSECTING ONLY REGION
LFN_P_convex_corner = INT LFN_P <= 0.001 ABUT==90 INTERSECTING ONLY REGION
ULVT_N_convex_corner = INT ULVT_N <= 0.001 ABUT==90 INTERSECTING ONLY REGION
ULVT_P_convex_corner = INT ULVT_P <= 0.001 ABUT==90 INTERSECTING ONLY REGION

SVT_N_concave_corner = EXT SVT_N <= 0.001 ABUT==90 INTERSECTING ONLY REGION
SVT_P_concave_corner = EXT SVT_P <= 0.001 ABUT==90 INTERSECTING ONLY REGION
LVT_N_concave_corner = EXT LVT_N <= 0.001 ABUT==90 INTERSECTING ONLY REGION
LVT_P_concave_corner = EXT LVT_P <= 0.001 ABUT==90 INTERSECTING ONLY REGION
HVT_N_concave_corner = EXT HVT_N <= 0.001 ABUT==90 INTERSECTING ONLY REGION
HVT_P_concave_corner = EXT HVT_P <= 0.001 ABUT==90 INTERSECTING ONLY REGION
LFN_N_concave_corner = EXT LFN_N <= 0.001 ABUT==90 INTERSECTING ONLY REGION
LFN_P_concave_corner = EXT LFN_P <= 0.001 ABUT==90 INTERSECTING ONLY REGION
ULVT_N_concave_corner = EXT ULVT_N <= 0.001 ABUT==90 INTERSECTING ONLY REGION
ULVT_P_concave_corner = EXT ULVT_P <= 0.001 ABUT==90 INTERSECTING ONLY REGION

ALL_SVT_convex_corner = INT ALL_SVT <= 0.001 ABUT==90 INTERSECTING ONLY REGION
ALL_LVT_convex_corner = INT ALL_LVT <= 0.001 ABUT==90 INTERSECTING ONLY REGION
ALL_HVT_convex_corner = INT ALL_HVT <= 0.001 ABUT==90 INTERSECTING ONLY REGION
ALL_LFN_convex_corner = INT ALL_LFN <= 0.001 ABUT==90 INTERSECTING ONLY REGION
ALL_ULVT_convex_corner = INT ALL_ULVT <= 0.001 ABUT==90 INTERSECTING ONLY REGION

ALL_SVT_concave_corner = EXT ALL_SVT <= 0.001 ABUT==90 INTERSECTING ONLY REGION
ALL_LVT_concave_corner = EXT ALL_LVT <= 0.001 ABUT==90 INTERSECTING ONLY REGION
ALL_HVT_concave_corner = EXT ALL_HVT <= 0.001 ABUT==90 INTERSECTING ONLY REGION
ALL_LFN_concave_corner = EXT ALL_LFN <= 0.001 ABUT==90 INTERSECTING ONLY REGION
ALL_ULVT_concave_corner = EXT ALL_ULVT <= 0.001 ABUT==90 INTERSECTING ONLY REGION

ALL_SVT_HVT_convex_corner = INT ALL_SVT_HVT <= 0.001 ABUT==90 INTERSECTING ONLY REGION
ALL_HVT_N_SVT_N_convex_corner = INT ALL_HVT_N_SVT_N <= 0.001 ABUT==90 INTERSECTING ONLY REGION

ALL_SVT_HVT_concave_corner = EXT ALL_SVT_HVT <= 0.001 ABUT==90 INTERSECTING ONLY REGION
ALL_HVT_N_SVT_N_concave_corner = EXT ALL_HVT_N_SVT_N <= 0.001 ABUT==90 INTERSECTING ONLY REGION
//;end of the derivation

//;derivation of orthogonal VT edges
SVT_N_v_edges = ANGLE SVT_N == 90
SVT_N_h_edges = ANGLE SVT_N == 0
SVT_P_v_edges = ANGLE SVT_P == 90
SVT_P_h_edges = ANGLE SVT_P == 0

LVT_N_v_edges = ANGLE LVT_N == 90
LVT_N_h_edges = ANGLE LVT_N == 0
LVT_P_v_edges = ANGLE LVT_P == 90
LVT_P_h_edges = ANGLE LVT_P == 0

HVT_N_v_edges = ANGLE HVT_N == 90
HVT_N_h_edges = ANGLE HVT_N == 0
HVT_P_v_edges = ANGLE HVT_P == 90
HVT_P_h_edges = ANGLE HVT_P == 0

LFN_N_v_edges = ANGLE LFN_N == 90
LFN_N_h_edges = ANGLE LFN_N == 0
LFN_P_v_edges = ANGLE LFN_P == 90
LFN_P_h_edges = ANGLE LFN_P == 0

ULVT_N_v_edges = ANGLE ULVT_N == 90
ULVT_N_h_edges = ANGLE ULVT_N == 0
ULVT_P_v_edges = ANGLE ULVT_P == 90
ULVT_P_h_edges = ANGLE ULVT_P == 0

ALL_SVT_v_edges = ANGLE ALL_SVT == 90
ALL_SVT_h_edges = ANGLE ALL_SVT == 0
ALL_LVT_v_edges = ANGLE ALL_LVT == 90
ALL_LVT_h_edges = ANGLE ALL_LVT == 0
ALL_HVT_v_edges = ANGLE ALL_HVT == 90
ALL_HVT_h_edges = ANGLE ALL_HVT == 0
ALL_LFN_v_edges = ANGLE ALL_LFN == 90
ALL_LFN_h_edges = ANGLE ALL_LFN == 0
ALL_ULVT_v_edges = ANGLE ALL_ULVT == 90
ALL_ULVT_h_edges = ANGLE ALL_ULVT == 0

ALL_SVT_HVT_v_edges = ANGLE ALL_SVT_HVT == 90
ALL_SVT_HVT_h_edges = ANGLE ALL_SVT_HVT == 0
ALL_HVT_N_SVT_N_v_edges = ANGLE ALL_HVT_N_SVT_N == 90
ALL_HVT_N_SVT_N_h_edges = ANGLE ALL_HVT_N_SVT_N == 0
//;end of the derivation

GATE_LE_14_in_GT_P96 = GATE_LE_14 WITH EDGE GATE_GT_P96_Lg
GATE_LE_16_in_GT_P96 = GATE_LE_16 WITH EDGE GATE_GT_P96_Lg
GATE_LE_18_in_GT_P96 = GATE_LE_18 WITH EDGE GATE_GT_P96_Lg
GATE_LE_20_in_GT_P96 = GATE_LE_20 WITH EDGE GATE_GT_P96_Lg
GATE_LE_22_in_GT_P96 = GATE_LE_22 WITH EDGE GATE_GT_P96_Lg
GATE_LE_24_in_GT_P96 = GATE_LE_24 WITH EDGE GATE_GT_P96_Lg

//;derivation of VT convex edge
SVT_N_convex_90_270_eqgt_073_lteq_149 = CONVEX EDGE SVT_N ANGLE1 == 90 ANGLE2 == 270 WITH LENGTH >= 0.073 <= 0.149
SVT_N_convex_90_270_eqgt_073_lteq_149_v_edges = ANGLE SVT_N_convex_90_270_eqgt_073_lteq_149 == 90
SVT_P_convex_90_270_eqgt_073_lteq_149 = CONVEX EDGE SVT_P ANGLE1 == 90 ANGLE2 == 270 WITH LENGTH >= 0.073 <= 0.149
SVT_P_convex_90_270_eqgt_073_lteq_149_v_edges = ANGLE SVT_P_convex_90_270_eqgt_073_lteq_149 == 90

LVT_N_convex_90_270_eqgt_073_lteq_149 = CONVEX EDGE LVT_N ANGLE1 == 90 ANGLE2 == 270 WITH LENGTH >= 0.073 <= 0.149
LVT_N_convex_90_270_eqgt_073_lteq_149_v_edges = ANGLE LVT_N_convex_90_270_eqgt_073_lteq_149 == 90
LVT_P_convex_90_270_eqgt_073_lteq_149 = CONVEX EDGE LVT_P ANGLE1 == 90 ANGLE2 == 270 WITH LENGTH >= 0.073 <= 0.149
LVT_P_convex_90_270_eqgt_073_lteq_149_v_edges = ANGLE LVT_P_convex_90_270_eqgt_073_lteq_149 == 90

HVT_N_convex_90_270_eqgt_073_lteq_149 = CONVEX EDGE HVT_N ANGLE1 == 90 ANGLE2 == 270 WITH LENGTH >= 0.073 <= 0.149
HVT_N_convex_90_270_eqgt_073_lteq_149_v_edges = ANGLE HVT_N_convex_90_270_eqgt_073_lteq_149 == 90
HVT_P_convex_90_270_eqgt_073_lteq_149 = CONVEX EDGE HVT_P ANGLE1 == 90 ANGLE2 == 270 WITH LENGTH >= 0.073 <= 0.149
HVT_P_convex_90_270_eqgt_073_lteq_149_v_edges = ANGLE HVT_P_convex_90_270_eqgt_073_lteq_149 == 90

LFN_N_convex_90_270_eqgt_073_lteq_149 = CONVEX EDGE LFN_N ANGLE1 == 90 ANGLE2 == 270 WITH LENGTH >= 0.073 <= 0.149
LFN_N_convex_90_270_eqgt_073_lteq_149_v_edges = ANGLE LFN_N_convex_90_270_eqgt_073_lteq_149 == 90
LFN_P_convex_90_270_eqgt_073_lteq_149 = CONVEX EDGE LFN_P ANGLE1 == 90 ANGLE2 == 270 WITH LENGTH >= 0.073 <= 0.149
LFN_P_convex_90_270_eqgt_073_lteq_149_v_edges = ANGLE LFN_P_convex_90_270_eqgt_073_lteq_149 == 90

ULVT_N_convex_90_270_eqgt_073_lteq_149 = CONVEX EDGE ULVT_N ANGLE1 == 90 ANGLE2 == 270 WITH LENGTH >= 0.073 <= 0.149
ULVT_N_convex_90_270_eqgt_073_lteq_149_v_edges = ANGLE ULVT_N_convex_90_270_eqgt_073_lteq_149 == 90
ULVT_P_convex_90_270_eqgt_073_lteq_149 = CONVEX EDGE ULVT_P ANGLE1 == 90 ANGLE2 == 270 WITH LENGTH >= 0.073 <= 0.149
ULVT_P_convex_90_270_eqgt_073_lteq_149_v_edges = ANGLE ULVT_P_convex_90_270_eqgt_073_lteq_149 == 90

SVT_N_convex_90_270_eqgt_073_lteq_150 = CONVEX EDGE SVT_N ANGLE1 == 90 ANGLE2 == 270 WITH LENGTH >= 0.073 <= 0.150
SVT_N_convex_90_270_eqgt_073_lteq_150_v_edges = ANGLE SVT_N_convex_90_270_eqgt_073_lteq_150 == 90
SVT_P_convex_90_270_eqgt_073_lteq_150 = CONVEX EDGE SVT_P ANGLE1 == 90 ANGLE2 == 270 WITH LENGTH >= 0.073 <= 0.150
SVT_P_convex_90_270_eqgt_073_lteq_150_v_edges = ANGLE SVT_P_convex_90_270_eqgt_073_lteq_150 == 90

LVT_N_convex_90_270_eqgt_073_lteq_150 = CONVEX EDGE LVT_N ANGLE1 == 90 ANGLE2 == 270 WITH LENGTH >= 0.073 <= 0.150
LVT_N_convex_90_270_eqgt_073_lteq_150_v_edges = ANGLE LVT_N_convex_90_270_eqgt_073_lteq_150 == 90
LVT_P_convex_90_270_eqgt_073_lteq_150 = CONVEX EDGE LVT_P ANGLE1 == 90 ANGLE2 == 270 WITH LENGTH >= 0.073 <= 0.150
LVT_P_convex_90_270_eqgt_073_lteq_150_v_edges = ANGLE LVT_P_convex_90_270_eqgt_073_lteq_150 == 90

HVT_N_convex_90_270_eqgt_073_lteq_150 = CONVEX EDGE HVT_N ANGLE1 == 90 ANGLE2 == 270 WITH LENGTH >= 0.073 <= 0.150
HVT_N_convex_90_270_eqgt_073_lteq_150_v_edges = ANGLE HVT_N_convex_90_270_eqgt_073_lteq_150 == 90
HVT_P_convex_90_270_eqgt_073_lteq_150 = CONVEX EDGE HVT_P ANGLE1 == 90 ANGLE2 == 270 WITH LENGTH >= 0.073 <= 0.150
HVT_P_convex_90_270_eqgt_073_lteq_150_v_edges = ANGLE HVT_P_convex_90_270_eqgt_073_lteq_150 == 90

LFN_N_convex_90_270_eqgt_073_lteq_150 = CONVEX EDGE LFN_N ANGLE1 == 90 ANGLE2 == 270 WITH LENGTH >= 0.073 <= 0.150
LFN_N_convex_90_270_eqgt_073_lteq_150_v_edges = ANGLE LFN_N_convex_90_270_eqgt_073_lteq_150 == 90
LFN_P_convex_90_270_eqgt_073_lteq_150 = CONVEX EDGE LFN_P ANGLE1 == 90 ANGLE2 == 270 WITH LENGTH >= 0.073 <= 0.150
LFN_P_convex_90_270_eqgt_073_lteq_150_v_edges = ANGLE LFN_P_convex_90_270_eqgt_073_lteq_150 == 90

ULVT_N_convex_90_270_eqgt_073_lteq_150 = CONVEX EDGE ULVT_N ANGLE1 == 90 ANGLE2 == 270 WITH LENGTH >= 0.073 <= 0.150
ULVT_N_convex_90_270_eqgt_073_lteq_150_v_edges = ANGLE ULVT_N_convex_90_270_eqgt_073_lteq_150 == 90
ULVT_P_convex_90_270_eqgt_073_lteq_150 = CONVEX EDGE ULVT_P ANGLE1 == 90 ANGLE2 == 270 WITH LENGTH >= 0.073 <= 0.150
ULVT_P_convex_90_270_eqgt_073_lteq_150_v_edges = ANGLE ULVT_P_convex_90_270_eqgt_073_lteq_150 == 90

SVT_N_convex_90_270_eqgt_072_lteq_150 = CONVEX EDGE SVT_N ANGLE1 == 90 ANGLE2 == 270 WITH LENGTH >= 0.072 <= 0.150
SVT_N_convex_90_270_eqgt_072_lteq_150_v_edges = ANGLE SVT_N_convex_90_270_eqgt_072_lteq_150 == 90
SVT_P_convex_90_270_eqgt_072_lteq_150 = CONVEX EDGE SVT_P ANGLE1 == 90 ANGLE2 == 270 WITH LENGTH >= 0.072 <= 0.150
SVT_P_convex_90_270_eqgt_072_lteq_150_v_edges = ANGLE SVT_P_convex_90_270_eqgt_072_lteq_150 == 90

LVT_N_convex_90_270_eqgt_072_lteq_150 = CONVEX EDGE LVT_N ANGLE1 == 90 ANGLE2 == 270 WITH LENGTH >= 0.072 <= 0.150
LVT_N_convex_90_270_eqgt_072_lteq_150_v_edges = ANGLE LVT_N_convex_90_270_eqgt_072_lteq_150 == 90
LVT_P_convex_90_270_eqgt_072_lteq_150 = CONVEX EDGE LVT_P ANGLE1 == 90 ANGLE2 == 270 WITH LENGTH >= 0.072 <= 0.150
LVT_P_convex_90_270_eqgt_072_lteq_150_v_edges = ANGLE LVT_P_convex_90_270_eqgt_072_lteq_150 == 90

HVT_N_convex_90_270_eqgt_072_lteq_150 = CONVEX EDGE HVT_N ANGLE1 == 90 ANGLE2 == 270 WITH LENGTH >= 0.072 <= 0.150
HVT_N_convex_90_270_eqgt_072_lteq_150_v_edges = ANGLE HVT_N_convex_90_270_eqgt_072_lteq_150 == 90
HVT_P_convex_90_270_eqgt_072_lteq_150 = CONVEX EDGE HVT_P ANGLE1 == 90 ANGLE2 == 270 WITH LENGTH >= 0.072 <= 0.150
HVT_P_convex_90_270_eqgt_072_lteq_150_v_edges = ANGLE HVT_P_convex_90_270_eqgt_072_lteq_150 == 90

LFN_N_convex_90_270_eqgt_072_lteq_150 = CONVEX EDGE LFN_N ANGLE1 == 90 ANGLE2 == 270 WITH LENGTH >= 0.072 <= 0.150
LFN_N_convex_90_270_eqgt_072_lteq_150_v_edges = ANGLE LFN_N_convex_90_270_eqgt_072_lteq_150 == 90
LFN_P_convex_90_270_eqgt_072_lteq_150 = CONVEX EDGE LFN_P ANGLE1 == 90 ANGLE2 == 270 WITH LENGTH >= 0.072 <= 0.150
LFN_P_convex_90_270_eqgt_072_lteq_150_v_edges = ANGLE LFN_P_convex_90_270_eqgt_072_lteq_150 == 90

ULVT_N_convex_90_270_eqgt_072_lteq_150 = CONVEX EDGE ULVT_N ANGLE1 == 90 ANGLE2 == 270 WITH LENGTH >= 0.072 <= 0.150
ULVT_N_convex_90_270_eqgt_072_lteq_150_v_edges = ANGLE ULVT_N_convex_90_270_eqgt_072_lteq_150 == 90
ULVT_P_convex_90_270_eqgt_072_lteq_150 = CONVEX EDGE ULVT_P ANGLE1 == 90 ANGLE2 == 270 WITH LENGTH >= 0.072 <= 0.150
ULVT_P_convex_90_270_eqgt_072_lteq_150_v_edges = ANGLE ULVT_P_convex_90_270_eqgt_072_lteq_150 == 90

//;for VT_N/P_S_2a/2b/2c
SVT_N_inside_AA_side_mark_v_edges = ANGLE (SVT_N INSIDE EDGE gtmk1_or_ar) == 90
SVT_P_inside_AA_side_mark_v_edges = ANGLE (SVT_P INSIDE EDGE gtmk1_or_ar) == 90
LVT_N_inside_AA_side_mark_v_edges = ANGLE (LVT_N INSIDE EDGE gtmk1_or_ar) == 90
LVT_P_inside_AA_side_mark_v_edges = ANGLE (LVT_P INSIDE EDGE gtmk1_or_ar) == 90
HVT_N_inside_AA_side_mark_v_edges = ANGLE (HVT_N INSIDE EDGE gtmk1_or_ar) == 90
HVT_P_inside_AA_side_mark_v_edges = ANGLE (HVT_P INSIDE EDGE gtmk1_or_ar) == 90
LFN_N_inside_AA_side_mark_v_edges = ANGLE (LFN_N INSIDE EDGE gtmk1_or_ar) == 90
LFN_P_inside_AA_side_mark_v_edges = ANGLE (LFN_P INSIDE EDGE gtmk1_or_ar) == 90
ULVT_N_inside_AA_side_mark_v_edges = ANGLE (ULVT_N INSIDE EDGE gtmk1_or_ar) == 90
ULVT_P_inside_AA_side_mark_v_edges = ANGLE (ULVT_P INSIDE EDGE gtmk1_or_ar) == 90

//;for VT_N/P_W_4
SVT_N_convex_eq_1_edges = CONVEX EDGE SVT_N == 1
SVT_P_convex_eq_1_edges = CONVEX EDGE SVT_P == 1
LVT_N_convex_eq_1_edges = CONVEX EDGE LVT_N == 1
LVT_P_convex_eq_1_edges = CONVEX EDGE LVT_P == 1
HVT_N_convex_eq_1_edges = CONVEX EDGE HVT_N == 1
HVT_P_convex_eq_1_edges = CONVEX EDGE HVT_P == 1
LFN_N_convex_eq_1_edges = CONVEX EDGE LFN_N == 1
LFN_P_convex_eq_1_edges = CONVEX EDGE LFN_P == 1
ULVT_N_convex_eq_1_edges = CONVEX EDGE ULVT_N == 1
ULVT_P_convex_eq_1_edges = CONVEX EDGE ULVT_P == 1
ALL_SVT_convex_eq_1_edges = CONVEX EDGE ALL_SVT == 1
ALL_LVT_convex_eq_1_edges = CONVEX EDGE ALL_LVT == 1
ALL_HVT_convex_eq_1_edges = CONVEX EDGE ALL_HVT == 1
ALL_ULVT_convex_eq_1_edges = CONVEX EDGE ALL_ULVT == 1

ALL_SVT_HVT_convex_eq_1_edges = CONVEX EDGE ALL_SVT_HVT == 1
ALL_HVT_N_SVT_N_convex_eq_1_edges = CONVEX EDGE ALL_HVT_N_SVT_N == 1

SVT_N_convex_eqlt_1_edges = CONVEX EDGE SVT_N <= 1
SVT_P_convex_eqlt_1_edges = CONVEX EDGE SVT_P <= 1
LVT_N_convex_eqlt_1_edges = CONVEX EDGE LVT_N <= 1
LVT_P_convex_eqlt_1_edges = CONVEX EDGE LVT_P <= 1
HVT_N_convex_eqlt_1_edges = CONVEX EDGE HVT_N <= 1
HVT_P_convex_eqlt_1_edges = CONVEX EDGE HVT_P <= 1
LFN_N_convex_eqlt_1_edges = CONVEX EDGE LFN_N <= 1
LFN_P_convex_eqlt_1_edges = CONVEX EDGE LFN_P <= 1
ULVT_N_convex_eqlt_1_edges = CONVEX EDGE ULVT_N <= 1
ULVT_P_convex_eqlt_1_edges = CONVEX EDGE ULVT_P <= 1
ALL_SVT_convex_eqlt_1_edges = CONVEX EDGE ALL_SVT <= 1
ALL_LVT_convex_eqlt_1_edges = CONVEX EDGE ALL_LVT <= 1
ALL_HVT_convex_eqlt_1_edges = CONVEX EDGE ALL_HVT <= 1
ALL_ULVT_convex_eqlt_1_edges = CONVEX EDGE ALL_ULVT <= 1

ALL_SVT_HVT_convex_eqlt_1_edges = CONVEX EDGE ALL_SVT_HVT <= 1
ALL_HVT_N_SVT_N_convex_eqlt_1_edges = CONVEX EDGE ALL_HVT_N_SVT_N <= 1

SVT_N_convex_eq_0_edges = CONVEX EDGE SVT_N == 0
SVT_P_convex_eq_0_edges = CONVEX EDGE SVT_P == 0
LVT_N_convex_eq_0_edges = CONVEX EDGE LVT_N == 0
LVT_P_convex_eq_0_edges = CONVEX EDGE LVT_P == 0
HVT_N_convex_eq_0_edges = CONVEX EDGE HVT_N == 0
HVT_P_convex_eq_0_edges = CONVEX EDGE HVT_P == 0
LFN_N_convex_eq_0_edges = CONVEX EDGE LFN_N == 0
LFN_P_convex_eq_0_edges = CONVEX EDGE LFN_P == 0
ULVT_N_convex_eq_0_edges = CONVEX EDGE ULVT_N == 0
ULVT_P_convex_eq_0_edges = CONVEX EDGE ULVT_P == 0
ALL_SVT_convex_eq_0_edges = CONVEX EDGE ALL_SVT == 0
ALL_LVT_convex_eq_0_edges = CONVEX EDGE ALL_LVT == 0
ALL_HVT_convex_eq_0_edges = CONVEX EDGE ALL_HVT == 0
ALL_ULVT_convex_eq_0_edges = CONVEX EDGE ALL_ULVT == 0

ALL_SVT_HVT_convex_eq_0_edges = CONVEX EDGE ALL_SVT_HVT == 0
ALL_HVT_N_SVT_N_convex_eq_0_edges = CONVEX EDGE ALL_HVT_N_SVT_N == 0

//;for VT.W.4/4a/5,VT.S.5/5a
SVT_N_h_edges_singular_point = SVT_N_h_edges COIN EDGE (SVT_N_concave_corner INTERACT SVT_N_convex_corner == 2)
SVT_P_h_edges_singular_point = SVT_P_h_edges COIN EDGE (SVT_P_concave_corner INTERACT SVT_P_convex_corner == 2)
LVT_N_h_edges_singular_point = LVT_N_h_edges COIN EDGE (LVT_N_concave_corner INTERACT LVT_N_convex_corner == 2)
LVT_P_h_edges_singular_point = LVT_P_h_edges COIN EDGE (LVT_P_concave_corner INTERACT LVT_P_convex_corner == 2)
HVT_N_h_edges_singular_point = HVT_N_h_edges COIN EDGE (HVT_N_concave_corner INTERACT HVT_N_convex_corner == 2)
HVT_P_h_edges_singular_point = HVT_P_h_edges COIN EDGE (HVT_P_concave_corner INTERACT HVT_P_convex_corner == 2)
LFN_N_h_edges_singular_point = LFN_N_h_edges COIN EDGE (LFN_N_concave_corner INTERACT LFN_N_convex_corner == 2)
LFN_P_h_edges_singular_point = LFN_P_h_edges COIN EDGE (LFN_P_concave_corner INTERACT LFN_P_convex_corner == 2)
ULVT_N_h_edges_singular_point = ULVT_N_h_edges COIN EDGE (ULVT_N_concave_corner INTERACT ULVT_N_convex_corner == 2)
ULVT_P_h_edges_singular_point = ULVT_P_h_edges COIN EDGE (ULVT_P_concave_corner INTERACT ULVT_P_convex_corner == 2)
ALL_SVT_h_edges_singular_point = ALL_SVT_h_edges COIN EDGE (ALL_SVT_concave_corner INTERACT ALL_SVT_convex_corner == 2)
ALL_LVT_h_edges_singular_point = ALL_LVT_h_edges COIN EDGE (ALL_LVT_concave_corner INTERACT ALL_LVT_convex_corner == 2)
ALL_HVT_h_edges_singular_point = ALL_HVT_h_edges COIN EDGE (ALL_HVT_concave_corner INTERACT ALL_HVT_convex_corner == 2)
ALL_ULVT_h_edges_singular_point = ALL_ULVT_h_edges COIN EDGE (ALL_ULVT_concave_corner INTERACT ALL_ULVT_convex_corner == 2)
ALL_SVT_HVT_h_edges_singular_point = ALL_SVT_HVT_h_edges COIN EDGE (ALL_SVT_HVT_concave_corner INTERACT ALL_SVT_HVT_convex_corner == 2)
ALL_HVT_N_SVT_N_h_edges_singular_point = ALL_HVT_N_SVT_N_h_edges COIN EDGE (ALL_HVT_N_SVT_N_concave_corner INTERACT ALL_HVT_N_SVT_N_convex_corner == 2)


//;270-270 convex edges filter 
SVT_N_270_270_jog_eqlt_048_eq_180 = CONVEX EDGE SVT_N ANGLE1 == 270 LENGTH1 <= 0.048 ANGLE2 == 270 WITH LENGTH == 0.180
SVT_N_270_270_jog_eqlt_048_eq_192 = CONVEX EDGE SVT_N ANGLE1 == 270 LENGTH1 <= 0.048 ANGLE2 == 270 WITH LENGTH == 0.192
SVT_N_270_270_jog_eqlt_048_eq_225 = CONVEX EDGE SVT_N ANGLE1 == 270 LENGTH1 <= 0.048 ANGLE2 == 270 WITH LENGTH == 0.225
SVT_N_270_270_jog_eqlt_048_eq_240 = CONVEX EDGE SVT_N ANGLE1 == 270 LENGTH1 <= 0.048 ANGLE2 == 270 WITH LENGTH == 0.240
SVT_N_270_270_jog_eq_002_eq_135 = CONVEX EDGE SVT_N ANGLE1 == 270 LENGTH1 == 0.002 ANGLE2 == 270 WITH LENGTH == 0.135
SVT_N_270_270_jog_eq_002_eq_144 = CONVEX EDGE SVT_N ANGLE1 == 270 LENGTH1 == 0.002 ANGLE2 == 270 WITH LENGTH == 0.144
SVT_N_270_270_jog_eqlt_048_eq_180_192 = OR EDGE SVT_N_270_270_jog_eqlt_048_eq_180 SVT_N_270_270_jog_eqlt_048_eq_192
SVT_N_270_270_jog_180_192_225_240_135_144 = ((((SVT_N_270_270_jog_eqlt_048_eq_180 OR EDGE SVT_N_270_270_jog_eqlt_048_eq_192) OR EDGE SVT_N_270_270_jog_eqlt_048_eq_225) OR EDGE SVT_N_270_270_jog_eqlt_048_eq_240) OR EDGE SVT_N_270_270_jog_eq_002_eq_135) OR EDGE SVT_N_270_270_jog_eq_002_eq_144
SVT_N_270_270_jog_180_192_225_240_135_144_h_edges = ANGLE SVT_N_270_270_jog_180_192_225_240_135_144 == 0

//;90-90 convex edges filter 
SVT_N_90_90_jog_eqlt_048_eq_180 = CONVEX EDGE SVT_N ANGLE1 == 90 LENGTH1 <= 0.048 ANGLE2 == 90 WITH LENGTH == 0.180
SVT_N_90_90_jog_eqlt_048_eq_192 = CONVEX EDGE SVT_N ANGLE1 == 90 LENGTH1 <= 0.048 ANGLE2 == 90 WITH LENGTH == 0.192
SVT_N_90_90_jog_eqlt_048_eq_225 = CONVEX EDGE SVT_N ANGLE1 == 90 LENGTH1 <= 0.048 ANGLE2 == 90 WITH LENGTH == 0.225
SVT_N_90_90_jog_eqlt_048_eq_240 = CONVEX EDGE SVT_N ANGLE1 == 90 LENGTH1 <= 0.048 ANGLE2 == 90 WITH LENGTH == 0.240
SVT_N_90_90_jog_eq_002_eq_135 = CONVEX EDGE SVT_N ANGLE1 == 90 LENGTH1 == 0.002 ANGLE2 == 90 WITH LENGTH == 0.135
SVT_N_90_90_jog_eq_002_eq_144 = CONVEX EDGE SVT_N ANGLE1 == 90 LENGTH1 == 0.002 ANGLE2 == 90 WITH LENGTH == 0.144
SVT_N_90_90_jog_eqlt_048_eq_180_192 = OR EDGE SVT_N_90_90_jog_eqlt_048_eq_180 SVT_N_90_90_jog_eqlt_048_eq_192
SVT_N_90_90_jog_180_192_225_240_135_144 = ((((SVT_N_90_90_jog_eqlt_048_eq_180 OR EDGE SVT_N_90_90_jog_eqlt_048_eq_192) OR EDGE SVT_N_90_90_jog_eqlt_048_eq_225) OR EDGE SVT_N_90_90_jog_eqlt_048_eq_240) OR EDGE SVT_N_90_90_jog_eq_002_eq_135) OR EDGE SVT_N_90_90_jog_eq_002_eq_144
SVT_N_90_90_jog_180_192_225_240_135_144_h_edges = ANGLE SVT_N_90_90_jog_180_192_225_240_135_144 == 0
SVT_N_90_90_jog_180_192_225_240_135_144_v_edges = ANGLE SVT_N_90_90_jog_180_192_225_240_135_144 == 90
SVT_N_90_90_jog_180_135_144 = (SVT_N_90_90_jog_eqlt_048_eq_180 OR EDGE SVT_N_90_90_jog_eq_002_eq_135) OR EDGE SVT_N_90_90_jog_eq_002_eq_144
SVT_N_90_90_jog_192_180_135_144 = SVT_N_90_90_jog_eqlt_048_eq_192 OR EDGE ((SVT_N_90_90_jog_eqlt_048_eq_180 OR EDGE SVT_N_90_90_jog_eq_002_eq_135) OR EDGE SVT_N_90_90_jog_eq_002_eq_144)

//;reverse VT 90-90 convex edges filter 
SVT_N_rvs = DRC:1 NOT SVT_N
SVT_N_rvs_90_90_jog_eqlt_048_eq_180 = CONVEX EDGE SVT_N_rvs ANGLE1 == 90 LENGTH1 <= 0.048 ANGLE2 == 90 WITH LENGTH == 0.180
SVT_N_rvs_90_90_jog_eqlt_048_eq_192 = CONVEX EDGE SVT_N_rvs ANGLE1 == 90 LENGTH1 <= 0.048 ANGLE2 == 90 WITH LENGTH == 0.192
SVT_N_rvs_90_90_jog_eqlt_048_eq_225 = CONVEX EDGE SVT_N_rvs ANGLE1 == 90 LENGTH1 <= 0.048 ANGLE2 == 90 WITH LENGTH == 0.225
SVT_N_rvs_90_90_jog_eqlt_048_eq_240 = CONVEX EDGE SVT_N_rvs ANGLE1 == 90 LENGTH1 <= 0.048 ANGLE2 == 90 WITH LENGTH == 0.240
SVT_N_rvs_90_90_jog_eq_002_eq_135 = CONVEX EDGE SVT_N_rvs ANGLE1 == 90 LENGTH1 == 0.002 ANGLE2 == 90 WITH LENGTH == 0.135
SVT_N_rvs_90_90_jog_eq_002_eq_144 = CONVEX EDGE SVT_N_rvs ANGLE1 == 90 LENGTH1 == 0.002 ANGLE2 == 90 WITH LENGTH == 0.144
SVT_N_rvs_90_90_jog_eqlt_048_eq_180_192 = OR EDGE SVT_N_rvs_90_90_jog_eqlt_048_eq_180 SVT_N_rvs_90_90_jog_eqlt_048_eq_192
SVT_N_rvs_90_90_jog_180_192_225_240_135_144 = ((((SVT_N_rvs_90_90_jog_eqlt_048_eq_180 OR EDGE SVT_N_rvs_90_90_jog_eqlt_048_eq_192) OR EDGE SVT_N_rvs_90_90_jog_eqlt_048_eq_225) OR EDGE SVT_N_rvs_90_90_jog_eqlt_048_eq_240) OR EDGE SVT_N_rvs_90_90_jog_eq_002_eq_135) OR EDGE SVT_N_rvs_90_90_jog_eq_002_eq_144
SVT_N_rvs_90_90_jog_180_135_144 = (SVT_N_rvs_90_90_jog_eqlt_048_eq_180 OR EDGE SVT_N_rvs_90_90_jog_eq_002_eq_135) OR EDGE SVT_N_rvs_90_90_jog_eq_002_eq_144

//;270-270 convex edges filter 
SVT_P_270_270_jog_eqlt_048_eq_180 = CONVEX EDGE SVT_P ANGLE1 == 270 LENGTH1 <= 0.048 ANGLE2 == 270 WITH LENGTH == 0.180
SVT_P_270_270_jog_eqlt_048_eq_192 = CONVEX EDGE SVT_P ANGLE1 == 270 LENGTH1 <= 0.048 ANGLE2 == 270 WITH LENGTH == 0.192
SVT_P_270_270_jog_eqlt_048_eq_225 = CONVEX EDGE SVT_P ANGLE1 == 270 LENGTH1 <= 0.048 ANGLE2 == 270 WITH LENGTH == 0.225
SVT_P_270_270_jog_eqlt_048_eq_240 = CONVEX EDGE SVT_P ANGLE1 == 270 LENGTH1 <= 0.048 ANGLE2 == 270 WITH LENGTH == 0.240
SVT_P_270_270_jog_eq_002_eq_135 = CONVEX EDGE SVT_P ANGLE1 == 270 LENGTH1 == 0.002 ANGLE2 == 270 WITH LENGTH == 0.135
SVT_P_270_270_jog_eq_002_eq_144 = CONVEX EDGE SVT_P ANGLE1 == 270 LENGTH1 == 0.002 ANGLE2 == 270 WITH LENGTH == 0.144
SVT_P_270_270_jog_eqlt_048_eq_180_192 = OR EDGE SVT_P_270_270_jog_eqlt_048_eq_180 SVT_P_270_270_jog_eqlt_048_eq_192
SVT_P_270_270_jog_180_192_225_240_135_144 = ((((SVT_P_270_270_jog_eqlt_048_eq_180 OR EDGE SVT_P_270_270_jog_eqlt_048_eq_192) OR EDGE SVT_P_270_270_jog_eqlt_048_eq_225) OR EDGE SVT_P_270_270_jog_eqlt_048_eq_240) OR EDGE SVT_P_270_270_jog_eq_002_eq_135) OR EDGE SVT_P_270_270_jog_eq_002_eq_144
SVT_P_270_270_jog_180_192_225_240_135_144_h_edges = ANGLE SVT_P_270_270_jog_180_192_225_240_135_144 == 0

//;90-90 convex edges filter 
SVT_P_90_90_jog_eqlt_048_eq_180 = CONVEX EDGE SVT_P ANGLE1 == 90 LENGTH1 <= 0.048 ANGLE2 == 90 WITH LENGTH == 0.180
SVT_P_90_90_jog_eqlt_048_eq_192 = CONVEX EDGE SVT_P ANGLE1 == 90 LENGTH1 <= 0.048 ANGLE2 == 90 WITH LENGTH == 0.192
SVT_P_90_90_jog_eqlt_048_eq_225 = CONVEX EDGE SVT_P ANGLE1 == 90 LENGTH1 <= 0.048 ANGLE2 == 90 WITH LENGTH == 0.225
SVT_P_90_90_jog_eqlt_048_eq_240 = CONVEX EDGE SVT_P ANGLE1 == 90 LENGTH1 <= 0.048 ANGLE2 == 90 WITH LENGTH == 0.240
SVT_P_90_90_jog_eq_002_eq_135 = CONVEX EDGE SVT_P ANGLE1 == 90 LENGTH1 == 0.002 ANGLE2 == 90 WITH LENGTH == 0.135
SVT_P_90_90_jog_eq_002_eq_144 = CONVEX EDGE SVT_P ANGLE1 == 90 LENGTH1 == 0.002 ANGLE2 == 90 WITH LENGTH == 0.144
SVT_P_90_90_jog_eqlt_048_eq_180_192 = OR EDGE SVT_P_90_90_jog_eqlt_048_eq_180 SVT_P_90_90_jog_eqlt_048_eq_192
SVT_P_90_90_jog_180_192_225_240_135_144 = ((((SVT_P_90_90_jog_eqlt_048_eq_180 OR EDGE SVT_P_90_90_jog_eqlt_048_eq_192) OR EDGE SVT_P_90_90_jog_eqlt_048_eq_225) OR EDGE SVT_P_90_90_jog_eqlt_048_eq_240) OR EDGE SVT_P_90_90_jog_eq_002_eq_135) OR EDGE SVT_P_90_90_jog_eq_002_eq_144
SVT_P_90_90_jog_180_192_225_240_135_144_h_edges = ANGLE SVT_P_90_90_jog_180_192_225_240_135_144 == 0
SVT_P_90_90_jog_180_192_225_240_135_144_v_edges = ANGLE SVT_P_90_90_jog_180_192_225_240_135_144 == 90
SVT_P_90_90_jog_180_135_144 = (SVT_P_90_90_jog_eqlt_048_eq_180 OR EDGE SVT_P_90_90_jog_eq_002_eq_135) OR EDGE SVT_P_90_90_jog_eq_002_eq_144
SVT_P_90_90_jog_192_180_135_144 = SVT_P_90_90_jog_eqlt_048_eq_192 OR EDGE ((SVT_P_90_90_jog_eqlt_048_eq_180 OR EDGE SVT_P_90_90_jog_eq_002_eq_135) OR EDGE SVT_P_90_90_jog_eq_002_eq_144)

//;reverse VT 90-90 convex edges filter 
SVT_P_rvs = DRC:1 NOT SVT_P
SVT_P_rvs_90_90_jog_eqlt_048_eq_180 = CONVEX EDGE SVT_P_rvs ANGLE1 == 90 LENGTH1 <= 0.048 ANGLE2 == 90 WITH LENGTH == 0.180
SVT_P_rvs_90_90_jog_eqlt_048_eq_192 = CONVEX EDGE SVT_P_rvs ANGLE1 == 90 LENGTH1 <= 0.048 ANGLE2 == 90 WITH LENGTH == 0.192
SVT_P_rvs_90_90_jog_eqlt_048_eq_225 = CONVEX EDGE SVT_P_rvs ANGLE1 == 90 LENGTH1 <= 0.048 ANGLE2 == 90 WITH LENGTH == 0.225
SVT_P_rvs_90_90_jog_eqlt_048_eq_240 = CONVEX EDGE SVT_P_rvs ANGLE1 == 90 LENGTH1 <= 0.048 ANGLE2 == 90 WITH LENGTH == 0.240
SVT_P_rvs_90_90_jog_eq_002_eq_135 = CONVEX EDGE SVT_P_rvs ANGLE1 == 90 LENGTH1 == 0.002 ANGLE2 == 90 WITH LENGTH == 0.135
SVT_P_rvs_90_90_jog_eq_002_eq_144 = CONVEX EDGE SVT_P_rvs ANGLE1 == 90 LENGTH1 == 0.002 ANGLE2 == 90 WITH LENGTH == 0.144
SVT_P_rvs_90_90_jog_eqlt_048_eq_180_192 = OR EDGE SVT_P_rvs_90_90_jog_eqlt_048_eq_180 SVT_P_rvs_90_90_jog_eqlt_048_eq_192
SVT_P_rvs_90_90_jog_180_192_225_240_135_144 = ((((SVT_P_rvs_90_90_jog_eqlt_048_eq_180 OR EDGE SVT_P_rvs_90_90_jog_eqlt_048_eq_192) OR EDGE SVT_P_rvs_90_90_jog_eqlt_048_eq_225) OR EDGE SVT_P_rvs_90_90_jog_eqlt_048_eq_240) OR EDGE SVT_P_rvs_90_90_jog_eq_002_eq_135) OR EDGE SVT_P_rvs_90_90_jog_eq_002_eq_144
SVT_P_rvs_90_90_jog_180_135_144 = (SVT_P_rvs_90_90_jog_eqlt_048_eq_180 OR EDGE SVT_P_rvs_90_90_jog_eq_002_eq_135) OR EDGE SVT_P_rvs_90_90_jog_eq_002_eq_144

//;270-270 convex edges filter 
LVT_N_270_270_jog_eqlt_048_eq_180 = CONVEX EDGE LVT_N ANGLE1 == 270 LENGTH1 <= 0.048 ANGLE2 == 270 WITH LENGTH == 0.180
LVT_N_270_270_jog_eqlt_048_eq_192 = CONVEX EDGE LVT_N ANGLE1 == 270 LENGTH1 <= 0.048 ANGLE2 == 270 WITH LENGTH == 0.192
LVT_N_270_270_jog_eqlt_048_eq_225 = CONVEX EDGE LVT_N ANGLE1 == 270 LENGTH1 <= 0.048 ANGLE2 == 270 WITH LENGTH == 0.225
LVT_N_270_270_jog_eqlt_048_eq_240 = CONVEX EDGE LVT_N ANGLE1 == 270 LENGTH1 <= 0.048 ANGLE2 == 270 WITH LENGTH == 0.240
LVT_N_270_270_jog_eq_002_eq_135 = CONVEX EDGE LVT_N ANGLE1 == 270 LENGTH1 == 0.002 ANGLE2 == 270 WITH LENGTH == 0.135
LVT_N_270_270_jog_eq_002_eq_144 = CONVEX EDGE LVT_N ANGLE1 == 270 LENGTH1 == 0.002 ANGLE2 == 270 WITH LENGTH == 0.144
LVT_N_270_270_jog_eqlt_048_eq_180_192 = OR EDGE LVT_N_270_270_jog_eqlt_048_eq_180 LVT_N_270_270_jog_eqlt_048_eq_192
LVT_N_270_270_jog_180_192_225_240_135_144 = ((((LVT_N_270_270_jog_eqlt_048_eq_180 OR EDGE LVT_N_270_270_jog_eqlt_048_eq_192) OR EDGE LVT_N_270_270_jog_eqlt_048_eq_225) OR EDGE LVT_N_270_270_jog_eqlt_048_eq_240) OR EDGE LVT_N_270_270_jog_eq_002_eq_135) OR EDGE LVT_N_270_270_jog_eq_002_eq_144
LVT_N_270_270_jog_180_192_225_240_135_144_h_edges = ANGLE LVT_N_270_270_jog_180_192_225_240_135_144 == 0

//;90-90 convex edges filter 
LVT_N_90_90_jog_eqlt_048_eq_180 = CONVEX EDGE LVT_N ANGLE1 == 90 LENGTH1 <= 0.048 ANGLE2 == 90 WITH LENGTH == 0.180
LVT_N_90_90_jog_eqlt_048_eq_192 = CONVEX EDGE LVT_N ANGLE1 == 90 LENGTH1 <= 0.048 ANGLE2 == 90 WITH LENGTH == 0.192
LVT_N_90_90_jog_eqlt_048_eq_225 = CONVEX EDGE LVT_N ANGLE1 == 90 LENGTH1 <= 0.048 ANGLE2 == 90 WITH LENGTH == 0.225
LVT_N_90_90_jog_eqlt_048_eq_240 = CONVEX EDGE LVT_N ANGLE1 == 90 LENGTH1 <= 0.048 ANGLE2 == 90 WITH LENGTH == 0.240
LVT_N_90_90_jog_eq_002_eq_135 = CONVEX EDGE LVT_N ANGLE1 == 90 LENGTH1 == 0.002 ANGLE2 == 90 WITH LENGTH == 0.135
LVT_N_90_90_jog_eq_002_eq_144 = CONVEX EDGE LVT_N ANGLE1 == 90 LENGTH1 == 0.002 ANGLE2 == 90 WITH LENGTH == 0.144
LVT_N_90_90_jog_eqlt_048_eq_180_192 = OR EDGE LVT_N_90_90_jog_eqlt_048_eq_180 LVT_N_90_90_jog_eqlt_048_eq_192
LVT_N_90_90_jog_180_192_225_240_135_144 = ((((LVT_N_90_90_jog_eqlt_048_eq_180 OR EDGE LVT_N_90_90_jog_eqlt_048_eq_192) OR EDGE LVT_N_90_90_jog_eqlt_048_eq_225) OR EDGE LVT_N_90_90_jog_eqlt_048_eq_240) OR EDGE LVT_N_90_90_jog_eq_002_eq_135) OR EDGE LVT_N_90_90_jog_eq_002_eq_144
LVT_N_90_90_jog_180_192_225_240_135_144_h_edges = ANGLE LVT_N_90_90_jog_180_192_225_240_135_144 == 0
LVT_N_90_90_jog_180_192_225_240_135_144_v_edges = ANGLE LVT_N_90_90_jog_180_192_225_240_135_144 == 90
LVT_N_90_90_jog_180_135_144 = (LVT_N_90_90_jog_eqlt_048_eq_180 OR EDGE LVT_N_90_90_jog_eq_002_eq_135) OR EDGE LVT_N_90_90_jog_eq_002_eq_144
LVT_N_90_90_jog_192_180_135_144 = LVT_N_90_90_jog_eqlt_048_eq_192 OR EDGE ((LVT_N_90_90_jog_eqlt_048_eq_180 OR EDGE LVT_N_90_90_jog_eq_002_eq_135) OR EDGE LVT_N_90_90_jog_eq_002_eq_144)

//;reverse VT 90-90 convex edges filter 
LVT_N_rvs = DRC:1 NOT LVT_N
LVT_N_rvs_90_90_jog_eqlt_048_eq_180 = CONVEX EDGE LVT_N_rvs ANGLE1 == 90 LENGTH1 <= 0.048 ANGLE2 == 90 WITH LENGTH == 0.180
LVT_N_rvs_90_90_jog_eqlt_048_eq_192 = CONVEX EDGE LVT_N_rvs ANGLE1 == 90 LENGTH1 <= 0.048 ANGLE2 == 90 WITH LENGTH == 0.192
LVT_N_rvs_90_90_jog_eqlt_048_eq_225 = CONVEX EDGE LVT_N_rvs ANGLE1 == 90 LENGTH1 <= 0.048 ANGLE2 == 90 WITH LENGTH == 0.225
LVT_N_rvs_90_90_jog_eqlt_048_eq_240 = CONVEX EDGE LVT_N_rvs ANGLE1 == 90 LENGTH1 <= 0.048 ANGLE2 == 90 WITH LENGTH == 0.240
LVT_N_rvs_90_90_jog_eq_002_eq_135 = CONVEX EDGE LVT_N_rvs ANGLE1 == 90 LENGTH1 == 0.002 ANGLE2 == 90 WITH LENGTH == 0.135
LVT_N_rvs_90_90_jog_eq_002_eq_144 = CONVEX EDGE LVT_N_rvs ANGLE1 == 90 LENGTH1 == 0.002 ANGLE2 == 90 WITH LENGTH == 0.144
LVT_N_rvs_90_90_jog_eqlt_048_eq_180_192 = OR EDGE LVT_N_rvs_90_90_jog_eqlt_048_eq_180 LVT_N_rvs_90_90_jog_eqlt_048_eq_192
LVT_N_rvs_90_90_jog_180_192_225_240_135_144 = ((((LVT_N_rvs_90_90_jog_eqlt_048_eq_180 OR EDGE LVT_N_rvs_90_90_jog_eqlt_048_eq_192) OR EDGE LVT_N_rvs_90_90_jog_eqlt_048_eq_225) OR EDGE LVT_N_rvs_90_90_jog_eqlt_048_eq_240) OR EDGE LVT_N_rvs_90_90_jog_eq_002_eq_135) OR EDGE LVT_N_rvs_90_90_jog_eq_002_eq_144
LVT_N_rvs_90_90_jog_180_135_144 = (LVT_N_rvs_90_90_jog_eqlt_048_eq_180 OR EDGE LVT_N_rvs_90_90_jog_eq_002_eq_135) OR EDGE LVT_N_rvs_90_90_jog_eq_002_eq_144

//;270-270 convex edges filter 
LVT_P_270_270_jog_eqlt_048_eq_180 = CONVEX EDGE LVT_P ANGLE1 == 270 LENGTH1 <= 0.048 ANGLE2 == 270 WITH LENGTH == 0.180
LVT_P_270_270_jog_eqlt_048_eq_192 = CONVEX EDGE LVT_P ANGLE1 == 270 LENGTH1 <= 0.048 ANGLE2 == 270 WITH LENGTH == 0.192
LVT_P_270_270_jog_eqlt_048_eq_225 = CONVEX EDGE LVT_P ANGLE1 == 270 LENGTH1 <= 0.048 ANGLE2 == 270 WITH LENGTH == 0.225
LVT_P_270_270_jog_eqlt_048_eq_240 = CONVEX EDGE LVT_P ANGLE1 == 270 LENGTH1 <= 0.048 ANGLE2 == 270 WITH LENGTH == 0.240
LVT_P_270_270_jog_eq_002_eq_135 = CONVEX EDGE LVT_P ANGLE1 == 270 LENGTH1 == 0.002 ANGLE2 == 270 WITH LENGTH == 0.135
LVT_P_270_270_jog_eq_002_eq_144 = CONVEX EDGE LVT_P ANGLE1 == 270 LENGTH1 == 0.002 ANGLE2 == 270 WITH LENGTH == 0.144
LVT_P_270_270_jog_eqlt_048_eq_180_192 = OR EDGE LVT_P_270_270_jog_eqlt_048_eq_180 LVT_P_270_270_jog_eqlt_048_eq_192
LVT_P_270_270_jog_180_192_225_240_135_144 = ((((LVT_P_270_270_jog_eqlt_048_eq_180 OR EDGE LVT_P_270_270_jog_eqlt_048_eq_192) OR EDGE LVT_P_270_270_jog_eqlt_048_eq_225) OR EDGE LVT_P_270_270_jog_eqlt_048_eq_240) OR EDGE LVT_P_270_270_jog_eq_002_eq_135) OR EDGE LVT_P_270_270_jog_eq_002_eq_144
LVT_P_270_270_jog_180_192_225_240_135_144_h_edges = ANGLE LVT_P_270_270_jog_180_192_225_240_135_144 == 0

//;90-90 convex edges filter 
LVT_P_90_90_jog_eqlt_048_eq_180 = CONVEX EDGE LVT_P ANGLE1 == 90 LENGTH1 <= 0.048 ANGLE2 == 90 WITH LENGTH == 0.180
LVT_P_90_90_jog_eqlt_048_eq_192 = CONVEX EDGE LVT_P ANGLE1 == 90 LENGTH1 <= 0.048 ANGLE2 == 90 WITH LENGTH == 0.192
LVT_P_90_90_jog_eqlt_048_eq_225 = CONVEX EDGE LVT_P ANGLE1 == 90 LENGTH1 <= 0.048 ANGLE2 == 90 WITH LENGTH == 0.225
LVT_P_90_90_jog_eqlt_048_eq_240 = CONVEX EDGE LVT_P ANGLE1 == 90 LENGTH1 <= 0.048 ANGLE2 == 90 WITH LENGTH == 0.240
LVT_P_90_90_jog_eq_002_eq_135 = CONVEX EDGE LVT_P ANGLE1 == 90 LENGTH1 == 0.002 ANGLE2 == 90 WITH LENGTH == 0.135
LVT_P_90_90_jog_eq_002_eq_144 = CONVEX EDGE LVT_P ANGLE1 == 90 LENGTH1 == 0.002 ANGLE2 == 90 WITH LENGTH == 0.144
LVT_P_90_90_jog_eqlt_048_eq_180_192 = OR EDGE LVT_P_90_90_jog_eqlt_048_eq_180 LVT_P_90_90_jog_eqlt_048_eq_192
LVT_P_90_90_jog_180_192_225_240_135_144 = ((((LVT_P_90_90_jog_eqlt_048_eq_180 OR EDGE LVT_P_90_90_jog_eqlt_048_eq_192) OR EDGE LVT_P_90_90_jog_eqlt_048_eq_225) OR EDGE LVT_P_90_90_jog_eqlt_048_eq_240) OR EDGE LVT_P_90_90_jog_eq_002_eq_135) OR EDGE LVT_P_90_90_jog_eq_002_eq_144
LVT_P_90_90_jog_180_192_225_240_135_144_h_edges = ANGLE LVT_P_90_90_jog_180_192_225_240_135_144 == 0
LVT_P_90_90_jog_180_192_225_240_135_144_v_edges = ANGLE LVT_P_90_90_jog_180_192_225_240_135_144 == 90
LVT_P_90_90_jog_180_135_144 = (LVT_P_90_90_jog_eqlt_048_eq_180 OR EDGE LVT_P_90_90_jog_eq_002_eq_135) OR EDGE LVT_P_90_90_jog_eq_002_eq_144
LVT_P_90_90_jog_192_180_135_144 = LVT_P_90_90_jog_eqlt_048_eq_192 OR EDGE ((LVT_P_90_90_jog_eqlt_048_eq_180 OR EDGE LVT_P_90_90_jog_eq_002_eq_135) OR EDGE LVT_P_90_90_jog_eq_002_eq_144)

//;reverse VT 90-90 convex edges filter 
LVT_P_rvs = DRC:1 NOT LVT_P
LVT_P_rvs_90_90_jog_eqlt_048_eq_180 = CONVEX EDGE LVT_P_rvs ANGLE1 == 90 LENGTH1 <= 0.048 ANGLE2 == 90 WITH LENGTH == 0.180
LVT_P_rvs_90_90_jog_eqlt_048_eq_192 = CONVEX EDGE LVT_P_rvs ANGLE1 == 90 LENGTH1 <= 0.048 ANGLE2 == 90 WITH LENGTH == 0.192
LVT_P_rvs_90_90_jog_eqlt_048_eq_225 = CONVEX EDGE LVT_P_rvs ANGLE1 == 90 LENGTH1 <= 0.048 ANGLE2 == 90 WITH LENGTH == 0.225
LVT_P_rvs_90_90_jog_eqlt_048_eq_240 = CONVEX EDGE LVT_P_rvs ANGLE1 == 90 LENGTH1 <= 0.048 ANGLE2 == 90 WITH LENGTH == 0.240
LVT_P_rvs_90_90_jog_eq_002_eq_135 = CONVEX EDGE LVT_P_rvs ANGLE1 == 90 LENGTH1 == 0.002 ANGLE2 == 90 WITH LENGTH == 0.135
LVT_P_rvs_90_90_jog_eq_002_eq_144 = CONVEX EDGE LVT_P_rvs ANGLE1 == 90 LENGTH1 == 0.002 ANGLE2 == 90 WITH LENGTH == 0.144
LVT_P_rvs_90_90_jog_eqlt_048_eq_180_192 = OR EDGE LVT_P_rvs_90_90_jog_eqlt_048_eq_180 LVT_P_rvs_90_90_jog_eqlt_048_eq_192
LVT_P_rvs_90_90_jog_180_192_225_240_135_144 = ((((LVT_P_rvs_90_90_jog_eqlt_048_eq_180 OR EDGE LVT_P_rvs_90_90_jog_eqlt_048_eq_192) OR EDGE LVT_P_rvs_90_90_jog_eqlt_048_eq_225) OR EDGE LVT_P_rvs_90_90_jog_eqlt_048_eq_240) OR EDGE LVT_P_rvs_90_90_jog_eq_002_eq_135) OR EDGE LVT_P_rvs_90_90_jog_eq_002_eq_144
LVT_P_rvs_90_90_jog_180_135_144 = (LVT_P_rvs_90_90_jog_eqlt_048_eq_180 OR EDGE LVT_P_rvs_90_90_jog_eq_002_eq_135) OR EDGE LVT_P_rvs_90_90_jog_eq_002_eq_144

//;270-270 convex edges filter 
HVT_N_270_270_jog_eqlt_048_eq_180 = CONVEX EDGE HVT_N ANGLE1 == 270 LENGTH1 <= 0.048 ANGLE2 == 270 WITH LENGTH == 0.180
HVT_N_270_270_jog_eqlt_048_eq_192 = CONVEX EDGE HVT_N ANGLE1 == 270 LENGTH1 <= 0.048 ANGLE2 == 270 WITH LENGTH == 0.192
HVT_N_270_270_jog_eqlt_048_eq_225 = CONVEX EDGE HVT_N ANGLE1 == 270 LENGTH1 <= 0.048 ANGLE2 == 270 WITH LENGTH == 0.225
HVT_N_270_270_jog_eqlt_048_eq_240 = CONVEX EDGE HVT_N ANGLE1 == 270 LENGTH1 <= 0.048 ANGLE2 == 270 WITH LENGTH == 0.240
HVT_N_270_270_jog_eq_002_eq_135 = CONVEX EDGE HVT_N ANGLE1 == 270 LENGTH1 == 0.002 ANGLE2 == 270 WITH LENGTH == 0.135
HVT_N_270_270_jog_eq_002_eq_144 = CONVEX EDGE HVT_N ANGLE1 == 270 LENGTH1 == 0.002 ANGLE2 == 270 WITH LENGTH == 0.144
HVT_N_270_270_jog_eqlt_048_eq_180_192 = OR EDGE HVT_N_270_270_jog_eqlt_048_eq_180 HVT_N_270_270_jog_eqlt_048_eq_192
HVT_N_270_270_jog_180_192_225_240_135_144 = ((((HVT_N_270_270_jog_eqlt_048_eq_180 OR EDGE HVT_N_270_270_jog_eqlt_048_eq_192) OR EDGE HVT_N_270_270_jog_eqlt_048_eq_225) OR EDGE HVT_N_270_270_jog_eqlt_048_eq_240) OR EDGE HVT_N_270_270_jog_eq_002_eq_135) OR EDGE HVT_N_270_270_jog_eq_002_eq_144
HVT_N_270_270_jog_180_192_225_240_135_144_h_edges = ANGLE HVT_N_270_270_jog_180_192_225_240_135_144 == 0

//;90-90 convex edges filter 
HVT_N_90_90_jog_eqlt_048_eq_180 = CONVEX EDGE HVT_N ANGLE1 == 90 LENGTH1 <= 0.048 ANGLE2 == 90 WITH LENGTH == 0.180
HVT_N_90_90_jog_eqlt_048_eq_192 = CONVEX EDGE HVT_N ANGLE1 == 90 LENGTH1 <= 0.048 ANGLE2 == 90 WITH LENGTH == 0.192
HVT_N_90_90_jog_eqlt_048_eq_225 = CONVEX EDGE HVT_N ANGLE1 == 90 LENGTH1 <= 0.048 ANGLE2 == 90 WITH LENGTH == 0.225
HVT_N_90_90_jog_eqlt_048_eq_240 = CONVEX EDGE HVT_N ANGLE1 == 90 LENGTH1 <= 0.048 ANGLE2 == 90 WITH LENGTH == 0.240
HVT_N_90_90_jog_eq_002_eq_135 = CONVEX EDGE HVT_N ANGLE1 == 90 LENGTH1 == 0.002 ANGLE2 == 90 WITH LENGTH == 0.135
HVT_N_90_90_jog_eq_002_eq_144 = CONVEX EDGE HVT_N ANGLE1 == 90 LENGTH1 == 0.002 ANGLE2 == 90 WITH LENGTH == 0.144
HVT_N_90_90_jog_eqlt_048_eq_180_192 = OR EDGE HVT_N_90_90_jog_eqlt_048_eq_180 HVT_N_90_90_jog_eqlt_048_eq_192
HVT_N_90_90_jog_180_192_225_240_135_144 = ((((HVT_N_90_90_jog_eqlt_048_eq_180 OR EDGE HVT_N_90_90_jog_eqlt_048_eq_192) OR EDGE HVT_N_90_90_jog_eqlt_048_eq_225) OR EDGE HVT_N_90_90_jog_eqlt_048_eq_240) OR EDGE HVT_N_90_90_jog_eq_002_eq_135) OR EDGE HVT_N_90_90_jog_eq_002_eq_144
HVT_N_90_90_jog_180_192_225_240_135_144_h_edges = ANGLE HVT_N_90_90_jog_180_192_225_240_135_144 == 0
HVT_N_90_90_jog_180_192_225_240_135_144_v_edges = ANGLE HVT_N_90_90_jog_180_192_225_240_135_144 == 90
HVT_N_90_90_jog_180_135_144 = (HVT_N_90_90_jog_eqlt_048_eq_180 OR EDGE HVT_N_90_90_jog_eq_002_eq_135) OR EDGE HVT_N_90_90_jog_eq_002_eq_144
HVT_N_90_90_jog_192_180_135_144 = HVT_N_90_90_jog_eqlt_048_eq_192 OR EDGE ((HVT_N_90_90_jog_eqlt_048_eq_180 OR EDGE HVT_N_90_90_jog_eq_002_eq_135) OR EDGE HVT_N_90_90_jog_eq_002_eq_144)

//;reverse VT 90-90 convex edges filter 
HVT_N_rvs = DRC:1 NOT HVT_N
HVT_N_rvs_90_90_jog_eqlt_048_eq_180 = CONVEX EDGE HVT_N_rvs ANGLE1 == 90 LENGTH1 <= 0.048 ANGLE2 == 90 WITH LENGTH == 0.180
HVT_N_rvs_90_90_jog_eqlt_048_eq_192 = CONVEX EDGE HVT_N_rvs ANGLE1 == 90 LENGTH1 <= 0.048 ANGLE2 == 90 WITH LENGTH == 0.192
HVT_N_rvs_90_90_jog_eqlt_048_eq_225 = CONVEX EDGE HVT_N_rvs ANGLE1 == 90 LENGTH1 <= 0.048 ANGLE2 == 90 WITH LENGTH == 0.225
HVT_N_rvs_90_90_jog_eqlt_048_eq_240 = CONVEX EDGE HVT_N_rvs ANGLE1 == 90 LENGTH1 <= 0.048 ANGLE2 == 90 WITH LENGTH == 0.240
HVT_N_rvs_90_90_jog_eq_002_eq_135 = CONVEX EDGE HVT_N_rvs ANGLE1 == 90 LENGTH1 == 0.002 ANGLE2 == 90 WITH LENGTH == 0.135
HVT_N_rvs_90_90_jog_eq_002_eq_144 = CONVEX EDGE HVT_N_rvs ANGLE1 == 90 LENGTH1 == 0.002 ANGLE2 == 90 WITH LENGTH == 0.144
HVT_N_rvs_90_90_jog_eqlt_048_eq_180_192 = OR EDGE HVT_N_rvs_90_90_jog_eqlt_048_eq_180 HVT_N_rvs_90_90_jog_eqlt_048_eq_192
HVT_N_rvs_90_90_jog_180_192_225_240_135_144 = ((((HVT_N_rvs_90_90_jog_eqlt_048_eq_180 OR EDGE HVT_N_rvs_90_90_jog_eqlt_048_eq_192) OR EDGE HVT_N_rvs_90_90_jog_eqlt_048_eq_225) OR EDGE HVT_N_rvs_90_90_jog_eqlt_048_eq_240) OR EDGE HVT_N_rvs_90_90_jog_eq_002_eq_135) OR EDGE HVT_N_rvs_90_90_jog_eq_002_eq_144
HVT_N_rvs_90_90_jog_180_135_144 = (HVT_N_rvs_90_90_jog_eqlt_048_eq_180 OR EDGE HVT_N_rvs_90_90_jog_eq_002_eq_135) OR EDGE HVT_N_rvs_90_90_jog_eq_002_eq_144

//;270-270 convex edges filter 
HVT_P_270_270_jog_eqlt_048_eq_180 = CONVEX EDGE HVT_P ANGLE1 == 270 LENGTH1 <= 0.048 ANGLE2 == 270 WITH LENGTH == 0.180
HVT_P_270_270_jog_eqlt_048_eq_192 = CONVEX EDGE HVT_P ANGLE1 == 270 LENGTH1 <= 0.048 ANGLE2 == 270 WITH LENGTH == 0.192
HVT_P_270_270_jog_eqlt_048_eq_225 = CONVEX EDGE HVT_P ANGLE1 == 270 LENGTH1 <= 0.048 ANGLE2 == 270 WITH LENGTH == 0.225
HVT_P_270_270_jog_eqlt_048_eq_240 = CONVEX EDGE HVT_P ANGLE1 == 270 LENGTH1 <= 0.048 ANGLE2 == 270 WITH LENGTH == 0.240
HVT_P_270_270_jog_eq_002_eq_135 = CONVEX EDGE HVT_P ANGLE1 == 270 LENGTH1 == 0.002 ANGLE2 == 270 WITH LENGTH == 0.135
HVT_P_270_270_jog_eq_002_eq_144 = CONVEX EDGE HVT_P ANGLE1 == 270 LENGTH1 == 0.002 ANGLE2 == 270 WITH LENGTH == 0.144
HVT_P_270_270_jog_eqlt_048_eq_180_192 = OR EDGE HVT_P_270_270_jog_eqlt_048_eq_180 HVT_P_270_270_jog_eqlt_048_eq_192
HVT_P_270_270_jog_180_192_225_240_135_144 = ((((HVT_P_270_270_jog_eqlt_048_eq_180 OR EDGE HVT_P_270_270_jog_eqlt_048_eq_192) OR EDGE HVT_P_270_270_jog_eqlt_048_eq_225) OR EDGE HVT_P_270_270_jog_eqlt_048_eq_240) OR EDGE HVT_P_270_270_jog_eq_002_eq_135) OR EDGE HVT_P_270_270_jog_eq_002_eq_144
HVT_P_270_270_jog_180_192_225_240_135_144_h_edges = ANGLE HVT_P_270_270_jog_180_192_225_240_135_144 == 0

//;90-90 convex edges filter 
HVT_P_90_90_jog_eqlt_048_eq_180 = CONVEX EDGE HVT_P ANGLE1 == 90 LENGTH1 <= 0.048 ANGLE2 == 90 WITH LENGTH == 0.180
HVT_P_90_90_jog_eqlt_048_eq_192 = CONVEX EDGE HVT_P ANGLE1 == 90 LENGTH1 <= 0.048 ANGLE2 == 90 WITH LENGTH == 0.192
HVT_P_90_90_jog_eqlt_048_eq_225 = CONVEX EDGE HVT_P ANGLE1 == 90 LENGTH1 <= 0.048 ANGLE2 == 90 WITH LENGTH == 0.225
HVT_P_90_90_jog_eqlt_048_eq_240 = CONVEX EDGE HVT_P ANGLE1 == 90 LENGTH1 <= 0.048 ANGLE2 == 90 WITH LENGTH == 0.240
HVT_P_90_90_jog_eq_002_eq_135 = CONVEX EDGE HVT_P ANGLE1 == 90 LENGTH1 == 0.002 ANGLE2 == 90 WITH LENGTH == 0.135
HVT_P_90_90_jog_eq_002_eq_144 = CONVEX EDGE HVT_P ANGLE1 == 90 LENGTH1 == 0.002 ANGLE2 == 90 WITH LENGTH == 0.144
HVT_P_90_90_jog_eqlt_048_eq_180_192 = OR EDGE HVT_P_90_90_jog_eqlt_048_eq_180 HVT_P_90_90_jog_eqlt_048_eq_192
HVT_P_90_90_jog_180_192_225_240_135_144 = ((((HVT_P_90_90_jog_eqlt_048_eq_180 OR EDGE HVT_P_90_90_jog_eqlt_048_eq_192) OR EDGE HVT_P_90_90_jog_eqlt_048_eq_225) OR EDGE HVT_P_90_90_jog_eqlt_048_eq_240) OR EDGE HVT_P_90_90_jog_eq_002_eq_135) OR EDGE HVT_P_90_90_jog_eq_002_eq_144
HVT_P_90_90_jog_180_192_225_240_135_144_h_edges = ANGLE HVT_P_90_90_jog_180_192_225_240_135_144 == 0
HVT_P_90_90_jog_180_192_225_240_135_144_v_edges = ANGLE HVT_P_90_90_jog_180_192_225_240_135_144 == 90
HVT_P_90_90_jog_180_135_144 = (HVT_P_90_90_jog_eqlt_048_eq_180 OR EDGE HVT_P_90_90_jog_eq_002_eq_135) OR EDGE HVT_P_90_90_jog_eq_002_eq_144
HVT_P_90_90_jog_192_180_135_144 = HVT_P_90_90_jog_eqlt_048_eq_192 OR EDGE ((HVT_P_90_90_jog_eqlt_048_eq_180 OR EDGE HVT_P_90_90_jog_eq_002_eq_135) OR EDGE HVT_P_90_90_jog_eq_002_eq_144)

//;reverse VT 90-90 convex edges filter 
HVT_P_rvs = DRC:1 NOT HVT_P
HVT_P_rvs_90_90_jog_eqlt_048_eq_180 = CONVEX EDGE HVT_P_rvs ANGLE1 == 90 LENGTH1 <= 0.048 ANGLE2 == 90 WITH LENGTH == 0.180
HVT_P_rvs_90_90_jog_eqlt_048_eq_192 = CONVEX EDGE HVT_P_rvs ANGLE1 == 90 LENGTH1 <= 0.048 ANGLE2 == 90 WITH LENGTH == 0.192
HVT_P_rvs_90_90_jog_eqlt_048_eq_225 = CONVEX EDGE HVT_P_rvs ANGLE1 == 90 LENGTH1 <= 0.048 ANGLE2 == 90 WITH LENGTH == 0.225
HVT_P_rvs_90_90_jog_eqlt_048_eq_240 = CONVEX EDGE HVT_P_rvs ANGLE1 == 90 LENGTH1 <= 0.048 ANGLE2 == 90 WITH LENGTH == 0.240
HVT_P_rvs_90_90_jog_eq_002_eq_135 = CONVEX EDGE HVT_P_rvs ANGLE1 == 90 LENGTH1 == 0.002 ANGLE2 == 90 WITH LENGTH == 0.135
HVT_P_rvs_90_90_jog_eq_002_eq_144 = CONVEX EDGE HVT_P_rvs ANGLE1 == 90 LENGTH1 == 0.002 ANGLE2 == 90 WITH LENGTH == 0.144
HVT_P_rvs_90_90_jog_eqlt_048_eq_180_192 = OR EDGE HVT_P_rvs_90_90_jog_eqlt_048_eq_180 HVT_P_rvs_90_90_jog_eqlt_048_eq_192
HVT_P_rvs_90_90_jog_180_192_225_240_135_144 = ((((HVT_P_rvs_90_90_jog_eqlt_048_eq_180 OR EDGE HVT_P_rvs_90_90_jog_eqlt_048_eq_192) OR EDGE HVT_P_rvs_90_90_jog_eqlt_048_eq_225) OR EDGE HVT_P_rvs_90_90_jog_eqlt_048_eq_240) OR EDGE HVT_P_rvs_90_90_jog_eq_002_eq_135) OR EDGE HVT_P_rvs_90_90_jog_eq_002_eq_144
HVT_P_rvs_90_90_jog_180_135_144 = (HVT_P_rvs_90_90_jog_eqlt_048_eq_180 OR EDGE HVT_P_rvs_90_90_jog_eq_002_eq_135) OR EDGE HVT_P_rvs_90_90_jog_eq_002_eq_144

//;270-270 convex edges filter 
ULVT_N_270_270_jog_eqlt_048_eq_180 = CONVEX EDGE ULVT_N ANGLE1 == 270 LENGTH1 <= 0.048 ANGLE2 == 270 WITH LENGTH == 0.180
ULVT_N_270_270_jog_eqlt_048_eq_192 = CONVEX EDGE ULVT_N ANGLE1 == 270 LENGTH1 <= 0.048 ANGLE2 == 270 WITH LENGTH == 0.192
ULVT_N_270_270_jog_eqlt_048_eq_225 = CONVEX EDGE ULVT_N ANGLE1 == 270 LENGTH1 <= 0.048 ANGLE2 == 270 WITH LENGTH == 0.225
ULVT_N_270_270_jog_eqlt_048_eq_240 = CONVEX EDGE ULVT_N ANGLE1 == 270 LENGTH1 <= 0.048 ANGLE2 == 270 WITH LENGTH == 0.240
ULVT_N_270_270_jog_eq_002_eq_135 = CONVEX EDGE ULVT_N ANGLE1 == 270 LENGTH1 == 0.002 ANGLE2 == 270 WITH LENGTH == 0.135
ULVT_N_270_270_jog_eq_002_eq_144 = CONVEX EDGE ULVT_N ANGLE1 == 270 LENGTH1 == 0.002 ANGLE2 == 270 WITH LENGTH == 0.144
ULVT_N_270_270_jog_eqlt_048_eq_180_192 = OR EDGE ULVT_N_270_270_jog_eqlt_048_eq_180 ULVT_N_270_270_jog_eqlt_048_eq_192
ULVT_N_270_270_jog_180_192_225_240_135_144 = ((((ULVT_N_270_270_jog_eqlt_048_eq_180 OR EDGE ULVT_N_270_270_jog_eqlt_048_eq_192) OR EDGE ULVT_N_270_270_jog_eqlt_048_eq_225) OR EDGE ULVT_N_270_270_jog_eqlt_048_eq_240) OR EDGE ULVT_N_270_270_jog_eq_002_eq_135) OR EDGE ULVT_N_270_270_jog_eq_002_eq_144
ULVT_N_270_270_jog_180_192_225_240_135_144_h_edges = ANGLE ULVT_N_270_270_jog_180_192_225_240_135_144 == 0

//;90-90 convex edges filter 
ULVT_N_90_90_jog_eqlt_048_eq_180 = CONVEX EDGE ULVT_N ANGLE1 == 90 LENGTH1 <= 0.048 ANGLE2 == 90 WITH LENGTH == 0.180
ULVT_N_90_90_jog_eqlt_048_eq_192 = CONVEX EDGE ULVT_N ANGLE1 == 90 LENGTH1 <= 0.048 ANGLE2 == 90 WITH LENGTH == 0.192
ULVT_N_90_90_jog_eqlt_048_eq_225 = CONVEX EDGE ULVT_N ANGLE1 == 90 LENGTH1 <= 0.048 ANGLE2 == 90 WITH LENGTH == 0.225
ULVT_N_90_90_jog_eqlt_048_eq_240 = CONVEX EDGE ULVT_N ANGLE1 == 90 LENGTH1 <= 0.048 ANGLE2 == 90 WITH LENGTH == 0.240
ULVT_N_90_90_jog_eq_002_eq_135 = CONVEX EDGE ULVT_N ANGLE1 == 90 LENGTH1 == 0.002 ANGLE2 == 90 WITH LENGTH == 0.135
ULVT_N_90_90_jog_eq_002_eq_144 = CONVEX EDGE ULVT_N ANGLE1 == 90 LENGTH1 == 0.002 ANGLE2 == 90 WITH LENGTH == 0.144
ULVT_N_90_90_jog_eqlt_048_eq_180_192 = OR EDGE ULVT_N_90_90_jog_eqlt_048_eq_180 ULVT_N_90_90_jog_eqlt_048_eq_192
ULVT_N_90_90_jog_180_192_225_240_135_144 = ((((ULVT_N_90_90_jog_eqlt_048_eq_180 OR EDGE ULVT_N_90_90_jog_eqlt_048_eq_192) OR EDGE ULVT_N_90_90_jog_eqlt_048_eq_225) OR EDGE ULVT_N_90_90_jog_eqlt_048_eq_240) OR EDGE ULVT_N_90_90_jog_eq_002_eq_135) OR EDGE ULVT_N_90_90_jog_eq_002_eq_144
ULVT_N_90_90_jog_180_192_225_240_135_144_h_edges = ANGLE ULVT_N_90_90_jog_180_192_225_240_135_144 == 0
ULVT_N_90_90_jog_180_192_225_240_135_144_v_edges = ANGLE ULVT_N_90_90_jog_180_192_225_240_135_144 == 90
ULVT_N_90_90_jog_180_135_144 = (ULVT_N_90_90_jog_eqlt_048_eq_180 OR EDGE ULVT_N_90_90_jog_eq_002_eq_135) OR EDGE ULVT_N_90_90_jog_eq_002_eq_144
ULVT_N_90_90_jog_192_180_135_144 = ULVT_N_90_90_jog_eqlt_048_eq_192 OR EDGE ((ULVT_N_90_90_jog_eqlt_048_eq_180 OR EDGE ULVT_N_90_90_jog_eq_002_eq_135) OR EDGE ULVT_N_90_90_jog_eq_002_eq_144)

//;reverse VT 90-90 convex edges filter 
ULVT_N_rvs = DRC:1 NOT ULVT_N
ULVT_N_rvs_90_90_jog_eqlt_048_eq_180 = CONVEX EDGE ULVT_N_rvs ANGLE1 == 90 LENGTH1 <= 0.048 ANGLE2 == 90 WITH LENGTH == 0.180
ULVT_N_rvs_90_90_jog_eqlt_048_eq_192 = CONVEX EDGE ULVT_N_rvs ANGLE1 == 90 LENGTH1 <= 0.048 ANGLE2 == 90 WITH LENGTH == 0.192
ULVT_N_rvs_90_90_jog_eqlt_048_eq_225 = CONVEX EDGE ULVT_N_rvs ANGLE1 == 90 LENGTH1 <= 0.048 ANGLE2 == 90 WITH LENGTH == 0.225
ULVT_N_rvs_90_90_jog_eqlt_048_eq_240 = CONVEX EDGE ULVT_N_rvs ANGLE1 == 90 LENGTH1 <= 0.048 ANGLE2 == 90 WITH LENGTH == 0.240
ULVT_N_rvs_90_90_jog_eq_002_eq_135 = CONVEX EDGE ULVT_N_rvs ANGLE1 == 90 LENGTH1 == 0.002 ANGLE2 == 90 WITH LENGTH == 0.135
ULVT_N_rvs_90_90_jog_eq_002_eq_144 = CONVEX EDGE ULVT_N_rvs ANGLE1 == 90 LENGTH1 == 0.002 ANGLE2 == 90 WITH LENGTH == 0.144
ULVT_N_rvs_90_90_jog_eqlt_048_eq_180_192 = OR EDGE ULVT_N_rvs_90_90_jog_eqlt_048_eq_180 ULVT_N_rvs_90_90_jog_eqlt_048_eq_192
ULVT_N_rvs_90_90_jog_180_192_225_240_135_144 = ((((ULVT_N_rvs_90_90_jog_eqlt_048_eq_180 OR EDGE ULVT_N_rvs_90_90_jog_eqlt_048_eq_192) OR EDGE ULVT_N_rvs_90_90_jog_eqlt_048_eq_225) OR EDGE ULVT_N_rvs_90_90_jog_eqlt_048_eq_240) OR EDGE ULVT_N_rvs_90_90_jog_eq_002_eq_135) OR EDGE ULVT_N_rvs_90_90_jog_eq_002_eq_144
ULVT_N_rvs_90_90_jog_180_135_144 = (ULVT_N_rvs_90_90_jog_eqlt_048_eq_180 OR EDGE ULVT_N_rvs_90_90_jog_eq_002_eq_135) OR EDGE ULVT_N_rvs_90_90_jog_eq_002_eq_144

//;270-270 convex edges filter 
ULVT_P_270_270_jog_eqlt_048_eq_180 = CONVEX EDGE ULVT_P ANGLE1 == 270 LENGTH1 <= 0.048 ANGLE2 == 270 WITH LENGTH == 0.180
ULVT_P_270_270_jog_eqlt_048_eq_192 = CONVEX EDGE ULVT_P ANGLE1 == 270 LENGTH1 <= 0.048 ANGLE2 == 270 WITH LENGTH == 0.192
ULVT_P_270_270_jog_eqlt_048_eq_225 = CONVEX EDGE ULVT_P ANGLE1 == 270 LENGTH1 <= 0.048 ANGLE2 == 270 WITH LENGTH == 0.225
ULVT_P_270_270_jog_eqlt_048_eq_240 = CONVEX EDGE ULVT_P ANGLE1 == 270 LENGTH1 <= 0.048 ANGLE2 == 270 WITH LENGTH == 0.240
ULVT_P_270_270_jog_eq_002_eq_135 = CONVEX EDGE ULVT_P ANGLE1 == 270 LENGTH1 == 0.002 ANGLE2 == 270 WITH LENGTH == 0.135
ULVT_P_270_270_jog_eq_002_eq_144 = CONVEX EDGE ULVT_P ANGLE1 == 270 LENGTH1 == 0.002 ANGLE2 == 270 WITH LENGTH == 0.144
ULVT_P_270_270_jog_eqlt_048_eq_180_192 = OR EDGE ULVT_P_270_270_jog_eqlt_048_eq_180 ULVT_P_270_270_jog_eqlt_048_eq_192
ULVT_P_270_270_jog_180_192_225_240_135_144 = ((((ULVT_P_270_270_jog_eqlt_048_eq_180 OR EDGE ULVT_P_270_270_jog_eqlt_048_eq_192) OR EDGE ULVT_P_270_270_jog_eqlt_048_eq_225) OR EDGE ULVT_P_270_270_jog_eqlt_048_eq_240) OR EDGE ULVT_P_270_270_jog_eq_002_eq_135) OR EDGE ULVT_P_270_270_jog_eq_002_eq_144
ULVT_P_270_270_jog_180_192_225_240_135_144_h_edges = ANGLE ULVT_P_270_270_jog_180_192_225_240_135_144 == 0

//;90-90 convex edges filter 
ULVT_P_90_90_jog_eqlt_048_eq_180 = CONVEX EDGE ULVT_P ANGLE1 == 90 LENGTH1 <= 0.048 ANGLE2 == 90 WITH LENGTH == 0.180
ULVT_P_90_90_jog_eqlt_048_eq_192 = CONVEX EDGE ULVT_P ANGLE1 == 90 LENGTH1 <= 0.048 ANGLE2 == 90 WITH LENGTH == 0.192
ULVT_P_90_90_jog_eqlt_048_eq_225 = CONVEX EDGE ULVT_P ANGLE1 == 90 LENGTH1 <= 0.048 ANGLE2 == 90 WITH LENGTH == 0.225
ULVT_P_90_90_jog_eqlt_048_eq_240 = CONVEX EDGE ULVT_P ANGLE1 == 90 LENGTH1 <= 0.048 ANGLE2 == 90 WITH LENGTH == 0.240
ULVT_P_90_90_jog_eq_002_eq_135 = CONVEX EDGE ULVT_P ANGLE1 == 90 LENGTH1 == 0.002 ANGLE2 == 90 WITH LENGTH == 0.135
ULVT_P_90_90_jog_eq_002_eq_144 = CONVEX EDGE ULVT_P ANGLE1 == 90 LENGTH1 == 0.002 ANGLE2 == 90 WITH LENGTH == 0.144
ULVT_P_90_90_jog_eqlt_048_eq_180_192 = OR EDGE ULVT_P_90_90_jog_eqlt_048_eq_180 ULVT_P_90_90_jog_eqlt_048_eq_192
ULVT_P_90_90_jog_180_192_225_240_135_144 = ((((ULVT_P_90_90_jog_eqlt_048_eq_180 OR EDGE ULVT_P_90_90_jog_eqlt_048_eq_192) OR EDGE ULVT_P_90_90_jog_eqlt_048_eq_225) OR EDGE ULVT_P_90_90_jog_eqlt_048_eq_240) OR EDGE ULVT_P_90_90_jog_eq_002_eq_135) OR EDGE ULVT_P_90_90_jog_eq_002_eq_144
ULVT_P_90_90_jog_180_192_225_240_135_144_h_edges = ANGLE ULVT_P_90_90_jog_180_192_225_240_135_144 == 0
ULVT_P_90_90_jog_180_192_225_240_135_144_v_edges = ANGLE ULVT_P_90_90_jog_180_192_225_240_135_144 == 90
ULVT_P_90_90_jog_180_135_144 = (ULVT_P_90_90_jog_eqlt_048_eq_180 OR EDGE ULVT_P_90_90_jog_eq_002_eq_135) OR EDGE ULVT_P_90_90_jog_eq_002_eq_144
ULVT_P_90_90_jog_192_180_135_144 = ULVT_P_90_90_jog_eqlt_048_eq_192 OR EDGE ((ULVT_P_90_90_jog_eqlt_048_eq_180 OR EDGE ULVT_P_90_90_jog_eq_002_eq_135) OR EDGE ULVT_P_90_90_jog_eq_002_eq_144)

//;reverse VT 90-90 convex edges filter 
ULVT_P_rvs = DRC:1 NOT ULVT_P
ULVT_P_rvs_90_90_jog_eqlt_048_eq_180 = CONVEX EDGE ULVT_P_rvs ANGLE1 == 90 LENGTH1 <= 0.048 ANGLE2 == 90 WITH LENGTH == 0.180
ULVT_P_rvs_90_90_jog_eqlt_048_eq_192 = CONVEX EDGE ULVT_P_rvs ANGLE1 == 90 LENGTH1 <= 0.048 ANGLE2 == 90 WITH LENGTH == 0.192
ULVT_P_rvs_90_90_jog_eqlt_048_eq_225 = CONVEX EDGE ULVT_P_rvs ANGLE1 == 90 LENGTH1 <= 0.048 ANGLE2 == 90 WITH LENGTH == 0.225
ULVT_P_rvs_90_90_jog_eqlt_048_eq_240 = CONVEX EDGE ULVT_P_rvs ANGLE1 == 90 LENGTH1 <= 0.048 ANGLE2 == 90 WITH LENGTH == 0.240
ULVT_P_rvs_90_90_jog_eq_002_eq_135 = CONVEX EDGE ULVT_P_rvs ANGLE1 == 90 LENGTH1 == 0.002 ANGLE2 == 90 WITH LENGTH == 0.135
ULVT_P_rvs_90_90_jog_eq_002_eq_144 = CONVEX EDGE ULVT_P_rvs ANGLE1 == 90 LENGTH1 == 0.002 ANGLE2 == 90 WITH LENGTH == 0.144
ULVT_P_rvs_90_90_jog_eqlt_048_eq_180_192 = OR EDGE ULVT_P_rvs_90_90_jog_eqlt_048_eq_180 ULVT_P_rvs_90_90_jog_eqlt_048_eq_192
ULVT_P_rvs_90_90_jog_180_192_225_240_135_144 = ((((ULVT_P_rvs_90_90_jog_eqlt_048_eq_180 OR EDGE ULVT_P_rvs_90_90_jog_eqlt_048_eq_192) OR EDGE ULVT_P_rvs_90_90_jog_eqlt_048_eq_225) OR EDGE ULVT_P_rvs_90_90_jog_eqlt_048_eq_240) OR EDGE ULVT_P_rvs_90_90_jog_eq_002_eq_135) OR EDGE ULVT_P_rvs_90_90_jog_eq_002_eq_144
ULVT_P_rvs_90_90_jog_180_135_144 = (ULVT_P_rvs_90_90_jog_eqlt_048_eq_180 OR EDGE ULVT_P_rvs_90_90_jog_eq_002_eq_135) OR EDGE ULVT_P_rvs_90_90_jog_eq_002_eq_144

//;270-270 convex edges filter 
LFN_N_270_270_jog_eqlt_048_eq_180 = CONVEX EDGE LFN_N ANGLE1 == 270 LENGTH1 <= 0.048 ANGLE2 == 270 WITH LENGTH == 0.180
LFN_N_270_270_jog_eqlt_048_eq_192 = CONVEX EDGE LFN_N ANGLE1 == 270 LENGTH1 <= 0.048 ANGLE2 == 270 WITH LENGTH == 0.192
LFN_N_270_270_jog_eqlt_048_eq_225 = CONVEX EDGE LFN_N ANGLE1 == 270 LENGTH1 <= 0.048 ANGLE2 == 270 WITH LENGTH == 0.225
LFN_N_270_270_jog_eqlt_048_eq_240 = CONVEX EDGE LFN_N ANGLE1 == 270 LENGTH1 <= 0.048 ANGLE2 == 270 WITH LENGTH == 0.240
LFN_N_270_270_jog_eq_002_eq_135 = CONVEX EDGE LFN_N ANGLE1 == 270 LENGTH1 == 0.002 ANGLE2 == 270 WITH LENGTH == 0.135
LFN_N_270_270_jog_eq_002_eq_144 = CONVEX EDGE LFN_N ANGLE1 == 270 LENGTH1 == 0.002 ANGLE2 == 270 WITH LENGTH == 0.144
LFN_N_270_270_jog_eqlt_048_eq_180_192 = OR EDGE LFN_N_270_270_jog_eqlt_048_eq_180 LFN_N_270_270_jog_eqlt_048_eq_192
LFN_N_270_270_jog_180_192_225_240_135_144 = ((((LFN_N_270_270_jog_eqlt_048_eq_180 OR EDGE LFN_N_270_270_jog_eqlt_048_eq_192) OR EDGE LFN_N_270_270_jog_eqlt_048_eq_225) OR EDGE LFN_N_270_270_jog_eqlt_048_eq_240) OR EDGE LFN_N_270_270_jog_eq_002_eq_135) OR EDGE LFN_N_270_270_jog_eq_002_eq_144
LFN_N_270_270_jog_180_192_225_240_135_144_h_edges = ANGLE LFN_N_270_270_jog_180_192_225_240_135_144 == 0

//;90-90 convex edges filter 
LFN_N_90_90_jog_eqlt_048_eq_180 = CONVEX EDGE LFN_N ANGLE1 == 90 LENGTH1 <= 0.048 ANGLE2 == 90 WITH LENGTH == 0.180
LFN_N_90_90_jog_eqlt_048_eq_192 = CONVEX EDGE LFN_N ANGLE1 == 90 LENGTH1 <= 0.048 ANGLE2 == 90 WITH LENGTH == 0.192
LFN_N_90_90_jog_eqlt_048_eq_225 = CONVEX EDGE LFN_N ANGLE1 == 90 LENGTH1 <= 0.048 ANGLE2 == 90 WITH LENGTH == 0.225
LFN_N_90_90_jog_eqlt_048_eq_240 = CONVEX EDGE LFN_N ANGLE1 == 90 LENGTH1 <= 0.048 ANGLE2 == 90 WITH LENGTH == 0.240
LFN_N_90_90_jog_eq_002_eq_135 = CONVEX EDGE LFN_N ANGLE1 == 90 LENGTH1 == 0.002 ANGLE2 == 90 WITH LENGTH == 0.135
LFN_N_90_90_jog_eq_002_eq_144 = CONVEX EDGE LFN_N ANGLE1 == 90 LENGTH1 == 0.002 ANGLE2 == 90 WITH LENGTH == 0.144
LFN_N_90_90_jog_eqlt_048_eq_180_192 = OR EDGE LFN_N_90_90_jog_eqlt_048_eq_180 LFN_N_90_90_jog_eqlt_048_eq_192
LFN_N_90_90_jog_180_192_225_240_135_144 = ((((LFN_N_90_90_jog_eqlt_048_eq_180 OR EDGE LFN_N_90_90_jog_eqlt_048_eq_192) OR EDGE LFN_N_90_90_jog_eqlt_048_eq_225) OR EDGE LFN_N_90_90_jog_eqlt_048_eq_240) OR EDGE LFN_N_90_90_jog_eq_002_eq_135) OR EDGE LFN_N_90_90_jog_eq_002_eq_144
LFN_N_90_90_jog_180_192_225_240_135_144_h_edges = ANGLE LFN_N_90_90_jog_180_192_225_240_135_144 == 0
LFN_N_90_90_jog_180_192_225_240_135_144_v_edges = ANGLE LFN_N_90_90_jog_180_192_225_240_135_144 == 90
LFN_N_90_90_jog_180_135_144 = (LFN_N_90_90_jog_eqlt_048_eq_180 OR EDGE LFN_N_90_90_jog_eq_002_eq_135) OR EDGE LFN_N_90_90_jog_eq_002_eq_144
LFN_N_90_90_jog_192_180_135_144 = LFN_N_90_90_jog_eqlt_048_eq_192 OR EDGE ((LFN_N_90_90_jog_eqlt_048_eq_180 OR EDGE LFN_N_90_90_jog_eq_002_eq_135) OR EDGE LFN_N_90_90_jog_eq_002_eq_144)

//;reverse VT 90-90 convex edges filter 
LFN_N_rvs = DRC:1 NOT LFN_N
LFN_N_rvs_90_90_jog_eqlt_048_eq_180 = CONVEX EDGE LFN_N_rvs ANGLE1 == 90 LENGTH1 <= 0.048 ANGLE2 == 90 WITH LENGTH == 0.180
LFN_N_rvs_90_90_jog_eqlt_048_eq_192 = CONVEX EDGE LFN_N_rvs ANGLE1 == 90 LENGTH1 <= 0.048 ANGLE2 == 90 WITH LENGTH == 0.192
LFN_N_rvs_90_90_jog_eqlt_048_eq_225 = CONVEX EDGE LFN_N_rvs ANGLE1 == 90 LENGTH1 <= 0.048 ANGLE2 == 90 WITH LENGTH == 0.225
LFN_N_rvs_90_90_jog_eqlt_048_eq_240 = CONVEX EDGE LFN_N_rvs ANGLE1 == 90 LENGTH1 <= 0.048 ANGLE2 == 90 WITH LENGTH == 0.240
LFN_N_rvs_90_90_jog_eq_002_eq_135 = CONVEX EDGE LFN_N_rvs ANGLE1 == 90 LENGTH1 == 0.002 ANGLE2 == 90 WITH LENGTH == 0.135
LFN_N_rvs_90_90_jog_eq_002_eq_144 = CONVEX EDGE LFN_N_rvs ANGLE1 == 90 LENGTH1 == 0.002 ANGLE2 == 90 WITH LENGTH == 0.144
LFN_N_rvs_90_90_jog_eqlt_048_eq_180_192 = OR EDGE LFN_N_rvs_90_90_jog_eqlt_048_eq_180 LFN_N_rvs_90_90_jog_eqlt_048_eq_192
LFN_N_rvs_90_90_jog_180_192_225_240_135_144 = ((((LFN_N_rvs_90_90_jog_eqlt_048_eq_180 OR EDGE LFN_N_rvs_90_90_jog_eqlt_048_eq_192) OR EDGE LFN_N_rvs_90_90_jog_eqlt_048_eq_225) OR EDGE LFN_N_rvs_90_90_jog_eqlt_048_eq_240) OR EDGE LFN_N_rvs_90_90_jog_eq_002_eq_135) OR EDGE LFN_N_rvs_90_90_jog_eq_002_eq_144
LFN_N_rvs_90_90_jog_180_135_144 = (LFN_N_rvs_90_90_jog_eqlt_048_eq_180 OR EDGE LFN_N_rvs_90_90_jog_eq_002_eq_135) OR EDGE LFN_N_rvs_90_90_jog_eq_002_eq_144

//;270-270 convex edges filter 
LFN_P_270_270_jog_eqlt_048_eq_180 = CONVEX EDGE LFN_P ANGLE1 == 270 LENGTH1 <= 0.048 ANGLE2 == 270 WITH LENGTH == 0.180
LFN_P_270_270_jog_eqlt_048_eq_192 = CONVEX EDGE LFN_P ANGLE1 == 270 LENGTH1 <= 0.048 ANGLE2 == 270 WITH LENGTH == 0.192
LFN_P_270_270_jog_eqlt_048_eq_225 = CONVEX EDGE LFN_P ANGLE1 == 270 LENGTH1 <= 0.048 ANGLE2 == 270 WITH LENGTH == 0.225
LFN_P_270_270_jog_eqlt_048_eq_240 = CONVEX EDGE LFN_P ANGLE1 == 270 LENGTH1 <= 0.048 ANGLE2 == 270 WITH LENGTH == 0.240
LFN_P_270_270_jog_eq_002_eq_135 = CONVEX EDGE LFN_P ANGLE1 == 270 LENGTH1 == 0.002 ANGLE2 == 270 WITH LENGTH == 0.135
LFN_P_270_270_jog_eq_002_eq_144 = CONVEX EDGE LFN_P ANGLE1 == 270 LENGTH1 == 0.002 ANGLE2 == 270 WITH LENGTH == 0.144
LFN_P_270_270_jog_eqlt_048_eq_180_192 = OR EDGE LFN_P_270_270_jog_eqlt_048_eq_180 LFN_P_270_270_jog_eqlt_048_eq_192
LFN_P_270_270_jog_180_192_225_240_135_144 = ((((LFN_P_270_270_jog_eqlt_048_eq_180 OR EDGE LFN_P_270_270_jog_eqlt_048_eq_192) OR EDGE LFN_P_270_270_jog_eqlt_048_eq_225) OR EDGE LFN_P_270_270_jog_eqlt_048_eq_240) OR EDGE LFN_P_270_270_jog_eq_002_eq_135) OR EDGE LFN_P_270_270_jog_eq_002_eq_144
LFN_P_270_270_jog_180_192_225_240_135_144_h_edges = ANGLE LFN_P_270_270_jog_180_192_225_240_135_144 == 0

//;90-90 convex edges filter 
LFN_P_90_90_jog_eqlt_048_eq_180 = CONVEX EDGE LFN_P ANGLE1 == 90 LENGTH1 <= 0.048 ANGLE2 == 90 WITH LENGTH == 0.180
LFN_P_90_90_jog_eqlt_048_eq_192 = CONVEX EDGE LFN_P ANGLE1 == 90 LENGTH1 <= 0.048 ANGLE2 == 90 WITH LENGTH == 0.192
LFN_P_90_90_jog_eqlt_048_eq_225 = CONVEX EDGE LFN_P ANGLE1 == 90 LENGTH1 <= 0.048 ANGLE2 == 90 WITH LENGTH == 0.225
LFN_P_90_90_jog_eqlt_048_eq_240 = CONVEX EDGE LFN_P ANGLE1 == 90 LENGTH1 <= 0.048 ANGLE2 == 90 WITH LENGTH == 0.240
LFN_P_90_90_jog_eq_002_eq_135 = CONVEX EDGE LFN_P ANGLE1 == 90 LENGTH1 == 0.002 ANGLE2 == 90 WITH LENGTH == 0.135
LFN_P_90_90_jog_eq_002_eq_144 = CONVEX EDGE LFN_P ANGLE1 == 90 LENGTH1 == 0.002 ANGLE2 == 90 WITH LENGTH == 0.144
LFN_P_90_90_jog_eqlt_048_eq_180_192 = OR EDGE LFN_P_90_90_jog_eqlt_048_eq_180 LFN_P_90_90_jog_eqlt_048_eq_192
LFN_P_90_90_jog_180_192_225_240_135_144 = ((((LFN_P_90_90_jog_eqlt_048_eq_180 OR EDGE LFN_P_90_90_jog_eqlt_048_eq_192) OR EDGE LFN_P_90_90_jog_eqlt_048_eq_225) OR EDGE LFN_P_90_90_jog_eqlt_048_eq_240) OR EDGE LFN_P_90_90_jog_eq_002_eq_135) OR EDGE LFN_P_90_90_jog_eq_002_eq_144
LFN_P_90_90_jog_180_192_225_240_135_144_h_edges = ANGLE LFN_P_90_90_jog_180_192_225_240_135_144 == 0
LFN_P_90_90_jog_180_192_225_240_135_144_v_edges = ANGLE LFN_P_90_90_jog_180_192_225_240_135_144 == 90
LFN_P_90_90_jog_180_135_144 = (LFN_P_90_90_jog_eqlt_048_eq_180 OR EDGE LFN_P_90_90_jog_eq_002_eq_135) OR EDGE LFN_P_90_90_jog_eq_002_eq_144
LFN_P_90_90_jog_192_180_135_144 = LFN_P_90_90_jog_eqlt_048_eq_192 OR EDGE ((LFN_P_90_90_jog_eqlt_048_eq_180 OR EDGE LFN_P_90_90_jog_eq_002_eq_135) OR EDGE LFN_P_90_90_jog_eq_002_eq_144)

//;reverse VT 90-90 convex edges filter 
LFN_P_rvs = DRC:1 NOT LFN_P
LFN_P_rvs_90_90_jog_eqlt_048_eq_180 = CONVEX EDGE LFN_P_rvs ANGLE1 == 90 LENGTH1 <= 0.048 ANGLE2 == 90 WITH LENGTH == 0.180
LFN_P_rvs_90_90_jog_eqlt_048_eq_192 = CONVEX EDGE LFN_P_rvs ANGLE1 == 90 LENGTH1 <= 0.048 ANGLE2 == 90 WITH LENGTH == 0.192
LFN_P_rvs_90_90_jog_eqlt_048_eq_225 = CONVEX EDGE LFN_P_rvs ANGLE1 == 90 LENGTH1 <= 0.048 ANGLE2 == 90 WITH LENGTH == 0.225
LFN_P_rvs_90_90_jog_eqlt_048_eq_240 = CONVEX EDGE LFN_P_rvs ANGLE1 == 90 LENGTH1 <= 0.048 ANGLE2 == 90 WITH LENGTH == 0.240
LFN_P_rvs_90_90_jog_eq_002_eq_135 = CONVEX EDGE LFN_P_rvs ANGLE1 == 90 LENGTH1 == 0.002 ANGLE2 == 90 WITH LENGTH == 0.135
LFN_P_rvs_90_90_jog_eq_002_eq_144 = CONVEX EDGE LFN_P_rvs ANGLE1 == 90 LENGTH1 == 0.002 ANGLE2 == 90 WITH LENGTH == 0.144
LFN_P_rvs_90_90_jog_eqlt_048_eq_180_192 = OR EDGE LFN_P_rvs_90_90_jog_eqlt_048_eq_180 LFN_P_rvs_90_90_jog_eqlt_048_eq_192
LFN_P_rvs_90_90_jog_180_192_225_240_135_144 = ((((LFN_P_rvs_90_90_jog_eqlt_048_eq_180 OR EDGE LFN_P_rvs_90_90_jog_eqlt_048_eq_192) OR EDGE LFN_P_rvs_90_90_jog_eqlt_048_eq_225) OR EDGE LFN_P_rvs_90_90_jog_eqlt_048_eq_240) OR EDGE LFN_P_rvs_90_90_jog_eq_002_eq_135) OR EDGE LFN_P_rvs_90_90_jog_eq_002_eq_144
LFN_P_rvs_90_90_jog_180_135_144 = (LFN_P_rvs_90_90_jog_eqlt_048_eq_180 OR EDGE LFN_P_rvs_90_90_jog_eq_002_eq_135) OR EDGE LFN_P_rvs_90_90_jog_eq_002_eq_144

//;270-270 convex edges filter 
ALL_SVT_270_270_jog_eqlt_048_eq_180 = CONVEX EDGE ALL_SVT ANGLE1 == 270 LENGTH1 <= 0.048 ANGLE2 == 270 WITH LENGTH == 0.180
ALL_SVT_270_270_jog_eqlt_048_eq_192 = CONVEX EDGE ALL_SVT ANGLE1 == 270 LENGTH1 <= 0.048 ANGLE2 == 270 WITH LENGTH == 0.192
ALL_SVT_270_270_jog_eqlt_048_eq_225 = CONVEX EDGE ALL_SVT ANGLE1 == 270 LENGTH1 <= 0.048 ANGLE2 == 270 WITH LENGTH == 0.225
ALL_SVT_270_270_jog_eqlt_048_eq_240 = CONVEX EDGE ALL_SVT ANGLE1 == 270 LENGTH1 <= 0.048 ANGLE2 == 270 WITH LENGTH == 0.240
ALL_SVT_270_270_jog_eq_002_eq_135 = CONVEX EDGE ALL_SVT ANGLE1 == 270 LENGTH1 == 0.002 ANGLE2 == 270 WITH LENGTH == 0.135
ALL_SVT_270_270_jog_eq_002_eq_144 = CONVEX EDGE ALL_SVT ANGLE1 == 270 LENGTH1 == 0.002 ANGLE2 == 270 WITH LENGTH == 0.144
ALL_SVT_270_270_jog_eqlt_048_eq_180_192 = OR EDGE ALL_SVT_270_270_jog_eqlt_048_eq_180 ALL_SVT_270_270_jog_eqlt_048_eq_192
ALL_SVT_270_270_jog_180_192_225_240_135_144 = ((((ALL_SVT_270_270_jog_eqlt_048_eq_180 OR EDGE ALL_SVT_270_270_jog_eqlt_048_eq_192) OR EDGE ALL_SVT_270_270_jog_eqlt_048_eq_225) OR EDGE ALL_SVT_270_270_jog_eqlt_048_eq_240) OR EDGE ALL_SVT_270_270_jog_eq_002_eq_135) OR EDGE ALL_SVT_270_270_jog_eq_002_eq_144
ALL_SVT_270_270_jog_180_192_225_240_135_144_h_edges = ANGLE ALL_SVT_270_270_jog_180_192_225_240_135_144 == 0

//;90-90 convex edges filter 
ALL_SVT_90_90_jog_eqlt_048_eq_180 = CONVEX EDGE ALL_SVT ANGLE1 == 90 LENGTH1 <= 0.048 ANGLE2 == 90 WITH LENGTH == 0.180
ALL_SVT_90_90_jog_eqlt_048_eq_192 = CONVEX EDGE ALL_SVT ANGLE1 == 90 LENGTH1 <= 0.048 ANGLE2 == 90 WITH LENGTH == 0.192
ALL_SVT_90_90_jog_eqlt_048_eq_225 = CONVEX EDGE ALL_SVT ANGLE1 == 90 LENGTH1 <= 0.048 ANGLE2 == 90 WITH LENGTH == 0.225
ALL_SVT_90_90_jog_eqlt_048_eq_240 = CONVEX EDGE ALL_SVT ANGLE1 == 90 LENGTH1 <= 0.048 ANGLE2 == 90 WITH LENGTH == 0.240
ALL_SVT_90_90_jog_eq_002_eq_135 = CONVEX EDGE ALL_SVT ANGLE1 == 90 LENGTH1 == 0.002 ANGLE2 == 90 WITH LENGTH == 0.135
ALL_SVT_90_90_jog_eq_002_eq_144 = CONVEX EDGE ALL_SVT ANGLE1 == 90 LENGTH1 == 0.002 ANGLE2 == 90 WITH LENGTH == 0.144
ALL_SVT_90_90_jog_eqlt_048_eq_180_192 = OR EDGE ALL_SVT_90_90_jog_eqlt_048_eq_180 ALL_SVT_90_90_jog_eqlt_048_eq_192
ALL_SVT_90_90_jog_180_192_225_240_135_144 = ((((ALL_SVT_90_90_jog_eqlt_048_eq_180 OR EDGE ALL_SVT_90_90_jog_eqlt_048_eq_192) OR EDGE ALL_SVT_90_90_jog_eqlt_048_eq_225) OR EDGE ALL_SVT_90_90_jog_eqlt_048_eq_240) OR EDGE ALL_SVT_90_90_jog_eq_002_eq_135) OR EDGE ALL_SVT_90_90_jog_eq_002_eq_144
ALL_SVT_90_90_jog_180_192_225_240_135_144_h_edges = ANGLE ALL_SVT_90_90_jog_180_192_225_240_135_144 == 0
ALL_SVT_90_90_jog_180_192_225_240_135_144_v_edges = ANGLE ALL_SVT_90_90_jog_180_192_225_240_135_144 == 90
ALL_SVT_90_90_jog_180_135_144 = (ALL_SVT_90_90_jog_eqlt_048_eq_180 OR EDGE ALL_SVT_90_90_jog_eq_002_eq_135) OR EDGE ALL_SVT_90_90_jog_eq_002_eq_144
ALL_SVT_90_90_jog_192_180_135_144 = ALL_SVT_90_90_jog_eqlt_048_eq_192 OR EDGE ((ALL_SVT_90_90_jog_eqlt_048_eq_180 OR EDGE ALL_SVT_90_90_jog_eq_002_eq_135) OR EDGE ALL_SVT_90_90_jog_eq_002_eq_144)

//;reverse VT 90-90 convex edges filter 
ALL_SVT_rvs = DRC:1 NOT ALL_SVT
ALL_SVT_rvs_90_90_jog_eqlt_048_eq_180 = CONVEX EDGE ALL_SVT_rvs ANGLE1 == 90 LENGTH1 <= 0.048 ANGLE2 == 90 WITH LENGTH == 0.180
ALL_SVT_rvs_90_90_jog_eqlt_048_eq_192 = CONVEX EDGE ALL_SVT_rvs ANGLE1 == 90 LENGTH1 <= 0.048 ANGLE2 == 90 WITH LENGTH == 0.192
ALL_SVT_rvs_90_90_jog_eqlt_048_eq_225 = CONVEX EDGE ALL_SVT_rvs ANGLE1 == 90 LENGTH1 <= 0.048 ANGLE2 == 90 WITH LENGTH == 0.225
ALL_SVT_rvs_90_90_jog_eqlt_048_eq_240 = CONVEX EDGE ALL_SVT_rvs ANGLE1 == 90 LENGTH1 <= 0.048 ANGLE2 == 90 WITH LENGTH == 0.240
ALL_SVT_rvs_90_90_jog_eq_002_eq_135 = CONVEX EDGE ALL_SVT_rvs ANGLE1 == 90 LENGTH1 == 0.002 ANGLE2 == 90 WITH LENGTH == 0.135
ALL_SVT_rvs_90_90_jog_eq_002_eq_144 = CONVEX EDGE ALL_SVT_rvs ANGLE1 == 90 LENGTH1 == 0.002 ANGLE2 == 90 WITH LENGTH == 0.144
ALL_SVT_rvs_90_90_jog_eqlt_048_eq_180_192 = OR EDGE ALL_SVT_rvs_90_90_jog_eqlt_048_eq_180 ALL_SVT_rvs_90_90_jog_eqlt_048_eq_192
ALL_SVT_rvs_90_90_jog_180_192_225_240_135_144 = ((((ALL_SVT_rvs_90_90_jog_eqlt_048_eq_180 OR EDGE ALL_SVT_rvs_90_90_jog_eqlt_048_eq_192) OR EDGE ALL_SVT_rvs_90_90_jog_eqlt_048_eq_225) OR EDGE ALL_SVT_rvs_90_90_jog_eqlt_048_eq_240) OR EDGE ALL_SVT_rvs_90_90_jog_eq_002_eq_135) OR EDGE ALL_SVT_rvs_90_90_jog_eq_002_eq_144
ALL_SVT_rvs_90_90_jog_180_135_144 = (ALL_SVT_rvs_90_90_jog_eqlt_048_eq_180 OR EDGE ALL_SVT_rvs_90_90_jog_eq_002_eq_135) OR EDGE ALL_SVT_rvs_90_90_jog_eq_002_eq_144

//;270-270 convex edges filter 
ALL_LVT_270_270_jog_eqlt_048_eq_180 = CONVEX EDGE ALL_LVT ANGLE1 == 270 LENGTH1 <= 0.048 ANGLE2 == 270 WITH LENGTH == 0.180
ALL_LVT_270_270_jog_eqlt_048_eq_192 = CONVEX EDGE ALL_LVT ANGLE1 == 270 LENGTH1 <= 0.048 ANGLE2 == 270 WITH LENGTH == 0.192
ALL_LVT_270_270_jog_eqlt_048_eq_225 = CONVEX EDGE ALL_LVT ANGLE1 == 270 LENGTH1 <= 0.048 ANGLE2 == 270 WITH LENGTH == 0.225
ALL_LVT_270_270_jog_eqlt_048_eq_240 = CONVEX EDGE ALL_LVT ANGLE1 == 270 LENGTH1 <= 0.048 ANGLE2 == 270 WITH LENGTH == 0.240
ALL_LVT_270_270_jog_eq_002_eq_135 = CONVEX EDGE ALL_LVT ANGLE1 == 270 LENGTH1 == 0.002 ANGLE2 == 270 WITH LENGTH == 0.135
ALL_LVT_270_270_jog_eq_002_eq_144 = CONVEX EDGE ALL_LVT ANGLE1 == 270 LENGTH1 == 0.002 ANGLE2 == 270 WITH LENGTH == 0.144
ALL_LVT_270_270_jog_eqlt_048_eq_180_192 = OR EDGE ALL_LVT_270_270_jog_eqlt_048_eq_180 ALL_LVT_270_270_jog_eqlt_048_eq_192
ALL_LVT_270_270_jog_180_192_225_240_135_144 = ((((ALL_LVT_270_270_jog_eqlt_048_eq_180 OR EDGE ALL_LVT_270_270_jog_eqlt_048_eq_192) OR EDGE ALL_LVT_270_270_jog_eqlt_048_eq_225) OR EDGE ALL_LVT_270_270_jog_eqlt_048_eq_240) OR EDGE ALL_LVT_270_270_jog_eq_002_eq_135) OR EDGE ALL_LVT_270_270_jog_eq_002_eq_144
ALL_LVT_270_270_jog_180_192_225_240_135_144_h_edges = ANGLE ALL_LVT_270_270_jog_180_192_225_240_135_144 == 0

//;90-90 convex edges filter 
ALL_LVT_90_90_jog_eqlt_048_eq_180 = CONVEX EDGE ALL_LVT ANGLE1 == 90 LENGTH1 <= 0.048 ANGLE2 == 90 WITH LENGTH == 0.180
ALL_LVT_90_90_jog_eqlt_048_eq_192 = CONVEX EDGE ALL_LVT ANGLE1 == 90 LENGTH1 <= 0.048 ANGLE2 == 90 WITH LENGTH == 0.192
ALL_LVT_90_90_jog_eqlt_048_eq_225 = CONVEX EDGE ALL_LVT ANGLE1 == 90 LENGTH1 <= 0.048 ANGLE2 == 90 WITH LENGTH == 0.225
ALL_LVT_90_90_jog_eqlt_048_eq_240 = CONVEX EDGE ALL_LVT ANGLE1 == 90 LENGTH1 <= 0.048 ANGLE2 == 90 WITH LENGTH == 0.240
ALL_LVT_90_90_jog_eq_002_eq_135 = CONVEX EDGE ALL_LVT ANGLE1 == 90 LENGTH1 == 0.002 ANGLE2 == 90 WITH LENGTH == 0.135
ALL_LVT_90_90_jog_eq_002_eq_144 = CONVEX EDGE ALL_LVT ANGLE1 == 90 LENGTH1 == 0.002 ANGLE2 == 90 WITH LENGTH == 0.144
ALL_LVT_90_90_jog_eqlt_048_eq_180_192 = OR EDGE ALL_LVT_90_90_jog_eqlt_048_eq_180 ALL_LVT_90_90_jog_eqlt_048_eq_192
ALL_LVT_90_90_jog_180_192_225_240_135_144 = ((((ALL_LVT_90_90_jog_eqlt_048_eq_180 OR EDGE ALL_LVT_90_90_jog_eqlt_048_eq_192) OR EDGE ALL_LVT_90_90_jog_eqlt_048_eq_225) OR EDGE ALL_LVT_90_90_jog_eqlt_048_eq_240) OR EDGE ALL_LVT_90_90_jog_eq_002_eq_135) OR EDGE ALL_LVT_90_90_jog_eq_002_eq_144
ALL_LVT_90_90_jog_180_192_225_240_135_144_h_edges = ANGLE ALL_LVT_90_90_jog_180_192_225_240_135_144 == 0
ALL_LVT_90_90_jog_180_192_225_240_135_144_v_edges = ANGLE ALL_LVT_90_90_jog_180_192_225_240_135_144 == 90
ALL_LVT_90_90_jog_180_135_144 = (ALL_LVT_90_90_jog_eqlt_048_eq_180 OR EDGE ALL_LVT_90_90_jog_eq_002_eq_135) OR EDGE ALL_LVT_90_90_jog_eq_002_eq_144
ALL_LVT_90_90_jog_192_180_135_144 = ALL_LVT_90_90_jog_eqlt_048_eq_192 OR EDGE ((ALL_LVT_90_90_jog_eqlt_048_eq_180 OR EDGE ALL_LVT_90_90_jog_eq_002_eq_135) OR EDGE ALL_LVT_90_90_jog_eq_002_eq_144)

//;reverse VT 90-90 convex edges filter 
ALL_LVT_rvs = DRC:1 NOT ALL_LVT
ALL_LVT_rvs_90_90_jog_eqlt_048_eq_180 = CONVEX EDGE ALL_LVT_rvs ANGLE1 == 90 LENGTH1 <= 0.048 ANGLE2 == 90 WITH LENGTH == 0.180
ALL_LVT_rvs_90_90_jog_eqlt_048_eq_192 = CONVEX EDGE ALL_LVT_rvs ANGLE1 == 90 LENGTH1 <= 0.048 ANGLE2 == 90 WITH LENGTH == 0.192
ALL_LVT_rvs_90_90_jog_eqlt_048_eq_225 = CONVEX EDGE ALL_LVT_rvs ANGLE1 == 90 LENGTH1 <= 0.048 ANGLE2 == 90 WITH LENGTH == 0.225
ALL_LVT_rvs_90_90_jog_eqlt_048_eq_240 = CONVEX EDGE ALL_LVT_rvs ANGLE1 == 90 LENGTH1 <= 0.048 ANGLE2 == 90 WITH LENGTH == 0.240
ALL_LVT_rvs_90_90_jog_eq_002_eq_135 = CONVEX EDGE ALL_LVT_rvs ANGLE1 == 90 LENGTH1 == 0.002 ANGLE2 == 90 WITH LENGTH == 0.135
ALL_LVT_rvs_90_90_jog_eq_002_eq_144 = CONVEX EDGE ALL_LVT_rvs ANGLE1 == 90 LENGTH1 == 0.002 ANGLE2 == 90 WITH LENGTH == 0.144
ALL_LVT_rvs_90_90_jog_eqlt_048_eq_180_192 = OR EDGE ALL_LVT_rvs_90_90_jog_eqlt_048_eq_180 ALL_LVT_rvs_90_90_jog_eqlt_048_eq_192
ALL_LVT_rvs_90_90_jog_180_192_225_240_135_144 = ((((ALL_LVT_rvs_90_90_jog_eqlt_048_eq_180 OR EDGE ALL_LVT_rvs_90_90_jog_eqlt_048_eq_192) OR EDGE ALL_LVT_rvs_90_90_jog_eqlt_048_eq_225) OR EDGE ALL_LVT_rvs_90_90_jog_eqlt_048_eq_240) OR EDGE ALL_LVT_rvs_90_90_jog_eq_002_eq_135) OR EDGE ALL_LVT_rvs_90_90_jog_eq_002_eq_144
ALL_LVT_rvs_90_90_jog_180_135_144 = (ALL_LVT_rvs_90_90_jog_eqlt_048_eq_180 OR EDGE ALL_LVT_rvs_90_90_jog_eq_002_eq_135) OR EDGE ALL_LVT_rvs_90_90_jog_eq_002_eq_144

//;270-270 convex edges filter 
ALL_HVT_270_270_jog_eqlt_048_eq_180 = CONVEX EDGE ALL_HVT ANGLE1 == 270 LENGTH1 <= 0.048 ANGLE2 == 270 WITH LENGTH == 0.180
ALL_HVT_270_270_jog_eqlt_048_eq_192 = CONVEX EDGE ALL_HVT ANGLE1 == 270 LENGTH1 <= 0.048 ANGLE2 == 270 WITH LENGTH == 0.192
ALL_HVT_270_270_jog_eqlt_048_eq_225 = CONVEX EDGE ALL_HVT ANGLE1 == 270 LENGTH1 <= 0.048 ANGLE2 == 270 WITH LENGTH == 0.225
ALL_HVT_270_270_jog_eqlt_048_eq_240 = CONVEX EDGE ALL_HVT ANGLE1 == 270 LENGTH1 <= 0.048 ANGLE2 == 270 WITH LENGTH == 0.240
ALL_HVT_270_270_jog_eq_002_eq_135 = CONVEX EDGE ALL_HVT ANGLE1 == 270 LENGTH1 == 0.002 ANGLE2 == 270 WITH LENGTH == 0.135
ALL_HVT_270_270_jog_eq_002_eq_144 = CONVEX EDGE ALL_HVT ANGLE1 == 270 LENGTH1 == 0.002 ANGLE2 == 270 WITH LENGTH == 0.144
ALL_HVT_270_270_jog_eqlt_048_eq_180_192 = OR EDGE ALL_HVT_270_270_jog_eqlt_048_eq_180 ALL_HVT_270_270_jog_eqlt_048_eq_192
ALL_HVT_270_270_jog_180_192_225_240_135_144 = ((((ALL_HVT_270_270_jog_eqlt_048_eq_180 OR EDGE ALL_HVT_270_270_jog_eqlt_048_eq_192) OR EDGE ALL_HVT_270_270_jog_eqlt_048_eq_225) OR EDGE ALL_HVT_270_270_jog_eqlt_048_eq_240) OR EDGE ALL_HVT_270_270_jog_eq_002_eq_135) OR EDGE ALL_HVT_270_270_jog_eq_002_eq_144
ALL_HVT_270_270_jog_180_192_225_240_135_144_h_edges = ANGLE ALL_HVT_270_270_jog_180_192_225_240_135_144 == 0

//;90-90 convex edges filter 
ALL_HVT_90_90_jog_eqlt_048_eq_180 = CONVEX EDGE ALL_HVT ANGLE1 == 90 LENGTH1 <= 0.048 ANGLE2 == 90 WITH LENGTH == 0.180
ALL_HVT_90_90_jog_eqlt_048_eq_192 = CONVEX EDGE ALL_HVT ANGLE1 == 90 LENGTH1 <= 0.048 ANGLE2 == 90 WITH LENGTH == 0.192
ALL_HVT_90_90_jog_eqlt_048_eq_225 = CONVEX EDGE ALL_HVT ANGLE1 == 90 LENGTH1 <= 0.048 ANGLE2 == 90 WITH LENGTH == 0.225
ALL_HVT_90_90_jog_eqlt_048_eq_240 = CONVEX EDGE ALL_HVT ANGLE1 == 90 LENGTH1 <= 0.048 ANGLE2 == 90 WITH LENGTH == 0.240
ALL_HVT_90_90_jog_eq_002_eq_135 = CONVEX EDGE ALL_HVT ANGLE1 == 90 LENGTH1 == 0.002 ANGLE2 == 90 WITH LENGTH == 0.135
ALL_HVT_90_90_jog_eq_002_eq_144 = CONVEX EDGE ALL_HVT ANGLE1 == 90 LENGTH1 == 0.002 ANGLE2 == 90 WITH LENGTH == 0.144
ALL_HVT_90_90_jog_eqlt_048_eq_180_192 = OR EDGE ALL_HVT_90_90_jog_eqlt_048_eq_180 ALL_HVT_90_90_jog_eqlt_048_eq_192
ALL_HVT_90_90_jog_180_192_225_240_135_144 = ((((ALL_HVT_90_90_jog_eqlt_048_eq_180 OR EDGE ALL_HVT_90_90_jog_eqlt_048_eq_192) OR EDGE ALL_HVT_90_90_jog_eqlt_048_eq_225) OR EDGE ALL_HVT_90_90_jog_eqlt_048_eq_240) OR EDGE ALL_HVT_90_90_jog_eq_002_eq_135) OR EDGE ALL_HVT_90_90_jog_eq_002_eq_144
ALL_HVT_90_90_jog_180_192_225_240_135_144_h_edges = ANGLE ALL_HVT_90_90_jog_180_192_225_240_135_144 == 0
ALL_HVT_90_90_jog_180_192_225_240_135_144_v_edges = ANGLE ALL_HVT_90_90_jog_180_192_225_240_135_144 == 90
ALL_HVT_90_90_jog_180_135_144 = (ALL_HVT_90_90_jog_eqlt_048_eq_180 OR EDGE ALL_HVT_90_90_jog_eq_002_eq_135) OR EDGE ALL_HVT_90_90_jog_eq_002_eq_144
ALL_HVT_90_90_jog_192_180_135_144 = ALL_HVT_90_90_jog_eqlt_048_eq_192 OR EDGE ((ALL_HVT_90_90_jog_eqlt_048_eq_180 OR EDGE ALL_HVT_90_90_jog_eq_002_eq_135) OR EDGE ALL_HVT_90_90_jog_eq_002_eq_144)

//;reverse VT 90-90 convex edges filter 
ALL_HVT_rvs = DRC:1 NOT ALL_HVT
ALL_HVT_rvs_90_90_jog_eqlt_048_eq_180 = CONVEX EDGE ALL_HVT_rvs ANGLE1 == 90 LENGTH1 <= 0.048 ANGLE2 == 90 WITH LENGTH == 0.180
ALL_HVT_rvs_90_90_jog_eqlt_048_eq_192 = CONVEX EDGE ALL_HVT_rvs ANGLE1 == 90 LENGTH1 <= 0.048 ANGLE2 == 90 WITH LENGTH == 0.192
ALL_HVT_rvs_90_90_jog_eqlt_048_eq_225 = CONVEX EDGE ALL_HVT_rvs ANGLE1 == 90 LENGTH1 <= 0.048 ANGLE2 == 90 WITH LENGTH == 0.225
ALL_HVT_rvs_90_90_jog_eqlt_048_eq_240 = CONVEX EDGE ALL_HVT_rvs ANGLE1 == 90 LENGTH1 <= 0.048 ANGLE2 == 90 WITH LENGTH == 0.240
ALL_HVT_rvs_90_90_jog_eq_002_eq_135 = CONVEX EDGE ALL_HVT_rvs ANGLE1 == 90 LENGTH1 == 0.002 ANGLE2 == 90 WITH LENGTH == 0.135
ALL_HVT_rvs_90_90_jog_eq_002_eq_144 = CONVEX EDGE ALL_HVT_rvs ANGLE1 == 90 LENGTH1 == 0.002 ANGLE2 == 90 WITH LENGTH == 0.144
ALL_HVT_rvs_90_90_jog_eqlt_048_eq_180_192 = OR EDGE ALL_HVT_rvs_90_90_jog_eqlt_048_eq_180 ALL_HVT_rvs_90_90_jog_eqlt_048_eq_192
ALL_HVT_rvs_90_90_jog_180_192_225_240_135_144 = ((((ALL_HVT_rvs_90_90_jog_eqlt_048_eq_180 OR EDGE ALL_HVT_rvs_90_90_jog_eqlt_048_eq_192) OR EDGE ALL_HVT_rvs_90_90_jog_eqlt_048_eq_225) OR EDGE ALL_HVT_rvs_90_90_jog_eqlt_048_eq_240) OR EDGE ALL_HVT_rvs_90_90_jog_eq_002_eq_135) OR EDGE ALL_HVT_rvs_90_90_jog_eq_002_eq_144
ALL_HVT_rvs_90_90_jog_180_135_144 = (ALL_HVT_rvs_90_90_jog_eqlt_048_eq_180 OR EDGE ALL_HVT_rvs_90_90_jog_eq_002_eq_135) OR EDGE ALL_HVT_rvs_90_90_jog_eq_002_eq_144

//;270-270 convex edges filter 
ALL_ULVT_270_270_jog_eqlt_048_eq_180 = CONVEX EDGE ALL_ULVT ANGLE1 == 270 LENGTH1 <= 0.048 ANGLE2 == 270 WITH LENGTH == 0.180
ALL_ULVT_270_270_jog_eqlt_048_eq_192 = CONVEX EDGE ALL_ULVT ANGLE1 == 270 LENGTH1 <= 0.048 ANGLE2 == 270 WITH LENGTH == 0.192
ALL_ULVT_270_270_jog_eqlt_048_eq_225 = CONVEX EDGE ALL_ULVT ANGLE1 == 270 LENGTH1 <= 0.048 ANGLE2 == 270 WITH LENGTH == 0.225
ALL_ULVT_270_270_jog_eqlt_048_eq_240 = CONVEX EDGE ALL_ULVT ANGLE1 == 270 LENGTH1 <= 0.048 ANGLE2 == 270 WITH LENGTH == 0.240
ALL_ULVT_270_270_jog_eq_002_eq_135 = CONVEX EDGE ALL_ULVT ANGLE1 == 270 LENGTH1 == 0.002 ANGLE2 == 270 WITH LENGTH == 0.135
ALL_ULVT_270_270_jog_eq_002_eq_144 = CONVEX EDGE ALL_ULVT ANGLE1 == 270 LENGTH1 == 0.002 ANGLE2 == 270 WITH LENGTH == 0.144
ALL_ULVT_270_270_jog_eqlt_048_eq_180_192 = OR EDGE ALL_ULVT_270_270_jog_eqlt_048_eq_180 ALL_ULVT_270_270_jog_eqlt_048_eq_192
ALL_ULVT_270_270_jog_180_192_225_240_135_144 = ((((ALL_ULVT_270_270_jog_eqlt_048_eq_180 OR EDGE ALL_ULVT_270_270_jog_eqlt_048_eq_192) OR EDGE ALL_ULVT_270_270_jog_eqlt_048_eq_225) OR EDGE ALL_ULVT_270_270_jog_eqlt_048_eq_240) OR EDGE ALL_ULVT_270_270_jog_eq_002_eq_135) OR EDGE ALL_ULVT_270_270_jog_eq_002_eq_144
ALL_ULVT_270_270_jog_180_192_225_240_135_144_h_edges = ANGLE ALL_ULVT_270_270_jog_180_192_225_240_135_144 == 0

//;90-90 convex edges filter 
ALL_ULVT_90_90_jog_eqlt_048_eq_180 = CONVEX EDGE ALL_ULVT ANGLE1 == 90 LENGTH1 <= 0.048 ANGLE2 == 90 WITH LENGTH == 0.180
ALL_ULVT_90_90_jog_eqlt_048_eq_192 = CONVEX EDGE ALL_ULVT ANGLE1 == 90 LENGTH1 <= 0.048 ANGLE2 == 90 WITH LENGTH == 0.192
ALL_ULVT_90_90_jog_eqlt_048_eq_225 = CONVEX EDGE ALL_ULVT ANGLE1 == 90 LENGTH1 <= 0.048 ANGLE2 == 90 WITH LENGTH == 0.225
ALL_ULVT_90_90_jog_eqlt_048_eq_240 = CONVEX EDGE ALL_ULVT ANGLE1 == 90 LENGTH1 <= 0.048 ANGLE2 == 90 WITH LENGTH == 0.240
ALL_ULVT_90_90_jog_eq_002_eq_135 = CONVEX EDGE ALL_ULVT ANGLE1 == 90 LENGTH1 == 0.002 ANGLE2 == 90 WITH LENGTH == 0.135
ALL_ULVT_90_90_jog_eq_002_eq_144 = CONVEX EDGE ALL_ULVT ANGLE1 == 90 LENGTH1 == 0.002 ANGLE2 == 90 WITH LENGTH == 0.144
ALL_ULVT_90_90_jog_eqlt_048_eq_180_192 = OR EDGE ALL_ULVT_90_90_jog_eqlt_048_eq_180 ALL_ULVT_90_90_jog_eqlt_048_eq_192
ALL_ULVT_90_90_jog_180_192_225_240_135_144 = ((((ALL_ULVT_90_90_jog_eqlt_048_eq_180 OR EDGE ALL_ULVT_90_90_jog_eqlt_048_eq_192) OR EDGE ALL_ULVT_90_90_jog_eqlt_048_eq_225) OR EDGE ALL_ULVT_90_90_jog_eqlt_048_eq_240) OR EDGE ALL_ULVT_90_90_jog_eq_002_eq_135) OR EDGE ALL_ULVT_90_90_jog_eq_002_eq_144
ALL_ULVT_90_90_jog_180_192_225_240_135_144_h_edges = ANGLE ALL_ULVT_90_90_jog_180_192_225_240_135_144 == 0
ALL_ULVT_90_90_jog_180_192_225_240_135_144_v_edges = ANGLE ALL_ULVT_90_90_jog_180_192_225_240_135_144 == 90
ALL_ULVT_90_90_jog_180_135_144 = (ALL_ULVT_90_90_jog_eqlt_048_eq_180 OR EDGE ALL_ULVT_90_90_jog_eq_002_eq_135) OR EDGE ALL_ULVT_90_90_jog_eq_002_eq_144
ALL_ULVT_90_90_jog_192_180_135_144 = ALL_ULVT_90_90_jog_eqlt_048_eq_192 OR EDGE ((ALL_ULVT_90_90_jog_eqlt_048_eq_180 OR EDGE ALL_ULVT_90_90_jog_eq_002_eq_135) OR EDGE ALL_ULVT_90_90_jog_eq_002_eq_144)

//;reverse VT 90-90 convex edges filter 
ALL_ULVT_rvs = DRC:1 NOT ALL_ULVT
ALL_ULVT_rvs_90_90_jog_eqlt_048_eq_180 = CONVEX EDGE ALL_ULVT_rvs ANGLE1 == 90 LENGTH1 <= 0.048 ANGLE2 == 90 WITH LENGTH == 0.180
ALL_ULVT_rvs_90_90_jog_eqlt_048_eq_192 = CONVEX EDGE ALL_ULVT_rvs ANGLE1 == 90 LENGTH1 <= 0.048 ANGLE2 == 90 WITH LENGTH == 0.192
ALL_ULVT_rvs_90_90_jog_eqlt_048_eq_225 = CONVEX EDGE ALL_ULVT_rvs ANGLE1 == 90 LENGTH1 <= 0.048 ANGLE2 == 90 WITH LENGTH == 0.225
ALL_ULVT_rvs_90_90_jog_eqlt_048_eq_240 = CONVEX EDGE ALL_ULVT_rvs ANGLE1 == 90 LENGTH1 <= 0.048 ANGLE2 == 90 WITH LENGTH == 0.240
ALL_ULVT_rvs_90_90_jog_eq_002_eq_135 = CONVEX EDGE ALL_ULVT_rvs ANGLE1 == 90 LENGTH1 == 0.002 ANGLE2 == 90 WITH LENGTH == 0.135
ALL_ULVT_rvs_90_90_jog_eq_002_eq_144 = CONVEX EDGE ALL_ULVT_rvs ANGLE1 == 90 LENGTH1 == 0.002 ANGLE2 == 90 WITH LENGTH == 0.144
ALL_ULVT_rvs_90_90_jog_eqlt_048_eq_180_192 = OR EDGE ALL_ULVT_rvs_90_90_jog_eqlt_048_eq_180 ALL_ULVT_rvs_90_90_jog_eqlt_048_eq_192
ALL_ULVT_rvs_90_90_jog_180_192_225_240_135_144 = ((((ALL_ULVT_rvs_90_90_jog_eqlt_048_eq_180 OR EDGE ALL_ULVT_rvs_90_90_jog_eqlt_048_eq_192) OR EDGE ALL_ULVT_rvs_90_90_jog_eqlt_048_eq_225) OR EDGE ALL_ULVT_rvs_90_90_jog_eqlt_048_eq_240) OR EDGE ALL_ULVT_rvs_90_90_jog_eq_002_eq_135) OR EDGE ALL_ULVT_rvs_90_90_jog_eq_002_eq_144
ALL_ULVT_rvs_90_90_jog_180_135_144 = (ALL_ULVT_rvs_90_90_jog_eqlt_048_eq_180 OR EDGE ALL_ULVT_rvs_90_90_jog_eq_002_eq_135) OR EDGE ALL_ULVT_rvs_90_90_jog_eq_002_eq_144

//;270-270 convex edges filter 
ALL_LFN_270_270_jog_eqlt_048_eq_180 = CONVEX EDGE ALL_LFN ANGLE1 == 270 LENGTH1 <= 0.048 ANGLE2 == 270 WITH LENGTH == 0.180
ALL_LFN_270_270_jog_eqlt_048_eq_192 = CONVEX EDGE ALL_LFN ANGLE1 == 270 LENGTH1 <= 0.048 ANGLE2 == 270 WITH LENGTH == 0.192
ALL_LFN_270_270_jog_eqlt_048_eq_225 = CONVEX EDGE ALL_LFN ANGLE1 == 270 LENGTH1 <= 0.048 ANGLE2 == 270 WITH LENGTH == 0.225
ALL_LFN_270_270_jog_eqlt_048_eq_240 = CONVEX EDGE ALL_LFN ANGLE1 == 270 LENGTH1 <= 0.048 ANGLE2 == 270 WITH LENGTH == 0.240
ALL_LFN_270_270_jog_eq_002_eq_135 = CONVEX EDGE ALL_LFN ANGLE1 == 270 LENGTH1 == 0.002 ANGLE2 == 270 WITH LENGTH == 0.135
ALL_LFN_270_270_jog_eq_002_eq_144 = CONVEX EDGE ALL_LFN ANGLE1 == 270 LENGTH1 == 0.002 ANGLE2 == 270 WITH LENGTH == 0.144
ALL_LFN_270_270_jog_eqlt_048_eq_180_192 = OR EDGE ALL_LFN_270_270_jog_eqlt_048_eq_180 ALL_LFN_270_270_jog_eqlt_048_eq_192
ALL_LFN_270_270_jog_180_192_225_240_135_144 = ((((ALL_LFN_270_270_jog_eqlt_048_eq_180 OR EDGE ALL_LFN_270_270_jog_eqlt_048_eq_192) OR EDGE ALL_LFN_270_270_jog_eqlt_048_eq_225) OR EDGE ALL_LFN_270_270_jog_eqlt_048_eq_240) OR EDGE ALL_LFN_270_270_jog_eq_002_eq_135) OR EDGE ALL_LFN_270_270_jog_eq_002_eq_144
ALL_LFN_270_270_jog_180_192_225_240_135_144_h_edges = ANGLE ALL_LFN_270_270_jog_180_192_225_240_135_144 == 0

//;90-90 convex edges filter 
ALL_LFN_90_90_jog_eqlt_048_eq_180 = CONVEX EDGE ALL_LFN ANGLE1 == 90 LENGTH1 <= 0.048 ANGLE2 == 90 WITH LENGTH == 0.180
ALL_LFN_90_90_jog_eqlt_048_eq_192 = CONVEX EDGE ALL_LFN ANGLE1 == 90 LENGTH1 <= 0.048 ANGLE2 == 90 WITH LENGTH == 0.192
ALL_LFN_90_90_jog_eqlt_048_eq_225 = CONVEX EDGE ALL_LFN ANGLE1 == 90 LENGTH1 <= 0.048 ANGLE2 == 90 WITH LENGTH == 0.225
ALL_LFN_90_90_jog_eqlt_048_eq_240 = CONVEX EDGE ALL_LFN ANGLE1 == 90 LENGTH1 <= 0.048 ANGLE2 == 90 WITH LENGTH == 0.240
ALL_LFN_90_90_jog_eq_002_eq_135 = CONVEX EDGE ALL_LFN ANGLE1 == 90 LENGTH1 == 0.002 ANGLE2 == 90 WITH LENGTH == 0.135
ALL_LFN_90_90_jog_eq_002_eq_144 = CONVEX EDGE ALL_LFN ANGLE1 == 90 LENGTH1 == 0.002 ANGLE2 == 90 WITH LENGTH == 0.144
ALL_LFN_90_90_jog_eqlt_048_eq_180_192 = OR EDGE ALL_LFN_90_90_jog_eqlt_048_eq_180 ALL_LFN_90_90_jog_eqlt_048_eq_192
ALL_LFN_90_90_jog_180_192_225_240_135_144 = ((((ALL_LFN_90_90_jog_eqlt_048_eq_180 OR EDGE ALL_LFN_90_90_jog_eqlt_048_eq_192) OR EDGE ALL_LFN_90_90_jog_eqlt_048_eq_225) OR EDGE ALL_LFN_90_90_jog_eqlt_048_eq_240) OR EDGE ALL_LFN_90_90_jog_eq_002_eq_135) OR EDGE ALL_LFN_90_90_jog_eq_002_eq_144
ALL_LFN_90_90_jog_180_192_225_240_135_144_h_edges = ANGLE ALL_LFN_90_90_jog_180_192_225_240_135_144 == 0
ALL_LFN_90_90_jog_180_192_225_240_135_144_v_edges = ANGLE ALL_LFN_90_90_jog_180_192_225_240_135_144 == 90
ALL_LFN_90_90_jog_180_135_144 = (ALL_LFN_90_90_jog_eqlt_048_eq_180 OR EDGE ALL_LFN_90_90_jog_eq_002_eq_135) OR EDGE ALL_LFN_90_90_jog_eq_002_eq_144
ALL_LFN_90_90_jog_192_180_135_144 = ALL_LFN_90_90_jog_eqlt_048_eq_192 OR EDGE ((ALL_LFN_90_90_jog_eqlt_048_eq_180 OR EDGE ALL_LFN_90_90_jog_eq_002_eq_135) OR EDGE ALL_LFN_90_90_jog_eq_002_eq_144)

//;reverse VT 90-90 convex edges filter 
ALL_LFN_rvs = DRC:1 NOT ALL_LFN
ALL_LFN_rvs_90_90_jog_eqlt_048_eq_180 = CONVEX EDGE ALL_LFN_rvs ANGLE1 == 90 LENGTH1 <= 0.048 ANGLE2 == 90 WITH LENGTH == 0.180
ALL_LFN_rvs_90_90_jog_eqlt_048_eq_192 = CONVEX EDGE ALL_LFN_rvs ANGLE1 == 90 LENGTH1 <= 0.048 ANGLE2 == 90 WITH LENGTH == 0.192
ALL_LFN_rvs_90_90_jog_eqlt_048_eq_225 = CONVEX EDGE ALL_LFN_rvs ANGLE1 == 90 LENGTH1 <= 0.048 ANGLE2 == 90 WITH LENGTH == 0.225
ALL_LFN_rvs_90_90_jog_eqlt_048_eq_240 = CONVEX EDGE ALL_LFN_rvs ANGLE1 == 90 LENGTH1 <= 0.048 ANGLE2 == 90 WITH LENGTH == 0.240
ALL_LFN_rvs_90_90_jog_eq_002_eq_135 = CONVEX EDGE ALL_LFN_rvs ANGLE1 == 90 LENGTH1 == 0.002 ANGLE2 == 90 WITH LENGTH == 0.135
ALL_LFN_rvs_90_90_jog_eq_002_eq_144 = CONVEX EDGE ALL_LFN_rvs ANGLE1 == 90 LENGTH1 == 0.002 ANGLE2 == 90 WITH LENGTH == 0.144
ALL_LFN_rvs_90_90_jog_eqlt_048_eq_180_192 = OR EDGE ALL_LFN_rvs_90_90_jog_eqlt_048_eq_180 ALL_LFN_rvs_90_90_jog_eqlt_048_eq_192
ALL_LFN_rvs_90_90_jog_180_192_225_240_135_144 = ((((ALL_LFN_rvs_90_90_jog_eqlt_048_eq_180 OR EDGE ALL_LFN_rvs_90_90_jog_eqlt_048_eq_192) OR EDGE ALL_LFN_rvs_90_90_jog_eqlt_048_eq_225) OR EDGE ALL_LFN_rvs_90_90_jog_eqlt_048_eq_240) OR EDGE ALL_LFN_rvs_90_90_jog_eq_002_eq_135) OR EDGE ALL_LFN_rvs_90_90_jog_eq_002_eq_144
ALL_LFN_rvs_90_90_jog_180_135_144 = (ALL_LFN_rvs_90_90_jog_eqlt_048_eq_180 OR EDGE ALL_LFN_rvs_90_90_jog_eq_002_eq_135) OR EDGE ALL_LFN_rvs_90_90_jog_eq_002_eq_144

//;270-270 convex edges filter 
ALL_SVT_HVT_270_270_jog_eqlt_048_eq_180 = CONVEX EDGE ALL_SVT_HVT ANGLE1 == 270 LENGTH1 <= 0.048 ANGLE2 == 270 WITH LENGTH == 0.180
ALL_SVT_HVT_270_270_jog_eqlt_048_eq_192 = CONVEX EDGE ALL_SVT_HVT ANGLE1 == 270 LENGTH1 <= 0.048 ANGLE2 == 270 WITH LENGTH == 0.192
ALL_SVT_HVT_270_270_jog_eqlt_048_eq_225 = CONVEX EDGE ALL_SVT_HVT ANGLE1 == 270 LENGTH1 <= 0.048 ANGLE2 == 270 WITH LENGTH == 0.225
ALL_SVT_HVT_270_270_jog_eqlt_048_eq_240 = CONVEX EDGE ALL_SVT_HVT ANGLE1 == 270 LENGTH1 <= 0.048 ANGLE2 == 270 WITH LENGTH == 0.240
ALL_SVT_HVT_270_270_jog_eq_002_eq_135 = CONVEX EDGE ALL_SVT_HVT ANGLE1 == 270 LENGTH1 == 0.002 ANGLE2 == 270 WITH LENGTH == 0.135
ALL_SVT_HVT_270_270_jog_eq_002_eq_144 = CONVEX EDGE ALL_SVT_HVT ANGLE1 == 270 LENGTH1 == 0.002 ANGLE2 == 270 WITH LENGTH == 0.144
ALL_SVT_HVT_270_270_jog_eqlt_048_eq_180_192 = OR EDGE ALL_SVT_HVT_270_270_jog_eqlt_048_eq_180 ALL_SVT_HVT_270_270_jog_eqlt_048_eq_192
ALL_SVT_HVT_270_270_jog_180_192_225_240_135_144 = ((((ALL_SVT_HVT_270_270_jog_eqlt_048_eq_180 OR EDGE ALL_SVT_HVT_270_270_jog_eqlt_048_eq_192) OR EDGE ALL_SVT_HVT_270_270_jog_eqlt_048_eq_225) OR EDGE ALL_SVT_HVT_270_270_jog_eqlt_048_eq_240) OR EDGE ALL_SVT_HVT_270_270_jog_eq_002_eq_135) OR EDGE ALL_SVT_HVT_270_270_jog_eq_002_eq_144
ALL_SVT_HVT_270_270_jog_180_192_225_240_135_144_h_edges = ANGLE ALL_SVT_HVT_270_270_jog_180_192_225_240_135_144 == 0

//;90-90 convex edges filter 
ALL_SVT_HVT_90_90_jog_eqlt_048_eq_180 = CONVEX EDGE ALL_SVT_HVT ANGLE1 == 90 LENGTH1 <= 0.048 ANGLE2 == 90 WITH LENGTH == 0.180
ALL_SVT_HVT_90_90_jog_eqlt_048_eq_192 = CONVEX EDGE ALL_SVT_HVT ANGLE1 == 90 LENGTH1 <= 0.048 ANGLE2 == 90 WITH LENGTH == 0.192
ALL_SVT_HVT_90_90_jog_eqlt_048_eq_225 = CONVEX EDGE ALL_SVT_HVT ANGLE1 == 90 LENGTH1 <= 0.048 ANGLE2 == 90 WITH LENGTH == 0.225
ALL_SVT_HVT_90_90_jog_eqlt_048_eq_240 = CONVEX EDGE ALL_SVT_HVT ANGLE1 == 90 LENGTH1 <= 0.048 ANGLE2 == 90 WITH LENGTH == 0.240
ALL_SVT_HVT_90_90_jog_eq_002_eq_135 = CONVEX EDGE ALL_SVT_HVT ANGLE1 == 90 LENGTH1 == 0.002 ANGLE2 == 90 WITH LENGTH == 0.135
ALL_SVT_HVT_90_90_jog_eq_002_eq_144 = CONVEX EDGE ALL_SVT_HVT ANGLE1 == 90 LENGTH1 == 0.002 ANGLE2 == 90 WITH LENGTH == 0.144
ALL_SVT_HVT_90_90_jog_eqlt_048_eq_180_192 = OR EDGE ALL_SVT_HVT_90_90_jog_eqlt_048_eq_180 ALL_SVT_HVT_90_90_jog_eqlt_048_eq_192
ALL_SVT_HVT_90_90_jog_180_192_225_240_135_144 = ((((ALL_SVT_HVT_90_90_jog_eqlt_048_eq_180 OR EDGE ALL_SVT_HVT_90_90_jog_eqlt_048_eq_192) OR EDGE ALL_SVT_HVT_90_90_jog_eqlt_048_eq_225) OR EDGE ALL_SVT_HVT_90_90_jog_eqlt_048_eq_240) OR EDGE ALL_SVT_HVT_90_90_jog_eq_002_eq_135) OR EDGE ALL_SVT_HVT_90_90_jog_eq_002_eq_144
ALL_SVT_HVT_90_90_jog_180_192_225_240_135_144_h_edges = ANGLE ALL_SVT_HVT_90_90_jog_180_192_225_240_135_144 == 0
ALL_SVT_HVT_90_90_jog_180_192_225_240_135_144_v_edges = ANGLE ALL_SVT_HVT_90_90_jog_180_192_225_240_135_144 == 90
ALL_SVT_HVT_90_90_jog_180_135_144 = (ALL_SVT_HVT_90_90_jog_eqlt_048_eq_180 OR EDGE ALL_SVT_HVT_90_90_jog_eq_002_eq_135) OR EDGE ALL_SVT_HVT_90_90_jog_eq_002_eq_144
ALL_SVT_HVT_90_90_jog_192_180_135_144 = ALL_SVT_HVT_90_90_jog_eqlt_048_eq_192 OR EDGE ((ALL_SVT_HVT_90_90_jog_eqlt_048_eq_180 OR EDGE ALL_SVT_HVT_90_90_jog_eq_002_eq_135) OR EDGE ALL_SVT_HVT_90_90_jog_eq_002_eq_144)

//;reverse VT 90-90 convex edges filter 
ALL_SVT_HVT_rvs = DRC:1 NOT ALL_SVT_HVT
ALL_SVT_HVT_rvs_90_90_jog_eqlt_048_eq_180 = CONVEX EDGE ALL_SVT_HVT_rvs ANGLE1 == 90 LENGTH1 <= 0.048 ANGLE2 == 90 WITH LENGTH == 0.180
ALL_SVT_HVT_rvs_90_90_jog_eqlt_048_eq_192 = CONVEX EDGE ALL_SVT_HVT_rvs ANGLE1 == 90 LENGTH1 <= 0.048 ANGLE2 == 90 WITH LENGTH == 0.192
ALL_SVT_HVT_rvs_90_90_jog_eqlt_048_eq_225 = CONVEX EDGE ALL_SVT_HVT_rvs ANGLE1 == 90 LENGTH1 <= 0.048 ANGLE2 == 90 WITH LENGTH == 0.225
ALL_SVT_HVT_rvs_90_90_jog_eqlt_048_eq_240 = CONVEX EDGE ALL_SVT_HVT_rvs ANGLE1 == 90 LENGTH1 <= 0.048 ANGLE2 == 90 WITH LENGTH == 0.240
ALL_SVT_HVT_rvs_90_90_jog_eq_002_eq_135 = CONVEX EDGE ALL_SVT_HVT_rvs ANGLE1 == 90 LENGTH1 == 0.002 ANGLE2 == 90 WITH LENGTH == 0.135
ALL_SVT_HVT_rvs_90_90_jog_eq_002_eq_144 = CONVEX EDGE ALL_SVT_HVT_rvs ANGLE1 == 90 LENGTH1 == 0.002 ANGLE2 == 90 WITH LENGTH == 0.144
ALL_SVT_HVT_rvs_90_90_jog_eqlt_048_eq_180_192 = OR EDGE ALL_SVT_HVT_rvs_90_90_jog_eqlt_048_eq_180 ALL_SVT_HVT_rvs_90_90_jog_eqlt_048_eq_192
ALL_SVT_HVT_rvs_90_90_jog_180_192_225_240_135_144 = ((((ALL_SVT_HVT_rvs_90_90_jog_eqlt_048_eq_180 OR EDGE ALL_SVT_HVT_rvs_90_90_jog_eqlt_048_eq_192) OR EDGE ALL_SVT_HVT_rvs_90_90_jog_eqlt_048_eq_225) OR EDGE ALL_SVT_HVT_rvs_90_90_jog_eqlt_048_eq_240) OR EDGE ALL_SVT_HVT_rvs_90_90_jog_eq_002_eq_135) OR EDGE ALL_SVT_HVT_rvs_90_90_jog_eq_002_eq_144
ALL_SVT_HVT_rvs_90_90_jog_180_135_144 = (ALL_SVT_HVT_rvs_90_90_jog_eqlt_048_eq_180 OR EDGE ALL_SVT_HVT_rvs_90_90_jog_eq_002_eq_135) OR EDGE ALL_SVT_HVT_rvs_90_90_jog_eq_002_eq_144

//;270-270 convex edges filter 
ALL_HVT_N_SVT_N_270_270_jog_eqlt_048_eq_180 = CONVEX EDGE ALL_HVT_N_SVT_N ANGLE1 == 270 LENGTH1 <= 0.048 ANGLE2 == 270 WITH LENGTH == 0.180
ALL_HVT_N_SVT_N_270_270_jog_eqlt_048_eq_192 = CONVEX EDGE ALL_HVT_N_SVT_N ANGLE1 == 270 LENGTH1 <= 0.048 ANGLE2 == 270 WITH LENGTH == 0.192
ALL_HVT_N_SVT_N_270_270_jog_eqlt_048_eq_225 = CONVEX EDGE ALL_HVT_N_SVT_N ANGLE1 == 270 LENGTH1 <= 0.048 ANGLE2 == 270 WITH LENGTH == 0.225
ALL_HVT_N_SVT_N_270_270_jog_eqlt_048_eq_240 = CONVEX EDGE ALL_HVT_N_SVT_N ANGLE1 == 270 LENGTH1 <= 0.048 ANGLE2 == 270 WITH LENGTH == 0.240
ALL_HVT_N_SVT_N_270_270_jog_eq_002_eq_135 = CONVEX EDGE ALL_HVT_N_SVT_N ANGLE1 == 270 LENGTH1 == 0.002 ANGLE2 == 270 WITH LENGTH == 0.135
ALL_HVT_N_SVT_N_270_270_jog_eq_002_eq_144 = CONVEX EDGE ALL_HVT_N_SVT_N ANGLE1 == 270 LENGTH1 == 0.002 ANGLE2 == 270 WITH LENGTH == 0.144
ALL_HVT_N_SVT_N_270_270_jog_eqlt_048_eq_180_192 = OR EDGE ALL_HVT_N_SVT_N_270_270_jog_eqlt_048_eq_180 ALL_HVT_N_SVT_N_270_270_jog_eqlt_048_eq_192
ALL_HVT_N_SVT_N_270_270_jog_180_192_225_240_135_144 = ((((ALL_HVT_N_SVT_N_270_270_jog_eqlt_048_eq_180 OR EDGE ALL_HVT_N_SVT_N_270_270_jog_eqlt_048_eq_192) OR EDGE ALL_HVT_N_SVT_N_270_270_jog_eqlt_048_eq_225) OR EDGE ALL_HVT_N_SVT_N_270_270_jog_eqlt_048_eq_240) OR EDGE ALL_HVT_N_SVT_N_270_270_jog_eq_002_eq_135) OR EDGE ALL_HVT_N_SVT_N_270_270_jog_eq_002_eq_144
ALL_HVT_N_SVT_N_270_270_jog_180_192_225_240_135_144_h_edges = ANGLE ALL_HVT_N_SVT_N_270_270_jog_180_192_225_240_135_144 == 0

//;90-90 convex edges filter 
ALL_HVT_N_SVT_N_90_90_jog_eqlt_048_eq_180 = CONVEX EDGE ALL_HVT_N_SVT_N ANGLE1 == 90 LENGTH1 <= 0.048 ANGLE2 == 90 WITH LENGTH == 0.180
ALL_HVT_N_SVT_N_90_90_jog_eqlt_048_eq_192 = CONVEX EDGE ALL_HVT_N_SVT_N ANGLE1 == 90 LENGTH1 <= 0.048 ANGLE2 == 90 WITH LENGTH == 0.192
ALL_HVT_N_SVT_N_90_90_jog_eqlt_048_eq_225 = CONVEX EDGE ALL_HVT_N_SVT_N ANGLE1 == 90 LENGTH1 <= 0.048 ANGLE2 == 90 WITH LENGTH == 0.225
ALL_HVT_N_SVT_N_90_90_jog_eqlt_048_eq_240 = CONVEX EDGE ALL_HVT_N_SVT_N ANGLE1 == 90 LENGTH1 <= 0.048 ANGLE2 == 90 WITH LENGTH == 0.240
ALL_HVT_N_SVT_N_90_90_jog_eq_002_eq_135 = CONVEX EDGE ALL_HVT_N_SVT_N ANGLE1 == 90 LENGTH1 == 0.002 ANGLE2 == 90 WITH LENGTH == 0.135
ALL_HVT_N_SVT_N_90_90_jog_eq_002_eq_144 = CONVEX EDGE ALL_HVT_N_SVT_N ANGLE1 == 90 LENGTH1 == 0.002 ANGLE2 == 90 WITH LENGTH == 0.144
ALL_HVT_N_SVT_N_90_90_jog_eqlt_048_eq_180_192 = OR EDGE ALL_HVT_N_SVT_N_90_90_jog_eqlt_048_eq_180 ALL_HVT_N_SVT_N_90_90_jog_eqlt_048_eq_192
ALL_HVT_N_SVT_N_90_90_jog_180_192_225_240_135_144 = ((((ALL_HVT_N_SVT_N_90_90_jog_eqlt_048_eq_180 OR EDGE ALL_HVT_N_SVT_N_90_90_jog_eqlt_048_eq_192) OR EDGE ALL_HVT_N_SVT_N_90_90_jog_eqlt_048_eq_225) OR EDGE ALL_HVT_N_SVT_N_90_90_jog_eqlt_048_eq_240) OR EDGE ALL_HVT_N_SVT_N_90_90_jog_eq_002_eq_135) OR EDGE ALL_HVT_N_SVT_N_90_90_jog_eq_002_eq_144
ALL_HVT_N_SVT_N_90_90_jog_180_192_225_240_135_144_h_edges = ANGLE ALL_HVT_N_SVT_N_90_90_jog_180_192_225_240_135_144 == 0
ALL_HVT_N_SVT_N_90_90_jog_180_192_225_240_135_144_v_edges = ANGLE ALL_HVT_N_SVT_N_90_90_jog_180_192_225_240_135_144 == 90
ALL_HVT_N_SVT_N_90_90_jog_180_135_144 = (ALL_HVT_N_SVT_N_90_90_jog_eqlt_048_eq_180 OR EDGE ALL_HVT_N_SVT_N_90_90_jog_eq_002_eq_135) OR EDGE ALL_HVT_N_SVT_N_90_90_jog_eq_002_eq_144
ALL_HVT_N_SVT_N_90_90_jog_192_180_135_144 = ALL_HVT_N_SVT_N_90_90_jog_eqlt_048_eq_192 OR EDGE ((ALL_HVT_N_SVT_N_90_90_jog_eqlt_048_eq_180 OR EDGE ALL_HVT_N_SVT_N_90_90_jog_eq_002_eq_135) OR EDGE ALL_HVT_N_SVT_N_90_90_jog_eq_002_eq_144)

//;reverse VT 90-90 convex edges filter 
ALL_HVT_N_SVT_N_rvs = DRC:1 NOT ALL_HVT_N_SVT_N
ALL_HVT_N_SVT_N_rvs_90_90_jog_eqlt_048_eq_180 = CONVEX EDGE ALL_HVT_N_SVT_N_rvs ANGLE1 == 90 LENGTH1 <= 0.048 ANGLE2 == 90 WITH LENGTH == 0.180
ALL_HVT_N_SVT_N_rvs_90_90_jog_eqlt_048_eq_192 = CONVEX EDGE ALL_HVT_N_SVT_N_rvs ANGLE1 == 90 LENGTH1 <= 0.048 ANGLE2 == 90 WITH LENGTH == 0.192
ALL_HVT_N_SVT_N_rvs_90_90_jog_eqlt_048_eq_225 = CONVEX EDGE ALL_HVT_N_SVT_N_rvs ANGLE1 == 90 LENGTH1 <= 0.048 ANGLE2 == 90 WITH LENGTH == 0.225
ALL_HVT_N_SVT_N_rvs_90_90_jog_eqlt_048_eq_240 = CONVEX EDGE ALL_HVT_N_SVT_N_rvs ANGLE1 == 90 LENGTH1 <= 0.048 ANGLE2 == 90 WITH LENGTH == 0.240
ALL_HVT_N_SVT_N_rvs_90_90_jog_eq_002_eq_135 = CONVEX EDGE ALL_HVT_N_SVT_N_rvs ANGLE1 == 90 LENGTH1 == 0.002 ANGLE2 == 90 WITH LENGTH == 0.135
ALL_HVT_N_SVT_N_rvs_90_90_jog_eq_002_eq_144 = CONVEX EDGE ALL_HVT_N_SVT_N_rvs ANGLE1 == 90 LENGTH1 == 0.002 ANGLE2 == 90 WITH LENGTH == 0.144
ALL_HVT_N_SVT_N_rvs_90_90_jog_eqlt_048_eq_180_192 = OR EDGE ALL_HVT_N_SVT_N_rvs_90_90_jog_eqlt_048_eq_180 ALL_HVT_N_SVT_N_rvs_90_90_jog_eqlt_048_eq_192
ALL_HVT_N_SVT_N_rvs_90_90_jog_180_192_225_240_135_144 = ((((ALL_HVT_N_SVT_N_rvs_90_90_jog_eqlt_048_eq_180 OR EDGE ALL_HVT_N_SVT_N_rvs_90_90_jog_eqlt_048_eq_192) OR EDGE ALL_HVT_N_SVT_N_rvs_90_90_jog_eqlt_048_eq_225) OR EDGE ALL_HVT_N_SVT_N_rvs_90_90_jog_eqlt_048_eq_240) OR EDGE ALL_HVT_N_SVT_N_rvs_90_90_jog_eq_002_eq_135) OR EDGE ALL_HVT_N_SVT_N_rvs_90_90_jog_eq_002_eq_144
ALL_HVT_N_SVT_N_rvs_90_90_jog_180_135_144 = (ALL_HVT_N_SVT_N_rvs_90_90_jog_eqlt_048_eq_180 OR EDGE ALL_HVT_N_SVT_N_rvs_90_90_jog_eq_002_eq_135) OR EDGE ALL_HVT_N_SVT_N_rvs_90_90_jog_eq_002_eq_144

// =======================================================
// SVT_N: N-type Standard Vt MOS design rules
// =======================================================
GROUP GVT GSVT_N GSVT_P GLVT_N GLVT_P GHVT_N GHVT_P GULVT_N GULVT_P GLFN_N GLFN_P
GROUP GSVT_N SVT_N_?

SVT_N_W_1 {
@ SVT_N width, single-point-interaction is allowed >= 0.192um
@ DRC waive:
@ 1) SVT_N one-track width within the range of 0.09~0.106um, 0.18~0.212um when PRL = 0um
@ 2) Jog width adjacent to edge (length <= 0.048um, between two consecutive 90-270 degree corners) = 0.18um in S/D direction
@ 3) Jog width adjacent to edge (length = 0.002um, between two consecutive 90-270 degree corners) = 0.135/0.144um in S/D direction
 y1 = INT [SVT_N] < 0.192 ABUT<90 OPPOSITE EXTENDED 0.001
 y2 = INT [SVT_N] < 0.192 CORNER
 y3 = INT [SVT_N_v_edges] >= 0.09 < 0.107 PROJ == 0
 y4 = INT [SVT_N_v_edges] >= 0.18 < 0.213 PROJ == 0
 y5 = INT [SVT_N_h_edges] >= 0.09 < 0.107 PROJ == 0
 y6 = INT [SVT_N_h_edges] >= 0.18 < 0.213 PROJ == 0
 y_all = (y3 OR EDGE y4) OR EDGE (y5 OR EDGE y6)

 waive_edges = SVT_N_90_90_jog_180_135_144 COIN EDGE SVT_N_h_edges
 waive_corner = INT [SVT_N_v_edges] waive_edges < 0.001 ABUT==90 INTERSECTING ONLY
 err1 = (y1 NOT COIN EDGE y_all) NOT TOUCH EDGE waive_corner
 err2 = (y2 COIN EDGE SVT_N_concave_corner) NOT TOUCH EDGE y_all
 err1 NOT INSIDE EDGE SealR_NOT_BULK
 err2 NOT INSIDE EDGE SealR_NOT_BULK
}

SVT_N_W_2 {
@ SVT_N width in S/D direction, single-point-interaction is allowed >= 0.27um
@ DRC waive:
@ 1) SVT_N one-track width within the range of 0.09~0.106um, 0.18~0.212um when PRL = 0um
@ 2) Jog width adjacent to edge (length <= 0.048um, between two consecutive 90-270 degree corners) = 0.18/0.192/0.225/0.24um in S/D direction
@ 3) Jog width adjacent to edge (length = 0.002um, between two consecutive 90-270 degree corners) = 0.135/0.144um in S/D direction
 y1 = INT [SVT_N_v_edges] < 0.27 ABUT<90 OPPOSITE EXTENDED 0.001
 y2 = INT [SVT_N_v_edges] >= 0.09 < 0.107 PROJ == 0
 y3 = INT [SVT_N_v_edges] >= 0.18 < 0.213 PROJ == 0
 y_all = y2 OR EDGE y3

 waive_edges = SVT_N_90_90_jog_180_192_225_240_135_144 COIN EDGE SVT_N_h_edges
 waive_corner = INT [SVT_N_v_edges] waive_edges < 0.001 ABUT==90 INTERSECTING ONLY
 err1 = (y1 NOT COIN EDGE y_all) NOT TOUCH EDGE waive_corner
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

SVT_N_W_3 {
@ SVT_N width in S/D direction, when one SVT_N vertical edge CUT (GTMK1 OR AR) and ABUT HVT_N >= 0.315um
@ DRC waive: 
@ 1) Jog width adjacent to edge (length <= 0.048um, between two consecutive 90-270 degree corners) = 0.18/0.192/0.225/0.24um in S/D direction
@ 2) Jog width adjacent to edge (length = 0.002um, between two consecutive 90-270 degree corners) = 0.135/0.144um in S/D direction
 y1 = (SVT_N_v_edges INSIDE EDGE gtmk1_or_ar) COIN EDGE HVT_N
 y2 = SVT_N_v_edges TOUCH EDGE y1

 waive_corner = INT SVT_N_v_edges SVT_N_90_90_jog_180_192_225_240_135_144_h_edges <= 0.001 ABUT==90 INTERSECTING ONLY REGION
 check_corner = SVT_N_v_edges NOT TOUCH EDGE waive_corner
 err1 = INT y2 check_corner < 0.315 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

SVT_N_W_4 {
@ SVT_N width in GATE poly direction when SVT_N point touch or horizontal width in the range of 0.09~0.106um, 0.18~0.212um while PRL = 0um in GATE poly direction
@ (except L-shape/T-shape concave corner) >= 0.238um
 err1 = INT (SVT_N_h_edges_singular_point COIN EDGE SVT_N_concave_corner) SVT_N_h_edges < 0.238 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK

 y1 = SVT_N_convex_eqlt_1_edges COIN EDGE SVT_N_h_edges
 y2 = SVT_N COIN EDGE (EXPAND EDGE (y1 COIN EDGE SVT_N_concave_corner) INSIDE BY 0.001 OUTSIDE BY 0.001)
 y3 = INT [y2] >= 0.09 <= 0.106+0.0005 ABUT<90 PROJ == 0
 y4 = INT [y2] >= 0.18 <= 0.212+0.0005 ABUT<90 PROJ == 0
 y5 = SVT_N_concave_corner WITH EDGE (SVT_N_concave_corner COIN EDGE (y3 OR EDGE y4))
 y6 = SVT_N_h_edges COIN EDGE y5
 err2 = INT SVT_N_h_edges y6 < 0.238 ABUT<90 OPPOSITE REGION
 err3 = (LENGTH ((SVT_N_v_edges TOUCH EDGE y5) TOUCH EDGE SVT_N_convex_eq_1_edges) < 0.238) EXPAND EDGE INSIDE BY 0.001
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
}

SVT_N_S_1 {
@ Space between SVT_N, single-point-interaction is allowed >= 0.192um
@ DRC waive:
@ 1) SVT_N one-track space within the range of 0.09~0.106um, 0.18~0.212um when PRL = 0um
@ 2) Jog space adjacent to edge (length <= 0.048um, between two consecutive 90-270 degree corners) = 0.18um in S/D direction 
@ 3) Jog space adjacent to edge (length = 0.002um, between two consecutive 90-270 degree corners) = 0.135/0.144um in S/D direction
 y1 = EXT [SVT_N] < 0.192 ABUT<90 OPPOSITE EXTENDED 0.001
 y2 = EXT [SVT_N] < 0.192 CORNER
 y3 = EXT [SVT_N_v_edges] >= 0.09 < 0.107 PROJ == 0
 y4 = EXT [SVT_N_v_edges] >= 0.18 < 0.213 PROJ == 0
 y5 = EXT [SVT_N_h_edges] >= 0.09 < 0.107 PROJ == 0
 y6 = EXT [SVT_N_h_edges] >= 0.18 < 0.213 PROJ == 0
 y_all = (y3 OR EDGE y4) OR EDGE (y5 OR EDGE y6)
 w_all = SVT_N_rvs_90_90_jog_180_135_144 OR EDGE SVT_N_90_90_jog_180_135_144

 z1 = w_all COIN EDGE SVT_N_h_edges
 z2 = SVT_N_rvs COIN EDGE SVT_N_v_edges
 z3 = INT [z2] z1 < 0.005 ABUT==90 INTERSECTING ONLY
 err1 = (y1 NOT COIN EDGE y_all) NOT TOUCH EDGE z3
 err2 = (y2 COIN EDGE SVT_N_convex_corner) NOT COIN EDGE y_all
 err1 NOT INSIDE EDGE SealR_NOT_BULK
 err2 NOT INSIDE EDGE SealR_NOT_BULK
}

SVT_N_S_2 {
@ Space between SVT_N in S/D direction, single-point-interaction is allowed >= 0.27um
@ DRC waive:
@ 1) SVT_N one-track space within the range of 0.09~0.106um, 0.18~0.212um when PRL = 0um
@ 2) Jog space adjacent to edge (length <= 0.048um, between two consecutive 90-270 degree corners) = 0.180/0.192/0.225/0.24um in S/D direction
@ 3) Jog space adjacent to edge (length = 0.002um, between two consecutive 90-270 degree corners) = 0.135/0.144um in S/D direction
 w_all = SVT_N_90_90_jog_180_192_225_240_135_144 OR EDGE SVT_N_rvs_90_90_jog_180_192_225_240_135_144
 y1 = ANGLE (EXT [SVT_N] < 0.27 ABUT<90 OPPOSITE EXTENDED 0.001) == 90
 y2 = EXT [SVT_N_v_edges] >= 0.09 < 0.107 PROJ == 0
 y3 = EXT [SVT_N_v_edges] >= 0.18 < 0.213 PROJ == 0
 y4 = y2 OR EDGE y3

 z1 = ANGLE SVT_N_rvs == 0
 z2 = w_all COIN EDGE z1
 z3 = ANGLE SVT_N_rvs == 90
 z4 = INT [z3] z2 < 0.001 ABUT==90 INTERSECTING ONLY
 err1 = (y1 NOT COIN EDGE y4) NOT TOUCH EDGE z4
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

SVT_N_S_3a {
@ Space between SVT_N in S/D direction, when just one SVT_N vertical edge CUT (GTMK1 OR AR) and abut LVT_N or ULVT_N >= 0.315um
@ DRC waive:
@ 1) Jog space adjacent to edge (length <= 0.048um, between two consecutive 90-270 degree corners) = 0.180/0.192/0.225/0.24um in S/D direction
@ 2) Jog space adjacent to edge (length = 0.002um, between two consecutive 90-270 degree corners) = 0.135/0.144um in S/D direction
 check_edges = (SVT_N_inside_AA_side_mark_v_edges TOUCH EDGE LVT_N) OR EDGE (SVT_N_inside_AA_side_mark_v_edges TOUCH EDGE ULVT_N)
 waive_corner = EXT SVT_N_270_270_jog_180_192_225_240_135_144_h_edges check_edges <= 0.001 ABUT==90 INTERSECTING ONLY REGION
 check_corner = check_edges NOT TOUCH EDGE waive_corner
 err1 = EXT check_corner SVT_N_v_edges < 0.315 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

SVT_N_S_3b {
@ Space between SVT_N in S/D direction, when both SVT_N vertical edge CUT (GTMK1 OR AR) and abut LVT_N or ULVT_N >= 0.36um
@ DRC waive:
@ 1) Jog space adjacent to edge (length <= 0.048um, between two consecutive 90-270 degree corners) = 0.180/0.192/0.225/0.24um in S/D direction
@ 2) Jog space adjacent to edge (length = 0.002um, between two consecutive 90-270 degree corners) = 0.135/0.144um in S/D direction
 check_edges = (SVT_N_inside_AA_side_mark_v_edges TOUCH EDGE LVT_N) OR EDGE (SVT_N_inside_AA_side_mark_v_edges TOUCH EDGE ULVT_N)
 waive_corner = EXT SVT_N_270_270_jog_180_192_225_240_135_144_h_edges check_edges <= 0.001 ABUT==90 INTERSECTING ONLY REGION
 check_corner = check_edges NOT TOUCH EDGE waive_corner
 err1 = EXT check_corner < 0.36 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

SVT_N_S_4 {
@ Space between SVT_N when PRL >= 0.29um. >= 0.248um
 Layer_area = EXT SVT_N < 0.248 OPPOSITE REGION
 err1 = Layer_area ENCLOSE RECTANGLE 0.001 0.29 ORTHOGONAL ONLY
 err1 NOT INSIDE SealR_NOT_BULK
}

SVT_N_S_5 {
@ SVT_N space in GATE poly direction when SVT_N point touch or horizontal width in the range of 0.09~0.106um, 0.18~0.212um when PRL = 0um in GATE poly direction >= 0.238um
 err1 = EXT SVT_N_h_edges_singular_point SVT_N_h_edges < 0.238 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK

 y1 = SVT_N_convex_eqlt_1_edges COIN EDGE SVT_N_h_edges
 y2 = SVT_N COIN EDGE (EXPAND EDGE (y1 COIN EDGE SVT_N_concave_corner) INSIDE BY 0.001 OUTSIDE BY 0.001)
 y3 = INT [y2] >= 0.09 <= 0.106+0.0005 ABUT<90 PROJ == 0
 y4 = INT [y2] >= 0.18 <= 0.212+0.0005 ABUT<90 PROJ == 0
 y5 = SVT_N_concave_corner WITH EDGE (SVT_N_concave_corner COIN EDGE (y3 OR EDGE y4))
 y6 = SVT_N_h_edges TOUCH EDGE y5
 err2 = EXT SVT_N_h_edges y6 < 0.238 ABUT<90 OPPOSITE REGION
 err3 = (LENGTH ((SVT_N_v_edges TOUCH EDGE y5) TOUCH EDGE SVT_N_convex_eq_0_edges) < 0.238) EXPAND EDGE INSIDE BY 0.002
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
}

SVT_N_S_6 {
@ Space between SVT_N and ALL_AA (vertical edge abut AA edge is allowed) >= 0.045um
 CHECK_RAW = EXT SVT_N ALL_AA < 0.045 ABUT<90 SINGULAR
 WAIVE_CRN = SVT_N COIN OUTSIDE EDGE ALL_AA_v_edges
 err1 = DFM COPY (DFM PROPERTY CHECK_RAW WAIVE_CRN ABUT ALSO OVERLAP MULTI SPLIT [-= count(WAIVE_CRN)] == 0) REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

SVT_N_S_6a {
@ Space between SVT_N and ALL_AA in GATE poly direction >= 0.048um
 err1 = EXT SVT_N ALL_AA_h_edges < 0.048 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

SVT_N_S_7 {
@ Space between SVT_N and (ALL_GT NOT P2) (ALL_GT width < 0.07um), except small ALL_GT jogs <= 0.004um. >= 0.024um
 err1 = EXT SVT_N ALL_GT_NOT_P2_not_jog_lteq_004 < 0.024 ABUT<90 REGION MEASURE ALL  //;minimum
 err1 NOT INSIDE SealR_NOT_BULK
}

SVT_N_S_7a {
@ Space between SVT_N and (ALL_GT NOT P2) (ALL_GT width >= 0.07um) >= 0.034um
 err1 = EXT SVT_N (ALL_GT_eqgt_070 NOT P2) < 0.034 ABUT<90 SINGULAR REGION MEASURE ALL
 err1 NOT INSIDE SealR_NOT_BULK
}

SVT_N_S_7b {
@ Space between SVT_N and (ALL_GT NOT P2) (ALL_GT width > 0.09um) >= 0.058um
 err1 = EXT SVT_N ALL_GT_NOT_P2_gt_090 < 0.058 ABUT<90 SINGULAR REGION MEASURE ALL
 err1 NOT INSIDE SealR_NOT_BULK
}

SVT_N_S_8 {
@ Space between SVT_N and (ALL_GT NOT P2) (ALL_GT width < 0.07um) in S/D direction >= 0.035um
 err1 = EXT ALL_GT_NOT_P2 SVT_N_v_edges < 0.035 ABUT<90 OPPOSITE REGION  //;minimum
 err1 NOT INSIDE SealR_NOT_BULK
}

SVT_N_S_8a {
@ Space between SVT_N and (ALL_GT NOT P2) (ALL_GT width >= 0.07um) in S/D direction >= 0.058um
 err1 = EXT SVT_N_v_edges ALL_GT_NOT_P2_eqgt_070 < 0.058 ABUT<90 OPPOSITE REGION MEASURE ALL
 err1 NOT INSIDE SealR_NOT_BULK
}

SVT_N_S_9a {
@ Space between SVT_N and GATE (when channel length = 0.016/0.018/0.02um) in S/D direction (GATE CUT SVT_N is not allowed), except GT_P96 region >= 0.082/0.081/0.08um
 err1 = DFM COPY (DFM SPACE GATE_LE_16 SVT_N < 0.082 BY EXT HORIZONTAL MEASURE ALL) REGION
 err2 = DFM COPY (DFM SPACE GATE_LE_18 SVT_N < 0.081 BY EXT HORIZONTAL MEASURE ALL) REGION
 err3 = DFM COPY (DFM SPACE GATE_LE_20 SVT_N < 0.080 BY EXT HORIZONTAL MEASURE ALL) REGION
 err4 = GATE CUT SVT_N

 err1 NOT INSIDE GT_P96
 err2 NOT INSIDE GT_P96
 err3 NOT INSIDE GT_P96
 err4 NOT INSIDE GT_P96
}

SVT_N_S_9b {
@ Space between SVT_N and GATE (when channel length = 0.016/0.018/0.02/0.022/0.024um, INSIDE GT_P96) in S/D direction (GATE CUT SVT_N is not allowed) >= 0.088/0.087/0.086/0.085/0.084um
 err1 = DFM COPY (DFM SPACE GATE_LE_16_in_GT_P96 SVT_N < 0.088 BY EXT HORIZONTAL MEASURE ALL) REGION
 err2 = DFM COPY (DFM SPACE GATE_LE_18_in_GT_P96 SVT_N < 0.087 BY EXT HORIZONTAL MEASURE ALL) REGION
 err3 = DFM COPY (DFM SPACE GATE_LE_20_in_GT_P96 SVT_N < 0.086 BY EXT HORIZONTAL MEASURE ALL) REGION
 err4 = DFM COPY (DFM SPACE GATE_LE_22_in_GT_P96 SVT_N < 0.085 BY EXT HORIZONTAL MEASURE ALL) REGION
 err5 = DFM COPY (DFM SPACE GATE_LE_24_in_GT_P96 SVT_N < 0.084 BY EXT HORIZONTAL MEASURE ALL) REGION
 err6 = GATE CUT SVT_N

 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
 err4 NOT INSIDE SealR_NOT_BULK
 err5 NOT INSIDE SealR_NOT_BULK
 err6 NOT INSIDE SealR_NOT_BULK
}

SVT_N_S_10 {
@ Space between SVT_N vertical edge (edge length <= 0.238um between two concave corners with both sides length >= 0.09um) and ((GT AND GTMK1) OR GATE) in S/D direction >= 0.079um
 check_RAW = CONVEX EDGE SVT_N ANGLE1 == 270 LENGTH1 >= 0.09 ANGLE2 == 270 LENGTH2 >= 0.09 WITH LENGTH <= 0.238
 check_TMP = ANGLE check_RAW == 90
 err1 = EXT (OR GATE_raw GT_and_GTMK1) check_TMP < 0.079 ABUT<90 OPPOSITE REGION  //;including edge GATE
 err1 NOT INSIDE SealR_NOT_BULK
}

SVT_N_S_11 {
@ Space between SVT_N and (ALL_GT NOT P2) in GATE poly direction with adjacent horizontal space to (ALL_GT NOT P2) <= 0.04um (SVT_N vertical edge length = 0.073~0.15um, between two consecutive 90-270 degree coners) >= 0.054um
 y1 = EXT [ALL_GT_NOT_P2] SVT_N_convex_90_270_eqgt_073_lteq_150_v_edges <= 0.040 ABUT<90 OPPOSITE
 y2 = EXT [SVT_N_h_edges] SVT_N_convex_90_270_eqgt_073_lteq_150_v_edges < 0.005 ABUT==90 INTERSECTING ONLY

 z1 = SVT_N_h_edges TOUCH EDGE y2
 z2 = EXT ALL_GT_NOT_P2 z1 < 0.054 ABUT<90 OPPOSITE REGION
 z3 = EXPAND EDGE y1 INSIDE BY 0.005 EXTEND BY 0.005
 err1 = z2 INTERACT z3
 err1 NOT INSIDE SealR_NOT_BULK
}

SVT_N_S_12 {
@ Space between SVT_N, SVT_P, LVT_N, LVT_P, HVT_N, HVT_P, LFN_N, LFN_P, ULVT_N and ULVT_P inside GT in GATE poly direction when PRL = 0um, and at least one vertical edge CUT (GTMK1 OR AR)) = 0um
@ DRC flags if more than one Vt horizontal edge inside (((GT NOT P2) INTERACT (GTMK1 OR AR)) NOT (AA OR GTMK1)))
 AE1 = GT_0 INTERACT gtmk1_or_ar
 AE2_SVT_N = EXPAND EDGE (SVT_N_v_edges TOUCH EDGE SVT_N_inside_AA_side_mark_v_edges) INSIDE BY 0.001 OUTSIDE BY 0.001
 AE2_SVT_P = EXPAND EDGE (SVT_P_v_edges TOUCH EDGE SVT_P_inside_AA_side_mark_v_edges) INSIDE BY 0.001 OUTSIDE BY 0.001
 AE2_LVT_N = EXPAND EDGE (LVT_N_v_edges TOUCH EDGE LVT_N_inside_AA_side_mark_v_edges) INSIDE BY 0.001 OUTSIDE BY 0.001
 AE2_LVT_P = EXPAND EDGE (LVT_P_v_edges TOUCH EDGE LVT_P_inside_AA_side_mark_v_edges) INSIDE BY 0.001 OUTSIDE BY 0.001
 AE2_HVT_N = EXPAND EDGE (HVT_N_v_edges TOUCH EDGE HVT_N_inside_AA_side_mark_v_edges) INSIDE BY 0.001 OUTSIDE BY 0.001
 AE2_HVT_P = EXPAND EDGE (HVT_P_v_edges TOUCH EDGE HVT_P_inside_AA_side_mark_v_edges) INSIDE BY 0.001 OUTSIDE BY 0.001
 AE2_LFN_N = EXPAND EDGE (LFN_N_v_edges TOUCH EDGE LFN_N_inside_AA_side_mark_v_edges) INSIDE BY 0.001 OUTSIDE BY 0.001
 AE2_LFN_P = EXPAND EDGE (LFN_P_v_edges TOUCH EDGE LFN_P_inside_AA_side_mark_v_edges) INSIDE BY 0.001 OUTSIDE BY 0.001
 AE2_ULVT_N = EXPAND EDGE (ULVT_N_v_edges TOUCH EDGE ULVT_N_inside_AA_side_mark_v_edges) INSIDE BY 0.001 OUTSIDE BY 0.001
 AE2_ULVT_P = EXPAND EDGE (ULVT_P_v_edges TOUCH EDGE ULVT_P_inside_AA_side_mark_v_edges) INSIDE BY 0.001 OUTSIDE BY 0.001
 AE2 = OR AE2_SVT_N AE2_SVT_P AE2_LVT_N AE2_LVT_P AE2_HVT_N AE2_HVT_P AE2_LFN_N AE2_LFN_P AE2_ULVT_N AE2_ULVT_P
 AE3 = (AE1 INTERACT AE2) NOT (OR AA gtmk1_or_ar)

 W11 = ANGLE (SVT_N INSIDE EDGE AE3) == 0
 W12 = ANGLE (SVT_P INSIDE EDGE AE3) == 0
 W13 = ANGLE (LVT_N INSIDE EDGE AE3) == 0
 W14 = ANGLE (LVT_P INSIDE EDGE AE3) == 0
 W15 = ANGLE (HVT_N INSIDE EDGE AE3) == 0
 W16 = ANGLE (HVT_P INSIDE EDGE AE3) == 0
 W17 = ANGLE (LFN_N INSIDE EDGE AE3) == 0
 W18 = ANGLE (LFN_P INSIDE EDGE AE3) == 0
 W19 = ANGLE (ULVT_N INSIDE EDGE AE3) == 0
 W20 = ANGLE (ULVT_P INSIDE EDGE AE3) == 0

 y11 = EXPAND EDGE W11 INSIDE BY 0.001
 y12 = EXPAND EDGE W12 INSIDE BY 0.001
 y13 = EXPAND EDGE W13 INSIDE BY 0.001
 y14 = EXPAND EDGE W14 INSIDE BY 0.001
 y15 = EXPAND EDGE W15 INSIDE BY 0.001
 y16 = EXPAND EDGE W16 INSIDE BY 0.001
 y17 = EXPAND EDGE W17 INSIDE BY 0.001
 y18 = EXPAND EDGE W18 INSIDE BY 0.001
 y19 = EXPAND EDGE W19 INSIDE BY 0.001
 y20 = EXPAND EDGE W20 INSIDE BY 0.001

 w_all = OR y11 y12 y13 y14 y15 y16 y17 y18 y19 y20
 err1 = w_all INTERACT (AE3 ENCLOSE w_all >= 2)
 err2 = NOT RECTANGLE w_all
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

SVT_N_EX_1 {
@ SVT_N extension outside of ALL_AA (vertical edge abut AA edge is allowed) >= 0.045um
 CHECK_RAW = ENC ALL_AA SVT_N < 0.045 ABUT<90 SINGULAR
 WAIVE_CRN = SVT_N COIN INSIDE EDGE ALL_AA_v_edges
 err1 = DFM COPY (DFM PROPERTY CHECK_RAW WAIVE_CRN ABUT ALSO OVERLAP MULTI SPLIT [-= count(WAIVE_CRN)] == 0) REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

SVT_N_EX_2 {
@ SVT_N extension outside of ALL_AA in GATE poly direction >= 0.048um
 err1 = SVT_N_h_edges INSIDE EDGE ALL_AA
 err2 = ENC ALL_AA_h_edges SVT_N < 0.048 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE EDGE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

SVT_N_EX_3 {
@ SVT_N extension outside of (ALL_GT NOT P2) (ALL_GT width < 0.07um), except small ALL_GT jog <= 0.004um. >= 0.024um
 err1 = ENC ALL_GT_NOT_P2_not_jog_lteq_004 SVT_N < 0.024 ABUT<90 OPPOSITE REGION  //;minimum
 err1 NOT INSIDE SealR_NOT_BULK
}

SVT_N_EX_4 {
@ SVT_N extension outside of (ALL_GT NOT P2) (ALL_GT width >= 0.07um) >= 0.034um
 err1 = ENC ALL_GT_NOT_P2_eqgt_070 SVT_N < 0.034 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

SVT_N_EX_5 {
@ SVT_N extension outside of (ALL_GT NOT P2) (ALL_GT width > 0.09um) >= 0.058um
 err1 = ENC ALL_GT_NOT_P2_gt_090 SVT_N < 0.058 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

SVT_N_EX_6 {
@ SVT_N extension outside of (ALL_GT NOT P2) (ALL_GT width < 0.07um) in S/D direction >= 0.035um
 err1 = ENC ALL_GT_NOT_P2 SVT_N_v_edges < 0.035 ABUT<90 OPPOSITE REGION //;minimum
 err1 NOT INSIDE SealR_NOT_BULK
}

SVT_N_EX_7 {
@ SVT_N extension outside of (ALL_GT NOT P2) (ALL_GT width >= 0.07um) in S/D direction >= 0.058um
 err1 = ENC ALL_GT_NOT_P2_eqgt_070 SVT_N_v_edges < 0.058 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

SVT_N_EX_8 {
@ SVT_N extension outside of GATE (when channel length = 0.016/0.018/0.02um) respectively in S/D direction, except GT_P96 region >= 0.082/0.081/0.08um
 err1 = DFM COPY (DFM SPACE GATE_LE_16 SVT_N < 0.082 BY ENC HORIZONTAL) REGION
 err2 = DFM COPY (DFM SPACE GATE_LE_18 SVT_N < 0.081 BY ENC HORIZONTAL) REGION
 err3 = DFM COPY (DFM SPACE GATE_LE_20 SVT_N < 0.080 BY ENC HORIZONTAL) REGION

 err1 NOT INSIDE GT_P96
 err2 NOT INSIDE GT_P96
 err3 NOT INSIDE GT_P96
}

SVT_N_EX_9 {
@ SVT_N extension outside of GATE (when channel length = 0.016/0.018/0.02/0.022/0.024um) respectively INSIDE GT_P96 in S/D direction >= 0.088/0.087/0.086/0.085/0.084um
 err1 = (DFM COPY (DFM SPACE GATE_LE_16 SVT_N < 0.088 BY ENC HORIZONTAL) REGION) NOT OUTSIDE GT_P96
 err2 = (DFM COPY (DFM SPACE GATE_LE_18 SVT_N < 0.087 BY ENC HORIZONTAL) REGION) NOT OUTSIDE GT_P96
 err3 = (DFM COPY (DFM SPACE GATE_LE_20 SVT_N < 0.086 BY ENC HORIZONTAL) REGION) NOT OUTSIDE GT_P96
 err4 = (DFM COPY (DFM SPACE GATE_LE_22 SVT_N < 0.085 BY ENC HORIZONTAL) REGION) NOT OUTSIDE GT_P96
 err5 = (DFM COPY (DFM SPACE GATE_LE_24 SVT_N < 0.084 BY ENC HORIZONTAL) REGION) NOT OUTSIDE GT_P96

 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
 err4 NOT INSIDE SealR_NOT_BULK
 err5 NOT INSIDE SealR_NOT_BULK
}

SVT_N_EX_10 {
@ SVT_N (line-end vertical width <= 0.238um between two consecutive 90-90 degree corners with both sides length >= 0.09um) enclosure of ((GT AND GTMK1) OR GATE) in S/D direction >= 0.079um
 check_RAW = CONVEX EDGE SVT_N ANGLE1 == 90 LENGTH1 >= 0.09 ANGLE2 == 90 LENGTH2 >= 0.09 WITH LENGTH <= 0.238
 check_TMP = ANGLE check_RAW == 90
 err1 = ENC (OR GATE_raw GT_and_GTMK1) check_TMP < 0.079 ABUT<90 OPPOSITE REGION  //;including edge GATE
 err1 NOT INSIDE SealR_NOT_BULK
}

SVT_N_EX_11 {
@ SVT_N extension outside of (ALL_GT NOT P2) in GATE poly direction with adjacent horizontal enclosure <= 0.04um by SVT vertical edge (edge length = 0.073~0.150um,
@ between two consecutive 90-270 degree corners) >= 0.054um
 y1 = ENC [ALL_GT_NOT_P2] SVT_N_convex_90_270_eqgt_073_lteq_150_v_edges <= 0.040 ABUT<90 OPPOSITE
 y2 = INT [SVT_N_h_edges] SVT_N_convex_90_270_eqgt_073_lteq_150_v_edges < 0.005 ABUT==90 INTERSECTING ONLY
 y3 = SVT_N_h_edges TOUCH EDGE y2
 y4 = ENC ALL_GT_NOT_P2 y3 < 0.054 ABUT<90 OPPOSITE REGION
 y5 = EXPAND EDGE y1 INSIDE BY 0.005 EXTEND BY 0.005
 err1 = y4 INTERACT y5
 err1 NOT INSIDE SealR_NOT_BULK
}

all_GT_center_region = DFM SPACE ALL_GT <= 0.024 BY INT HORIZONTAL
all_GT_center_odd = DFM COPY (DFM PROPERTY all_GT_center_region [-= ABS(REMAINDER(EW(all_GT_center_region), 0.002))] > 0) CENTERLINE
all_GT_center_even = DFM COPY (DFM PROPERTY all_GT_center_region [-= ABS(REMAINDER(EW(all_GT_center_region), 0.002))] == 0) CENTERLINE
all_GT_in_ar_gtmk1 = WITH WIDTH (ALL_GT AND gtmk1_or_ar) <= 0.024

SVT_N_in_ALL_GT_h_edges = ANGLE (SVT_N NOT OUTSIDE EDGE ALL_GT) == 0
SVT_N_in_all_GT_in_ar_gtmk1_edges = SVT_N NOT OUTSIDE EDGE all_GT_in_ar_gtmk1
SVT_N_in_all_GT_in_ar_gtmk1_area = INT SVT_N_in_all_GT_in_ar_gtmk1_edges < 0.005 ABUT INTERSECTING ONLY REGION

SVT_N_EX_12 {
@ (ALL_GT NOT P2) extension outside of SVT_N, except small ALL_GT jogs <= 0.004um, Dummy_Cell_WO_IMP, and SVT_N vertical edge CUT (GTMK1 OR AR) (channel length <= 0.024um, centerline abut SVT_N vertical edge) >= 0.083um
//;Only need to check the vertical extension
 y1 = SVT_N_in_all_GT_in_ar_gtmk1_edges COIN EDGE all_GT_center_even
 y2 = ANGLE (SVT_N_in_all_GT_in_ar_gtmk1_edges TOUCH EDGE (SVT_N_in_all_GT_in_ar_gtmk1_area WITH EDGE (SVT_N_in_all_GT_in_ar_gtmk1_area COIN EDGE y1))) == 0
 y3 = SVT_N_in_ALL_GT_h_edges NOT COIN EDGE y2
 err1 = ENC y3 ALL_GT_NOT_P2_not_jog_lteq_004 < 0.083 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE Dummy_Cell_WO_IMP
}

SVT_N_O_1 {
@ Overlap of (ALL_GT NOT P2) and SVT_N, except small ALL_GT jogs <= 0.004um, Dummy_Cell_WO_IMP, and SVT_N vertical edge CUT (GTMK1 OR AR) (channel length <= 0.024um, centerline abut SVT_N vertical edge) >= 0.083um
//;Only need to check the vertical overlap
 y1 = SVT_N_in_all_GT_in_ar_gtmk1_edges COIN EDGE all_GT_center_even
 y2 = ANGLE (SVT_N_in_all_GT_in_ar_gtmk1_edges TOUCH EDGE (SVT_N_in_all_GT_in_ar_gtmk1_area WITH EDGE (SVT_N_in_all_GT_in_ar_gtmk1_area COIN EDGE y1))) == 0
 y3 = SVT_N_in_ALL_GT_h_edges NOT COIN EDGE y2
 err1 = INT y3 ALL_GT_NOT_P2_not_jog_lteq_004 < 0.083 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE Dummy_Cell_WO_IMP
}

SVT_N_A_1 {
@ SVT_N area >= 0.085um2
 err1 = AREA SVT_N < VT_MiniArea
 err1 NOT INSIDE SealR_NOT_BULK
}

SVT_N_A_2 {
@ SVT_N enclosed area >= 0.085um2
 err1 = AREA ((HOLES SVT_N INNER SINGULAR ALSO) NOT SVT_N) < VT_MiniArea
 err1 NOT INSIDE SealR_NOT_BULK
}

SVT_N_A_3 {
@ Area of ((ALL_GT NOT P2) AND SVT_N) >= 0.00158um2
 err1 = AREA (ALL_GT_NOT_P2 AND SVT_N) < 0.00158
 err1 NOT INSIDE SealR_NOT_BULK
}

SVT_N_R_1 {
@ (ALL_AA interact GT (width >= 0.032um)) CUT SVT_N is not allowed
 err1 = ALL_AA_INTERACT_GT_eqgt_032 CUT SVT_N
 err1 NOT INSIDE SealR_NOT_BULK
}

SVT_N_R_2 {
@ SVT_N overlap with P+AA, SVT_P, HVT_N, HVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, DG, PSUB, INST, RESNW, VARMOS, DMPNP, MARKS is not allowed, exclude OCCD region
 err1 = SVT_N AND (OR PACT SVT_P HVT_N HVT_P LVT_N LVT_P LFN_N LFN_P ULVT_N ULVT_P DG PSUB INST RESNW VARMOS DMPNP MARKS)
 err1 NOT INSIDE OCCD
}

SVT_N_R_3 {
@ (ALL_AA NOT AR) straddle on SVT_N horizontal edge is not allowed
 err1 = SVT_N_h_edges COIN EDGE ((SVT_N CUT ALL_AA_NOT_AR) INSIDE EDGE ALL_AA_NOT_AR)
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

SVT_N_R_4 {
@ Vertical edge of (SVT_N, LVT_N, ULVT_N, HVT_N, LFN_N) abut (SVT_P, LVT_P, ULVT_P, HVT_P, LFN_P) interact GT is not allowed
 chk_EDGE = ANGLE (ALL_VT_N_IMP COIN EDGE ALL_VT_P_IMP) == 90
 err1 = chk_EDGE NOT OUTSIDE EDGE GT
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

SVT_N_R_5 {
@ (SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, HVT_N, HVT_P, LFN_N, LFN_P) overlap with MARKS is not allowed
 err1 = ALL_VT_IMP AND MARKS
 err1 NOT INSIDE SealR_NOT_BULK
}

SVT_N_R_6 {
@ ((GT NOT P2) NOT INTERACT (GTMK1 OR AR) (channel length <= 0.024um)) straddle on vertical edge of SVT_N, SVT_P, LVT_N, LVT_P, HVT_N, HVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P is not allowed
 chk_GT = WITH WIDTH (GT_0 NOT INTERACT gtmk1_or_ar) <= 0.024
 err1 = SVT_N_v_edges INSIDE EDGE chk_GT
 err2 = SVT_P_v_edges INSIDE EDGE chk_GT
 err3 = LVT_N_v_edges INSIDE EDGE chk_GT
 err4 = LVT_P_v_edges INSIDE EDGE chk_GT
 err5 = HVT_N_v_edges INSIDE EDGE chk_GT
 err6 = HVT_P_v_edges INSIDE EDGE chk_GT
 err7 = LFN_N_v_edges INSIDE EDGE chk_GT
 err8 = LFN_P_v_edges INSIDE EDGE chk_GT
 err9 = ULVT_N_v_edges INSIDE EDGE chk_GT
 err0 = ULVT_P_v_edges INSIDE EDGE chk_GT

 err1 NOT INSIDE EDGE SealR_NOT_BULK
 err2 NOT INSIDE EDGE SealR_NOT_BULK
 err3 NOT INSIDE EDGE SealR_NOT_BULK
 err4 NOT INSIDE EDGE SealR_NOT_BULK
 err5 NOT INSIDE EDGE SealR_NOT_BULK
 err6 NOT INSIDE EDGE SealR_NOT_BULK
 err7 NOT INSIDE EDGE SealR_NOT_BULK
 err8 NOT INSIDE EDGE SealR_NOT_BULK
 err9 NOT INSIDE EDGE SealR_NOT_BULK
 err0 NOT INSIDE EDGE SealR_NOT_BULK
}
 
SVT_N_R_7_SVT_N {
@ (DUM_GT NOT P2) CUT SVT_N, SVT_P, HVT_N, HVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N or LFN_P is not allowed
 err1_TMP = DUM_GT_NOT_P2 CUT SVT_N
 err1 = SVT_N INSIDE EDGE err1_TMP
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
SVT_N_R_7_SVT_P {
@ (DUM_GT NOT P2) CUT SVT_N, SVT_P, HVT_N, HVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N or LFN_P is not allowed
 err1_TMP = DUM_GT_NOT_P2 CUT SVT_P
 err1 = SVT_P INSIDE EDGE err1_TMP
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
SVT_N_R_7_HVT_N {
@ (DUM_GT NOT P2) CUT SVT_N, SVT_P, HVT_N, HVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N or LFN_P is not allowed
 err1_TMP = DUM_GT_NOT_P2 CUT HVT_N
 err1 = HVT_N INSIDE EDGE err1_TMP
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
SVT_N_R_7_HVT_P {
@ (DUM_GT NOT P2) CUT SVT_N, SVT_P, HVT_N, HVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N or LFN_P is not allowed
 err1_TMP = DUM_GT_NOT_P2 CUT HVT_P
 err1 = HVT_P INSIDE EDGE err1_TMP
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
SVT_N_R_7_LVT_N {
@ (DUM_GT NOT P2) CUT SVT_N, SVT_P, HVT_N, HVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N or LFN_P is not allowed
 err1_TMP = DUM_GT_NOT_P2 CUT LVT_N
 err1 = LVT_N INSIDE EDGE err1_TMP
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
SVT_N_R_7_LVT_P {
@ (DUM_GT NOT P2) CUT SVT_N, SVT_P, HVT_N, HVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N or LFN_P is not allowed
 err1_TMP = DUM_GT_NOT_P2 CUT LVT_P
 err1 = LVT_P INSIDE EDGE err1_TMP
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
SVT_N_R_7_ULVT_N {
@ (DUM_GT NOT P2) CUT SVT_N, SVT_P, HVT_N, HVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N or LFN_P is not allowed
 err1_TMP = DUM_GT_NOT_P2 CUT ULVT_N
 err1 = ULVT_N INSIDE EDGE err1_TMP
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
SVT_N_R_7_ULVT_P {
@ (DUM_GT NOT P2) CUT SVT_N, SVT_P, HVT_N, HVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N or LFN_P is not allowed
 err1_TMP = DUM_GT_NOT_P2 CUT ULVT_P
 err1 = ULVT_P INSIDE EDGE err1_TMP
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
SVT_N_R_7_LFN_N {
@ (DUM_GT NOT P2) CUT SVT_N, SVT_P, HVT_N, HVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N or LFN_P is not allowed
 err1_TMP = DUM_GT_NOT_P2 CUT LFN_N
 err1 = LFN_N INSIDE EDGE err1_TMP
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
SVT_N_R_7_LFN_P {
@ (DUM_GT NOT P2) CUT SVT_N, SVT_P, HVT_N, HVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N or LFN_P is not allowed
 err1_TMP = DUM_GT_NOT_P2 CUT LFN_P
 err1 = LFN_P INSIDE EDGE err1_TMP
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

SVT_N_R_8 {
@ ALL_GT must be covered by (SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, HVT_N, HVT_P, LFN_N, LFN_P), except INST, DSTR, DMPNP, VARMOS, DG, RESNW, RESP1, DMCMK1, MARKS, OCCD, OCOVL, RESP3t region for 3t resistor bulk region
 except_area = OR INST DSTR DMPNP VARMOS DG_RESNW RESP1 MARKS_DMCMK1 ALL_GT_NWR OCCD OCOVL RESP3T
 err1 = (ALL_GT NOT except_area) NOT ALL_VT_IMP
 err1 NOT INSIDE SealR_NOT_BULK
}

SVT_N_R_9 {
@ ACTIVE must be covered by (SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, HVT_N, HVT_P, LFN_N, LFN_P), except INST DSTR, DMPNP, VARMOS, DG, RESNW, DMCMK1, MARKS, OCCD regions
 except_area = OR INST DSTR DMPNP VARMOS DG_RESNW MARKS_DMCMK1 (AA INTERACT AA_NWR) OCCD
 err1 = (ACT NOT except_area) NOT ALL_VT_IMP
 err1 NOT INSIDE SealR_NOT_BULK
}

SVT_N_R_10 {
@ ALL_AA CUT (SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, HVT_N, HVT_P, LFN_N, LFN_P) horizontal edge is not allowed
 err1 = OR (EXPAND EDGE (SVT_N_h_edges INSIDE EDGE ALL_AA) INSIDE BY 0.001) (EXPAND EDGE (SVT_P_h_edges INSIDE EDGE ALL_AA) INSIDE BY 0.001)
 err2 = OR (EXPAND EDGE (LVT_N_h_edges INSIDE EDGE ALL_AA) INSIDE BY 0.001) (EXPAND EDGE (LVT_P_h_edges INSIDE EDGE ALL_AA) INSIDE BY 0.001)
 err3 = OR (EXPAND EDGE (ULVT_N_h_edges INSIDE EDGE ALL_AA) INSIDE BY 0.001) (EXPAND EDGE (ULVT_P_h_edges INSIDE EDGE ALL_AA) INSIDE BY 0.001)
 err4 = OR (EXPAND EDGE (HVT_N_h_edges INSIDE EDGE ALL_AA) INSIDE BY 0.001) (EXPAND EDGE (HVT_P_h_edges INSIDE EDGE ALL_AA) INSIDE BY 0.001)
 err5 = OR (EXPAND EDGE (LFN_N_h_edges INSIDE EDGE ALL_AA) INSIDE BY 0.001) (EXPAND EDGE (LFN_P_h_edges INSIDE EDGE ALL_AA) INSIDE BY 0.001)
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
 err4 NOT INSIDE SealR_NOT_BULK
 err5 NOT INSIDE SealR_NOT_BULK
}

// =======================================================
// SVT_P: P-type Standard Vt MOS design rules
// =======================================================

GROUP GSVT_P SVT_P_?

SVT_P_W_1 {
@ SVT_P width, single-point-interaction is allowed >= 0.192um
@ DRC waive:
@ 1) SVT_P one-track width within the range of 0.09~0.106um, 0.18~0.212um when PRL = 0um
@ 2) Jog width adjacent to edge (length <= 0.048um, between two consecutive 90-270 degree corners) = 0.18um in S/D direction
@ 3) Jog width adjacent to edge (length = 0.002um, between two consecutive 90-270 degree corners) = 0.135/0.144um in S/D direction
 y1 = INT [SVT_P] < 0.192 ABUT<90 OPPOSITE EXTENDED 0.001
 y2 = INT [SVT_P] < 0.192 CORNER
 y3 = INT [SVT_P_v_edges] >= 0.09 < 0.107 PROJ == 0
 y4 = INT [SVT_P_v_edges] >= 0.18 < 0.213 PROJ == 0
 y5 = INT [SVT_P_h_edges] >= 0.09 < 0.107 PROJ == 0
 y6 = INT [SVT_P_h_edges] >= 0.18 < 0.213 PROJ == 0
 y_all = (y3 OR EDGE y4) OR EDGE (y5 OR EDGE y6)

 waive_edges = SVT_P_90_90_jog_180_135_144 COIN EDGE SVT_P_h_edges
 waive_corner = INT [SVT_P_v_edges] waive_edges < 0.001 ABUT==90 INTERSECTING ONLY
 err1 = (y1 NOT COIN EDGE y_all) NOT TOUCH EDGE waive_corner
 err2 = (y2 COIN EDGE SVT_P_concave_corner) NOT TOUCH EDGE y_all
 err1 NOT INSIDE EDGE SealR_NOT_BULK
 err2 NOT INSIDE EDGE SealR_NOT_BULK
}

SVT_P_W_2 {
@ SVT_P width in S/D direction, single-point-interaction is allowed >= 0.270um
@ DRC waive:
@ 1) SVT_P one-track width within the range of 0.09~0.106um, 0.18~0.212um when PRL = 0um
@ 2) Jog width adjacent to edge (length <= 0.048um, between two consecutive 90-270 degree corners) = 0.18/0.192/0.225/0.24um in S/D direction
@ 3) Jog width adjacent to edge (length = 0.002um, between two consecutive 90-270 degree corners) = 0.135/0.144um in S/D direction
 y1 = INT [SVT_P_v_edges] < 0.27 ABUT<90 OPPOSITE EXTENDED 0.001
 y2 = INT [SVT_P_v_edges] >= 0.09 < 0.107 PROJ == 0
 y3 = INT [SVT_P_v_edges] >= 0.18 < 0.213 PROJ == 0
 y4 = y2 OR EDGE y3

 waive_corner = INT [SVT_P_v_edges] SVT_P_90_90_jog_180_192_225_240_135_144_h_edges < 0.001 ABUT==90 INTERSECTING ONLY
 err1 = (y1 NOT COIN EDGE y4) NOT TOUCH EDGE waive_corner
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

SVT_P_W_3 {
@ SVT_P width in S/D direction, when SVT_P vertical edge CUT (GTMK1 OR AR) and ABUT HVT_P >= 0.315um
@ DRC waive: 
@ 1) Jog width adjacent to edge (length <= 0.048um, between two consecutive 90-270 degree corners) = 0.18/0.192/0.225/0.24um in S/D direction
@ 2) Jog width adjacent to edge (length = 0.002um, between two consecutive 90-270 degree corners) = 0.135/0.144um in S/D direction
 y1 = (SVT_P_v_edges INSIDE EDGE gtmk1_or_ar) COIN EDGE HVT_P
 y2 = SVT_P_v_edges TOUCH EDGE y1

 waive_corner = INT SVT_P_v_edges SVT_P_90_90_jog_180_192_225_240_135_144_h_edges <= 0.001 ABUT==90 INTERSECTING ONLY REGION
 check_corner = SVT_P_v_edges NOT TOUCH EDGE waive_corner
 err1 = INT y2 check_corner < 0.315 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

SVT_P_W_4 {
@ SVT_P width in GATE poly direction when SVT_P point touch or horizontal width in the range of 0.09~0.106um, 0.18~0.212um while PRL = 0um in GATE poly direction (except L-shape/T-shape concave corner) >= 0.238um
 err1 = INT (SVT_P_h_edges_singular_point COIN EDGE SVT_P_concave_corner) SVT_P_h_edges < 0.238 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK

 y1 = SVT_P_convex_eqlt_1_edges COIN EDGE SVT_P_h_edges
 y2 = SVT_P COIN EDGE (EXPAND EDGE (y1 COIN EDGE SVT_P_concave_corner) INSIDE BY 0.001 OUTSIDE BY 0.001)
 y3 = INT [y2] >= 0.09 <= 0.106+0.0005 ABUT<90 PROJ == 0
 y4 = INT [y2] >= 0.18 <= 0.212+0.0005 ABUT<90 PROJ == 0
 y5 = SVT_P_concave_corner WITH EDGE (SVT_P_concave_corner COIN EDGE (y3 OR EDGE y4))
 y6 = SVT_P_h_edges COIN EDGE y5
 err2 = INT SVT_P_h_edges y6 < 0.238 ABUT<90 OPPOSITE REGION
 err3 = (LENGTH ((SVT_P_v_edges TOUCH EDGE y5) TOUCH EDGE SVT_P_convex_eq_1_edges) < 0.238) EXPAND EDGE INSIDE BY 0.001
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
}

SVT_P_S_1 {
@ Space between SVT_P, single-point-interaction is allowed >= 0.192um
@ DRC waive:
@ 1) SVT_P one-track space within the range of 0.09~0.106um, 0.18~0.212um when PRL = 0um
@ 2) Jog space adjacent to edge (length <= 0.048um, between two consecutive 90-270 degree corners) = 0.18um in S/D direction
@ 3) Jog space adjacent to edge (length = 0.002um, between two consecutive 90-270 degree corners) = 0.135/0.144um in S/D direction
 y1 = EXT [SVT_P] < 0.192 ABUT<90 OPPOSITE EXTENDED 0.001
 y2 = EXT [SVT_P] < 0.192 CORNER
 y3 = EXT [SVT_P_v_edges] >= 0.09 < 0.107 PROJ == 0
 y4 = EXT [SVT_P_v_edges] >= 0.18 < 0.213 PROJ == 0
 y5 = EXT [SVT_P_h_edges] >= 0.09 < 0.107 PROJ == 0
 y6 = EXT [SVT_P_h_edges] >= 0.18 < 0.213 PROJ == 0
 y_all = (y3 OR EDGE y4) OR EDGE (y5 OR EDGE y6)
 w_all = SVT_P_rvs_90_90_jog_180_135_144 OR EDGE SVT_P_90_90_jog_180_135_144

 z1 = w_all COIN EDGE SVT_P_h_edges
 z2 = SVT_P_rvs COIN EDGE SVT_P_v_edges
 z3 = INT [z2] z1 < 0.005 ABUT==90 INTERSECTING ONLY
 err1 = (y1 NOT COIN EDGE y_all) NOT TOUCH EDGE z3
 err2 = (y2 COIN EDGE SVT_P_convex_corner) NOT COIN EDGE y_all
 err1 NOT INSIDE EDGE SealR_NOT_BULK
 err2 NOT INSIDE EDGE SealR_NOT_BULK
}

SVT_P_S_2 {
@ Space between SVT_P in S/D direction, single-point-interaction is allowed >= 0.27um
@ DRC waive:
@ 1) SVT_P one-track space within the range of 0.09~0.106um, 0.18~0.212um when PRL = 0um
@ 2) Jog space adjacent to edge (length <= 0.048um, between two consecutive 90-270 degree corners) = 0.180/0.192/0.225/0.24um in S/D direction
@ 3) Jog space adjacent to edge (length = 0.002um, between two consecutive 90-270 degree corners) = 0.135/0.144um in S/D direction
 w_all = SVT_P_90_90_jog_180_192_225_240_135_144 OR EDGE SVT_P_rvs_90_90_jog_180_192_225_240_135_144
 y1 = ANGLE (EXT [SVT_P] < 0.27 ABUT<90 OPPOSITE EXTENDED 0.001) == 90
 y2 = EXT [SVT_P_v_edges] >= 0.09 < 0.107 PROJ == 0
 y3 = EXT [SVT_P_v_edges] >= 0.18 < 0.213 PROJ == 0
 y4 = y2 OR EDGE y3

 z1 = ANGLE SVT_P_rvs == 0
 z2 = w_all COIN EDGE z1
 z3 = ANGLE SVT_P_rvs == 90
 z4 = INT [z3] z2 < 0.001 ABUT==90 INTERSECTING ONLY
 err1 = (y1 NOT COIN EDGE y4) NOT TOUCH EDGE z4
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

SVT_P_S_3a {
@ Space between SVT_P in S/D direction, when just one SVT_P vertical edge CUT (GTMK1 OR AR) and abut LVT_P or ULVT_P >= 0.315um
@ DRC waive:
@ 1) Jog space adjacent to edge (length <= 0.048um, between two consecutive 90-270 degree corners) = 0.180/0.192/0.225/0.24um in S/D direction
@ 2) Jog space adjacent to edge (length = 0.002um, between two consecutive 90-270 degree corners) = 0.135/0.144um in S/D direction
 check_edges = (SVT_P_inside_AA_side_mark_v_edges TOUCH EDGE LVT_P) OR EDGE (SVT_P_inside_AA_side_mark_v_edges TOUCH EDGE ULVT_P)
 waive_corner = EXT SVT_P_270_270_jog_180_192_225_240_135_144_h_edges check_edges <= 0.001 ABUT==90 INTERSECTING ONLY REGION
 check_corner = check_edges NOT TOUCH EDGE waive_corner
 err1 = EXT check_corner SVT_P_v_edges < 0.315 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

SVT_P_S_3b {
@ Space between SVT_P in S/D direction, when both SVT_P’s vertical edges CUT (GTMK1 OR AR) and abut LVT_P or ULVT_P >= 0.36um
@ DRC waive:
@ 1) Jog space adjacent to edge (length <= 0.048um, between two consecutive 90-270 degree corners) = 0.180/0.192/0.225/0.24um in S/D direction
@ 2) Jog space adjacent to edge (length = 0.002um, between two consecutive 90-270 degree corners) = 0.135/0.144um in S/D direction
 check_edges = (SVT_P_inside_AA_side_mark_v_edges TOUCH EDGE LVT_P) OR EDGE (SVT_P_inside_AA_side_mark_v_edges TOUCH EDGE ULVT_P)
 waive_corner = EXT SVT_P_270_270_jog_180_192_225_240_135_144_h_edges check_edges <= 0.001 ABUT==90 INTERSECTING ONLY REGION
 check_corner = check_edges NOT TOUCH EDGE waive_corner
 err1 = EXT check_corner < 0.36 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

SVT_P_S_4 {
@ Space between SVT_P when PRL >= 0.29um. >= 0.248um
 Layer_area = EXT SVT_P < 0.248 OPPOSITE REGION
 err1 = Layer_area ENCLOSE RECTANGLE 0.001 0.29 ORTHOGONAL ONLY
 err1 NOT INSIDE SealR_NOT_BULK
}

SVT_P_S_5 {
@ SVT_P space in GATE poly direction when SVT_P point touch or horizontal width in the range of 0.09~0.106um, 0.18~0.212um while PRL = 0um in GATE poly direction >= 0.238um
 err1 = EXT SVT_P_h_edges_singular_point SVT_P_h_edges < 0.238 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK

 y1 = SVT_P_convex_eqlt_1_edges COIN EDGE SVT_P_h_edges
 y2 = SVT_P COIN EDGE (EXPAND EDGE (y1 COIN EDGE SVT_P_concave_corner) INSIDE BY 0.001 OUTSIDE BY 0.001)
 y3 = INT [y2] >= 0.09 <= 0.106+0.0005 ABUT<90 PROJ == 0
 y4 = INT [y2] >= 0.18 <= 0.212+0.0005 ABUT<90 PROJ == 0
 y5 = SVT_P_concave_corner WITH EDGE (SVT_P_concave_corner COIN EDGE (y3 OR EDGE y4))
 y6 = SVT_P_h_edges TOUCH EDGE y5
 err2 = EXT SVT_P_h_edges y6 < 0.238 ABUT<90 OPPOSITE REGION
 err3 = (LENGTH ((SVT_P_v_edges TOUCH EDGE y5) TOUCH EDGE SVT_P_convex_eq_0_edges) < 0.238) EXPAND EDGE INSIDE BY 0.002
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
}

SVT_P_S_6 {
@ Space between SVT_P and ALL_AA (vertical edge abut AA edge is allowed) >= 0.045um
 CHECK_RAW = EXT SVT_P ALL_AA < 0.045 ABUT<90 SINGULAR
 WAIVE_CRN = SVT_P COIN OUTSIDE EDGE ALL_AA_v_edges
 err1 = DFM COPY (DFM PROPERTY CHECK_RAW WAIVE_CRN ABUT ALSO OVERLAP MULTI SPLIT [-= count(WAIVE_CRN)] == 0) REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

SVT_P_S_6a {
@ Space between SVT_P and ALL_AA in GATE poly direction >= 0.048um
 err1 = EXT SVT_P ALL_AA_h_edges < 0.048 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

SVT_P_S_7 {
@ Space between SVT_P and (ALL_GT NOT P2) (ALL_GT width < 0.07um), except small ALL_GT jog <= 0.004um. >= 0.024um
 err1 = EXT SVT_P ALL_GT_NOT_P2_not_jog_lteq_004 < 0.024 ABUT<90 REGION MEASURE ALL  //;minimum
 err1 NOT INSIDE SealR_NOT_BULK
}

SVT_P_S_7a {
@ Space between SVT_P and (ALL_GT NOT P2) (ALL_GT width >= 0.07um) >= 0.034um
 err1 = EXT SVT_P (ALL_GT_eqgt_070 NOT P2) < 0.034 ABUT<90 SINGULAR REGION MEASURE ALL
 err1 NOT INSIDE SealR_NOT_BULK
}

SVT_P_S_7b {
@ Space between SVT_P and (ALL_GT NOT P2) (ALL_GT width > 0.09um) >= 0.058um
 err1 = EXT SVT_P ALL_GT_NOT_P2_gt_090 < 0.058 ABUT<90 SINGULAR REGION MEASURE ALL
 err1 NOT INSIDE SealR_NOT_BULK
}

SVT_P_S_8 {
@ Space between SVT_P and (ALL_GT NOT P2) (ALL_GT width < 0.07um) in S/D direction >= 0.035um
 err1 = EXT ALL_GT_NOT_P2 SVT_P_v_edges < 0.035 ABUT<90 OPPOSITE REGION  //;minimum
 err1 NOT INSIDE SealR_NOT_BULK
}

SVT_P_S_8a {
@ Space between SVT_P and (ALL_GT NOT P2) (ALL_GT width >= 0.07um) in S/D direction >= 0.058um
 err1 = EXT SVT_P_v_edges ALL_GT_NOT_P2_eqgt_070 < 0.058 ABUT<90 OPPOSITE REGION MEASURE ALL
 err1 NOT INSIDE SealR_NOT_BULK
}

SVT_P_S_9a {
@ Space between SVT_P and GATE (when channel length = 0.016/0.018/0.02um) respectively in S/D direction, (GATE CUT SVT_P is not allowed), except GT_P96 region >= 0.082/0.081/0.08um
 err1 = DFM COPY (DFM SPACE GATE_LE_16 SVT_P < 0.082 BY EXT HORIZONTAL MEASURE ALL) REGION
 err2 = DFM COPY (DFM SPACE GATE_LE_18 SVT_P < 0.081 BY EXT HORIZONTAL MEASURE ALL) REGION
 err3 = DFM COPY (DFM SPACE GATE_LE_20 SVT_P < 0.080 BY EXT HORIZONTAL MEASURE ALL) REGION
 err4 = GATE CUT SVT_P

 err1 NOT INSIDE GT_P96
 err2 NOT INSIDE GT_P96
 err3 NOT INSIDE GT_P96
 err4 NOT INSIDE GT_P96
}

SVT_P_S_9b {
@ Space between SVT_P and GATE (when channel length = 0.016/0.018/0.02/0.022/0.024um, INSIDE GT_P96) in S/D direction (GATE CUT SVT_P is not allowed) >= 0.088/0.087/0.086/0.085/0.084um
 err1 = DFM COPY (DFM SPACE GATE_LE_16_in_GT_P96 SVT_P < 0.088 BY EXT HORIZONTAL MEASURE ALL) REGION
 err2 = DFM COPY (DFM SPACE GATE_LE_18_in_GT_P96 SVT_P < 0.087 BY EXT HORIZONTAL MEASURE ALL) REGION
 err3 = DFM COPY (DFM SPACE GATE_LE_20_in_GT_P96 SVT_P < 0.086 BY EXT HORIZONTAL MEASURE ALL) REGION
 err4 = DFM COPY (DFM SPACE GATE_LE_22_in_GT_P96 SVT_P < 0.085 BY EXT HORIZONTAL MEASURE ALL) REGION
 err5 = DFM COPY (DFM SPACE GATE_LE_24_in_GT_P96 SVT_P < 0.084 BY EXT HORIZONTAL MEASURE ALL) REGION
 err6 = GATE CUT SVT_P

 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
 err4 NOT INSIDE SealR_NOT_BULK
 err5 NOT INSIDE SealR_NOT_BULK
 err6 NOT INSIDE SealR_NOT_BULK
}

SVT_P_S_10 {
@ Space between SVT_P vertical edge (edge length <= 0.238um between two concave corners with both sides length >= 0.09um) and ((GT AND GTMK1) OR GATE) in S/D direction >= 0.079um
 check_RAW = CONVEX EDGE SVT_P ANGLE1 == 270 LENGTH1 >= 0.09 ANGLE2 == 270 LENGTH2 >= 0.09 WITH LENGTH <= 0.238
 check_TMP = ANGLE check_RAW == 90
 err1 = EXT (OR GATE_raw GT_and_GTMK1) check_TMP < 0.079 ABUT<90 OPPOSITE REGION  //;including edge GATE
 err1 NOT INSIDE SealR_NOT_BULK
}

SVT_P_S_11 {
@ Space between SVT_P and (ALL_GT NOT P2) in GATE poly direction with adjacent horizontal space <= 0.04um (SVT_P vertical edge length = 0.073~0.15um, between two consecutive 90-270 degree coners) >= 0.054um
 y1 = EXT [ALL_GT_NOT_P2] SVT_P_convex_90_270_eqgt_073_lteq_150_v_edges <= 0.040 ABUT<90 OPPOSITE
 y2 = EXT [SVT_P_h_edges] SVT_P_convex_90_270_eqgt_073_lteq_150_v_edges < 0.005 ABUT==90 INTERSECTING ONLY

 z1 = SVT_P_h_edges TOUCH EDGE y2
 z2 = EXT ALL_GT_NOT_P2 z1 < 0.054 ABUT<90 OPPOSITE REGION
 z3 = EXPAND EDGE y1 INSIDE BY 0.005 EXTEND BY 0.005
 err1 = z2 INTERACT z3
 err1 NOT INSIDE SealR_NOT_BULK
}

SVT_P_EX_1 {
@ SVT_P extension outside of ALL_AA (vertical edge abut AA edge is allowed) >= 0.045um
 CHECK_RAW = ENC ALL_AA SVT_P < 0.045 ABUT<90 SINGULAR
 WAIVE_CRN = SVT_P COIN INSIDE EDGE ALL_AA_v_edges
 err1 = DFM COPY (DFM PROPERTY CHECK_RAW WAIVE_CRN ABUT ALSO OVERLAP MULTI SPLIT [-= count(WAIVE_CRN)] == 0) REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

SVT_P_EX_2 {
@ SVT_P extension outside of ALL_AA in GATE poly direction >= 0.048um
 err1 = ENC ALL_AA_h_edges SVT_P < 0.048 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

SVT_P_EX_3 {
@ SVT_P extension outside of (ALL_GT NOT P2) (ALL_GT width < 0.07um), except small ALL_GT jog <= 0.004um. >= 0.024um
 err1 = ENC ALL_GT_NOT_P2_not_jog_lteq_004 SVT_P < 0.024 ABUT<90 OPPOSITE REGION  //;minimum
 err1 NOT INSIDE SealR_NOT_BULK
}

SVT_P_EX_4 {
@ SVT_P extension outside of (ALL_GT NOT P2) (ALL_GT width >= 0.07um) >= 0.034um
 err1 = ENC ALL_GT_NOT_P2_eqgt_070 SVT_P < 0.034 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

SVT_P_EX_5 {
@ SVT_P extension outside of (ALL_GT NOT P2) (ALL_GT width > 0.09um) >= 0.058um
 err1 = ENC ALL_GT_NOT_P2_gt_090 SVT_P < 0.058 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

SVT_P_EX_6 {
@ SVT_P extension outside of (ALL_GT NOT P2) (ALL_GT width < 0.07um) in S/D direction >= 0.035um
 err1 = ENC ALL_GT_NOT_P2 SVT_P_v_edges < 0.035 ABUT<90 OPPOSITE REGION //;minimum
 err1 NOT INSIDE SealR_NOT_BULK
}

SVT_P_EX_7 {
@ SVT_P extension outside of (ALL_GT NOT P2) (ALL_GT width >= 0.07um) in S/D direction >= 0.058um
 err1 = ENC ALL_GT_NOT_P2_eqgt_070 SVT_P_v_edges < 0.058 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

SVT_P_EX_8 {
@ SVT_P extension outside of GATE (when channel length = 0.016/0.018/0.02um) respectively in S/D direction, except GT_P96 region >= 0.082/0.081/0.080um
 err1 = DFM COPY (DFM SPACE GATE_LE_16 SVT_P < 0.082 BY ENC HORIZONTAL) REGION
 err2 = DFM COPY (DFM SPACE GATE_LE_18 SVT_P < 0.081 BY ENC HORIZONTAL) REGION
 err3 = DFM COPY (DFM SPACE GATE_LE_20 SVT_P < 0.080 BY ENC HORIZONTAL) REGION

 err1 NOT INSIDE GT_P96
 err2 NOT INSIDE GT_P96
 err3 NOT INSIDE GT_P96
}

SVT_P_EX_9 {
@ SVT_P extension outside of GATE (when channel length = 0.016/0.018/0.02/0.022/0.024um, INSIDE GT_P96) in S/D direction >= 0.088/0.087/0.086/0.085/0.084um
 err1 = (DFM COPY (DFM SPACE GATE_LE_16 SVT_P < 0.088 BY ENC HORIZONTAL) REGION) NOT OUTSIDE GT_P96
 err2 = (DFM COPY (DFM SPACE GATE_LE_18 SVT_P < 0.087 BY ENC HORIZONTAL) REGION) NOT OUTSIDE GT_P96
 err3 = (DFM COPY (DFM SPACE GATE_LE_20 SVT_P < 0.086 BY ENC HORIZONTAL) REGION) NOT OUTSIDE GT_P96
 err4 = (DFM COPY (DFM SPACE GATE_LE_22 SVT_P < 0.085 BY ENC HORIZONTAL) REGION) NOT OUTSIDE GT_P96
 err5 = (DFM COPY (DFM SPACE GATE_LE_24 SVT_P < 0.084 BY ENC HORIZONTAL) REGION) NOT OUTSIDE GT_P96

 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
 err4 NOT INSIDE SealR_NOT_BULK
 err5 NOT INSIDE SealR_NOT_BULK
}

SVT_P_EX_10 {
@ SVT_P (line-end vertical width <= 0.238um between two consecutive 90-90 degree corners with both sides length >= 0.09um) enclosure of ((GT AND GTMK1) OR GATE) in S/D direction >= 0.079um
 check_RAW = CONVEX EDGE SVT_P ANGLE1 == 90 LENGTH1 >= 0.09 ANGLE2 == 90 LENGTH2 >= 0.09 WITH LENGTH <= 0.238
 check_TMP = ANGLE check_RAW == 90
 err1 = ENC (OR GATE_raw GT_and_GTMK1) check_TMP < 0.079 ABUT<90 OPPOSITE REGION  //;including edge GATE
 err1 NOT INSIDE SealR_NOT_BULK
}

SVT_P_EX_11 {
@ SVT_P extension outside of (ALL_GT NOT P2) in GATE poly direction with adjacent horizontal enclosure <= 0.04um by SVT_P vertical edge (edge length = 0.073~0.15um, between two consecutive 90-270 degree corners) >= 0.054um
 y1 = ENC [ALL_GT_NOT_P2] SVT_P_convex_90_270_eqgt_073_lteq_150_v_edges <= 0.040 ABUT<90 OPPOSITE
 y2 = INT [SVT_P_h_edges] SVT_P_convex_90_270_eqgt_073_lteq_150_v_edges < 0.005 ABUT==90 INTERSECTING ONLY
 y3 = SVT_P_h_edges TOUCH EDGE y2
 y4 = ENC ALL_GT_NOT_P2 y3 < 0.054 ABUT<90 OPPOSITE REGION
 y5 = EXPAND EDGE y1 INSIDE BY 0.005 EXTEND BY 0.005
 err1 = y4 INTERACT y5
 err1 NOT INSIDE SealR_NOT_BULK
}

SVT_P_in_ALL_GT_h_edges = ANGLE (SVT_P NOT OUTSIDE EDGE ALL_GT) == 0
SVT_P_in_all_GT_in_ar_gtmk1_edges = SVT_P NOT OUTSIDE EDGE all_GT_in_ar_gtmk1
SVT_P_in_all_GT_in_ar_gtmk1_area = INT SVT_P_in_all_GT_in_ar_gtmk1_edges < 0.005 ABUT INTERSECTING ONLY REGION

SVT_P_EX_12 {
@ (ALL_GT NOT P2) extension outside of SVT_P, except small ALL_GT jogs <= 0.004um, Dummy_Cell_WO_IMP, and SVT_P vertical edge CUT (GTMK1 OR AR) (channel length <= 0.024um, centerline abut SVT_P vertical edge) >= 0.083um
//;Only need to check the vertical extension
 y1 = SVT_P_in_all_GT_in_ar_gtmk1_edges COIN EDGE all_GT_center_even
 y2 = ANGLE (SVT_P_in_all_GT_in_ar_gtmk1_edges TOUCH EDGE (SVT_P_in_all_GT_in_ar_gtmk1_area WITH EDGE (SVT_P_in_all_GT_in_ar_gtmk1_area COIN EDGE y1))) == 0
 y3 = SVT_P_in_ALL_GT_h_edges NOT COIN EDGE y2
 err1 = ENC y3 ALL_GT_NOT_P2_not_jog_lteq_004 < 0.083 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE Dummy_Cell_WO_IMP
}

SVT_P_O_1 {
@ Overlap of (ALL_GT NOT P2) and SVT_P, except small ALL_GT jogs <= 0.004um, Dummy_Cell_WO_IMP, and SVT_P vertical edge CUT (GTMK1 OR AR) (channel length <= 0.024um, centerline abut SVT_P vertical edge) >= 0.083um
//;Only need to check the vertical overlap
 y1 = SVT_P_in_all_GT_in_ar_gtmk1_edges COIN EDGE all_GT_center_even
 y2 = ANGLE (SVT_P_in_all_GT_in_ar_gtmk1_edges TOUCH EDGE (SVT_P_in_all_GT_in_ar_gtmk1_area WITH EDGE (SVT_P_in_all_GT_in_ar_gtmk1_area COIN EDGE y1))) == 0
 y3 = SVT_P_in_ALL_GT_h_edges NOT COIN EDGE y2
 err1 = INT y3 ALL_GT_NOT_P2_not_jog_lteq_004 < 0.083 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE Dummy_Cell_WO_IMP
}

SVT_P_A_1 {
@ SVT_P area >= 0.085um2
 err1 = AREA SVT_P < VT_MiniArea
 err1 NOT INSIDE SealR_NOT_BULK
}

SVT_P_A_2 {
@ SVT_P enclosed area >= 0.085um2
 err1 = AREA ((HOLES SVT_P INNER SINGULAR ALSO) NOT SVT_P) < VT_MiniArea
 err1 NOT INSIDE SealR_NOT_BULK
}

SVT_P_A_3 {
@ Area of ((ALL_GT NOT P2) AND SVT_P) >= 0.00158um2
 err1 = AREA (ALL_GT_NOT_P2 AND SVT_P) < 0.00158
 err1 NOT INSIDE SealR_NOT_BULK
}

SVT_P_R_1 {
@ (ALL_AA interact GT (width >= 0.032um)) CUT SVT_P is not allowed
 err1 = ALL_AA_INTERACT_GT_eqgt_032 CUT SVT_P
 err1 NOT INSIDE SealR_NOT_BULK
}

SVT_P_R_2 {
@ SVT_P overlap with N+AA, SVT_N, HVT_N, HVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, DG, PSUB, INST, RESNW, VARMOS, DMPNP, MARKS is not allowed, exclude OCCD region
 err1 = SVT_P AND (OR NACT SVT_N HVT_N HVT_P LVT_N LVT_P ULVT_N ULVT_P LFN_N LFN_P DG PSUB INST RESNW VARMOS DMPNP MARKS)
 err1 NOT INSIDE OCCD
}

SVT_P_R_3 {
@ (ALL_AA NOT AR) straddle on SVT_P horizontal edge is not allowed
 err1 = SVT_P_h_edges COIN EDGE ((SVT_P CUT ALL_AA_NOT_AR) INSIDE EDGE ALL_AA_NOT_AR)
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

// =======================================================
// HVT_N: N-type High Vt MOS design rules
// =======================================================

GROUP GHVT_N HVT_N_?

HVT_N_W_1 {
@ HVT_N width, single-point-interaction is allowed >= 0.192um
@ DRC waive:
@ 1) HVT_N one-track width within the range of 0.09~0.106um, 0.18~0.212um when PRL = 0um
@ 2) Jog width adjacent to edge (length <= 0.048um, between two consecutive 90-270 degree corners) = 0.18um in S/D direction
@ 3) Jog width adjacent to edge (length = 0.002um, between two consecutive 90-270 degree corners) = 0.135/0.144um in S/D direction
 y1 = INT [HVT_N] < 0.192 ABUT<90 OPPOSITE EXTENDED 0.001
 y2 = INT [HVT_N] < 0.192 CORNER
 y3 = INT [HVT_N_v_edges] >= 0.09 < 0.107 PROJ == 0
 y4 = INT [HVT_N_v_edges] >= 0.18 < 0.213 PROJ == 0
 y5 = INT [HVT_N_h_edges] >= 0.09 < 0.107 PROJ == 0
 y6 = INT [HVT_N_h_edges] >= 0.18 < 0.213 PROJ == 0
 y_all = (y3 OR EDGE y4) OR EDGE (y5 OR EDGE y6)

 waive_edges = HVT_N_90_90_jog_180_135_144 COIN EDGE HVT_N_h_edges
 waive_corner = INT [HVT_N_v_edges] waive_edges < 0.001 ABUT==90 INTERSECTING ONLY
 err1 = (y1 NOT COIN EDGE y_all) NOT TOUCH EDGE waive_corner
 err2 = (y2 COIN EDGE HVT_N_concave_corner) NOT TOUCH EDGE y_all
 err1 NOT INSIDE EDGE SealR_NOT_BULK
 err2 NOT INSIDE EDGE SealR_NOT_BULK
}

HVT_N_W_2 {
@ HVT_N width in S/D direction, single-point-interaction is allowed >= 0.27um
@ DRC waive:
@ 1) HVT_N one-track width within the range of 0.09~0.106um, 0.18~0.212um when PRL = 0um
@ 2) Jog width adjacent to edge (length <= 0.048um, between two consecutive 90-270 degree corners) = 0.18/0.192/0.225/0.24um in S/D direction
@ 3) Jog width adjacent to edge (length = 0.002um, between two consecutive 90-270 degree corners) = 0.135/0.144um in S/D direction
 y1 = INT [HVT_N_v_edges] < 0.27 ABUT<90 OPPOSITE EXTENDED 0.001
 y2 = INT [HVT_N_v_edges] >= 0.09 < 0.107 PROJ == 0
 y3 = INT [HVT_N_v_edges] >= 0.18 < 0.213 PROJ == 0
 y_all = y2 OR EDGE y3

 waive_edges = HVT_N_90_90_jog_180_192_225_240_135_144 COIN EDGE HVT_N_h_edges
 waive_corner = INT [HVT_N_v_edges] waive_edges < 0.001 ABUT==90 INTERSECTING ONLY
 err1 = (y1 NOT COIN EDGE y_all) NOT TOUCH EDGE waive_corner
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

HVT_N_W_3 {
@ HVT_N width in GATE poly direction when HVT_N point touch or horizontal width in the range of 0.09~0.106um, 0.18~0.212um while PRL = 0um in GATE poly direction (except L-shape/T-shape concave corner) >= 0.238um
 err1 = INT (HVT_N_h_edges_singular_point COIN EDGE HVT_N_concave_corner) HVT_N_h_edges < 0.238 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK

 y1 = HVT_N_convex_eqlt_1_edges COIN EDGE HVT_N_h_edges
 y2 = HVT_N COIN EDGE (EXPAND EDGE (y1 COIN EDGE HVT_N_concave_corner) INSIDE BY 0.001 OUTSIDE BY 0.001)
 y3 = INT [y2] >= 0.09 <= 0.106+0.0005 ABUT<90 PROJ == 0
 y4 = INT [y2] >= 0.18 <= 0.212+0.0005 ABUT<90 PROJ == 0
 y5 = HVT_N_concave_corner WITH EDGE (HVT_N_concave_corner COIN EDGE (y3 OR EDGE y4))
 y6 = HVT_N_h_edges COIN EDGE y5
 err2 = INT HVT_N_h_edges y6 < 0.238 ABUT<90 OPPOSITE REGION
 err3 = (LENGTH ((HVT_N_v_edges TOUCH EDGE y5) TOUCH EDGE HVT_N_convex_eq_1_edges) < 0.238) EXPAND EDGE INSIDE BY 0.001
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
}

HVT_N_S_1 {
@ Space between HVT_N, single-point-interaction is allowed >= 0.192um
@ DRC waive:
@ 1) HVT_N one-track space within the range of 0.09~0.106um, 0.18~0.212um when PRL = 0um
@ 2) Jog space adjacent to edge (length <= 0.048um, between two consecutive 90-270 degree corners) = 0.18um in S/D direction
@ 3) Jog space adjacent to edge (length = 0.002um, between two consecutive 90-270 degree corners) = 0.135/0.144um in S/D direction
 y1 = EXT [HVT_N] < 0.192 ABUT<90 OPPOSITE EXTENDED 0.001
 y2 = EXT [HVT_N] < 0.192 CORNER
 y3 = EXT [HVT_N_v_edges] >= 0.09 < 0.107 PROJ == 0
 y4 = EXT [HVT_N_v_edges] >= 0.18 < 0.213 PROJ == 0
 y5 = EXT [HVT_N_h_edges] >= 0.09 < 0.107 PROJ == 0
 y6 = EXT [HVT_N_h_edges] >= 0.18 < 0.213 PROJ == 0
 y_all = (y3 OR EDGE y4) OR EDGE (y5 OR EDGE y6)
 w_all = HVT_N_rvs_90_90_jog_180_135_144 OR EDGE HVT_N_90_90_jog_180_135_144

 z1 = w_all COIN EDGE HVT_N_h_edges
 z2 = HVT_N_rvs COIN EDGE HVT_N_v_edges
 z3 = INT [z2] z1 < 0.005 ABUT==90 INTERSECTING ONLY
 err1 = (y1 NOT COIN EDGE y_all) NOT TOUCH EDGE z3
 err2 = (y2 COIN EDGE HVT_N_convex_corner) NOT COIN EDGE y_all
 err1 NOT INSIDE EDGE SealR_NOT_BULK
 err2 NOT INSIDE EDGE SealR_NOT_BULK
}

HVT_N_S_2 {
@ Space between HVT_N in S/D direction, single-point-interaction is allowed >= 0.27um
@ DRC waive:
@ 1) HVT_N one-track space within the range of 0.09~0.106um, 0.18~0.212um when PRL = 0um
@ 2) Jog space adjacent to edge (length <= 0.048um, between two consecutive 90-270 degree corners) = 0.180/0.192/0.225/0.24um in S/D direction
@ 3) Jog space adjacent to edge (length = 0.002um, between two consecutive 90-270 degree corners) = 0.135/0.144um in S/D direction
 w_all = HVT_N_90_90_jog_180_192_225_240_135_144 OR EDGE HVT_N_rvs_90_90_jog_180_192_225_240_135_144
 y1 = ANGLE (EXT [HVT_N] < 0.27 ABUT<90 OPPOSITE EXTENDED 0.001) == 90
 y2 = EXT [HVT_N_v_edges] >= 0.09 < 0.107 PROJ == 0
 y3 = EXT [HVT_N_v_edges] >= 0.18 < 0.213 PROJ == 0
 y4 = y2 OR EDGE y3

 z1 = ANGLE HVT_N_rvs == 0
 z2 = w_all COIN EDGE z1
 z3 = ANGLE HVT_N_rvs == 90
 z4 = INT [z3] z2 < 0.001 ABUT==90 INTERSECTING ONLY
 err1 = (y1 NOT COIN EDGE y4) NOT TOUCH EDGE z4
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

HVT_N_S_3a {
@ Space between HVT_N in S/D direction, when just one HVT_N’s vertical edge CUT (GTMK1 OR AR) >= 0.315um
@ DRC waive:
@ 1) Jog space adjacent to edge (length <= 0.048um, between two consecutive 90-270 degree corners) = 0.180/0.192/0.225/0.24um in S/D direction
@ 2) Jog space adjacent to edge (length = 0.002um, between two consecutive 90-270 degree corners) = 0.135/0.144um in S/D direction
 waive_corner = EXT HVT_N_270_270_jog_180_192_225_240_135_144_h_edges HVT_N_v_edges <= 0.001 ABUT==90 INTERSECTING ONLY REGION
 check_corner = HVT_N_inside_AA_side_mark_v_edges NOT TOUCH EDGE waive_corner
 err1 = EXT check_corner HVT_N_v_edges < 0.315 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

HVT_N_S_3b {
@ Space between HVT_N in S/D direction, when both HVT_N’s vertical edge CUT (GTMK1 OR AR) >= 0.36um
@ DRC waive:
@ 1) Jog space adjacent to edge (length <= 0.048um, between two consecutive 90-270 degree corners) = 0.180/0.192/0.225/0.24um in S/D direction
@ 2) Jog space adjacent to edge (length = 0.002um, between two consecutive 90-270 degree corners) = 0.135/0.144um in S/D direction
 waive_corner = EXT HVT_N_270_270_jog_180_192_225_240_135_144_h_edges HVT_N_v_edges <= 0.001 ABUT==90 INTERSECTING ONLY REGION
 check_corner = HVT_N_inside_AA_side_mark_v_edges NOT TOUCH EDGE waive_corner
 err1 = EXT check_corner < 0.36 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

HVT_N_S_4 {
@ Space between HVT_N when PRL >= 0.29um. >= 0.248um
 Layer_area = EXT HVT_N < 0.248 OPPOSITE REGION
 err1 = Layer_area ENCLOSE RECTANGLE 0.001 0.29 ORTHOGONAL ONLY
 err1 NOT INSIDE SealR_NOT_BULK
}

HVT_N_S_5 {
@ HVT_N space in GATE poly direction when HVT_N point touch or horizontal width in the range of 0.09~0.106um, 0.18~0.212um while PRL = 0um in GATE poly direction >= 0.238um
 err1 = EXT HVT_N_h_edges_singular_point HVT_N_h_edges < 0.238 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK

 y1 = HVT_N_convex_eqlt_1_edges COIN EDGE HVT_N_h_edges
 y2 = HVT_N COIN EDGE (EXPAND EDGE (y1 COIN EDGE HVT_N_concave_corner) INSIDE BY 0.001 OUTSIDE BY 0.001)
 y3 = INT [y2] >= 0.09 <= 0.106+0.0005 ABUT<90 PROJ == 0
 y4 = INT [y2] >= 0.18 <= 0.212+0.0005 ABUT<90 PROJ == 0
 y5 = HVT_N_concave_corner WITH EDGE (HVT_N_concave_corner COIN EDGE (y3 OR EDGE y4))
 y6 = HVT_N_h_edges TOUCH EDGE y5
 err2 = EXT HVT_N_h_edges y6 < 0.238 ABUT<90 OPPOSITE REGION
 err3 = (LENGTH ((HVT_N_v_edges TOUCH EDGE y5) TOUCH EDGE HVT_N_convex_eq_0_edges) < 0.238) EXPAND EDGE INSIDE BY 0.002
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
}

HVT_N_S_6 {
@ Space between HVT_N and ALL_AA (vertical edge abut AA edge is allowed) >= 0.045um
 CHECK_RAW = EXT HVT_N ALL_AA < 0.045 ABUT<90 SINGULAR
 WAIVE_CRN = HVT_N COIN OUTSIDE EDGE ALL_AA_v_edges
 err1 = DFM COPY (DFM PROPERTY CHECK_RAW WAIVE_CRN ABUT ALSO OVERLAP MULTI SPLIT [-= count(WAIVE_CRN)] == 0) REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

HVT_N_S_6a {
@ Space between HVT_N and ALL_AA in GATE poly direction >= 0.048um
 err1 = EXT HVT_N ALL_AA_h_edges < 0.048 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

HVT_N_S_7 {
@ Space between HVT_N and (ALL_GT NOT P2) (ALL_GT width < 0.07um), except small ALL_GT jogs <= 0.004um. >= 0.024um
 err1 = EXT HVT_N ALL_GT_NOT_P2_not_jog_lteq_004 < 0.024 ABUT<90 REGION MEASURE ALL  //;minimum
 err1 NOT INSIDE SealR_NOT_BULK
}

HVT_N_S_7a {
@ Space between HVT_N and (ALL_GT NOT P2) (ALL_GT width >= 0.07um) >= 0.034um
 err1 = EXT HVT_N (ALL_GT_eqgt_070 NOT P2) < 0.034 ABUT<90 SINGULAR REGION MEASURE ALL
 err1 NOT INSIDE SealR_NOT_BULK
}

HVT_N_S_7b {
@ Space between HVT_N and (ALL_GT NOT P2) (ALL_GT width > 0.09um) >= 0.058um
 err1 = EXT HVT_N ALL_GT_NOT_P2_gt_090 < 0.058 ABUT<90 SINGULAR REGION MEASURE ALL
 err1 NOT INSIDE SealR_NOT_BULK
}

HVT_N_S_8 {
@ Space between HVT_N and (ALL_GT NOT P2) (ALL_GT width < 0.07um) in S/D direction >= 0.035um
 err1 = EXT ALL_GT_NOT_P2 HVT_N_v_edges < 0.035 ABUT<90 OPPOSITE REGION  //;minimum
 err1 NOT INSIDE SealR_NOT_BULK
}

HVT_N_S_8a {
@ Space between HVT_N and (ALL_GT NOT P2) (ALL_GT width >= 0.07um) in S/D direction >= 0.058um
 err1 = EXT HVT_N_v_edges ALL_GT_NOT_P2_eqgt_070 < 0.058 ABUT<90 OPPOSITE REGION MEASURE ALL
 err1 NOT INSIDE SealR_NOT_BULK
}

HVT_N_S_9a {
@ Space between HVT_N and GATE (when channel length = 0.016/0.018/0.02um) respectively in S/D direction (GATE CUT HVT_N is not allowed), except GT_P96 region >= 0.082/0.081/0.08um
 err1 = DFM COPY (DFM SPACE GATE_LE_16 HVT_N < 0.082 BY EXT HORIZONTAL MEASURE ALL) REGION
 err2 = DFM COPY (DFM SPACE GATE_LE_18 HVT_N < 0.081 BY EXT HORIZONTAL MEASURE ALL) REGION
 err3 = DFM COPY (DFM SPACE GATE_LE_20 HVT_N < 0.080 BY EXT HORIZONTAL MEASURE ALL) REGION
 err4 = GATE CUT HVT_N

 err1 NOT INSIDE GT_P96
 err2 NOT INSIDE GT_P96
 err3 NOT INSIDE GT_P96
 err4 NOT INSIDE GT_P96
}

HVT_N_S_9b {
@ Space between HVT_N and GATE (when channel length = 0.016/0.018/0.02/0.022/0.024um, INSIDE GT_P96) in S/D direction (GATE CUT HVT_N is not allowed) >= 0.088/0.087/0.086/0.085/0.084um
 err1 = DFM COPY (DFM SPACE GATE_LE_16_in_GT_P96 HVT_N < 0.088 BY EXT HORIZONTAL MEASURE ALL) REGION
 err2 = DFM COPY (DFM SPACE GATE_LE_18_in_GT_P96 HVT_N < 0.087 BY EXT HORIZONTAL MEASURE ALL) REGION
 err3 = DFM COPY (DFM SPACE GATE_LE_20_in_GT_P96 HVT_N < 0.086 BY EXT HORIZONTAL MEASURE ALL) REGION
 err4 = DFM COPY (DFM SPACE GATE_LE_22_in_GT_P96 HVT_N < 0.085 BY EXT HORIZONTAL MEASURE ALL) REGION
 err5 = DFM COPY (DFM SPACE GATE_LE_24_in_GT_P96 HVT_N < 0.084 BY EXT HORIZONTAL MEASURE ALL) REGION
 err6 = GATE CUT HVT_N

 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
 err4 NOT INSIDE SealR_NOT_BULK
 err5 NOT INSIDE SealR_NOT_BULK
 err6 NOT INSIDE SealR_NOT_BULK
}

HVT_N_S_10 {
@ Space between HVT_N vertical edge (edge length <= 0.238um between two concave corners with both sides length >= 0.09um) and ((GT AND GTMK1) OR GATE) in S/D direction >= 0.079um
 check_RAW = CONVEX EDGE HVT_N ANGLE1 == 270 LENGTH1 >= 0.09 ANGLE2 == 270 LENGTH2 >= 0.09 WITH LENGTH <= 0.238
 check_TMP = ANGLE check_RAW == 90
 err1 = EXT (OR GATE_raw GT_and_GTMK1) check_TMP < 0.079 ABUT<90 OPPOSITE REGION  //;including edge GATE
 err1 NOT INSIDE SealR_NOT_BULK
}

HVT_N_S_11 {
@ Space between HVT_N and (ALL_GT NOT P2) in GATE poly direction with adjacent horizontal space <= 0.04um (HVT_N vertical edge length = 0.073~0.15um, between two consecutive 90-270 degree coners) >= 0.054um
 y1 = EXT [ALL_GT_NOT_P2] HVT_N_convex_90_270_eqgt_073_lteq_150_v_edges <= 0.040 ABUT<90 OPPOSITE
 y2 = EXT [HVT_N_h_edges] HVT_N_convex_90_270_eqgt_073_lteq_150_v_edges < 0.005 ABUT==90 INTERSECTING ONLY

 z1 = HVT_N_h_edges TOUCH EDGE y2
 z2 = EXT ALL_GT_NOT_P2 z1 < 0.054 ABUT<90 OPPOSITE REGION
 z3 = EXPAND EDGE y1 INSIDE BY 0.005 EXTEND BY 0.005
 err1 = z2 INTERACT z3
 err1 NOT INSIDE SealR_NOT_BULK
}

HVT_N_EX_1 {
@ HVT_N extension outside of ALL_AA (vertical edge abut AA edge is allowed) >= 0.045um
 CHECK_RAW = ENC ALL_AA HVT_N < 0.045 ABUT<90 SINGULAR
 WAIVE_CRN = HVT_N COIN INSIDE EDGE ALL_AA_v_edges
 err1 = DFM COPY (DFM PROPERTY CHECK_RAW WAIVE_CRN ABUT ALSO OVERLAP MULTI SPLIT [-= count(WAIVE_CRN)] == 0) REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

HVT_N_EX_2 {
@ HVT_N extension outside of ALL_AA in GATE poly direction >= 0.048um
 err1 = ENC ALL_AA_h_edges HVT_N < 0.048 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

HVT_N_EX_3 {
@ HVT_N extension outside of (ALL_GT NOT P2) (ALL_GT width < 0.07um), except small ALL_GT jog <= 0.004um. >= 0.024um
 err1 = ENC ALL_GT_NOT_P2_not_jog_lteq_004 HVT_N < 0.024 ABUT<90 OPPOSITE REGION  //;minimum
 err1 NOT INSIDE SealR_NOT_BULK
}

HVT_N_EX_4 {
@ HVT_N extension outside of (ALL_GT NOT P2) (ALL_GT width >= 0.07um) >= 0.034um
 err1 = ENC ALL_GT_NOT_P2_eqgt_070 HVT_N < 0.034 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

HVT_N_EX_5 {
@ HVT_N extension outside of (ALL_GT NOT P2) (ALL_GT width > 0.09um) >= 0.058um
 err1 = ENC ALL_GT_NOT_P2_gt_090 HVT_N < 0.058 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

HVT_N_EX_6 {
@ HVT_N extension outside of (ALL_GT NOT P2) (ALL_GT width < 0.07um) in S/D direction >= 0.035um
 err1 = ENC ALL_GT_NOT_P2 HVT_N_v_edges < 0.035 ABUT<90 OPPOSITE REGION //;minimum
 err1 NOT INSIDE SealR_NOT_BULK
}

HVT_N_EX_7 {
@ HVT_N extension outside of (ALL_GT NOT P2) (ALL_GT width >= 0.07um) in S/D direction >= 0.058um
 err1 = ENC ALL_GT_NOT_P2_eqgt_070 HVT_N_v_edges < 0.058 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

HVT_N_EX_8 {
@ HVT_N extension outside of GATE (when channel length = 0.016/0.018/0.02um) respectively in S/D direction, except GT_P96 region >= 0.082/0.081/0.080um
 err1 = DFM COPY (DFM SPACE GATE_LE_16 HVT_N < 0.082 BY ENC HORIZONTAL) REGION
 err2 = DFM COPY (DFM SPACE GATE_LE_18 HVT_N < 0.081 BY ENC HORIZONTAL) REGION
 err3 = DFM COPY (DFM SPACE GATE_LE_20 HVT_N < 0.080 BY ENC HORIZONTAL) REGION

 err1 NOT INSIDE GT_P96
 err2 NOT INSIDE GT_P96
 err3 NOT INSIDE GT_P96
}

HVT_N_EX_9 {
@ HVT_N extension outside of GATE (when channel length = 0.016/0.018/0.02/0.022/0.024um, INSIDE GT_P96) in S/D direction >= 0.088/0.087/0.086/0.085/0.084um
 err1 = DFM COPY (DFM SPACE GATE_LE_16_in_GT_P96 HVT_N < 0.088 BY ENC HORIZONTAL) REGION
 err2 = DFM COPY (DFM SPACE GATE_LE_18_in_GT_P96 HVT_N < 0.087 BY ENC HORIZONTAL) REGION
 err3 = DFM COPY (DFM SPACE GATE_LE_20_in_GT_P96 HVT_N < 0.086 BY ENC HORIZONTAL) REGION
 err4 = DFM COPY (DFM SPACE GATE_LE_22_in_GT_P96 HVT_N < 0.085 BY ENC HORIZONTAL) REGION
 err5 = DFM COPY (DFM SPACE GATE_LE_24_in_GT_P96 HVT_N < 0.084 BY ENC HORIZONTAL) REGION

 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
 err4 NOT INSIDE SealR_NOT_BULK
 err5 NOT INSIDE SealR_NOT_BULK
}

HVT_N_EX_10 {
@ HVT_N (line-end vertical width <= 0.238um between two consecutive 90-90 degree corners with both sides length >= 0.09um) enclosure of ((GT AND GTMK1) OR GATE) in S/D direction >= 0.079um
 check_RAW = CONVEX EDGE HVT_N ANGLE1 == 90 LENGTH1 >= 0.09 ANGLE2 == 90 LENGTH2 >= 0.09 WITH LENGTH <= 0.238
 check_TMP = ANGLE check_RAW == 90
 err1 = ENC (OR GATE_raw GT_and_GTMK1) check_TMP < 0.079 ABUT<90 OPPOSITE REGION  //;including edge GATE
 err1 NOT INSIDE SealR_NOT_BULK
}

HVT_N_EX_11 {
@ HVT_N extension outside of (ALL_GT NOT P2) in GATE poly direction with adjacent horizontal enclosure <= 0.04um by HVT_N vertical edge (edge length = 0.073~0.150um,
@ between two consecutive 90-270 degree corners) >= 0.054um
 y1 = ENC [ALL_GT_NOT_P2] HVT_N_convex_90_270_eqgt_073_lteq_150_v_edges <= 0.040 ABUT<90 OPPOSITE
 y2 = INT [HVT_N_h_edges] HVT_N_convex_90_270_eqgt_073_lteq_150_v_edges < 0.005 ABUT==90 INTERSECTING ONLY
 y3 = HVT_N_h_edges TOUCH EDGE y2
 y4 = ENC ALL_GT_NOT_P2 y3 < 0.054 ABUT<90 OPPOSITE REGION
 y5 = EXPAND EDGE y1 INSIDE BY 0.005 EXTEND BY 0.005
 err1 = y4 INTERACT y5
 err1 NOT INSIDE SealR_NOT_BULK
}

HVT_N_in_ALL_GT_h_edges = ANGLE (HVT_N NOT OUTSIDE EDGE ALL_GT) == 0
HVT_N_in_all_GT_in_ar_gtmk1_edges = HVT_N NOT OUTSIDE EDGE all_GT_in_ar_gtmk1
HVT_N_in_all_GT_in_ar_gtmk1_area = INT HVT_N_in_all_GT_in_ar_gtmk1_edges < 0.005 ABUT INTERSECTING ONLY REGION

HVT_N_EX_12 {
@ (ALL_GT NOT P2) extension outside of HVT_N, except small ALL_GT jogs <= 0.004um, Dummy_Cell_WO_IMP, and HVT_N vertical edge CUT (GTMK1 OR AR) (channel length <= 0.024um, centerline abut HVT_N vertical edge) >= 0.083um
//;Only need to check the vertical extension.
 y1 = HVT_N_in_all_GT_in_ar_gtmk1_edges COIN EDGE all_GT_center_even
 y2 = ANGLE (HVT_N_in_all_GT_in_ar_gtmk1_edges TOUCH EDGE (HVT_N_in_all_GT_in_ar_gtmk1_area WITH EDGE (HVT_N_in_all_GT_in_ar_gtmk1_area COIN EDGE y1))) == 0
 y3 = HVT_N_in_ALL_GT_h_edges NOT COIN EDGE y2
 err1 = ENC y3 ALL_GT_NOT_P2_not_jog_lteq_004 < 0.083 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE Dummy_Cell_WO_IMP
}

HVT_N_O_1 {
@ Overlap of (ALL_GT NOT P2) and HVT_N, except small ALL_GT jogs <= 0.004um, Dummy_Cell_WO_IMP, and HVT_N vertical edge CUT (GTMK1 OR AR) (channel length <= 0.024um, centerline abut HVT_N vertical edge) >= 0.083um
//;Only need to check the vertical overlap.
 y1 = HVT_N_in_all_GT_in_ar_gtmk1_edges COIN EDGE all_GT_center_even
 y2 = ANGLE (HVT_N_in_all_GT_in_ar_gtmk1_edges TOUCH EDGE (HVT_N_in_all_GT_in_ar_gtmk1_area WITH EDGE (HVT_N_in_all_GT_in_ar_gtmk1_area COIN EDGE y1))) == 0
 y3 = HVT_N_in_ALL_GT_h_edges NOT COIN EDGE y2
 err1 = INT y3 ALL_GT_NOT_P2_not_jog_lteq_004 < 0.083 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE Dummy_Cell_WO_IMP
}

HVT_N_A_1 {
@ HVT_N area >= 0.085um2
 err1 = AREA HVT_N < VT_MiniArea
 err1 NOT INSIDE SealR_NOT_BULK
}

HVT_N_A_2 {
@ HVT_N enclosed area >= 0.085um2
 err1 = AREA ((HOLES HVT_N INNER SINGULAR ALSO) NOT HVT_N) < VT_MiniArea
 err1 NOT INSIDE SealR_NOT_BULK
}

HVT_N_A_3 {
@ Area of ((ALL_GT NOT P2) AND HVT_N) >= 0.00158um2
 err1 = AREA (ALL_GT_NOT_P2 AND HVT_N) < 0.00158
 err1 NOT INSIDE SealR_NOT_BULK
}

HVT_N_R_1 {
@ (ALL_AA interact GT (width >= 0.032um)) CUT HVT_N is not allowed
 err1 = ALL_AA_INTERACT_GT_eqgt_032 CUT HVT_N
 err1 NOT INSIDE SealR_NOT_BULK
}

HVT_N_R_2 {
@ HVT_N overlap with P+AA, SVT_N, SVT_P, HVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, DG, PSUB, INST, RESNW, VARMOS, DMPNP, MARKS is not allowed, exclude OCCD region
 err1 = HVT_N AND (OR PACT SVT_N SVT_P HVT_P LVT_N LVT_P ULVT_N ULVT_P LFN_N LFN_P DG PSUB INST RESNW VARMOS DMPNP MARKS)
 err1 NOT INSIDE OCCD
}

HVT_N_R_3 {
@ (ALL_AA NOT AR) straddle on HVT_N horizontal edge is not allowed
 err1 = HVT_N_h_edges COIN EDGE ((HVT_N CUT ALL_AA_NOT_AR) INSIDE EDGE ALL_AA_NOT_AR)
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

// =======================================================
// HVT_P: P-type High Vt MOS design rules
// =======================================================

GROUP GHVT_P HVT_P_?

HVT_P_W_1 {
@ HVT_P width, single-point-interaction is allowed >= 0.192um
@ DRC waive:
@ 1) HVT_P one-track width within the range of 0.09~0.106um, 0.18~0.212um when PRL = 0um
@ 2) Jog width adjacent to edge (length <= 0.048um, between two consecutive 90-270 degree corners) = 0.18um in S/D direction
@ 3) Jog width adjacent to edge (length = 0.002um, between two consecutive 90-270 degree corners) = 0.135/0.144um in S/D direction
 y1 = INT [HVT_P] < 0.192 ABUT<90 OPPOSITE EXTENDED 0.001
 y2 = INT [HVT_P] < 0.192 CORNER
 y3 = INT [HVT_P_v_edges] >= 0.09 < 0.107 PROJ == 0
 y4 = INT [HVT_P_v_edges] >= 0.18 < 0.213 PROJ == 0
 y5 = INT [HVT_P_h_edges] >= 0.09 < 0.107 PROJ == 0
 y6 = INT [HVT_P_h_edges] >= 0.18 < 0.213 PROJ == 0
 y_all = (y3 OR EDGE y4) OR EDGE (y5 OR EDGE y6)

 waive_edges = HVT_P_90_90_jog_180_135_144 COIN EDGE HVT_P_h_edges
 waive_corner = INT [HVT_P_v_edges] waive_edges < 0.001 ABUT==90 INTERSECTING ONLY
 err1 = (y1 NOT COIN EDGE y_all) NOT TOUCH EDGE waive_corner
 err2 = (y2 COIN EDGE HVT_P_concave_corner) NOT TOUCH EDGE y_all
 err1 NOT INSIDE EDGE SealR_NOT_BULK
 err2 NOT INSIDE EDGE SealR_NOT_BULK
}

HVT_P_W_2 {
@ HVT_P width in S/D direction, single-point-interaction is allowed >= 0.27um
@ DRC waive:
@ 1) HVT_P one-track width within the range of 0.09~0.106um, 0.18~0.212um when PRL = 0um
@ 2) Jog width adjacent to edge (length <= 0.048um, between two consecutive 90-270 degree corners) = 0.18/0.192/0.225/0.24um in S/D direction
@ 3) Jog width adjacent to edge (length = 0.002um, between two consecutive 90-270 degree corners) = 0.135/0.144um in S/D direction
 y1 = INT [HVT_P_v_edges] < 0.27 ABUT<90 OPPOSITE EXTENDED 0.001
 y2 = INT [HVT_P_v_edges] >= 0.09 < 0.107 PROJ == 0
 y3 = INT [HVT_P_v_edges] >= 0.18 < 0.213 PROJ == 0
 y4 = y2 OR EDGE y3

 waive_corner = INT [HVT_P_v_edges] HVT_P_90_90_jog_180_192_225_240_135_144_h_edges < 0.001 ABUT==90 INTERSECTING ONLY
 err1 = (y1 NOT COIN EDGE y4) NOT TOUCH EDGE waive_corner
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

HVT_P_W_3 {
@ HVT_P width in GATE poly direction when HVT_P point touch or horizontal width in the range of 0.09~0.106um, 0.18~0.212um while PRL = 0um in GATE poly direction (except L-shape/T-shape concave corner) >= 0.238um
 err1 = INT (HVT_P_h_edges_singular_point COIN EDGE HVT_P_concave_corner) HVT_P_h_edges < 0.238 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK

 y1 = HVT_P_convex_eqlt_1_edges COIN EDGE HVT_P_h_edges
 y2 = HVT_P COIN EDGE (EXPAND EDGE (y1 COIN EDGE HVT_P_concave_corner) INSIDE BY 0.001 OUTSIDE BY 0.001)
 y3 = INT [y2] >= 0.09 <= 0.106+0.0005 ABUT<90 PROJ == 0
 y4 = INT [y2] >= 0.18 <= 0.212+0.0005 ABUT<90 PROJ == 0
 y5 = HVT_P_concave_corner WITH EDGE (HVT_P_concave_corner COIN EDGE (y3 OR EDGE y4))
 y6 = HVT_P_h_edges COIN EDGE y5
 err2 = INT HVT_P_h_edges y6 < 0.238 ABUT<90 OPPOSITE REGION
 err3 = (LENGTH ((HVT_P_v_edges TOUCH EDGE y5) TOUCH EDGE HVT_P_convex_eq_1_edges) < 0.238) EXPAND EDGE INSIDE BY 0.001
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
}

HVT_P_S_1 {
@ Space between HVT_P, single-point-interaction is allowed >= 0.192um
@ DRC waive:
@ 1) HVT_P one-track space within the range of 0.09~0.106um, 0.18~0.212um when PRL = 0um
@ 2) Jog space adjacent to edge (length <= 0.048um, between two consecutive 90-270 degree corners) = 0.18um in S/D direction
@ 3) Jog space adjacent to edge (length = 0.002um, between two consecutive 90-270 degree corners) = 0.135/0.144um in S/D direction
 y1 = EXT [HVT_P] < 0.192 ABUT<90 OPPOSITE EXTENDED 0.001
 y2 = EXT [HVT_P] < 0.192 CORNER
 y3 = EXT [HVT_P_v_edges] >= 0.09 < 0.107 PROJ == 0
 y4 = EXT [HVT_P_v_edges] >= 0.18 < 0.213 PROJ == 0
 y5 = EXT [HVT_P_h_edges] >= 0.09 < 0.107 PROJ == 0
 y6 = EXT [HVT_P_h_edges] >= 0.18 < 0.213 PROJ == 0
 y_all = (y3 OR EDGE y4) OR EDGE (y5 OR EDGE y6)
 w_all = HVT_P_rvs_90_90_jog_180_135_144 OR EDGE HVT_P_90_90_jog_180_135_144

 z1 = w_all COIN EDGE HVT_P_h_edges
 z2 = HVT_P_rvs COIN EDGE HVT_P_v_edges
 z3 = INT [z2] z1 < 0.005 ABUT==90 INTERSECTING ONLY
 err1 = (y1 NOT COIN EDGE y_all) NOT TOUCH EDGE z3
 err2 = (y2 COIN EDGE HVT_P_convex_corner) NOT COIN EDGE y_all
 err1 NOT INSIDE EDGE SealR_NOT_BULK
 err2 NOT INSIDE EDGE SealR_NOT_BULK
}

HVT_P_S_2 {
@ Space between HVT_P in S/D direction, single-point-interaction is allowed >= 0.27um
@ DRC waive:
@ 1) HVT_P one-track space within the range of 0.09~0.106um, 0.18~0.212um when PRL = 0um
@ 2) Jog space adjacent to edge (length <= 0.048um, between two consecutive 90-270 degree corners) = 0.180/0.192/0.225/0.24um in S/D direction
@ 3) Jog space adjacent to edge (length = 0.002um, between two consecutive 90-270 degree corners) = 0.135/0.144um in S/D direction
 w_all = HVT_P_90_90_jog_180_192_225_240_135_144 OR EDGE HVT_P_rvs_90_90_jog_180_192_225_240_135_144
 y1 = ANGLE (EXT [HVT_P] < 0.27 ABUT<90 OPPOSITE EXTENDED 0.001) == 90
 y2 = EXT [HVT_P_v_edges] >= 0.09 < 0.107 PROJ == 0
 y3 = EXT [HVT_P_v_edges] >= 0.18 < 0.213 PROJ == 0
 y4 = y2 OR EDGE y3

 z1 = ANGLE HVT_P_rvs == 0
 z2 = w_all COIN EDGE z1
 z3 = ANGLE HVT_P_rvs == 90
 z4 = INT [z3] z2 < 0.001 ABUT==90 INTERSECTING ONLY
 err1 = (y1 NOT COIN EDGE y4) NOT TOUCH EDGE z4
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

HVT_P_S_3a {
@ Space between HVT_P when just one vertical edge CUT (GTMK1 OR AR) in S/D direction >= 0.315um
@ DRC waive:
@ 1) Jog space adjacent to edge (length <= 0.048um, between two consecutive 90-270 degree corners) = 0.180/0.192/0.225/0.24um in S/D direction
@ 2) Jog space adjacent to edge (length = 0.002um, between two consecutive 90-270 degree corners) = 0.135/0.144um in S/D direction
 waive_corner = EXT HVT_P_270_270_jog_180_192_225_240_135_144_h_edges HVT_P_v_edges <= 0.001 ABUT==90 INTERSECTING ONLY REGION
 check_corner = HVT_P_inside_AA_side_mark_v_edges NOT TOUCH EDGE waive_corner
 err1 = EXT check_corner HVT_P_v_edges < 0.315 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

HVT_P_S_3b {
@ Space between HVT_P when both vertical edge CUT (GTMK1 OR AR) in S/D direction >= 0.36um
@ DRC waive:
@ 1) Jog space adjacent to edge (length <= 0.048um, between two consecutive 90-270 degree corners) = 0.180/0.192/0.225/0.24um in S/D direction
@ 2) Jog space adjacent to edge (length = 0.002um, between two consecutive 90-270 degree corners) = 0.135/0.144um in S/D direction
 waive_corner = EXT HVT_P_270_270_jog_180_192_225_240_135_144_h_edges HVT_P_v_edges <= 0.001 ABUT==90 INTERSECTING ONLY REGION
 check_corner = HVT_P_inside_AA_side_mark_v_edges NOT TOUCH EDGE waive_corner
 err1 = EXT check_corner < 0.36 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

HVT_P_S_4 {
@ Space between HVT_P when PRL >= 0.29um. >= 0.248um
 Layer_area = EXT HVT_P < 0.248 OPPOSITE REGION
 err1 = Layer_area ENCLOSE RECTANGLE 0.001 0.29 ORTHOGONAL ONLY
 err1 NOT INSIDE SealR_NOT_BULK
}

HVT_P_S_5 {
@ Space between HVT_P in GATE poly direction when HVT_P point touch or horizontal width in the range of 0.09~0.106um, 0.180~0.212 while PRL = 0um in GATE poly direction >= 0.238um
 err1 = EXT HVT_P_h_edges_singular_point HVT_P_h_edges < 0.238 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK

 y1 = HVT_P_convex_eqlt_1_edges COIN EDGE HVT_P_h_edges
 y2 = HVT_P COIN EDGE (EXPAND EDGE (y1 COIN EDGE HVT_P_concave_corner) INSIDE BY 0.001 OUTSIDE BY 0.001)
 y3 = INT [y2] >= 0.09 <= 0.106+0.0005 ABUT<90 PROJ == 0
 y4 = INT [y2] >= 0.18 <= 0.212+0.0005 ABUT<90 PROJ == 0
 y5 = HVT_P_concave_corner WITH EDGE (HVT_P_concave_corner COIN EDGE (y3 OR EDGE y4))
 y6 = HVT_P_h_edges TOUCH EDGE y5
 err2 = EXT HVT_P_h_edges y6 < 0.238 ABUT<90 OPPOSITE REGION
 err3 = (LENGTH ((HVT_P_v_edges TOUCH EDGE y5) TOUCH EDGE HVT_P_convex_eq_0_edges) < 0.238) EXPAND EDGE INSIDE BY 0.002
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
}

HVT_P_S_6 {
@ Space between HVT_P and ALL_AA (vertical edge abut AA edge is allowed) >= 0.045um
 CHECK_RAW = EXT HVT_P ALL_AA < 0.045 ABUT<90 SINGULAR
 WAIVE_CRN = HVT_P COIN OUTSIDE EDGE ALL_AA_v_edges
 err1 = DFM COPY (DFM PROPERTY CHECK_RAW WAIVE_CRN ABUT ALSO OVERLAP MULTI SPLIT [-= count(WAIVE_CRN)] == 0) REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

HVT_P_S_6a {
@ Space between HVT_P and ALL_AA in GATE poly direction >= 0.048um
 err1 = EXT HVT_P ALL_AA_h_edges < 0.048 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

HVT_P_S_7 {
@ Space between HVT_P and (ALL_GT NOT P2) (ALL_GT width < 0.07um), except small ALL_GT jogs <= 0.004um. >= 0.024um
 err1 = EXT HVT_P ALL_GT_NOT_P2_not_jog_lteq_004 < 0.024 ABUT<90 REGION MEASURE ALL  //;minimum
 err1 NOT INSIDE SealR_NOT_BULK
}

HVT_P_S_7a {
@ Space between HVT_P and (ALL_GT NOT P2) (ALL_GT width >= 0.07um) >= 0.034um
 err1 = EXT HVT_P (ALL_GT_eqgt_070 NOT P2) < 0.034 ABUT<90 SINGULAR REGION MEASURE ALL
 err1 NOT INSIDE SealR_NOT_BULK
}

HVT_P_S_7b {
@ Space between HVT_P and (ALL_GT NOT P2) (ALL_GT width > 0.09um) >= 0.058um
 err1 = EXT HVT_P ALL_GT_NOT_P2_gt_090 < 0.058 ABUT<90 SINGULAR REGION MEASURE ALL
 err1 NOT INSIDE SealR_NOT_BULK
}

HVT_P_S_8 {
@ Space between HVT_P and (ALL_GT NOT P2) (ALL_GT width < 0.07um) in S/D direction >= 0.035um
 err1 = EXT ALL_GT_NOT_P2 HVT_P_v_edges < 0.035 ABUT<90 OPPOSITE REGION  //;minimum
 err1 NOT INSIDE SealR_NOT_BULK
}

HVT_P_S_8a {
@ Space between HVT_P and (ALL_GT NOT P2) (ALL_GT width >= 0.07um) in S/D direction >= 0.058um
 err1 = EXT HVT_P_v_edges ALL_GT_NOT_P2_eqgt_070 < 0.058 ABUT<90 OPPOSITE REGION MEASURE ALL
 err1 NOT INSIDE SealR_NOT_BULK
}

HVT_P_S_9a {
@ Space between HVT_P and GATE (when channel length = 0.016/0.018/0.02um) respectively in S/D direction (GATE CUT HVT_P is not allowed), except GT_P96 region >= 0.082/0.081/0.08um
 err1 = DFM COPY (DFM SPACE GATE_LE_16 HVT_P < 0.082 BY EXT HORIZONTAL MEASURE ALL) REGION
 err2 = DFM COPY (DFM SPACE GATE_LE_18 HVT_P < 0.081 BY EXT HORIZONTAL MEASURE ALL) REGION
 err3 = DFM COPY (DFM SPACE GATE_LE_20 HVT_P < 0.080 BY EXT HORIZONTAL MEASURE ALL) REGION
 err4 = GATE CUT HVT_P

 err1 NOT INSIDE GT_P96
 err2 NOT INSIDE GT_P96
 err3 NOT INSIDE GT_P96
 err4 NOT INSIDE GT_P96
}

HVT_P_S_9b {
@ Space between HVT_P and GATE (when channel length = 0.016/0.018/0.02/0.022/0.024um, INSIDE GT_P96) in S/D direction (GATE CUT HVT_P is not allowed) >= 0.088/0.087/0.086/0.085/0.084um
 err1 = DFM COPY (DFM SPACE GATE_LE_16_in_GT_P96 HVT_P < 0.088 BY EXT HORIZONTAL MEASURE ALL) REGION
 err2 = DFM COPY (DFM SPACE GATE_LE_18_in_GT_P96 HVT_P < 0.087 BY EXT HORIZONTAL MEASURE ALL) REGION
 err3 = DFM COPY (DFM SPACE GATE_LE_20_in_GT_P96 HVT_P < 0.086 BY EXT HORIZONTAL MEASURE ALL) REGION
 err4 = DFM COPY (DFM SPACE GATE_LE_22_in_GT_P96 HVT_P < 0.085 BY EXT HORIZONTAL MEASURE ALL) REGION
 err5 = DFM COPY (DFM SPACE GATE_LE_24_in_GT_P96 HVT_P < 0.084 BY EXT HORIZONTAL MEASURE ALL) REGION
 err6 = GATE CUT HVT_P

 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
 err4 NOT INSIDE SealR_NOT_BULK
 err5 NOT INSIDE SealR_NOT_BULK
 err6 NOT INSIDE SealR_NOT_BULK
}

HVT_P_S_10 {
@ Space between HVT_P vertical edge (edge length <= 0.238um between two concave corners with both sides length >= 0.09um) and ((GT AND GTMK1) OR GATE) in S/D direction >= 0.079um
 check_RAW = CONVEX EDGE HVT_P ANGLE1 == 270 LENGTH1 >= 0.09 ANGLE2 == 270 LENGTH2 >= 0.09 WITH LENGTH <= 0.238
 check_TMP = ANGLE check_RAW == 90
 err1 = EXT (OR GATE_raw GT_and_GTMK1) check_TMP < 0.079 ABUT<90 OPPOSITE REGION  //;including edge GATE
 err1 NOT INSIDE SealR_NOT_BULK
}

HVT_P_S_11 {
@ Space between HVT_P and (ALL_GT NOT P2) in GATE poly direction with adjacent horizontal space <= 0.04um (HVT_P vertical edge length = 0.073~0.150um, between two consecutive 90-270 degree coners) >= 0.054um
 y1 = EXT [ALL_GT_NOT_P2] HVT_P_convex_90_270_eqgt_073_lteq_150_v_edges <= 0.040 ABUT<90 OPPOSITE
 y2 = EXT [HVT_P_h_edges] HVT_P_convex_90_270_eqgt_073_lteq_150_v_edges < 0.005 ABUT==90 INTERSECTING ONLY

 z1 = HVT_P_h_edges TOUCH EDGE y2
 z2 = EXT ALL_GT_NOT_P2 z1 < 0.054 ABUT<90 OPPOSITE REGION
 z3 = EXPAND EDGE y1 INSIDE BY 0.005 EXTEND BY 0.005
 err1 = z2 INTERACT z3
 err1 NOT INSIDE SealR_NOT_BULK
}

HVT_P_EX_1 {
@ HVT_P extension outside of ALL_AA (vertical edge abut AA edge is allowed) >= 0.045um
 CHECK_RAW = ENC ALL_AA HVT_P < 0.045 ABUT<90 SINGULAR
 WAIVE_CRN = HVT_P COIN INSIDE EDGE ALL_AA_v_edges
 err1 = DFM COPY (DFM PROPERTY CHECK_RAW WAIVE_CRN ABUT ALSO OVERLAP MULTI SPLIT [-= count(WAIVE_CRN)] == 0) REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

HVT_P_EX_2 {
@ HVT_P extension outside of ALL_AA in GATE poly direction >= 0.048um
 err1 = ENC ALL_AA_h_edges HVT_P < 0.048 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

HVT_P_EX_3 {
@ HVT_P extension outside of (ALL_GT NOT P2) (ALL_GT width < 0.07um), except small ALL_GT jogs <= 0.004um. >= 0.024um
 err1 = ENC ALL_GT_NOT_P2_not_jog_lteq_004 HVT_P < 0.024 ABUT<90 OPPOSITE REGION  //;minimum
 err1 NOT INSIDE SealR_NOT_BULK
}

HVT_P_EX_4 {
@ HVT_P extension outside of (ALL_GT NOT P2) (ALL_GT width >= 0.07um) >= 0.034um
 err1 = ENC ALL_GT_NOT_P2_eqgt_070 HVT_P < 0.034 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

HVT_P_EX_5 {
@ HVT_P extension outside of (ALL_GT NOT P2) (ALL_GT width > 0.09um) >= 0.058um
 err1 = ENC ALL_GT_NOT_P2_gt_090 HVT_P < 0.058 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

HVT_P_EX_6 {
@ HVT_P extension outside of (ALL_GT NOT P2) (ALL_GT width < 0.07um) in S/D direction >= 0.035um
 err1 = ENC ALL_GT_NOT_P2 HVT_P_v_edges < 0.035 ABUT<90 OPPOSITE REGION //;minimum
 err1 NOT INSIDE SealR_NOT_BULK
}

HVT_P_EX_7 {
@ HVT_P extension outside of (ALL_GT NOT P2) (ALL_GT width >= 0.07um) in S/D direction >= 0.058um
 err1 = ENC ALL_GT_NOT_P2_eqgt_070 HVT_P_v_edges < 0.058 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

HVT_P_EX_8 {
@ HVT_P extension outside of GATE (when channel length = 0.016/0.018/0.02um) respectively in S/D direction, except GT_P96 region >= 0.082/0.081/0.080um
 err1 = DFM COPY (DFM SPACE GATE_LE_16 HVT_P < 0.082 BY ENC HORIZONTAL) REGION
 err2 = DFM COPY (DFM SPACE GATE_LE_18 HVT_P < 0.081 BY ENC HORIZONTAL) REGION
 err3 = DFM COPY (DFM SPACE GATE_LE_20 HVT_P < 0.080 BY ENC HORIZONTAL) REGION

 err1 NOT INSIDE GT_P96
 err2 NOT INSIDE GT_P96
 err3 NOT INSIDE GT_P96
}

HVT_P_EX_9 {
@ HVT_P extension outside of GATE (when channel length = 0.016/0.018/0.02/0.022/0.024um, INSIDE GT_P96) in S/D direction >= 0.088/0.087/0.086/0.085/0.084um
 err1 = DFM COPY (DFM SPACE GATE_LE_16_in_GT_P96 HVT_P < 0.088 BY ENC HORIZONTAL) REGION
 err2 = DFM COPY (DFM SPACE GATE_LE_18_in_GT_P96 HVT_P < 0.087 BY ENC HORIZONTAL) REGION
 err3 = DFM COPY (DFM SPACE GATE_LE_20_in_GT_P96 HVT_P < 0.086 BY ENC HORIZONTAL) REGION
 err4 = DFM COPY (DFM SPACE GATE_LE_22_in_GT_P96 HVT_P < 0.085 BY ENC HORIZONTAL) REGION
 err5 = DFM COPY (DFM SPACE GATE_LE_24_in_GT_P96 HVT_P < 0.084 BY ENC HORIZONTAL) REGION

 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
 err4 NOT INSIDE SealR_NOT_BULK
 err5 NOT INSIDE SealR_NOT_BULK
}

HVT_P_EX_10 {
@ HVT_P (line-end vertical width <= 0.238um between two consecutive 90-90 degree corners with both sides length >= 0.09um) enclosure of ((GT AND GTMK1) OR GATE) in S/D direction >= 0.079um
 check_RAW = CONVEX EDGE HVT_P ANGLE1 == 90 LENGTH1 >= 0.09 ANGLE2 == 90 LENGTH2 >= 0.09 WITH LENGTH <= 0.238
 check_TMP = ANGLE check_RAW == 90
 err1 = ENC (OR GATE_raw GT_and_GTMK1) check_TMP < 0.079 ABUT<90 OPPOSITE REGION  //;including edge GATE
 err1 NOT INSIDE SealR_NOT_BULK
}

HVT_P_EX_11 {
@ HVT_P extension outside of (ALL_GT NOT P2) in GATE poly direction with adjacent horizontal enclosure <= 0.04um by HVT_P vertical edge (edge length = 0.073~0.150um, between two consecutive 90-270 degree corners) >= 0.054um
 y1 = ENC [ALL_GT_NOT_P2] HVT_P_convex_90_270_eqgt_073_lteq_150_v_edges <= 0.040 ABUT<90 OPPOSITE
 y2 = INT [HVT_P_h_edges] HVT_P_convex_90_270_eqgt_073_lteq_150_v_edges < 0.005 ABUT==90 INTERSECTING ONLY
 y3 = HVT_P_h_edges TOUCH EDGE y2
 y4 = ENC ALL_GT_NOT_P2 y3 < 0.054 ABUT<90 OPPOSITE REGION
 y5 = EXPAND EDGE y1 INSIDE BY 0.005 EXTEND BY 0.005
 err1 = y4 INTERACT y5
 err1 NOT INSIDE SealR_NOT_BULK
}

HVT_P_in_ALL_GT_h_edges = ANGLE (HVT_P NOT OUTSIDE EDGE ALL_GT) == 0
HVT_P_in_all_GT_in_ar_gtmk1_edges = HVT_P NOT OUTSIDE EDGE all_GT_in_ar_gtmk1
HVT_P_in_all_GT_in_ar_gtmk1_area = INT HVT_P_in_all_GT_in_ar_gtmk1_edges < 0.005 ABUT INTERSECTING ONLY REGION

HVT_P_EX_12 {
@ (ALL_GT NOT P2) extension outside of HVT_P, except small ALL_GT jogs <= 0.004um, Dummy_Cell_WO_IMP, and HVT_P vertical edge CUT (GTMK1 OR AR) (channel length <= 0.024um, centerline abut HVT_P vertical edge) >= 0.083um
//;Only need to check the vertical extension
 y1 = HVT_P_in_all_GT_in_ar_gtmk1_edges COIN EDGE all_GT_center_even
 y2 = ANGLE (HVT_P_in_all_GT_in_ar_gtmk1_edges TOUCH EDGE (HVT_P_in_all_GT_in_ar_gtmk1_area WITH EDGE (HVT_P_in_all_GT_in_ar_gtmk1_area COIN EDGE y1))) == 0
 y3 = HVT_P_in_ALL_GT_h_edges NOT COIN EDGE y2
 err1 = ENC y3 ALL_GT_NOT_P2_not_jog_lteq_004 < 0.083 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE Dummy_Cell_WO_IMP
}

HVT_P_O_1 {
@ Overlap of (ALL_GT NOT P2) and HVT_P, except small ALL_GT jogs <= 0.004um, Dummy_Cell_WO_IMP, and HVT_P vertical edge CUT (GTMK1 OR AR) (channel length <= 0.024um, centerline abut HVT_P vertical edge) >= 0.083um
//;Only need to check the vertical overlap.
 y1 = HVT_P_in_all_GT_in_ar_gtmk1_edges COIN EDGE all_GT_center_even
 y2 = ANGLE (HVT_P_in_all_GT_in_ar_gtmk1_edges TOUCH EDGE (HVT_P_in_all_GT_in_ar_gtmk1_area WITH EDGE (HVT_P_in_all_GT_in_ar_gtmk1_area COIN EDGE y1))) == 0
 y3 = HVT_P_in_ALL_GT_h_edges NOT COIN EDGE y2
 err1 = INT y3 ALL_GT_NOT_P2_not_jog_lteq_004 < 0.083 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE Dummy_Cell_WO_IMP
}

HVT_P_A_1 {
@ HVT_P area >= 0.085um2
 err1 = AREA HVT_P < VT_MiniArea
 err1 NOT INSIDE SealR_NOT_BULK
}

HVT_P_A_2 {
@ HVT_P enclosed area >= 0.085um2
 err1 = AREA ((HOLES HVT_P INNER SINGULAR ALSO) NOT HVT_P) < VT_MiniArea
 err1 NOT INSIDE SealR_NOT_BULK
}

HVT_P_A_3 {
@ Area of ((ALL_GT NOT P2) AND HVT_P) >= 0.00158um2
 err1 = AREA (ALL_GT_NOT_P2 AND HVT_P) < 0.00158
 err1 NOT INSIDE SealR_NOT_BULK
}

HVT_P_R_1 {
@ (ALL_AA interact GT (width >= 0.032um)) CUT HVT_P is not allowed
 err1 = ALL_AA_INTERACT_GT_eqgt_032 CUT HVT_P
 err1 NOT INSIDE SealR_NOT_BULK
}

HVT_P_R_2 {
@ HVT_P overlap with N+AA, SVT_N, SVT_P, HVT_N, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, DG, PSUB, INST, RESNW, VARMOS, DMPNP, MARKS is not allowed, exclude OCCD region
 err1 = HVT_P AND (OR NACT SVT_N SVT_P HVT_N LVT_N LVT_P ULVT_N ULVT_P LFN_N LFN_P DG PSUB INST RESNW VARMOS DMPNP MARKS)
 err1 NOT INSIDE OCCD
}

HVT_P_R_3 {
@ (ALL_AA NOT AR) straddle on HVT_P horizontal edge is not allowed
 err1 = HVT_P_h_edges COIN EDGE ((HVT_P CUT ALL_AA_NOT_AR) INSIDE EDGE ALL_AA_NOT_AR)
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

// =======================================================
// LVT_N: N-type Low Vt MOS design rules
// =======================================================

GROUP GLVT_N LVT_N_?

LVT_N_W_1 {
@ LVT_N width, single-point-interaction is allowed >= 0.192um
@ DRC waive:
@ 1) LVT_N one-track width within the range of 0.09~0.106um, 0.18~0.212um when PRL = 0um
@ 2) Jog width adjacent to edge (length <= 0.048um, between two consecutive 90-270 degree corners) = 0.18um in S/D direction
@ 3) Jog width adjacent to edge (length = 0.002um, between two consecutive 90-270 degree corners) = 0.135/0.144um in S/D direction
 y1 = INT [LVT_N] < 0.192 ABUT<90 OPPOSITE EXTENDED 0.001
 y2 = INT [LVT_N] < 0.192 CORNER
 y3 = INT [LVT_N_v_edges] >= 0.09 < 0.107 PROJ == 0
 y4 = INT [LVT_N_v_edges] >= 0.18 < 0.213 PROJ == 0
 y5 = INT [LVT_N_h_edges] >= 0.09 < 0.107 PROJ == 0
 y6 = INT [LVT_N_h_edges] >= 0.18 < 0.213 PROJ == 0
 y_all = (y3 OR EDGE y4) OR EDGE (y5 OR EDGE y6)

 waive_edges = LVT_N_90_90_jog_180_135_144 COIN EDGE LVT_N_h_edges
 waive_corner = INT [LVT_N_v_edges] waive_edges < 0.001 ABUT==90 INTERSECTING ONLY
 err1 = (y1 NOT COIN EDGE y_all) NOT TOUCH EDGE waive_corner
 err2 = (y2 COIN EDGE LVT_N_concave_corner) NOT TOUCH EDGE y_all
 err1 NOT INSIDE EDGE SealR_NOT_BULK
 err2 NOT INSIDE EDGE SealR_NOT_BULK
}

LVT_N_W_2 {
@ LVT_N width in S/D direction, single-point-interaction is allowed >= 0.27um
@ DRC waive:
@ 1) LVT_N one-track width within the range of 0.09~0.106um, 0.18~0.212um when PRL = 0um
@ 2) Jog width adjacent to edge (length <= 0.048um, between two consecutive 90-270 degree corners) = 0.18/0.192/0.225/0.24um in S/D direction
@ 3) Jog width adjacent to edge (length = 0.002um, between two consecutive 90-270 degree corners) = 0.135/0.144um in S/D direction
 y1 = INT [LVT_N_v_edges] < 0.27 ABUT<90 OPPOSITE EXTENDED 0.001
 y2 = INT [LVT_N_v_edges] >= 0.09 < 0.107 PROJ == 0
 y3 = INT [LVT_N_v_edges] >= 0.18 < 0.213 PROJ == 0
 y_all = y2 OR EDGE y3

 waive_edges = LVT_N_90_90_jog_180_192_225_240_135_144 COIN EDGE LVT_N_h_edges
 waive_corner = INT [LVT_N_v_edges] waive_edges < 0.001 ABUT==90 INTERSECTING ONLY
 err1 = (y1 NOT COIN EDGE y_all) NOT TOUCH EDGE waive_corner
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

LVT_N_W_3a {
@ LVT_N width in S/D direction when just one LVT_N vertical edge CUT (GTMK1 OR AR), and ABUT SVT_N or HVT_N >= 0.315um
@ DRC waive:
@ 1) Jog width adjacent to edge (length <= 0.048um, between two consecutive 90-270 degree corners) = 0.18/0.192/0.225/0.24um in S/D direction
@ 2) Jog width adjacent to edge (length = 0.002um, between two consecutive 90-270 degree corners) = 0.135/0.144um in S/D direction
 y1 = ((LVT_N_v_edges INSIDE EDGE gtmk1_or_ar) COIN EDGE SVT_N) OR EDGE ((LVT_N_v_edges INSIDE EDGE gtmk1_or_ar) COIN EDGE HVT_N)
 y2 = LVT_N_v_edges TOUCH EDGE y1

 waive_corner = INT LVT_N_v_edges LVT_N_90_90_jog_180_192_225_240_135_144_h_edges <= 0.001 ABUT==90 INTERSECTING ONLY REGION
 check_corner = LVT_N_v_edges NOT TOUCH EDGE waive_corner
 err1 = INT y2 check_corner < 0.315 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

LVT_N_W_3b {
@ LVT_N width in S/D direction when both two LVT_N’s vertical edges CUT (GTMK1 OR AR) and ABUT SVT_N or HVT_N >= 0.36um
@ DRC waive:
@ 1) Jog width adjacent to edge (length <= 0.048um, between two consecutive 90-270 degree corners) = 0.18/0.192/0.225/0.24um in S/D direction
@ 2) Jog width adjacent to edge (length = 0.002um, between two consecutive 90-270 degree corners) = 0.135/0.144um in S/D direction
 y1 = ((LVT_N_v_edges INSIDE EDGE gtmk1_or_ar) COIN EDGE SVT_N) OR EDGE ((LVT_N_v_edges INSIDE EDGE gtmk1_or_ar) COIN EDGE HVT_N)
 y2 = LVT_N_v_edges TOUCH EDGE y1

 waive_corner = INT LVT_N_v_edges LVT_N_90_90_jog_180_192_225_240_135_144_h_edges <= 0.001 ABUT==90 INTERSECTING ONLY REGION
 check_corner = (LVT_N_v_edges NOT TOUCH EDGE waive_corner) TOUCH EDGE y1
 err1 = INT y2 check_corner < 0.360 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

LVT_N_W_4 {
@ LVT_N width in GATE poly direction when LVT_N point touch or horizontal width in the range of 0.09~0.106um, 0.18~0.212um while PRL = 0um in GATE poly direction (except L-shape/T-shape concave corner) >= 0.238um
 err1 = INT (LVT_N_h_edges_singular_point COIN EDGE LVT_N_concave_corner) LVT_N_h_edges < 0.238 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK

 y1 = LVT_N_convex_eqlt_1_edges COIN EDGE LVT_N_h_edges
 y2 = LVT_N COIN EDGE (EXPAND EDGE (y1 COIN EDGE LVT_N_concave_corner) INSIDE BY 0.001 OUTSIDE BY 0.001)
 y3 = INT [y2] >= 0.09 <= 0.106+0.0005 ABUT<90 PROJ == 0
 y4 = INT [y2] >= 0.18 <= 0.212+0.0005 ABUT<90 PROJ == 0
 y5 = LVT_N_concave_corner WITH EDGE (LVT_N_concave_corner COIN EDGE (y3 OR EDGE y4))
 y6 = LVT_N_h_edges COIN EDGE y5
 err2 = INT LVT_N_h_edges y6 < 0.238 ABUT<90 OPPOSITE REGION
 err3 = (LENGTH ((LVT_N_v_edges TOUCH EDGE y5) TOUCH EDGE LVT_N_convex_eq_1_edges) < 0.238) EXPAND EDGE INSIDE BY 0.001
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
}

LVT_N_S_1 {
@ Space between LVT_N, single-point-interaction is allowed >= 0.192um
@ DRC waive:
@ 1) LVT_N one-track space within the range of 0.09~0.106um, 0.18~0.212um when PRL = 0um
@ 2) Jog space adjacent to edge (length <= 0.048um, between two consecutive 90-270 degree corners) = 0.18um in S/D direction
@ 3) Jog space adjacent to edge (length = 0.002um, between two consecutive 90-270 degree corners) = 0.135/0.144um in S/D direction
 y1 = EXT [LVT_N] < 0.192 ABUT<90 OPPOSITE EXTENDED 0.001
 y2 = EXT [LVT_N] < 0.192 CORNER
 y3 = EXT [LVT_N_v_edges] >= 0.09 < 0.107 PROJ == 0
 y4 = EXT [LVT_N_v_edges] >= 0.18 < 0.213 PROJ == 0
 y5 = EXT [LVT_N_h_edges] >= 0.09 < 0.107 PROJ == 0
 y6 = EXT [LVT_N_h_edges] >= 0.18 < 0.213 PROJ == 0
 y_all = (y3 OR EDGE y4) OR EDGE (y5 OR EDGE y6)
 w_all = LVT_N_rvs_90_90_jog_180_135_144 OR EDGE LVT_N_90_90_jog_180_135_144

 z1 = w_all COIN EDGE LVT_N_h_edges
 z2 = LVT_N_rvs COIN EDGE LVT_N_v_edges
 z3 = INT [z2] z1 < 0.005 ABUT==90 INTERSECTING ONLY
 err1 = (y1 NOT COIN EDGE y_all) NOT TOUCH EDGE z3
 err2 = (y2 COIN EDGE LVT_N_convex_corner) NOT COIN EDGE y_all
 err1 NOT INSIDE EDGE SealR_NOT_BULK
 err2 NOT INSIDE EDGE SealR_NOT_BULK
}

LVT_N_S_2 {
@ Space between LVT_N in S/D direction, single-point-interaction is allowed >= 0.27um
@ DRC waive:
@ 1) LVT_N one-track space within the range of 0.09~0.106um, 0.18~0.212um when PRL = 0um
@ 2) Jog space adjacent to edge (length <= 0.048um, between two consecutive 90-270 degree corners) = 0.180/0.192/0.225/0.24um in S/D direction
@ 3) Jog space adjacent to edge (length = 0.002um, between two consecutive 90-270 degree corners) = 0.135/0.144um in S/D direction
 w_all = LVT_N_90_90_jog_180_192_225_240_135_144 OR EDGE LVT_N_rvs_90_90_jog_180_192_225_240_135_144
 y1 = ANGLE (EXT [LVT_N] < 0.27 ABUT<90 OPPOSITE EXTENDED 0.001) == 90
 y2 = EXT [LVT_N_v_edges] >= 0.09 < 0.107 PROJ == 0
 y3 = EXT [LVT_N_v_edges] >= 0.18 < 0.213 PROJ == 0
 y4 = y2 OR EDGE y3

 z1 = ANGLE LVT_N_rvs == 0
 z2 = w_all COIN EDGE z1
 z3 = ANGLE LVT_N_rvs == 90
 z4 = INT [z3] z2 < 0.001 ABUT==90 INTERSECTING ONLY
 err1 = (y1 NOT COIN EDGE y4) NOT TOUCH EDGE z4
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

LVT_N_S_3a {
@ Space between LVT_N when just one vertical edge CUT (GTMK1 OR AR), and ABUT ULVT_N in S/D direction >= 0.315um
@ DRC waive:
@ 1) Jog space adjacent to edge (length <= 0.048um, between two consecutive 90-270 degree corners) = 0.180/0.192/0.225/0.24um in S/D direction
@ 2) Jog space adjacent to edge (length = 0.002um, between two consecutive 90-270 degree corners) = 0.135/0.144um in S/D direction
 check_edges = LVT_N_inside_AA_side_mark_v_edges TOUCH EDGE ULVT_N
 waive_corner = EXT LVT_N_270_270_jog_180_192_225_240_135_144_h_edges check_edges <= 0.001 ABUT==90 INTERSECTING ONLY REGION
 check_corner = check_edges NOT TOUCH EDGE waive_corner
 err1 = EXT check_corner LVT_N_v_edges < 0.315 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

LVT_N_S_3b {
@ Space between LVT_N when both LVT_N’s vertical edge CUT (GTMK1 OR AR) and ABUT ULVT_N) in S/D direction >= 0.36um
@ DRC waive:
@ 1) Jog space adjacent to edge (length <= 0.048um, between two consecutive 90-270 degree corners) = 0.180/0.192/0.225/0.24um in S/D direction
@ 2) Jog space adjacent to edge (length = 0.002um, between two consecutive 90-270 degree corners) = 0.135/0.144um in S/D direction
 check_edges = LVT_N_inside_AA_side_mark_v_edges TOUCH EDGE ULVT_N
 waive_corner = EXT LVT_N_270_270_jog_180_192_225_240_135_144_h_edges check_edges <= 0.001 ABUT==90 INTERSECTING ONLY REGION
 check_corner = check_edges NOT TOUCH EDGE waive_corner
 err1 = EXT check_corner < 0.36 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

LVT_N_S_4 {
@ Space between LVT_N when PRL >= 0.29um. >= 0.248um
 Layer_area = EXT LVT_N < 0.248 OPPOSITE REGION
 err1 = Layer_area ENCLOSE RECTANGLE 0.001 0.29 ORTHOGONAL ONLY
 err1 NOT INSIDE SealR_NOT_BULK
}

LVT_N_S_5 {
@ LVT_N space in GATE poly direction when LVT_N point touch or horizontal width in the range of 0.09~0.106um, 0.18~0.212um while PRL = 0um in GATE poly direction >= 0.238um
 err1 = EXT LVT_N_h_edges_singular_point LVT_N_h_edges < 0.238 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK

 y1 = LVT_N_convex_eqlt_1_edges COIN EDGE LVT_N_h_edges
 y2 = LVT_N COIN EDGE (EXPAND EDGE (y1 COIN EDGE LVT_N_concave_corner) INSIDE BY 0.001 OUTSIDE BY 0.001)
 y3 = INT [y2] >= 0.09 <= 0.106+0.0005 ABUT<90 PROJ == 0
 y4 = INT [y2] >= 0.18 <= 0.212+0.0005 ABUT<90 PROJ == 0
 y5 = LVT_N_concave_corner WITH EDGE (LVT_N_concave_corner COIN EDGE (y3 OR EDGE y4))
 y6 = LVT_N_h_edges TOUCH EDGE y5
 err2 = EXT LVT_N_h_edges y6 < 0.238 ABUT<90 OPPOSITE REGION
 err3 = (LENGTH ((LVT_N_v_edges TOUCH EDGE y5) TOUCH EDGE LVT_N_convex_eq_0_edges) < 0.238) EXPAND EDGE INSIDE BY 0.002
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
}

LVT_N_S_6 {
@ Space between LVT_N and ALL_AA (vertical edge abut AA edge is allowed) >= 0.045um
 CHECK_RAW = EXT LVT_N ALL_AA < 0.045 ABUT<90 SINGULAR
 WAIVE_CRN = LVT_N COIN OUTSIDE EDGE ALL_AA_v_edges
 err1 = DFM COPY (DFM PROPERTY CHECK_RAW WAIVE_CRN ABUT ALSO OVERLAP MULTI SPLIT [-= count(WAIVE_CRN)] == 0) REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

LVT_N_S_6a {
@ Space between LVT_N and ALL_AA in GATE poly direction >= 0.048um
 err1 = EXT LVT_N ALL_AA_h_edges < 0.048 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

LVT_N_S_7 {
@ Space between LVT_N and (ALL_GT NOT P2) (ALL_GT width < 0.07um), except small ALL_GT jogs <= 0.004um. >= 0.024um
 err1 = EXT LVT_N ALL_GT_NOT_P2_not_jog_lteq_004 < 0.024 ABUT<90 REGION MEASURE ALL  //;minimum
 err1 NOT INSIDE SealR_NOT_BULK
}

LVT_N_S_7a {
@ Space between LVT_N and (ALL_GT NOT P2) (ALL_GT width >= 0.07um) >= 0.034um
 err1 = EXT LVT_N (ALL_GT_eqgt_070 NOT P2) < 0.034 ABUT<90 SINGULAR REGION MEASURE ALL
 err1 NOT INSIDE SealR_NOT_BULK
}

LVT_N_S_7b {
@ Space between LVT_N and (ALL_GT NOT P2) (ALL_GT width > 0.09um) >= 0.058um
 err1 = EXT LVT_N ALL_GT_NOT_P2_gt_090 < 0.058 ABUT<90 SINGULAR REGION MEASURE ALL
 err1 NOT INSIDE SealR_NOT_BULK
}

LVT_N_S_8 {
@ Space between LVT_N and (ALL_GT NOT P2) (ALL_GT width < 0.07um) in S/D direction >= 0.035um
 err1 = EXT ALL_GT_NOT_P2 LVT_N_v_edges < 0.035 ABUT<90 OPPOSITE REGION //;minimum
 err1 NOT INSIDE SealR_NOT_BULK
}

LVT_N_S_8a {
@ Space between LVT_N and (ALL_GT NOT P2) (ALL_GT width >= 0.07um) in S/D direction >= 0.058um
 err1 = EXT LVT_N_v_edges ALL_GT_NOT_P2_eqgt_070 < 0.058 ABUT<90 OPPOSITE REGION MEASURE ALL
 err1 NOT INSIDE SealR_NOT_BULK
}

LVT_N_S_9a {
@ Space between LVT_N and GATE (when channel length = 0.016/0.018/0.02um) respectively in S/D direction (GATE CUT LVT_N is not allowed), except GT_P96 region >= 0.082/0.081/0.08um
 err1 = DFM COPY (DFM SPACE GATE_LE_16 LVT_N < 0.082 BY EXT HORIZONTAL MEASURE ALL) REGION
 err2 = DFM COPY (DFM SPACE GATE_LE_18 LVT_N < 0.081 BY EXT HORIZONTAL MEASURE ALL) REGION
 err3 = DFM COPY (DFM SPACE GATE_LE_20 LVT_N < 0.080 BY EXT HORIZONTAL MEASURE ALL) REGION
 err4 = GATE CUT LVT_N

 err1 NOT INSIDE GT_P96
 err2 NOT INSIDE GT_P96
 err3 NOT INSIDE GT_P96
 err4 NOT INSIDE GT_P96
}

LVT_N_S_9b {
@ Space between LVT_N and GATE (when channel length = 0.016/0.018/0.02/0.022/0.024um, INSIDE GT_P96) in S/D direction (GATE CUT LVT_N is not allowed) >= 0.088/0.087/0.086/0.085/0.084um
 err1 = DFM COPY (DFM SPACE GATE_LE_16_in_GT_P96 LVT_N < 0.088 BY EXT HORIZONTAL MEASURE ALL) REGION
 err2 = DFM COPY (DFM SPACE GATE_LE_18_in_GT_P96 LVT_N < 0.087 BY EXT HORIZONTAL MEASURE ALL) REGION
 err3 = DFM COPY (DFM SPACE GATE_LE_20_in_GT_P96 LVT_N < 0.086 BY EXT HORIZONTAL MEASURE ALL) REGION
 err4 = DFM COPY (DFM SPACE GATE_LE_22_in_GT_P96 LVT_N < 0.085 BY EXT HORIZONTAL MEASURE ALL) REGION
 err5 = DFM COPY (DFM SPACE GATE_LE_24_in_GT_P96 LVT_N < 0.084 BY EXT HORIZONTAL MEASURE ALL) REGION
 err6 = GATE CUT LVT_N

 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
 err4 NOT INSIDE SealR_NOT_BULK
 err5 NOT INSIDE SealR_NOT_BULK
 err6 NOT INSIDE SealR_NOT_BULK
}

LVT_N_S_10 {
@ Space between LVT_N vertical edge (edge length <= 0.238um between two concave corners with both sides length >= 0.09um) and ((GT AND GTMK1) OR GATE) in S/D direction >= 0.079um
 check_RAW = CONVEX EDGE LVT_N ANGLE1 == 270 LENGTH1 >= 0.09 ANGLE2 == 270 LENGTH2 >= 0.09 WITH LENGTH <= 0.238
 check_TMP = ANGLE check_RAW == 90
 err1 = EXT (OR GATE_raw GT_and_GTMK1) check_TMP < 0.079 ABUT<90 OPPOSITE REGION  //;including edge GATE
 err1 NOT INSIDE SealR_NOT_BULK
}

LVT_N_S_11 {
@ Space between LVT_N and (ALL_GT NOT P2) in GATE poly direction with adjacent horizontal space <= 0.040um (LVT_N vertical edge length = 0.073~0.150um, between two consecutive 90-270 degree coners) >= 0.054um
 y1 = EXT [ALL_GT_NOT_P2] LVT_N_convex_90_270_eqgt_073_lteq_150_v_edges <= 0.040 ABUT<90 OPPOSITE
 y2 = EXT [LVT_N_h_edges] LVT_N_convex_90_270_eqgt_073_lteq_150_v_edges < 0.005 ABUT==90 INTERSECTING ONLY

 z1 = LVT_N_h_edges TOUCH EDGE y2
 z2 = EXT ALL_GT_NOT_P2 z1 < 0.054 ABUT<90 OPPOSITE REGION
 z3 = EXPAND EDGE y1 INSIDE BY 0.005 EXTEND BY 0.005
 err1 = z2 INTERACT z3
 err1 NOT INSIDE SealR_NOT_BULK
}

LVT_N_EX_1 {
@ LVT_N extension outside of ALL_AA (vertical edge abut AA edge is allowed) >= 0.045um
 CHECK_RAW = ENC ALL_AA LVT_N < 0.045 ABUT<90 SINGULAR
 WAIVE_CRN = LVT_N COIN INSIDE EDGE ALL_AA_v_edges
 err1 = DFM COPY (DFM PROPERTY CHECK_RAW WAIVE_CRN ABUT ALSO OVERLAP MULTI SPLIT [-= count(WAIVE_CRN)] == 0) REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

LVT_N_EX_2 {
@ LVT_N extension outside of ALL_AA in GATE poly direction >= 0.048um
 err1 = ENC ALL_AA_h_edges LVT_N < 0.048 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

LVT_N_EX_3 {
@ LVT_N extension outside of (ALL_GT NOT P2) (ALL_GT width < 0.07um), except small ALL_GT jogs <= 0.004um. >= 0.024um
 err1 = ENC ALL_GT_NOT_P2_not_jog_lteq_004 LVT_N < 0.024 ABUT<90 OPPOSITE REGION  //;minimum
 err1 NOT INSIDE SealR_NOT_BULK
}

LVT_N_EX_4 {
@ LVT_N extension outside of (ALL_GT NOT P2) (ALL_GT width >= 0.07um) >= 0.034um
 err1 = ENC ALL_GT_NOT_P2_eqgt_070 LVT_N < 0.034 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

LVT_N_EX_5 {
@ LVT_N extension outside of (ALL_GT NOT P2) (ALL_GT width > 0.09um) >= 0.058um
 err1 = ENC ALL_GT_NOT_P2_gt_090 LVT_N < 0.058 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

LVT_N_EX_6 {
@ LVT_N extension outside of (ALL_GT NOT P2) (ALL_GT width < 0.07um) in S/D direction >= 0.035um
 err1 = ENC ALL_GT_NOT_P2 LVT_N_v_edges < 0.035 ABUT<90 OPPOSITE REGION //;minimum
 err1 NOT INSIDE SealR_NOT_BULK
}

LVT_N_EX_7 {
@ LVT_N extension outside of (ALL_GT NOT P2) (ALL_GT width >= 0.07um) in S/D direction >= 0.058um
 err1 = ENC ALL_GT_NOT_P2_eqgt_070 LVT_N_v_edges < 0.058 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

LVT_N_EX_8 {
@ LVT_N extension outside of GATE (when channel length = 0.016/0.018/0.02um) respectively in S/D direction, except GT_P96 region >= 0.082/0.081/0.080um
 err1 = DFM COPY (DFM SPACE GATE_LE_16 LVT_N < 0.082 BY ENC HORIZONTAL) REGION
 err2 = DFM COPY (DFM SPACE GATE_LE_18 LVT_N < 0.081 BY ENC HORIZONTAL) REGION
 err3 = DFM COPY (DFM SPACE GATE_LE_20 LVT_N < 0.080 BY ENC HORIZONTAL) REGION

 err1 NOT INSIDE GT_P96
 err2 NOT INSIDE GT_P96
 err3 NOT INSIDE GT_P96
}

LVT_N_EX_9 {
@ LVT_N extension outside of GATE (when channel length = 0.016/0.018/0.02/0.022/0.024um, INSIDE GT_P96) in S/D direction >= 0.088/0.087/0.086/0.085/0.084um
 err1 = (DFM COPY (DFM SPACE GATE_LE_16 LVT_N < 0.088 BY ENC HORIZONTAL) REGION) NOT OUTSIDE GT_P96
 err2 = (DFM COPY (DFM SPACE GATE_LE_18 LVT_N < 0.087 BY ENC HORIZONTAL) REGION) NOT OUTSIDE GT_P96
 err3 = (DFM COPY (DFM SPACE GATE_LE_20 LVT_N < 0.086 BY ENC HORIZONTAL) REGION) NOT OUTSIDE GT_P96
 err4 = (DFM COPY (DFM SPACE GATE_LE_22 LVT_N < 0.085 BY ENC HORIZONTAL) REGION) NOT OUTSIDE GT_P96
 err5 = (DFM COPY (DFM SPACE GATE_LE_24 LVT_N < 0.084 BY ENC HORIZONTAL) REGION) NOT OUTSIDE GT_P96

 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
 err4 NOT INSIDE SealR_NOT_BULK
 err5 NOT INSIDE SealR_NOT_BULK
}

LVT_N_EX_10 {
@ LVT_N (line-end vertical width <= 0.238um between two consecutive 90-90 degree corners with both sides length >= 0.09um) enclosure of ((GT AND GTMK1) OR GATE) in S/D direction >= 0.079um
 check_RAW = CONVEX EDGE LVT_N ANGLE1 == 90 LENGTH1 >= 0.09 ANGLE2 == 90 LENGTH2 >= 0.09 WITH LENGTH <= 0.238
 check_TMP = ANGLE check_RAW == 90
 err1 = ENC (OR GATE_raw GT_and_GTMK1) check_TMP < 0.079 ABUT<90 OPPOSITE REGION  //;including edge GATE
 err1 NOT INSIDE SealR_NOT_BULK
}

LVT_N_EX_11 {
@ LVT_N extension outside of (ALL_GT NOT P2) in GATE poly direction with adjacent horizontal enclosure <= 0.04um by LVT_N vertical edge (edge length = 0.073~0.150um,
@ between two consecutive 90-270 degree corners) >= 0.054um
 y1 = ENC [ALL_GT_NOT_P2] LVT_N_convex_90_270_eqgt_073_lteq_150_v_edges <= 0.040 ABUT<90 OPPOSITE
 y2 = INT [LVT_N_h_edges] LVT_N_convex_90_270_eqgt_073_lteq_150_v_edges < 0.005 ABUT==90 INTERSECTING ONLY
 y3 = LVT_N_h_edges TOUCH EDGE y2
 y4 = ENC ALL_GT_NOT_P2 y3 < 0.054 ABUT<90 OPPOSITE REGION
 y5 = EXPAND EDGE y1 INSIDE BY 0.005 EXTEND BY 0.005
 err1 = y4 INTERACT y5
 err1 NOT INSIDE SealR_NOT_BULK
}

LVT_N_in_ALL_GT_h_edges = ANGLE (LVT_N NOT OUTSIDE EDGE ALL_GT) == 0
LVT_N_in_all_GT_in_ar_gtmk1_edges = LVT_N NOT OUTSIDE EDGE all_GT_in_ar_gtmk1
LVT_N_in_all_GT_in_ar_gtmk1_area = INT LVT_N_in_all_GT_in_ar_gtmk1_edges < 0.005 ABUT INTERSECTING ONLY REGION

LVT_N_EX_12 {
@ (ALL_GT NOT P2) extension outside of LVT_N, except small ALL_GT jogs <= 0.004um, Dummy_Cell_WO_IMP, and LVT_N vertical edge CUT (GTMK1 OR AR) (channel length <= 0.024um, centerline abut LVT_N vertical edge) >= 0.083um
//;Only need to check the vertical extension.
 y1 = LVT_N_in_all_GT_in_ar_gtmk1_edges COIN EDGE all_GT_center_even
 y2 = ANGLE (LVT_N_in_all_GT_in_ar_gtmk1_edges TOUCH EDGE (LVT_N_in_all_GT_in_ar_gtmk1_area WITH EDGE (LVT_N_in_all_GT_in_ar_gtmk1_area COIN EDGE y1))) == 0
 y3 = LVT_N_in_ALL_GT_h_edges NOT COIN EDGE y2
 err1 = ENC y3 ALL_GT_NOT_P2_not_jog_lteq_004 < 0.083 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE Dummy_Cell_WO_IMP
}

LVT_N_O_1 {
@ Overlap of (ALL_GT NOT P2) and LVT_N, except small ALL_GT jogs <= 0.004um, Dummy_Cell_WO_IMP, and LVT_N vertical edge CUT (GTMK1 OR AR) (channel length <= 0.024um, centerline abut LVT_N vertical edge) >= 0.083um
//;Only need to check the vertical overlap.
 y1 = LVT_N_in_all_GT_in_ar_gtmk1_edges COIN EDGE all_GT_center_even
 y2 = ANGLE (LVT_N_in_all_GT_in_ar_gtmk1_edges TOUCH EDGE (LVT_N_in_all_GT_in_ar_gtmk1_area WITH EDGE (LVT_N_in_all_GT_in_ar_gtmk1_area COIN EDGE y1))) == 0
 y3 = LVT_N_in_ALL_GT_h_edges NOT COIN EDGE y2
 err1 = INT y3 ALL_GT_NOT_P2_not_jog_lteq_004 < 0.083 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE Dummy_Cell_WO_IMP
}

LVT_N_A_1 {
@ LVT_N area >= 0.085um2
 err1 = AREA LVT_N < VT_MiniArea
 err1 NOT INSIDE SealR_NOT_BULK
}

LVT_N_A_2 {
@ LVT_N enclosed area >= 0.085um2
 err1 = AREA ((HOLES LVT_N INNER SINGULAR ALSO) NOT LVT_N) < VT_MiniArea
 err1 NOT INSIDE SealR_NOT_BULK
}

LVT_N_A_3 {
@ Area of ((ALL_GT NOT P2) AND LVT_N) >= 0.00158um2
 err1 = AREA (ALL_GT_NOT_P2 AND LVT_N) < 0.00158
 err1 NOT INSIDE SealR_NOT_BULK
}

LVT_N_R_1 {
@ (ALL_AA interact GT (width >= 0.032um)) CUT LVT_N is not allowed
 err1 = ALL_AA_INTERACT_GT_eqgt_032 CUT LVT_N
 err1 NOT INSIDE SealR_NOT_BULK
}

LVT_N_R_2 {
@ LVT_N overlap with P+AA, SVT_N, SVT_P, HVT_N, HVT_P, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, DG, PSUB, INST, RESNW, VARMOS, DMPNP, MARKS is not allowed, exclude OCCD region
 err1 = LVT_N AND (OR PACT SVT_N SVT_P HVT_N HVT_P LVT_P LFN_N LFN_P ULVT_N ULVT_P DG PSUB INST RESNW VARMOS DMPNP MARKS)
 err1 NOT INSIDE OCCD
}

LVT_N_R_3 {
@ (ALL_AA NOT AR) straddle on LVT_P horizontal edge is not allowed
 err1 = LVT_N_h_edges COIN EDGE ((LVT_N CUT ALL_AA_NOT_AR) INSIDE EDGE ALL_AA_NOT_AR)
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

// =======================================================
// LVT_P: P-type Low Vt MOS design rules
// =======================================================

GROUP GLVT_P LVT_P_?

LVT_P_W_1 {
@ LVT_P width, single-point-interaction is allowed >= 0.192um
@ DRC waive:
@ 1) LVT_P one-track width within the range of 0.09~0.106um, 0.18~0.212um when PRL = 0um
@ 2) Jog width adjacent to edge (length <= 0.048um, between two consecutive 90-270 degree corners) = 0.18um in S/D direction
@ 3) Jog width adjacent to edge (length = 0.002um, between two consecutive 90-270 degree corners) = 0.135/0.144um in S/D direction
 y1 = INT [LVT_P] < 0.192 ABUT<90 OPPOSITE EXTENDED 0.001
 y2 = INT [LVT_P] < 0.192 CORNER
 y3 = INT [LVT_P_v_edges] >= 0.09 < 0.107 PROJ == 0
 y4 = INT [LVT_P_v_edges] >= 0.18 < 0.213 PROJ == 0
 y5 = INT [LVT_P_h_edges] >= 0.09 < 0.107 PROJ == 0
 y6 = INT [LVT_P_h_edges] >= 0.18 < 0.213 PROJ == 0
 y_all = (y3 OR EDGE y4) OR EDGE (y5 OR EDGE y6)

 waive_edges = LVT_P_90_90_jog_180_135_144 COIN EDGE LVT_P_h_edges
 waive_corner = INT [LVT_P_v_edges] waive_edges < 0.001 ABUT==90 INTERSECTING ONLY
 err1 = (y1 NOT COIN EDGE y_all) NOT TOUCH EDGE waive_corner
 err2 = (y2 COIN EDGE LVT_P_concave_corner) NOT TOUCH EDGE y_all
 err1 NOT INSIDE EDGE SealR_NOT_BULK
 err2 NOT INSIDE EDGE SealR_NOT_BULK
}

LVT_P_W_2 {
@ LVT_P width in S/D direction, single-point-interaction is allowed >= 0.27um
@ DRC waive:
@ 1) LVT_P one-track width within the range of 0.09~0.106um, 0.18~0.212um when PRL = 0um
@ 2) Jog width adjacent to edge (length <= 0.048um, between two consecutive 90-270 degree corners) = 0.18/0.192/0.225/0.24um in S/D direction
@ 3) Jog width adjacent to edge (length = 0.002um, between two consecutive 90-270 degree corners) = 0.135/0.144um in S/D direction
 y1 = INT [LVT_P_v_edges] < 0.27 ABUT<90 OPPOSITE EXTENDED 0.001
 y2 = INT [LVT_P_v_edges] >= 0.09 < 0.107 PROJ == 0
 y3 = INT [LVT_P_v_edges] >= 0.18 < 0.213 PROJ == 0
 y_all = y2 OR EDGE y3

 waive_corner = INT [LVT_P_v_edges] LVT_P_90_90_jog_180_192_225_240_135_144_h_edges < 0.001 ABUT==90 INTERSECTING ONLY
 err1 = (y1 NOT COIN EDGE y_all) NOT TOUCH EDGE waive_corner
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

LVT_P_W_3 {
@ LVT_P width in S/D direction when just one LVT_P vertical edge CUT (GTMK1 OR AR) and ABUT SVT_P or HVT_P >= 0.315um
@ DRC waive:
@ 1) Jog width adjacent to edge (length <= 0.048um, between two consecutive 90-270 degree corners) = 0.18/0.192/0.225/0.24um in S/D direction
@ 2) Jog width adjacent to edge (length = 0.002um, between two consecutive 90-270 degree corners) = 0.135/0.144um in S/D direction
 y1 = ((LVT_P_v_edges INSIDE EDGE gtmk1_or_ar) COIN EDGE SVT_P) OR EDGE ((LVT_P_v_edges INSIDE EDGE gtmk1_or_ar) COIN EDGE HVT_P)
 y2 = LVT_P_v_edges TOUCH EDGE y1

 waive_corner = INT LVT_P_v_edges LVT_P_90_90_jog_180_192_225_240_135_144_h_edges <= 0.001 ABUT==90 INTERSECTING ONLY REGION
 check_corner = LVT_P_v_edges NOT TOUCH EDGE waive_corner
 err1 = INT y2 check_corner < 0.315 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

LVT_P_W_3a {
@ LVT_P width in S/D direction when both LVT_P vertical edge CUT (GTMK1 OR AR) and ABUT SVT_P or HVT_P >= 0.36um
@ DRC waive:
@ 1) Jog width adjacent to edge (length <= 0.048um, between two consecutive 90-270 degree corners) = 0.18/0.192/0.225/0.24um in S/D direction
@ 2) Jog width adjacent to edge (length = 0.002um, between two consecutive 90-270 degree corners) = 0.135/0.144um in S/D direction
 y1 = ((LVT_P_v_edges INSIDE EDGE gtmk1_or_ar) COIN EDGE SVT_P) OR EDGE ((LVT_P_v_edges INSIDE EDGE gtmk1_or_ar) COIN EDGE HVT_P)
 y2 = LVT_P_v_edges TOUCH EDGE y1

 waive_corner = INT LVT_P_v_edges LVT_P_90_90_jog_180_192_225_240_135_144_h_edges <= 0.001 ABUT==90 INTERSECTING ONLY REGION
 check_corner = (LVT_P_v_edges NOT TOUCH EDGE waive_corner) TOUCH EDGE y1
 err1 = INT y2 check_corner < 0.360 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

LVT_P_W_4 {
@ LVT_P width in GATE poly direction when LVT_P point touch or horizontal width in the range of 0.09~0.106um, 0.18~0.212um while PRL = 0um in GATE poly direction (except L-shape/T-shape concave corner) >= 0.238um
 err1 = INT (LVT_P_h_edges_singular_point COIN EDGE LVT_P_concave_corner) LVT_P_h_edges < 0.238 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK

 y1 = LVT_P_convex_eqlt_1_edges COIN EDGE LVT_P_h_edges
 y2 = LVT_P COIN EDGE (EXPAND EDGE (y1 COIN EDGE LVT_P_concave_corner) INSIDE BY 0.001 OUTSIDE BY 0.001)
 y3 = INT [y2] >= 0.09 <= 0.106+0.0005 ABUT<90 PROJ == 0
 y4 = INT [y2] >= 0.18 <= 0.212+0.0005 ABUT<90 PROJ == 0
 y5 = LVT_P_concave_corner WITH EDGE (LVT_P_concave_corner COIN EDGE (y3 OR EDGE y4))
 y6 = LVT_P_h_edges COIN EDGE y5
 err2 = INT LVT_P_h_edges y6 < 0.238 ABUT<90 OPPOSITE REGION
 err3 = (LENGTH ((LVT_P_v_edges TOUCH EDGE y5) TOUCH EDGE LVT_P_convex_eq_1_edges) < 0.238) EXPAND EDGE INSIDE BY 0.001
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
}

LVT_P_S_1 {
@ Space between LVT_P, single-point-interaction is allowed >= 0.192um
@ DRC waive:
@ 1) LVT_P one-track space within the range of 0.09~0.106um, 0.18~0.212um when PRL = 0um
@ 2) Jog space adjacent to edge (length <= 0.048um, between two consecutive 90-270 degree corners) = 0.18um in S/D direction
@ 3) Jog space adjacent to edge (length = 0.002um, between two consecutive 90-270 degree corners) = 0.135/0.144um in S/D direction
 y1 = EXT [LVT_P] < 0.192 ABUT<90 OPPOSITE EXTENDED 0.001
 y2 = EXT [LVT_P] < 0.192 CORNER
 y3 = EXT [LVT_P_v_edges] >= 0.09 < 0.107 PROJ == 0
 y4 = EXT [LVT_P_v_edges] >= 0.18 < 0.213 PROJ == 0
 y5 = EXT [LVT_P_h_edges] >= 0.09 < 0.107 PROJ == 0
 y6 = EXT [LVT_P_h_edges] >= 0.18 < 0.213 PROJ == 0
 y_all = (y3 OR EDGE y4) OR EDGE (y5 OR EDGE y6)
 w_all = LVT_P_rvs_90_90_jog_180_135_144 OR EDGE LVT_P_90_90_jog_180_135_144

 z1 = w_all COIN EDGE LVT_P_h_edges
 z2 = LVT_P_rvs COIN EDGE LVT_P_v_edges
 z3 = INT [z2] z1 < 0.005 ABUT==90 INTERSECTING ONLY
 err1 = (y1 NOT COIN EDGE y_all) NOT TOUCH EDGE z3
 err2 = (y2 COIN EDGE LVT_P_convex_corner) NOT COIN EDGE y_all
 err1 NOT INSIDE EDGE SealR_NOT_BULK
 err2 NOT INSIDE EDGE SealR_NOT_BULK
}

LVT_P_S_2 {
@ Space between LVT_P in S/D direction, single-point-interaction is allowed >= 0.27um
@ DRC waive:
@ 1) LVT_P one-track space within the range of 0.09~0.106um, 0.18~0.212um when PRL = 0um
@ 2) Jog space adjacent to edge (length <= 0.048um, between two consecutive 90-270 degree corners) = 0.180/0.192/0.225/0.24um in S/D direction
@ 3) Jog space adjacent to edge (length = 0.002um, between two consecutive 90-270 degree corners) = 0.135/0.144um in S/D direction
 w_all = LVT_P_90_90_jog_180_192_225_240_135_144 OR EDGE LVT_P_rvs_90_90_jog_180_192_225_240_135_144
 y1 = ANGLE (EXT [LVT_P] < 0.27 ABUT<90 OPPOSITE EXTENDED 0.001) == 90
 y2 = EXT [LVT_P_v_edges] >= 0.09 < 0.107 PROJ == 0
 y3 = EXT [LVT_P_v_edges] >= 0.18 < 0.213 PROJ == 0
 y4 = y2 OR EDGE y3

 z1 = ANGLE LVT_P_rvs == 0
 z2 = w_all COIN EDGE z1
 z3 = ANGLE LVT_P_rvs == 90
 z4 = INT [z3] z2 < 0.001 ABUT==90 INTERSECTING ONLY
 err1 = (y1 NOT COIN EDGE y4) NOT TOUCH EDGE z4
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

LVT_P_S_3a {
@ Space between LVT_P in S/D direction when just one LVT_P vertical edge CUT (GTMK1 OR AR), ABUT ULVT_P >= 0.315um
@ DRC waive:
@ 1) Jog space adjacent to edge (length <= 0.048um, between two consecutive 90-270 degree corners) = 0.180/0.192/0.225/0.24um in S/D direction
@ 2) Jog space adjacent to edge (length = 0.002um, between two consecutive 90-270 degree corners) = 0.135/0.144um in S/D direction
 check_edges = LVT_P_inside_AA_side_mark_v_edges TOUCH EDGE ULVT_P
 waive_corner = EXT LVT_P_270_270_jog_180_192_225_240_135_144_h_edges check_edges <= 0.001 ABUT==90 INTERSECTING ONLY REGION
 check_corner = check_edges NOT TOUCH EDGE waive_corner
 err1 = EXT check_corner LVT_P_v_edges < 0.315 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

LVT_P_S_3b {
@ Space between LVT_P in S/D direction when both LVT_P vertical edge CUT (GTMK1 OR AR), ABUT ULVT_P >= 0.36um
@ DRC waive:
@ 1) Jog space adjacent to edge (length <= 0.048um, between two consecutive 90-270 degree corners) = 0.180/0.192/0.225/0.24um in S/D direction
@ 2) Jog space adjacent to edge (length = 0.002um, between two consecutive 90-270 degree corners) = 0.135/0.144um in S/D direction
 check_edges = LVT_P_inside_AA_side_mark_v_edges TOUCH EDGE ULVT_P
 waive_corner = EXT LVT_P_270_270_jog_180_192_225_240_135_144_h_edges check_edges <= 0.001 ABUT==90 INTERSECTING ONLY REGION
 check_corner = check_edges NOT TOUCH EDGE waive_corner
 err1 = EXT check_corner < 0.36 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

LVT_P_S_4 {
@ Space between LVT_P when PRL >= 0.29um. >= 0.248um
 Layer_area = EXT LVT_P < 0.248 OPPOSITE REGION
 err1 = Layer_area ENCLOSE RECTANGLE 0.001 0.29 ORTHOGONAL ONLY
 err1 NOT INSIDE SealR_NOT_BULK
}

LVT_P_S_5 {
@ LVT_P space in GATE poly direction when LVT_P point touch or horizontal width in the range of 0.09~0.106um, 0.18~0.212um while PRL = 0um in GATE poly direction >= 0.238um
 err1 = EXT LVT_P_h_edges_singular_point LVT_P_h_edges < 0.238 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK

 y1 = LVT_P_convex_eqlt_1_edges COIN EDGE LVT_P_h_edges
 y2 = LVT_P COIN EDGE (EXPAND EDGE (y1 COIN EDGE LVT_P_concave_corner) INSIDE BY 0.001 OUTSIDE BY 0.001)
 y3 = INT [y2] >= 0.09 <= 0.106+0.0005 ABUT<90 PROJ == 0
 y4 = INT [y2] >= 0.18 <= 0.212+0.0005 ABUT<90 PROJ == 0
 y5 = LVT_P_concave_corner WITH EDGE (LVT_P_concave_corner COIN EDGE (y3 OR EDGE y4))
 y6 = LVT_P_h_edges TOUCH EDGE y5
 err2 = EXT LVT_P_h_edges y6 < 0.238 ABUT<90 OPPOSITE REGION
 err3 = (LENGTH ((LVT_P_v_edges TOUCH EDGE y5) TOUCH EDGE LVT_P_convex_eq_0_edges) < 0.238) EXPAND EDGE INSIDE BY 0.002
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
}

LVT_P_S_6 {
@ Space between LVT_P and ALL_AA (vertical edge abut AA edge is allowed) >= 0.045um
 CHECK_RAW = EXT LVT_P ALL_AA < 0.045 ABUT<90 SINGULAR
 WAIVE_CRN = LVT_P COIN OUTSIDE EDGE ALL_AA_v_edges
 err1 = DFM COPY (DFM PROPERTY CHECK_RAW WAIVE_CRN ABUT ALSO OVERLAP MULTI SPLIT [-= count(WAIVE_CRN)] == 0) REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

LVT_P_S_6a {
@ Space between LVT_P and ALL_AA in GATE poly direction >= 0.048um
 err1 = EXT LVT_P ALL_AA_h_edges < 0.048 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

LVT_P_S_7 {
@ Space between LVT_P and (ALL_GT NOT P2) (ALL_GT width < 0.07um), except small ALL_GT jogs <= 0.004um. >= 0.024um
 err1 = EXT LVT_P ALL_GT_NOT_P2_not_jog_lteq_004 < 0.024 ABUT<90 REGION MEASURE ALL  //;minimum
 err1 NOT INSIDE SealR_NOT_BULK
}

LVT_P_S_7a {
@ Space between LVT_P and (ALL_GT NOT P2) (ALL_GT width >= 0.07um) >= 0.034um
 err1 = EXT LVT_P (ALL_GT_eqgt_070 NOT P2) < 0.034 ABUT<90 SINGULAR REGION MEASURE ALL
 err1 NOT INSIDE SealR_NOT_BULK
}

LVT_P_S_7b {
@ Space between LVT_P and (ALL_GT NOT P2) (ALL_GT width > 0.09um) >= 0.058um
 err1 = EXT LVT_P ALL_GT_NOT_P2_gt_090 < 0.058 ABUT<90 SINGULAR REGION MEASURE ALL
 err1 NOT INSIDE SealR_NOT_BULK
}

LVT_P_S_8 {
@ Space between LVT_P and (ALL_GT NOT P2) (ALL_GT width < 0.07um) in S/D direction >= 0.035um
 err1 = EXT ALL_GT_NOT_P2 LVT_P_v_edges < 0.035 ABUT<90 OPPOSITE REGION //;minimum
 err1 NOT INSIDE SealR_NOT_BULK
}

LVT_P_S_8a {
@ Space between LVT_P and (ALL_GT NOT P2) (ALL_GT width >= 0.07um) in S/D direction >= 0.058um
 err1 = EXT LVT_P_v_edges ALL_GT_NOT_P2_eqgt_070 < 0.058 ABUT<90 OPPOSITE REGION MEASURE ALL
 err1 NOT INSIDE SealR_NOT_BULK
}

LVT_P_S_9a {
@ Space between LVT_P and GATE (when channel length = 0.016/0.018/0.02um) respectively in S/D direction, (GATE CUT LVT_P is not allowed), except GT_P96 region >= 0.082/0.081/0.08um
 err1 = DFM COPY (DFM SPACE GATE_LE_16 LVT_P < 0.082 BY EXT HORIZONTAL MEASURE ALL) REGION
 err2 = DFM COPY (DFM SPACE GATE_LE_18 LVT_P < 0.081 BY EXT HORIZONTAL MEASURE ALL) REGION
 err3 = DFM COPY (DFM SPACE GATE_LE_20 LVT_P < 0.080 BY EXT HORIZONTAL MEASURE ALL) REGION
 err4 = GATE CUT LVT_P

 err1 NOT INSIDE (OR GT_P96 SealR_NOT_BULK)
 err2 NOT INSIDE (OR GT_P96 SealR_NOT_BULK)
 err3 NOT INSIDE (OR GT_P96 SealR_NOT_BULK)
 err4 NOT INSIDE (OR GT_P96 SealR_NOT_BULK)
}

LVT_P_S_9b {
@ Space between LVT_P and to GATE (when channel length = 0.016/0.018/0.02/0.022/0.024um, INSIDE GT_P96) in S/D direction (GATE CUT LVT_P is not allowed) >= 0.088/0.087/0.086/0.085/0.084um
 err1 = DFM COPY (DFM SPACE GATE_LE_16_in_GT_P96 LVT_P < 0.088 BY EXT HORIZONTAL MEASURE ALL) REGION
 err2 = DFM COPY (DFM SPACE GATE_LE_18_in_GT_P96 LVT_P < 0.087 BY EXT HORIZONTAL MEASURE ALL) REGION
 err3 = DFM COPY (DFM SPACE GATE_LE_20_in_GT_P96 LVT_P < 0.086 BY EXT HORIZONTAL MEASURE ALL) REGION
 err4 = DFM COPY (DFM SPACE GATE_LE_22_in_GT_P96 LVT_P < 0.085 BY EXT HORIZONTAL MEASURE ALL) REGION
 err5 = DFM COPY (DFM SPACE GATE_LE_24_in_GT_P96 LVT_P < 0.084 BY EXT HORIZONTAL MEASURE ALL) REGION
 err6 = GATE CUT LVT_P

 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
 err4 NOT INSIDE SealR_NOT_BULK
 err5 NOT INSIDE SealR_NOT_BULK
 err6 NOT INSIDE SealR_NOT_BULK
}

LVT_P_S_10 {
@ Space between LVT_P vertical edge (edge length <= 0.238um between two concave corners with both sides length >= 0.09um) and ((GT AND GTMK1) OR GATE) in S/D direction >= 0.079um
 check_RAW = CONVEX EDGE LVT_P ANGLE1 == 270 LENGTH1 >= 0.09 ANGLE2 == 270 LENGTH2 >= 0.09 WITH LENGTH <= 0.238
 check_TMP = ANGLE check_RAW == 90
 err1 = EXT (OR GATE_raw GT_and_GTMK1) check_TMP < 0.079 ABUT<90 OPPOSITE REGION  //;including edge GATE
 err1 NOT INSIDE SealR_NOT_BULK
}

LVT_P_S_11 {
@ Space between LVT_P and (ALL_GT NOT P2) in GATE poly direction with adjacent horizontal space <= 0.04um (LVT_P vertical edge length = 0.073~0.15um, between two consecutive 90-270 degree coners) >= 0.054um
 y1 = EXT [ALL_GT_NOT_P2] LVT_P_convex_90_270_eqgt_073_lteq_150_v_edges <= 0.040 ABUT<90 OPPOSITE
 y2 = EXT [LVT_P_h_edges] LVT_P_convex_90_270_eqgt_073_lteq_150_v_edges < 0.005 ABUT==90 INTERSECTING ONLY

 z1 = LVT_P_h_edges TOUCH EDGE y2
 z2 = EXT ALL_GT_NOT_P2 z1 < 0.054 ABUT<90 OPPOSITE REGION
 z3 = EXPAND EDGE y1 INSIDE BY 0.005 EXTEND BY 0.005
 err1 = z2 INTERACT z3
 err1 NOT INSIDE SealR_NOT_BULK
}

LVT_P_EX_1 {
@ LVT_P extension outside of ALL_AA (vertical edge abut AA edge is allowed) >= 0.045um
 CHECK_RAW = ENC ALL_AA LVT_P < 0.045 ABUT<90 SINGULAR
 WAIVE_CRN = LVT_P COIN INSIDE EDGE ALL_AA_v_edges
 err1 = DFM COPY (DFM PROPERTY CHECK_RAW WAIVE_CRN ABUT ALSO OVERLAP MULTI SPLIT [-= count(WAIVE_CRN)] == 0) REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

LVT_P_EX_2 {
@ LVT_P extension outside of ALL_AA in GATE poly direction >= 0.048um
 err1 = ENC ALL_AA_h_edges LVT_P < 0.048 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

LVT_P_EX_3 {
@ LVT_P extension outside of (ALL_GT NOT P2) (ALL_GT width < 0.07um), except small ALL_GT jog <= 0.004um. >= 0.024um
 err1 = ENC ALL_GT_NOT_P2_not_jog_lteq_004 LVT_P < 0.024 ABUT<90 OPPOSITE REGION  //;minimum
 err1 NOT INSIDE SealR_NOT_BULK
}

LVT_P_EX_4 {
@ LVT_P extension outside of (ALL_GT NOT P2) (ALL_GT width >= 0.07um) >= 0.034um
 err1 = ENC ALL_GT_NOT_P2_eqgt_070 LVT_P < 0.034 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

LVT_P_EX_5 {
@ LVT_P extension outside of (ALL_GT NOT P2) (ALL_GT width > 0.09um) >= 0.058um
 err1 = ENC ALL_GT_NOT_P2_gt_090 LVT_P < 0.058 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

LVT_P_EX_6 {
@ LVT_P extension outside of (ALL_GT NOT P2) (ALL_GT width < 0.07um) in S/D direction >= 0.035um
 err1 = ENC ALL_GT_NOT_P2 LVT_P_v_edges < 0.035 ABUT<90 OPPOSITE REGION //;minimum
 err1 NOT INSIDE SealR_NOT_BULK
}

LVT_P_EX_7 {
@ LVT_P extension outside of (ALL_GT NOT P2) (ALL_GT width >= 0.07um) in S/D direction >= 0.058um
 err1 = ENC ALL_GT_NOT_P2_eqgt_070 LVT_P_v_edges < 0.058 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

LVT_P_EX_8 {
@ LVT_P extension outside of GATE (when channel length = 0.016/0.018/0.02um) respectively in S/D direction, except GT_P96 region >= 0.082/0.081/0.080um
 err1 = DFM COPY (DFM SPACE GATE_LE_16 LVT_P < 0.082 BY ENC HORIZONTAL) REGION
 err2 = DFM COPY (DFM SPACE GATE_LE_18 LVT_P < 0.081 BY ENC HORIZONTAL) REGION
 err3 = DFM COPY (DFM SPACE GATE_LE_20 LVT_P < 0.080 BY ENC HORIZONTAL) REGION

 err1 NOT INSIDE (OR GT_P96 SealR_NOT_BULK)
 err2 NOT INSIDE (OR GT_P96 SealR_NOT_BULK)
 err3 NOT INSIDE (OR GT_P96 SealR_NOT_BULK)
}

LVT_P_EX_9 {
@ LVT_P extension outside of GATE (when channel length = 0.016/0.018/0.02/0.022/0.024um, INSIDE GT_P96) in S/D direction >= 0.088/0.087/0.086/0.085/0.084um
 err1 = (DFM COPY (DFM SPACE GATE_LE_16 LVT_P < 0.088 BY ENC HORIZONTAL) REGION) NOT OUTSIDE GT_P96
 err2 = (DFM COPY (DFM SPACE GATE_LE_18 LVT_P < 0.087 BY ENC HORIZONTAL) REGION) NOT OUTSIDE GT_P96
 err3 = (DFM COPY (DFM SPACE GATE_LE_20 LVT_P < 0.086 BY ENC HORIZONTAL) REGION) NOT OUTSIDE GT_P96
 err4 = (DFM COPY (DFM SPACE GATE_LE_22 LVT_P < 0.085 BY ENC HORIZONTAL) REGION) NOT OUTSIDE GT_P96
 err5 = (DFM COPY (DFM SPACE GATE_LE_24 LVT_P < 0.084 BY ENC HORIZONTAL) REGION) NOT OUTSIDE GT_P96

 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
 err4 NOT INSIDE SealR_NOT_BULK
 err5 NOT INSIDE SealR_NOT_BULK
}

LVT_P_EX_10 {
@ LVT_P (line-end vertical width <= 0.238um between two consecutive 90-90 degree corners with both sides length >= 0.09um) enclosure of ((GT AND GTMK1) OR GATE) in S/D direction >= 0.079um
 check_RAW = CONVEX EDGE LVT_P ANGLE1 == 90 LENGTH1 >= 0.09 ANGLE2 == 90 LENGTH2 >= 0.09 WITH LENGTH <= 0.238
 check_TMP = ANGLE check_RAW == 90
 err1 = ENC (OR GATE_raw GT_and_GTMK1) check_TMP < 0.079 ABUT<90 OPPOSITE REGION  //;including edge GATE
 err1 NOT INSIDE SealR_NOT_BULK
}

LVT_P_EX_11 {
@ LVT_P extension outside of (ALL_GT NOT P2) in GATE poly direction with adjacent enclosure <= 0.04um by LVT_P vertical edge (edge length = 0.073~0.150um,
@ between two consecutive 90-270 degree corners) >= 0.054um
 y1 = ENC [ALL_GT_NOT_P2] LVT_P_convex_90_270_eqgt_073_lteq_150_v_edges <= 0.040 ABUT<90 OPPOSITE
 y2 = INT [LVT_P_h_edges] LVT_P_convex_90_270_eqgt_073_lteq_150_v_edges < 0.005 ABUT==90 INTERSECTING ONLY
 y3 = LVT_P_h_edges TOUCH EDGE y2
 y4 = ENC ALL_GT_NOT_P2 y3 < 0.054 ABUT<90 OPPOSITE REGION
 y5 = EXPAND EDGE y1 INSIDE BY 0.005 EXTEND BY 0.005
 err1 = y4 INTERACT y5
 err1 NOT INSIDE SealR_NOT_BULK
}

LVT_P_in_ALL_GT_h_edges = ANGLE (LVT_P NOT OUTSIDE EDGE ALL_GT) == 0
LVT_P_in_all_GT_in_ar_gtmk1_edges = LVT_P NOT OUTSIDE EDGE all_GT_in_ar_gtmk1
LVT_P_in_all_GT_in_ar_gtmk1_area = INT LVT_P_in_all_GT_in_ar_gtmk1_edges < 0.005 ABUT INTERSECTING ONLY REGION

LVT_P_EX_12 {
@ (ALL_GT NOT P2) extension outside of LVT_P, except small ALL_GT jogs <= 0.004um, Dummy_Cell_WO_IMP, and LVT_P vertical edge CUT (GTMK1 OR AR) (channel length <= 0.024um, centerline abut LVT_P vertical edge) >= 0.083um
//;Only need to check the vertical extension.
 y1 = LVT_P_in_all_GT_in_ar_gtmk1_edges COIN EDGE all_GT_center_even
 y2 = ANGLE (LVT_P_in_all_GT_in_ar_gtmk1_edges TOUCH EDGE (LVT_P_in_all_GT_in_ar_gtmk1_area WITH EDGE (LVT_P_in_all_GT_in_ar_gtmk1_area COIN EDGE y1))) == 0
 y3 = LVT_P_in_ALL_GT_h_edges NOT COIN EDGE y2
 err1 = ENC y3 ALL_GT_NOT_P2_not_jog_lteq_004 < 0.083 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE Dummy_Cell_WO_IMP
}

LVT_P_O_1 {
@ Overlap of (ALL_GT NOT P2) and LVT_P, except small ALL_GT jogs <= 0.004um, Dummy_Cell_WO_IMP, and LVT_P vertical edge CUT (GTMK1 OR AR) (channel length <= 0.024um, centerline abut LVT_P vertical edge) >= 0.083um
//;Only need to check the vertical overlap.
 y1 = LVT_P_in_all_GT_in_ar_gtmk1_edges COIN EDGE all_GT_center_even
 y2 = ANGLE (LVT_P_in_all_GT_in_ar_gtmk1_edges TOUCH EDGE (LVT_P_in_all_GT_in_ar_gtmk1_area WITH EDGE (LVT_P_in_all_GT_in_ar_gtmk1_area COIN EDGE y1))) == 0
 y3 = LVT_P_in_ALL_GT_h_edges NOT COIN EDGE y2
 err1 = INT y3 ALL_GT_NOT_P2_not_jog_lteq_004 < 0.083 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE Dummy_Cell_WO_IMP
}

LVT_P_A_1 {
@ LVT_P area >= 0.085um2
 err1 = AREA LVT_P < VT_MiniArea
 err1 NOT INSIDE SealR_NOT_BULK
}

LVT_P_A_2 {
@ LVT_P enclosed area >= 0.085um2
 err1 = AREA ((HOLES LVT_P INNER SINGULAR ALSO) NOT LVT_P) < VT_MiniArea
 err1 NOT INSIDE SealR_NOT_BULK
}

LVT_P_A_3 {
@ Area of ((ALL_GT NOT P2) AND LVT_P) >= 0.00158um2
 err1 = AREA (ALL_GT_NOT_P2 AND LVT_P) < 0.00158
 err1 NOT INSIDE SealR_NOT_BULK
}

LVT_P_R_1 {
@ (ALL_AA interact GT (width >= 0.032um)) CUT LVT_P is not allowed
 err1 = ALL_AA_INTERACT_GT_eqgt_032 CUT LVT_P
 err1 NOT INSIDE SealR_NOT_BULK
}

LVT_P_R_2 {
@ LVT_P overlap with N+AA, SVT_N, SVT_P, HVT_N, HVT_P, LVT_N, ULVT_N, ULVT_P, LFN_N, LFN_P, DG, PSUB, INST, RESNW, VARMOS, DMPNP, MARKS is not allowed, exclude OCCD region
 err1 = LVT_P AND (OR NACT SVT_N SVT_P HVT_N HVT_P LVT_N ULVT_N ULVT_P LFN_N LFN_P DG PSUB INST RESNW VARMOS DMPNP MARKS)
 err1 NOT INSIDE OCCD
}

LVT_P_R_3 {
@ (ALL_AA NOT AR) straddle on LVT_P horizontal edge is not allowed
 err1 = LVT_P_h_edges COIN EDGE ((LVT_P CUT ALL_AA_NOT_AR) INSIDE EDGE ALL_AA_NOT_AR)
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

// =======================================================
// ULVT_N:N type Ultra low Vt MOS design
// =======================================================

GROUP GULVT_N ULVT_N_?

ULVT_N_W_1 {
@ ULVT_N width, single-point-interaction is allowed >= 0.192um
@ DRC waive:
@ 1) ULVT_N one-track width within the range of 0.09~0.106um, 0.18~0.212um when PRL = 0um
@ 2) Jog width adjacent to edge (length <= 0.048um, between two consecutive 90-270 degree corners) = 0.18um in S/D direction
@ 3) Jog width adjacent to edge (length = 0.002um, between two consecutive 90-270 degree corners) = 0.135/0.144um in S/D direction
 y1 = INT [ULVT_N] < 0.192 ABUT<90 OPPOSITE EXTENDED 0.001
 y2 = INT [ULVT_N] < 0.192 CORNER
 y3 = INT [ULVT_N_v_edges] >= 0.09 < 0.107 PROJ == 0
 y4 = INT [ULVT_N_v_edges] >= 0.18 < 0.213 PROJ == 0
 y5 = INT [ULVT_N_h_edges] >= 0.09 < 0.107 PROJ == 0
 y6 = INT [ULVT_N_h_edges] >= 0.18 < 0.213 PROJ == 0
 y_all = (y3 OR EDGE y4) OR EDGE (y5 OR EDGE y6)

 waive_edges = ULVT_N_90_90_jog_180_135_144 COIN EDGE ULVT_N_h_edges
 waive_corner = INT [ULVT_N_v_edges] waive_edges < 0.001 ABUT==90 INTERSECTING ONLY
 err1 = (y1 NOT COIN EDGE y_all) NOT TOUCH EDGE waive_corner
 err2 = (y2 COIN EDGE ULVT_N_concave_corner) NOT TOUCH EDGE y_all
 err1 NOT INSIDE EDGE SealR_NOT_BULK
 err2 NOT INSIDE EDGE SealR_NOT_BULK
}

ULVT_N_W_2 {
@ ULVT_N width in S/D direction, single-point-interaction is allowed >= 0.27um
@ DRC waive:
@ 1) ULVT_N one-track width within the range of 0.09~0.106um, 0.18~0.212um when PRL = 0um
@ 2) Jog width adjacent to edge (length <= 0.048um, between two consecutive 90-270 degree corners) = 0.18/0.192/0.225/0.24um in S/D direction
@ 3) Jog width adjacent to edge (length = 0.002um, between two consecutive 90-270 degree corners) = 0.135/0.144um in S/D direction
 y1 = INT [ULVT_N_v_edges] < 0.27 ABUT<90 OPPOSITE EXTENDED 0.001
 y2 = INT [ULVT_N_v_edges] >= 0.09 < 0.107 PROJ == 0
 y3 = INT [ULVT_N_v_edges] >= 0.18 < 0.213 PROJ == 0
 y_all = y2 OR EDGE y3

 waive_edges = ULVT_N_90_90_jog_180_192_225_240_135_144 COIN EDGE ULVT_N_h_edges
 waive_corner = INT [ULVT_N_v_edges] waive_edges < 0.001 ABUT==90 INTERSECTING ONLY
 err1 = (y1 NOT COIN EDGE y_all) NOT TOUCH EDGE waive_corner
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

ULVT_N_W_3a {
@ ULVT_N width when just one vertical edge CUT (GTMK1 OR AR)) in S/D direction >= 0.315um
@ DRC waive:
@ 1) Jog width adjacent to edge (length <= 0.048um, between two consecutive 90-270 degree corners) = 0.18/0.192/0.225/0.24um in S/D direction
@ 2) Jog width adjacent to edge (length = 0.002um, between two consecutive 90-270 degree corners) = 0.135/0.144um in S/D direction
 check_edges = ULVT_N_v_edges TOUCH EDGE (ULVT_N_v_edges INSIDE EDGE gtmk1_or_ar)
 waive_corner = INT ULVT_N_v_edges ULVT_N_90_90_jog_180_192_225_240_135_144_h_edges <= 0.001 ABUT==90 INTERSECTING ONLY REGION
 check_corner = ULVT_N_v_edges NOT TOUCH EDGE waive_corner
 err1 = INT check_edges check_corner < 0.315 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

ULVT_N_W_3b {
@ ULVT_N width when both vertical ULVT_N edges CUT (GTMK1 OR AR) in S/D direction >= 0.36um
@ DRC waive:
@ 1) Jog width adjacent to edge (length <= 0.048um, between two consecutive 90-270 degree corners) = 0.18/0.192/0.225/0.24um in S/D direction
@ 2) Jog width adjacent to edge (length = 0.002um, between two consecutive 90-270 degree corners) = 0.135/0.144um in S/D direction
 waive_corner = INT ULVT_N_v_edges ULVT_N_90_90_jog_180_192_225_240_135_144_h_edges <= 0.001 ABUT==90 INTERSECTING ONLY REGION
 check_edges = ULVT_N_inside_AA_side_mark_v_edges NOT TOUCH EDGE waive_corner
 err1 = INT check_edges < 0.36 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

ULVT_N_W_4 {
@ ULVT_N width in GATE poly direction when ULVT_N point touch or horizontal width in the range of 0.09~0.106um, 0.18~0.212um while PRL = 0um in GATE poly direction (except L-shape/T-shape concave corner) >= 0.238um
 err1 = INT (ULVT_N_h_edges_singular_point COIN EDGE ULVT_N_concave_corner) ULVT_N_h_edges < 0.238 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK

 y1 = ULVT_N_convex_eqlt_1_edges COIN EDGE ULVT_N_h_edges
 y2 = ULVT_N COIN EDGE (EXPAND EDGE (y1 COIN EDGE ULVT_N_concave_corner) INSIDE BY 0.001 OUTSIDE BY 0.001)
 y3 = INT [y2] >= 0.09 <= 0.106+0.0005 ABUT<90 PROJ == 0
 y4 = INT [y2] >= 0.18 <= 0.212+0.0005 ABUT<90 PROJ == 0
 y5 = ULVT_N_concave_corner WITH EDGE (ULVT_N_concave_corner COIN EDGE (y3 OR EDGE y4))
 y6 = ULVT_N_h_edges COIN EDGE y5
 err2 = INT ULVT_N_h_edges y6 < 0.238 ABUT<90 OPPOSITE REGION
 err3 = (LENGTH ((ULVT_N_v_edges TOUCH EDGE y5) TOUCH EDGE ULVT_N_convex_eq_1_edges) < 0.238) EXPAND EDGE INSIDE BY 0.001
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
}

ULVT_N_S_1 {
@ Space between ULVT_N, single-point-interaction is allowed >= 0.192um
@ DRC waive:
@ 1) ULVT_N one-track space within the range of 0.09~0.106um, 0.18~0.212um when PRL = 0um
@ 2) Jog space adjacent to edge (length <= 0.048um, between two consecutive 90-270 degree corners) = 0.18um in S/D direction
@ 3) Jog space adjacent to edge (length = 0.002um, between two consecutive 90-270 degree corners) = 0.135/0.144um in S/D direction
 y1 = EXT [ULVT_N] < 0.192 ABUT<90 OPPOSITE EXTENDED 0.001
 y2 = EXT [ULVT_N] < 0.192 CORNER
 y3 = EXT [ULVT_N_v_edges] >= 0.09 < 0.107 PROJ == 0
 y4 = EXT [ULVT_N_v_edges] >= 0.18 < 0.213 PROJ == 0
 y5 = EXT [ULVT_N_h_edges] >= 0.09 < 0.107 PROJ == 0
 y6 = EXT [ULVT_N_h_edges] >= 0.18 < 0.213 PROJ == 0
 y_all = (y3 OR EDGE y4) OR EDGE (y5 OR EDGE y6)
 w_all = ULVT_N_rvs_90_90_jog_180_135_144 OR EDGE ULVT_N_90_90_jog_180_135_144

 z1 = w_all COIN EDGE ULVT_N_h_edges
 z2 = ULVT_N_rvs COIN EDGE ULVT_N_v_edges
 z3 = INT [z2] z1 < 0.005 ABUT==90 INTERSECTING ONLY
 err1 = (y1 NOT COIN EDGE y_all) NOT TOUCH EDGE z3
 err2 = (y2 COIN EDGE ULVT_N_convex_corner) NOT COIN EDGE y_all
 err1 NOT INSIDE EDGE SealR_NOT_BULK
 err2 NOT INSIDE EDGE SealR_NOT_BULK
}

ULVT_N_S_2 {
@ Space between ULVT_N in S/D direction, single-point-interaction is allowed >= 0.27um
@ DRC waive:
@ 1) ULVT_N one-track space within the range of 0.09~0.106um, 0.18~0.212um when PRL = 0um
@ 2) Jog space adjacent to edge (length <= 0.048um, between two consecutive 90-270 degree corners) = 0.180/0.192/0.225/0.24um in S/D direction
@ 3) Jog space adjacent to edge (length = 0.002um, between two consecutive 90-270 degree corners) = 0.135/0.144um in S/D direction
 w_all = ULVT_N_90_90_jog_180_192_225_240_135_144 OR EDGE ULVT_N_rvs_90_90_jog_180_192_225_240_135_144
 y1 = ANGLE (EXT [ULVT_N] < 0.27 ABUT<90 OPPOSITE EXTENDED 0.001) == 90
 y2 = EXT [ULVT_N_v_edges] >= 0.09 < 0.107 PROJ == 0
 y3 = EXT [ULVT_N_v_edges] >= 0.18 < 0.213 PROJ == 0
 y4 = y2 OR EDGE y3

 z1 = ANGLE ULVT_N_rvs == 0
 z2 = w_all COIN EDGE z1
 z3 = ANGLE ULVT_N_rvs == 90
 z4 = INT [z3] z2 < 0.001 ABUT==90 INTERSECTING ONLY
 err1 = (y1 NOT COIN EDGE y4) NOT TOUCH EDGE z4
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

ULVT_N_S_4 {
@ Space between ULVT_N when PRL >= 0.29um. >= 0.248um
 Layer_area = EXT ULVT_N < 0.248 OPPOSITE REGION
 err1 = Layer_area ENCLOSE RECTANGLE 0.001 0.29 ORTHOGONAL ONLY
 err1 NOT INSIDE SealR_NOT_BULK
}

ULVT_N_S_5 {
@ Space between ULVT_N in GATE poly direction when ULVT_N point touch or horizontal width in the range of 0.09~0.106um, 0.18~0.212um while PRL = 0um in GATE poly direction >= 0.238um
 err1 = EXT ULVT_N_h_edges_singular_point ULVT_N_h_edges < 0.238 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK

 y1 = ULVT_N_convex_eqlt_1_edges COIN EDGE ULVT_N_h_edges
 y2 = ULVT_N COIN EDGE (EXPAND EDGE (y1 COIN EDGE ULVT_N_concave_corner) INSIDE BY 0.001 OUTSIDE BY 0.001)
 y3 = INT [y2] >= 0.09 <= 0.106+0.0005 ABUT<90 PROJ == 0
 y4 = INT [y2] >= 0.18 <= 0.212+0.0005 ABUT<90 PROJ == 0
 y5 = ULVT_N_concave_corner WITH EDGE (ULVT_N_concave_corner COIN EDGE (y3 OR EDGE y4))
 y6 = ULVT_N_h_edges TOUCH EDGE y5
 err2 = EXT ULVT_N_h_edges y6 < 0.238 ABUT<90 OPPOSITE REGION
 err3 = (LENGTH ((ULVT_N_v_edges TOUCH EDGE y5) TOUCH EDGE ULVT_N_convex_eq_0_edges) < 0.238) EXPAND EDGE INSIDE BY 0.002
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
}

ULVT_N_S_6 {
@ Space between ULVT_N and ALL_AA (vertical edge abut AA edge is allowed) >= 0.045um
 CHECK_RAW = EXT ULVT_N ALL_AA < 0.045 ABUT<90 SINGULAR
 WAIVE_CRN = ULVT_N COIN OUTSIDE EDGE ALL_AA_v_edges
 err1 = DFM COPY (DFM PROPERTY CHECK_RAW WAIVE_CRN ABUT ALSO OVERLAP MULTI SPLIT [-= count(WAIVE_CRN)] == 0) REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

ULVT_N_S_6a {
@ Space between ULVT_N and ALL_AA in GATE poly direction >= 0.048um
 err1 = EXT ULVT_N ALL_AA_h_edges < 0.048 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

ULVT_N_S_7 {
@ Space between ULVT_N and (ALL_GT NOT P2) (ALL_GT width < 0.07um), except small ALL_GT jog <= 0.004um. >= 0.024um
 err1 = EXT ULVT_N ALL_GT_NOT_P2_not_jog_lteq_004 < 0.024 ABUT<90 REGION MEASURE ALL  //;minimum
 err1 NOT INSIDE SealR_NOT_BULK
}

ULVT_N_S_7a {
@ Space between ULVT_N and (ALL_GT NOT P2) (ALL_GT width >= 0.07um) >= 0.034um
 err1 = EXT ULVT_N (ALL_GT_eqgt_070 NOT P2) < 0.034 ABUT<90 SINGULAR REGION MEASURE ALL
 err1 NOT INSIDE SealR_NOT_BULK
}

ULVT_N_S_7b {
@ Space between ULVT_N and (ALL_GT NOT P2) (ALL_GT width > 0.09um) >= 0.058um
 err1 = EXT ULVT_N ALL_GT_NOT_P2_gt_090 < 0.058 ABUT<90 SINGULAR REGION MEASURE ALL
 err1 NOT INSIDE SealR_NOT_BULK
}

ULVT_N_S_8 {
@ Space between ULVT_N and (ALL_GT NOT P2) (ALL_GT width < 0.07um) in S/D direction >= 0.035um
 err1 = EXT ALL_GT_NOT_P2 ULVT_N_v_edges < 0.035 ABUT<90 OPPOSITE REGION //;minimum
 err1 NOT INSIDE SealR_NOT_BULK
}

ULVT_N_S_8a {
@ Space between ULVT_N and (ALL_GT NOT P2) (ALL_GT width >= 0.07um) in S/D direction >= 0.058um
 err1 = EXT ULVT_N_v_edges ALL_GT_NOT_P2_eqgt_070 < 0.058 ABUT<90 OPPOSITE REGION MEASURE ALL
 err1 NOT INSIDE SealR_NOT_BULK
}

ULVT_N_S_9a {
@ Space between ULVT_N and GATE (when channel length = 0.016/0.018/0.02um) respectively in S/D direction (GATE CUT ULVT_N is not allowed), except GT_P96 region >= 0.082/0.081/0.08um
 err1 = DFM COPY (DFM SPACE GATE_LE_16 ULVT_N < 0.082 BY EXT HORIZONTAL MEASURE ALL) REGION
 err2 = DFM COPY (DFM SPACE GATE_LE_18 ULVT_N < 0.081 BY EXT HORIZONTAL MEASURE ALL) REGION
 err3 = DFM COPY (DFM SPACE GATE_LE_20 ULVT_N < 0.080 BY EXT HORIZONTAL MEASURE ALL) REGION
 err4 = GATE CUT ULVT_N

 err1 NOT INSIDE GT_P96
 err2 NOT INSIDE GT_P96
 err3 NOT INSIDE GT_P96
 err4 NOT INSIDE GT_P96
}

ULVT_N_S_9b {
@ Space between ULVT_N and GATE (when channel length = 0.016/0.018/0.02/0.022/0.024um, INSIDE GT_P96) in S/D direction (GATE CUT ULVT_N is not allowed) >= 0.088/0.087/0.086/0.085/0.084um
 err1 = DFM COPY (DFM SPACE GATE_LE_16_in_GT_P96 ULVT_N < 0.088 BY EXT HORIZONTAL MEASURE ALL) REGION
 err2 = DFM COPY (DFM SPACE GATE_LE_18_in_GT_P96 ULVT_N < 0.087 BY EXT HORIZONTAL MEASURE ALL) REGION
 err3 = DFM COPY (DFM SPACE GATE_LE_20_in_GT_P96 ULVT_N < 0.086 BY EXT HORIZONTAL MEASURE ALL) REGION
 err4 = DFM COPY (DFM SPACE GATE_LE_22_in_GT_P96 ULVT_N < 0.085 BY EXT HORIZONTAL MEASURE ALL) REGION
 err5 = DFM COPY (DFM SPACE GATE_LE_24_in_GT_P96 ULVT_N < 0.084 BY EXT HORIZONTAL MEASURE ALL) REGION
 err6 = GATE CUT ULVT_N

 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
 err4 NOT INSIDE SealR_NOT_BULK
 err5 NOT INSIDE SealR_NOT_BULK
 err6 NOT INSIDE SealR_NOT_BULK
}

ULVT_N_S_10 {
@ Space between ULVT_N vertical edge (edge length <= 0.238um between two concave corners with both sides length >= 0.09um) and ((GT AND GTMK1) OR GATE) in S/D direction >= 0.079um
 check_RAW = CONVEX EDGE ULVT_N ANGLE1 == 270 LENGTH1 >= 0.09 ANGLE2 == 270 LENGTH2 >= 0.09 WITH LENGTH <= 0.238
 check_TMP = ANGLE check_RAW == 90
 err1 = EXT (OR GATE_raw GT_and_GTMK1) check_TMP < 0.079 ABUT<90 OPPOSITE REGION  //;including edge GATE
 err1 NOT INSIDE SealR_NOT_BULK
}

ULVT_N_S_11 {
@ Space between ULVT_N and (ALL_GT NOT P2) in GATE poly direction with adjacent horizontal space <= 0.040um (ULVT_N vertical edge length = 0.073~0.15um, between two consecutive 90-270 degree coners) >= 0.054um
 y1 = EXT [ALL_GT_NOT_P2] ULVT_N_convex_90_270_eqgt_073_lteq_150_v_edges <= 0.040 ABUT<90 OPPOSITE
 y2 = EXT [ULVT_N_h_edges] ULVT_N_convex_90_270_eqgt_073_lteq_150_v_edges < 0.005 ABUT==90 INTERSECTING ONLY

 z1 = ULVT_N_h_edges TOUCH EDGE y2
 z2 = EXT ALL_GT_NOT_P2 z1 < 0.054 ABUT<90 OPPOSITE REGION
 z3 = EXPAND EDGE y1 INSIDE BY 0.005 EXTEND BY 0.005
 err1 = z2 INTERACT z3
 err1 NOT INSIDE SealR_NOT_BULK
}

ULVT_N_EX_1 {
@ ULVT_N extension outside of ALL_AA (vertical edge abut AA edge is allowed) >= 0.045um
 CHECK_RAW = ENC ALL_AA ULVT_N < 0.045 ABUT<90 SINGULAR
 WAIVE_CRN = ULVT_N COIN INSIDE EDGE ALL_AA_v_edges
 err1 = DFM COPY (DFM PROPERTY CHECK_RAW WAIVE_CRN ABUT ALSO OVERLAP MULTI SPLIT [-= count(WAIVE_CRN)] == 0) REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

ULVT_N_EX_2 {
@ ULVT_N extension outside of ALL_AA in GATE poly direction >= 0.048um
 err1 = ENC ALL_AA_h_edges ULVT_N < 0.048 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

ULVT_N_EX_3 {
@ ULVT_N extension outside of (ALL_GT NOT P2) (ALL_GT width < 0.07um), except small ALL_GT jog <= 0.004um. >= 0.024um
 err1 = ENC ALL_GT_NOT_P2_not_jog_lteq_004 ULVT_N < 0.024 ABUT<90 OPPOSITE REGION  //;minimum
 err1 NOT INSIDE SealR_NOT_BULK
}

ULVT_N_EX_4 {
@ ULVT_N extension outside of (ALL_GT NOT P2) (ALL_GT width >= 0.07um) >= 0.034um
 err1 = ENC ALL_GT_NOT_P2_eqgt_070 ULVT_N < 0.034 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

ULVT_N_EX_5 {
@ ULVT_N extension outside of (ALL_GT NOT P2) (ALL_GT width > 0.09um) >= 0.058um
 err1 = ENC ALL_GT_NOT_P2_gt_090 ULVT_N < 0.058 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

ULVT_N_EX_6 {
@ Extension of ULVT_N extension outside of (ALL_GT NOT P2) (ALL_GT width < 0.07um) in S/D direction >= 0.035um
 err1 = ENC ALL_GT_NOT_P2 ULVT_N_v_edges < 0.035 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

ULVT_N_EX_7 {
@ ULVT_N extension outside of (ALL_GT NOT P2) (ALL_GT width >= 0.07um) in S/D direction >= 0.058um
 err1 = ENC ALL_GT_NOT_P2_eqgt_070 ULVT_N_v_edges < 0.058 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

ULVT_N_EX_8 {
@ ULVT_N extension outside of GATE (when channel length = 0.016/0.018/0.02um) respectively in S/D direction, except GT_P96 region >= 0.082/0.081/0.080um
 err1 = DFM COPY (DFM SPACE GATE_LE_16 ULVT_N < 0.082 BY ENC HORIZONTAL) REGION
 err2 = DFM COPY (DFM SPACE GATE_LE_18 ULVT_N < 0.081 BY ENC HORIZONTAL) REGION
 err3 = DFM COPY (DFM SPACE GATE_LE_20 ULVT_N < 0.080 BY ENC HORIZONTAL) REGION

 err1 NOT INSIDE GT_P96
 err2 NOT INSIDE GT_P96
 err3 NOT INSIDE GT_P96
}

ULVT_N_EX_9 {
@ ULVT_N extension outside of GATE (when channel length = 0.016/0.018/0.02/0.022/0.024um, INSIDE GT_P96) in S/D direction >= 0.088/0.087/0.086/0.085/0.084um
 err1 = DFM COPY (DFM SPACE GATE_LE_16_in_GT_P96 ULVT_N < 0.088 BY ENC HORIZONTAL) REGION
 err2 = DFM COPY (DFM SPACE GATE_LE_18_in_GT_P96 ULVT_N < 0.087 BY ENC HORIZONTAL) REGION
 err3 = DFM COPY (DFM SPACE GATE_LE_20_in_GT_P96 ULVT_N < 0.086 BY ENC HORIZONTAL) REGION
 err4 = DFM COPY (DFM SPACE GATE_LE_22_in_GT_P96 ULVT_N < 0.085 BY ENC HORIZONTAL) REGION
 err5 = DFM COPY (DFM SPACE GATE_LE_24_in_GT_P96 ULVT_N < 0.084 BY ENC HORIZONTAL) REGION

 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
 err4 NOT INSIDE SealR_NOT_BULK
 err5 NOT INSIDE SealR_NOT_BULK
}

ULVT_N_EX_10 {
@ ULVT_N (line-end vertical width <= 0.238um between two consecutive 90-90 degree corners with both sides length >= 0.09um) enclosure of ((GT AND GTMK1) OR GATE) in S/D direction >= 0.079um
 check_RAW = CONVEX EDGE ULVT_N ANGLE1 == 90 LENGTH1 >= 0.09 ANGLE2 == 90 LENGTH2 >= 0.09 WITH LENGTH <= 0.238
 check_TMP = ANGLE check_RAW == 90
 err1 = ENC (OR GATE_raw GT_and_GTMK1) check_TMP < 0.079 ABUT<90 OPPOSITE REGION  //;including edge GATE
 err1 NOT INSIDE SealR_NOT_BULK
}

ULVT_N_EX_11 {
@ ULVT_N extension outside of (ALL_GT NOT P2) in GATE poly direction with adjacent horizontal enclosure <= 0.04um by ULVT_N vertical edge (edge length = 0.073~0.15um, between two consecutive 90-270 degree corners) >= 0.054um
 y1 = ENC [ALL_GT_NOT_P2] ULVT_N_convex_90_270_eqgt_073_lteq_150_v_edges <= 0.040 ABUT<90 OPPOSITE
 y2 = INT [ULVT_N_h_edges] ULVT_N_convex_90_270_eqgt_073_lteq_150_v_edges < 0.005 ABUT==90 INTERSECTING ONLY
 y3 = ULVT_N_h_edges TOUCH EDGE y2
 y4 = ENC ALL_GT_NOT_P2 y3 < 0.054 ABUT<90 OPPOSITE REGION
 y5 = EXPAND EDGE y1 INSIDE BY 0.005 EXTEND BY 0.005
 err1 = y4 INTERACT y5
 err1 NOT INSIDE SealR_NOT_BULK
}

ULVT_N_in_ALL_GT_h_edges = ANGLE (ULVT_N NOT OUTSIDE EDGE ALL_GT) == 0
ULVT_N_in_all_GT_in_ar_gtmk1_edges = ULVT_N NOT OUTSIDE EDGE all_GT_in_ar_gtmk1
ULVT_N_in_all_GT_in_ar_gtmk1_area = INT ULVT_N_in_all_GT_in_ar_gtmk1_edges < 0.005 ABUT INTERSECTING ONLY REGION

ULVT_N_EX_12 {
@ (ALL_GT NOT P2) extension outside of ULVT_N, except small ALL_GT jogs <= 0.004um, Dummy_Cell_WO_IMP, and ULVT_N vertical edge CUT (GTMK1 OR AR) (channel length <= 0.024um, centerline abut ULVT_N vertical edge) >= 0.083um
//;Only need to check the vertical extension.
 y1 = ULVT_N_in_all_GT_in_ar_gtmk1_edges COIN EDGE all_GT_center_even
 y2 = ANGLE (ULVT_N_in_all_GT_in_ar_gtmk1_edges TOUCH EDGE (ULVT_N_in_all_GT_in_ar_gtmk1_area WITH EDGE (ULVT_N_in_all_GT_in_ar_gtmk1_area COIN EDGE y1))) == 0
 y3 = ULVT_N_in_ALL_GT_h_edges NOT COIN EDGE y2
 err1 = ENC y3 ALL_GT_NOT_P2_not_jog_lteq_004 < 0.083 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE Dummy_Cell_WO_IMP
}

ULVT_N_O_1 {
@ Overlap of (ALL_GT NOT P2) and ULVT_N, except small ALL_GT jogs <= 0.004um, Dummy_Cell_WO_IMP, and ULVT_N vertical edge CUT (GTMK1 OR AR) (channel length <= 0.024um, centerline abut ULVT_N vertical edge) >= 0.083um
//;Only need to check the vertical overlap.
 y1 = ULVT_N_in_all_GT_in_ar_gtmk1_edges COIN EDGE all_GT_center_even
 y2 = ANGLE (ULVT_N_in_all_GT_in_ar_gtmk1_edges TOUCH EDGE (ULVT_N_in_all_GT_in_ar_gtmk1_area WITH EDGE (ULVT_N_in_all_GT_in_ar_gtmk1_area COIN EDGE y1))) == 0
 y3 = ULVT_N_in_ALL_GT_h_edges NOT COIN EDGE y2
 err1 = INT y3 ALL_GT_NOT_P2_not_jog_lteq_004 < 0.083 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE Dummy_Cell_WO_IMP
}

ULVT_N_A_1 {
@ ULVT_N area >= 0.085um2
 err1 = AREA ULVT_N < VT_MiniArea
 err1 NOT INSIDE SealR_NOT_BULK
}

ULVT_N_A_2 {
@ ULVT_N enclosed area >= 0.085um2
 err1 = AREA ((HOLES ULVT_N INNER SINGULAR ALSO) NOT ULVT_N) < VT_MiniArea
 err1 NOT INSIDE SealR_NOT_BULK
}

ULVT_N_A_3 {
@ Area of ((ALL_GT NOT P2) AND ULVT_N) >= 0.00158um2
 err1 = AREA (ALL_GT_NOT_P2 AND ULVT_N) < 0.00158
 err1 NOT INSIDE SealR_NOT_BULK
}

ULVT_N_R_1 {
@ (ALL_AA interact GT (width >= 0.032um)) CUT ULVT_N is not allowed
 err1 = ALL_AA_INTERACT_GT_eqgt_032 CUT ULVT_N
 err1 NOT INSIDE SealR_NOT_BULK
}

ULVT_N_R_2 {
@ ULVT_N overlap with P+AA, SVT_N, SVT_P, HVT_N, HVT_P, LVT_N, LVT_P, ULVT_P, LFN_N, LFN_P, DG, PSUB, INST, RESNW, VARMOS, DMPNP, MARKS is not allowed, exclude OCCD region
 err1 = ULVT_N AND (OR PACT SVT_N SVT_P HVT_N HVT_P LVT_P LVT_N ULVT_P LFN_N LFN_P DG PSUB INST RESNW VARMOS DMPNP MARKS)
 err1 NOT INSIDE OCCD
}

ULVT_N_R_3 {
@ (ALL_AA NOT AR) straddle on ULVT_N horizontal edge is not allowed
 err1 = ULVT_N_h_edges COIN EDGE ((ULVT_N CUT ALL_AA_NOT_AR) INSIDE EDGE ALL_AA_NOT_AR)
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

// =======================================================
// ULVT_P:P type Ultra low Vt MOS design rules
// =======================================================

GROUP GULVT_P ULVT_P_?

ULVT_P_W_1 {
@ ULVT_P width, single-point-interaction is allowed >= 0.192um
@ DRC waive:
@ 1) ULVT_P one-track width within the range of 0.09~0.106um, 0.18~0.212um when PRL = 0um
@ 2) Jog width adjacent to edge (length <= 0.048um, between two consecutive 90-270 degree corners) = 0.18um in S/D direction
@ 3) Jog width adjacent to edge (length = 0.002um, between two consecutive 90-270 degree corners) = 0.135/0.144um in S/D direction
 y1 = INT [ULVT_P] < 0.192 ABUT<90 OPPOSITE EXTENDED 0.001
 y2 = INT [ULVT_P] < 0.192 CORNER
 y3 = INT [ULVT_P_v_edges] >= 0.09 < 0.107 PROJ == 0
 y4 = INT [ULVT_P_v_edges] >= 0.18 < 0.213 PROJ == 0
 y5 = INT [ULVT_P_h_edges] >= 0.09 < 0.107 PROJ == 0
 y6 = INT [ULVT_P_h_edges] >= 0.18 < 0.213 PROJ == 0
 y_all = (y3 OR EDGE y4) OR EDGE (y5 OR EDGE y6)

 waive_edges = ULVT_P_90_90_jog_180_135_144 COIN EDGE ULVT_P_h_edges
 waive_corner = INT [ULVT_P_v_edges] waive_edges < 0.001 ABUT==90 INTERSECTING ONLY
 err1 = (y1 NOT COIN EDGE y_all) NOT TOUCH EDGE waive_corner
 err2 = (y2 COIN EDGE ULVT_P_concave_corner) NOT TOUCH EDGE y_all
 err1 NOT INSIDE EDGE SealR_NOT_BULK
 err2 NOT INSIDE EDGE SealR_NOT_BULK
}

ULVT_P_W_2 {
@ ULVT_P width in S/D direction, single-point-interaction is allowed >= 0.27um
@ DRC waive:
@ 1) ULVT_P one-track width within the range of 0.09~0.106um, 0.18~0.212um when PRL = 0um
@ 2) Jog width adjacent to edge (length <= 0.048um, between two consecutive 90-270 degree corners) = 0.18/0.192/0.225/0.24um in S/D direction
@ 3) Jog width adjacent to edge (length = 0.002um, between two consecutive 90-270 degree corners) = 0.135/0.144um in S/D direction
 y1 = INT [ULVT_P_v_edges] < 0.27 ABUT<90 OPPOSITE EXTENDED 0.001
 y2 = INT [ULVT_P_v_edges] >= 0.09 < 0.107 PROJ == 0
 y3 = INT [ULVT_P_v_edges] >= 0.18 < 0.213 PROJ == 0
 y4 = y2 OR EDGE y3

 waive_corner = INT [ULVT_P_v_edges] ULVT_P_90_90_jog_180_192_225_240_135_144_h_edges < 0.001 ABUT==90 INTERSECTING ONLY
 err1 = (y1 NOT COIN EDGE y4) NOT TOUCH EDGE waive_corner
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

ULVT_P_W_3a {
@ ULVT_P width when just one vertical edge CUT (GTMK1 OR AR) in S/D direction >= 0.315um
@ DRC waive:
@ 1) Jog width adjacent to edge (length <= 0.048um, between two consecutive 90-270 degree corners) = 0.18/0.192/0.225/0.24um in S/D direction
@ 2) Jog width adjacent to edge (length = 0.002um, between two consecutive 90-270 degree corners) = 0.135/0.144um in S/D direction
 check_edges = ULVT_P_v_edges TOUCH EDGE (ULVT_P_v_edges INSIDE EDGE gtmk1_or_ar)
 waive_corner = INT ULVT_P_v_edges ULVT_P_90_90_jog_180_192_225_240_135_144_h_edges <= 0.001 ABUT==90 INTERSECTING ONLY REGION
 check_corner = ULVT_P_v_edges NOT TOUCH EDGE waive_corner
 err1 = INT check_edges check_corner < 0.315 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

ULVT_P_W_3b {
@ ULVT_P width when both vertical ULVT_P edge CUT (GTMK1 OR AR) in S/D direction >= 0.36um
@ DRC waive:
@ 1) Jog width adjacent to edge (length <= 0.048um, between two consecutive 90-270 degree corners) = 0.18/0.192/0.225/0.24um in S/D direction
@ 2) Jog width adjacent to edge (length = 0.002um, between two consecutive 90-270 degree corners) = 0.135/0.144um in S/D direction
 waive_corner = INT ULVT_P_v_edges ULVT_P_90_90_jog_180_192_225_240_135_144_h_edges <= 0.001 ABUT==90 INTERSECTING ONLY REGION
 check_edges = ULVT_P_inside_AA_side_mark_v_edges NOT TOUCH EDGE waive_corner
 err1 = INT check_edges < 0.36 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

ULVT_P_W_4 {
@ ULVT_P width in GATE poly direction when ULVT_P point touch or horizontal width in the range of 0.09~0.106um, 0.18~0.212um while PRL = 0um in GATE poly direction (except L-shape/T-shape concave corner) >= 0.238um
 err1 = INT (ULVT_P_h_edges_singular_point COIN EDGE ULVT_P_concave_corner) ULVT_P_h_edges < 0.238 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK

 y1 = ULVT_P_convex_eqlt_1_edges COIN EDGE ULVT_P_h_edges
 y2 = ULVT_P COIN EDGE (EXPAND EDGE (y1 COIN EDGE ULVT_P_concave_corner) INSIDE BY 0.001 OUTSIDE BY 0.001)
 y3 = INT [y2] >= 0.09 <= 0.106+0.0005 ABUT<90 PROJ == 0
 y4 = INT [y2] >= 0.18 <= 0.212+0.0005 ABUT<90 PROJ == 0
 y5 = ULVT_P_concave_corner WITH EDGE (ULVT_P_concave_corner COIN EDGE (y3 OR EDGE y4))
 y6 = ULVT_P_h_edges COIN EDGE y5
 err2 = INT ULVT_P_h_edges y6 < 0.238 ABUT<90 OPPOSITE REGION
 err3 = (LENGTH ((ULVT_P_v_edges TOUCH EDGE y5) TOUCH EDGE ULVT_P_convex_eq_1_edges) < 0.238) EXPAND EDGE INSIDE BY 0.001
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
}

ULVT_P_S_1 {
@ Space between ULVT_P, single-point-interaction is allowed >= 0.192um
@ DRC waive:
@ 1) ULVT_P one-track space within the range of 0.09~0.106um, 0.18~0.212um when PRL = 0um
@ 2) Jog space adjacent to edge (length <= 0.048um, between two consecutive 90-270 degree corners) = 0.18um in S/D direction
@ 3) Jog space adjacent to edge (length = 0.002um, between two consecutive 90-270 degree corners) = 0.135/0.144um in S/D direction
 y1 = EXT [ULVT_P] < 0.192 ABUT<90 OPPOSITE EXTENDED 0.001
 y2 = EXT [ULVT_P] < 0.192 CORNER
 y3 = EXT [ULVT_P_v_edges] >= 0.09 < 0.107 PROJ == 0
 y4 = EXT [ULVT_P_v_edges] >= 0.18 < 0.213 PROJ == 0
 y5 = EXT [ULVT_P_h_edges] >= 0.09 < 0.107 PROJ == 0
 y6 = EXT [ULVT_P_h_edges] >= 0.18 < 0.213 PROJ == 0
 y_all = (y3 OR EDGE y4) OR EDGE (y5 OR EDGE y6)
 w_all = ULVT_P_rvs_90_90_jog_180_135_144 OR EDGE ULVT_P_90_90_jog_180_135_144

 z1 = w_all COIN EDGE ULVT_P_h_edges
 z2 = ULVT_P_rvs COIN EDGE ULVT_P_v_edges
 z3 = INT [z2] z1 < 0.005 ABUT==90 INTERSECTING ONLY
 err1 = (y1 NOT COIN EDGE y_all) NOT TOUCH EDGE z3
 err2 = (y2 COIN EDGE ULVT_P_convex_corner) NOT COIN EDGE y_all
 err1 NOT INSIDE EDGE SealR_NOT_BULK
 err2 NOT INSIDE EDGE SealR_NOT_BULK
}

ULVT_P_S_2 {
@ Space between ULVT_P in S/D direction, single-point-interaction is allowed >= 0.27um
@ DRC waive:
@ 1) ULVT_P one-track space within the range of 0.09~0.106um, 0.18~0.212um when PRL = 0um
@ 2) Jog space adjacent to edge (length <= 0.048um, between two consecutive 90-270 degree corners) = 0.180/0.192/0.225/0.24um in S/D direction
@ 3) Jog space adjacent to edge (length = 0.002um, between two consecutive 90-270 degree corners) = 0.135/0.144um in S/D direction
 w_all = ULVT_P_90_90_jog_180_192_225_240_135_144 OR EDGE ULVT_P_rvs_90_90_jog_180_192_225_240_135_144
 y1 = ANGLE (EXT [ULVT_P] < 0.27 ABUT<90 OPPOSITE EXTENDED 0.001) == 90
 y2 = EXT [ULVT_P_v_edges] >= 0.09 < 0.107 PROJ == 0
 y3 = EXT [ULVT_P_v_edges] >= 0.18 < 0.213 PROJ == 0
 y4 = y2 OR EDGE y3

 z1 = ANGLE ULVT_P_rvs == 0
 z2 = w_all COIN EDGE z1
 z3 = ANGLE ULVT_P_rvs == 90
 z4 = INT [z3] z2 < 0.001 ABUT==90 INTERSECTING ONLY
 err1 = (y1 NOT COIN EDGE y4) NOT TOUCH EDGE z4
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

ULVT_P_S_4 {
@ Space between ULVT_P when PRL >= 0.29um. >= 0.248um
 Layer_area = EXT ULVT_P < 0.248 OPPOSITE REGION
 err1 = Layer_area ENCLOSE RECTANGLE 0.001 0.29 ORTHOGONAL ONLY
 err1 NOT INSIDE SealR_NOT_BULK
}

ULVT_P_S_5 {
@ Space between ULVT_P in GATE poly direction when ULVT_P point touch or horizontal width in the range of 0.09~0.106um, 0.18~0.212um while PRL = 0um in GATE poly direction >= 0.238um
 err1 = EXT ULVT_P_h_edges_singular_point ULVT_P_h_edges < 0.238 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK

 y1 = ULVT_P_convex_eqlt_1_edges COIN EDGE ULVT_P_h_edges
 y2 = ULVT_P COIN EDGE (EXPAND EDGE (y1 COIN EDGE ULVT_P_concave_corner) INSIDE BY 0.001 OUTSIDE BY 0.001)
 y3 = INT [y2] >= 0.09 <= 0.106+0.0005 ABUT<90 PROJ == 0
 y4 = INT [y2] >= 0.18 <= 0.212+0.0005 ABUT<90 PROJ == 0
 y5 = ULVT_P_concave_corner WITH EDGE (ULVT_P_concave_corner COIN EDGE (y3 OR EDGE y4))
 y6 = ULVT_P_h_edges TOUCH EDGE y5
 err2 = EXT ULVT_P_h_edges y6 < 0.238 ABUT<90 OPPOSITE REGION
 err3 = (LENGTH ((ULVT_P_v_edges TOUCH EDGE y5) TOUCH EDGE ULVT_P_convex_eq_0_edges) < 0.238) EXPAND EDGE INSIDE BY 0.002
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
}

ULVT_P_S_6 {
@ Space between ULVT_P and ALL_AA (vertical edge abut AA edge is allowed) >= 0.045um
 CHECK_RAW = EXT ULVT_P ALL_AA < 0.045 ABUT<90 SINGULAR
 WAIVE_CRN = ULVT_P COIN OUTSIDE EDGE ALL_AA_v_edges
 err1 = DFM COPY (DFM PROPERTY CHECK_RAW WAIVE_CRN ABUT ALSO OVERLAP MULTI SPLIT [-= count(WAIVE_CRN)] == 0) REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

ULVT_P_S_6a {
@ Space between ULVT_P and ALL_AA in GATE poly direction >= 0.048um
 err1 = EXT ULVT_P ALL_AA_h_edges < 0.048 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

ULVT_P_S_7 {
@ Space between ULVT_P and (ALL_GT NOT P2) (ALL_GT width < 0.07um), except small ALL_GT jog <= 0.004um. >= 0.024um
 err1 = EXT ULVT_P ALL_GT_NOT_P2_not_jog_lteq_004 < 0.024 ABUT<90 REGION MEASURE ALL  //;minimum
 err1 NOT INSIDE SealR_NOT_BULK
}

ULVT_P_S_7a {
@ Space between ULVT_P and (ALL_GT NOT P2) (ALL_GT width >= 0.07um) >= 0.034um
 err1 = EXT ULVT_P (ALL_GT_eqgt_070 NOT P2) < 0.034 ABUT<90 SINGULAR REGION MEASURE ALL
 err1 NOT INSIDE SealR_NOT_BULK
}

ULVT_P_S_7b {
@ Space between ULVT_P and (ALL_GT NOT P2) (ALL_GT width > 0.09um) >= 0.058um
 err1 = EXT ULVT_P ALL_GT_NOT_P2_gt_090 < 0.058 ABUT<90 SINGULAR REGION MEASURE ALL
 err1 NOT INSIDE SealR_NOT_BULK
}

ULVT_P_S_8 {
@ Space between ULVT_P and (ALL_GT NOT P2) (ALL_GT width < 0.07um) in S/D direction >= 0.035um
 err1 = EXT ALL_GT_NOT_P2 ULVT_P_v_edges < 0.035 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

ULVT_P_S_8a {
@ Space between ULVT_P and (ALL_GT NOT P2) (ALL_GT width >= 0.07um) in S/D direction >= 0.058um
 err1 = EXT ULVT_P_v_edges ALL_GT_NOT_P2_eqgt_070 < 0.058 ABUT<90 OPPOSITE REGION MEASURE ALL
 err1 NOT INSIDE SealR_NOT_BULK
}

ULVT_P_S_9a {
@ Space between ULVT_P and GATE (when channel length = 0.016/0.018/0.02um) respectively in S/D direction (GATE CUT ULVT_P is not allowed), except GT_P96 region >= 0.082/0.081/0.08um
 err1 = DFM COPY (DFM SPACE GATE_LE_16 ULVT_P < 0.082 BY EXT HORIZONTAL MEASURE ALL) REGION
 err2 = DFM COPY (DFM SPACE GATE_LE_18 ULVT_P < 0.081 BY EXT HORIZONTAL MEASURE ALL) REGION
 err3 = DFM COPY (DFM SPACE GATE_LE_20 ULVT_P < 0.080 BY EXT HORIZONTAL MEASURE ALL) REGION
 err4 = GATE CUT ULVT_P

 err1 NOT INSIDE GT_P96
 err2 NOT INSIDE GT_P96
 err3 NOT INSIDE GT_P96
 err4 NOT INSIDE GT_P96
}

ULVT_P_S_9b {
@ Space between ULVT_P and GATE (when channel length = 0.016/0.018/0.02/0.022/0.024um, INSIDE GT_P96) in S/D direction (GATE CUT ULVT_P is not allowed) >= 0.088/0.087/0.086/0.085/0.084um
 err1 = DFM COPY (DFM SPACE GATE_LE_16_in_GT_P96 ULVT_P < 0.088 BY EXT HORIZONTAL MEASURE ALL) REGION
 err2 = DFM COPY (DFM SPACE GATE_LE_18_in_GT_P96 ULVT_P < 0.087 BY EXT HORIZONTAL MEASURE ALL) REGION
 err3 = DFM COPY (DFM SPACE GATE_LE_20_in_GT_P96 ULVT_P < 0.086 BY EXT HORIZONTAL MEASURE ALL) REGION
 err4 = DFM COPY (DFM SPACE GATE_LE_22_in_GT_P96 ULVT_P < 0.085 BY EXT HORIZONTAL MEASURE ALL) REGION
 err5 = DFM COPY (DFM SPACE GATE_LE_24_in_GT_P96 ULVT_P < 0.084 BY EXT HORIZONTAL MEASURE ALL) REGION
 err6 = GATE CUT ULVT_P

 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
 err4 NOT INSIDE SealR_NOT_BULK
 err5 NOT INSIDE SealR_NOT_BULK
 err6 NOT INSIDE SealR_NOT_BULK
}

ULVT_P_S_10 {
@ Space between ULVT_P vertical edge (edge length <= 0.238um between two concave corners with both sides length >= 0.09um) and ((GT AND GTMK1) OR GATE) in S/D direction >= 0.079um
 check_RAW = CONVEX EDGE ULVT_P ANGLE1 == 270 LENGTH1 >= 0.09 ANGLE2 == 270 LENGTH2 >= 0.09 WITH LENGTH <= 0.238
 check_TMP = ANGLE check_RAW == 90
 err1 = EXT (OR GATE_raw GT_and_GTMK1) check_TMP < 0.079 ABUT<90 OPPOSITE REGION  //;including edge GATE
 err1 NOT INSIDE SealR_NOT_BULK
}

ULVT_P_S_11 {
@ Space between ULVT_P and (ALL_GT NOT P2) in GATE poly direction with adjacent horizontal space <= 0.04um (ULVT_P vertical edge length = 0.073~0.15um, between two consecutive 90-270 degree coners) >= 0.054um
 y1 = EXT [ALL_GT_NOT_P2] ULVT_P_convex_90_270_eqgt_073_lteq_150_v_edges <= 0.040 ABUT<90 OPPOSITE
 y2 = EXT [ULVT_P_h_edges] ULVT_P_convex_90_270_eqgt_073_lteq_150_v_edges < 0.005 ABUT==90 INTERSECTING ONLY

 z1 = ULVT_P_h_edges TOUCH EDGE y2
 z2 = EXT ALL_GT_NOT_P2 z1 < 0.054 ABUT<90 OPPOSITE REGION
 z3 = EXPAND EDGE y1 INSIDE BY 0.005 EXTEND BY 0.005
 err1 = z2 INTERACT z3
 err1 NOT INSIDE SealR_NOT_BULK
}

ULVT_P_EX_1 {
@ ULVT_P extension outside of ALL_AA (vertical edge abut AA edge is allowed) >= 0.045um
 CHECK_RAW = ENC ALL_AA ULVT_P < 0.045 ABUT<90 SINGULAR
 WAIVE_CRN = ULVT_P COIN INSIDE EDGE ALL_AA_v_edges
 err1 = DFM COPY (DFM PROPERTY CHECK_RAW WAIVE_CRN ABUT ALSO OVERLAP MULTI SPLIT [-= count(WAIVE_CRN)] == 0) REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

ULVT_P_EX_2 {
@ ULVT_P extension outside of ALL_AA in GATE poly direction >= 0.048um
 err1 = ENC ALL_AA_h_edges ULVT_P < 0.048 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

ULVT_P_EX_3 {
@ ULVT_P extension outside of (ALL_GT NOT P2) (ALL_GT width < 0.07um) (Except small ALL_GT jogs <= 0.004um) >= 0.024um
 err1 = ENC ALL_GT_NOT_P2_not_jog_lteq_004 ULVT_P < 0.024 ABUT<90 OPPOSITE REGION  //;minimum
 err1 NOT INSIDE SealR_NOT_BULK
}

ULVT_P_EX_4 {
@ ULVT_P extension outside of (ALL_GT NOT P2) (ALL_GT width >= 0.07um) >= 0.034um
 err1 = ENC ALL_GT_NOT_P2_eqgt_070 ULVT_P < 0.034 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

ULVT_P_EX_5 {
@ ULVT_P extension outside of (ALL_GT NOT P2) (ALL_GT width > 0.09um) >= 0.058um
 err1 = ENC ALL_GT_NOT_P2_gt_090 ULVT_P < 0.058 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

ULVT_P_EX_6 {
@ ULVT_P extension outside of (ALL_GT NOT P2) (ALL_GT width < 0.07um) in S/D direction >= 0.035um
 err1 = ENC ALL_GT_NOT_P2 ULVT_P_v_edges < 0.035 ABUT<90 OPPOSITE REGION  //;minimum
 err1 NOT INSIDE SealR_NOT_BULK
}

ULVT_P_EX_7 {
@ ULVT_P extension outside of (ALL_GT NOT P2) (ALL_GT width >= 0.07um) in S/D direction >= 0.058um
 err1 = ENC ALL_GT_NOT_P2_eqgt_070 ULVT_P_v_edges < 0.058 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

ULVT_P_EX_8 {
@ ULVT_P extension outside of GATE (when channel length = 0.016/0.018/0.02um) respectively in S/D direction, except GT_P96 region >= 0.082/0.081/0.080um
 err1 = DFM COPY (DFM SPACE GATE_LE_16 ULVT_P < 0.082 BY ENC HORIZONTAL) REGION
 err2 = DFM COPY (DFM SPACE GATE_LE_18 ULVT_P < 0.081 BY ENC HORIZONTAL) REGION
 err3 = DFM COPY (DFM SPACE GATE_LE_20 ULVT_P < 0.080 BY ENC HORIZONTAL) REGION

 err1 NOT INSIDE GT_P96
 err2 NOT INSIDE GT_P96
 err3 NOT INSIDE GT_P96
}

ULVT_P_EX_9 {
@ ULVT extension outside GATE (channel length = 0.016/0.018/0.020/0.022/0.024um, INSIDE GT_P96) in S/D direction >= 0.088/0.087/0.086/0.085/0.084um
 err1 = (DFM COPY (DFM SPACE GATE_LE_16 ULVT_P < 0.088 BY ENC HORIZONTAL) REGION) NOT OUTSIDE GT_P96
 err2 = (DFM COPY (DFM SPACE GATE_LE_18 ULVT_P < 0.087 BY ENC HORIZONTAL) REGION) NOT OUTSIDE GT_P96
 err3 = (DFM COPY (DFM SPACE GATE_LE_20 ULVT_P < 0.086 BY ENC HORIZONTAL) REGION) NOT OUTSIDE GT_P96
 err4 = (DFM COPY (DFM SPACE GATE_LE_22 ULVT_P < 0.085 BY ENC HORIZONTAL) REGION) NOT OUTSIDE GT_P96
 err5 = (DFM COPY (DFM SPACE GATE_LE_24 ULVT_P < 0.084 BY ENC HORIZONTAL) REGION) NOT OUTSIDE GT_P96

 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
 err4 NOT INSIDE SealR_NOT_BULK
 err5 NOT INSIDE SealR_NOT_BULK
}

ULVT_P_EX_10 {
@ ULVT_P (line-end vertical width <= 0.238um between two consecutive 90-90 degree corners with both sides length >= 0.09um) enclosure of ((GT AND GTMK1) OR GATE) in S/D direction >= 0.079um
 check_RAW = CONVEX EDGE ULVT_P ANGLE1 == 90 LENGTH1 >= 0.09 ANGLE2 == 90 LENGTH2 >= 0.09 WITH LENGTH <= 0.238
 check_TMP = ANGLE check_RAW == 90
 err1 = ENC (OR GATE_raw GT_and_GTMK1) check_TMP < 0.079 ABUT<90 OPPOSITE REGION  //;including edge GATE
 err1 NOT INSIDE SealR_NOT_BULK
}

ULVT_P_EX_11 {
@ ULVT_P extension outside of (ALL_GT NOT P2) in GATE poly direction with adjacent horizontal enclosure <= 0.04um by ULVT_P vertical edge (edge length = 0.073~0.15um, between two consecutive 90-270 degree corners) >= 0.054um
 y1 = ENC [ALL_GT_NOT_P2] ULVT_P_convex_90_270_eqgt_073_lteq_150_v_edges <= 0.040 ABUT<90 OPPOSITE
 y2 = INT [ULVT_P_h_edges] ULVT_P_convex_90_270_eqgt_073_lteq_150_v_edges < 0.005 ABUT==90 INTERSECTING ONLY
 y3 = ULVT_P_h_edges TOUCH EDGE y2
 y4 = ENC ALL_GT_NOT_P2 y3 < 0.054 ABUT<90 OPPOSITE REGION
 y5 = EXPAND EDGE y1 INSIDE BY 0.005 EXTEND BY 0.005
 err1 = y4 INTERACT y5
 err1 NOT INSIDE SealR_NOT_BULK
}

ULVT_P_in_ALL_GT_h_edges = ANGLE (ULVT_P NOT OUTSIDE EDGE ALL_GT) == 0
ULVT_P_in_all_GT_in_ar_gtmk1_edges = ULVT_P NOT OUTSIDE EDGE all_GT_in_ar_gtmk1
ULVT_P_in_all_GT_in_ar_gtmk1_area = INT ULVT_P_in_all_GT_in_ar_gtmk1_edges < 0.005 ABUT INTERSECTING ONLY REGION

ULVT_P_EX_12 {
@ (ALL_GT NOT P2) extension outside of ULVT_P (Except small ALL_GT jogs <= 0.004um, Dummy_Cell_WO_IMP, and ULVT_P vertical edge CUT (GTMK1 OR AR) (channel length <= 0.024um, centerline abut ULVT_P vertical edge)) >= 0.083um
//;Only need to check the vertical extension.
 y1 = ULVT_P_in_all_GT_in_ar_gtmk1_edges COIN EDGE all_GT_center_even
 y2 = ANGLE (ULVT_P_in_all_GT_in_ar_gtmk1_edges TOUCH EDGE (ULVT_P_in_all_GT_in_ar_gtmk1_area WITH EDGE (ULVT_P_in_all_GT_in_ar_gtmk1_area COIN EDGE y1))) == 0
 y3 = ULVT_P_in_ALL_GT_h_edges NOT COIN EDGE y2
 err1 = ENC y3 ALL_GT_NOT_P2_not_jog_lteq_004 < 0.083 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE Dummy_Cell_WO_IMP
}

ULVT_P_O_1 {
@ Overlap of (ALL_GT NOT P2) and ULVT_P (Except small ALL_GT jogs <= 0.004um, Dummy_Cell_WO_IMP, and ULVT_P vertical edge CUT (GTMK1 OR AR) (channel length <= 0.024um, centerline abut ULVT_P vertical edge)) >= 0.083um
//;Only need to check the vertical overlap.
 y1 = ULVT_P_in_all_GT_in_ar_gtmk1_edges COIN EDGE all_GT_center_even
 y2 = ANGLE (ULVT_P_in_all_GT_in_ar_gtmk1_edges TOUCH EDGE (ULVT_P_in_all_GT_in_ar_gtmk1_area WITH EDGE (ULVT_P_in_all_GT_in_ar_gtmk1_area COIN EDGE y1))) == 0
 y3 = ULVT_P_in_ALL_GT_h_edges NOT COIN EDGE y2
 err1 = INT y3 ALL_GT_NOT_P2_not_jog_lteq_004 < 0.083 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE Dummy_Cell_WO_IMP
}

ULVT_P_A_1 {
@ ULVT_P area >= 0.085um2
 err1 = AREA ULVT_P < VT_MiniArea
 err1 NOT INSIDE SealR_NOT_BULK
}

ULVT_P_A_2 {
@ ULVT_P enclosed area >= 0.085um2
 err1 = AREA ((HOLES ULVT_P INNER SINGULAR ALSO) NOT ULVT_P) < VT_MiniArea
 err1 NOT INSIDE SealR_NOT_BULK
}

ULVT_P_A_3 {
@ Area of ((ALL_GT NOT P2) AND ULVT_P) >= 0.00158um2
 err1 = AREA (ALL_GT_NOT_P2 AND ULVT_P) < 0.00158
 err1 NOT INSIDE SealR_NOT_BULK
}

ULVT_P_R_1 {
@ (ALL_AA interact GT (width >= 0.032um)) CUT ULVT_P is not allowed
 err1 = ALL_AA_INTERACT_GT_eqgt_032 CUT ULVT_P
 err1 NOT INSIDE SealR_NOT_BULK
}

ULVT_P_R_2 {
@ ULVT_P overlap with N+AA, SVT_N, SVT_P, HVT_N, HVT_P, LVT_N, LVT_P, ULVT_N, LFN_N, LFN_P, DG, PSUB, INST, RESNW, VARMOS, DMPNP, MARKS is not allowed, exclude OCCD region
 err1 = ULVT_P AND (OR NACT SVT_N SVT_P HVT_N HVT_P ULVT_N LVT_N LVT_P LFN_N LFN_P DG PSUB INST RESNW VARMOS DMPNP MARKS)
 err1 NOT INSIDE OCCD
}

ULVT_P_R_3 {
@ (ALL_AA NOT AR) straddle on ULVT_P horizontal edge is not allowed
 err1 = ULVT_P_h_edges COIN EDGE ((ULVT_P CUT ALL_AA_NOT_AR) INSIDE EDGE ALL_AA_NOT_AR)
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

// =======================================================
// LFN_N: design rules
// =======================================================

GROUP GLFN_N LFN_N_?

LFN_N_W_1 {
@ LFN_N width, single-point-interaction is allowed >= 0.192um
@ DRC waive:
@ 1) LFN_N one-track width within the range of 0.09~0.106um, 0.18~0.212um when PRL = 0um
@ 2) Jog width adjacent to edge (length <= 0.048um, between two consecutive 90-270 degree corners) = 0.18um in S/D direction
@ 3) Jog width adjacent to edge (length = 0.002um, between two consecutive 90-270 degree corners) = 0.135/0.144um in S/D direction
 y1 = INT [LFN_N] < 0.192 ABUT<90 OPPOSITE EXTENDED 0.001
 y2 = INT [LFN_N] < 0.192 CORNER
 y3 = INT [LFN_N_v_edges] >= 0.09 < 0.107 PROJ == 0
 y4 = INT [LFN_N_v_edges] >= 0.18 < 0.213 PROJ == 0
 y5 = INT [LFN_N_h_edges] >= 0.09 < 0.107 PROJ == 0
 y6 = INT [LFN_N_h_edges] >= 0.18 < 0.213 PROJ == 0
 y_all = (y3 OR EDGE y4) OR EDGE (y5 OR EDGE y6)

 waive_edges = LFN_N_90_90_jog_180_135_144 COIN EDGE LFN_N_h_edges
 waive_corner = INT [LFN_N_v_edges] waive_edges < 0.001 ABUT==90 INTERSECTING ONLY
 err1 = (y1 NOT COIN EDGE y_all) NOT TOUCH EDGE waive_corner
 err2 = (y2 COIN EDGE LFN_N_concave_corner) NOT TOUCH EDGE y_all
 err1 NOT INSIDE EDGE SealR_NOT_BULK
 err2 NOT INSIDE EDGE SealR_NOT_BULK
}

LFN_N_W_2 {
@ LFN_N width in S/D direction, single-point-interaction is allowed >= 0.27um
@ DRC waive:
@ 1) LFN_N one-track width within the range of 0.09~0.106um, 0.18~0.212um when PRL = 0um
@ 2) Jog width adjacent to edge (length <= 0.048um, between two consecutive 90-270 degree corners) = 0.18/0.192/0.225/0.24um in S/D direction
@ 3) Jog width adjacent to edge (length = 0.002um, between two consecutive 90-270 degree corners) = 0.135/0.144um in S/D direction
 y1 = INT [LFN_N_v_edges] < 0.27 ABUT<90 OPPOSITE EXTENDED 0.001
 y2 = INT [LFN_N_v_edges] >= 0.09 < 0.107 PROJ == 0
 y3 = INT [LFN_N_v_edges] >= 0.18 < 0.213 PROJ == 0
 y_all = y2 OR EDGE y3

 waive_edges = LFN_N_90_90_jog_180_192_225_240_135_144 COIN EDGE LFN_N_h_edges
 waive_corner = INT [LFN_N_v_edges] waive_edges < 0.001 ABUT==90 INTERSECTING ONLY
 err1 = (y1 NOT COIN EDGE y_all) NOT TOUCH EDGE waive_corner
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

LFN_N_W_3 {
@ LFN_N width in S/D direction, when one LFN_N vertical edge CUT (GTMK1 OR AR) and ABUT HVT_N >= 0.315um
@ DRC waive:
@ 1) Jog width adjacent to edge (length <= 0.048um, between two consecutive 90-270 degree corners) = 0.18/0.192/0.225/0.24um in S/D direction
@ 2) Jog width adjacent to edge (length = 0.002um, between two consecutive 90-270 degree corners) = 0.135/0.144um in S/D direction
 check_edges = (LFN_N_v_edges TOUCH EDGE (LFN_N_v_edges INSIDE EDGE gtmk1_or_ar)) COIN EDGE HVT_N
 waive_corner = INT LFN_N_v_edges LFN_N_90_90_jog_180_192_225_240_135_144_h_edges <= 0.001 ABUT==90 INTERSECTING ONLY REGION
 check_corner = LFN_N_v_edges NOT TOUCH EDGE waive_corner
 err1 = INT check_edges check_corner < 0.315 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

LFN_N_W_4 {
@ LFN_N width in GATE poly direction when LFN_N point touch or horizontal width in the range of 0.09~0.106um, 0.18~0.212um while PRL = 0um in GATE poly direction (except L-shape/T-shape concave corner) >= 0.238um
 err1 = INT (LFN_N_h_edges_singular_point COIN EDGE LFN_N_concave_corner) LFN_N_h_edges < 0.238 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK

 y1 = LFN_N_convex_eqlt_1_edges COIN EDGE LFN_N_h_edges
 y2 = LFN_N COIN EDGE (EXPAND EDGE (y1 COIN EDGE LFN_N_concave_corner) INSIDE BY 0.001 OUTSIDE BY 0.001)
 y3 = INT [y2] >= 0.09 <= 0.106+0.0005 ABUT<90 PROJ == 0
 y4 = INT [y2] >= 0.18 <= 0.212+0.0005 ABUT<90 PROJ == 0
 y5 = LFN_N_concave_corner WITH EDGE (LFN_N_concave_corner COIN EDGE (y3 OR EDGE y4))
 y6 = LFN_N_h_edges COIN EDGE y5
 err2 = INT LFN_N_h_edges y6 < 0.238 ABUT<90 OPPOSITE REGION
 err3 = (LENGTH ((LFN_N_v_edges TOUCH EDGE y5) TOUCH EDGE LFN_N_convex_eq_1_edges) < 0.238) EXPAND EDGE INSIDE BY 0.001
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
}

LFN_N_S_1 {
@ Space between LFN_N, single-point-interaction is allowed >= 0.192um
@ DRC waive:
@ 1) LFN_N one-track space within the range of 0.09~0.106um, 0.18~0.212um when PRL = 0um
@ 2) Jog space adjacent to edge (length <= 0.048um, between two consecutive 90-270 degree corners) = 0.18um in S/D direction
@ 3) Jog space adjacent to edge (length = 0.002um, between two consecutive 90-270 degree corners) = 0.135/0.144um in S/D direction
 y1 = EXT [LFN_N] < 0.192 ABUT<90 OPPOSITE EXTENDED 0.001
 y2 = EXT [LFN_N] < 0.192 CORNER
 y3 = EXT [LFN_N_v_edges] >= 0.09 < 0.107 PROJ == 0
 y4 = EXT [LFN_N_v_edges] >= 0.18 < 0.213 PROJ == 0
 y5 = EXT [LFN_N_h_edges] >= 0.09 < 0.107 PROJ == 0
 y6 = EXT [LFN_N_h_edges] >= 0.18 < 0.213 PROJ == 0
 y_all = (y3 OR EDGE y4) OR EDGE (y5 OR EDGE y6)
 w_all = LFN_N_rvs_90_90_jog_180_135_144 OR EDGE LFN_N_90_90_jog_180_135_144

 z1 = w_all COIN EDGE LFN_N_h_edges
 z2 = LFN_N_rvs COIN EDGE LFN_N_v_edges
 z3 = INT [z2] z1 < 0.005 ABUT==90 INTERSECTING ONLY
 err1 = (y1 NOT COIN EDGE y_all) NOT TOUCH EDGE z3
 err2 = (y2 COIN EDGE LFN_N_convex_corner) NOT COIN EDGE y_all
 err1 NOT INSIDE EDGE SealR_NOT_BULK
 err2 NOT INSIDE EDGE SealR_NOT_BULK
}

LFN_N_S_2 {
@ Space between LFN_N in S/D direction, single-point-interaction is allowed >= 0.27um
@ DRC waive:
@ 1) LFN_N one-track space within the range of 0.09~0.106um, 0.18~0.212um when PRL = 0um
@ 2) Jog space adjacent to edge (length <= 0.048um, between two consecutive 90-270 degree corners) = 0.180/0.192/0.225/0.24um in S/D direction
@ 3) Jog space adjacent to edge (length = 0.002um, between two consecutive 90-270 degree corners) = 0.135/0.144um in S/D direction
 w_all = LFN_N_90_90_jog_180_192_225_240_135_144 OR EDGE LFN_N_rvs_90_90_jog_180_192_225_240_135_144
 y1 = ANGLE (EXT [LFN_N] < 0.27 ABUT<90 OPPOSITE EXTENDED 0.001) == 90
 y2 = EXT [LFN_N_v_edges] >= 0.09 < 0.107 PROJ == 0
 y3 = EXT [LFN_N_v_edges] >= 0.18 < 0.213 PROJ == 0
 y4 = y2 OR EDGE y3

 z1 = ANGLE LFN_N_rvs == 0
 z2 = w_all COIN EDGE z1
 z3 = ANGLE LFN_N_rvs == 90
 z4 = INT [z3] z2 < 0.001 ABUT==90 INTERSECTING ONLY
 err1 = (y1 NOT COIN EDGE y4) NOT TOUCH EDGE z4
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

LFN_N_S_3a {
@ Space between LFN_N in S/D direction, when just one LFN_N vertical edge CUT (GTMK1 OR AR) and abut LVT_N or ULVT_N >= 0.315um
@ DRC waive:
@ 1) Jog space adjacent to edge (length <= 0.048um, between two consecutive 90-270 degree corners) = 0.180/0.192/0.225/0.24um in S/D direction
@ 2) Jog space adjacent to edge (length = 0.002um, between two consecutive 90-270 degree corners) = 0.135/0.144um in S/D direction
 check_edges = (LFN_N_inside_AA_side_mark_v_edges TOUCH EDGE LVT_N) OR EDGE (LFN_N_inside_AA_side_mark_v_edges TOUCH EDGE ULVT_N)
 waive_corner = EXT LFN_N_270_270_jog_180_192_225_240_135_144_h_edges check_edges <= 0.001 ABUT==90 INTERSECTING ONLY REGION
 check_corner = check_edges NOT TOUCH EDGE waive_corner
 err1 = EXT check_corner LFN_N_v_edges < 0.315 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

LFN_N_S_3b {
@ Space between LFN_N in S/D direction, when both LFN_N vertical edge CUT (GTMK1 OR AR) and abut LVT_N or ULVT_N >= 0.36um
@ DRC waive:
@ 1) Jog space adjacent to edge (length <= 0.048um, between two consecutive 90-270 degree corners) = 0.180/0.192/0.225/0.24um in S/D direction
@ 2) Jog space adjacent to edge (length = 0.002um, between two consecutive 90-270 degree corners) = 0.135/0.144um in S/D direction
 check_edges = (LFN_N_inside_AA_side_mark_v_edges TOUCH EDGE LVT_N) OR EDGE (LFN_N_inside_AA_side_mark_v_edges TOUCH EDGE ULVT_N)
 waive_corner = EXT LFN_N_270_270_jog_180_192_225_240_135_144_h_edges check_edges <= 0.001 ABUT==90 INTERSECTING ONLY REGION
 check_corner = check_edges NOT TOUCH EDGE waive_corner
 err1 = EXT check_corner < 0.36 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

LFN_N_S_4 {
@ Space between LFN_N when PRL >= 0.29um. >= 0.248um
 Layer_area = EXT LFN_N < 0.248 OPPOSITE REGION
 err1 = Layer_area ENCLOSE RECTANGLE 0.001 0.29 ORTHOGONAL ONLY
 err1 NOT INSIDE SealR_NOT_BULK
}

LFN_N_S_5 {
@ Space between LFN_N in GATE poly direction when LFN_N point touch or horizontal width in the range of 0.09~0.106um, 0.18~0.212um while PRL = 0um in GATE poly direction >= 0.238um
 err1 = EXT LFN_N_h_edges_singular_point LFN_N_h_edges < 0.238 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK

 y1 = LFN_N_convex_eqlt_1_edges COIN EDGE LFN_N_h_edges
 y2 = LFN_N COIN EDGE (EXPAND EDGE (y1 COIN EDGE LFN_N_concave_corner) INSIDE BY 0.001 OUTSIDE BY 0.001)
 y3 = INT [y2] >= 0.09 <= 0.106+0.0005 ABUT<90 PROJ == 0
 y4 = INT [y2] >= 0.18 <= 0.212+0.0005 ABUT<90 PROJ == 0
 y5 = LFN_N_concave_corner WITH EDGE (LFN_N_concave_corner COIN EDGE (y3 OR EDGE y4))
 y6 = LFN_N_h_edges TOUCH EDGE y5
 err2 = EXT LFN_N_h_edges y6 < 0.238 ABUT<90 OPPOSITE REGION
 err3 = (LENGTH ((LFN_N_v_edges TOUCH EDGE y5) TOUCH EDGE LFN_N_convex_eq_0_edges) < 0.238) EXPAND EDGE INSIDE BY 0.002
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
}

LFN_N_S_6 {
@ Space between LFN_N and ALL_AA (vertical edge abut AA edge is allowed) >= 0.045um
 CHECK_RAW = EXT LFN_N ALL_AA < 0.045 ABUT<90 SINGULAR
 WAIVE_CRN = LFN_N COIN OUTSIDE EDGE ALL_AA_v_edges
 err1 = DFM COPY (DFM PROPERTY CHECK_RAW WAIVE_CRN ABUT ALSO OVERLAP MULTI SPLIT [-= count(WAIVE_CRN)] == 0) REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

LFN_N_S_6a {
@ Space between LFN_N and ALL_AA in GATE poly direction >= 0.048um
 err1 = EXT LFN_N ALL_AA_h_edges < 0.048 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

LFN_N_S_7 {
@ Space between LFN_N and (ALL_GT NOT P2) (ALL_GT width < 0.07um), except small ALL_GT jogs <= 0.004um. >= 0.024um
 err1 = EXT LFN_N ALL_GT_NOT_P2_not_jog_lteq_004 < 0.024 ABUT<90 REGION MEASURE ALL  //;minimum
 err1 NOT INSIDE SealR_NOT_BULK
}

LFN_N_S_7a {
@ Space between LFN_N and (ALL_GT NOT P2) (ALL_GT width >= 0.07um) >= 0.034um
 err1 = EXT LFN_N (ALL_GT_eqgt_070 NOT P2) < 0.034 ABUT<90 SINGULAR REGION MEASURE ALL
 err1 NOT INSIDE SealR_NOT_BULK
}

LFN_N_S_7b {
@ Space between LFN_N and (ALL_GT NOT P2) (ALL_GT width > 0.09um) >= 0.058um
 err1 = EXT LFN_N ALL_GT_NOT_P2_gt_090 < 0.058 ABUT<90 SINGULAR REGION MEASURE ALL
 err1 NOT INSIDE SealR_NOT_BULK
}

LFN_N_S_8 {
@ Space between LFN_N and (ALL_GT NOT P2) (ALL_GT width < 0.07um) in S/D direction >= 0.035um
 err1 = EXT ALL_GT_NOT_P2 LFN_N_v_edges < 0.035 ABUT<90 OPPOSITE REGION //;minimum
 err1 NOT INSIDE SealR_NOT_BULK
}

LFN_N_S_8a {
@ Space between LFN_N and (ALL_GT NOT P2) (ALL_GT width >= 0.07um) in S/D direction >= 0.058um
 err1 = EXT LFN_N_v_edges ALL_GT_NOT_P2_eqgt_070 < 0.058 ABUT<90 OPPOSITE REGION MEASURE ALL
 err1 NOT INSIDE SealR_NOT_BULK
}

LFN_N_S_9a {
@ Space between LFN_N and GATE (when channel length = 0.016/0.018/0.02um) respectively in S/D direction, (GATE CUT LFN_N is not allowed), except GT_P96 region >= 0.082/0.081/0.08um
 err1 = DFM COPY (DFM SPACE GATE_LE_16 LFN_N < 0.082 BY EXT HORIZONTAL MEASURE ALL) REGION
 err2 = DFM COPY (DFM SPACE GATE_LE_18 LFN_N < 0.081 BY EXT HORIZONTAL MEASURE ALL) REGION
 err3 = DFM COPY (DFM SPACE GATE_LE_20 LFN_N < 0.080 BY EXT HORIZONTAL MEASURE ALL) REGION
 err4 = GATE CUT LFN_N

 err1 NOT INSIDE GT_P96
 err2 NOT INSIDE GT_P96
 err3 NOT INSIDE GT_P96
 err4 NOT INSIDE GT_P96
}

LFN_N_S_9b {
@ Space between LFN_N and GATE (when channel length = 0.016/0.018/0.02/0.022/0.024um, INSIDE GT_P96) in S/D direction (GATE CUT LFN_N is not allowed) >= 0.088/0.087/0.086/0.085/0.084um
 err1 = DFM COPY (DFM SPACE GATE_LE_16_in_GT_P96 LFN_N < 0.088 BY EXT HORIZONTAL MEASURE ALL) REGION
 err2 = DFM COPY (DFM SPACE GATE_LE_18_in_GT_P96 LFN_N < 0.087 BY EXT HORIZONTAL MEASURE ALL) REGION
 err3 = DFM COPY (DFM SPACE GATE_LE_20_in_GT_P96 LFN_N < 0.086 BY EXT HORIZONTAL MEASURE ALL) REGION
 err4 = DFM COPY (DFM SPACE GATE_LE_22_in_GT_P96 LFN_N < 0.085 BY EXT HORIZONTAL MEASURE ALL) REGION
 err5 = DFM COPY (DFM SPACE GATE_LE_24_in_GT_P96 LFN_N < 0.084 BY EXT HORIZONTAL MEASURE ALL) REGION
 err6 = GATE CUT LFN_N

 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
 err4 NOT INSIDE SealR_NOT_BULK
 err5 NOT INSIDE SealR_NOT_BULK
 err6 NOT INSIDE SealR_NOT_BULK
}

LFN_N_S_10 {
@ Space between LFN_N vertical edge (edge length <= 0.238um between two concave corners with both sides length >= 0.09um) and ((GT AND GTMK1) OR GATE) in S/D direction >= 0.079um
 check_RAW = CONVEX EDGE LFN_N ANGLE1 == 270 LENGTH1 >= 0.09 ANGLE2 == 270 LENGTH2 >= 0.09 WITH LENGTH <= 0.238
 check_TMP = ANGLE check_RAW == 90
 err1 = EXT (OR GATE_raw GT_and_GTMK1) check_TMP < 0.079 ABUT<90 OPPOSITE REGION  //;including edge GATE
 err1 NOT INSIDE SealR_NOT_BULK
}

LFN_N_S_11 {
@ Space between LFN_N and (ALL_GT NOT P2) in GATE poly direction with adjacent horizontal space to (ALL_GT NOT P2) <= 0.04um (LFN_N vertical edge length = 0.073~0.150um,
@ between two consecutive 90-270 degree coners) >= 0.054um
 y1 = EXT [ALL_GT_NOT_P2] LFN_N_convex_90_270_eqgt_073_lteq_150_v_edges <= 0.040 ABUT<90 OPPOSITE
 y2 = EXT [LFN_N_h_edges] LFN_N_convex_90_270_eqgt_073_lteq_150_v_edges < 0.005 ABUT==90 INTERSECTING ONLY

 z1 = LFN_N_h_edges TOUCH EDGE y2
 z2 = EXT ALL_GT_NOT_P2 z1 < 0.054 ABUT<90 OPPOSITE REGION
 z3 = EXPAND EDGE y1 INSIDE BY 0.005 EXTEND BY 0.005
 err1 = z2 INTERACT z3
 err1 NOT INSIDE SealR_NOT_BULK
}

LFN_N_EX_1 {
@ LFN_N extension outside of ALL_AA (vertical edge abut AA edge is allowed) >= 0.045um
 CHECK_RAW = ENC ALL_AA LFN_N < 0.045 ABUT<90 SINGULAR
 WAIVE_CRN = LFN_N COIN INSIDE EDGE ALL_AA_v_edges
 err1 = DFM COPY (DFM PROPERTY CHECK_RAW WAIVE_CRN ABUT ALSO OVERLAP MULTI SPLIT [-= count(WAIVE_CRN)] == 0) REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

LFN_N_EX_2 {
@ LFN_N extension outside of ALL_AA in GATE poly direction >= 0.048um
 err1 = ENC ALL_AA_h_edges LFN_N < 0.048 ABUT<90 OPPOSITE REGION
 err2 = LFN_N_h_edges INSIDE EDGE ALL_AA
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE EDGE SealR_NOT_BULK
}

LFN_N_EX_3 {
@ LFN_N extension outside of (ALL_GT NOT P2) (ALL_GT width < 0.07um), except small ALL_GT jog <= 0.004um. >= 0.024um
 err1 = ENC ALL_GT_NOT_P2_not_jog_lteq_004 LFN_N < 0.024 ABUT<90 OPPOSITE REGION  //;minimum
 err1 NOT INSIDE SealR_NOT_BULK
}

LFN_N_EX_4 {
@ LFN_N extension outside of (ALL_GT NOT P2) (ALL_GT width >= 0.07um) >= 0.034um
 err1 = ENC ALL_GT_NOT_P2_eqgt_070 LFN_N < 0.034 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

LFN_N_EX_5 {
@ LFN_N extension outside of (ALL_GT NOT P2) (ALL_GT width > 0.09um) >= 0.058um
 err1 = ENC ALL_GT_NOT_P2_gt_090 LFN_N < 0.058 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

LFN_N_EX_6 {
@ LFN_N extension outside of (ALL_GT NOT P2) (ALL_GT width < 0.07um) in S/D direction >= 0.035um
 err1 = ENC ALL_GT_NOT_P2 LFN_N_v_edges < 0.035 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

LFN_N_EX_7 {
@ LFN_N extension outside of (ALL_GT NOT P2) (ALL_GT width >= 0.07um) in S/D direction >= 0.058um
 err1 = ENC ALL_GT_NOT_P2_eqgt_070 LFN_N_v_edges < 0.058 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

LFN_N_EX_8 {
@ LFN_N extension outside of GATE (when channel length = 0.016/0.018/0.02um) respectively in S/D direction, except GT_P96 region >= 0.082/0.081/0.080um
 err1 = DFM COPY (DFM SPACE GATE_LE_16 LFN_N < 0.082 BY ENC HORIZONTAL) REGION
 err2 = DFM COPY (DFM SPACE GATE_LE_18 LFN_N < 0.081 BY ENC HORIZONTAL) REGION
 err3 = DFM COPY (DFM SPACE GATE_LE_20 LFN_N < 0.080 BY ENC HORIZONTAL) REGION

 err1 NOT INSIDE GT_P96
 err2 NOT INSIDE GT_P96
 err3 NOT INSIDE GT_P96
}

LFN_N_EX_9 {
@ LFN_N extension outside of GATE (when channel length = 0.016/0.018/0.02/0.022/0.024um) respectively INSIDE GT_P96 in S/D direction >= 0.088/0.087/0.086/0.085/0.084um
 err1 = DFM COPY (DFM SPACE GATE_LE_16_in_GT_P96 LFN_N < 0.088 BY ENC HORIZONTAL) REGION
 err2 = DFM COPY (DFM SPACE GATE_LE_18_in_GT_P96 LFN_N < 0.087 BY ENC HORIZONTAL) REGION
 err3 = DFM COPY (DFM SPACE GATE_LE_20_in_GT_P96 LFN_N < 0.086 BY ENC HORIZONTAL) REGION
 err4 = DFM COPY (DFM SPACE GATE_LE_22_in_GT_P96 LFN_N < 0.085 BY ENC HORIZONTAL) REGION
 err5 = DFM COPY (DFM SPACE GATE_LE_24_in_GT_P96 LFN_N < 0.084 BY ENC HORIZONTAL) REGION

 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
 err4 NOT INSIDE SealR_NOT_BULK
 err5 NOT INSIDE SealR_NOT_BULK
}

LFN_N_EX_10 {
@ LFN_N (line-end vertical width <= 0.238um between two consecutive 90-90 degree corners with both sides length >= 0.09um) enclosure of ((GT AND GTMK1) OR GATE) in S/D direction >= 0.079um
 check_RAW = CONVEX EDGE LFN_N ANGLE1 == 90 LENGTH1 >= 0.09 ANGLE2 == 90 LENGTH2 >= 0.09 WITH LENGTH <= 0.238
 check_TMP = ANGLE check_RAW == 90
 err1 = ENC (OR GATE_raw GT_and_GTMK1) check_TMP < 0.079 ABUT<90 OPPOSITE REGION  //;including edge GATE
 err1 NOT INSIDE SealR_NOT_BULK
}

LFN_N_EX_11 {
@ LFN_N extension outside of (ALL_GT NOT P2) in GATE poly direction with adjacent horizontal enclosure <= 0.04um by LFN_N vertical edge (edge length = 0.073~0.15um, between two consecutive 90-270 degree corners) >= 0.054um
 y1 = ENC [ALL_GT_NOT_P2] LFN_N_convex_90_270_eqgt_073_lteq_150_v_edges <= 0.040 ABUT<90 OPPOSITE
 y2 = INT [LFN_N_h_edges] LFN_N_convex_90_270_eqgt_073_lteq_150_v_edges < 0.005 ABUT==90 INTERSECTING ONLY
 y3 = LFN_N_h_edges TOUCH EDGE y2
 y4 = ENC ALL_GT_NOT_P2 y3 < 0.054 ABUT<90 OPPOSITE REGION
 y5 = EXPAND EDGE y1 INSIDE BY 0.005 EXTEND BY 0.005
 err1 = y4 INTERACT y5
 err1 NOT INSIDE SealR_NOT_BULK
}

LFN_N_in_ALL_GT_h_edges = ANGLE (LFN_N NOT OUTSIDE EDGE ALL_GT) == 0
LFN_N_in_all_GT_in_ar_gtmk1_edges = LFN_N NOT OUTSIDE EDGE all_GT_in_ar_gtmk1
LFN_N_in_all_GT_in_ar_gtmk1_area = INT LFN_N_in_all_GT_in_ar_gtmk1_edges < 0.005 ABUT INTERSECTING ONLY REGION

LFN_N_EX_12 {
@ (ALL_GT NOT P2) extension outside of LFN_N, except small ALL_GT jogs <= 0.004um, Dummy_Cell_WO_IMP, and LFN_N vertical edge CUT (GTMK1 OR AR) (channel length <= 0.024um, centerline abut LFN_N vertical edge) >= 0.083um
//;Only need to check the vertical extension.
 y1 = LFN_N_in_all_GT_in_ar_gtmk1_edges COIN EDGE all_GT_center_even
 y2 = ANGLE (LFN_N_in_all_GT_in_ar_gtmk1_edges TOUCH EDGE (LFN_N_in_all_GT_in_ar_gtmk1_area WITH EDGE (LFN_N_in_all_GT_in_ar_gtmk1_area COIN EDGE y1))) == 0
 y3 = LFN_N_in_ALL_GT_h_edges NOT COIN EDGE y2
 err1 = ENC y3 ALL_GT_NOT_P2_not_jog_lteq_004 < 0.083 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE Dummy_Cell_WO_IMP
}

LFN_N_O_1 {
@ Overlap of (ALL_GT NOT P2) and LFN_N, except small ALL_GT jogs <= 0.004um, Dummy_Cell_WO_IMP, and LFN_N vertical edge CUT (GTMK1 OR AR) (channel length <= 0.024um, centerline abut LFN_N vertical edge) >= 0.083um
//;Only need to check the vertical overlap.
 y1 = LFN_N_in_all_GT_in_ar_gtmk1_edges COIN EDGE all_GT_center_even
 y2 = ANGLE (LFN_N_in_all_GT_in_ar_gtmk1_edges TOUCH EDGE (LFN_N_in_all_GT_in_ar_gtmk1_area WITH EDGE (LFN_N_in_all_GT_in_ar_gtmk1_area COIN EDGE y1))) == 0
 y3 = LFN_N_in_ALL_GT_h_edges NOT COIN EDGE y2
 err1 = INT y3 ALL_GT_NOT_P2_not_jog_lteq_004 < 0.083 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE Dummy_Cell_WO_IMP
}

LFN_N_A_1 {
@ LFN_N area >= 0.085um2
 err1 = AREA LFN_N < VT_MiniArea
 err1 NOT INSIDE SealR_NOT_BULK
}

LFN_N_A_2 {
@ LFN_N enclosed area >= 0.085um2
 err1 = AREA ((HOLES LFN_N INNER SINGULAR ALSO) NOT LFN_N) < VT_MiniArea
 err1 NOT INSIDE SealR_NOT_BULK
}

LFN_N_A_3 {
@ Area of ((ALL_GT NOT P2) AND LFN_N) >= 0.00158um2
 err1 = AREA (ALL_GT_NOT_P2 AND LFN_N) < 0.00158
 err1 NOT INSIDE SealR_NOT_BULK
}

LFN_N_R_1 {
@ (ALL_AA interact GT (width >= 0.032um)) CUT LFN_N is not allowed
 err1 = ALL_AA_INTERACT_GT_eqgt_032 CUT LFN_N
 err1 NOT INSIDE SealR_NOT_BULK
}

LFN_N_R_2 {
@ LFN_N overlap with P+AA, SVT_N, SVT_P, HVT_N, HVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_P, DG, PSUB, INST, RESNW, VARMOS, DMPNP, MARKS is not allowed, exclude OCCD region
 err1 = LFN_N AND (OR PACT SVT_N SVT_P HVT_N HVT_P LVT_N LVT_P ULVT_N ULVT_P LFN_P DG PSUB INST RESNW VARMOS DMPNP MARKS)
 err1 NOT INSIDE OCCD
}

LFN_N_R_3 {
@ (ALL_AA NOT AR) straddle on LFN_N horizontal edge is not allowed
 err1 = LFN_N_h_edges COIN EDGE ((LFN_N CUT ALL_AA_NOT_AR) INSIDE EDGE ALL_AA_NOT_AR)
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

// =======================================================
// LFN_P: design rules
// =======================================================

GROUP GLFN_P LFN_P_?

LFN_P_W_1 {
@ LFN_P width, single-point-interaction is allowed >= 0.192um
@ DRC waive:
@ 1) LFN_P one-track width within the range of 0.09~0.106um, 0.18~0.212um when PRL = 0um
@ 2) Jog width adjacent to edge (length <= 0.048um, between two consecutive 90-270 degree corners) = 0.18um in S/D direction
@ 3) Jog width adjacent to edge (length = 0.002um, between two consecutive 90-270 degree corners) = 0.135/0.144um in S/D direction
 y1 = INT [LFN_P] < 0.192 ABUT<90 OPPOSITE EXTENDED 0.001
 y2 = INT [LFN_P] < 0.192 CORNER
 y3 = INT [LFN_P_v_edges] >= 0.09 < 0.107 PROJ == 0
 y4 = INT [LFN_P_v_edges] >= 0.18 < 0.213 PROJ == 0
 y5 = INT [LFN_P_h_edges] >= 0.09 < 0.107 PROJ == 0
 y6 = INT [LFN_P_h_edges] >= 0.18 < 0.213 PROJ == 0
 y_all = (y3 OR EDGE y4) OR EDGE (y5 OR EDGE y6)

 waive_edges = LFN_P_90_90_jog_180_135_144 COIN EDGE LFN_P_h_edges
 waive_corner = INT [LFN_P_v_edges] waive_edges < 0.001 ABUT==90 INTERSECTING ONLY
 err1 = (y1 NOT COIN EDGE y_all) NOT TOUCH EDGE waive_corner
 err2 = (y2 COIN EDGE LFN_P_concave_corner) NOT TOUCH EDGE y_all
 err1 NOT INSIDE EDGE SealR_NOT_BULK
 err2 NOT INSIDE EDGE SealR_NOT_BULK
}

LFN_P_W_2 {
@ LFN_P width in S/D direction, single-point-interaction is allowed >= 0.27um
@ DRC waive:
@ 1) LFN_P one-track width within the range of 0.09~0.106um, 0.18~0.212um when PRL = 0um
@ 2) Jog width adjacent to edge (length <= 0.048um, between two consecutive 90-270 degree corners) = 0.18/0.192/0.225/0.24um in S/D direction
@ 3) Jog width adjacent to edge (length = 0.002um, between two consecutive 90-270 degree corners) = 0.135/0.144um in S/D direction
 y1 = INT [LFN_P_v_edges] < 0.27 ABUT<90 OPPOSITE EXTENDED 0.001
 y2 = INT [LFN_P_v_edges] >= 0.09 < 0.107 PROJ == 0
 y3 = INT [LFN_P_v_edges] >= 0.18 < 0.213 PROJ == 0
 y4 = y2 OR EDGE y3

 waive_corner = INT [LFN_P_v_edges] LFN_P_90_90_jog_180_192_225_240_135_144_h_edges < 0.001 ABUT==90 INTERSECTING ONLY
 err1 = (y1 NOT COIN EDGE y4) NOT TOUCH EDGE waive_corner
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

LFN_P_W_3 {
@ LFN_P width in S/D direction, when LFN_P vertical edge CUT (GTMK1 OR AR) and ABUT HVT_P >= 0.315um
@ DRC waive:
@ 1) Jog width adjacent to edge (length <= 0.048um, between two consecutive 90-270 degree corners) = 0.18/0.192/0.225/0.24um in S/D direction
@ 2) Jog width adjacent to edge (length = 0.002um, between two consecutive 90-270 degree corners) = 0.135/0.144um in S/D direction
 check_edges = (LFN_P_v_edges TOUCH EDGE (LFN_P_v_edges INSIDE EDGE gtmk1_or_ar)) COIN EDGE HVT_P
 waive_corner = INT LFN_P_v_edges LFN_P_90_90_jog_180_192_225_240_135_144_h_edges <= 0.001 ABUT==90 INTERSECTING ONLY REGION
 check_corner = LFN_P_v_edges NOT TOUCH EDGE waive_corner
 err1 = INT check_edges check_corner < 0.315 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

LFN_P_W_4 {
@ LFN_P width in GATE poly direction when LFN_P point touch or horizontal width in the range of 0.09~0.106um, 0.18~0.212um while PRL = 0um in GATE poly direction (except L-shape/T-shape concave corner) >= 0.238um
 err1 = INT (LFN_P_h_edges_singular_point COIN EDGE LFN_P_concave_corner) LFN_P_h_edges < 0.238 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK

 y1 = LFN_P_convex_eqlt_1_edges COIN EDGE LFN_P_h_edges
 y2 = LFN_P COIN EDGE (EXPAND EDGE (y1 COIN EDGE LFN_P_concave_corner) INSIDE BY 0.001 OUTSIDE BY 0.001)
 y3 = INT [y2] >= 0.09 <= 0.106+0.0005 ABUT<90 PROJ == 0
 y4 = INT [y2] >= 0.18 <= 0.212+0.0005 ABUT<90 PROJ == 0
 y5 = LFN_P_concave_corner WITH EDGE (LFN_P_concave_corner COIN EDGE (y3 OR EDGE y4))
 y6 = LFN_P_h_edges COIN EDGE y5
 err2 = INT LFN_P_h_edges y6 < 0.238 ABUT<90 OPPOSITE REGION
 err3 = (LENGTH ((LFN_P_v_edges TOUCH EDGE y5) TOUCH EDGE LFN_P_convex_eq_1_edges) < 0.238) EXPAND EDGE INSIDE BY 0.001
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
}

LFN_P_S_1 {
@ Space between LFN_P, single-point-interaction is allowed >= 0.192um
@ DRC waive:
@ 1) LFN_P one-track space within the range of 0.09~0.106um, 0.18~0.212um when PRL = 0um
@ 2) Jog space adjacent to edge (length <= 0.048um, between two consecutive 90-270 degree corners) = 0.18um in S/D direction
@ 3) Jog space adjacent to edge (length = 0.002um, between two consecutive 90-270 degree corners) = 0.135/0.144um in S/D direction
 y1 = EXT [LFN_P] < 0.192 ABUT<90 OPPOSITE EXTENDED 0.001
 y2 = EXT [LFN_P] < 0.192 CORNER
 y3 = EXT [LFN_P_v_edges] >= 0.09 < 0.107 PROJ == 0
 y4 = EXT [LFN_P_v_edges] >= 0.18 < 0.213 PROJ == 0
 y5 = EXT [LFN_P_h_edges] >= 0.09 < 0.107 PROJ == 0
 y6 = EXT [LFN_P_h_edges] >= 0.18 < 0.213 PROJ == 0
 y_all = (y3 OR EDGE y4) OR EDGE (y5 OR EDGE y6)
 w_all = LFN_P_rvs_90_90_jog_180_135_144 OR EDGE LFN_P_90_90_jog_180_135_144

 z1 = w_all COIN EDGE LFN_P_h_edges
 z2 = LFN_P_rvs COIN EDGE LFN_P_v_edges
 z3 = INT [z2] z1 < 0.005 ABUT==90 INTERSECTING ONLY
 err1 = (y1 NOT COIN EDGE y_all) NOT TOUCH EDGE z3
 err2 = (y2 COIN EDGE LFN_P_convex_corner) NOT COIN EDGE y_all
 err1 NOT INSIDE EDGE SealR_NOT_BULK
 err2 NOT INSIDE EDGE SealR_NOT_BULK
}

LFN_P_S_2 {
@ Space between LFN_P in S/D direction, single-point-interaction is allowed >= 0.27um
@ DRC waive:
@ 1) LFN_P one-track space within the range of 0.09~0.106um, 0.18~0.212um when PRL = 0um
@ 2) Jog space adjacent to edge (length <= 0.048um, between two consecutive 90-270 degree corners) = 0.180/0.192/0.225/0.24um in S/D direction
@ 3) Jog space adjacent to edge (length = 0.002um, between two consecutive 90-270 degree corners) = 0.135/0.144um in S/D direction
 w_all = LFN_P_90_90_jog_180_192_225_240_135_144 OR EDGE LFN_P_rvs_90_90_jog_180_192_225_240_135_144
 y1 = ANGLE (EXT [LFN_P] < 0.27 ABUT<90 OPPOSITE EXTENDED 0.001) == 90
 y2 = EXT [LFN_P_v_edges] >= 0.09 < 0.107 PROJ == 0
 y3 = EXT [LFN_P_v_edges] >= 0.18 < 0.213 PROJ == 0
 y4 = y2 OR EDGE y3

 z1 = ANGLE LFN_P_rvs == 0
 z2 = w_all COIN EDGE z1
 z3 = ANGLE LFN_P_rvs == 90
 z4 = INT [z3] z2 < 0.001 ABUT==90 INTERSECTING ONLY
 err1 = (y1 NOT COIN EDGE y4) NOT TOUCH EDGE z4
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

LFN_P_S_3a {
@ Space between LFN_P in S/D direction, when just one LFN_P vertical edge CUT (GTMK1 OR AR) and abut LVT_P or ULVT_P >= 0.315um
@ DRC waive:
@ 1) Jog space adjacent to edge (length <= 0.048um, between two consecutive 90-270 degree corners) = 0.180/0.192/0.225/0.24um in S/D direction
@ 2) Jog space adjacent to edge (length = 0.002um, between two consecutive 90-270 degree corners) = 0.135/0.144um in S/D direction
 check_edges = (LFN_P_inside_AA_side_mark_v_edges TOUCH EDGE LVT_P) OR EDGE (LFN_P_inside_AA_side_mark_v_edges TOUCH EDGE ULVT_P)
 waive_corner = EXT LFN_P_270_270_jog_180_192_225_240_135_144_h_edges check_edges <= 0.001 ABUT==90 INTERSECTING ONLY REGION
 check_corner = check_edges NOT TOUCH EDGE waive_corner
 err1 = EXT check_corner LFN_P_v_edges < 0.315 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

LFN_P_S_3b {
@ Space between LFN_P in S/D direction, when both LFN_P’s vertical edges CUT (GTMK1 OR AR) and abut LVT_P or ULVT_P >= 0.36um
@ DRC waive:
@ 1) Jog space adjacent to edge (length <= 0.048um, between two consecutive 90-270 degree corners) = 0.180/0.192/0.225/0.24um in S/D direction
@ 2) Jog space adjacent to edge (length = 0.002um, between two consecutive 90-270 degree corners) = 0.135/0.144um in S/D direction
 check_edges = (LFN_P_inside_AA_side_mark_v_edges TOUCH EDGE LVT_P) OR EDGE (LFN_P_inside_AA_side_mark_v_edges TOUCH EDGE ULVT_P)
 waive_corner = EXT LFN_P_270_270_jog_180_192_225_240_135_144_h_edges check_edges <= 0.001 ABUT==90 INTERSECTING ONLY REGION
 check_corner = check_edges NOT TOUCH EDGE waive_corner
 err1 = EXT check_corner < 0.36 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

LFN_P_S_4 {
@ Space between LFN_P when PRL >= 0.29um. >= 0.248um
 Layer_area = EXT LFN_P < 0.248 OPPOSITE REGION
 err1 = Layer_area ENCLOSE RECTANGLE 0.001 0.29 ORTHOGONAL ONLY
 err1 NOT INSIDE SealR_NOT_BULK
}

LFN_P_S_5 {
@ Space between LFN_P in GATE poly direction when LFN_P point touch or horizontal width in the range of 0.09~0.106um, 0.18~0.212um while PRL = 0um in GATE poly direction >= 0.238um
 err1 = EXT LFN_P_h_edges_singular_point LFN_P_h_edges < 0.238 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK

 y1 = LFN_P_convex_eqlt_1_edges COIN EDGE LFN_P_h_edges
 y2 = LFN_P COIN EDGE (EXPAND EDGE (y1 COIN EDGE LFN_P_concave_corner) INSIDE BY 0.001 OUTSIDE BY 0.001)
 y3 = INT [y2] >= 0.09 <= 0.106+0.0005 ABUT<90 PROJ == 0
 y4 = INT [y2] >= 0.18 <= 0.212+0.0005 ABUT<90 PROJ == 0
 y5 = LFN_P_concave_corner WITH EDGE (LFN_P_concave_corner COIN EDGE (y3 OR EDGE y4))
 y6 = LFN_P_h_edges TOUCH EDGE y5
 err2 = EXT LFN_P_h_edges y6 < 0.238 ABUT<90 OPPOSITE REGION
 err3 = (LENGTH ((LFN_P_v_edges TOUCH EDGE y5) TOUCH EDGE LFN_P_convex_eq_0_edges) < 0.238) EXPAND EDGE INSIDE BY 0.002
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
}

LFN_P_S_6 {
@ Space between LFN_P and ALL_AA (vertical edge abut AA edge is allowed) >= 0.045um
 CHECK_RAW = EXT LFN_P ALL_AA < 0.045 ABUT<90 SINGULAR
 WAIVE_CRN = LFN_P COIN OUTSIDE EDGE ALL_AA_v_edges
 err1 = DFM COPY (DFM PROPERTY CHECK_RAW WAIVE_CRN ABUT ALSO OVERLAP MULTI SPLIT [-= count(WAIVE_CRN)] == 0) REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

LFN_P_S_6a {
@ Space between LFN_P and ALL_AA in GATE poly direction >= 0.048um
 err1 = EXT LFN_P ALL_AA_h_edges < 0.048 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

LFN_P_S_7 {
@ Space between LFN_P and (ALL_GT NOT P2) (ALL_GT width < 0.07um), except small ALL_GT jog <= 0.004um. >= 0.024um
 err1 = EXT LFN_P ALL_GT_NOT_P2_not_jog_lteq_004 < 0.024 ABUT<90 REGION MEASURE ALL  //;minimum
 err1 NOT INSIDE SealR_NOT_BULK
}

LFN_P_S_7a {
@ Space between LFN_P and (ALL_GT NOT P2) (ALL_GT width >= 0.07um) >= 0.034um
 err1 = EXT LFN_P (ALL_GT_eqgt_070 NOT P2) < 0.034 ABUT<90 SINGULAR REGION MEASURE ALL
 err1 NOT INSIDE SealR_NOT_BULK
}

LFN_P_S_7b {
@ Space between LFN_P and (ALL_GT NOT P2) (ALL_GT width > 0.09um) >= 0.058um
 err1 = EXT LFN_P ALL_GT_NOT_P2_gt_090 < 0.058 ABUT<90 SINGULAR REGION MEASURE ALL
 err1 NOT INSIDE SealR_NOT_BULK
}

LFN_P_S_8 {
@ Space between LFN_P and (ALL_GT NOT P2) (ALL_GT width < 0.07um) in S/D direction >= 0.035um
 err1 = EXT ALL_GT_NOT_P2 LFN_P_v_edges < 0.035 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

LFN_P_S_8a {
@ Space between LFN_P and (ALL_GT NOT P2) (ALL_GT width >= 0.07um) in S/D direction >= 0.058um
 err1 = EXT LFN_P_v_edges ALL_GT_NOT_P2_eqgt_070 < 0.058 ABUT<90 OPPOSITE REGION MEASURE ALL
 err1 NOT INSIDE SealR_NOT_BULK
}

LFN_P_S_9a {
@ Space between LFN_P and GATE (when channel length = 0.016/0.018/0.02um) respectively in S/D direction (GATE CUT LFN_P is not allowed), except GT_P96 region >= 0.082/0.081/0.08um
 err1 = DFM COPY (DFM SPACE GATE_LE_16 LFN_P < 0.082 BY EXT HORIZONTAL MEASURE ALL) REGION
 err2 = DFM COPY (DFM SPACE GATE_LE_18 LFN_P < 0.081 BY EXT HORIZONTAL MEASURE ALL) REGION
 err3 = DFM COPY (DFM SPACE GATE_LE_20 LFN_P < 0.080 BY EXT HORIZONTAL MEASURE ALL) REGION
 err4 = GATE CUT LFN_P

 err1 NOT INSIDE GT_P96
 err2 NOT INSIDE GT_P96
 err3 NOT INSIDE GT_P96
 err4 NOT INSIDE GT_P96
}

LFN_P_S_9b {
@ Space between LFN_P and GATE (when channel length = 0.016/0.018/0.02/0.022/0.024um, INSIDE GT_P96) in S/D direction (GATE CUT LFN_P is not allowed) >= 0.088/0.087/0.086/0.085/0.084um
 err1 = DFM COPY (DFM SPACE GATE_LE_16_in_GT_P96 LFN_P < 0.088 BY EXT HORIZONTAL MEASURE ALL) REGION
 err2 = DFM COPY (DFM SPACE GATE_LE_18_in_GT_P96 LFN_P < 0.087 BY EXT HORIZONTAL MEASURE ALL) REGION
 err3 = DFM COPY (DFM SPACE GATE_LE_20_in_GT_P96 LFN_P < 0.086 BY EXT HORIZONTAL MEASURE ALL) REGION
 err4 = DFM COPY (DFM SPACE GATE_LE_22_in_GT_P96 LFN_P < 0.085 BY EXT HORIZONTAL MEASURE ALL) REGION
 err5 = DFM COPY (DFM SPACE GATE_LE_24_in_GT_P96 LFN_P < 0.084 BY EXT HORIZONTAL MEASURE ALL) REGION
 err6 = GATE CUT LFN_P

 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
 err4 NOT INSIDE SealR_NOT_BULK
 err5 NOT INSIDE SealR_NOT_BULK
 err6 NOT INSIDE SealR_NOT_BULK
}

LFN_P_S_10 {
@ Space between LFN_P vertical edge (edge length <= 0.238um between two concave corners with both sides length >= 0.09um) and ((GT AND GTMK1) OR GATE) in S/D direction >= 0.079um
 check_RAW = CONVEX EDGE LFN_P ANGLE1 == 270 LENGTH1 >= 0.09 ANGLE2 == 270 LENGTH2 >= 0.09 WITH LENGTH <= 0.238
 check_TMP = ANGLE check_RAW == 90
 err1 = EXT (OR GATE_raw GT_and_GTMK1) check_TMP < 0.079 ABUT<90 OPPOSITE REGION  //;including edge GATE
 err1 NOT INSIDE SealR_NOT_BULK
}

LFN_P_S_11 {
@ Space between LFN_P and (ALL_GT NOT P2) in GATE poly direction with adjacent horizontal space <= 0.04um (LFN_P vertical edge length = 0.073~0.15um, between two consecutive 90-270 degree coners) >= 0.054um
 y1 = EXT [ALL_GT_NOT_P2] LFN_P_convex_90_270_eqgt_073_lteq_150_v_edges <= 0.040 ABUT<90 OPPOSITE
 y2 = EXT [LFN_P_h_edges] LFN_P_convex_90_270_eqgt_073_lteq_150_v_edges < 0.005 ABUT==90 INTERSECTING ONLY

 z1 = LFN_P_h_edges TOUCH EDGE y2
 z2 = EXT ALL_GT_NOT_P2 z1 < 0.054 ABUT<90 OPPOSITE REGION
 z3 = EXPAND EDGE y1 INSIDE BY 0.005 EXTEND BY 0.005
 err1 = z2 INTERACT z3
 err1 NOT INSIDE SealR_NOT_BULK
}

LFN_P_EX_1 {
@ LFN_P extension outside of ALL_AA (vertical edge abut AA edge is allowed) >= 0.045um
 CHECK_RAW = ENC ALL_AA LFN_P < 0.045 ABUT<90 SINGULAR
 WAIVE_CRN = LFN_P COIN INSIDE EDGE ALL_AA_v_edges
 err1 = DFM COPY (DFM PROPERTY CHECK_RAW WAIVE_CRN ABUT ALSO OVERLAP MULTI SPLIT [-= count(WAIVE_CRN)] == 0) REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

LFN_P_EX_2 {
@ LFN_P extension outside of ALL_AA in GATE poly direction >= 0.048um
 err1 = ENC ALL_AA_h_edges LFN_P < 0.048 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

LFN_P_EX_3 {
@ LFN_P extension outside of (ALL_GT NOT P2) (ALL_GT width < 0.07um), except small ALL_GT jog <= 0.004um. >= 0.024um
 err1 = ENC ALL_GT_NOT_P2_not_jog_lteq_004 LFN_P < 0.024 ABUT<90 OPPOSITE REGION  //;minimum
 err1 NOT INSIDE SealR_NOT_BULK
}

LFN_P_EX_4 {
@ LFN_P extension outside of (ALL_GT NOT P2) (ALL_GT width >= 0.07um) >= 0.034um
 err1 = ENC ALL_GT_NOT_P2_eqgt_070 LFN_P < 0.034 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

LFN_P_EX_5 {
@ LFN_P extension outside of (ALL_GT NOT P2) (ALL_GT width > 0.09um) >= 0.058um
 err1 = ENC ALL_GT_NOT_P2_gt_090 LFN_P < 0.058 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

LFN_P_EX_6 {
@ LFN_P extension outside of (ALL_GT NOT P2) (ALL_GT width < 0.07um) in S/D direction >= 0.035um
 err1 = ENC ALL_GT_NOT_P2 LFN_P_v_edges < 0.035 ABUT<90 OPPOSITE REGION  //;minimum
 err1 NOT INSIDE SealR_NOT_BULK
}

LFN_P_EX_7 {
@ LFN_P extension outside of (ALL_GT NOT P2) (ALL_GT width >= 0.07um) in S/D direction >= 0.058um
 err1 = ENC ALL_GT_NOT_P2_eqgt_070 LFN_P_v_edges < 0.058 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

LFN_P_EX_8 {
@ LFN_P extension outside of GATE (when channel length = 0.016/0.018/0.02um) respectively in S/D direction, except GT_P96 region >= 0.082/0.081/0.080um
 err1 = DFM COPY (DFM SPACE GATE_LE_16 LFN_P < 0.082 BY ENC HORIZONTAL) REGION
 err2 = DFM COPY (DFM SPACE GATE_LE_18 LFN_P < 0.081 BY ENC HORIZONTAL) REGION
 err3 = DFM COPY (DFM SPACE GATE_LE_20 LFN_P < 0.080 BY ENC HORIZONTAL) REGION

 err1 NOT INSIDE GT_P96
 err2 NOT INSIDE GT_P96
 err3 NOT INSIDE GT_P96
}

LFN_P_EX_9 {
@ LFN_P extension outside of GATE (when channel length = 0.016/0.018/0.02/0.022/0.024um, INSIDE GT_P96) in S/D direction >= 0.088/0.087/0.086/0.085/0.084um
 err1 = (DFM COPY (DFM SPACE GATE_LE_16 LFN_P < 0.088 BY ENC HORIZONTAL) REGION) NOT OUTSIDE GT_P96
 err2 = (DFM COPY (DFM SPACE GATE_LE_18 LFN_P < 0.087 BY ENC HORIZONTAL) REGION) NOT OUTSIDE GT_P96
 err3 = (DFM COPY (DFM SPACE GATE_LE_20 LFN_P < 0.086 BY ENC HORIZONTAL) REGION) NOT OUTSIDE GT_P96
 err4 = (DFM COPY (DFM SPACE GATE_LE_22 LFN_P < 0.085 BY ENC HORIZONTAL) REGION) NOT OUTSIDE GT_P96
 err5 = (DFM COPY (DFM SPACE GATE_LE_24 LFN_P < 0.084 BY ENC HORIZONTAL) REGION) NOT OUTSIDE GT_P96

 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
 err4 NOT INSIDE SealR_NOT_BULK
 err5 NOT INSIDE SealR_NOT_BULK
}

LFN_P_EX_10 {
@ LFN_P (line-end vertical width <= 0.238um between two consecutive 90-90 degree corners with both sides length >= 0.09um) enclosure of ((GT AND GTMK1) OR GATE) in S/D direction >= 0.079um
 check_RAW = CONVEX EDGE LFN_P ANGLE1 == 90 LENGTH1 >= 0.09 ANGLE2 == 90 LENGTH2 >= 0.09 WITH LENGTH <= 0.238
 check_TMP = ANGLE check_RAW == 90
 err1 = ENC (OR GATE_raw GT_and_GTMK1) check_TMP < 0.079 ABUT<90 OPPOSITE REGION  //;including edge GATE
 err1 NOT INSIDE SealR_NOT_BULK
}

LFN_P_EX_11 {
@ LFN_P extension outside of (ALL_GT NOT P2) in GATE poly direction with adjacent horizontal enclosure <= 0.04um by LFN_P vertical edge (edge length = 0.073~0.15um, between two consecutive 90-270 degree corners) >= 0.054um
 y1 = ENC [ALL_GT_NOT_P2] LFN_P_convex_90_270_eqgt_073_lteq_150_v_edges <= 0.040 ABUT<90 OPPOSITE
 y2 = INT [LFN_P_h_edges] LFN_P_convex_90_270_eqgt_073_lteq_150_v_edges < 0.005 ABUT==90 INTERSECTING ONLY
 y3 = LFN_P_h_edges TOUCH EDGE y2
 y4 = ENC ALL_GT_NOT_P2 y3 < 0.054 ABUT<90 OPPOSITE REGION
 y5 = EXPAND EDGE y1 INSIDE BY 0.005 EXTEND BY 0.005
 err1 = y4 INTERACT y5
 err1 NOT INSIDE SealR_NOT_BULK
}

LFN_P_in_ALL_GT_h_edges = ANGLE (LFN_P NOT OUTSIDE EDGE ALL_GT) == 0
LFN_P_in_all_GT_in_ar_gtmk1_edges = LFN_P NOT OUTSIDE EDGE all_GT_in_ar_gtmk1
LFN_P_in_all_GT_in_ar_gtmk1_area = INT LFN_P_in_all_GT_in_ar_gtmk1_edges < 0.005 ABUT INTERSECTING ONLY REGION

LFN_P_EX_12 {
@ (ALL_GT NOT P2) extension outside of LFN_P, except small ALL_GT jogs <= 0.004um, Dummy_Cell_WO_IMP, and LFN_P vertical edge CUT (GTMK1 OR AR) (channel length <= 0.024um, centerline abut LFN_P vertical edge) >= 0.083um
//;Only need to check the vertical extension.
 y1 = LFN_P_in_all_GT_in_ar_gtmk1_edges COIN EDGE all_GT_center_even
 y2 = ANGLE (LFN_P_in_all_GT_in_ar_gtmk1_edges TOUCH EDGE (LFN_P_in_all_GT_in_ar_gtmk1_area WITH EDGE (LFN_P_in_all_GT_in_ar_gtmk1_area COIN EDGE y1))) == 0
 y3 = LFN_P_in_ALL_GT_h_edges NOT COIN EDGE y2
 err1 = ENC y3 ALL_GT_NOT_P2_not_jog_lteq_004 < 0.083 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE Dummy_Cell_WO_IMP
}

LFN_P_O_1 {
@ Overlap of (ALL_GT NOT P2) and LFN_P, except small ALL_GT jogs <= 0.004um, Dummy_Cell_WO_IMP, and LFN_P vertical edge CUT (GTMK1 OR AR) (channel length <= 0.024um, centerline abut LFN_P vertical edge) >= 0.083um
//;Only need to check the vertical overlap.
 y1 = LFN_P_in_all_GT_in_ar_gtmk1_edges COIN EDGE all_GT_center_even
 y2 = ANGLE (LFN_P_in_all_GT_in_ar_gtmk1_edges TOUCH EDGE (LFN_P_in_all_GT_in_ar_gtmk1_area WITH EDGE (LFN_P_in_all_GT_in_ar_gtmk1_area COIN EDGE y1))) == 0
 y3 = LFN_P_in_ALL_GT_h_edges NOT COIN EDGE y2
 err1 = INT y3 ALL_GT_NOT_P2_not_jog_lteq_004 < 0.083 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE Dummy_Cell_WO_IMP
}

LFN_P_A_1 {
@ LFN_P area >= 0.085um2
 err1 = AREA LFN_P < VT_MiniArea
 err1 NOT INSIDE SealR_NOT_BULK
}

LFN_P_A_2 {
@ LFN_P enclosed area >= 0.085um2
 err1 = AREA ((HOLES LFN_P INNER SINGULAR ALSO) NOT LFN_P) < VT_MiniArea
 err1 NOT INSIDE SealR_NOT_BULK
}

LFN_P_A_3 {
@ Area of ((ALL_GT NOT P2) AND LFN_P) >= 0.00158um2
 err1 = AREA (ALL_GT_NOT_P2 AND LFN_P) < 0.00158
 err1 NOT INSIDE SealR_NOT_BULK
}

LFN_P_R_1 {
@ (ALL_AA interact GT (width >= 0.032um)) CUT LFN_P is not allowed
 err1 = ALL_AA_INTERACT_GT_eqgt_032 CUT LFN_P
 err1 NOT INSIDE SealR_NOT_BULK
}

LFN_P_R_2 {
@ LFN_P overlap with N+AA, SVT_N, SVT_P, HVT_N, HVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, DG, PSUB, INST, RESNW, VARMOS, DMPNP, MARKS is not allowed, exclude OCCD region
 err1 = LFN_P AND (OR NACT SVT_N SVT_P HVT_N HVT_P LVT_N LVT_P ULVT_N ULVT_P LFN_N DG PSUB INST RESNW VARMOS DMPNP MARKS)
 err1 NOT INSIDE OCCD
}

LFN_P_R_3 {
@ (ALL_AA NOT AR) straddle on LFN_P horizontal edge is not allowed
 err1 = LFN_P_h_edges COIN EDGE ((LFN_P CUT ALL_AA_NOT_AR) INSIDE EDGE ALL_AA_NOT_AR)
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

// =======================================================
// DG - Dual Gate DRC
// =======================================================

GROUP GDG DG_?

DG_W_1 {
@ DG width >= 0.286um
 err1 = INT DG < 0.286 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

DG_S_1 {
@ Space between two DGs >= 0.286um
 err1 = EXT DG < 0.286 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

DG_S_2a {
@ Space between DG and GATE along the S/D direction >= 0.313um
 err1 = EXT DG_v_edges GATE < 0.313 ABUT<90 OPPOSITE REGION  //;based on DG.S.1
 err2 = DG_v_edges COIN OUTSIDE EDGE GATE
 err3 = DG INTERACT GATE SINGULAR ONLY

 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE EDGE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
}

DG_S_2b {
@ Space between DG and AA (AA cut DG is not allowed), except pick-up AA >= 0.098um
 err1 = EXT DG AA_NOT_TAP < 0.098 ABUT<90 SINGULAR REGION
 err2 = AA CUT DG
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

DG_S_2c {
@ Space between DG and AA (AA vertical edge extend 1/2 GT width) in S/D direction (AA cut DG is not allowed), except pick-up AA >= 0.116um
 chk_AA = AA_NOT_TAP OR (edge_gate_AA_uGT NOT INTERACT TAP_RAW)
 err1 = EXT DG_v_edges chk_AA < 0.116 ABUT<90 OPPOSITE REGION
 err2 = chk_AA CUT DG
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

DG_S_2d {
@ Space between DG and DUM_AA (DUM_AA cut DG is not allowed) >= 0.053um
 err1 = EXT DG DUM_AA < 0.053 ABUT<90 SINGULAR REGION
 err2 = DUM_AA CUT DG
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

DG_S_2e {
@ Space between DG and DUM_AA (AA vertical edge extend 1/2 GT width) in S/D direction (DUM_AA cut DG is not allowed) >= 0.07um
 chk_AA = DUM_AA OR edge_gate_dumAA
 err1 = EXT DG_v_edges chk_AA < 0.07 ABUT<90 OPPOSITE REGION
 err2 = DUM_AA CUT DG
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

DG_S_3 {
@ Space between DG and NW (space = 0 is allowed) >= 0.238um
 err1 = EXT DG NW < 0.238 ABUT>0<90 SINGULAR REGION  //;MEASURE ALL, based on DG.S.1, DG.EN.2
 err1 NOT INSIDE SealR_NOT_BULK
}

DG_EN_1a {
@ DG enclosure of GATE along the S/D direction >= 0.313um
 err1 = ENC (GATE AND DG) DG_v_edges < 0.313 ABUT<90 OPPOSITE REGION
 err2 = ENC GATE DG < 0.001 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

DG_EN_1b {
@ DG enclosure of AA, except pick-up AA >= 0.098um
 err1 = ENC (AA_NOT_TAP AND DG) DG < 0.098 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

DG_EN_1c {
@ DG enclosure of AA (AA vertical edge extend 1/2 GT width) in S/D direction, except pick-up AA >= 0.116um
 chk_AA = AA_NOT_TAP OR (edge_gate_AA_uGT NOT INTERACT TAP_RAW)
 err1 = ENC (chk_AA AND DG) DG_v_edges < 0.116 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

DG_EN_1d {
@ DG enclosure of DUM_AA >= 0.053um
 err1 = ENC (DUM_AA AND DG) DG < 0.053 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

DG_EN_1e {
@ DG enclosure of DUM_AA (AA vertical edge extend 1/2 GT width) in S/D direction >= 0.07um
 chk_AA = DUM_AA OR edge_gate_dumAA
 err1 = ENC chk_AA DG_v_edges < 0.07 ABUT<90 OPPOSITE REGION EXCLUDE SHIELDED
 err1 NOT INSIDE SealR_NOT_BULK
}

DG_EN_2a {
@ DG extension outside of NW (extension = 0um is allowed) >= 0.238um
 err1 = ENC NW DG < 0.238 ABUT>0<90 SINGULAR REGION
 err2 = ENC DG NW < 0.001 ABUT>0<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

DG_EN_2b {
@ DG enclosure by NW (enclosure = 0um is allowed) >= 0.238um
 err1 = ENC DG NW < 0.238 ABUT>0<90 SINGULAR REGION
 err2 = ENC NW DG < 0.001 ABUT>0<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

DG_O_1 {
@ DG overlap of NW (abut is allowed) >= 0.238um
 err1 = INT DG NW < 0.238 ABUT>0<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

DG_A_1 {
@ DG area >= 0.32um2
 err1 = AREA DG < 0.32
 err1 NOT INSIDE SealR_NOT_BULK
}

DG_A_2 {
@ DG enclosed area >= 0.32um2
 err1 = AREA ((HOLES DG INNER) NOT DG) < 0.32
 err1 NOT INSIDE SealR_NOT_BULK
}

DG_R_1 {
@ 1.8V, 1.2V and 1.5V GATE cannot inside the same NW
 nw_18v_gate = NW INTERACT GATE_18
 nw_12v_gate = NW INTERACT GATE_12
 nw_15v_gate = NW INTERACT GATE_15

 err1 = AND nw_18v_gate nw_12v_gate
 err2 = AND nw_18v_gate nw_15v_gate
 err3 = AND nw_12v_gate nw_15v_gate
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
}

DG_R_2 {
@ (GATE AND DGUD), (GATE AND DGV) must inside DG
 err1 = (GATE AND DGUD) NOT DG
 err2 = (GATE AND DGV) NOT DG
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

DG_R_3 {
@ GATE cut DG, DGUD or DGV is not allowed
 err1 = GATE CUT DG
 err2 = GATE CUT DGUD
 err3 = GATE CUT DGV
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
}

DG_R_4 {
@ AOP_GT CUT DGV is not allowed
 err1 = DGV INSIDE EDGE (AOP_GT CUT DGV)
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

DG_R_5 {
@ DGUD overlap DGV is not allowed
 err1 = DGUD AND DGV
 err1 NOT INSIDE SealR_NOT_BULK
}

DG_R_6 {
@ (DGV or DGUD) overlap VARMOS is not allowed
 err1 = DGV AND VARMOS
 err2 = DGUD AND VARMOS
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}


// =======================================================
// GT - GT design rules
// =======================================================

GROUP GGT GT_?

AA_and_AOP_GT_el_024 = AA AND AOP_GT_eqlt_024
AA_and_AOP_GT_gt_024 = AA AND AOP_GT_gt_024

AA_with_GT_lt_024_gt_024 = (AA INTERACT AA_and_AOP_GT_el_024) INTERACT AA_and_AOP_GT_gt_024 //; AA with AOP_GT > 0.024 and <= 0.024
AA_with_GT_lt_024 = (AA INTERACT AA_and_AOP_GT_el_024) NOT INTERACT AA_and_AOP_GT_gt_024 //; AA with AOP_GT <= 0.024 only

#IFDEF DFM_RULES_PRIORITY_1 YES
GT_R_4_DFM1 {
@ Recommend width of AOP_GT (width <= 0.024um INTERACT the same AA) must be the same, except INST region
@ DRC flag AOP_GT width not equal on same AA when there has at least one AOP_GT width <= 0.024um
 chk_SD = AA_with_GT_lt_024 NOT AOP_GT
 err1 = (chk_SD INTERACT AOP_GT_014) INTERACT (OR AOP_GT_016 AOP_GT_018 AOP_GT_020 AOP_GT_022 AOP_GT_024)
 err2 = (chk_SD INTERACT AOP_GT_016) INTERACT (OR AOP_GT_018 AOP_GT_020 AOP_GT_022 AOP_GT_024)
 err3 = (chk_SD INTERACT AOP_GT_018) INTERACT (OR AOP_GT_020 AOP_GT_022 AOP_GT_024)
 err4 = (chk_SD INTERACT AOP_GT_020) INTERACT (OR AOP_GT_022 AOP_GT_024)
 err5 = (chk_SD INTERACT AOP_GT_022) INTERACT AOP_GT_024
 err6 = AOP_GT_gt_024 AND AA_with_GT_lt_024_gt_024  //;with greater that 0.024

 err1 NOT INSIDE INST
 err2 NOT INSIDE INST
 err3 NOT INSIDE INST
 err4 NOT INSIDE INST
 err5 NOT INSIDE INST
 err6 NOT INSIDE INST
}
#ENDIF

#IFDEF DFM_RULES_PRIORITY_2 YES
GT_R_20_DFM2 {
@ GT abut with EMPTY_GT region in S/D direction is not allowed when meet either one of below condition
@ EMPTY_GT region definition:
@ ((chip NOT ALL_GT) sd 0.125um) su 0.125um) with one horizontal edge length > 0.35um and vertical edge length >= 0.25um
@ 1) (ALL_GT NOT P2) width <= 0.2um and area <= 0.0055um2
@ 2) (ALL_GT NOT P2) abut EMPTY_GT length in GATE poly direction >= 0.25um
 EMPTY_GT_TMP = SIZE (DRC:1 NOT ALL_GT) BY 0.125 UNDEROVER
 EMPTY_GT = EMPTY_GT_TMP WITH EDGE (ANGLE (LENGTH EMPTY_GT_TMP > 0.350) == 0)

 RISK_GT_0 = (AOP_GT WITH WIDTH <= 0.20) NOT P2
 RISK_GT_1 = AREA RISK_GT_0 <= 0.0055
 RISK_GT_2 = LENGTH (RISK_GT_0 COIN EDGE EMPTY_GT) >= 0.25
 err1 = RISK_GT_1 INTERACT EMPTY_GT
 err2 = RISK_GT_0 WITH EDGE RISK_GT_2

 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}
#ENDIF

#IFDEF DFM_RULES_PRIORITY_2 YES
GT_R_21_DFM2 {
@ It's not allowed to use GT on AA edge for routing
@ DRC flag (Edge GT not P2) electrically connect both P+AA and N+AA
 err1 = (((GT_0 INTERACT AA_v_edges_exp001) INTERACT NACT) INTERACT PACT) INTERACT M0G
 err1 NOT INSIDE SealR_NOT_BULK
}
#ENDIF

#IFDEF DFM_RULES_PRIORITY_1 YES
GT_R_23_DFM1 {
@ It is not recommended to use GATE at L-shape AA corner
 err1 = GATE_raw NOT OUTSIDE GTMK2
 err1 NOT INSIDE SealR_NOT_BULK
}
#ENDIF

#IFDEF DFM_RULES_PRIORITY_2 YES
GT_R_24_DFM2 {
@ It is not recommended to use NMOS with both SA and SB > 15CPP (Critical poly pitch), except ESD device
 err1 = (NACT ENCLOSE NGATE) INTERACT GATE_raw >= (15+1)*2 +1
 err1 NOT INSIDE ESDIO_ALL
}
#ENDIF

GT_W_1 {
@ ALL_GT width >= 0.016um
 err1 = INT ALL_GT < GT_MiniWidth ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

GT_W_2 {
@ ALL_GT width, except DMCMK1, LDBK, MARKS, OCOVL and LOGO regions <= 0.242um
 except_region = OR DMCMK1 LDBK OCOVL LOGO MARKS
 err1 = (WITH WIDTH ALL_GT > GT_MaxiWidth) NOT except_region
 err1 NOT INSIDE SealR_NOT_BULK
}

GT_W_3 {
@ ALL_GT width in core region, except GT_P96, INST, MARKS, OCOVL and LOGO regions = 0.016/0.018/0.02, 0.032, 0.07~0.242um
 except_region = OR GT_P96 OCOVL LOGO INST MARKS
 chk_GT = (ALL_GT NOT INSIDE DG) NOT INSIDE except_region
 good_1 = OR ALL_GT_016 ALL_GT_018 ALL_GT_020
 good_2 = WITH WIDTH chk_GT == 0.032
 good_3 = WITH WIDTH chk_GT >= 0.070 <= 0.242
 err1 = (chk_GT NOT (OR good_1 good_2 good_3)) NOT (OR DG except_region)
 err1 NOT INSIDE SealR_NOT_BULK
}

GT_W_3a {
@ (GT OR GTDMP) width in core region INSIDE GT_P96 = 0.016/0.018/0.02/0.022/0.024um
 chk_GT = (DMP_GT NOT INSIDE DG) INTERACT GT_P96
 good_GT = OR ALL_GT_016 ALL_GT_018 ALL_GT_020 ALL_GT_022 ALL_GT_024
 err1 = ((chk_GT NOT good_GT) AND GT_P96) NOT DG
 err1 NOT INSIDE SealR_NOT_BULK
}

GT_W_4 {
@ (AOP_GT INTERACT DG) width, except DGV region >= 0.086um
 chk_GT = (AOP_GT INTERACT DG) NOT INSIDE DGV
 err1 = INT chk_GT < 0.086 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE DGV
}

GT_W_4a {
@ (AOP_GT INTERACT DG) width in DGV region >= 0.08um
 chk_GT = (AOP_GT INTERACT DG) NOT OUTSIDE DGV
 err1 = (INT chk_GT < 0.08 ABUT<90 SINGULAR REGION) INTERACT DGV
 err1 NOT INSIDE SealR_NOT_BULK
}

GT_W_5 {
@ Channel length for core NMOS/PMOS transistor, except ESDIO2, GT_P96, VARMOS, INST and PSUB regions = 0.016/0.018/0.02, 0.032, 0.07~0.242um
 except_region = OR ESDIO2 GT_P96 VARMOS PSUB INST
 chk_GATE = (GATE_CORE NOT INSIDE except_region) COIN EDGE channel_width_GT_edge
 bad_1 = INT (chk_GATE) == 0.016 ABUT<90 OPPOSITE
 bad_2 = INT (bad_1) == 0.018 ABUT<90 OPPOSITE
 bad_3 = INT (bad_2) == 0.020 ABUT<90 OPPOSITE
 bad_4 = INT (bad_3) == 0.032 ABUT<90 OPPOSITE
 bad_5 = INT (bad_4) >= 0.070 <= 0.242 ABUT<90 OPPOSITE EXCLUDE SHIELDED
 err1 = bad_5 NOT INSIDE EDGE except_region
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

GT_W_5a {
@ Channel length for core NMOS/PMOS transistor INSIDE GT_P96 = 0.016/0.018/0.02/0.022/0.024um
 chk_GATE = (GATE_CORE INTERACT GT_P96) COIN EDGE channel_width_GT_edge
 bad_1 = INT (chk_GATE) == 0.016 ABUT<90 OPPOSITE
 bad_2 = INT (bad_1) == 0.018 ABUT<90 OPPOSITE
 bad_3 = INT (bad_2) == 0.020 ABUT<90 OPPOSITE
 bad_4 = INT (bad_3) == 0.022 ABUT<90 OPPOSITE
 bad_5 = INT (bad_4) == 0.024 ABUT<90 OPPOSITE
 err1 = bad_5 INSIDE EDGE GT_P96
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

GT_W_6 {
@ Channel length of 1.8V MOS underdrive to 1.5V I/O NMOS/PMOS transistor (GATE AND DGUD) = 0.086~0.242um
 chk_GATE = GATE_15 COIN EDGE channel_width_GT_edge
 err1 = INT (chk_GATE) >= 0.086 <= 0.242 ABUT<90 OPPOSITE EXCLUDE SHIELDED
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

GT_W_7 {
@ Channel length of 1.8V MOS underdrive to 1.2V I/O NMOS/PMOS transistor (GATE AND DGV) = 0.08~0.242um
 chk_GATE = GATE_12 COIN EDGE channel_width_GT_edge
 err1 = INT (chk_GATE) >= 0.080 <= 0.242 ABUT<90 OPPOSITE EXCLUDE SHIELDED
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

GT_W_8 {
@ Channel length of 1.8V I/O NMOS/PMOS transistor, except DGUD, DGV, VARMOS, LDBK regions = 0.134~0.242um
 WAIVE_AREA = OR VARMOS LDBK
 chk_GATE = (GATE_18 NOT INSIDE (OR DGV DGUD)) COIN EDGE channel_width_GT_edge
 err1 = INT (chk_GATE) >= 0.134 <= 0.242 ABUT<90 OPPOSITE EXCLUDE SHIELDED
 err1 NOT INSIDE EDGE WAIVE_AREA
}

GT_W_9 {
@ Channel length for core NMOS/PMOS transistor for HVT device <= 0.032um
 chk_GATE = (GATE_CORE NOT OUTSIDE (OR HVT_N HVT_P)) COIN EDGE channel_width_GT_edge
 bad_1 = INT (chk_GATE) <= 0.032 ABUT<90 OPPOSITE
 err1 = bad_1 NOT OUTSIDE EDGE (OR HVT_N HVT_P)
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

gt_on_field_oxide = GT INTERACT AA
gt_on_field_oxide_jog_004 = CONVEX EDGE gt_on_field_oxide == 1 WITH LENGTH <= 0.004

GT_W_10b {
@ Width of AOP_GT neighboring to AOP_GT (width = 0.016/0.018um, space to AOP_GT < 0.117um), except ESDIO1, ESDIO2 regions = 0.016/0.018/0.02um
 chk_AOP_GT = OR EDGE AOP_GT_016_v_edges AOP_GT_018_v_edges
 out_0 = AOP_GT_noESD COIN EDGE (EXT [AOP_GT_noESD] chk_AOP_GT < 0.117 OPPOSITE)
 out_1 = INT (out_0) AOP_GT_noESD == 0.016 OPPOSITE
 out_2 = INT (out_1) AOP_GT_noESD == 0.018 OPPOSITE
 out_3 = INT (out_2) AOP_GT_noESD == 0.020 OPPOSITE
 err1 = out_3 NOT INSIDE EDGE ESDIO_ALL
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

/*
GT_W_10c {
@ Width of AOP_GT neighboring to AOP_GT (width = 0.016/0.018um, space to AOP_GT < 0.117um), except ESDIO1, ESDIO2 regions = 0.016~0.02um
 out_0 = AOP_GT_noESD COIN EDGE (EXT [AOP_GT_noESD] AOP_GT_018_v_edges < 0.117 OPPOSITE)
 out_1 = INT (out_0) AOP_GT_noESD == 0.016 OPPOSITE
 out_2 = INT (out_1) AOP_GT_noESD == 0.018 OPPOSITE
 out_3 = INT (out_2) AOP_GT_noESD >= 0.016 <= 0.020 OPPOSITE
 err1 = out_3 NOT INSIDE EDGE ESDIO_ALL
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
*/

GT_W_10d {
@ Width of AOP_GT neighboring to AOP_GT (width = 0.02um, space to AOP_GT < 0.117um), except INST, ESDIO1 and ESDIO2 regions = 0.016/0.018/0.02/0.022/0.024/0.032um
 out_0 = AOP_GT_noESD_SRAM COIN EDGE (EXT [AOP_GT_noESD_SRAM] AOP_GT_020_v_edges < 0.117 OPPOSITE)
 out_1 = INT (out_0) AOP_GT_noESD == 0.016 OPPOSITE
 out_2 = INT (out_1) AOP_GT_noESD == 0.018 OPPOSITE
 out_3 = INT (out_2) AOP_GT_noESD == 0.020 OPPOSITE
 out_4 = INT (out_3) AOP_GT_noESD == 0.022 OPPOSITE
 out_5 = INT (out_4) AOP_GT_noESD == 0.024 OPPOSITE
 out_6 = INT (out_5) AOP_GT_noESD == 0.032 OPPOSITE
 err1 = out_6 NOT INSIDE EDGE (OR ESDIO_ALL INST)
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

GT_W_10e {
@ Width of AOP_GT neighboring to AOP_GT (width = 0.022/0.024um, space to ALL_GT < 0.117um), except ESDIO1 and ESDIO2 regions = 0.02/0.022/0.024/0.032um
 out_0 = AOP_GT_noESD COIN EDGE (EXT [AOP_GT_noESD] AOP_GT_022_024_v_edges < 0.117 OPPOSITE)
 out_1 = INT (out_0) AOP_GT_noESD == 0.020 OPPOSITE
 out_2 = INT (out_1) AOP_GT_noESD == 0.022 OPPOSITE
 out_3 = INT (out_2) AOP_GT_noESD == 0.024 OPPOSITE
 out_4 = INT (out_3) AOP_GT_noESD == 0.032 OPPOSITE
 err1 = out_4 NOT INSIDE EDGE ESDIO_ALL
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

GT_W_10f {
@ Width of AOP_GT neighboring to AOP_GT (width = 0.032um, space to ALL_GT < 0.117um), except INST, ESDIO1 and ESDIO2 regions = 0.02/0.022/0.024/0.032um
 out_0 = AOP_GT_noESD_SRAM COIN EDGE (EXT [AOP_GT_noESD_SRAM] AOP_GT_032_v_edges < 0.117 OPPOSITE)
 out_1 = INT (out_0) AOP_GT_noESD == 0.020 OPPOSITE
 out_2 = INT (out_1) AOP_GT_noESD == 0.022 OPPOSITE
 out_3 = INT (out_2) AOP_GT_noESD == 0.024 OPPOSITE
 out_4 = INT (out_3) AOP_GT_noESD == 0.032 OPPOSITE
 err1 = out_4 NOT INSIDE EDGE (OR ESDIO_ALL INST)
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

GT_W_11a {
@ Width of AOP_GT neighboring to GATE (channel length <= 0.02um, AOP_GT to neighboring GATE space < 0.117um), except INST, ESDIO1 and ESDIO2 regions = 0.016/0.018/0.02um
 chk_GATE = GATE_noESD WITH EDGE (LENGTH GATE_LE <= 0.020)
 out_0 = AOP_GT_noESD_SRAM COIN EDGE (EXT [AOP_GT_noESD_SRAM] chk_GATE < 0.117 OPPOSITE)
 out_1 = INT (out_0) AOP_GT_noESD == 0.016 OPPOSITE
 out_2 = INT (out_1) AOP_GT_noESD == 0.018 OPPOSITE
 out_3 = INT (out_2) AOP_GT_noESD == 0.020 OPPOSITE
 err1 = out_3 NOT INSIDE EDGE (OR ESDIO_ALL INST)
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

GT_W_11b {
@ Width of AOP_GT neighboring to GATE (channel length = 0.022/0.024um, AOP_GT to neighboring GATE space < 0.117um), except ESDIO1, ESDIO2 regions = 0.02/0.022/0.024um
 chk_GATE = GATE_noESD WITH EDGE (OR EDGE (LENGTH GATE_LE == 0.022) (LENGTH GATE_LE == 0.024))
 out_0 = AOP_GT_noESD COIN EDGE (EXT [AOP_GT_noESD] chk_GATE < 0.117 OPPOSITE)
 out_1 = INT (out_0) AOP_GT_noESD == 0.020 OPPOSITE
 out_2 = INT (out_1) AOP_GT_noESD == 0.022 OPPOSITE
 out_3 = INT (out_2) AOP_GT_noESD == 0.024 OPPOSITE
 err1 = out_3 NOT INSIDE EDGE ESDIO_ALL
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

GT_W_11c {
@ Width of AOP_GT neighboring to GATE (channel length = 0.032um, AOP_GT to neighboring GATE space < 0.117um), AOP_GT should be same to neighboring GATE, except ESDIO1, ESDIO2 regions = 0.032um
 chk_GATE_032 = GATE_noESD WITH EDGE (LENGTH GATE_LE == 0.032)
 chk_GATE_034 = GATE_noESD WITH EDGE (LENGTH GATE_LE == 0.034)
 chk_GATE_036 = GATE_noESD WITH EDGE (LENGTH GATE_LE == 0.036)
 out_1 = AOP_GT_noESD COIN EDGE (EXT [AOP_GT_noESD] chk_GATE_032 < 0.117 OPPOSITE)
 out_2 = AOP_GT_noESD COIN EDGE (EXT [AOP_GT_noESD] chk_GATE_034 < 0.117 OPPOSITE)
 out_3 = AOP_GT_noESD COIN EDGE (EXT [AOP_GT_noESD] chk_GATE_036 < 0.117 OPPOSITE)

 err1_TMP = INT (out_1) AOP_GT_noESD == 0.032 OPPOSITE
 err1 = err1_TMP NOT INSIDE EDGE ESDIO_ALL
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

GT_W_11d {
@ Width of AOP_GT neighboring to GATE (channel length >= 0.07um, AOP_GT to neighboring GATE space = 0.117~0.118um), except ESDIO1, ESDIO2 and L-shape AA region >= 0.07um
 chk_GATE = (GATE_noESD WITH EDGE (LENGTH GATE_LE >= 0.070)) NOT INTERACT L_shape_AA
 out_0 = AOP_GT_noESD_noLAA COIN EDGE (EXT [AOP_GT_noESD] chk_GATE >= 0.117 <= 0.118 OPPOSITE)
 out_1 = INT [out_0] AOP_GT_noESD < 0.070 OPPOSITE
 err1 = out_1 NOT INSIDE EDGE (OR ESDIO_ALL L_shape_AA)
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

GT_W_12a {
@ Width of AOP_GT neighboring to GATE (INSIDE DG, AOP_GT to neighboring GATE space = 0.117~0.118um), except DGV, ESDIO1, ESDIO2 and L-shape AA region >= 0.086um
 chk_GATE = GATE_in_DG NOT INSIDE (OR DGV ESDIO_ALL L_shape_AA)
 out_0 = AOP_GT_noESD_noLAA COIN EDGE (EXT [AOP_GT_noESD] chk_GATE >= 0.117 <= 0.118 OPPOSITE)
 out_1 = INT [out_0] AOP_GT_noESD < 0.086 OPPOSITE
 err1 = out_1 NOT INSIDE EDGE (OR DGV ESDIO_ALL L_shape_AA)
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

GT_W_12b {
@ Width of AOP_GT neighboring to GATE (INSIDE DGV, AOP_GT to neighboring GATE space = 0.117~0.118um), except ESDIO1, ESDIO2 and L-shape AA region >= 0.08um
 chk_GATE = (GATE INSIDE DGV) NOT INSIDE (OR ESDIO_ALL L_shape_AA)
 out_0 = AOP_GT_noESD_noLAA COIN EDGE (EXT [AOP_GT_noESD] chk_GATE >= 0.117 <= 0.118 OPPOSITE)
 out_1 = INT [out_0] AOP_GT_noESD < 0.08 OPPOSITE
 err1 = out_1 NOT INSIDE EDGE (OR ESDIO_ALL L_shape_AA)
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

GT_S_1 {
@ GT space, except LOGO and OCOVL region >= 0.07um
 err1 = EXT GT < 0.07 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE OCOVL_LOGO
}

GT_S_2 {
@ Space between AOP_GT centerline (both AOP_GT width <= 0.02um) in S/D direction, except centerline space > 0.1um case and GT_P96 region = 0.09um
 chk_centerline = INT AOP_GT <= 0.020 OPPOSITE REGION CENTERLINE 0.002
 err1 = DFM COPY (DFM SPACE chk_centerline < 0.088 BY EXT HORIZONTAL) REGION
 err2 = DFM COPY (DFM SPACE chk_centerline > 0.088 <= 0.098 BY EXT HORIZONTAL) REGION
 err1 NOT INSIDE GT_P96
 err2 NOT INSIDE GT_P96
}

GT_S_3a {
@ Space between AOP_GT centerline (both AOP_GT width <= 0.024um, INSIDE GT_P96) in S/D direction except centerline space > 0.1um. = 0.096um
 chk_centerline = INT (AOP_GT NOT OUTSIDE GT_P96) <= 0.024 OPPOSITE REGION CENTERLINE 0.002
 err1 = (DFM COPY (DFM SPACE chk_centerline < 0.094 BY EXT HORIZONTAL) REGION) AND GT_P96
 err2 = (DFM COPY (DFM SPACE chk_centerline > 0.094 <= 0.098 BY EXT HORIZONTAL) REGION) AND GT_P96
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

GT_S_3b {
@ Space between AOP_GT centerline (both AOP_GT width = 0.032um) in S/D direction >= 0.106um
 chk_centerline = INT AOP_GT == 0.032 OPPOSITE REGION CENTERLINE 0.002
 err1 = DFM COPY (DFM SPACE chk_centerline < 0.106 - 0.002 BY EXT HORIZONTAL) REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

GT_S_4 {
@ Space between two AOP_GT when either AOP_GT width >= 0.07um, except LOGO and OCOVL region >= 0.117um
 err1 = EXT AOP_GT AOP_GT_eqgt_070 < 0.117 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE OCOVL_LOGO
}

GT_S_5 {
@ Space between (AOP_GT NOT OUTSIDE DG) and AOP_GT >= 0.117um
 err1 = EXT (AOP_GT NOT OUTSIDE DG) AOP_GT < 0.117 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

ALL_AA_SD_all = (ALL_AA NOT AOP_GT) INTERACT AOP_GT > 1
ALL_AA_SD_all_lt_96_pitch = LENGTH (ANGLE ALL_AA_SD_all == 0) <= 0.096 //;To reduce runtime, here drc exclude GT pitch <= 96 area

GT_S_6 {
@ Space between AOP_GT (INTERACT the same ALL_AA) in S/D direction, except ESDIO1 and ESDIO2 regions <= 0.120um
 chk_AOP_GT_inAA_EDGE_all = (AOP_GT INSIDE EDGE ALL_AA) COIN EDGE (ALL_AA_SD_all NOT INSIDE ESDIO_all)
 chk_AOP_GT_inAA_EDGE_one_aa = (ALL_AA_SD_all NOT WITH EDGE ALL_AA_SD_all_lt_96_pitch) COIN EDGE chk_AOP_GT_inAA_EDGE_all
 err1 = INT (chk_AOP_GT_inAA_EDGE_one_aa) <= 0.120 ABUT<90 OPPOSITE EXCLUDE SHIELDED
 err1 NOT INSIDE EDGE ESDIO_all
}

GT_S_7 {
@ Space between the short side of AOP_GT (width <= 0.032um) and AOP_GT when PRL > -0.07um. >= 0.108um
 chk_AOP_GT_W_sides = LENGTH AOP_GT_eqlt_036 <= 0.032
 chk_AOP_GT_L_sides = AOP_GT COIN EDGE chk_AOP_GT_W_sides
 err1 = EXT chk_AOP_GT_L_sides AOP_GT < 0.108 ABUT<90 REGION OPPOSITE EXTENDED 0.070
 err1 NOT INSIDE SealR_NOT_BULK
}

GT_S_8 {
@ Space between the long side of ALL_GT (width <= 0.024um) and AOP_GT when PRL > -0.108um. >= 0.07um
 chk_AOP_GT_W_sides = LENGTH ALL_GT_eqlt_024 <= 0.024
 chk_AOP_GT_L_sides = ALL_GT_eqlt_024 NOT COIN EDGE chk_AOP_GT_W_sides
 err1 = EXT chk_AOP_GT_L_sides AOP_GT < 0.07 ABUT<90 REGION OPPOSITE EXTENDED 0.108
 err1 NOT INSIDE SealR_NOT_BULK
}

GT_S_8a {
@ Space between the long side of ALL_GT (width = 0.032um) and AOP_GT when PRL > -0.108um. >= 0.072um
 chk_AOP_GT_W_sides = LENGTH ALL_GT_032 == 0.032
 chk_AOP_GT_L_sides = ALL_GT_032 NOT COIN EDGE chk_AOP_GT_W_sides
 err1 = EXT chk_AOP_GT_L_sides AOP_GT < 0.072 ABUT<90 REGION OPPOSITE EXTENDED 0.108
 err1 NOT INSIDE SealR_NOT_BULK
}

GT_S_9 {
@ Space between AOP_GT (width >= 0.07um) and AOP_GT when PRL > -0.117um, except LOGO and OCOVL region >= 0.117um
 err1 = EXT AOP_GT_eqgt_070 AOP_GT < 0.117 ABUT<90 REGION OPPOSITE EXTENDED 0.117
 err1 NOT INSIDE OCOVL_LOGO
}

GT_S_10 {
@ Space between AOP_GT and AOP_AA >= 0.046um
 err1 = EXT AOP_GT AOP_AA < 0.046 ABUT<90 SINGULAR REGION MEASURE ALL
 err1 NOT INSIDE SealR_NOT_BULK
}

//;GT.S.11: delta voltage rule
//;GT.S.12: delta voltage rule

#IFDEF MINIMUM_DENSITY_CHECK YES
GT_S_13 {
@ Space between (ALL_GT NOT ALL_P2), except (NODMF su 1um), (MARKS su 1um), RESP1, LOGO, OCOVL regions <= 1.25um
@ This rule is a local density related rule
@ DRC flags (((Chip NOT (ALL_GT NOT ALL_P2)) sd 0.625um) su 0.625um) region greater than 1.25*1.25um
 waive_AREA = OR MARKS_SIZE_1 NODMF_SIZE_1 RESP1 LOGO OCOVL
 check_AREA = (DRC:1 NOT ALL_GT_NOT_P2_ALL) NOT waive_AREA
 err1 = SIZE check_AREA BY 1.25/2 UNDEROVER
 err1 NOT INSIDE SealR_NOT_BULK
}
#ENDIF

GT_S_14 {
@ Space between (ALL_GT NOT ALL_P2) INSIDE RESP1 region <= 2.1um
@ This rule is a local density related rule
@ DRC flags ((((Chip AND RESP1) NOT (ALL_GT NOT ALL_P2)) sd 1.05um) su 1.05um) region greater than 2.1*2.1um
 err1 = SIZE ((DRC:1 AND RESP1) NOT ALL_GT_NOT_P2_ALL) BY 2.1/2 UNDEROVER
 err1 NOT INSIDE SealR_NOT_BULK
}

GT_S_15b {
@ Space between ((GATE SIZING 0.02um) AND GT) (channel length = 0.016um) and neighboring AOP_GT for core NMOS/PMOS, except ESDIO1, ESDIO2 and GT_P96 regions = 0.072~0.074um
 y1 = GATE_LE_16 NOT INSIDE ESD_DG_P96
 y2 = (SIZE y1 BY 0.020) AND GT
 y3 = (INT [y2] == 0.016 OPPOSITE) COIN EDGE GT
 y4 = (y2 WITH EDGE y3) COIN EDGE channel_width_GT_edge

 out_1 = EXT (y4) AOP_GT == 0.072 OPPOSITE
 out_2 = EXT (out_1) AOP_GT == 0.073 OPPOSITE
 err1 = EXT (out_2) AOP_GT == 0.074 OPPOSITE
 err1 NOT INSIDE EDGE ESD_DG_P96
}

GT_S_15c {
@ Space between ((GATE SIZING 0.02um) AND GT) (channel length = 0.018um) and neighboring AOP_GT for core NMOS/PMOS, except ESDIO1, ESDIO2 and GT_P96 regions = 0.071~0.073um
 y1 = GATE_LE_18 NOT INSIDE ESD_DG_P96
 y2 = (SIZE y1 BY 0.020) AND GT
 y3 = (INT [y2] == 0.018 OPPOSITE) COIN EDGE GT
 y4 = (y2 WITH EDGE y3) COIN EDGE channel_width_GT_edge

 out_1 = EXT (y4) AOP_GT == 0.071 OPPOSITE
 out_2 = EXT (out_1) AOP_GT == 0.072 OPPOSITE
 err1 = EXT (out_2) AOP_GT == 0.073 OPPOSITE
 err1 NOT INSIDE EDGE ESD_DG_P96
}

GT_S_15d {
@ Space between ((GATE SIZING 0.02um) AND GT) (channel length = 0.02um) and neighboring AOP_GT for core NMOS/PMOS, except ESDIO1, ESDIO2 and GT_P96 regions = 0.070~0.072um
 y1 = GATE_LE_20 NOT INSIDE ESD_DG_P96
 y2 = (SIZE y1 BY 0.020) AND GT
 y3 = (INT [y2] == 0.020 OPPOSITE) COIN EDGE GT
 y4 = (y2 WITH EDGE y3) COIN EDGE channel_width_GT_edge

 out_1 = EXT (y4) AOP_GT == 0.070 OPPOSITE
 out_2 = EXT (out_1) AOP_GT == 0.071 OPPOSITE
 err1 = EXT (out_2) AOP_GT == 0.072 OPPOSITE
 err1 NOT INSIDE EDGE ESD_DG_P96
}

GT_S_15e {
@ Space between ((GATE SIZING 0.02um) AND GT) (channel length = 0.032um) and neighboring AOP_GT for core NMOS/PMOS, except ESDIO1, ESDIO2 regions = 0.074um
 y1 = GATE_LE_32 NOT INSIDE ESD_DG
 y2 = (SIZE y1 BY 0.020) AND GT
 y3 = (INT [y2] == 0.032 OPPOSITE) COIN EDGE GT
 y4 = (y2 WITH EDGE y3) COIN EDGE channel_width_GT_edge

 err1 = EXT (y4) AOP_GT == 0.074 OPPOSITE
 err1 NOT INSIDE EDGE ESD_DG
}

GT_S_15f {
@ Space between ((GATE SIZING 0.042um) AND GT) (channel length >= 0.07um) and neighboring AOP_GT for core NMOS/PMOS, except ESDIO1, ESDIO2 regions = 0.118, 0.119um
 y1 = GATE_LE_GT_70 NOT INSIDE ESD_DG
 y2 = (SIZE y1 BY 0.042) AND GT
 y3 = ANGLE y2 == 90
 y4 = (INT (y3) < 0.070 OPPOSITE EXCLUDE SHIELDED) COIN EDGE GT
 y5 = (y2 WITH EDGE y4) COIN EDGE channel_width_GT_edge

 err1 = EXT (y5) AOP_GT >= 0.118 <= 0.119 OPPOSITE
 err1 NOT INSIDE EDGE ESD_DG
}

GT_S_15g {
@ Space between ((GATE SIZING 0.042um) AND GT) and neighboring AOP_GT for I/O device, except ESDIO1, ESDIO2, LDBK regions = 0.118, 0.119um
 y1 = ((SIZE GATE_IO BY 0.042) AND GT) NOT INSIDE ESD_LDBK
 y2 = y1 COIN EDGE channel_width_GT_edge
 err1 = EXT (y2) AOP_GT >= 0.118 <= 0.119 OPPOSITE
 err1 NOT INSIDE EDGE ESD_LDBK
}

GT_S_15i {
@ Space between ((GATE SIZING 0.02um) AND GT) (channel length = 0.016um) and neighboring AOP_GT for core NMOS/PMOS in GT_P96 region = 0.078~0.08um
 y1 = GATE_LE_16 NOT DG
 y2 = ((SIZE y1 BY 0.020) AND GT) INTERACT GT_P96
 y3 = (INT [y2] == 0.016 OPPOSITE) COIN EDGE GT
 y4 = (y2 WITH EDGE y3) COIN EDGE channel_width_GT_edge

 out_1 = EXT (y4) AOP_GT == 0.078 OPPOSITE
 out_2 = EXT (out_1) AOP_GT == 0.079 OPPOSITE
 out_3 = EXT (out_2) AOP_GT == 0.080 OPPOSITE
 err1 = out_3 INSIDE EDGE GT_P96
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

GT_S_15j {
@ Space between ((GATE SIZING 0.02um) AND GT) (channel length = 0.018um) and neighboring AOP_GT for core NMOS/PMOS in GT_P96 region = 0.077~0.079um
 y1 = GATE_LE_18 NOT DG
 y2 = ((SIZE y1 BY 0.020) AND GT) INTERACT GT_P96
 y3 = (INT [y2] == 0.018 OPPOSITE) COIN EDGE GT
 y4 = (y2 WITH EDGE y3) COIN EDGE channel_width_GT_edge

 out_1 = EXT (y4) AOP_GT == 0.077 OPPOSITE
 out_2 = EXT (out_1) AOP_GT == 0.078 OPPOSITE
 out_3 = EXT (out_2) AOP_GT == 0.079 OPPOSITE
 err1 = out_3 INSIDE EDGE GT_P96
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

GT_S_15k {
@ Space between ((GATE SIZING 0.02um) AND GT) (channel length = 0.02um) and neighboring AOP_GT for core NMOS/PMOS in GT_P96 region = 0.076~0.078um
 y1 = GATE_LE_20 NOT DG
 y2 = ((SIZE y1 BY 0.020) AND GT) INTERACT GT_P96
 y3 = (INT [y2] == 0.020 OPPOSITE) COIN EDGE GT
 y4 = (y2 WITH EDGE y3) COIN EDGE channel_width_GT_edge

 out_1 = EXT (y4) AOP_GT == 0.076 OPPOSITE
 out_2 = EXT (out_1) AOP_GT == 0.077 OPPOSITE
 out_3 = EXT (out_2) AOP_GT == 0.078 OPPOSITE
 err1 = out_3 INSIDE EDGE GT_P96
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

GT_S_15l_1 {
@ Space between ((GATE SIZING 0.02um) AND GT) (channel length = 0.022/0.024um) and neighboring AOP_GT for core NMOS/PMOS in GT_P96 region. = 0.072~0.075um
 y1 = GATE_LE_22 NOT DG
 y2 = ((SIZE y1 BY 0.020) AND GT) INTERACT GT_P96
 y3 = (INT [y2] == 0.022 OPPOSITE) COIN EDGE GT
 y4 = (y2 WITH EDGE y3) COIN EDGE channel_width_GT_edge

 out_1 = EXT (y4) AOP_GT == 0.072 OPPOSITE
 out_2 = EXT (out_1) AOP_GT >= 0.072 <= 0.075 OPPOSITE
 err1 = out_2 INSIDE EDGE GT_P96
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

GT_S_15l_2 {
@ Space between ((GATE SIZING 0.02um) AND GT) (channel length = 0.022/0.024um) and neighboring AOP_GT for core NMOS/PMOS in GT_P96 region. = 0.072~0.075um
 y1 = GATE_LE_24 NOT DG
 y2 = ((SIZE y1 BY 0.020) AND GT) INTERACT GT_P96
 y3 = (INT [y2] == 0.024 OPPOSITE) COIN EDGE GT
 y4 = (y2 WITH EDGE y3) COIN EDGE channel_width_GT_edge

 out_1 = EXT (y4) AOP_GT == 0.072 OPPOSITE
 out_2 = EXT (out_1) AOP_GT >= 0.072 <= 0.075 OPPOSITE
 err1 = out_2 INSIDE EDGE GT_P96
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

GT_S_16a {
@ Space between GATE (channel length <= 0.032um) and neighboring second AOP_GT in S/D direction for core MOS device <= 0.18um
@ The second AOP_GT is required to be placed second neighboring the GATE, except INST, ESDIO1 and ESDIO2 regions
 WAIVE_AREA = OR INST ESDIO_ALL
 neighboring_TRGATE = TRGATE NOT INSIDE (OR DG INST ESDIO_ALL)  //; based GT.W.x
 neighboring_TRGATE_v_edges = neighboring_TRGATE COIN EDGE AOP_GT_v_edges
 neighboring_TRGATE_v_edges_eqlt_032 = INT [neighboring_TRGATE_v_edges] <= 0.032 OPPOSITE EXCLUDE SHIELDED
 neighboring_TRGATE_v_edges_eqlt_032_real = neighboring_TRGATE_v_edges COIN EDGE GT_eqlt_032
 neighboring_TRGATE_good = DFM SPACE [neighboring_TRGATE_v_edges_eqlt_032_real] AOP_GT <= 0.18 BY EXT COUNT == 2 BY LAYER AOP_GT
 err1 = neighboring_TRGATE_v_edges_eqlt_032_real NOT COIN EDGE neighboring_TRGATE_good
 err1 NOT INSIDE EDGE WAIVE_AREA
}

GT_S_16b {
@ Space between GATE (channel length >= 0.07um) and neighboring second AOP_GT in S/D direction for core MOS device <= 0.481um
@ The second AOP_GT is required to be placed second neighboring the GATE, except ESDIO1 and ESDIO2 region
 neighboring_TRGATE = (TRGATE INTERACT GT_eqgt_070) NOT INSIDE DG
 neighboring_TRGATE_v_edges = neighboring_TRGATE COIN EDGE AOP_GT_v_edges
 neighboring_TRGATE_v_edges_eqgt_070 = INT (neighboring_TRGATE_v_edges) < 0.070 OPPOSITE EXCLUDE SHIELDED
 neighboring_TRGATE_v_edges_eqgt_070_real = neighboring_TRGATE_v_edges_eqgt_070 COIN EDGE GT_eqgt_070
 neighboring_TRGATE_good = DFM SPACE [neighboring_TRGATE_v_edges_eqgt_070_real] AOP_GT <= MAXIMUM_2nd_DummySpace BY EXT COUNT == 2 BY LAYER AOP_GT
 err1 = neighboring_TRGATE_v_edges_eqgt_070_real NOT COIN EDGE neighboring_TRGATE_good
 err1 NOT INSIDE EDGE ESDIO_ALL
}

AOP_GT_space_gt_080 = AOP_GT COIN EDGE (EXT (AOP_GT_v_edges) <= 0.08 OPPOSITE)
AOP_GT_space_eqgt_081 = AOP_GT COIN EDGE (EXT (AOP_GT_v_edges) < 0.081 OPPOSITE)
AOP_GT_space_lteq_080 = AOP_GT COIN EDGE (EXT [AOP_GT_v_edges] <= 0.08 OPPOSITE)
AOP_GT_space_gt_081 = AOP_GT COIN EDGE (EXT (AOP_GT_v_edges) <= 0.081 OPPOSITE)
AOP_GT_space_lt_081 = AOP_GT COIN EDGE (EXT [AOP_GT_v_edges] < 0.081 OPPOSITE)
AOP_GT_space_gt_082 = AOP_GT COIN EDGE (EXT (AOP_GT_v_edges) <= 0.082 OPPOSITE)
AOP_GT_space_lt_082 = AOP_GT COIN EDGE (EXT [AOP_GT_v_edges] < 0.082 OPPOSITE)

AOP_GT_space_not_eqgt_073_eqlt_076_edges = EXT (AOP_GT_v_edges) >= 0.073 <= 0.076 OPPOSITE
AOP_GT_space_not_eqgt_072_eqlt_075_edges = EXT (AOP_GT_v_edges) >= 0.072 <= 0.075 OPPOSITE
AOP_GT_space_not_eqgt_072_eqlt_074_edges = EXT (AOP_GT_v_edges) >= 0.072 <= 0.074 OPPOSITE
AOP_GT_space_not_eqgt_071_eqlt_074_edges = EXT (AOP_GT_v_edges) >= 0.071 <= 0.074 OPPOSITE
AOP_GT_space_not_eqgt_071_eqlt_073_edges = EXT (AOP_GT_v_edges) >= 0.071 <= 0.073 OPPOSITE
AOP_GT_space_not_eqgt_070_eqlt_073_edges = EXT (AOP_GT_v_edges) >= 0.070 <= 0.073 OPPOSITE
AOP_GT_space_not_eqgt_070_eqlt_072_edges = EXT (AOP_GT_v_edges) >= 0.070 <= 0.072 OPPOSITE

AOP_GT_space_not_eqgt_079_eqlt_082_edges = EXT (AOP_GT_v_edges) >= 0.079 <= 0.082 OPPOSITE
AOP_GT_space_not_eqgt_078_eqlt_080_edges = EXT (AOP_GT_v_edges) >= 0.078 <= 0.080 OPPOSITE
AOP_GT_space_not_eqgt_078_eqlt_081_edges = EXT (AOP_GT_v_edges) >= 0.078 <= 0.081 OPPOSITE
AOP_GT_space_not_eqgt_077_eqlt_079_edges = EXT (AOP_GT_v_edges) >= 0.077 <= 0.079 OPPOSITE

AOP_GT_space_not_eq_070_edges = EXT (AOP_GT_v_edges) == 0.070 OPPOSITE
AOP_GT_space_not_eq_072_edges = EXT (AOP_GT_v_edges) == 0.072 OPPOSITE
AOP_GT_space_not_eq_074_edges = EXT (AOP_GT_v_edges) == 0.074 OPPOSITE
ALL_GT_space_not_eq_118_edges = EXT (ALL_GT_v_edges) == 0.118 OPPOSITE
ALL_GT_space_not_eq_118_119_edges = EXT (ALL_GT_v_edges) >= 0.118 <= 0.119 OPPOSITE

GT_S_17b {
@ Space between AOP_GT (width = 0.016um and one side poly space >= 0.081um) and AOP_GT, except GT_P96 region = 0.072~0.074um
 y1 = AOP_GT_016_v_edges COIN EDGE AOP_GT_space_eqgt_081
 y2 = AOP_GT COIN EDGE AOP_GT_space_not_eqgt_072_eqlt_074_edges
 y3 = y2 NOT COIN EDGE AOP_GT_space_eqgt_081
 err1 = INT [y1] == 0.016 OPPOSITE
 err2 = INT y1 [y3] == 0.016 OPPOSITE
 err1 NOT INSIDE EDGE GT_P96
 err2 NOT INSIDE EDGE GT_P96
}

GT_S_17c {
@ Space between AOP_GT (width = 0.018um and one side poly space >= 0.081um) and AOP_GT, except GT_P96 region = 0.071~0.073um
 y1 = AOP_GT_018_v_edges COIN EDGE AOP_GT_space_eqgt_081
 y2 = AOP_GT COIN EDGE AOP_GT_space_not_eqgt_071_eqlt_073_edges
 y3 = y2 NOT COIN EDGE AOP_GT_space_eqgt_081
 err1 = INT [y1] == 0.018 OPPOSITE
 err2 = INT y1 [y3] == 0.018 OPPOSITE
 err1 NOT INSIDE EDGE GT_P96
 err2 NOT INSIDE EDGE GT_P96
}

GT_S_17d {
@ Space between AOP_GT (width = 0.02um and one side poly space >= 0.081um) and AOP_GT, except GT_P96 region = 0.070~0.072um
 y1 = AOP_GT_020_v_edges COIN EDGE AOP_GT_space_eqgt_081
 y2 = AOP_GT COIN EDGE AOP_GT_space_not_eqgt_070_eqlt_072_edges
 y3 = y2 NOT COIN EDGE AOP_GT_space_eqgt_081
 err1 = INT [y1] == 0.020 OPPOSITE
 err2 = INT y1 [y3] == 0.020 OPPOSITE
 err1 NOT INSIDE EDGE GT_P96
 err2 NOT INSIDE EDGE GT_P96
}

GT_S_17e {
@ Space between AOP_GT (width = 0.032um and one side poly space >= 0.081um) and AOP_GT, except INST region = 0.074um
 y1 = AOP_GT_032_v_edges COIN EDGE AOP_GT_space_eqgt_081
 y2 = AOP_GT COIN EDGE AOP_GT_space_not_eq_074_edges
 y3 = y2 NOT COIN EDGE AOP_GT_space_eqgt_081
 err1 = INT [y1] == 0.032 OPPOSITE
 err2 = INT y1 [y3] == 0.032 OPPOSITE
 err1 NOT INSIDE EDGE INST
 err2 NOT INSIDE EDGE INST
}

AOP_GT_space_eqlt_343 = EXT [AOP_GT_v_edges] <= 0.343 OPPOSITE EXCLUDE SHIELDED

ALL_GT_space_gt_119 = ALL_GT COIN EDGE (EXT (ALL_GT_v_edges) <= 0.119 OPPOSITE)
ALL_GT_space_gt_118 = ALL_GT COIN EDGE (EXT (ALL_GT_v_edges) <= 0.118 OPPOSITE)
ALL_GT_width_eqgt_072_eqlt_162_edges = INT [ALL_GT_v_edges] >= 0.072 <= 0.162 OPPOSITE EXCLUDE SHIELDED
ALL_GT_space_eqgt_118 = ALL_GT COIN EDGE (EXT (ALL_GT_v_edges) < 0.118 OPPOSITE)
ALL_GT_width_eqgt_070_eqlt_160_edges = INT [ALL_GT_v_edges] >= 0.070 <= 0.160 OPPOSITE EXCLUDE SHIELDED

GT_S_17f {
@ Space between ALL_GT (0.07um <= width <= 0.16um and one side poly space >= 0.118um) and ALL_GT, except ESDIO1, ESDIO2 and OCOVL regions = 0.118, 0.119um
 waive_area = OR ESDIO_all OCOVL
 y1 = ALL_GT_width_eqgt_070_eqlt_160_edges COIN EDGE ALL_GT_space_eqgt_118
 y2 = ALL_GT_width_eqgt_070_eqlt_160_edges NOT COIN EDGE y1
 y3 = ALL_GT_width_eqgt_070_eqlt_160_edges COIN EDGE ALL_GT_space_gt_119
 err1 = INT y1 y2 >= 0.070 <= 0.160 OPPOSITE REGION
 err2 = INT y3 >= 0.070 <= 0.160 OPPOSITE REGION
 err1 NOT INSIDE waive_area
 err2 NOT INSIDE waive_area
}

GT_S_17h {
@ Space between AOP_GT (width = 0.016um and one side poly space >= 0.081um) and AOP_GT, inside GT_P96 region = 0.078~0.080um
 y1 = (AOP_GT_016_v_edges COIN EDGE AOP_GT_space_eqgt_081) COIN EDGE AOP_GT_in_GT_P96
 y2 = (AOP_GT_016_v_edges COIN EDGE AOP_GT_space_eqgt_081) COIN EDGE AOP_GT_in_GT_P96
 y3 = AOP_GT COIN EDGE AOP_GT_space_not_eqgt_078_eqlt_080_edges
 y4 = y3 NOT COIN EDGE AOP_GT_space_eqgt_081
 err1 = (INT [y2] == 0.016 OPPOSITE) INSIDE EDGE GT_P96
 err2 = (INT y1 [y4] == 0.016 OPPOSITE) INSIDE EDGE GT_P96
 err1 NOT INSIDE EDGE SealR_NOT_BULK
 err2 NOT INSIDE EDGE SealR_NOT_BULK
}

GT_S_17i {
@ Space between AOP_GT (width = 0.018um and one side poly space >= 0.081um) and AOP_GT, inside GT_P96 region = 0.077~0.079um
 y1 = (AOP_GT_018_v_edges COIN EDGE AOP_GT_space_eqgt_081) COIN EDGE AOP_GT_in_GT_P96
 y2 = AOP_GT COIN EDGE AOP_GT_space_not_eqgt_077_eqlt_079_edges
 y3 = y2 NOT COIN EDGE AOP_GT_space_eqgt_081
 err1 = (INT [y1] == 0.018 OPPOSITE) INSIDE EDGE GT_P96
 err2 = (INT y1 [y3] == 0.018 OPPOSITE) INSIDE EDGE GT_P96
 err1 NOT INSIDE EDGE SealR_NOT_BULK
 err2 NOT INSIDE EDGE SealR_NOT_BULK
}

GT_S_17j {
@ Space between AOP_GT (width = 0.02um and one side poly space >= 0.081um) and AOP_GT, inside GT_P96 region = 0.074, 0.076~0.078um
 y1 = AOP_GT_in_GT_P96 COIN EDGE AOP_GT_020_v_edges
 y2 = INT (y1 COIN EDGE AOP_GT_space_eqgt_081) == 0.020 OPPOSITE REGION //; two sides space > 0.08
 y3 = INT AOP_GT_space_eqgt_081 y1 == 0.020 OPPOSITE REGION
 err1 = y2 AND GT_P96
 err1 NOT INSIDE SealR_NOT_BULK

 out1 = ((y3 NOT y2) COIN EDGE y1) NOT COIN EDGE AOP_GT_space_eqgt_081
 out2 = EXT (out1) AOP_GT == 0.074 OPPOSITE
 out3 = EXT (out2) AOP_GT >= 0.076 <= 0.078 OPPOSITE
 err2 = out3 INSIDE EDGE GT_P96
 err2 NOT INSIDE EDGE SealR_NOT_BULK
}

GT_S_17k_1 {
@ Space between AOP_GT (width = 0.022/0.024um and one side poly space >= 0.081um) and AOP_GT, inside GT_P96 region = 0.072~0.075um
 y1 = AOP_GT_in_GT_P96 COIN EDGE AOP_GT_022_v_edges
 y2 = INT (y1 COIN EDGE AOP_GT_space_eqgt_081) == 0.022 OPPOSITE REGION //; two sides space > 0.08
 y3 = INT AOP_GT_space_eqgt_081 y1 == 0.022 OPPOSITE REGION
 err1 = y2 AND GT_P96
 err1 NOT INSIDE SealR_NOT_BULK

 out1 = ((y3 NOT y2) COIN EDGE y1) NOT COIN EDGE AOP_GT_space_eqgt_081
 out2 = EXT (out1) AOP_GT == 0.072 OPPOSITE
 out3 = EXT (out2) AOP_GT >= 0.072 <= 0.075 OPPOSITE
 err2 = out3 INSIDE EDGE GT_P96
 err2 NOT INSIDE EDGE SealR_NOT_BULK
}

GT_S_17k_2 {
@ Space between AOP_GT (width = 0.022/0.024um and one side poly space >= 0.081um) and AOP_GT, inside GT_P96 region = 0.072~0.075um
 y1 = AOP_GT_in_GT_P96 COIN EDGE AOP_GT_024_v_edges
 y2 = INT (y1 COIN EDGE AOP_GT_space_eqgt_081) == 0.024 OPPOSITE REGION //; two sides space > 0.08
 y3 = INT AOP_GT_space_eqgt_081 y1 == 0.024 OPPOSITE REGION
 err1 = y2 AND GT_P96
 err1 NOT INSIDE SealR_NOT_BULK

 out1 = ((y3 NOT y2) COIN EDGE y1) NOT COIN EDGE AOP_GT_space_eqgt_081
 out2 = EXT (out1) AOP_GT == 0.072 OPPOSITE
 out3 = EXT (out2) AOP_GT >= 0.072 <= 0.075 OPPOSITE
 err2 = out3 INSIDE EDGE GT_P96
 err2 NOT INSIDE EDGE SealR_NOT_BULK
}

AOP_GT_GR_Long_Side = AOP_GT_eqlt_032 COIN EDGE AOP_GT_v_edges
AOP_GT_GR_Area = EXT AOP_GT_GR_Long_Side <= 0.074 OPPOSITE REGION
AOP_GT_GR_Alls = AOP_GT_eqlt_032 OR AOP_GT_GR_Area
AOP_GT_GR_Real = AOP_GT_GR_Alls ENCLOSE AOP_GT_eqlt_032 >= 7
AOP_GT_GR_s207_s342_Area = EXT AOP_GT_v_edges AOP_GT_GR_Real >= 0.207 <= 0.342 OPPOSITE REGION EXCLUDE SHIELDED
AOP_GT_GR_s207_s343_Area = EXT AOP_GT_v_edges AOP_GT_GR_Real >= 0.207 <= 0.343 OPPOSITE REGION EXCLUDE SHIELDED

Forbidden_aop_GT_space_070_071 = EXT AOP_GT_v_edges >= 0.070 <= 0.071 OPPOSITE REGION
Forbidden_aop_GT_space_070_072 = EXT AOP_GT_v_edges >= 0.070 <= 0.072 OPPOSITE REGION
Forbidden_aop_GT_space_070_073 = EXT AOP_GT_v_edges >= 0.070 <= 0.073 OPPOSITE REGION
Forbidden_aop_GT_space_070_076 = EXT AOP_GT_v_edges >= 0.070 <= 0.076 OPPOSITE REGION
Forbidden_aop_GT_space_070_077 = EXT AOP_GT_v_edges >= 0.070 <= 0.077 OPPOSITE REGION
Forbidden_aop_GT_space_070_078 = EXT AOP_GT_v_edges >= 0.070 <= 0.078 OPPOSITE REGION
Forbidden_aop_GT_space_071_073 = EXT AOP_GT_v_edges >= 0.071 <= 0.073 OPPOSITE REGION
Forbidden_aop_GT_space_073_075 = EXT AOP_GT_v_edges >= 0.073 <= 0.075 OPPOSITE REGION
Forbidden_aop_GT_space_073_079 = EXT AOP_GT_v_edges >= 0.073 <= 0.079 OPPOSITE REGION
Forbidden_aop_GT_space_074_079 = EXT AOP_GT_v_edges >= 0.074 <= 0.079 OPPOSITE REGION
Forbidden_aop_GT_space_075_079 = EXT AOP_GT_v_edges >= 0.075 <= 0.079 OPPOSITE REGION
Forbidden_aop_GT_space_076_079 = EXT AOP_GT_v_edges >= 0.076 <= 0.079 OPPOSITE REGION
Forbidden_aop_GT_space_077_079 = EXT AOP_GT_v_edges >= 0.077 <= 0.079 OPPOSITE REGION
Forbidden_aop_GT_space_093_206 = EXT AOP_GT_v_edges >= 0.093 <= 0.206 OPPOSITE REGION EXCLUDE SHIELDED
Forbidden_aop_GT_space_100_206 = EXT AOP_GT_v_edges >= 0.100 <= 0.206 OPPOSITE REGION EXCLUDE SHIELDED
Forbidden_aop_GT_space_093_343 = EXT AOP_GT_v_edges >= 0.093 <= 0.343 OPPOSITE REGION EXCLUDE SHIELDED
Forbidden_aop_GT_space_100_342 = EXT AOP_GT_v_edges >= 0.100 <= 0.342 OPPOSITE REGION EXCLUDE SHIELDED
Forbidden_aop_GT_space_207_343 = EXT AOP_GT_v_edges >= 0.207 <= 0.343 OPPOSITE REGION EXCLUDE SHIELDED
Forbidden_aop_GT_space_207_342 = EXT AOP_GT_v_edges >= 0.207 <= 0.342 OPPOSITE REGION EXCLUDE SHIELDED

Forbidden_aop_GT_space_eq_070 = EXT AOP_GT_v_edges == 0.070 OPPOSITE REGION
Forbidden_aop_GT_space_eq_071 = EXT AOP_GT_v_edges == 0.071 OPPOSITE REGION
Forbidden_aop_GT_space_eq_072 = EXT AOP_GT_v_edges == 0.072 OPPOSITE REGION
Forbidden_aop_GT_space_eq_073 = EXT AOP_GT_v_edges == 0.073 OPPOSITE REGION
Forbidden_aop_GT_space_eq_075 = EXT AOP_GT_v_edges == 0.075 OPPOSITE REGION
Forbidden_aop_GT_space_eq_079 = EXT AOP_GT_v_edges == 0.079 OPPOSITE REGION
Forbidden_aop_GT_space_eq_081 = EXT AOP_GT_v_edges == 0.081 OPPOSITE REGION

GT_S_18b {
@ Forbidden space between AOP_GT (width = 0.016um) and AOP_GT = 0.070~0.071, 0.075~0.079, 0.1~0.342um
@ DRC don't check:
@ 1) AOP_GT (INSIDE P2) with PRL <= 0.012um
@ 2) Space to one AOP_GT group = 0.207~0.342um
@ AOP_GT group definition: number of (AOP_GT width <= 0.032um and space <= 0.074um) >= 7
@ 3) GT_P96 region
 Forbidden_range_A = COPY Forbidden_aop_GT_space_070_071
 Forbidden_range_B = COPY Forbidden_aop_GT_space_075_079
 Forbidden_range_C = COPY Forbidden_aop_GT_space_100_206
 Forbidden_range_D = COPY Forbidden_aop_GT_space_207_342
 Forbidden_range_A_InP2 = (Forbidden_range_A ENCLOSE RECTANGLE 0.070 0.012+GLOBAL_TOLERANCE ORTHOGONAL ONLY) INSIDE P2
 Forbidden_range_B_InP2 = (Forbidden_range_B ENCLOSE RECTANGLE 0.070 0.012+GLOBAL_TOLERANCE ORTHOGONAL ONLY) INSIDE P2
 Forbidden_range_C_InP2 = (Forbidden_range_C ENCLOSE RECTANGLE 0.070 0.012+GLOBAL_TOLERANCE ORTHOGONAL ONLY) INSIDE P2
 Forbidden_range_D_InP2 = (Forbidden_range_D ENCLOSE RECTANGLE 0.070 0.012+GLOBAL_TOLERANCE ORTHOGONAL ONLY) INSIDE P2
 err1 = AOP_GT_016_v_edges COIN EDGE (OR Forbidden_range_A_InP2 Forbidden_range_B_InP2 Forbidden_range_C_InP2 (Forbidden_range_D_InP2 NOT AOP_GT_GR_s207_s342_Area))
 err2 = AOP_GT_016_v_edges COIN EDGE ((Forbidden_range_A NOT INSIDE P2) OR ((Forbidden_range_B NOT INSIDE P2) OR (Forbidden_range_C NOT INSIDE P2)))
 err3 = AOP_GT_016_v_edges COIN EDGE ((Forbidden_range_D NOT INSIDE P2) NOT AOP_GT_GR_s207_s342_Area)
 err1 NOT INSIDE EDGE GT_P96
 err2 NOT INSIDE EDGE GT_P96
 err3 NOT INSIDE EDGE GT_P96
}

GT_S_18c {
@ Forbidden space between AOP_GT (width = 0.018um) and AOP_GT = 0.07, 0.074~0.079, 0.1~0.342um
@ DRC don't check:
@ 1) AOP_GT (INSIDE P2) with PRL <= 0.012um
@ 2) Space to one AOP_GT group = 0.207~0.342um
@ AOP_GT group definition: number of (AOP_GT width <= 0.032um and space <= 0.074um) >= 7
@ 3) GT_P96 region
 Forbidden_range_A = COPY Forbidden_aop_GT_space_eq_070
 Forbidden_range_B = COPY Forbidden_aop_GT_space_074_079
 Forbidden_range_C = COPY Forbidden_aop_GT_space_100_206
 Forbidden_range_D = COPY Forbidden_aop_GT_space_207_342
 Forbidden_range_A_InP2 = (Forbidden_range_A ENCLOSE RECTANGLE 0.070 0.012+GLOBAL_TOLERANCE ORTHOGONAL ONLY) INSIDE P2
 Forbidden_range_B_InP2 = (Forbidden_range_B ENCLOSE RECTANGLE 0.070 0.012+GLOBAL_TOLERANCE ORTHOGONAL ONLY) INSIDE P2
 Forbidden_range_C_InP2 = (Forbidden_range_C ENCLOSE RECTANGLE 0.070 0.012+GLOBAL_TOLERANCE ORTHOGONAL ONLY) INSIDE P2
 Forbidden_range_D_InP2 = (Forbidden_range_D ENCLOSE RECTANGLE 0.070 0.012+GLOBAL_TOLERANCE ORTHOGONAL ONLY) INSIDE P2
 err1 = AOP_GT_018_v_edges COIN EDGE (OR Forbidden_range_A_InP2 Forbidden_range_B_InP2 Forbidden_range_C_InP2 (Forbidden_range_D_InP2 NOT AOP_GT_GR_s207_s342_Area))
 err2 = AOP_GT_018_v_edges COIN EDGE ((Forbidden_range_A NOT INSIDE P2) OR ((Forbidden_range_B NOT INSIDE P2) OR (Forbidden_range_C NOT INSIDE P2)))
 err3 = AOP_GT_018_v_edges COIN EDGE ((Forbidden_range_D NOT INSIDE P2) NOT AOP_GT_GR_s207_s342_Area)
 err1 NOT INSIDE EDGE GT_P96
 err2 NOT INSIDE EDGE GT_P96
 err3 NOT INSIDE EDGE GT_P96
}

GT_S_18d {
@ Forbidden space between AOP_GT (width = 0.02um) and AOP_GT = 0.073~0.079, 0.1~0.342um
@ DRC don't check:
@ 1) AOP_GT (INSIDE P2) with PRL <= 0.012um
@ 2) Space to one AOP_GT group = 0.207~0.342um
@ AOP_GT group definition: number of (AOP_GT width <= 0.032um and space <= 0.074um) >= 7
@ 3) GT_P96 and INST regions
 WAIVE_AREA = OR GT_P96 INST
 Forbidden_range_A = COPY Forbidden_aop_GT_space_073_079
 Forbidden_range_B = COPY Forbidden_aop_GT_space_100_206
 Forbidden_range_C = COPY Forbidden_aop_GT_space_207_342
 Forbidden_range_A_InP2 = (Forbidden_range_A ENCLOSE RECTANGLE 0.070 0.012+GLOBAL_TOLERANCE ORTHOGONAL ONLY) INSIDE P2
 Forbidden_range_B_InP2 = (Forbidden_range_B ENCLOSE RECTANGLE 0.070 0.012+GLOBAL_TOLERANCE ORTHOGONAL ONLY) INSIDE P2
 Forbidden_range_C_InP2 = (Forbidden_range_C ENCLOSE RECTANGLE 0.070 0.012+GLOBAL_TOLERANCE ORTHOGONAL ONLY) INSIDE P2
 err1 = AOP_GT_020_v_edges COIN EDGE (OR Forbidden_range_A_InP2 Forbidden_range_B_InP2 (Forbidden_range_C_InP2 NOT AOP_GT_GR_s207_s342_Area))
 err2 = AOP_GT_020_v_edges COIN EDGE ((Forbidden_range_A NOT INSIDE P2) OR (Forbidden_range_B NOT INSIDE P2))
 err3 = AOP_GT_020_v_edges COIN EDGE ((Forbidden_range_C NOT INSIDE P2) NOT AOP_GT_GR_s207_s342_Area)
 err1 NOT INSIDE EDGE WAIVE_AREA
 err2 NOT INSIDE EDGE WAIVE_AREA
 err3 NOT INSIDE EDGE WAIVE_AREA
}

GT_S_18f {
@ Forbidden space between AOP_GT (width = 0.016um, INSIDE GT_P96) and AOP_GT = 0.07~0.077, 0.1~0.342um
@ DRC don't check:
@ 1) AOP_GT (INSIDE P2) with PRL <= 0.012um
 Forbidden_range_A = COPY Forbidden_aop_GT_space_070_077
 Forbidden_range_B = COPY Forbidden_aop_GT_space_100_342
 Forbidden_range_A_InP2 = (Forbidden_range_A ENCLOSE RECTANGLE 0.070 0.012+GLOBAL_TOLERANCE ORTHOGONAL ONLY) INSIDE P2
 Forbidden_range_B_InP2 = (Forbidden_range_B ENCLOSE RECTANGLE 0.070 0.012+GLOBAL_TOLERANCE ORTHOGONAL ONLY) INSIDE P2
 err1_TMP = AOP_GT_016_v_edges COIN EDGE (OR Forbidden_range_A_InP2 Forbidden_range_B_InP2)
 err2_TMP = AOP_GT_016_v_edges COIN EDGE ((Forbidden_range_A NOT INSIDE P2) OR (Forbidden_range_B NOT INSIDE P2))
 err1 = err1_TMP INSIDE EDGE GT_P96
 err2 = err2_TMP INSIDE EDGE GT_P96
 err1 NOT INSIDE EDGE SealR_NOT_BULK
 err2 NOT INSIDE EDGE SealR_NOT_BULK
}

GT_S_18g {
@ Forbidden space between AOP_GT (width = 0.018um, INSIDE GT_P96) and AOP_GT = 0.07~0.076, 0.1~0.342um
@ DRC don't check:
@ 1) AOP_GT (INSIDE P2) with PRL <= 0.012um
 Forbidden_range_A = COPY Forbidden_aop_GT_space_070_076
 Forbidden_range_B = COPY Forbidden_aop_GT_space_100_342
 Forbidden_range_A_InP2 = (Forbidden_range_A ENCLOSE RECTANGLE 0.070 0.012+GLOBAL_TOLERANCE ORTHOGONAL ONLY) INSIDE P2
 Forbidden_range_B_InP2 = (Forbidden_range_B ENCLOSE RECTANGLE 0.070 0.012+GLOBAL_TOLERANCE ORTHOGONAL ONLY) INSIDE P2
 err1_TMP = AOP_GT_018_v_edges COIN EDGE (OR Forbidden_range_A_InP2 Forbidden_range_B_InP2)
 err2_TMP = AOP_GT_018_v_edges COIN EDGE ((Forbidden_range_A NOT INSIDE P2) OR (Forbidden_range_B NOT INSIDE P2))
 err1 = err1_TMP INSIDE EDGE GT_P96
 err2 = err2_TMP INSIDE EDGE GT_P96
 err1 NOT INSIDE EDGE SealR_NOT_BULK
 err2 NOT INSIDE EDGE SealR_NOT_BULK
}

GT_S_18h {
@ Forbidden space between AOP_GT (width = 0.02um, INSIDE GT_P96) and AOP_GT (except 0.032um AOP_GT) = 0.071~0.073, 0.079, 0.1~0.342um
@ DRC don't check:
@ 1) AOP_GT (INSIDE P2) with PRL <= 0.012um
 Forbidden_aop_GT_space_071_073_GT_032 = EXT AOP_GT_v_edges AOP_GT_032_v_edges >= 0.071 <= 0.073 OPPOSITE REGION
 Forbidden_aop_GT_space_eq_079_GT_032 = EXT AOP_GT_v_edges AOP_GT_032_v_edges == 0.079 OPPOSITE REGION
 Forbidden_aop_GT_space_100_342_GT_032 = EXT (EXT [AOP_GT_v_edges] >= 0.100 <= 0.342 OPPOSITE EXCLUDE SHIELDED) AOP_GT_032_v_edges >= 0.100 <= 0.342 OPPOSITE REGION EXCLUDE SHIELDED
 Forbidden_range_A = Forbidden_aop_GT_space_071_073 NOT Forbidden_aop_GT_space_071_073_GT_032
 Forbidden_range_B = Forbidden_aop_GT_space_eq_079 NOT Forbidden_aop_GT_space_eq_079_GT_032
 Forbidden_range_C = Forbidden_aop_GT_space_100_342 NOT Forbidden_aop_GT_space_100_342_GT_032
 Forbidden_range_A_InP2 = (Forbidden_range_A ENCLOSE RECTANGLE 0.070 0.012+GLOBAL_TOLERANCE ORTHOGONAL ONLY) INSIDE P2
 Forbidden_range_B_InP2 = (Forbidden_range_B ENCLOSE RECTANGLE 0.070 0.012+GLOBAL_TOLERANCE ORTHOGONAL ONLY) INSIDE P2
 Forbidden_range_C_InP2 = (Forbidden_range_C ENCLOSE RECTANGLE 0.070 0.012+GLOBAL_TOLERANCE ORTHOGONAL ONLY) INSIDE P2
 err1_TMP = AOP_GT_020_v_edges COIN EDGE (OR Forbidden_range_A_InP2 Forbidden_range_B_InP2 Forbidden_range_C_InP2)
 err2_TMP = AOP_GT_020_v_edges COIN EDGE ((Forbidden_range_A NOT INSIDE P2) OR ((Forbidden_range_B NOT INSIDE P2) OR (Forbidden_range_C NOT INSIDE P2)))
 err1 = err1_TMP INSIDE EDGE GT_P96
 err2 = err2_TMP INSIDE EDGE GT_P96
 err1 NOT INSIDE EDGE SealR_NOT_BULK
 err2 NOT INSIDE EDGE SealR_NOT_BULK
}

GT_S_18i {
@ Forbidden space between AOP_GT (width = 0.024um, INSIDE GT_P96) and AOP_GT = 0.07~0.071, 0.075~0.079, 0.1~0.342um
@ DRC don't check:
@ 1) AOP_GT (INSIDE P2) with PRL <= 0.012um
 Forbidden_range_A = COPY Forbidden_aop_GT_space_070_071
 Forbidden_range_B = COPY Forbidden_aop_GT_space_075_079
 Forbidden_range_C = COPY Forbidden_aop_GT_space_100_342
 Forbidden_range_A_InP2 = (Forbidden_range_A ENCLOSE RECTANGLE 0.070 0.012+GLOBAL_TOLERANCE ORTHOGONAL ONLY) INSIDE P2
 Forbidden_range_B_InP2 = (Forbidden_range_B ENCLOSE RECTANGLE 0.070 0.012+GLOBAL_TOLERANCE ORTHOGONAL ONLY) INSIDE P2
 Forbidden_range_C_InP2 = (Forbidden_range_C ENCLOSE RECTANGLE 0.070 0.012+GLOBAL_TOLERANCE ORTHOGONAL ONLY) INSIDE P2
 err1_TMP = AOP_GT_024_v_edges COIN EDGE (OR Forbidden_range_A_InP2 Forbidden_range_B_InP2 Forbidden_range_C_InP2)
 err2_TMP = AOP_GT_024_v_edges COIN EDGE ((Forbidden_range_A NOT INSIDE P2) OR ((Forbidden_range_B NOT INSIDE P2) OR (Forbidden_range_C NOT INSIDE P2)))
 err1 = err1_TMP INSIDE EDGE GT_P96
 err2 = err2_TMP INSIDE EDGE GT_P96
 err1 NOT INSIDE EDGE SealR_NOT_BULK
 err2 NOT INSIDE EDGE SealR_NOT_BULK
}

GT_S_18j {
@ Forbidden space between AOP_GT (width = 0.022um, INSIDE GT_P96) and AOP_GT = 0.07~0.072, 0.076~0.079, 0.1~0.342um
@ DRC don’t check:
@ 1) AOP_GT (INSIDE P2) with PRL <= 0.012um
 Forbidden_range_A = COPY Forbidden_aop_GT_space_070_072
 Forbidden_range_B = COPY Forbidden_aop_GT_space_076_079
 Forbidden_range_C = COPY Forbidden_aop_GT_space_100_342
 Forbidden_range_A_InP2 = (Forbidden_range_A ENCLOSE RECTANGLE 0.070 0.012+GLOBAL_TOLERANCE ORTHOGONAL ONLY) INSIDE P2
 Forbidden_range_B_InP2 = (Forbidden_range_B ENCLOSE RECTANGLE 0.070 0.012+GLOBAL_TOLERANCE ORTHOGONAL ONLY) INSIDE P2
 Forbidden_range_C_InP2 = (Forbidden_range_C ENCLOSE RECTANGLE 0.070 0.012+GLOBAL_TOLERANCE ORTHOGONAL ONLY) INSIDE P2
 err1_TMP = AOP_GT_022_v_edges COIN EDGE (OR Forbidden_range_A_InP2 Forbidden_range_B_InP2 Forbidden_range_C_InP2)
 err2_TMP = AOP_GT_022_v_edges COIN EDGE (((Forbidden_range_A NOT INSIDE P2) OR (Forbidden_range_B NOT INSIDE P2)) OR (Forbidden_range_C NOT INSIDE P2))
 err1 = err1_TMP INSIDE EDGE GT_P96
 err2 = err2_TMP INSIDE EDGE GT_P96
 err1 NOT INSIDE EDGE SealR_NOT_BULK
 err2 NOT INSIDE EDGE SealR_NOT_BULK
}

GT_S_18k {
@ Forbidden space between AOP_GT (width = 0.02um, INSIDE GT_P96) and AOP_GT (width = 0.032) = 0.073~0.075, 0.081, 0.1~0.342um
@ DRC don’t check:
@ 1) AOP_GT (INSIDE P2) with PRL <= 0.012um
 Forbidden_range_A = COPY Forbidden_aop_GT_space_073_075
 Forbidden_range_B = COPY Forbidden_aop_GT_space_eq_081
 Forbidden_range_C = COPY Forbidden_aop_GT_space_100_342
 Forbidden_range_A_InP2 = (Forbidden_range_A ENCLOSE RECTANGLE 0.070 0.012+GLOBAL_TOLERANCE ORTHOGONAL ONLY) INSIDE P2
 Forbidden_range_B_InP2 = (Forbidden_range_B ENCLOSE RECTANGLE 0.070 0.012+GLOBAL_TOLERANCE ORTHOGONAL ONLY) INSIDE P2
 Forbidden_range_C_InP2 = (Forbidden_range_C ENCLOSE RECTANGLE 0.070 0.012+GLOBAL_TOLERANCE ORTHOGONAL ONLY) INSIDE P2
 err1_TMP = ((OR Forbidden_range_A_InP2 Forbidden_range_B_InP2 Forbidden_range_C_InP2) WITH EDGE AOP_GT_020_v_edges) WITH EDGE AOP_GT_032_v_edges
 err2_TMP = ((((Forbidden_range_A NOT INSIDE P2) OR (Forbidden_range_B NOT INSIDE P2)) OR (Forbidden_range_C NOT INSIDE P2)) WITH EDGE AOP_GT_020_v_edges) WITH EDGE AOP_GT_032_v_edges
 err1 = err1_TMP NOT OUTSIDE GT_P96
 err2 = err2_TMP NOT OUTSIDE GT_P96
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

GT_S_19 {
@ Space between AOP_GT jog (width <= 0.004um) and GATE in GATE poly direction when PRL > -0.096um. >= 0.048um
 err1 = EXT AOP_GT_jog_lteq_004 GATE < 0.048 OPPOSITE EXTENDED 0.096 MEASURE ALL REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

#IFDEF DFM_RULES_PRIORITY_1 YES
NODMF_SIZE_045 = SIZE NODMF BY 0.45
MARKS_SIZE_045 = SIZE MARKS BY 0.45

GT_S_20a_DFM1 {
@ Empty space between (ALL_GT NOT P2), except DIR, RESNW, OCCD, OCOVL, LOGO, and ((Chip corner stress relief and MARKS) su 0.45um) regions
@ DRC flags (((chip NOT (ALL_GT NOT P2)) sd 0.45um) su 0.45um) <= 0.9um
 waive_AREA = OR MARKS_SIZE_045 NODMF_SIZE_045 RESNW DIR OCCD OCOVL LOGO
 check_AREA = (DRC:1 NOT ALL_GT_NOT_P2) NOT waive_AREA
 err1 = SIZE check_AREA BY 0.45 UNDEROVER
 err1 NOT INSIDE SealR_NOT_BULK
}
#ENDIF

GT_EX_1 {
@ AOP_GT jog (width <= 0.004um) extension outside of GATE in GATE poly direction when PRL > -0.1um. >= 0.048um
 chk_GATE = ANGLE GATE == 0
 err1 = ENC chk_GATE (AOP_GT COIN EDGE AOP_GT_jog_lteq_004) < 0.048 OPPOSITE EXTENDED 0.100 MEASURE ALL REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

GT_EX_2 {
@ AOP_GT extension outside of AA in GATE poly direction (extension < 0 is not allowed), except AOP_GT jog <= 0.004um and MARKS region >= 0.041um
 err1_TMP = ENC AA [AOP_GT_h_edges] < 0.041 ABUT<90 OPPOSITE INSIDE ALSO
 err1 = (err1_TMP NOT COIN EDGE AOP_GT_jog_lteq_004) NOT INSIDE EDGE MARKS
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

GT_L_1 {
@ Maximum (GT NOT P2) (GT width <= 0.032um) length between two M0Gs, as well as the length from any point inside GATE to the nearest M0G when the GT width <= 0.032um, except ESDMK1, ESDIO1 and ESDIO2 regions <= 10.5um
//;dummy GT without M0G or gate is ok
 except_region = OR ESDMK1 ESDIO_all
 tar_gt = (GT_0 AND GT_eqlt_032) NOT INSIDE except_region
 X1 = tar_gt OUTSIDE EDGE M0G
 X2 = INT X1 <= 0.032 OPPOSITE REGION
 X3 = X2 ENCLOSE RECTANGLE 10.5+GLOBAL_TOLERANCE 0.002 ORTHOGONAL ONLY
 err1 = (X3 INTERACT M0G == 2) NOT INTERACT GATE
 err1 NOT INSIDE except_region

 tar_gate = GATE NOT INSIDE except_region
 tar_gate_032 = (GT_0 AND GT_eqlt_032) NOT INSIDE except_region
 tar_gate_chk = tar_gate_032 ENCLOSE RECTANGLE 10.5+GLOBAL_TOLERANCE 0.002 ORTHOGONAL ONLY

 Y0_input = tar_gate_chk INTERACT tar_gate
 Y0_step1 = M0G AND Y0_input
 Y0_good1 = tar_gate INTERACT Y0_input

//;sizing operations are splitted into 9 steps
 Y1_input = COPY Y0_input
 Y1_step1 = SIZE Y0_step1 BY 1 INSIDE OF Y1_input STEP 0.10 //;based on GT.S.1 and M0G.EX.1
 Y1_good1 = Y0_good1 NOT INSIDE Y1_step1   //;step1: 1.00um

 Y2_input = Y1_input INTERACT Y1_good1
 Y2_step1 = SIZE Y1_step1 BY 1 INSIDE OF Y2_input STEP 0.10
 Y2_good1 = Y1_good1 NOT INSIDE Y2_step1   //;step2: 1.00um

 Y3_input = Y2_input INTERACT Y2_good1
 Y3_step1 = SIZE Y2_step1 BY 1 INSIDE OF Y3_input STEP 0.10
 Y3_good1 = Y2_good1 NOT INSIDE Y3_step1   //;step3: 1.00um

 Y4_input = Y3_input INTERACT Y3_good1
 Y4_step1 = SIZE Y3_step1 BY 1 INSIDE OF Y4_input STEP 0.10
 Y4_good1 = Y3_good1 NOT INSIDE Y4_step1   //;step4: 1.00um

 Y5_input = Y4_input INTERACT Y4_good1
 Y5_step1 = SIZE Y4_step1 BY 1 INSIDE OF Y5_input STEP 0.10
 Y5_good1 = Y4_good1 NOT INSIDE Y5_step1   //;step5: 1.00um

 Y6_input = Y5_input INTERACT Y5_good1
 Y6_step1 = SIZE Y5_step1 BY 1 INSIDE OF Y6_input STEP 0.10
 Y6_good1 = Y5_good1 NOT INSIDE Y6_step1   //;step6: 1.00um

 Y7_input = Y6_input INTERACT Y6_good1
 Y7_step1 = SIZE Y6_step1 BY 1 INSIDE OF Y7_input STEP 0.10
 Y7_good1 = Y6_good1 NOT INSIDE Y7_step1   //;step7: 1.00um

 Y8_input = Y7_input INTERACT Y7_good1
 Y8_step1 = SIZE Y7_step1 BY 1 INSIDE OF Y8_input STEP 0.10
 Y8_good1 = Y7_good1 NOT INSIDE Y8_step1   //;step8: 1.00um

 Y9_input = Y8_input INTERACT Y8_good1
 Y9_step1 = SIZE Y8_step1 BY 2.5 INSIDE OF Y9_input STEP 0.10
 Y9_good1 = Y8_good1 NOT INSIDE Y9_step1   //;step9: 2.50um
 err2 = Y9_good1 NOT Y9_step1
 err2 NOT INSIDE except_region
}

GT_L_2 {
@ AOP_GT length (width < 0.07um), except DMCMK1 region >= 0.246um
 err1 = AOP_GT_lt_070 NOT (AOP_GT_lt_070 ENCLOSE RECTANGLE 0.002 0.246 ORTHOGONAL ONLY)
 err1 NOT INSIDE DMCMK1
}

GT_L_3 {
@ AOP_GT length (width >= 0.07um), except DMCMK1 region >= 0.225um
 err1 = AOP_GT_eqgt_070 NOT (AOP_GT_eqgt_070 ENCLOSE RECTANGLE 0.002 0.225 ORTHOGONAL ONLY)
 err1 NOT INSIDE DMCMK1
}

GT_L_4 {
@ AOP_GT jog length (jog width <= 0.004um) >= 0.24um
 edge_waive = CONVEX EDGE AOP_GT ANGLE1 == 90 LENGTH1 >= 0.24 ANGLE2 == 270 LENGTH2 >= 0.24 WITH LENGTH <= 0.004
 edge_check = LENGTH AOP_GT_convex_90_270_edge <= 0.004
 err1 = edge_check NOT COIN EDGE edge_waive
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

GT_L_6 {
@ Length of ((ALL_GT NOT P2) INTERACT ALL_AA), except DMPNP, VARMOS region <= 10.5um
 chk_ALL_GT = ALL_GT_NOT_P2 INTERACT ALL_AA
 err1 = chk_ALL_GT ENCLOSE RECTANGLE 0.002 10.5+GLOBAL_TOLERANCE ORTHOGONAL ONLY
 err1 NOT INSIDE (OR DMPNP VARMOS)
}

GT_L_7 {
@ Length of ((ALL_GT (width >= 0.032um) NOT ALL_P2) INTERACT ALL_AA), except DMPNP, VARMOS, LDBK and DMC1 regions <= 1.6um
 chk_ALL_GT = (ALL_GT_eqgt_032 NOT ALL_P2) INTERACT ALL_AA
 err1 = chk_ALL_GT ENCLOSE RECTANGLE 0.002 1.6+GLOBAL_TOLERANCE ORTHOGONAL ONLY
 err1 NOT INSIDE (OR DMPNP VARMOS LDBK DMC1)
}

GT_A_1 {
@ GT area >= 0.00416um2
 err1 = AREA GT < 0.00416
 err1 NOT INSIDE SealR_NOT_BULK
}

VARIABLE GT_A_2_val 2.45

ALL_GT_area_CHK = AREA (ALL_GT_NOT_P2_ALL NOT (OR DMPNP MARKS OCOVL)) > GT_A_2_val
ALL_GT_filt_a = ALL_GT_area_CHK WITH WIDTH <= 0.032
ALL_GT_filt_b = (WITH WIDTH ALL_GT_area_CHK >= 0.1 <= 0.242) NOT ENCLOSE RECTANGLE 0.001 30+GLOBAL_TOLERANCE
ALL_GT_filt_c = OR ALL_GT_filt_a ALL_GT_filt_b
ALL_GT_filt_d = SIZE ALL_GT_filt_c BY 5

GT_A_2 {
@ (ALL_GT NOT ALL_P2) area <= 2.45um2
@ DRC don't check:
@ 1) BJT region (DMPNP) and OCOVL region
@ 2) (AOP_GT NOT ALL_P2) (width <= 0.032um) enclosed in 10um*10um window with GT density <= 50%
@ 3) (ALL_GT NOT ALL_P2) (width = 0.1um ~ 0.242um, length <= 30um) enclosed in 10um*10um window with poly density <= 50%
 STEP_1 = ALL_GT_NOT_P2_ALL AND ALL_GT_filt_d
 STEP_2 = DENSITY STEP_1 ALL_GT_filt_d [!!AREA(ALL_GT_filt_d)*AREA(STEP_1)/AREA(ALL_GT_filt_d)] > 0.5 WINDOW 10 STEP 5 BACKUP INSIDE OF LAYER DRC:1 BY POLYGON PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_GT_A_2.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_GT_A_2.rdb"
 STEP_3 = ALL_GT_filt_c NOT INTERACT (ALL_GT_filt_c AND STEP_2)
 err1 = (ALL_GT_area_CHK NOT STEP_3) NOT (OR DMPNP MARKS OCOVL)
 err1 NOT INSIDE SealR_NOT_BULK
}

GT_A_3 {
@ (ALL_GT NOT ALL_P2) area INSIDE DMPNP region <= 4.1um2
 err1 = AREA (ALL_GT_NOT_P2_ALL INSIDE DMPNP) > 4.1
 err1 NOT INSIDE SealR_NOT_BULK
}

#IFDEF MINIMUM_DENSITY_CHECK YES
GT_A_4 {
@ When (ALL_GT NOT ALL_P2) space >= 1.21um, the PRL must be <= 17um, except (NODMF OR MARKS), DIR, DIRDMP, OCOVL regions
 except_area = OR NODMF MARKS DIR DIRDMP OCOVL
 STEP_1 = SIZE ALL_GT_NOT_P2_ALL BY 1.21/2 OVERUNDER
 STEP_2 = (DRC:1 NOT STEP_1) NOT except_area
 STEP_3 = SIZE STEP_2 BY 1.21/2 UNDEROVER
 err1 = ENCLOSE RECTANGLE STEP_3 17 1.21 ORTHOGONAL ONLY
 err1 NOT INSIDE except_area
}

GT_A_4a {
@ When (ALL_GT NOT ALL_P2) space >= 0.91um, the PRL must be <= 5.5um
@ Except (NODMF OR MARKS), RESNW, DIR, DIRDMP, DMPNP, LOGO, OCOVL regions
 except_area = OR NODMF MARKS RESNW DIR DIRDMP DMPNP LOGO OCOVL
 STEP_1 = SIZE ALL_GT_NOT_P2_ALL BY 0.91/2 OVERUNDER
 STEP_2 = (DRC:1 NOT STEP_1) NOT except_area
 STEP_3 = SIZE STEP_2 BY 0.91/2 UNDEROVER
 err1 = ENCLOSE RECTANGLE STEP_3 5.5 0.91 ORTHOGONAL ONLY
 err1 NOT INSIDE except_area
}

GT_A_5_except_1_TMP = EXT INST (AOP_GT NOT ALL_P2) <= 0.4 OPPOSITE
GT_A_5_except_1 = DFM COPY (DFM PROPERTY GT_A_5_except_1_TMP [-= EC(GT_A_5_except_1_TMP)] > 0.25) REGION
GT_A_5_except_2 = ENC INST BORDER <= 0.16 ABUT<90 SINGULAR REGION

GT_A_5 {
@ When (ALL_GT NOT ALL_P2) space >= 0.55um in ((INST SIZING 1um) NOT INST), the PRL must be <= 10um
@ Except BORDER enclosure INST <= 0.16um in cell level
 STEP_1 = (SIZE INST BY 1) NOT INST
 STEP_2 = SIZE ALL_GT_NOT_P2_ALL BY 0.55/2 OVERUNDER
 STEP_3 = (STEP_1 NOT STEP_2) NOT GT_A_5_except_2
 err1 = ENCLOSE RECTANGLE STEP_3 10 0.55 ORTHOGONAL ONLY
 err1 NOT INSIDE MARKS
}
#ENDIF

#IFDEF IP_LEVEL_DENSITY_CHECK YES
#IFDEF MINIMUM_DENSITY_CHECK YES
GT_D_1 {
@ (ALL_GT NOT ALL_P2) full chip density >= 14%
 check_pattern = ALL_GT_NOT_P2_ALL NOT MARKS
 DENSITY check_pattern CHIP_NOT_MARKS < 0.14 [AREA(check_pattern)/AREA(CHIP_NOT_MARKS)] PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_GT_D_1.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_GT_D_1.rdb"
}
#ENDIF

GT_D_2 {
@ (ALL_GT NOT ALL_P2) full chip density <= 40%
 check_pattern = ALL_GT_NOT_P2_ALL NOT MARKS
 DENSITY check_pattern CHIP_NOT_MARKS > 0.4 [AREA(check_pattern)/AREA(CHIP_NOT_MARKS)] PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_GT_D_2.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_GT_D_2.rdb"
}

#IFDEF MINIMUM_DENSITY_CHECK YES
VARIABLE GT_D_3_val 10.5
VARIABLE GT_D_3_window 10

GT_D_3 {
@ (ALL_GT NOT ALL_P2) density, except (NODMF su 1um), OCOVL, DIR, DIRDMP regions (window 10um*10um, stepping 10um/step_number) >= 10.5%
 waive_area = OR NODMF_SIZE_1 MARKS DIR DIRDMP OCOVL
 check_region = DRC:1 NOT waive_area
 check_pattern = ALL_GT_NOT_P2_ALL AND check_region

 check_window1 = check_region WITH WIDTH >= GT_D_3_window/4
 err1_TMP1 = DENSITY check_pattern check_window1 check_region [!AREA(check_window1) + !!AREA(check_window1)*AREA(check_pattern)/AREA(check_region)] < GT_D_3_val/100 WINDOW GT_D_3_window STEP GT_D_3_window/step_number BACKUP INSIDE OF LAYER DRC:1 BY POLYGON

 check_window2 = WITH WIDTH (check_region AND err1_TMP1) >= GT_D_3_window/4
 err1_TMP2 = DENSITY check_pattern check_window2 check_region [!AREA(check_window2) + !!AREA(check_window2)*AREA(check_pattern)/AREA(check_region)] < GT_D_3_val/100 WINDOW GT_D_3_window STEP GT_D_3_window/step_number BACKUP INSIDE OF LAYER err1_TMP1 BY POLYGON

 check_window3 = WITH WIDTH (check_region AND err1_TMP2) >= GT_D_3_window/4
 DENSITY check_pattern check_window3 check_region [!AREA(check_window3) + !!AREA(check_window3)*AREA(check_pattern)/AREA(check_region)] < GT_D_3_val/100 WINDOW GT_D_3_window STEP GT_D_3_window/step_number BACKUP INSIDE OF LAYER err1_TMP2 BY POLYGON PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_GT_D_3.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_GT_D_3.rdb"
}

VARIABLE GT_D_4_val 6
VARIABLE GT_D_4_window 10

GT_D_4 {
@ (ALL_GT NOT ALL_P2) density for RESP1 region (window 10um*10um, stepping 10um/step_number) >= 6%
 check_region = (CHIP_NOT_MARKS WITH WIDTH >= 2.5) AND RESP1
 check_pattern = ALL_GT_NOT_P2_ALL AND check_region

 check_window1 = COPY RESP1
 err1_TMP1 = DENSITY check_pattern check_window1 check_region [!AREA(check_window1) + !!AREA(check_window1)*AREA(check_pattern)/AREA(check_region)] < GT_D_4_val/100 WINDOW GT_D_4_window STEP GT_D_4_window/step_number BACKUP INSIDE OF LAYER DRC:1 BY POLYGON

 check_window2 = WITH WIDTH (check_region AND err1_TMP1) >= GT_D_4_window/4
 err1_TMP2 = DENSITY check_pattern check_window2 check_region [!AREA(check_window2) + !!AREA(check_window2)*AREA(check_pattern)/AREA(check_region)] < GT_D_4_val/100 WINDOW GT_D_4_window STEP GT_D_4_window/step_number BACKUP INSIDE OF LAYER err1_TMP1 BY POLYGON

 check_window3 = WITH WIDTH (check_region AND err1_TMP2) >= GT_D_4_window/4
 DENSITY check_pattern check_window3 check_region [!AREA(check_window3) + !!AREA(check_window3)*AREA(check_pattern)/AREA(check_region)] < GT_D_4_val/100 WINDOW GT_D_4_window STEP GT_D_4_window/step_number BACKUP INSIDE OF LAYER err1_TMP2 BY POLYGON PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_GT_D_4.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_GT_D_4.rdb"
}
#ENDIF

VARIABLE GT_D_5_val 47.5
VARIABLE GT_D_5_window 10

GT_D_5 {
@ (ALL_GT NOT ALL_P2) density for core device region (window 10um*10um, stepping 10um/step_number) <= 47.5%
 check_region = CHIP_NOT_MARKS NOT DG
 check_pattern = ALL_GT_NOT_P2_ALL AND check_region

 check_window1 = check_region WITH WIDTH >= GT_D_5_window/4
 err1_TMP1 = DENSITY check_pattern check_window1 check_region [!!AREA(check_window1)*AREA(check_pattern)/AREA(check_region)] > GT_D_5_val/100 WINDOW GT_D_5_window STEP GT_D_5_window/step_number BACKUP INSIDE OF LAYER DRC:1 BY POLYGON

 check_window2 = WITH WIDTH (check_region AND err1_TMP1) >= GT_D_5_window/4
 err1_TMP2 = DENSITY check_pattern check_window2 check_region [!!AREA(check_window2)*AREA(check_pattern)/AREA(check_region)] > GT_D_5_val/100 WINDOW GT_D_5_window STEP GT_D_5_window/step_number BACKUP INSIDE OF LAYER err1_TMP1 BY POLYGON

 check_window3 = WITH WIDTH (check_region AND err1_TMP2) >= GT_D_5_window/4
 DENSITY check_pattern check_window3 check_region [!!AREA(check_window3)*AREA(check_pattern)/AREA(check_region)] > GT_D_5_val/100 WINDOW GT_D_5_window STEP GT_D_5_window/step_number BACKUP INSIDE OF LAYER err1_TMP2 BY POLYGON PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_GT_D_5.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_GT_D_5.rdb"
}

VARIABLE GT_D_5a_val 57
VARIABLE GT_D_5a_window 10

GT_D_5a {
@ (ALL_GT NOT ALL_P2) density for I/O device region (window 10um*10um, stepping 10um/step_number) <= 57%
 check_region = DG NOT MARKS
 check_pattern = ALL_GT_NOT_P2_ALL AND check_region

 check_window1 = check_region WITH WIDTH >= GT_D_5a_window/4
 err1_TMP1 = DENSITY check_pattern check_window1 check_region [!!AREA(check_window1)*AREA(check_pattern)/AREA(check_region)] > GT_D_5a_val/100 WINDOW GT_D_5a_window STEP GT_D_5a_window/step_number BACKUP INSIDE OF LAYER DRC:1 BY POLYGON

 check_window2 = WITH WIDTH (check_region AND err1_TMP1) >= GT_D_5a_window/4
 err1_TMP2 = DENSITY check_pattern check_window2 check_region [!!AREA(check_window2)*AREA(check_pattern)/AREA(check_region)] > GT_D_5a_val/100 WINDOW GT_D_5a_window STEP GT_D_5a_window/step_number BACKUP INSIDE OF LAYER err1_TMP1 BY POLYGON

 check_window3 = WITH WIDTH (check_region AND err1_TMP2) >= GT_D_5a_window/4
 DENSITY check_pattern check_window3 check_region [!!AREA(check_window3)*AREA(check_pattern)/AREA(check_region)] > GT_D_5a_val/100 WINDOW GT_D_5a_window STEP GT_D_5a_window/step_number BACKUP INSIDE OF LAYER err1_TMP2 BY POLYGON PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_GT_D_5a.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_GT_D_5a.rdb"
}

VARIABLE GT_D_6_val 47.5
VARIABLE GT_D_6_window 140

GT_D_6 {
@ (ALL_GT NOT ALL_P2) density (window 140um*140um, stepping 140um/step_number) <= 47.5%
 check_region = COPY CHIP_NOT_MARKS
 check_pattern = ALL_GT_NOT_P2_ALL AND check_region

 check_window1 = check_region WITH WIDTH >= GT_D_6_window/4
 err1_TMP1 = DENSITY check_pattern check_window1 check_region [!!AREA(check_window1)*AREA(check_pattern)/AREA(check_region)] > GT_D_6_val/100 WINDOW GT_D_6_window STEP GT_D_6_window/step_number BACKUP INSIDE OF LAYER DRC:1 BY POLYGON

 check_window2 = WITH WIDTH (check_region AND err1_TMP1) >= GT_D_6_window/4
 err1_TMP2 = DENSITY check_pattern check_window2 check_region [!!AREA(check_window2)*AREA(check_pattern)/AREA(check_region)] > GT_D_6_val/100 WINDOW GT_D_6_window STEP GT_D_6_window/step_number BACKUP INSIDE OF LAYER err1_TMP1 BY POLYGON

 check_window3 = WITH WIDTH (check_region AND err1_TMP2) >= GT_D_6_window/4
 DENSITY check_pattern check_window3 check_region [!!AREA(check_window3)*AREA(check_pattern)/AREA(check_region)] > GT_D_6_val/100 WINDOW GT_D_6_window STEP GT_D_6_window/step_number BACKUP INSIDE OF LAYER err1_TMP2 BY POLYGON PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_GT_D_6.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_GT_D_6.rdb"
}

GT_D_7 {
@ (ALL_GT NOT ALL_P2) density difference between any two neighboring checking window (window 20um*20um, stepping 20um/step_number) <= 33.3%
 check_pattern = ALL_GT_NOT_P2_ALL NOT MARKS
 DENSITY check_pattern CHIP_NOT_MARKS [AREA(check_pattern)/AREA(CHIP_NOT_MARKS)] >= 0 WINDOW 20 STEP 20/step_number GRADIENT > 0.333 ABSOLUTE BACKUP PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_GT_D_7.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_GT_D_7.rdb"
}
#ELSE

#IFDEF MINIMUM_DENSITY_CHECK YES
GT_D_1 {
@ (ALL_GT NOT ALL_P2) full chip density >= 14%
 check_pattern = ALL_GT_NOT_P2_ALL NOT MARKS
 DENSITY check_pattern CHIP_NOT_MARKS < 0.14 [AREA(check_pattern)/AREA(CHIP_NOT_MARKS)] PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_GT_D_1.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_GT_D_1.rdb"
}
#ENDIF

GT_D_2 {
@ (ALL_GT NOT ALL_P2) full chip density <= 40%
 check_pattern = ALL_GT_NOT_P2_ALL NOT MARKS
 DENSITY check_pattern CHIP_NOT_MARKS > 0.4 [AREA(check_pattern)/AREA(CHIP_NOT_MARKS)] PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_GT_D_2.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_GT_D_2.rdb"
}

#IFDEF MINIMUM_DENSITY_CHECK YES
VARIABLE GT_D_3_val 10
VARIABLE GT_D_3_window 10

GT_D_3 {
@ (ALL_GT NOT ALL_P2) density, except (NODMF su 1um), OCOVL, DIR, DIRDMP regions (window 10um*10um, stepping 5um) >= 10%
 waive_area = OR NODMF_SIZE_1 MARKS DIR DIRDMP OCOVL
 check_region = DRC:1 NOT waive_area
 check_pattern = ALL_GT_NOT_P2_ALL AND check_region

 check_window1 = check_region WITH WIDTH >= GT_D_3_window/4
 err1_TMP1 = DENSITY check_pattern check_window1 check_region [!AREA(check_window1) + !!AREA(check_window1)*AREA(check_pattern)/AREA(check_region)] < GT_D_3_val/100 WINDOW GT_D_3_window STEP GT_D_3_window/2 BACKUP INSIDE OF LAYER DRC:1 BY POLYGON

 check_window2 = WITH WIDTH (check_region AND err1_TMP1) >= GT_D_3_window/4
 err1_TMP2 = DENSITY check_pattern check_window2 check_region [!AREA(check_window2) + !!AREA(check_window2)*AREA(check_pattern)/AREA(check_region)] < GT_D_3_val/100 WINDOW GT_D_3_window STEP GT_D_3_window/2 BACKUP INSIDE OF LAYER err1_TMP1 BY POLYGON

 check_window3 = WITH WIDTH (check_region AND err1_TMP2) >= GT_D_3_window/4
 DENSITY check_pattern check_window3 check_region [!AREA(check_window3) + !!AREA(check_window3)*AREA(check_pattern)/AREA(check_region)] < GT_D_3_val/100 WINDOW GT_D_3_window STEP GT_D_3_window/2 BACKUP INSIDE OF LAYER err1_TMP2 BY POLYGON PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_GT_D_3.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_GT_D_3.rdb"
}

VARIABLE GT_D_4_val 6
VARIABLE GT_D_4_window 10

GT_D_4 {
@ (ALL_GT NOT ALL_P2) density for RESP1 region (window 10um*10um, stepping 5um) >= 6%
 check_region = (CHIP_NOT_MARKS WITH WIDTH >= 2.5) AND RESP1
 check_pattern = ALL_GT_NOT_P2_ALL AND check_region

 check_window1 = COPY RESP1
 err1_TMP1 = DENSITY check_pattern check_window1 check_region [!AREA(check_window1) + !!AREA(check_window1)*AREA(check_pattern)/AREA(check_region)] < GT_D_4_val/100 WINDOW GT_D_4_window STEP GT_D_4_window/2 BACKUP INSIDE OF LAYER DRC:1 BY POLYGON

 check_window2 = WITH WIDTH (check_region AND err1_TMP1) >= GT_D_4_window/4
 err1_TMP2 = DENSITY check_pattern check_window2 check_region [!AREA(check_window2) + !!AREA(check_window2)*AREA(check_pattern)/AREA(check_region)] < GT_D_4_val/100 WINDOW GT_D_4_window STEP GT_D_4_window/2 BACKUP INSIDE OF LAYER err1_TMP1 BY POLYGON

 check_window3 = WITH WIDTH (check_region AND err1_TMP2) >= GT_D_4_window/4
 DENSITY check_pattern check_window3 check_region [!AREA(check_window3) + !!AREA(check_window3)*AREA(check_pattern)/AREA(check_region)] < GT_D_4_val/100 WINDOW GT_D_4_window STEP GT_D_4_window/2 BACKUP INSIDE OF LAYER err1_TMP2 BY POLYGON PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_GT_D_4.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_GT_D_4.rdb"
}
#ENDIF

VARIABLE GT_D_5_val 50
VARIABLE GT_D_5_window 10

GT_D_5 {
@ (ALL_GT NOT ALL_P2) density for core device region (window 10um*10um, stepping 5um) <= 50%
 check_region = CHIP_NOT_MARKS NOT DG
 check_pattern = ALL_GT_NOT_P2_ALL AND check_region

 check_window1 = check_region WITH WIDTH >= GT_D_5_window/4
 err1_TMP1 = DENSITY check_pattern check_window1 check_region [!!AREA(check_window1)*AREA(check_pattern)/AREA(check_region)] > GT_D_5_val/100 WINDOW GT_D_5_window STEP GT_D_5_window/2 BACKUP INSIDE OF LAYER DRC:1 BY POLYGON

 check_window2 = WITH WIDTH (check_region AND err1_TMP1) >= GT_D_5_window/4
 err1_TMP2 = DENSITY check_pattern check_window2 check_region [!!AREA(check_window2)*AREA(check_pattern)/AREA(check_region)] > GT_D_5_val/100 WINDOW GT_D_5_window STEP GT_D_5_window/2 BACKUP INSIDE OF LAYER err1_TMP1 BY POLYGON

 check_window3 = WITH WIDTH (check_region AND err1_TMP2) >= GT_D_5_window/4
 DENSITY check_pattern check_window3 check_region [!!AREA(check_window3)*AREA(check_pattern)/AREA(check_region)] > GT_D_5_val/100 WINDOW GT_D_5_window STEP GT_D_5_window/2 BACKUP INSIDE OF LAYER err1_TMP2 BY POLYGON PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_GT_D_5.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_GT_D_5.rdb"
}

VARIABLE GT_D_5a_val 60
VARIABLE GT_D_5a_window 10

GT_D_5a {
@ (ALL_GT NOT ALL_P2) density for I/O device region (window 10um*10um, stepping 5um) <= 60%
 check_region = DG NOT MARKS
 check_pattern = ALL_GT_NOT_P2_ALL AND check_region

 check_window1 = check_region WITH WIDTH >= GT_D_5a_window/4
 err1_TMP1 = DENSITY check_pattern check_window1 check_region [!!AREA(check_window1)*AREA(check_pattern)/AREA(check_region)] > GT_D_5a_val/100 WINDOW GT_D_5a_window STEP GT_D_5a_window/2 BACKUP INSIDE OF LAYER DRC:1 BY POLYGON

 check_window2 = WITH WIDTH (check_region AND err1_TMP1) >= GT_D_5a_window/4
 err1_TMP2 = DENSITY check_pattern check_window2 check_region [!!AREA(check_window2)*AREA(check_pattern)/AREA(check_region)] > GT_D_5a_val/100 WINDOW GT_D_5a_window STEP GT_D_5a_window/2 BACKUP INSIDE OF LAYER err1_TMP1 BY POLYGON

 check_window3 = WITH WIDTH (check_region AND err1_TMP2) >= GT_D_5a_window/4
 DENSITY check_pattern check_window3 check_region [!!AREA(check_window3)*AREA(check_pattern)/AREA(check_region)] > GT_D_5a_val/100 WINDOW GT_D_5a_window STEP GT_D_5a_window/2 BACKUP INSIDE OF LAYER err1_TMP2 BY POLYGON PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_GT_D_5a.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_GT_D_5a.rdb"
}

VARIABLE GT_D_6_val 50
VARIABLE GT_D_6_window 140

GT_D_6 {
@ (ALL_GT NOT ALL_P2) density (window 140um*140um, stepping 70um) <= 50%
 check_region = COPY CHIP_NOT_MARKS
 check_pattern = ALL_GT_NOT_P2_ALL AND check_region

 check_window1 = check_region WITH WIDTH >= GT_D_6_window/4
 err1_TMP1 = DENSITY check_pattern check_window1 check_region [!!AREA(check_window1)*AREA(check_pattern)/AREA(check_region)] > GT_D_6_val/100 WINDOW GT_D_6_window STEP GT_D_6_window/2 BACKUP INSIDE OF LAYER DRC:1 BY POLYGON

 check_window2 = WITH WIDTH (check_region AND err1_TMP1) >= GT_D_6_window/4
 err1_TMP2 = DENSITY check_pattern check_window2 check_region [!!AREA(check_window2)*AREA(check_pattern)/AREA(check_region)] > GT_D_6_val/100 WINDOW GT_D_6_window STEP GT_D_6_window/2 BACKUP INSIDE OF LAYER err1_TMP1 BY POLYGON

 check_window3 = WITH WIDTH (check_region AND err1_TMP2) >= GT_D_6_window/4
 DENSITY check_pattern check_window3 check_region [!!AREA(check_window3)*AREA(check_pattern)/AREA(check_region)] > GT_D_6_val/100 WINDOW GT_D_6_window STEP GT_D_6_window/2 BACKUP INSIDE OF LAYER err1_TMP2 BY POLYGON PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_GT_D_6.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_GT_D_6.rdb"
}

GT_D_7 {
@ (ALL_GT NOT ALL_P2) density difference between any two neighboring checking window (window 20um*20um, stepping 10um) <= 35%
 check_pattern = ALL_GT_NOT_P2_ALL NOT MARKS
 DENSITY check_pattern CHIP_NOT_MARKS [AREA(check_pattern)/AREA(CHIP_NOT_MARKS)] >= 0 WINDOW 20 STEP 10 GRADIENT > 0.35 ABSOLUTE BACKUP PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_GT_D_7.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_GT_D_7.rdb"
}
#ENDIF

GT_R_1 {
@ ALL_GT (width >= 0.032um) must be a rectangle orthogonal to grid, except MARKS and LOGO regions
 chk_ALL_GT = ALL_GT INTERACT ALL_GT_eqgt_032
 err1 = (chk_ALL_GT NOT INSIDE MARKS_LOGO) NOT RECTANGLE ORTHOGONAL ONLY
 err1 NOT INSIDE MARKS_LOGO
}

GT_R_2 {
@ ALL_GT (width < 0.032um) must be a rectangle orthogonal to grid, except small jogs <= 0.004um
 chk_ALL_GT = ALL_GT_lt_032 NOT COIN EDGE (LENGTH ALL_GT_convex_equal_one_edge <= 0.004)  //;redundant
 err1 = ANGLE chk_ALL_GT > 0 < 90
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

GT_R_3 {
@ O-shape GT is not allowed, except LOGO region
 err1 = (DONUT GT) NOT INSIDE LOGO
 err1 NOT INSIDE SealR_NOT_BULK
}

GT_R_4 {
@ AOP_GT (width < 0.032um) interact AOP_GT (width >= 0.032um) is not allowed
 err1 = AOP_GT_lt_032 INTERACT AOP_GT_eqgt_032
 err1 NOT INSIDE SealR_NOT_BULK
}

ALL_GT_jog = ALL_GT_convex_90_270_edge TOUCH EDGE ALL_GT_h_edges
ALL_GT_jog_in_P2 = ALL_GT_jog INSIDE EDGE P2
ALL_GT_v_jog_edge = ANGLE ALL_GT_convex_90_270_edge == 90

ALL_GT_center_iso = NOT RECTANGLE ((NOT RECTANGLE ALL_GT) NOT (OR edge_gate_AA_all GTMK1 GT_and_GTMK1))
ALL_GT_center_iso_region = DFM SPACE ALL_GT_center_iso <= 0.086 BY INT HORIZONTAL
ALL_GT_center = DFM COPY ALL_GT_center_iso_region CENTERLINE
ALL_GT_center_jog = EXPAND EDGE ALL_GT_center INSIDE BY 0.001 OUTSIDE BY 0.001

GT_R_5 {
@ Different jog width on the same ALL_GT is not allowed, except LOGO region
//;jog will be splitted by using expand edge with extending operation
 err1 = NOT RECTANGLE ALL_GT_center_jog ORTHOGONAL ONLY
 err2 = ALL_GT_center_jog INTERACT (ALL_GT_center_iso INTERACT ALL_GT_center_jog > 1)
 err3 = EXT ALL_GT_center_jog < 0.001 ABUT==90 INTERSECTING ONLY REGION
 err1 NOT INSIDE LOGO
 err2 NOT INSIDE LOGO
 err3 NOT INSIDE LOGO
}

GT_R_6 {
@ Different ALL_GT jog height inside the same P2 is not allowed
 GT_WITH_JOGS = (ALL_GT WITH EDGE ALL_GT_jog_in_P2) AND P2
 GT_JOGS_inP2 = ALL_GT_v_jog_edge INSIDE EDGE P2
 GT_JOGS_neq = DFM PROPERTY GT_WITH_JOGS GT_JOGS_inP2 OVERLAP ABUT ALSO MULTI [-= MAX(LENGTH(GT_JOGS_inP2)) - MIN(LENGTH(GT_JOGS_inP2))] != 0
 GT_JOGS_neq_EXP = EXPAND EDGE ALL_GT_jog OUTSIDE BY 0.001
 GT_JOGS_neq_FOUND = GT_JOGS_neq COIN EDGE GT_JOGS_inP2   //; jog height in the same ALL_GT
 err1 = GT_JOGS_neq_EXP WITH EDGE GT_JOGS_neq_FOUND
 err1 NOT INSIDE SealR_NOT_BULK

 RVS_GT_inP2 = (P2 INTERACT ALL_GT) NOT ALL_GT
 RVS_GT_inP2_H = RVS_GT_inP2 COIN EDGE P2_h_edges
 RVS_GT_in_LEGS = CONVEX EDGE RVS_GT_inP2 ANGLE1 == 90 ANGLE2 == 270
 RVS_GT_in_LEGS_V = RVS_GT_in_LEGS COIN EDGE ALL_GT_v_edges
 RVS_GT_in_LEGS_V_inP2_CORNER = INT [RVS_GT_in_LEGS_V] RVS_GT_inP2_H < 0.005 ABUT==90 INTERSECTING ONLY
 RVS_GT_in_LEGS_V_inP2 = RVS_GT_in_LEGS_V TOUCH EDGE RVS_GT_in_LEGS_V_inP2_CORNER
 RVS_GT_JOGS_neq = DFM PROPERTY RVS_GT_inP2 RVS_GT_in_LEGS_V_inP2 OVERLAP ABUT ALSO MULTI [-= MAX(LENGTH(RVS_GT_in_LEGS_V_inP2)) - MIN(LENGTH(RVS_GT_in_LEGS_V_inP2))] != 0
 RVS_GT_JOGS_neq_EXP = EXPAND EDGE ALL_GT_jog INSIDE BY 0.001
 RVS_GT_JOGS_neq_FOUND = RVS_GT_JOGS_neq COIN EDGE RVS_GT_in_LEGS_V_inP2   //; jog height between two ALL_GTs
 err2 = RVS_GT_JOGS_neq_EXP WITH EDGE RVS_GT_JOGS_neq_FOUND
 err2 NOT INSIDE SealR_NOT_BULK
}

GT_R_7 {
@ Different jog height on the same ALL_GT and Z-shape GT jog are not allowed, except LOGO region
 ALL_GT_lend_END = ANGLE ALL_GT_convex_90_90_edge == 0
 ALL_GT_lend_EXP = EXPAND EDGE ALL_GT_lend_END INSIDE BY 0.005
 ALL_GT_legs = EXPAND EDGE ALL_GT_v_jog_edge INSIDE BY 0.005
 ALL_GT_lend_WITH_twoLegs = ALL_GT_lend_EXP INTERACT ALL_GT_legs == 2
 ALL_GT_legs_NEAR_lend = ALL_GT_v_jog_edge TOUCH EDGE ALL_GT_lend_WITH_twoLegs
 ALL_GT_lend_EXP_ERROR = DFM PROPERTY ALL_GT_lend_WITH_twoLegs ALL_GT_legs_NEAR_lend OVERLAP ABUT ALSO MULTI [-= MAX(LENGTH(ALL_GT_legs_NEAR_lend)) - MIN(LENGTH(ALL_GT_legs_NEAR_lend))] != 0
 err1 = ALL_GT_v_jog_edge TOUCH EDGE ALL_GT_lend_EXP_ERROR   //; jog height in the same ALL_GT
 err1 NOT INSIDE EDGE LOGO

 ALL_GT_lend_WITH_oneLegs = ALL_GT_lend_EXP INTERACT ALL_GT_legs == 1
 ALL_GT_WITH_oneLegs_ERROR = ALL_GT INTERACT ALL_GT_lend_WITH_oneLegs > 1
 err2 = ALL_GT_v_jog_edge TOUCH EDGE (ALL_GT_lend_WITH_oneLegs INTERACT ALL_GT_WITH_oneLegs_ERROR)
 err2 NOT INSIDE EDGE LOGO   //; Z-shape ALL_GT
}

GT_R_8 {
@ ALL_GT jog height must be the same when interact the same AA. DRC check the region of the AA horizontal edge sizing 0.1um
 SETP_1 = (edge_gate_AA_all INTERACT (GATE INTERACT (AA INTERACT GATE))) NOT ALL_GT
 SETP_2 = SETP_1 OR (EXPAND EDGE (SETP_1 INSIDE EDGE edge_gate_AA_all) OUTSIDE BY 0.003)
 SETP_3 = ANGLE SETP_2 == 0
 err1_a = ENC SETP_3 ALL_GT_jog <= 0.100 OPPOSITE EXTENDED 0.005 EXCLUDE SHIELDED
 err1_b = EXT SETP_3 ALL_GT_jog <= 0.100 OPPOSITE EXTENDED 0.005 EXCLUDE SHIELDED
 err1_c = DFM COPY err1_a err1_b

 err1_TMP = DFM PROPERTY SETP_3 err1_a err1_b err1_c ABUT ALSO OVERLAP MULTI
 [jog_e = (COUNT(err1_c) > 1) ? 1 : 0] > 0
 [jog_h = (MIN(EWYP(err1_c)) == MAX(EWYP(err1_c))) ? 1 : 0 ] == 0
 err1 = EXPAND EDGE err1_TMP OUTSIDE BY 0.005
 err1 NOT INSIDE SealR_NOT_BULK
}

GT_R_9 {
@ ALL_GT must be vertical direction, except DMCMK1, LOGO and MARKS regions
 chk_GT = ALL_GT NOT INSIDE (OR DMCMK1 LOGO MARKS)
 v_sides_gt = ANGLE chk_GT == 90
 h_sides_gt = ANGLE chk_GT == 0
 err1 = DFM PROPERTY chk_GT v_sides_gt h_sides_gt OVERLAP [diff_len_h = MAX(LENGTH(h_sides_gt)) - MAX(LENGTH(v_sides_gt))] > 0
 err1 NOT INSIDE (OR DMCMK1 LOGO MARKS)
}

GT_R_10 {
@ (((ALL_GT NOT P2) NOT (DUM_GT INSIDE DMCB1)) CUT (DG OR ((DMPNP OR DSTR) OR VARMOS))) is not alllowed
 Check_Layers = OR DG DMPNP DSTR VARMOS
 Layer_Cutted = ALL_GT_NOT_P2 NOT (DUM_GT INSIDE DMCB1)
 err1 = Check_Layers INSIDE EDGE Layer_Cutted
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

TRGATE_CORE_wlt_020 = TRGATE_LE_LT_20 NOT INSIDE DG
TRGATE_CORE_wlt_020_EXP = (SIZE TRGATE_CORE_wlt_020 BY 0.035) AND GT
TRGATE_CORE_wlt_024 = TRGATE_LE_LT_24 NOT INSIDE DG
TRGATE_CORE_wlt_024_EXP = (SIZE TRGATE_CORE_wlt_024 BY 0.035) AND GT

TRGATE_2gt_024 = TRGATE_CORE_wlt_024_EXP ENCLOSE (TRGATE_CORE_wlt_024 INTERACT (AA INTERACT TRGATE_CORE_wlt_024 == 2))
TRGATE_2gt_020 = TRGATE_CORE_wlt_020_EXP ENCLOSE (TRGATE_CORE_wlt_020 INTERACT (AA INTERACT TRGATE_CORE_wlt_020 == 2))
TRGATE_1gt_024 = TRGATE_CORE_wlt_024_EXP ENCLOSE (TRGATE_CORE_wlt_024 INTERACT (AA INTERACT TRGATE_CORE_wlt_024 == 1))
TRGATE_1gt_020 = TRGATE_CORE_wlt_020_EXP ENCLOSE (TRGATE_CORE_wlt_020 INTERACT (AA INTERACT TRGATE_CORE_wlt_020 == 1))

TRGATE_2gt_gap_080 = EXT (TRGATE_2gt_024 TOUCH EDGE GATE_raw) <= 0.080 OPPOSITE REGION
TRGATE_2gt_gap_076 = EXT (TRGATE_2gt_020 TOUCH EDGE GATE_raw) <= 0.076 OPPOSITE REGION
TRGATE_2gt_gap_074 = EXT (TRGATE_2gt_020 TOUCH EDGE GATE_raw) <= 0.074 OPPOSITE REGION

VARIABLE Trgate_three_pitch 0.096*3
VARIABLE Trgate_four_pitch 0.096*4
VARIABLE AOP_GT_MinSpace 0.080

GT_P96_EMPTY = GT_P96 NOT DRC:1

GT_R_11_1 {
@ The number of AOP_GT in one group >= 7
@ 1) AA with only one or two GATE (width <= 0.024um)
@ 2) AOP_GT space <= 0.08um
@ 3) AOP_GT has same PRL as ((GATE su 0.035um) AND GT)
//;DRC flag the AA with only one or two GATE
 Tr_1gt_com_Trgate = TRGATE_1gt_024 NOT INSIDE GT_P96_EMPTY
 Tr_1gt_com_Three_Body = Tr_1gt_com_Trgate TOUCH EDGE GTEIAA
 Tr_1gt_com_Three_Body_ERRS_near = EXT (Tr_1gt_com_Three_Body) AOP_GT <= AOP_GT_MinSpace ABUT<90 OPPOSITE
 Tr_1gt_com_Three_Body_ERRS = EXT (Tr_1gt_com_Three_Body) AOP_GT <= AOP_GT_MinSpace ABUT<90 OPPOSITE
 err1 = EXPAND EDGE Tr_1gt_com_Three_Body_ERRS OUTSIDE BY 0.0005
 err1 NOT INSIDE GT_P96_EMPTY

 Tr_1gt_com = Tr_1gt_com_Trgate NOT INSIDE (EXT Tr_1gt_com_Three_Body <= Trgate_four_pitch ABUT<90 OPPOSITE REGION)
 Tr_1gt_com_edge = Tr_1gt_com TOUCH EDGE GTEIAA
 Tr_1gt_com_iso_side = EXT (Tr_1gt_com_edge) <= Trgate_four_pitch ABUT<90 OPPOSITE
 Tr_1gt_com_den_area = EXT (TRGATE_CORE_wlt_024_EXP TOUCH EDGE Tr_1gt_com_edge) <= Trgate_four_pitch ABUT<90 OPPOSITE REGION

 Tr_1gt_com_L_side = (EXPAND EDGE Tr_1gt_com_edge OUTSIDE BY 0.005) AND (GROW Tr_1gt_com LEFT BY 0.005)
 Tr_1gt_com_R_side = (EXPAND EDGE Tr_1gt_com_edge OUTSIDE BY 0.005) AND (GROW Tr_1gt_com RIGHT BY 0.005)
 Tr_1gt_com_L_edge = Tr_1gt_com_edge COIN EDGE Tr_1gt_com_L_side  //;TRGATE left side
 Tr_1gt_com_R_edge = Tr_1gt_com_edge COIN EDGE Tr_1gt_com_R_side
 Tr_1gt_com_L_edge_est = Tr_1gt_com_L_edge COIN EDGE Tr_1gt_com_iso_side
 Tr_1gt_com_R_edge_est = Tr_1gt_com_R_edge COIN EDGE Tr_1gt_com_iso_side
 Tr_1gt_com_L_area_est = GROW Tr_1gt_com_L_edge_est LEFT BY Trgate_four_pitch
 Tr_1gt_com_R_area_est = GROW Tr_1gt_com_R_edge_est RIGHT BY Trgate_four_pitch

 Tr_1gt_gap_L_est = Tr_1gt_com_L_area_est NOT AOP_GT_eqlt_024
 Tr_1gt_gap_R_est = Tr_1gt_com_R_area_est NOT AOP_GT_eqlt_024
 Tr_1gt_gap_L_est_raw = DFM SPACE Tr_1gt_gap_L_est <= AOP_GT_MinSpace BY INT HORIZONTAL
 Tr_1gt_gap_R_est_raw = DFM SPACE Tr_1gt_gap_R_est <= AOP_GT_MinSpace BY INT HORIZONTAL
 Tr_1gt_gap_L_est_chk = DFM COPY (DFM PROPERTY Tr_1gt_gap_L_est_raw AOP_GT_eqlt_024 ABUT ALSO OVERLAP MULTI [-= count(AOP_GT_eqlt_024)] == 2) REGION
 Tr_1gt_gap_R_est_chk = DFM COPY (DFM PROPERTY Tr_1gt_gap_R_est_raw AOP_GT_eqlt_024 ABUT ALSO OVERLAP MULTI [-= count(AOP_GT_eqlt_024)] == 2) REGION
 Tr_1gt_gap_L_est_err = Tr_1gt_gap_L_est NOT Tr_1gt_gap_L_est_chk
 Tr_1gt_gap_R_est_err = Tr_1gt_gap_R_est NOT Tr_1gt_gap_R_est_chk

 Tr_1gt_gap_L_est_real = Tr_1gt_gap_L_est_chk NOT INTERACT Tr_1gt_gap_L_est_err
 Tr_1gt_gap_R_est_real = Tr_1gt_gap_R_est_chk NOT INTERACT Tr_1gt_gap_R_est_err
 Tr_1gt_com_L_est_pass = Tr_1gt_com_L_area_est ENCLOSE Tr_1gt_gap_L_est_real > 3
 Tr_1gt_com_R_est_pass = Tr_1gt_com_R_area_est ENCLOSE Tr_1gt_gap_R_est_real > 3
 Tr_1gt_com_pass = (Tr_1gt_com NOT INTERACT Tr_1gt_com_L_est_pass) NOT INTERACT Tr_1gt_com_R_est_pass

 Tr_1gt_com_edge_est = OR EDGE Tr_1gt_com_L_edge_est Tr_1gt_com_R_edge_est
 Tr_1gt_com_edge_est_all = OR Tr_1gt_com (EXPAND EDGE Tr_1gt_com_edge_est OUTSIDE BY Trgate_three_pitch)
 Tr_1gt_com_gaps_est = Tr_1gt_com_edge_est_all NOT AOP_GT_eqlt_024
 Tr_1gt_com_gaps_est_sps_raw = DFM SPACE Tr_1gt_com_gaps_est <= AOP_GT_MinSpace BY INT HORIZONTAL
 Tr_1gt_com_gaps_est_sps_chk = DFM COPY (DFM PROPERTY Tr_1gt_com_gaps_est_sps_raw AOP_GT_eqlt_024 ABUT ALSO OVERLAP MULTI [-= count(AOP_GT_eqlt_024)] == 2) REGION
 Tr_1gt_com_gaps_est_sps_err = Tr_1gt_com_gaps_est NOT Tr_1gt_com_gaps_est_sps_chk
 Tr_1gt_com_gaps_est_sps_real = Tr_1gt_com_gaps_est_sps_chk NOT INTERACT Tr_1gt_com_gaps_est_sps_err
 Tr_1gt_com_gaps_est_sps_pass = Tr_1gt_com_edge_est_all ENCLOSE Tr_1gt_com_gaps_est_sps_real >= 6

 err2_TMP = (Tr_1gt_com_pass NOT INTERACT Tr_1gt_com_gaps_est_sps_pass) NOT WITH EDGE Tr_1gt_com_Three_Body_ERRS
 err2_waive = (EXPAND EDGE Tr_1gt_com_edge OUTSIDE BY 0.005) INSIDE Tr_1gt_com_den_area
 err2 = err2_TMP NOT INTERACT err2_waive
 err2 NOT INSIDE GT_P96_EMPTY
}

GT_R_11_2 {
@ The number of AOP_GT in one group >= 7
@ 1) AA with only one or two GATE (width <= 0.024um)
@ 2) AOP_GT space <= 0.08um
@ 3) AOP_GT has same PRL as ((GATE su 0.035um) AND GT)
//;DRC flag the AA with only one or two GATE
 Tr_2gt_com_Trgate = TRGATE_2gt_024 NOT INSIDE GT_P96_EMPTY
 Tr_2gt_com_Four_Body = Tr_2gt_com_Trgate TOUCH EDGE GTEIAA
 Tr_2gt_com_Four_Body_ERRS = EXT (Tr_2gt_com_Four_Body) AOP_GT <= AOP_GT_MinSpace ABUT<90 OPPOSITE
 err1 = EXPAND EDGE Tr_2gt_com_Four_Body_ERRS OUTSIDE BY 0.0005
 err1 NOT INSIDE GT_P96_EMPTY

 Tr_2gt_gap_all = OR TRGATE_2gt_024 TRGATE_2gt_gap_080
 Tr_2gt_gap_all_v_edge = Tr_2gt_gap_all COIN EDGE AOP_GT_v_edges
 Tr_2gt_gap_all_v_edge_L = Tr_2gt_gap_all_v_edge COIN EDGE ((GROW Tr_2gt_gap_all LEFT BY 0.005) NOT Tr_2gt_gap_all)
 Tr_2gt_gap_all_v_edge_R = Tr_2gt_gap_all_v_edge COIN EDGE ((GROW Tr_2gt_gap_all RIGHT BY 0.005) NOT Tr_2gt_gap_all)
 Tr_2gt_gap_sti = EXT Tr_2gt_gap_all_v_edge <= Trgate_three_pitch OPPOSITE REGION

 Tr_2gt_est_L_EDG = Tr_2gt_gap_all_v_edge_L OUTSIDE EDGE Tr_2gt_gap_sti
 Tr_2gt_est_R_EDG = Tr_2gt_gap_all_v_edge_R OUTSIDE EDGE Tr_2gt_gap_sti
 Tr_2gt_est_L_EDG_3p = EXPAND EDGE Tr_2gt_est_L_EDG OUTSIDE BY Trgate_three_pitch
 Tr_2gt_est_R_EDG_3p = EXPAND EDGE Tr_2gt_est_R_EDG OUTSIDE BY Trgate_three_pitch
 Tr_2gt_gap_L_3p = Tr_2gt_est_L_EDG_3p NOT AOP_GT_eqlt_024
 Tr_2gt_gap_R_3p = Tr_2gt_est_R_EDG_3p NOT AOP_GT_eqlt_024

 Tr_2gt_gap_L_sps_raw = DFM SPACE Tr_2gt_gap_L_3p <= AOP_GT_MinSpace BY INT HORIZONTAL
 Tr_2gt_gap_R_sps_raw = DFM SPACE Tr_2gt_gap_R_3p <= AOP_GT_MinSpace BY INT HORIZONTAL
 Tr_2gt_gap_L_sps_chk = DFM COPY (DFM PROPERTY Tr_2gt_gap_L_sps_raw AOP_GT_eqlt_024 ABUT ALSO OVERLAP MULTI [-= count(AOP_GT_eqlt_024)] == 2) REGION
 Tr_2gt_gap_R_sps_chk = DFM COPY (DFM PROPERTY Tr_2gt_gap_R_sps_raw AOP_GT_eqlt_024 ABUT ALSO OVERLAP MULTI [-= count(AOP_GT_eqlt_024)] == 2) REGION
 Tr_2gt_gap_L_sps_err = Tr_2gt_gap_L_3p NOT Tr_2gt_gap_L_sps_chk
 Tr_2gt_gap_R_sps_err = Tr_2gt_gap_R_3p NOT Tr_2gt_gap_R_sps_chk

 Tr_2gt_gap_L_sps_real = Tr_2gt_gap_L_sps_chk NOT INTERACT Tr_2gt_gap_L_sps_ERR
 Tr_2gt_gap_R_sps_real = Tr_2gt_gap_R_sps_chk NOT INTERACT Tr_2gt_gap_R_sps_ERR
 Tr_2gt_gap_L_sps_pass = Tr_2gt_est_L_EDG_3p ENCLOSE Tr_2gt_gap_L_sps_REAL > 2
 Tr_2gt_gap_R_sps_pass = Tr_2gt_est_R_EDG_3p ENCLOSE Tr_2gt_gap_R_sps_REAL > 2

 err2_TMP = ((Tr_2gt_gap_all NOT INTERACT Tr_2gt_gap_L_sps_pass) NOT INTERACT Tr_2gt_gap_R_sps_pass) NOT WITH EDGE Tr_2gt_com_Four_Body_ERRS
 err2_waive = (EXPAND EDGE Tr_2gt_gap_all_v_edge OUTSIDE BY 0.005) INSIDE Tr_2gt_gap_sti
 err2 = err2_TMP NOT INTERACT err2_waive
 err2 NOT INSIDE GT_P96_EMPTY
}

GT_R_12 {
@ The number of AOP_GT inside P96_Group >= 7
@ Definition of P96_Group:
@ (((AOP_GT INSIDE GT_P96) with width <= 0.024um) su 0.04um) sd 0.04
@ DRC flags width of P96_Group <= 0.504um in S/D direction
 AOP_GT_INSIDE_p96 = AOP_GT_eqlt_024 INSIDE GT_P96
 AOP_GT_GROUP_080 = SIZE AOP_GT_INSIDE_p96 BY 0.04 OVERUNDER   //; P96_Group
 AOP_GT_ERROR = AOP_GT_GROUP_080 INTERACT AOP_GT_INSIDE_p96 < 7
 err1 = DFM COPY (DFM SPACE AOP_GT_ERROR <= 0.504 BY INT HORIZONTAL) REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
LAYER MAP 9199 DATATYPE 1121 8129
LAYER EMPTY_fgi 8129
EMPTY_fg = EMPTY_fgi NOT BULK
 
 //; metal and via derivation for connection 
M1_em = EMPTY_fg OR M1
M2_em = EMPTY_fg OR M2
M3_em = EMPTY_fg OR M3
M4_em = EMPTY_fg OR M4
M5_em = EMPTY_fg OR M5
M6_em = EMPTY_fg OR M6
M7_em = EMPTY_fg OR M7
M8_em = EMPTY_fg OR M8
V1_em = EMPTY_fg OR V1
V2_em = EMPTY_fg OR V2
V3_em = EMPTY_fg OR V3
V4_em = EMPTY_fg OR V4
V5_em = EMPTY_fg OR V5
V6_em = EMPTY_fg OR V6
V7_em = EMPTY_fg OR V7
TV2_em = EMPTY_fg OR TV2
TM2_em = EMPTY_fg OR TM2

GATE_em = EMPTY_fg OR GATE
M0_0_em = EMPTY_fg OR M0_0
M0G_em = EMPTY_fg OR M0G
M0_em = EMPTY_fg OR M0_NOT_M0C
GT_em = EMPTY_fg OR GT_0
HR_em = EMPTY_fg OR HR_0
V0_em = EMPTY_fg OR V0

NWRT_em = EMPTY_fg OR NWRT
NTAP_em = EMPTY_fg OR NTAPi
PTAP_em = EMPTY_fg OR PTAP
NSD_em = EMPTY_fg OR NSD
PSD_em = EMPTY_fg OR PSD
real_NSD_em = EMPTY_fg OR real_NSD
real_PSD_em = EMPTY_fg OR real_PSD
N_inject_em = EMPTY_fg OR N_inject
P_inject_em = EMPTY_fg OR P_inject

//;DNW_em = EMPTY_fg OR DNW
AA_em = EMPTY_fg OR NTAP_em PTAP_em NSD_em PSD_em real_NSD_em real_PSD_em N_inject_em P_inject_em
NW_em = EMPTY_fg OR NW
PW_em = EMPTY_fg OR PW_0
RW_em = EMPTY_fg OR RW
PA_em = EMPTY_fg OR PA
MD_em = EMPTY_fg OR MD
ALPA_em = EMPTY_fg OR ALPA

TV_em = EMPTY_fg OR TV
TM_em = EMPTY_fg OR TM
TM_1_em = EMPTY_fg OR TM_1
UTV_em = EMPTY_fg OR UTV
UTM_em = EMPTY_fg OR UTM

TV_AND_MIM_mapping_em = EMPTY_fg OR TV_AND_MIM_mapping
TV_AND_CTOP_mapping_em = EMPTY_fg OR TV_AND_CTOP_mapping
TV_NOT_MIM_CTOP_mapping_em = EMPTY_fg OR TV_NOT_MIM_CTOP_mapping

CTOP_NOT_MIM_final_em = EMPTY_fg OR CTOP_NOT_MIM_final
CTOP_final_em = EMPTY_fg OR CTOP_final
MIM_final_em = EMPTY_fg OR MIM_final

//; connectivity for GT.R.13 check
CONNECT GATE_em GT_em
CONNECT M0_0_em M1_em BY V0_em
CONNECT M0_em M1_em BY V0_em
CONNECT M0G_em M1_em BY V0_em

CONNECT M0_0_em NTAP_em
CONNECT M0_0_em PTAP_em
CONNECT M0_0_em real_PSD_em
CONNECT M0_0_em real_NSD_em
CONNECT M0_0_em P_inject_em
CONNECT M0_0_em N_inject_em
CONNECT M0_0_em PSD_em
CONNECT M0_0_em NSD_em
CONNECT M0_0_em GT_em
CONNECT M0_0_em M0_em
CONNECT M0_0_em M0G_em

CONNECT M0_em M0G_em
CONNECT M0_em NTAP_em
CONNECT M0_em PTAP_em
CONNECT M0_em real_PSD_em
CONNECT M0_em real_NSD_em
CONNECT M0_em P_inject_em
CONNECT M0_em N_inject_em
CONNECT M0_em PSD_em
CONNECT M0_em NSD_em
CONNECT M0_em GT_em
CONNECT M0_em NWRT_em

CONNECT M0G_em NTAP_em
CONNECT M0G_em PTAP_em
CONNECT M0G_em real_PSD_em
CONNECT M0G_em real_NSD_em
CONNECT M0G_em P_inject_em
CONNECT M0G_em N_inject_em
CONNECT M0G_em PSD_em
CONNECT M0G_em NSD_em
CONNECT M0G_em GT_em
CONNECT M0G_em HR_em
CONNECT M0G_em NWRT_em

CONNECT AA_em NTAP_em
CONNECT AA_em PTAP_em
CONNECT AA_em PSD_em
CONNECT AA_em NSD_em
CONNECT AA_em NWRT_em
CONNECT real_PSD_em PSD_em
CONNECT real_NSD_em NSD_em
CONNECT P_inject_em PSD_em
CONNECT N_inject_em NSD_em

CONNECT NTAP_em NW_em
CONNECT PTAP_em RW_em
CONNECT PTAP_em PW_em

//; For BEOL mapping layers connection 
CONNECT M1_em M2_em BY V1_em
CONNECT M2_em M3_em BY V2_em
CONNECT M3_em M4_em BY V3_em
CONNECT M4_em M5_em BY V4_em
CONNECT M5_em M6_em BY V5_em
CONNECT M6_em M7_em BY V6_em
CONNECT M7_em M8_em BY TV_NOT_MIM_CTOP_mapping_em
CONNECT M8_em MIM_final_em BY TV_AND_MIM_mapping_em
CONNECT M8_em CTOP_final_em BY TV_AND_CTOP_mapping_em
CONNECT M8_em ALPA_em BY PA_em
CONNECT TM_1_em TM_em BY TV_NOT_MIM_CTOP_mapping_em
CONNECT TM_em MIM_final_em BY TV_AND_MIM_mapping_em
CONNECT TM_em CTOP_final_em BY TV_AND_CTOP_mapping_em
CONNECT TM_em ALPA_em BY PA_em
CONNECT TM_em PA_em
CONNECT ALPA_em MD_em

//; For top via/metal self-connection
CONNECT TV_em UTV_em
CONNECT TM_em UTM_em
CONNECT TV_em TV_AND_MIM_mapping_em
CONNECT TV_em TV_AND_CTOP_mapping_em
CONNECT TV_em TV_NOT_MIM_CTOP_mapping_em
CONNECT TV_em V7_em
CONNECT TM_1_em M7_em
CONNECT TM_em M8_em
CONNECT CTOP_NOT_MIM_final_em CTOP_final_em

//; For all via/metal self-connection
CONNECT TM2_em M8_em
CONNECT TV2_em V7_em

GATE_CONNECT = GATE_em INTERACT GT_em
GATE_not_connect_AA = NET AREA RATIO GATE_CONNECT PTAP_em NTAP_em PSD_em NSD_em MD_em > 0 [!AREA(PTAP_em)*!AREA(NTAP_em)*!AREA(PSD_em)*!AREA(NSD_em)*!AREA(MD_em)] //;not connect to TAP/SD
FGATE_raw = GATE_em INTERACT GATE_not_connect_AA

//#IFDEF GT_R_13_FLOATING_GATE_CHECK YES
GT_R_13 {
@ Floating GATE is not allowed if the effective S/D are not connected together, for chip level purpose
@ Floating GATE definition:
@ (1) GATE not connected to M0G
@ (2) GATE connected to M0G but not connected to MOS AA, pick-up or MD
@ (3) It is not a floating GATE if the GATE is connected to AA by M0G in SRAM bit cell
@ (4) HR resistor is treated as a conductor between the two HR terminal
@ DRC check methodology for effective S/D:
@ (1) S/D is connected to different (MOS AA NOT GT), pick-up, Gate, or MD
//;source/drain not connect other source/drain, gate, tap and md
 FNSD = NET AREA RATIO NSD_em PSD_em GATE_CONNECT PTAP_em NTAP_em MD_em > 0 [~(count(NSD_em) -1)*!AREA(PSD_em)*!AREA(GATE_CONNECT)*!AREA(PTAP_em)*!AREA(NTAP_em)*!AREA(MD_em)]
 FPSD = NET AREA RATIO PSD_em NSD_em GATE_CONNECT PTAP_em NTAP_em MD_em > 0 [~(count(PSD_em) -1)*!AREA(NSD_em)*!AREA(GATE_CONNECT)*!AREA(PTAP_em)*!AREA(NTAP_em)*!AREA(MD_em)]
 NSD_effective_TMP = NSD_em NOT INTERACT FNSD
 PSD_effective_TMP = PSD_em NOT INTERACT FPSD
 NSD_effective = (FNSD OR GATE_em) INTERACT NSD_effective_TMP > 1 BY NET
 PSD_effective = (FPSD OR GATE_em) INTERACT PSD_effective_TMP > 1 BY NET

 NSD_floating_real = FNSD NOT NSD_effective
 PSD_floating_real = FPSD NOT PSD_effective
 FGATE_real = FGATE_raw NOT INTERACT (NSD_floating_real OR PSD_floating_real)  //;floating gate with (SD connected to MOS AA/pick-up/GATE/MD)
 err1 = FGATE_real INTERACT real_NSD_em > 1 BY NET  //;floating gate with SD connected to different MOS AA/pick-up/GATE/MD
 err2 = FGATE_real INTERACT real_PSD_em > 1 BY NET  //;floating gate with SD connected to different MOS AA/pick-up/GATE/MD
 err1 NOT INSIDE INST
 err2 NOT INSIDE INST
}
//#ENDIF

GT_R_14 {
@ ALL_GT must be fully covered by (SN OR SP), except DMCMK1, RESNW, MARKS and OCOVL regions
 err1 = (ALL_GT NOT (OR DMCMK1 RESNW MARKS OCOVL)) NOT ALL_SN_SP
 err1 NOT INSIDE SealR_NOT_BULK
}

GT_R_15 {
@ AOP_GT extension outside of AOP_AA in S/D direction equal to the half width of the same AOP_GT, except AOP_GT both side space to neighboring AOP_GT on the same AOP_AA, INST, and LDBK region
@ DRC flags the vertical edge of AOP_AA (INTERACT AOP_GT) NOT fully abut the centerline of AOP_GT
 WAIVE_AREA = OR LDBK INST
 CHK_AOP_GT = AOP_GT INTERACT AOP_AA
 CHK_AOP_AA = AOP_AA INTERACT CHK_AOP_GT
 CHK_AOP_AA_EDGE = (ANGLE CHK_AOP_AA == 90) COIN EDGE (CHK_AOP_AA NOT OUTSIDE EDGE CHK_AOP_GT)
 err1 = CHK_AOP_AA_EDGE NOT COIN EDGE AOP_GT_center_even
 err1 NOT INSIDE EDGE WAIVE_AREA //;waive odd AOP_GT
}

GT_R_17 {
@ Space between P90_Group (AOP_GT number < 7, width < 0.556um in S/D direction) to AOP_GT (width >= 0.032um, PRL > -0.03um) <= 0.079um in S/D direction at both sides is not allowed, except GT_P96 region
@ Definition of P90_Group: ((AOP_GT (width <= 0.02um) su 0.037um) sd -0.037um)
 AOP_GT_CHECK_032_v_edges = AOP_GT_v_edges COIN EDGE AOP_GT_eqgt_032
 AOP_GT_GROUP_078 = SIZE AOP_GT_eqlt_020 BY 0.037 OVERUNDER
 AOP_GT_GROUP_p90 = (AOP_GT_GROUP_078 INTERACT AOP_GT_eqlt_020 <= 7) NOT INSIDE GT_P96  //;6pitch*0.09 = 0.540,7pitch*0.09 = 0.630, reduce runtime
 AOP_GT_GROUP_p90_SPACE_eqlt_079 = EXT [AOP_GT_GROUP_p90] AOP_GT_CHECK_032_v_edges <= 0.079 ABUT<90 OPPOSITE EXTENDED 0.03
 err1 = (INT AOP_GT_GROUP_p90_SPACE_eqlt_079 < 0.556 ABUT<90 OPPOSITE REGION) NOT INSIDE GT_P96
 err1 NOT INSIDE SealR_NOT_BULK
}

GT_R_18 {
@ GT fully cover AA is not allowed
 err1 = AA INSIDE GT
 err1 NOT INSIDE SealR_NOT_BULK
}

// =======================================================
// EGATE: Edge GATE design rule
// GTMK1 and GTMK2 are the marking layers to define edge GATE
// =======================================================

GROUP GEGATE EGATE_?

GTMK1_v_edges = ANGLE GTMK1 == 90
GTMK2_v_edges = ANGLE GTMK2 == 90
GTMK1_h_edges = ANGLE GTMK1 == 0
GTMK2_h_edges = ANGLE GTMK2 == 0
GT_and_GTMK1 = GT AND GTMK1
GT_and_GTMK2 = GT AND GTMK2

EGATE_R_1 {
@ GTMK1 must be fully covered by AOP_GT
 err1 = GTMK1 NOT AOP_GT
 err1 NOT INSIDE SealR_NOT_BULK
}

EGATE_R_2 {
@ GTMK2 both two vertical edges must fully abut GT vertical edge
 err1 = GTMK2_v_edges NOT COIN EDGE GT
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

EGATE_R_3 {
@ GTMK1 and GTMK2 must be rectangles and orthogoral to grid
 err1 = NOT RECTANGLE GTMK1 ORTHOGONAL ONLY
 err2 = NOT RECTANGLE GTMK2 ORTHOGONAL ONLY
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

EGATE_R_4 {
@ (GTMK2 AND AA) must be rectangles and orthogoral to grid
 err1 = NOT RECTANGLE (GTMK2 AND AA) ORTHOGONAL ONLY
 err1 NOT INSIDE SealR_NOT_BULK
}

EGATE_R_5 {
@ GTMK2 both two horizontal edges must abut AA horizontal edges
 err1 = GTMK2_h_edges NOT TOUCH EDGE AA
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

EGATE_R_6 {
@ GTMK2 at least one horizontal edge must abut GTMK1 horizontal edge
 err1 = GTMK2 NOT WITH EDGE (GTMK2 COIN EDGE GTMK1_h_edges)
 err1 NOT INSIDE SealR_NOT_BULK
}

EGATE_R_7 {
@ (GT AND GTMK1) width in S/D and outside AA direction must be the same as LAST GATE of 0.032um, when neighboring to LAST GATE (channel length = 0.032um, (GT AND GTMK1) to LAST GATE space = 0.074um)
@ LAST GATE definition: the closest GATE to AA edge in S/D direction (AA on LAST GATE extension <= 0.318um)
 CHK_Range = GATE_LE_32 WITH EDGE (ENC [GATE] AA_v_edges <= 0.318 ABUT<90 OPPOSITE EXCLUDE SHIELDED)
 GOOD_side_A = EXT [GT_and_GTMK1] CHK_Range == 0.074 ABUT<90 OPPOSITE
 GOOD_side_B = INT (GOOD_side_A) GT_and_GTMK1 == 0.032 ABUT<90 OPPOSITE
 err1 = GT_and_GTMK1 WITH EDGE GOOD_side_B
 err1 NOT INSIDE SealR_NOT_BULK
}

gtmk_all = OR (GT_and_GTMK1 INTERACT GT_and_GTMK2) (GT_and_GTMK2 INTERACT GT_and_GTMK1) (GT_and_GTMK1 NOT INTERACT GT_and_GTMK2)
last_trgate_edges = ENC [GATE] AA_v_edges <= 0.358 ABUT<90 OPPOSITE EXCLUDE SHIELDED

EGATE_R_8 {
@ (GT AND GTMK1) width in S/D and outside AA direction must be the same as LAST GATE, or 0.072um, when neighboring to LAST GATE (channel length >= 0.07um, (GT AND GTMK1) to LAST GATE space = 0.118 or 0.119um), in core region
@ LAST GATE definition: the closest GATE to AA edge in S/D direction (AA on LAST GATE extension <= 0.358um)
 CHK_Range = (GATE_LE_GT_70 WITH EDGE last_trgate_edges) NOT INSIDE DG
 GOOD_side_A = EXT [GT_and_GTMK1] CHK_Range >= 0.118 <= 0.119 ABUT<90 OPPOSITE
 GOOD_side_B = INT (GOOD_side_A) GT_and_GTMK1 == 0.072 ABUT<90 OPPOSITE

 CHK_SD = (((AA_SD_all INTERACT CHK_Range) WITH EDGE GOOD_side_A) WITH EDGE GOOD_side_B) NOT INSIDE DG
 ERR_SD = DFM PROPERTY CHK_SD CHK_Range gtmk_all ABUT ALSO OVERLAP MULTI [two_gt = (count(CHK_Range) > 0 && count(gtmk_all) > 0) ? 1 : 0] > 0 [diff_wl = abs(area(CHK_Range) - area(gtmk_all))] > 0
 err1 = (GT_and_GTMK1 WITH EDGE (ERR_SD COIN EDGE GT_and_GTMK1)) WITH EDGE GOOD_side_B
 err1 NOT INSIDE DG
}

EGATE_R_9 {
@ (GT AND GTMK1) width in S/D and outside AA direction must be the same as LAST GATE, or 0.086um, or 0.134um, when neighboring to LAST GATE ((GT AND GTMK1) to LAST GATE space = 0.118 or 0.119um) INSIDE DG, except DGV region
@ LAST GATE definition: the closest GATE to AA edge in S/D direction (AA on LAST GATE extension <= 0.358um)
 CHK_Range = ((GATE WITH EDGE last_trgate_edges) INTERACT DG) NOT INSIDE DGV
 GOOD_side_A = EXT [GT_and_GTMK1] CHK_Range >= 0.118 <= 0.119 ABUT<90 OPPOSITE
 GOOD_side_B = INT (GOOD_side_A) GT_and_GTMK1 == 0.134 ABUT<90 OPPOSITE
 GOOD_side_C = INT (GOOD_side_B) GT_and_GTMK1 == 0.086 ABUT<90 OPPOSITE

 CHK_SD = (((AA_SD_all INTERACT CHK_Range) WITH EDGE GOOD_side_A) INTERACT DG) NOT INSIDE DGV
 ERR_SD = DFM PROPERTY CHK_SD CHK_Range gtmk_all ABUT ALSO OVERLAP MULTI [two_gt = (count(CHK_Range) > 0 && count(gtmk_all) > 0) ? 1 : 0] > 0 [diff_wl = abs(area(CHK_Range) - area(gtmk_all))] > 0
 err1 = (GT_and_GTMK1 WITH EDGE (ERR_SD COIN EDGE GT_and_GTMK1)) WITH EDGE GOOD_side_C
 err1 NOT INSIDE DGV
}

EGATE_R_10 {
@ (GT AND GTMK1) width in S/D and outside AA direction must be the same as LAST GATE, or 0.08um, or 0.086um, or 0.134um, when neighboring to LAST GATE
@ (GT AND GTMK1) to LAST GATE space = 0.118 or 0.119um), inside DGV region
@ LAST GATE definition: the closest GATE to AA edge in S/D direction (AA on LAST GATE extension <= 0.358um)
 CHK_Range = (GATE WITH EDGE last_trgate_edges) INTERACT DGV
 GOOD_side_A = EXT [GT_and_GTMK1] CHK_Range >= 0.118 <= 0.119 ABUT<90 OPPOSITE
 GOOD_side_B = INT (GOOD_side_A) GT_and_GTMK1 == 0.080 ABUT<90 OPPOSITE
 GOOD_side_C = INT (GOOD_side_B) GT_and_GTMK1 == 0.086 ABUT<90 OPPOSITE
 GOOD_side_D = INT (GOOD_side_C) GT_and_GTMK1 == 0.134 ABUT<90 OPPOSITE

 CHK_SD = ((AA_SD_all INTERACT CHK_Range) WITH EDGE GOOD_side_A) INTERACT DGV
 ERR_SD = DFM PROPERTY CHK_SD CHK_Range gtmk_all ABUT ALSO OVERLAP MULTI [two_gt = (count(CHK_Range) > 0 && count(gtmk_all) > 0) ? 1 : 0] > 0 [diff_wl = abs(area(CHK_Range) - area(gtmk_all))] > 0
 err1_TMP = (GT_and_GTMK1 WITH EDGE (ERR_SD COIN EDGE GT_and_GTMK1)) WITH EDGE GOOD_side_D
 err1 = err1_TMP INTERACT DGV
 err1 NOT INSIDE SealR_NOT_BULK
}

EGATE_R_11 {
@ AA vertical edge must align both GT and (GTMK1 or AR) centerline, except INST and MARKS regions
@ The value of (GT AND GTMK1) width must be a even number
 chk_aa = AA_v_edges NOT INSIDE EDGE MARKS_INST
 err1 = chk_aa NOT COIN EDGE GT_center_even
 err2 = chk_aa NOT INSIDE EDGE gtmk1_or_ar

 err1 NOT INSIDE EDGE MARKS_INST
 err2 NOT INSIDE EDGE MARKS_INST
}

EGATE_R_12 {
@ GTMK2 overlap more than one GATE is not allowed
 err1 = GTMK2 INTERACT (GTMK2 AND GATE_raw) >= 2
 err1 NOT INSIDE SealR_NOT_BULK
}

EGATE_R_13 {
@ ((GT NOT P2) INTERACT (GTMK1 AND NW)) must connect to (N+ pick-up AA inside VARMOS)
 chk_GT = (GT_0 INTERACT (GTMK1 AND NW)) AND VARMOS
 good_GT = NET AREA RATIO chk_GT NTAP [!!AREA(chk_GT)*!!AREA(NTAP)] > 0
 err1 = chk_GT NOT good_GT
 err1 NOT INSIDE SealR_NOT_BULK
}

aa_with_gate_el_024 = (edge_gate_AA_all INTERACT (edge_gate_AA_all AND GT_eqlt_024)) INTERACT gtmk1_or_ar >= 2
aa_gate_gt_024 = edge_gate_AA_all AND GT_gt_024
aa_gate_el_024 = aa_with_gate_el_024 NOT INTERACT (aa_gate_gt_024 NOT gtmk1_or_ar) //;GT <= 0.024 only

EGATE_R_14 {
@ Width of GATE (channel length <= 0.024um) between two adjacent (GTMK1 OR AR) on the same AA must be the same
 chk_SD = (aa_gate_el_024 NOT GT) INTERACT GATE == 2
 err1 = OR ((chk_SD INTERACT GT_014) INTERACT GT_gt_014) ((chk_SD INTERACT GT_015) INTERACT GT_gt_015)
 err2 = OR ((chk_SD INTERACT GT_016) INTERACT GT_gt_016) ((chk_SD INTERACT GT_017) INTERACT GT_gt_017)
 err3 = OR ((chk_SD INTERACT GT_018) INTERACT GT_gt_018) ((chk_SD INTERACT GT_019) INTERACT GT_gt_019)
 err4 = OR ((chk_SD INTERACT GT_020) INTERACT GT_gt_020) ((chk_SD INTERACT GT_021) INTERACT GT_gt_021) ((chk_SD INTERACT GT_022) INTERACT GT_gt_022) ((chk_SD INTERACT GT_023) INTERACT GT_gt_023)
 err5 = (GT_gt_024 AND (aa_with_gate_el_024 INTERACT aa_gate_gt_024)) NOT gtmk1_or_ar

 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
 err4 NOT INSIDE SealR_NOT_BULK
 err5 NOT INSIDE SealR_NOT_BULK
}

EGATE_R_15 {
@ GTMK2 interact the vertical edge (between 90-90 degree corners) of AA is not allowed
 chk_aa = AA_v_edges COIN EDGE AA_convex_90_90_edge
 err1 = GTMK2 INTERACT (EXPAND EDGE chk_aa INSIDE BY 0.001)
 err1 NOT INSIDE SealR_NOT_BULK
}

AA_INTERACT_RESNW_OR_DOP_AA = AA_INTERACT_RESNW OR DOP_AA
AA_INTERACT_RESNW_OR_DOP_AA_v_edge = ANGLE AA_INTERACT_RESNW_OR_DOP_AA == 90

EGATE_R_16 {
@ The vertical edge of ((AA INTERACT RESNW) OR DOP_AA) must align with AOP_GT centerline
 err1 = AA_INTERACT_RESNW_OR_DOP_AA_v_edge NOT COIN EDGE AOP_GT_center_even
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

EGATE_R_17 {
@ (AA AND GT) (INSIDE (pick-up NOT VARMOS), (DIOMK1 OR DIOMK2), DIR, DMPNP, or DSTR) must interact GTMK1, except INST region
//;GT inside pick-up, diomk1/diomk2, nw diode, rw diode should not be GATE
 err1 = (GATE_raw INSIDE TAP_NOT_VARMOS) NOT INTERACT GTMK1
 err2 = (GATE_raw INSIDE (DIOMK1 OR DIOMK2)) NOT INTERACT GTMK1
 err3 = (((GATE_raw INSIDE DIR) OR (GATE_raw INSIDE DMPNP)) OR (GATE_raw INSIDE DSTR)) NOT INTERACT GTMK1

 err1 NOT INSIDE INST
 err2 NOT INSIDE INST
 err3 NOT INSIDE INST
}

EGATE_R_18 {
@ GTMK1 (width > 0.032um in S/D direction) centerline must align (AA NOT INTERACT RESNW) vertical edge, except (pick-up NOT VARMOS), (DIOMK1 OR DIOMK2), DIR, DMPNP and DSTR regions
//;based on GTMK1 shape
 waive_area = OR TAP_NOT_VARMOS DIOMK1 DIOMK2 DIR DMPNP DSTR
 check_gtmk1 = (GTMK1 NOT INSIDE (OR waive_area AA_INTERACT_RESNW)) INTERACT (GTMK1 WITH WIDTH > 0.032) //; exclude nw resistor terminal
 check_area = GROW (EXTENTS check_gtmk1 CENTERS 0.0001) TOP BY 0.01 BOTTOM BY 0.01  //;DFM COPY (DFM SPACE Y1 < 0.250 BY INT HORIZONTAL) CENTERLINE
 err1 = ANGLE (check_area NOT TOUCH EDGE (EXPAND EDGE AA_v_edges BY 0.0001)) == 90
 err1 NOT INSIDE EDGE waive_area
}

EGATE_R_19 {
@ GTMK1 must be drawn identically to (GT AND AA (vertical edge extend 1/2 GT width) NOT GTMK2)
 GTMK1_edge_gate = GATE_raw INTERACT AA_v_edges_exp001
 GTMK1_edge_side = GTMK1 INTERACT GTMK1_edge_gate

 err1 = (GTMK1_edge_side NOT GT) NOT GTMK2
 err2 = ((GTMK1_edge_side AND GT) TOUCH (GT NOT GTMK1_edge_side) == 1) NOT GTMK2
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK

 err3 = AA_v_edges COIN EDGE GTMK1
 err3 NOT INSIDE EDGE SealR_NOT_BULK

//; GTMK1 horizontal edge must be align with AA horizontal edge
//; Vertical edge must coin with GT when GTMK1 interact (GT AND AA)
 chk_GTMK1 = GTMK1 INTERACT GATE_raw
 err4 = (chk_GTMK1 COIN EDGE GTMK1_h_edges) NOT TOUCH EDGE AA
 err5 = (chk_GTMK1 COIN EDGE GTMK1_v_edges) NOT COIN EDGE GT
 err4 NOT INSIDE EDGE SealR_NOT_BULK
 err5 NOT INSIDE EDGE SealR_NOT_BULK
}

EGATE_R_20 {
@ GTMK1 overlap GTMK2 is not allowed
 err1 = GTMK1 AND GTMK2
 err1 NOT INSIDE SealR_NOT_BULK
}

EGATE_R_21 {
@ GTMK2 must be rectangle orthogonal to grid
 err1 = COPY (NOT RECTANGLE GTMK2 ORTHOGONAL ONLY)
 err1 NOT INSIDE SealR_NOT_BULK
}

//;EGATE.R.22[NC] 4-teminal MOS with GTMK1 must be turned off and connect to metal pin test, except DSTR, DMPNP, (DIOMK1 OR DIOMK2), DIR, and MARKS regions

GTMK1_interact_AA = GTMK1 INTERACT AA
GTMK2_interact_AA = GTMK2 INTERACT AA
GTMK1_v_interact_AA = GTMK1_v_edges COIN EDGE GTMK1_interact_AA
GTMK2_v_interact_AA = GTMK2_v_edges COIN EDGE GTMK2_interact_AA

VARIABLE EGATE_S_1_val 0.066
VARIABLE EGATE_EN_1_val 0.066

/*
EGATE_S_1_GTMK1_SN {
@ GTMK1/GTMK2 (INTERACT AA not abut RESNW) space to NW, SN, SP in S/D direction >= 0.066um
@ Exclude NW for NW resistor
 err1 = EXT GTMK1_v_interact_AA SN < EGATE_S_1_val ABUT<90 MEASURE ALL OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

EGATE_S_1_GTMK1_SP {
@ GTMK1/GTMK2 (INTERACT AA not abut RESNW) space to NW, SN, SP in S/D direction >= 0.066um
@ Exclude NW for NW resistor
 err1 = EXT GTMK1_v_interact_AA SP < EGATE_S_1_val ABUT<90 MEASURE ALL OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

EGATE_S_1_GTMK1_NW {
@ GTMK1/GTMK2 (INTERACT AA not abut RESNW) space to NW, SN, SP in S/D direction >= 0.066um
@ Exclude NW for NW resistor
 err1 = EXT GTMK1_v_interact_AA NWRN < EGATE_S_1_val ABUT<90 MEASURE ALL OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

EGATE_S_1_GTMK2_SN {
@ GTMK1/GTMK2 (INTERACT AA not abut RESNW) space to NW, SN, SP in S/D direction >= 0.066um
@ Exclude NW for NW resistor
 err1 = EXT GTMK2_v_interact_AA SN < EGATE_S_1_val ABUT<90 MEASURE ALL OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

EGATE_S_1_GTMK2_SP {
@ GTMK1/GTMK2 (INTERACT AA not abut RESNW) space to NW, SN, SP in S/D direction >= 0.066um
@ Exclude NW for NW resistor
 err1 = EXT GTMK2_v_interact_AA SP < EGATE_S_1_val ABUT<90 MEASURE ALL OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

EGATE_S_1_GTMK2_NW {
@ GTMK1/GTMK2 (INTERACT AA not abut RESNW) space to NW, SN, SP in S/D direction >= 0.066um
@ Exclude NW for NW resistor
 err1 = EXT GTMK2_v_interact_AA NW < EGATE_S_1_val ABUT<90 MEASURE ALL OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

EGATE_EN_1_GTMK1_SN {
@ GTMK1/GTMK2 (INTERACT AA not abut RESNW) enclosure by NW, SN, SP in S/D direction >= 0.066um
@ Exclude NW for NW resistor
 err1 = ENC (GTMK1_v_edges COIN EDGE (GTMK1_interact_AA AND SN)) SN < EGATE_EN_1_val ABUT<90 MEASURE ALL OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

EGATE_EN_1_GTMK1_SP {
@ GTMK1/GTMK2 (INTERACT AA not abut RESNW) enclosure by NW, SN, SP in S/D direction >= 0.066um
@ Exclude NW for NW resistor
 err1 = ENC (GTMK1_v_edges COIN EDGE (GTMK1_interact_AA AND SP)) SP < EGATE_EN_1_val ABUT<90 MEASURE ALL OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

EGATE_EN_1_GTMK1_NW {
@ GTMK1/GTMK2 (INTERACT AA not abut RESNW) enclosure by NW, SN, SP in S/D direction >= 0.066um
@ Exclude NW for NW resistor
 err1 = ENC (GTMK1_v_edges COIN EDGE (GTMK1_interact_AA AND NWRN)) NWRN < EGATE_EN_1_val ABUT<90 MEASURE ALL OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

EGATE_EN_1_GTMK2_SN {
@ GTMK1/GTMK2 (INTERACT AA not abut RESNW) enclosure by NW, SN, SP in S/D direction >= 0.066um
@ Exclude NW for NW resistor
 err1 = ENC (GTMK2_v_edges COIN EDGE (GTMK2_interact_AA AND SN)) SN < EGATE_EN_1_val ABUT<90 MEASURE ALL OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

EGATE_EN_1_GTMK2_SP {
@ GTMK1/GTMK2 (INTERACT AA not abut RESNW) enclosure by NW, SN, SP in S/D direction >= 0.066um
@ Exclude NW for NW resistor
 err1 = ENC (GTMK2_v_edges COIN EDGE (GTMK2_interact_AA AND SP)) SP < EGATE_EN_1_val ABUT<90 MEASURE ALL OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

EGATE_EN_1_GTMK2_NW {
@ GTMK1/GTMK2 (INTERACT AA not abut RESNW) enclosure by NW, SN, SP in S/D direction >= 0.066um
@ Exclude NW for NW resistor
 err1 = ENC (GTMK2_v_edges COIN EDGE (GTMK2_interact_AA AND NW)) NW < EGATE_EN_1_val ABUT<90 MEASURE ALL OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
*/


// =======================================================
// GT_P96: pitch 96 GT desing rule
// =======================================================

GROUP GGT_P96 GT_P96_?

GT_P96_v_edges = ANGLE GT_P96 == 90
GT_P96_h_edges = ANGLE GT_P96 == 0

GT_P96_W_1 {
@ GT_P96 width in S/D direction >= 1.44um
 err1 = INT GT_P96_v_edges < 1.44 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

GT_P96_S_1 {
@ Space between two GT_P96 >= 0.63um
 err1 = EXT GT_P96 < 0.63 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

GT_P96_S_2 {
@ Space between GT_P96 and GATE >= 0.24um
 err1 = EXT GT_P96 GATE < 0.24 ABUT<90 SINGULAR REGION  //;based on GT_P96_S_1
 err1 NOT INSIDE SealR_NOT_BULK
}

GT_P96_S_3 {
@ Space between GT_P96 and GATE in S/D direction >= 0.395um
 err1 = EXT GT_P96_v_edges GATE < 0.395 ABUT<90 OPPOSITE REGION EXCLUDE SHIELDED
 err1 NOT INSIDE SealR_NOT_BULK
}

GT_P96_S_4 {
@ Space between GT_P96 and AOP_GT in S/D direction, except DMCMK1 >= 0.035um
 err1 = EXT GT_P96_v_edges AOP_GT < 0.035 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE DMCMK1
}

GT_P96_EN_1 {
@ GT_P96 enclosure of GATE >= 0.048um
 err1 = ENC (GATE AND GT_P96) GT_P96 < 0.048 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

GT_P96_EN_2 {
@ GT_P96 enclosure of GATE in S/D direction >= 0.313um
 err1 = ENC (GATE AND GT_P96) GT_P96_v_edges < 0.313 ABUT<90 OPPOSITE REGION EXCLUDE SHIELDED
 err1 NOT INSIDE SealR_NOT_BULK
}

GT_P96_EN_3 {
@ GT_P96 enclosure of AOP_GT in S/D direction, except DMCMK1 >= 0.035um
 err1 = ENC AOP_GT GT_P96_v_edges < 0.035 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE DMCMK1
}

GT_P96_R_1 {
@ GT_P96 INTERACT DG is not allowed
 err1 = GT_P96 INTERACT DG
 err1 NOT INSIDE SealR_NOT_BULK
}

GT_P96_R_2 {
@ AOP_AA or AOP_GT CUT GT_P96 is not allowed
 err1 = GT_P96 INSIDE EDGE (AOP_AA OR AOP_GT)
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

// =======================================================
// GTDMP: GT dummy rules
// =======================================================

GROUP GGTDMP GTDMP_?

GTDMP_in_GT_P96 = GTDMP INTERACT GT_P96

GTDMP_W_1 {
@ GTDMP width = 0.016/0.018/0.02/0.022/0.024, 0.032, 0.07~0.242um
 good_range = OR (OR GTDMP_016 GTDMP_018 GTDMP_020 GTDMP_022 GTDMP_024 GTDMP_032) (WITH WIDTH GTDMP >= 0.07 <= 0.242)
 err1 = GTDMP NOT good_range
 err2 = INT GTDMP < 0.016 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

GTDMP_W_2 {
@ GTDMP width when INTERACT DG, except DGV region = 0.086~0.242um
 GTDMP_chk = (GTDMP INTERACT DG) NOT INSIDE DGV
 GTDMP_good = WITH WIDTH GTDMP_chk >= 0.086 <= 0.242
 err1 = GTDMP_chk NOT GTDMP_good
 err1 NOT INSIDE SealR_NOT_BULK
}

GTDMP_W_3 {
@ GTDMP width INSIDE GT_P96, except dummy cell = 0.016~0.024um
 good_1 = WITH WIDTH GTDMP_in_GT_P96 == 0.016
 good_2 = WITH WIDTH GTDMP_in_GT_P96 == 0.018
 good_3 = WITH WIDTH GTDMP_in_GT_P96 == 0.020
 good_4 = WITH WIDTH GTDMP_in_GT_P96 == 0.024
 good_5 = WITH WIDTH GTDMP_in_GT_P96 >= 0.016 <= 0.024
 err1 = (GTDMP_in_GT_P96 NOT (OR good_1 good_2 good_3 good_4 good_5)) AND GT_P96
 err1 NOT INSIDE DMCB1
}

GTDMP_S_1 {
@ Space between (GT OR GTDMP) (GTDMP overlap or abut GT is not allowed), except OCOVL region >= 0.07um
 err1 = EXT DMP_GT < 0.07 ABUT<90 SINGULAR REGION
 err2 = GTDMP NOT OUTSIDE EDGE GT
 err1 NOT INSIDE OCOVL
 err2 NOT INSIDE EDGE OCOVL
}

GTDMP_S_2 {
@ Space between GTDMP (width <= 0.032um) and AOP_GT (width >= 0.07um) >= 0.117um
 err1 = EXT GTDMP_eqlt_032 AOP_GT_eqgt_070 < 0.117 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

GTDMP_S_3 {
@ Space between GTDMP (width >= 0.07um) and AOP_GT >= 0.117um
 err1 = EXT GTDMP_eqgt_070 AOP_GT < 0.117 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

//;GTDMP_S_4 { //;duplicated rule GT.S.5
//;@ Space betwee AOP_GT (NOT OUTSIDE DG) and AOP_GT >= 0.117um
//; err1 = EXT AOP_GT (AOP_GT NOT OUTSIDE DG) < 0.117 ABUT<90 SINGULAR REGION
//; err1 NOT INSIDE SealR_NOT_BULK
//;}

GTDMP_S_5 {
@ Space between GTDMP (width <= 0.032um) and AOP_GT in GATE poly direction >= 0.108um
 chk_GTDMP = GTDMP WITH EDGE (CONVEX EDGE GTDMP == 2 WITH LENGTH <= 0.032)
 err1 = EXT chk_GTDMP AOP_GT_h_edges < 0.108 ABUT<90 REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

GTDMP_S_6 {
@ Space between GTDMP (width >= 0.07um) and AOP_GT in GATE poly direction >= 0.117um
 err1 = EXT GTDMP_eqgt_070 AOP_GT_h_edges < 0.117 ABUT<90 REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

GTDMP_S_7 {
@ Space between GTDMP and AOP_AA >= 0.046um
 err1 = EXT AOP_AA GTDMP < 0.046 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

GTDMP_EX_1 {
@ GTDMP extension outside of DOP_AA in GATE poly direction (Extension < 0um is not allowed) >= 0.041um
 chk_GTDMP = GTDMP COIN EDGE AOP_GT_h_edges
 err1 = ENC DOP_AA [chk_GTDMP] < 0.041 ABUT<90 OPPOSITE INSIDE ALSO
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

GTDMP_L_1 {
@ GTDMP length (width < 0.07um) >= 0.246um
 err1 = LENGTH (INT [GTDMP] < 0.07 OPPOSITE) < 0.246
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

GTDMP_L_2 {
@ GTDMP length (width >= 0.07um) >= 0.225um
 chk_DOP_GT = RECTANGLE GTDMP >= 0.07 BY >= 0.072
 good_DOP_GT = RECTANGLE GTDMP >= 0.07 BY >= 0.225
 err1 = chk_DOP_GT NOT good_DOP_GT
 err1 NOT INSIDE SealR_NOT_BULK
}

GTDMP_A_1 {
@ GTDMP area >= 0.00416um2
 err1 = AREA GTDMP < 0.00416
 err1 NOT INSIDE SealR_NOT_BULK
}

GTDMP_R_1 {
@ Rectangle GTDMP outside AA must be GATE poly direction and the same with the device channel width direction of core area in a chip (GTDMP length/width > 1 and width < 0.1um)
//; DRC only check if GTDMP width < 0.1um, it should be in GATE poly direction
 chk_dop_gt = WITH WIDTH (RECTANGLE (GTDMP OUTSIDE AA) ORTHOGONAL ONLY) < 0.100
 v_sides_gt = ANGLE chk_dop_gt == 90
 h_sides_gt = ANGLE chk_dop_gt == 0
 err1 = DFM PROPERTY chk_dop_gt v_sides_gt h_sides_gt OVERLAP [diff_len_h = MAX(LENGTH(h_sides_gt)) - MAX(LENGTH(v_sides_gt))] > 0
 err1 NOT INSIDE SealR_NOT_BULK
}

AA_interact_GT_v_edges = edge_gate_AA_all_v_edges COIN EDGE (edge_gate_AA_all INTERACT AA_INTERACT_GT)
AA_sd_all_dum = (AA NOT AOP_GT) INTERACT GTDMP >= 2

GTDMP_R_2 {
@ GTDMP form device is not allowed
@ 1) Maximum two AOP_GTs must be placed beside AA edge (AA INTERACT GT)
@ 2) M0 be placed between GTDMP and AA edge, and between two GTDMPs are not allowed, except MOMDMY, ESDIO1, ESDIO2 regions
 waive_area = OR MOMDMY ESDIO_all
 err1 = (GTDMP AND AA) NOT INSIDE waive_area
 err1 NOT INSIDE SealR_NOT_BULK  //; GTDMP is used for device

 err2 = ((M0 INTERACT AA_sd_all_dum) OR AA_sd_all_dum) NOT INSIDE waive_area
 err2 NOT INSIDE SealR_NOT_BULK  //; AOP_GTs are placed in between

 GTDMP_AA_in_between = EXT AA_interact_GT_v_edges (GTDMP NOT INSIDE waive_area) < 0.180 OPPOSITE REGION EXCLUDE SHIELDED  //;based on GT pitch
 GTDMP_M0_in_between = EXT (GTDMP NOT INSIDE waive_area) < 0.180 OPPOSITE REGION EXCLUDE SHIELDED
 err3 = (M0 AND (OR GTDMP_AA_in_between GTDMP_M0_in_between)) NOT INSIDE waive_area
 err3 NOT INSIDE SealR_NOT_BULK
}

// =======================================================
// P2: GT cut design rules
// =======================================================

GROUP GP2 P2_?

#IFDEF MANUFACTURABILITY_ENHANCEMENT_RULES YES
P2_S_1a_ME {
@ Space between two P2s, except poly center-to-center space = 0.09um design, except INST region >= 0.096um
 waive_TMP = INT GT_v_edges <= 0.036 OPPOSITE REGION CENTERLINE 0.0002
 waive = (EXT waive_TMP == 0.09-0.0002 ABUT<90 OPPOSITE REGION) OR waive_TMP
 err1 = (EXT P2 < 0.096 ABUT<90 SINGULAR REGION) NOT INSIDE waive
 err1 NOT INSIDE INST
}

P2_S_4b_ME {
@ Space between P2 and AOP_AA in P2 width direction (overlap is not allowed), except P2 to pick-up space = 0.014um and INST region >= 0.02um
 waive_cond = EXT P2 TAP_RAW == 0.014 OPPOSITE REGION
 err1 = (EXT P2_h_edges AOP_AA < 0.02 ABUT<90 OPPOSITE REGION) NOT waive_cond
 err2 = AND AOP_AA (P2 INTERACT AOP_AA)

 err1 NOT INSIDE INST
 err2 NOT INSIDE INST
}

P2_EX_1a_ME {
@ P2 extension outside of AOP_GT (width = 0.016um) in P2 length direction in GT_P96 region, except INST region >= 0.04um
 err1_TMP = ENC AOP_GT_016 P2_v_edges < 0.040 ABUT<90 OPPOSITE REGION EXCLUDE SHIELDED
 err1 = err1_TMP NOT OUTSIDE GT_P96
 err1 NOT INSIDE INST
}

P2_EX_1b_ME {
@ P2 extension outside of AOP_GT (width = 0.018um) in P2 length direction in GT_P96 region, except INST region >= 0.039um
 err1_TMP = ENC AOP_GT_018 P2_v_edges < 0.039 ABUT<90 OPPOSITE REGION EXCLUDE SHIELDED
 err1 = err1_TMP NOT OUTSIDE GT_P96
 err1 NOT INSIDE INST
}

P2_EX_1c_ME {
@ P2 extension outside of AOP_GT (width = 0.02um) in P2 length direction in GT_P96 region, except INST region >= 0.038um
 err1_TMP = ENC AOP_GT_020 P2_v_edges < 0.038 ABUT<90 OPPOSITE REGION EXCLUDE SHIELDED
 err1 = err1_TMP NOT OUTSIDE GT_P96
 err1 NOT INSIDE INST
}

P2_EX_1c1_ME {
@ P2 extension outside of AOP_GT (width = 0.022um) in P2 length direction in GT_P96 region, except INST region >= 0.037um
 err1_TMP = ENC AOP_GT_022 P2_v_edges < 0.037 ABUT<90 OPPOSITE REGION EXCLUDE SHIELDED
 err1 = err1_TMP NOT OUTSIDE GT_P96
 err1 NOT INSIDE INST
}

P2_EX_1d_ME {
@ P2 extension outside of AOP_GT (width = 0.024um) in P2 length direction in GT_P96 region, except INST region >= 0.036um
 err1_TMP = ENC AOP_GT_024 P2_v_edges < 0.036 ABUT<90 OPPOSITE REGION EXCLUDE SHIELDED
 err1 = err1_TMP NOT OUTSIDE GT_P96
 err1 NOT INSIDE INST
}
#ENDIF

P2_W_1 {
@ P2 width in GATE poly direction, except INST and OCOVL region = 0.048, 0.068, 0.108um
 err1 = P2 NOT (OR P2_W_048 P2_W_068 P2_W_108)
 err1 NOT INSIDE INST_OCOVL
}

P2_W_2 {
@ Maximum width of ((ALL_GT INTERACT P2) NOT DG) <= 0.092um
 err1 = ALL_GT_with_P2_core WITH WIDTH > 0.092
 err1 NOT INSIDE SealR_NOT_BULK
}

P2_W_3 {
@ Maximum width of ((ALL_GT INTERACT P2) NOT DG) when P2 width = 0.048um. < 0.07um
 chk_ALL_GT = ALL_GT_with_P2_core INTERACT P2_W_048
 err1 = chk_ALL_GT WITH WIDTH >= 0.07
 err1 NOT INSIDE SealR_NOT_BULK
}

P2_L_1 {
@ P2 edge length in S/D direction >= 0.09um
 err1 = LENGTH P2_h_edges < 0.09
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

P2_L_2 {
@ P2 edge length (width >= 0.108um) in S/D direction, except OCOVL region >= 0.166um
 err1 = LENGTH P2_W_eqgt_108_edges < 0.166
 err1 NOT INSIDE EDGE OCOVL
}

P2_S_1a {
@ Space between two P2s, except INST region >= 0.09um
 err1 = EXT P2 < 0.09 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE INST
}

P2_S_1b {
@ Space between two P2s when one or both P2 width >= 0.108um. >= 0.178um
 err1 = EXT P2 P2_eqgt_108 < 0.178 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

P2_S_1c {
@ Space between P2 (width = 0.048um) in GATE poly direction, except INST region >= 0.148um
 err1 = EXT P2_W_048_edges < 0.148 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE INST
}

P2_S_1d {
@ At least one side space between P2 in GATE poly direction when PRL > 0.312um, except OCOVLP2A region >= 0.178um
 sps_lt180_sides = EXT [P2_h_edges] P2 < 0.178 ABUT<90 OPPOSITE
 sps_lt180_sides_PRL = LENGTH sps_lt180_sides > 0.312
 err1_TMP = INT sps_lt180_sides_PRL <= 0.130 ABUT<90 OPPOSITE REGION EXCLUDE SHIELDED  //;based on P2.W.1
 err1 = err1_TMP ENCLOSE RECTANGLE 0.312+GLOBAL_TOLERANCE 0.005 ORTHOGONAL ONLY
 err1 NOT INSIDE OCOVLP2A
}

P2_S_1e {
@ At least one side space between P2(width >= 0.108um) in GATE poly direction when PRL > 0.312um. >= 0.218um
 sps_lt225_sides = EXT [P2_W_eqgt_108_edges] < 0.218 ABUT<90 OPPOSITE
 sps_lt225_sides_PRL = LENGTH sps_lt225_sides > 0.312
 err1_TMP = INT sps_lt225_sides_PRL <= 0.130 ABUT<90 OPPOSITE REGION  //;based on P2.W.1
 err1 = err1_TMP ENCLOSE RECTANGLE 0.312+GLOBAL_TOLERANCE 0.005 ORTHOGONAL ONLY
 err1 NOT INSIDE SealR_NOT_BULK
}

P2_S_2 {
@ Space between P2 and AOP_GT, except INST region >= 0.035um
 err1 = EXT P2 AOP_GT < 0.035 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE INST
}

P2_jog_100 = ANGLE (CONVEX EDGE P2 ANGLE1 == 90 ANGLE2 == 270 WITH LENGTH < 0.100) == 90
P2_jog_sps_040_AOP_GT_edges = EXT P2_jog_100 [AOP_GT] <= 0.040 ABUT<90 OPPOSITE
P2_jog_sps_045_AOP_GT_edges = EXT P2_jog_100 [AOP_GT] <= 0.045 ABUT<90 OPPOSITE

P2_S_3 {
@ Space between P2 and M0G in GATE poly direction (overlap is not allowed) >= 0.035um
@ 1) DRC checks the M0G on nearest AOP_GT with distance from P2 jog <= 0.100um
@ 2) Space between P2 jog's vertical edge and GT is <= 0.04um
 m0g_CHK = M0G INTERACT (AOP_GT WITH EDGE P2_jog_sps_040_AOP_GT_edges)
 GTs_CHK = AOP_GT_NOT_P2 INTERACT m0g_CHK
 err_CRN = INT GTs_CHK < 0.005 ABUT==90 INTERSECTING ONLY REGION
 err_CHK = P2_h_edges TOUCH EDGE (err_CRN WITH EDGE P2_jog_sps_040_AOP_GT_edges)

 err1 = EXT m0g_CHK err_CHK < 0.035 ABUT<90 OPPOSITE REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK

// err2 = m0g_CHK AND P2  // M0G is allowed in P2 based on P2.EX.6
// err2 NOT INSIDE SealR_NOT_BULK
}

P2_S_4a {
@ Space between P2 and AOP_AA in P2 width direction (overlap is not allowed), except P2 to pick-up space = 0.014um and INST region >= 0.016um
 err1_waive = EXT P2_h_edges TAP_RAW == 0.014 OPPOSITE REGION
 err1 = (EXT P2_h_edges AOP_AA < 0.016 ABUT<90 OPPOSITE REGION) NOT err1_waive
 err2 = AND AOP_AA P2

 err1 NOT INSIDE INST
 err2 NOT INSIDE INST
}

#IFDEF DFM_RULES_PRIORITY_1 YES
P2_S_7_DFM1 {
@ Recommended P2 space to GATE in GATE poly direction when AA width <= 0.576um, poly <= 0.02um, PRL > -0.215um. >= 0.12um
 chk_aa = (AA INTERACT GT_eqlt_020) WITH WIDTH <= 0.576
 chk_po = (GT_eqlt_020 AND chk_aa) AND GATE
 err1 = EXT P2_h_edges chk_po < 0.12 ABUT<90 OPPOSITE EXTENDED 0.215 REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

P2_S_8_DFM1 {
@ Recommended P2 space to GATE in GATE poly direction when AA width <= 0.576um, poly <= 0.024um, PRL > -0.23um inside GT_P96 region >= 0.12um
 chk_aa = (AA INTERACT GT_eqlt_024) WITH WIDTH <= 0.576
 chk_po = (GT_eqlt_024 AND chk_aa) AND GATE
 err1 = (EXT P2_h_edges chk_po < 0.12 ABUT<90 OPPOSITE EXTENDED 0.23 REGION) NOT OUTSIDE GT_P96
 err1 NOT INSIDE SealR_NOT_BULK
}

P2_S_9_DFM1 {
@ For NMOS, Channel length <= 24nm, SA/SB = (192nm-GT/2) or (180-GT/2):
@ If both left and right first adjacent GT is cut, Fin number = 2, suggest P2 to AA space >= 40nm, Fin number = 3&4, suggest P2 to AA space >= 25nm
 sa_sb_192_180 = ((NACT ENCLOSE NGATE) INTERACT GATE_raw == (1+1)*2 +1) ENCLOSE TRGATE_LE_LT_24
 adjacent_gate = TRGATE INTERACT (SD INTERACT TRGATE == 1)
 adjacent_gate_o = ((GT INTERACT adjacent_gate) NOT edge_gate_AA_act) INTERACT P2
 adjacent_gate_r = sa_sb_192_180 INTERACT (adjacent_gate INTERACT adjacent_gate_o) == 2
 adjacent_gate_p = P2 INTERACT (adjacent_gate_o INTERACT adjacent_gate_r)
 err1 = EXT (adjacent_gate_r INTERACT FIN == 2) (adjacent_gate_p COIN EDGE P2_h_edges) < 0.040 ABUT<90 OPPOSITE REGION
 err2 = EXT (adjacent_gate_r INTERACT FIN >= 3 <= 4) (adjacent_gate_p COIN EDGE P2_h_edges) < 0.025 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

P2_S_10_DFM1 {
@ For PMOS, Channel length <= 24nm:
@ If both left and right first adjacent GT is cut, Fin number = 2, suggest P2 to AA space >= 68nm, Fin number = 3&4, suggest P2 to AA space >= 50nm
@ if only one side adjacent GT is cut, suggest P2 to AA space >= 25nm
 sa_sb_192_180 = ((PACT ENCLOSE PGATE) INTERACT GATE_raw == (1+1)*2 +1) ENCLOSE TRGATE_LE_LT_24
 adjacent_gate = TRGATE INTERACT (SD INTERACT TRGATE == 1)
 adjacent_gate_o = ((GT INTERACT adjacent_gate) NOT edge_gate_AA_act) INTERACT P2
 adjacent_gate_r2 = sa_sb_192_180 INTERACT (adjacent_gate INTERACT adjacent_gate_o) == 2
 adjacent_gate_r1 = sa_sb_192_180 INTERACT (adjacent_gate INTERACT adjacent_gate_o) == 1
 adjacent_gate_p2 = P2 INTERACT (adjacent_gate_o INTERACT adjacent_gate_r2)
 adjacent_gate_p1 = P2 INTERACT (adjacent_gate_o INTERACT adjacent_gate_r1)
 err1 = EXT (adjacent_gate_r2 INTERACT FIN == 2) (adjacent_gate_p2 COIN EDGE P2_h_edges) < 0.068 ABUT<90 OPPOSITE REGION
 err2 = EXT (adjacent_gate_r2 INTERACT FIN >= 3 <= 4) (adjacent_gate_p2 COIN EDGE P2_h_edges) < 0.050 ABUT<90 OPPOSITE REGION
 err3 = EXT (adjacent_gate_r1 INTERACT FIN >= 2 <= 4) (adjacent_gate_p1 COIN EDGE P2_h_edges) < 0.025 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
}
#ENDIF

P2_EX_1 {
@ P2 extension outside of AOP_GT in P2 length direction >= 0.035um
 err1 = ENC AOP_GT_v_edges P2 < 0.035 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

/*
P2_EX_1a {
@ P2 extension outside of AOP_GT (width = 0.016/0.018/0.02/0.024um) in P2 length direction respectively in GT_P96 region >= 0.04/0.039/0.038/0.036um
 err1 = (ENC AOP_GT_016_v_edges P2 < 0.040 ABUT<90 OPPOSITE REGION EXCLUDE SHIELDED) NOT OUTSIDE GT_P96
 err2 = (ENC AOP_GT_018_v_edges P2 < 0.039 ABUT<90 OPPOSITE REGION EXCLUDE SHIELDED) NOT OUTSIDE GT_P96
 err3 = (ENC AOP_GT_020_v_edges P2 < 0.038 ABUT<90 OPPOSITE REGION EXCLUDE SHIELDED) NOT OUTSIDE GT_P96
 err4 = (ENC AOP_GT_024_v_edges P2 < 0.036 ABUT<90 OPPOSITE REGION EXCLUDE SHIELDED) NOT OUTSIDE GT_P96

 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
 err4 NOT INSIDE SealR_NOT_BULK
}
*/

AOP_GT_convex_edges_in_P2 = ((CONVEX EDGE AOP_GT == 2) INSIDE EDGE P2) NOT TOUCH EDGE (AOP_GT TOUCH EDGE (AOP_GT OUTSIDE EDGE P2))
P2_enclosure_AOP_GT_area = ENC AOP_GT_convex_edges_in_P2 P2 <= 0.130-0.04 OPPOSITE REGION //;based on P2.O.1
P2_cut_by_AOP_GT_area = (P2 NOT (OR AOP_GT P2_enclosure_AOP_GT_area)) WITH EDGE P2_v_edges

VARIABLE P2_EX_2_val_min 0.036
VARIABLE P2_EX_2_val_max 0.052

P2_EX_2 {
@ P2 extension outside of AOP_GT along S/D direction when one side poly space >= 0.08um and width <= 0.02um, except GT_P96 region = 0.036~0.052um
@ DRC only flags the outermost AOP_GT along S/D direction
 AOP_GT_lt_020_edges = INT [AOP_GT_eqlt_020] <= 0.020 ABUT<90 OPPOSITE
 AOP_GT_lt_020_edges_in_P2 = AOP_GT_lt_020_edges NOT OUTSIDE EDGE P2
 AOP_GT_lt_020_edges_in_P2_080 = EXT (AOP_GT_lt_020_edges_in_P2) AOP_GT < 0.08 ABUT<90 OPPOSITE EXCLUDE SHIELDED
 AOP_GT_extension_ok = ENC AOP_GT_lt_020_edges_in_P2_080 [P2] >= P2_EX_2_val_min <= P2_EX_2_val_max ABUT<90 OPPOSITE EXCLUDE SHIELDED
 err1 = ENC [AOP_GT_lt_020_edges_in_P2_080] P2 < P2_EX_2_val_min ABUT<90 OPPOSITE
 err1 NOT INSIDE EDGE GT_P96

 AOP_GT_extension_gt_050_all = ENC (AOP_GT_lt_020_edges_in_P2_080) P2 <= P2_EX_2_val_max ABUT<90 OPPOSITE EXCLUDE SHIELDED
 AOP_GT_extension_gt_050_all_005 = EXPAND EDGE AOP_GT_extension_gt_050_all INSIDE BY 0.005 OUTSIDE BY 0.005

 P2_cut_by_AOP_GT = (P2 INTERACT (AOP_GT WITH EDGE AOP_GT_lt_020_edges_in_P2_080)) NOT AOP_GT
 P2_cut_by_AOP_GT_hor = EXPAND EDGE (P2_h_edges COIN EDGE P2_cut_by_AOP_GT) INSIDE BY 0.001
 P2_cut_by_AOP_GT_est = P2_cut_by_AOP_GT_hor WITH EDGE (P2_v_edges NOT TOUCH EDGE AOP_GT_extension_ok)
 P2_cut_by_AOP_GT_chk = P2_cut_by_AOP_GT_area WITH EDGE AOP_GT_lt_020_edges
 P2_cut_by_AOP_GT_err = (P2_cut_by_AOP_GT_est INTERACT AOP_GT_extension_gt_050_all_005) OR (AOP_GT_extension_gt_050_all_005 INTERACT P2_cut_by_AOP_GT_est)
 err2 = (AOP_GT INSIDE EDGE P2_cut_by_AOP_GT_err) COIN EDGE P2_cut_by_AOP_GT_chk
 err2 NOT INSIDE EDGE GT_P96
}

VARIABLE P2_EX_3_val_min 0.039
VARIABLE P2_EX_3_val_max 0.052

P2_EX_3 {
@ P2 extension outside of AOP_GT along S/D direction when one side poly space > 0.08um and width <= 0.024um INSIDE GT_P96 region = 0.039~0.052um
@ DRC only flags the outermost AOP_GT along S/D direction
 P2_INSIDE_GT_P96 = P2 NOT OUTSIDE GT_P96
 AOP_GT_lt_024_edges = INT [AOP_GT_eqlt_024] <= 0.024 ABUT<90 OPPOSITE
 AOP_GT_lt_024_edges_in_P2 = AOP_GT_lt_024_edges NOT OUTSIDE EDGE P2
 AOP_GT_lt_024_edges_in_P2_080 = EXT (AOP_GT_lt_024_edges_in_P2) AOP_GT <= 0.08 ABUT<90 OPPOSITE EXCLUDE SHIELDED
 AOP_GT_extension_ok = ENC AOP_GT_lt_024_edges_in_P2_080 [P2] >= P2_EX_3_val_min <= P2_EX_3_val_max ABUT<90 OPPOSITE EXCLUDE SHIELDED
 err1 = ENC [AOP_GT_lt_024_edges_in_P2_080] P2_INSIDE_GT_P96 < P2_EX_3_val_min ABUT<90 OPPOSITE
 err1 NOT INSIDE EDGE SealR_NOT_BULK

 AOP_GT_extension_gt_050_all = ENC (AOP_GT_lt_024_edges_in_P2_080) P2 <= P2_EX_3_val_max ABUT<90 OPPOSITE EXCLUDE SHIELDED
 AOP_GT_extension_gt_050_all_005 = EXPAND EDGE AOP_GT_extension_gt_050_all INSIDE BY 0.005 OUTSIDE BY 0.005

 P2_cut_by_AOP_GT = (P2_INSIDE_GT_P96 INTERACT (AOP_GT WITH EDGE AOP_GT_lt_024_edges_in_P2_080)) NOT AOP_GT
 P2_cut_by_AOP_GT_hor = EXPAND EDGE (P2_h_edges COIN EDGE P2_cut_by_AOP_GT) INSIDE BY 0.001
 P2_cut_by_AOP_GT_est = P2_cut_by_AOP_GT_hor WITH EDGE (P2_v_edges NOT TOUCH EDGE AOP_GT_extension_ok)
 P2_cut_by_AOP_GT_chk = P2_cut_by_AOP_GT_area WITH EDGE AOP_GT_lt_024_edges
 P2_cut_by_AOP_GT_err = (P2_cut_by_AOP_GT_est INTERACT AOP_GT_extension_gt_050_all_005) OR (AOP_GT_extension_gt_050_all_005 INTERACT P2_cut_by_AOP_GT_est)
 err2 = ((AOP_GT INSIDE EDGE P2_cut_by_AOP_GT_err) COIN EDGE P2_cut_by_AOP_GT_chk) NOT OUTSIDE EDGE GT_P96
 err2 NOT INSIDE EDGE SealR_NOT_BULK
}

P2_EX_4 {
@ P2 extension outside of AOP_GT in GATE poly direction when PRL > -0.035um, except GT jog <= 0.004um and INST region >= 0.028um
 err1_TMP = ENC [AOP_GT_h_edges] P2 < 0.028 ABUT<90 OPPOSITE EXTENDED 0.035
 err1 = err1_TMP NOT COIN EDGE AOP_GT_jog_lteq_004
 err1 NOT INSIDE EDGE INST
}

P2_EX_5 {
@ ALL_GT extension outside of P2 in P2 width direction >= 0.09um
 err1 = ENC P2_h_edges ALL_GT < 0.09 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

P2_EX_6 {
@ P2 extension outside of (M0G AND AOP_GT) in GATE poly direction (P2 cut (M0G AND AOP_GT) is not allowed), except M0G (width/length = 0.06/0.095~0.096um) and INST region >= 0.034um
 m0g_RAW = M0G NOT (OR M0G_W060_L095 M0G_W060_L096)
 m0g_CHK = m0g_RAW AND AOP_GT
 err1 = ENC (ANGLE m0g_CHK == 0) P2 < 0.034 ABUT<90 OPPOSITE REGION
 err2 = m0g_CHK CUT P2  //; m0g_CHK totally inside P2 is allowed
 err1 NOT INSIDE INST
 err2 NOT INSIDE INST
}

P2_O_1 {
@ Overlap of AOP_GT and P2 in GATE poly direction, except AOP_GT jog <= 0.004um and INST region >= 0.04um
 err1 = INT (AOP_GT NOT COIN EDGE AOP_GT_jog_lteq_004) P2_h_edges < 0.04 ABUT<90 OPPOSITE REGION  //; exclude jog, GT can be jointed in P2
 err1 NOT INSIDE INST
}

P2_A_1 {
@ (ALL_GT NOT P2) area, except INST region >= 0.0024um2
 err1 = AREA ALL_GT_NOT_P2 < 0.0024
 err1 NOT INSIDE INST
}

ALL_P2_NOT_MARKS = ALL_P2 NOT MARKS

#IFDEF IP_LEVEL_DENSITY_CHECK YES
P2_D_1a {
@ Full chip ALL_P2 density <= 15%
 DENSITY ALL_P2_NOT_MARKS CHIP_NOT_MARKS [AREA(ALL_P2_NOT_MARKS)/AREA(CHIP_NOT_MARKS)] > 0.15 PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_P2_D_1a.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_P2_D_1a.rdb"
}

#IFDEF MINIMUM_DENSITY_CHECK YES
P2_D_1b {
@ Full chip ALL_P2 density >= 5%
 DENSITY ALL_P2_NOT_MARKS CHIP_NOT_MARKS [AREA(ALL_P2_NOT_MARKS)/AREA(CHIP_NOT_MARKS)] < 0.05 PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_P2_D_1b.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_P2_D_1b.rdb"
}
#ENDIF

VARIABLE P2_D_2_val 19
VARIABLE P2_D_2_window 20

P2_D_2 {
@ Maximum ALL_P2 density (window 20um*20um, stepping 20um/step_number), except INST region <= 19%
 check_region = DRC:1 NOT MARKS_INST
 check_pattern = ALL_P2 AND check_region

 check_window1 = check_region WITH WIDTH >= P2_D_2_window/4
 err1_TMP1 = DENSITY check_pattern check_window1 check_region [!!AREA(check_window1)*AREA(check_pattern)/AREA(check_region)] > P2_D_2_val/100 WINDOW P2_D_2_window STEP P2_D_2_window/step_number BACKUP INSIDE OF LAYER DRC:1 BY POLYGON

 check_window2 = WITH WIDTH (check_region AND err1_TMP1) >= P2_D_2_window/4
 err1_TMP2 = DENSITY check_pattern check_window2 check_region [!!AREA(check_window2)*AREA(check_pattern)/AREA(check_region)] > P2_D_2_val/100 WINDOW P2_D_2_window STEP P2_D_2_window/step_number BACKUP INSIDE OF LAYER err1_TMP1 BY POLYGON

 check_window3 = WITH WIDTH (check_region AND err1_TMP2) >= P2_D_2_window/4
 DENSITY check_pattern check_window3 check_region [!!AREA(check_window3)*AREA(check_pattern)/AREA(check_region)] > P2_D_2_val/100 WINDOW P2_D_2_window STEP P2_D_2_window/step_number BACKUP INSIDE OF LAYER err1_TMP2 BY POLYGON PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_P2_D_2.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_P2_D_2.rdb"
}
#ELSE

P2_D_1a {
@ Full chip ALL_P2 density <= 15%
 DENSITY ALL_P2_NOT_MARKS CHIP_NOT_MARKS [AREA(ALL_P2_NOT_MARKS)/AREA(CHIP_NOT_MARKS)] > 0.15 PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_P2_D_1a.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_P2_D_1a.rdb"
}

#IFDEF MINIMUM_DENSITY_CHECK YES
P2_D_1b {
@ Full chip ALL_P2 density >= 5%
 DENSITY ALL_P2_NOT_MARKS CHIP_NOT_MARKS [AREA(ALL_P2_NOT_MARKS)/AREA(CHIP_NOT_MARKS)] < 0.05 PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_P2_D_1b.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_P2_D_1b.rdb"
}
#ENDIF

VARIABLE P2_D_2_val 20
VARIABLE P2_D_2_window 20

P2_D_2 {
@ Maximum ALL_P2 density (window 20um*20um, stepping 10um), except INST region <= 20%
 check_region = DRC:1 NOT MARKS_INST
 check_pattern = ALL_P2 AND check_region

 check_window1 = check_region WITH WIDTH >= P2_D_2_window/4
 err1_TMP1 = DENSITY check_pattern check_window1 check_region [!!AREA(check_window1)*AREA(check_pattern)/AREA(check_region)] > P2_D_2_val/100 WINDOW P2_D_2_window STEP P2_D_2_window/2 BACKUP INSIDE OF LAYER DRC:1 BY POLYGON

 check_window2 = WITH WIDTH (check_region AND err1_TMP1) >= P2_D_2_window/4
 err1_TMP2 = DENSITY check_pattern check_window2 check_region [!!AREA(check_window2)*AREA(check_pattern)/AREA(check_region)] > P2_D_2_val/100 WINDOW P2_D_2_window STEP P2_D_2_window/2 BACKUP INSIDE OF LAYER err1_TMP1 BY POLYGON

 check_window3 = WITH WIDTH (check_region AND err1_TMP2) >= P2_D_2_window/4
 DENSITY check_pattern check_window3 check_region [!!AREA(check_window3)*AREA(check_pattern)/AREA(check_region)] > P2_D_2_val/100 WINDOW P2_D_2_window STEP P2_D_2_window/2 BACKUP INSIDE OF LAYER err1_TMP2 BY POLYGON PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_P2_D_2.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_P2_D_2.rdb"
}
#ENDIF

P2_R_1 {
@ P2 must be a rectangle, horizontal T- and crosstype-shape, square-wave-shape, L-shape, except OCOVL region
@ 1. Every segment of L-, T-, crosstype- or square-wave-shape P2 INTERACT at least two AOP_GT
@ 2. L- or square-wave-shape P2 width must be combination of 0.048/0.068um and jog must = 0.020um
@ 3. Horizontal T-shape, crosstype-shape P2 must be symmetric in GATE poly direction
//; ;;;;;;;;;;;;;;  ;;;;;;;;;;;;;;	    ;;;;;;;;;;;;;;	       ;;;;;;;;;;;       	;;;;;;;;;;	  ;;;;;;;;		  ;;;;;;;;	;;;;;;;;
//; ;;		;;  ;;		;;	    ;;		;;;;;;;;;  ;;;;;;	;;;;;;;	 ;;;;;;;;;	;;;;;;;;  ;;	;;;;;;;;;;;;;;;;  ;;	;;;;;;;;;;    ;;
//; ;;any size	;;  ;;		;;;;;;;;;;  ;;	any size,symm  ;;  ;;	 	     ;;  ;; any size,symm     ;;  ;; only 48*68	      ;;  ;;   only 48*68     ;;
//; ;;		;;  ;; only 48*68	;;  ;;		;;;;;;;;;  ;; only 48*68     ;;  ;;;;;;;;;	;;;;;;;;  ;;;;;;;;;;;;;;;;    ;;  ;;		      ;;
//; ;;;;;;;;;;;;;;  ;;;;;;;;;;;;;;;;;;;;;;  ;;;;;;;;;;;;;;   	   ;;;;;;;;;;;;;;;;;;;;  	;;;;;;;;;;			;;;;;;;;  ;;;;;;;;;;;;;;;;;;;;;;
//;
//; ;;;;;;;;	;;;;;;;;    ;;;;;;;;	    ;;;;;;;;;;;;     ;;;;;;;;;;;     ;;;;;;;;;;
//; ;;	  ;;;;;;;;    ;;;;;;;;    ;;;;;;;;  ;;	      ;;;;;;;;;	      ;;;;;;;;;      ;;
//; ;;  only 48*68,any jogs(>= 2) is ok	;;  ;;	bad pattern,any jogs(>= 2) is fail   ;;
//; ;;		           		;;  ;;	      ;;;;;;;;;	      ;;;;;;;;;      ;;
//; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;  ;;;;;;;;;;;;     ;;;;;;;;;;;     ;;;;;;;;;;

 P2_check = P2 NOT INSIDE OCOVL
 P2_R_shape = RECTANGLE P2_check
 P2_NR_shape = NOT RECTANGLE P2_check
 P2_concave_corner = EXT P2_check < 0.005 ABUT==90 INTERSECTING ONLY REGION
 err1 = ANGLE P2_check > 0 < 90
 err2 = DONUT P2_check
 err1 NOT INSIDE EDGE OCOVL //;non-orthogonal P2
 err2 NOT INSIDE OCOVL  //;ring type P2

//;P2 each width parts
 Y1 = (ANGLE P2_convex_90_90_edge == 0) COIN EDGE P2_check
 Y2 = (ANGLE P2_convex_90_270_edge == 90) COIN EDGE P2_check
 Y3 = (ANGLE P2_convex_270_270_edge == 90) COIN EDGE P2_check
 Y4 = EXPAND EDGE Y1 OUTSIDE BY 0.005
 Y5 = EXPAND EDGE Y2 INSIDE BY 0.005

 P2_CONVEX_90_90_real = Y1 COIN EDGE (Y4 INTERACT Y5)
 P2_WHOLE_NR_SHAPE = INT P2_CONVEX_90_90_real P2 <= P2_MaxiWidth ABUT<90 OPPOSITE REGION  //;whole big part in non-R shape
 P2_WHOLE_NR_SHAPE_OPP = INT P2_CONVEX_90_90_real (P2 NOT COIN EDGE P2_CONVEX_90_90_real) <= P2_MaxiWidth ABUT<90 OPPOSITE REGION  //;1.whole big part in R shape 2.opposite part
 P2_CORSS_SHAPE_OPP = INT P2_CONVEX_90_90_real <= P2_MaxiWidth ABUT<90 OPPOSITE REGION  //;opposite portion in the corss part

//;P2_L_SHAPE: only can be 0.048/0.068
 P2_L_SHAPE_TMP = P2_NR_shape INTERACT P2_concave_corner == 1
 P2_L_SHAPE_CHK = ((P2_L_SHAPE_TMP WITH EDGE P2_convex_90_90_edge == 4) WITH EDGE P2_convex_90_270_edge == 2) NOT WITH EDGE P2_convex_270_270_edge
 P2_L_SHAPE = ((P2_L_SHAPE_CHK INTERACT P2_W_048) INTERACT P2_W_068) NOT INTERACT (OR P2_W_036 P2_W_110 P2_W_130)  //;good L-shape

//;P2_T_SHAPE (symmetry along S/D direction): can be any size
 P2_T_SHAPE_TMP = P2_NR_shape INTERACT P2_concave_corner == 2
 P2_T_SHAPE_CHK = ((P2_T_SHAPE_TMP WITH EDGE P2_convex_90_90_edge == 4) WITH EDGE P2_convex_90_270_edge == 4) NOT WITH EDGE P2_convex_270_270_edge
 P2_T_SHAPE_VER_E = EXPAND EDGE (P2_T_SHAPE_CHK COIN EDGE (ANGLE P2_convex_90_90_edge == 90)) INSIDE BY 0.001
 P2_T_SHAPE_VER_P = P2_T_SHAPE_VER_E WITH EDGE (P2_T_SHAPE_VER_E COIN EDGE P2_convex_90_270_edge) == 2
 P2_T_SHAPE = (P2_T_SHAPE_CHK INTERACT P2_T_SHAPE_VER_P) INTERACT P2_WHOLE_NR_SHAPE == 1

//;P2_S_SHAPE: only can be 0.048/0.068
 P2_S_SHAPE = (((P2 WITH EDGE Y2 == 2) NOT WITH EDGE P2_convex_270_270_edge) INTERACT P2_W_068 == 2) INTERACT P2_W_048 == 1
 P2_S_SHAPE_JOG_PART = P2_W_068 AND P2_S_SHAPE

//;P2_CROSSTYPE_SHAPE (single cross shape): can be any size
 P2_C_SHAPE_TMP = P2_NR_shape INTERACT P2_concave_corner == 4
 P2_C_SHAPE_CHK = ((P2_C_SHAPE_TMP WITH EDGE P2_convex_90_90_edge == 4) WITH EDGE P2_convex_90_270_edge == 8) NOT WITH EDGE P2_convex_270_270_edge
 P2_C_SHAPE = P2_C_SHAPE_CHK INTERACT P2_WHOLE_NR_SHAPE == 1

//;ALL L-shape R-shape T-shape C-shape P2
 P2_RLTC_SHAP = OR P2_R_shape P2_L_SHAPE P2_L_SHAPE_CHK P2_T_SHAPE P2_C_SHAPE

//;P2_SQUARE_WAVE_SHAPE
 P2_SQUARE_WAVE_SHAPE = P2_NR_shape NOT P2_RLTC_SHAP
 P2_SQUARE_WAVE_SHAPE_JOG = P2_SQUARE_WAVE_SHAPE COIN EDGE Y2

//;P2 width check
 err3 = P2_L_SHAPE_CHK NOT P2_L_SHAPE
 err3 NOT INSIDE OCOVL  //;L-shape P2 width must be 0.048/0.068

 err4 = LENGTH (P2_WHOLE_NR_SHAPE_OPP COIN EDGE Y2) != 0.02
 err4 NOT INSIDE EDGE OCOVL  //;wave jog length must be 0.02

 P2_MULTI_CORSS_SHAPE_OPP = P2_CORSS_SHAPE_OPP ENCLOSE (INT (P2 INTERACT P2_CORSS_SHAPE_OPP) < 0.001 ABUT==90 INTERSECTING ONLY REGION) == 4
 err5 = P2 INTERACT (P2_MULTI_CORSS_SHAPE_OPP INTERACT (P2 INTERACT P2_MULTI_CORSS_SHAPE_OPP > 1))
 err5 NOT INSIDE OCOVL  //;multi cross shape is not allowed

//;AOP_GT count check
 P2_L_SHAPE_B = SIZE (P2_L_SHAPE AND P2_WHOLE_NR_SHAPE) BY -0.001
 P2_L_SHAPE_S = SIZE (P2_L_SHAPE NOT P2_L_SHAPE_B) BY -0.001
 err6 = OR (P2_L_SHAPE_B INTERACT AOP_GT < 2) (P2_L_SHAPE_S INTERACT AOP_GT < 2)
 err6 NOT INSIDE OCOVL  //;AOP_GT < 2 for any part

 P2_T_SHAPE_C = INT (P2_T_SHAPE TOUCH EDGE P2_h_edges) <= P2_MaxiWidth ABUT<90 OPPOSITE REGION CENTERLINE 0.001 EXCLUDE SHIELDED
 P2_T_SHAPE_B = SIZE ((P2_T_SHAPE INTERACT P2_T_SHAPE_C == 1) AND P2_WHOLE_NR_SHAPE) BY -0.001
 P2_T_SHAPE_S = SIZE ((P2_T_SHAPE INTERACT P2_T_SHAPE_C == 1) NOT P2_T_SHAPE_B) BY -0.001
 err7 = OR (P2_T_SHAPE_B INTERACT AOP_GT < 2) (P2_T_SHAPE_S INTERACT AOP_GT < 2) (P2_T_SHAPE_B NOT INTERACT AOP_GT) (P2_T_SHAPE_S NOT INTERACT AOP_GT)
 err7 NOT INSIDE OCOVL  //;no AOP_GT/AOP_GT < 2 for any part

 P2_C_SHAPE_C = INT (P2_C_SHAPE TOUCH EDGE P2_h_edges) <= P2_MaxiWidth ABUT<90 OPPOSITE REGION CENTERLINE 0.001 EXCLUDE SHIELDED
 P2_C_SHAPE_B = SIZE ((P2_C_SHAPE INTERACT P2_C_SHAPE_C == 1) AND P2_WHOLE_NR_SHAPE) BY -0.001
 P2_C_SHAPE_S = SIZE ((P2_C_SHAPE INTERACT P2_C_SHAPE_C == 1) NOT P2_C_SHAPE_B) BY -0.001
 err8 = OR (P2_C_SHAPE_B INTERACT AOP_GT < 2) (P2_C_SHAPE_S INTERACT AOP_GT < 2) (P2_C_SHAPE_B NOT INTERACT AOP_GT) (P2_C_SHAPE_S NOT INTERACT AOP_GT)
 err8 NOT INSIDE OCOVL  //;no AOP_GT/AOP_GT < 2 for any part

 P2_SQUARE_WAVE_SHAPE_C = P2_SQUARE_WAVE_SHAPE NOT INTERACT (NOT RECTANGLE P2_WHOLE_NR_SHAPE)
 P2_SQUARE_WAVE_SHAPE_B = SIZE (P2_SQUARE_WAVE_SHAPE AND P2_WHOLE_NR_SHAPE) BY -0.001
 P2_SQUARE_WAVE_SHAPE_S = SIZE (P2_SQUARE_WAVE_SHAPE NOT P2_SQUARE_WAVE_SHAPE_B) BY -0.001
 err9 = OR (P2_SQUARE_WAVE_SHAPE_B INTERACT AOP_GT < 2) (P2_SQUARE_WAVE_SHAPE_S INTERACT AOP_GT < 2)
 err9 NOT INSIDE OCOVL  //;AOP_GT < 2 for any part

 err10 = OR (P2_NR_shape INTERACT AOP_GT < 2) (P2_NR_shape NOT INTERACT AOP_GT)
 err10 NOT INSIDE OCOVL  //;no AOP_GT/single AOP_GT for whole P2

 err11 = OR (P2_S_SHAPE_JOG_PART INTERACT AOP_GT < 2) (P2_S_SHAPE_JOG_PART NOT INTERACT AOP_GT)
 err11 NOT INSIDE OCOVL  //;no AOP_GT/single AOP_GT for JOG part of S-shape P2

//;Check symmetrical relation in GATE poly direction
 P2_WHOLE_NR_SHAPE_R_PART = RECTANGLE P2_WHOLE_NR_SHAPE
 P2_WHOLE_NR_SHAPE_R_PART_JOG = Y2 COIN EDGE P2_WHOLE_NR_SHAPE_R_PART
 P2_WHOLE_NR_SHAPE_R_PART_CHK = DFM PROPERTY P2_WHOLE_NR_SHAPE_R_PART P2_WHOLE_NR_SHAPE_R_PART_JOG OVERLAP ABUT ALSO MULTI
 [-= MAX(LENGTH(P2_WHOLE_NR_SHAPE_R_PART_JOG)) - MIN(LENGTH(P2_WHOLE_NR_SHAPE_R_PART_JOG))] > 0
 err12 = P2_WHOLE_NR_SHAPE_R_PART_JOG COIN EDGE P2_WHOLE_NR_SHAPE_R_PART_CHK
 err12 NOT INSIDE EDGE OCOVL

 err13 = NOT RECTANGLE P2_WHOLE_NR_SHAPE
 err13 NOT INSIDE OCOVL  //;whole big part should be rectangle

 err14 = P2_T_SHAPE_C INTERACT (P2_T_SHAPE INTERACT P2_T_SHAPE_C > 1)
 err14 NOT INSIDE OCOVL  //;P2_T_SHAPE centerline must be aligned

 err15 = INT (P2_h_edges) <= P2_MaxiWidth OPPOSITE
 err15 NOT INSIDE EDGE OCOVL  //;width > P2_MaxiWidth P2
}

VARIABLE MAXIMUM_2nd_DummySpace 0.481
VARIABLE MIMIMUM_2nd_DummySpace 0.180

P2_R_2 {
@ Width of P2 (INTERACT the second AOP_GT neighboring of GATE) in S/D direction = 0.048, 0.068um
//;P2 number > 1 is allowed
 neighboring_TRGATE_TEMP = TRGATE INTERACT (SD INTERACT (GATE_raw INTERACT AA_v_edges_exp001))
 neighboring_TRGATE_side = ENC [neighboring_TRGATE_TEMP] AA_v_edges < MAXIMUM_2nd_DummySpace/2 ABUT>0<90 OPPOSITE EXCLUDE SHIELDED
 neighboring_TRGATE_bulk = TRGATE WITH EDGE neighboring_TRGATE_side
 neighboring_TRGATE = neighboring_TRGATE_bulk AND GT

 neighboring_TRGATE_side_all = (neighboring_TRGATE TOUCH EDGE neighboring_TRGATE_side) NOT TOUCH OUTSIDE EDGE GTMK2  //;exclude the 1st GT in L-shape-AA corner
 neighboring_TRGATE_side_070 = neighboring_TRGATE_side_all TOUCH EDGE TRGATE_LE_GT_70
 neighboring_TRGATE_CheckAll = (EXPAND EDGE neighboring_TRGATE_side_all OUTSIDE BY MIMIMUM_2nd_DummySpace) OR (EXPAND EDGE neighboring_TRGATE_side_070 OUTSIDE BY MAXIMUM_2nd_DummySpace)
 err1 = (P2 INTERACT neighboring_TRGATE_CheckAll) NOT (OR P2_W_048 P2_W_068)
 err1 NOT INSIDE SealR_NOT_BULK
}

P2_R_3 {
@ P2 INTERACT DG is not allowed
 err1 = P2 INTERACT DG
 err1 NOT INSIDE SealR_NOT_BULK
}

P2_R_4 {
@ ALL_GT line end (width <= 0.024um) must fully INTERACT P2
 chk_ALL_GT = LENGTH ALL_GT_convex_90_90_edge <= 0.024
 err1 = (chk_ALL_GT NOT COIN EDGE P2) NOT INSIDE EDGE P2
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

P2_R_5 {
@ (P2 not INTERACT ALL_GT) is not allowed, except OCOVL region
 err1 = P2 NOT INTERACT ALL_GT
 err1 NOT INSIDE OCOVL
}

P2_R_6 {
@ Any vertex of P2 INTERACT AOP_GT is not allowed
 err1 = P2_v_edges NOT OUTSIDE EDGE AOP_GT  //;To reduce runtime
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

VARIABLE P2_R_7_P2Length 3.1

P2_and_GT = P2 AND AOP_GT
P2_l_gt_max = P2 ENCLOSE RECTANGLE 0.005 P2_R_7_P2Length ORTHOGONAL ONLY
P2_l_gt_max_and_GT = P2_l_gt_max AND AOP_GT

AOP_GT_NOT_P2_l_gt_max = (AOP_GT INTERACT P2_l_gt_max_and_GT) NOT P2
AOP_GT_NOT_P2_l_gt_max_good = (AOP_GT_NOT_P2_l_gt_max INTERACT M0G) INTERACT GTMK1

P2_R_7 {
@ Floating AOP_GT must be placed beside P2 edge if P2 length >= 3.1um
@ Floating AOP_GT definition: (AOP_GT NOT P2) NOT INTERACT M0G
@ Except the ((floating AOP_GT interact M0G) INTERACT GTMK1)
 P2_has_2_GT = (P2_l_gt_max NOT P2_l_gt_max_and_GT) INTERACT P2_l_gt_max_and_GT >= 2
 P2_has_1_GT = (P2_l_gt_max NOT P2_l_gt_max_and_GT) INTERACT P2_l_gt_max_and_GT < 2
 P2_and_2_GT = (P2_l_gt_max_and_GT INTERACT P2_has_2_GT) NOT INTERACT P2_has_1_GT //; inner intersecting area
 P2_and_1_GT = (P2_l_gt_max_and_GT INTERACT P2_has_1_GT) NOT INTERACT P2_and_2_GT
 AOP_GT_float = AOP_GT_NOT_P2_l_gt_max NOT INTERACT M0G
 AOP_GT_float_non = AOP_GT_NOT_P2_l_gt_max INTERACT M0G
 AOP_GT_float_non_P2 = P2_and_GT INTERACT AOP_GT_float_non

 P2_not_GT_beside_est = (P2_has_1_GT NOT INTERACT AOP_GT_float) INTERACT AOP_GT_float_non_P2
 P2_and_GT_beside_est = P2_and_GT INTERACT P2_not_GT_beside_est
 P2_and_GT_beside_est_v_edges = P2_and_GT_beside_est COIN EDGE P2_not_GT_beside_est
 err1_TMP = P2_and_GT_beside_est OR (EXPAND EDGE P2_and_GT_beside_est_v_edges OUTSIDE BY 0.01)
 err1 = err1_TMP NOT INTERACT AOP_GT_NOT_P2_l_gt_max_good
 err1 NOT INSIDE SealR_NOT_BULK
}

// =======================================================
// SN: N+ source/drain implantation design rules
// =======================================================

GROUP GSN SN_?

pact_no_butted = PACT not coin edge (AA AND SN)
nact_no_butted = NACT not coin edge (AA AND SP)
ptap_no_butted = PTAP_RAW not coin edge (AA AND SN)
ntap_no_butted = NTAPi_RAW not coin edge (AA AND SP)

NACT_inside_SN = NACT INSIDE SN
PACT_inside_SP = PACT INSIDE SP
NACT_outside_SP = NACT OUTSIDE SP
PACT_outside_SN = PACT OUTSIDE SN

NACT_inside_SN_h_edges = ANGLE NACT_inside_SN == 0
PACT_inside_SP_h_edges = ANGLE PACT_inside_SP == 0
NACT_outside_SP_h_edges = ANGLE NACT_outside_SP == 0
PACT_outside_SN_h_edges = ANGLE PACT_outside_SN == 0

NACT_inside_SN_v_edges = ANGLE NACT_inside_SN == 90
PACT_inside_SP_v_edges = ANGLE PACT_inside_SP == 90
NACT_outside_SP_v_edges = ANGLE NACT_outside_SP == 90
PACT_outside_SN_v_edges = ANGLE PACT_outside_SN == 90

pact_no_butted_ov = edge_gate_AA_pact not coin edge (edge_gate_AA_all AND SN)
nact_no_butted_ov = edge_gate_AA_nact not coin edge (edge_gate_AA_all AND SP)
ptap_no_butted_ov = edge_gate_AA_ptap not coin edge (edge_gate_AA_all AND SN)
ntap_no_butted_ov = edge_gate_AA_ntap not coin edge (edge_gate_AA_all AND SP)

NACT_inside_SN_ov = edge_gate_AA_nact AND SN
PACT_inside_SP_ov = edge_gate_AA_pact AND SP
NACT_outside_SP_ov = edge_gate_AA_nact NOT SP
PACT_outside_SN_ov = edge_gate_AA_pact NOT SN

NACT_inside_SN_h_edges_ov = ANGLE NACT_inside_SN_ov == 0
PACT_inside_SP_h_edges_ov = ANGLE PACT_inside_SP_ov == 0
NACT_outside_SP_h_edges_ov = ANGLE NACT_outside_SP_ov == 0
PACT_outside_SN_h_edges_ov = ANGLE PACT_outside_SN_ov == 0

NACT_inside_SN_v_edges_ov = ANGLE NACT_inside_SN_ov == 90
PACT_inside_SP_v_edges_ov = ANGLE PACT_inside_SP_ov == 90
NACT_outside_SP_v_edges_ov = ANGLE NACT_outside_SP_ov == 90
PACT_outside_SN_v_edges_ov = ANGLE PACT_outside_SN_ov == 90

//;For SN.S.8/SP.S.8/SN/EN.8/SP.EN.8
SN_v_edges = ANGLE SN > 88 <= 90
SP_v_edges = ANGLE SP > 88 <= 90
SN_chk_edges = LENGTH SN >= 0.0005  //;exclude jog < 0.01um
SP_chk_edges = LENGTH SP >= 0.0005

sn_convex_corner = INT [SN_chk_edges] < 0.002 ABUT==90 INTERSECTING ONLY
sn_concave_corner = EXT [SN_chk_edges] < 0.002 ABUT==90 INTERSECTING ONLY
nact_convex_corner = INT [NACT_inside_SN] < 0.002 ABUT==90 INTERSECTING ONLY
nact_concave_corner = EXT [NACT_inside_SN] < 0.002 ABUT==90 INTERSECTING ONLY
nact_convex_corner_ov = INT [NACT_inside_SN_ov] < 0.002 ABUT==90 INTERSECTING ONLY
nact_concave_corner_ov = EXT [NACT_inside_SN_ov] < 0.002 ABUT==90 INTERSECTING ONLY

sp_convex_corner = INT [SP_chk_edges] < 0.002 ABUT==90 INTERSECTING ONLY
sp_concave_corner = EXT [SP_chk_edges] < 0.002 ABUT==90 INTERSECTING ONLY
pact_convex_corner = INT [PACT_inside_SP] < 0.002 ABUT==90 INTERSECTING ONLY
pact_concave_corner = EXT [PACT_inside_SP] < 0.002 ABUT==90 INTERSECTING ONLY
pact_convex_corner_ov = INT [PACT_inside_SP_ov] < 0.002 ABUT==90 INTERSECTING ONLY
pact_concave_corner_ov = EXT [PACT_inside_SP_ov] < 0.002 ABUT==90 INTERSECTING ONLY

SN_W_1 {
@ SN width, except INST region >= 0.192um
 err1 = INT SN < SN_MiniWidth ABUT<90 SINGULAR REGION
 err1 NOT INSIDE INST
}

SN_S_1 {
@ SN space, except INST region >= 0.192um
 err1 = EXT SN < 0.192 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE INST
}

VARIABLE SN_S_2_val 0.248
VARIABLE SN_S_2_PRL 0.255-GLOBAL_TOLERANCE

SN_S_2 {
@ Space between SN in S/D direction when PRL >= 0.255um. >= 0.248um
 nw_err_RAW = ANGLE (EXT [SN] < SN_S_2_val ABUT<90 OPPOSITE) > 88 <= 90
 nw_jog_ALL = (CONVEX EDGE SN == 1) NOT COIN EDGE nw_err_RAW
 nw_jog_EXP_a = EXPAND EDGE nw_jog_ALL INSIDE BY 0.0005
 nw_jog_EXP_b = EXPAND EDGE nw_jog_ALL OUTSIDE BY 0.0005
 nw_jog_TMP = (nw_jog_ALL COIN EDGE (nw_jog_EXP_a WITH EDGE nw_err_RAW)) COIN EDGE (nw_jog_EXP_b WITH EDGE nw_err_RAW)
 nw_jog_EXP = ((VERTEX (EXPAND EDGE nw_jog_TMP OUTSIDE BY 0.001 EXTEND BY 0.001) == 4) OR (EXPAND EDGE nw_err_RAW OUTSIDE BY 0.001)) NOT SN
 nw_err_PRL = DFM PROPERTY nw_jog_EXP nw_err_RAW OVERLAP ABUT ALSO MULTI [-= LENGTH(nw_err_RAW)] > SN_S_2_PRL
 err1 = EXT (nw_err_RAW TOUCH EDGE nw_err_PRL) SN < SN_S_2_val ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

VARIABLE SN_S_3_val 0.224
VARIABLE SN_S_3_PRL 0.352

SN_S_3 {
@ SN space on STI if PRL >= 0.352um. >= 0.224um
@ except:
@ 1) SN space to ALL_AA < 0.082um in GATE poly direction
@ 2) SN space to ALL_AA < 0.109um in S/D direction
@ 3) GT_P96 and INST regions
 ERRS_all_RAW = EXT SN < SN_S_3_val ABUT<90 OPPOSITE REGION
 ERRS_all_TMP = ERRS_all_RAW ENCLOSE RECTANGLE 0.001 SN_S_3_PRL ORTHOGONAL ONLY
 waive_v_AREA = EXT ALL_AA_h_edges (SN INTERACT ERRS_all_TMP) < 0.082 ABUT<90 OPPOSITE REGION
 waive_h_AREA = EXT ALL_AA_v_edges (SN INTERACT ERRS_all_TMP) < 0.109 ABUT<90 OPPOSITE REGION

 err1_RAW = (ERRS_all_TMP NOT ALL_AA) NOT (OR waive_v_AREA waive_h_AREA)
 err1_TMP = err1_RAW ENCLOSE RECTANGLE 0.001 SN_S_3_PRL ORTHOGONAL ONLY
 err1 = err1_TMP NOT INSIDE GT_P96
 err1 NOT INSIDE INST
}

VARIABLE SN_S_4_val 0.224
VARIABLE SN_S_4_PRL 0.386

SN_S_4 {
@ SN space on STI if PRL >= 0.386um INSIDE GT_P96 region >= 0.224um
@ except:
@ 1) SN space to ALL_AA < 0.082um in GATE poly direction
@ 2) SN space to ALL_AA < 0.112um in S/D direction
 ERRS_all_RAW = EXT SN < SN_S_4_val ABUT<90 OPPOSITE REGION
 ERRS_all_TMP = ERRS_all_RAW ENCLOSE RECTANGLE 0.001 SN_S_4_PRL ORTHOGONAL ONLY
 waive_v_AREA = EXT ALL_AA_h_edges (SN INTERACT ERRS_all_TMP) < 0.082 ABUT<90 OPPOSITE REGION
 waive_h_AREA = EXT ALL_AA_v_edges (SN INTERACT ERRS_all_TMP) < 0.112 ABUT<90 OPPOSITE REGION

 err1_RAW = (ERRS_all_TMP NOT ALL_AA) NOT (OR waive_v_AREA waive_h_AREA)
 err1_TMP = err1_RAW ENCLOSE RECTANGLE 0.001 SN_S_4_PRL ORTHOGONAL ONLY
 err1 = err1_TMP NOT OUTSIDE GT_P96
 err1 NOT INSIDE SealR_NOT_BULK
}

SN_S_5 {
@ Space between SN and P+AA, except INST and DIOMK2 region >= 0.048um
 err1 = EXT SN PACT < 0.048 ABUT<90 SINGULAR REGION  //;GATED diode can be butted based on SN.R.1
 err1 NOT INSIDE INST_DIOMK2
}

SN_S_5a {
@ Space between SN and P+AA (AA vertical edge extend 1/2 GT width) in S/D direction, except INST and DIOMK2 region >= 0.065um
 err1 = EXT SN_v_edges edge_gate_AA_pact < 0.065 ABUT<90 OPPOSITE REGION  //;GATED diode can be butted based on SN.R.1
 err1 NOT INSIDE INST_DIOMK2
}

SN_S_6 {
@ Space between SN and P+ pick-up AA, except INST and DIOMK2 region >= 0.048um
 err1 = EXT SN PTAP_RAW < 0.048 ABUT<90 SINGULAR REGION  //;GATED diode can be butted based on SN.R.1
 err1 NOT INSIDE INST_DIOMK2
}

SN_S_6a {
@ Space between SN and P+ pick-up AA (AA vertical edge extend 1/2 GT width) in horizontal direction, except INST and DIOMK2 region >= 0.065um
 err1 = EXT SN_v_edges edge_gate_AA_ptap < 0.065 ABUT<90 OPPOSITE REGION  //;GATED diode can be butted based on SN.R.1
 err1 NOT INSIDE INST_DIOMK2
}

SN_S_7 {
@ Space between SN and DOP_AA (DOP_AA CUT SN is not allowed) >= 0.048um
 err1 = EXT DOP_AA SN < 0.048 ABUT<90 SINGULAR REGION
 err2 = SN INSIDE EDGE (DOP_AA CUT SN)

 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE EDGE SealR_NOT_BULK
}

SN_S_7a {
@ Space between SN and DOP_AA (AA vertical edge extend 1/2 GT width) in hotizontal direction (DOP_AA CUT SN is not allowed) >= 0.065um
 err1 = EXT SN_v_edges edge_gate_dopAA_all < 0.065 ABUT<90 OPPOSITE REGION
 err2 = SN INSIDE EDGE (edge_gate_dopAA_all CUT SN)

 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE EDGE SealR_NOT_BULK
}

VARIABLE SN_S_8_val_hor 0.087
VARIABLE SN_S_8_val_ver 0.061

SN_S_8 {
@ Space between SN and P+AA in GATE poly direction when space in S/D direction < 0.087um at each SN corner, except INST and DIOMK2 region >= 0.061um
 y1 = (EXT [PACT_outside_SN_v_edges] SN < SN_S_8_val_hor ABUT<90 OPPOSITE EXTENDED SN_S_8_val_ver) OR EDGE (EXT [PACT_outside_SN_h_edges] SN < SN_S_8_val_ver ABUT<90 OPPOSITE EXTENDED SN_S_8_val_hor)
 y2 = (EXT PACT_outside_SN_v_edges [SN] < SN_S_8_val_hor ABUT<90 OPPOSITE EXTENDED SN_S_8_val_ver) OR EDGE (EXT PACT_outside_SN_h_edges [SN] < SN_S_8_val_ver ABUT<90 OPPOSITE EXTENDED SN_S_8_val_hor)
 y3 = EXT pact_convex_corner sn_concave_corner < SN_S_8_val_hor ABUT<90 OPPOSITE EXTENDED SN_S_8_val_hor
 y4 = EXT pact_concave_corner sn_convex_corner < SN_S_8_val_hor ABUT<90 OPPOSITE EXTENDED SN_S_8_val_hor
 err1_a = INT y1 < 0.001 ABUT==90 INTERSECTING ONLY
 err1_b = EXT y2 < 0.001 ABUT==90 INTERSECTING ONLY
 err2_a = INT y2 < 0.001 ABUT==90 INTERSECTING ONLY
 err2_b = EXT y1 < 0.001 ABUT==90 INTERSECTING ONLY

 err1_c = DFM PROPERTY y3 err1_a err1_b ABUT ALSO OVERLAP MULTI [-= (count(err1_a) > 0 && count(err1_b) > 0) ? 1 : 0] > 0
 err2_c = DFM PROPERTY y4 err2_a err2_b ABUT ALSO OVERLAP MULTI [-= (count(err2_a) > 0 && count(err2_b) > 0) ? 1 : 0] > 0
 err1 = DFM COPY err1_c REGION
 err2 = DFM COPY err2_c REGION
 err1 NOT INSIDE INST_DIOMK2
 err2 NOT INSIDE INST_DIOMK2
}

VARIABLE SN_S_8a_val_hor 0.079
VARIABLE SN_S_8a_val_ver 0.061

SN_S_8a {
@ Space between SN and P+AA (AA vertical edge extend 1/2 GT width) in S/D direction when space in GATE poly direction < 0.061um at each SN corner >= 0.079um
@ Except INST and DIOMK2 region
 y1 = (EXT [PACT_outside_SN_v_edges_ov] SN < SN_S_8a_val_hor ABUT<90 OPPOSITE EXTENDED SN_S_8a_val_ver) OR EDGE (EXT [PACT_outside_SN_h_edges_ov] SN < SN_S_8a_val_ver ABUT<90 OPPOSITE EXTENDED SN_S_8a_val_hor)
 y2 = (EXT PACT_outside_SN_v_edges_ov [SN] < SN_S_8a_val_hor ABUT<90 OPPOSITE EXTENDED SN_S_8a_val_ver) OR EDGE (EXT PACT_outside_SN_h_edges_ov [SN] < SN_S_8a_val_ver ABUT<90 OPPOSITE EXTENDED SN_S_8a_val_hor)
 y3 = EXT pact_convex_corner_ov sn_concave_corner < SN_S_8a_val_hor ABUT<90 OPPOSITE EXTENDED SN_S_8a_val_hor
 y4 = EXT pact_concave_corner_ov sn_convex_corner < SN_S_8a_val_hor ABUT<90 OPPOSITE EXTENDED SN_S_8a_val_hor
 err1_a = INT y1 < 0.001 ABUT==90 INTERSECTING ONLY
 err1_b = EXT y2 < 0.001 ABUT==90 INTERSECTING ONLY
 err2_a = INT y2 < 0.001 ABUT==90 INTERSECTING ONLY
 err2_b = EXT y1 < 0.001 ABUT==90 INTERSECTING ONLY

 err1_c = DFM PROPERTY Y3 err1_a err1_b ABUT ALSO OVERLAP MULTI [-= (count(err1_a) > 0 && count(err1_b) > 0) ? 1 : 0] > 0
 err2_c = DFM PROPERTY Y4 err2_a err2_b ABUT ALSO OVERLAP MULTI [-= (count(err2_a) > 0 && count(err2_b) > 0) ? 1 : 0] > 0
 err1 = DFM COPY err1_c REGION
 err2 = DFM COPY err2_c REGION
 err1 NOT INSIDE INST_DIOMK2
 err2 NOT INSIDE INST_DIOMK2
}

SN_S_9 {
@ Space between SN vertical edge (edge length <= 0.296um between two concave corners with both sides length >= 0.09um) and AA (AA vertical edge extend 1/2 GT width) in S/D direction >= 0.079um
 EDG_RAW = CONVEX EDGE SN ANGLE1 == 270 LENGTH1 >= 0.09 ANGLE2 == 270 LENGTH2 >= 0.09 WITH LENGTH <= 0.296
 EDG_CHK = ANGLE EDG_RAW == 90
 err1 = EXT EDG_CHK edge_gate_AA_all < 0.079 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

SN_EN_5 {
@ SN enclosure of N+AA, except MARKS and INST and DIOMK2 regions >= 0.048um
 err1 = ENC NACT SN < 0.048 ABUT<90 REGION
 err1 NOT INSIDE (OR MARKS_INST DIOMK2)
}

SN_EN_5a {
@ SN enclosure of N+AA (AA vertical edge extend 1/2 GT width) in S/D direction, except INST and DIOMK2 region >= 0.065um
 err1 = ENC edge_gate_AA_nact SN_v_edges < 0.065 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE INST_DIOMK2
}

SN_EN_6 {
@ SN enclosure of N+ pick-up AA, except INST and DIOMK2 region >= 0.048um
 err1 = ENC NTAPi_RAW SN < 0.048 ABUT<90 REGION
 err1 NOT INSIDE INST_DIOMK2
}

SN_EN_6a {
@ SN enclosure of N+ pick-up AA (AA vertical edge extend 1/2 GT width) in horizontal direction, except INST and DIOMK2 region >= 0.065um
 err1 = ENC edge_gate_AA_ntap SN_v_edges < 0.065 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE INST_DIOMK2
}

SN_EN_7 {
@ SN enclosure of DOP_AA >= 0.048um
 err1 = ENC (DOP_AA AND SN) SN < 0.048 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

SN_EN_7a {
@ SN enclosure of DOP_AA (AA vertical edge extend 1/2 GT width) in S/D direction, except LOGO region >= 0.065um
 err1 = ENC (edge_gate_dopAA_all AND SN) SN_v_edges < 0.065 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE LOGO
}

VARIABLE SN_EN_8_val_ver 0.061
VARIABLE SN_EN_8_val_hor 0.087

SN_EN_8 {
@ SN enclosure of N+AA in GATE poly direction when enclosure in S/D direction < 0.087um at each SN corner, except INST and DIOMK2 region >= 0.061um
 y1 = (ENC [NACT_inside_SN_v_edges] SN < SN_EN_8_val_hor ABUT<90 OPPOSITE EXTENDED SN_EN_8_val_ver) OR EDGE (ENC [NACT_inside_SN_h_edges] SN < SN_EN_8_val_ver ABUT<90 OPPOSITE EXTENDED SN_EN_8_val_hor)
 y2 = (ENC NACT_inside_SN_v_edges [SN] < SN_EN_8_val_hor ABUT<90 OPPOSITE EXTENDED SN_EN_8_val_ver) OR EDGE (ENC NACT_inside_SN_h_edges [SN] < SN_EN_8_val_ver ABUT<90 OPPOSITE EXTENDED SN_EN_8_val_hor)
 y3 = ENC nact_convex_corner sn_convex_corner < SN_EN_8_val_hor ABUT<90 OPPOSITE EXTENDED SN_EN_8_val_hor
 y4 = ENC nact_concave_corner sn_concave_corner < SN_EN_8_val_hor ABUT<90 OPPOSITE EXTENDED SN_EN_8_val_hor
 err1_a = INT y1 < 0.001 ABUT==90 INTERSECTING ONLY
 err1_b = INT y2 < 0.001 ABUT==90 INTERSECTING ONLY
 err2_a = EXT y1 < 0.001 ABUT==90 INTERSECTING ONLY
 err2_b = EXT y2 < 0.001 ABUT==90 INTERSECTING ONLY

 err1_c = DFM PROPERTY y3 err1_a err1_b ABUT ALSO OVERLAP MULTI [-= (count(err1_a) > 0 && count(err1_b) > 0) ? 1 : 0] > 0
 err2_c = DFM PROPERTY y4 err2_a err2_b ABUT ALSO OVERLAP MULTI [-= (count(err2_a) > 0 && count(err2_b) > 0) ? 1 : 0] > 0
 err1 = DFM COPY err1_c REGION
 err2 = DFM COPY err2_c REGION
 err1 NOT INSIDE INST_DIOMK2
 err2 NOT INSIDE INST_DIOMK2
}

VARIABLE SN_EN_8a_val_ver 0.061
VARIABLE SN_EN_8a_val_hor 0.079

SN_EN_8a {
@ SN enclosure of N+AA (AA vertical edge extend 1/2 GT width) in S/D direction when enclosure in GATE poly direction < 0.061um at each SN corner, except INST and DIOMK2 region >= 0.079um
 y1 = (ENC [NACT_inside_SN_v_edges_ov] SN < SN_EN_8a_val_hor ABUT<90 OPPOSITE EXTENDED SN_EN_8a_val_ver) OR EDGE (ENC [NACT_inside_SN_h_edges_ov] SN < SN_EN_8a_val_ver ABUT<90 OPPOSITE EXTENDED SN_EN_8a_val_hor)
 y2 = (ENC NACT_inside_SN_v_edges_ov [SN] < SN_EN_8a_val_hor ABUT<90 OPPOSITE EXTENDED SN_EN_8a_val_ver) OR EDGE (ENC NACT_inside_SN_h_edges_ov [SN] < SN_EN_8a_val_ver ABUT<90 OPPOSITE EXTENDED SN_EN_8a_val_hor)
 y3 = ENC nact_convex_corner_ov sn_convex_corner < SN_EN_8a_val_hor ABUT<90 OPPOSITE EXTENDED SN_EN_8a_val_hor
 y4 = ENC nact_concave_corner_ov sn_concave_corner < SN_EN_8a_val_hor ABUT<90 OPPOSITE EXTENDED SN_EN_8a_val_hor
 err1_a = INT y1 < 0.001 ABUT==90 INTERSECTING ONLY
 err1_b = INT y2 < 0.001 ABUT==90 INTERSECTING ONLY
 err2_a = EXT y1 < 0.001 ABUT==90 INTERSECTING ONLY
 err2_b = EXT y2 < 0.001 ABUT==90 INTERSECTING ONLY

 err1_c = DFM PROPERTY y3 err1_a err1_b ABUT ALSO OVERLAP MULTI [-= (count(err1_a) > 0 && count(err1_b) > 0) ? 1 : 0] > 0
 err2_c = DFM PROPERTY y4 err2_a err2_b ABUT ALSO OVERLAP MULTI [-= (count(err2_a) > 0 && count(err2_b) > 0) ? 1 : 0] > 0
 err1 = DFM COPY err1_c REGION
 err2 = DFM COPY err2_c REGION
 err1 NOT INSIDE INST_DIOMK2
 err2 NOT INSIDE INST_DIOMK2
}

SN_EN_9 {
@ SN line-end (vertical width <= 0.296um between two consecutive 90-90 degree corners with both sides length >= 0.09um) enclosure of AA (AA vertical edge extend 1/2 GT width) in S/D direction, except INST region >= 0.079um
 chk_sn = CONVEX EDGE SN ANGLE1 == 90 LENGTH1 >= 0.09 ANGLE2 == 90 LENGTH2 >= 0.09 WITH LENGTH <= 0.296
 err1 = ENC edge_gate_AA_all_v_edges chk_sn < 0.079 ABUT<90 OPPOSITE REGION EXCLUDE SHIELDED
 err1 NOT INSIDE INST
}

SN_EX_1 {
@ SN extension outside of NMOS GATE for core region (Extension <= 0um is not allowed), except MARKS and INST regions >= 0.048um
 err1 = ENC (GATE_CORE AND SN) SN < 0.048 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE MARKS_INST
}

SN_EX_2 {
@ SN extension outside of NMOS GATE for I/O region (Extension <= 0um is not allowed), except DIOMK2 region >= 0.096um
 err1 = ENC (GATE_IO AND SN) SN < 0.096 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE DIOMK2
}

SN_A_1a {
@ SN area, except INST region >= 0.087um2
 err1 = AREA SN < SN_MiniArea
 err1 NOT INSIDE INST
}

NW_PSUB_VARMOS_DMPNP = OR NW PSUB VARMOS DMPNP
NW_not_PSUB_VARMOS_DMPNP = ((NW NOT PSUB) OR VARMOS) OR DMPNP

SN_A_1b {
@ SN area, >= 0.087um2
@ (((((SN NOT DG) NOT (((NW OR PSUB) OR VARMOS) OR DMPNP)) su 0.095um) sd 0.19um) su 0.095um)
@ (((((SN AND DG) NOT (((NW NOT PSUB) OR VARMOS) OR DMPNP)) su 0.095um) sd 0.19um) su 0.095um)
 STEP_1a = SIZE ((SN NOT DG) NOT NW_PSUB_VARMOS_DMPNP) BY 0.095
 STEP_2a = SIZE (SIZE STEP_1a BY -0.190) BY 0.095
 err1 = AREA STEP_2a < SN_MiniArea
 err1 NOT INSIDE SealR_NOT_BULK

 STEP_1b = SIZE ((SN AND DG) NOT NW_not_PSUB_VARMOS_DMPNP) BY 0.095
 STEP_2b = SIZE (SIZE STEP_1b BY -0.190) BY 0.095
 err2 = AREA STEP_2b < SN_MiniArea
 err2 NOT INSIDE SealR_NOT_BULK
}

SN_A_2a {
@ SN enclosed area, except INST region >= 0.087um2
 err1 = AREA ((HOLES SN INNER) NOT SN) < SN_MiniArea
 err1 NOT INSIDE INST
}

SN_A_2b {
@ SN enclosed area, except INST region >= 0.087um2
@ (((((SN NOT DG) NOT (((NW OR PSUB) OR VARMOS) OR DMPNP)) su 0.095um) sd 0.19um) su 0.095um),
@ (((((SN AND DG) NOT (((NW NOT PSUB) OR VARMOS) OR DMPNP)) su 0.095um) sd 0.19um) su 0.095um)
 STEP_1a = SIZE ((SN NOT DG) NOT NW_PSUB_VARMOS_DMPNP) BY 0.095
 STEP_2a = SIZE (SIZE STEP_1a BY -0.190) BY 0.095
 STEP_3a = (HOLES STEP_2a INNER) NOT SN
 err1 = AREA STEP_3a < SN_MiniArea
 err1 NOT INSIDE INST

 STEP_1b = SIZE ((SN AND DG) NOT NW_not_PSUB_VARMOS_DMPNP) BY 0.095
 STEP_2b = SIZE (SIZE STEP_1b BY -0.190) BY 0.095
 STEP_3b = (HOLES STEP_2b INNER) NOT SN
 err2 = AREA STEP_3b < SN_MiniArea
 err2 NOT INSIDE INST
}

SN_R_1 {
@ SP and SN interact the same ALL_AA is not allowed, except DIOMK2 region
 err1 = (ALL_AA INTERACT SN) INTERACT SP
 err1 NOT INSIDE DIOMK2  //; please refer GATED.R.4
}

SN_R_2 {
@ SN and SP overlap is not allowed
 err1 = AND SN SP
 err1 NOT INSIDE SealR_NOT_BULK
}





// =======================================================
// SP: P+ source/drain implantation design rules
// =======================================================

GROUP GSP SP_?

SP_W_1 {
@ SP width, except INST region and 45-degree SP in MARKS region >= 0.192um
 err1 = INT (SP NOT INSIDE MARKS) < SP_MiniWidth ABUT<90 SINGULAR REGION
 err2 = INT (SP NOT OUTSIDE MARKS) < SP_MiniWidth SINGULAR REGION ANGLED == 0
 err1 NOT INSIDE MARKS_INST
 err2 NOT OUTSIDE MARKS
}

SP_S_1 {
@ SP space, except INST region >= 0.192um
 err1 = EXT SP < 0.192 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE INST
}

VARIABLE SP_S_2_val 0.248
VARIABLE SP_S_2_PRL 0.255-GLOBAL_TOLERANCE

SP_S_2 {
@ Space between SP in S/D direction when PRL >= 0.255um. >= 0.248um
 nw_err_RAW = ANGLE (EXT [SP] < SP_S_2_val ABUT<90 OPPOSITE) > 88 <= 90
 nw_jog_ALL = (CONVEX EDGE SP == 1) NOT COIN EDGE nw_err_RAW
 nw_jog_EXP_a = EXPAND EDGE nw_jog_ALL INSIDE BY 0.0005
 nw_jog_EXP_b = EXPAND EDGE nw_jog_ALL OUTSIDE BY 0.0005
 nw_jog_TMP = (nw_jog_ALL COIN EDGE (nw_jog_EXP_a WITH EDGE nw_err_RAW)) COIN EDGE (nw_jog_EXP_b WITH EDGE nw_err_RAW)
 nw_jog_EXP = ((VERTEX (EXPAND EDGE nw_jog_TMP OUTSIDE BY 0.001 EXTEND BY 0.001) == 4) OR (EXPAND EDGE nw_err_RAW OUTSIDE BY 0.001)) NOT SP
 nw_err_PRL = DFM PROPERTY nw_jog_EXP nw_err_RAW OVERLAP ABUT ALSO MULTI [-= LENGTH(nw_err_RAW)] > SP_S_2_PRL
 err1 = EXT (nw_err_RAW TOUCH EDGE nw_err_PRL) SP < SP_S_2_val ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

VARIABLE SP_S_3_val 0.224
VARIABLE SP_S_3_PRL 0.352

SP_S_3 {
@ SP space on STI if PRL >= 0.352um. >= 0.224um
@ except:
@ 1) SP space to ALL_AA < 0.082um in GATE poly direction
@ 2) SP space to ALL_AA < 0.109um in S/D direction
@ 3) GT_P96 and INST regions
 ERRS_all_RAW = EXT SP < SP_S_3_val ABUT<90 OPPOSITE REGION
 ERRS_all_TMP = ERRS_all_RAW ENCLOSE RECTANGLE 0.001 SP_S_3_PRL ORTHOGONAL ONLY
 waive_v_AREA = EXT ALL_AA_h_edges (SP INTERACT ERRS_all_TMP) < 0.082 ABUT<90 OPPOSITE REGION
 waive_h_AREA = EXT ALL_AA_v_edges (SP INTERACT ERRS_all_TMP) < 0.109 ABUT<90 OPPOSITE REGION

 err1_RAW = (ERRS_all_TMP NOT ALL_AA) NOT (OR waive_v_AREA waive_h_AREA)
 err1_TMP = err1_RAW ENCLOSE RECTANGLE 0.001 SP_S_3_PRL ORTHOGONAL ONLY
 err1 = err1_TMP NOT INSIDE GT_P96
 err1 NOT INSIDE INST
}

VARIABLE SP_S_4_val 0.224
VARIABLE SP_S_4_PRL 0.386

SP_S_4 {
@ SP space on STI if PRL >= 0.386um in GT_P96 region >= 0.224um
@ except:
@ 1) SP space to ALL_AA < 0.082um in GATE poly direction
@ 2) SP space to ALL_AA < 0.112um in S/D direction
 ERRS_all_RAW = EXT SP < SP_S_4_val ABUT<90 OPPOSITE REGION
 ERRS_all_TMP = ERRS_all_RAW ENCLOSE RECTANGLE 0.001 SP_S_4_PRL ORTHOGONAL ONLY
 waive_v_AREA = EXT ALL_AA_h_edges (SP INTERACT ERRS_all_TMP) < 0.082 ABUT<90 OPPOSITE REGION
 waive_h_AREA = EXT ALL_AA_v_edges (SP INTERACT ERRS_all_TMP) < 0.112 ABUT<90 OPPOSITE REGION

 err1_RAW = (ERRS_all_TMP NOT ALL_AA) NOT (OR waive_v_AREA waive_h_AREA)
 err1_TMP = err1_RAW ENCLOSE RECTANGLE 0.001 SP_S_4_PRL ORTHOGONAL ONLY
 err1 = err1_TMP NOT OUTSIDE GT_P96
 err1 NOT INSIDE SealR_NOT_BULK
}

SP_in_GT_P96 = SP NOT OUTSIDE GT_P96
STI_not_SP = CHIP_NOT_ALL_AA NOT SP
STI_not_SP_GT_P96 = STI_not_SP NOT INSIDE GT_P96

SP_S_5 {
@ Space between SP and N+AA, except INST and DIOMK2 region >= 0.048um
 err1 = EXT SP NACT < 0.048 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE INST_DIOMK2
}

SP_S_5a {
@ Space between SP and N+AA (AA vertical edge extend 1/2 GT width) in S/D direction, except INST and DIOMK2 region >= 0.065um
 err1 = EXT SP_v_edges edge_gate_AA_nact < 0.065 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE INST_DIOMK2
}

SP_S_6 {
@ Space between SP and N+ pick-up AA, except INST and DIOMK2 region >= 0.048um
 err1 = EXT SP NTAPi_RAW < 0.048 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE INST_DIOMK2
}

SP_S_6a {
@ Space between SP and N+ pick-up AA (AA vertical edge extend 1/2 GT width) in S/D direction, except INST and DIOMK2 region >= 0.065um
 err1 = EXT SP_v_edges edge_gate_AA_ntap < 0.065 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE INST_DIOMK2
}

SP_S_7 {
@ Space between SP and DOP_AA (DOP_AA CUT SP is not allowed) >= 0.048um
 err1 = EXT DOP_AA SP < 0.048 ABUT<90 SINGULAR REGION
 err2 = SP INSIDE EDGE (DOP_AA CUT SP)

 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE EDGE SealR_NOT_BULK
}

SP_S_7a {
@ Space between SP and DOP_AA (AA vertical edge extend 1/2 GT width) in S/D direction (DOP_AA CUT SP is not allowed) >= 0.065um
 err1 = EXT edge_gate_dopAA_all SP_v_edges < 0.065 ABUT<90 OPPOSITE REGION
 err2 = SP INSIDE EDGE (edge_gate_dopAA_all CUT SP)

 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE EDGE SealR_NOT_BULK
}

VARIABLE SP_S_8_val_ver 0.061
VARIABLE SP_S_8_val_hor 0.087

SP_S_8 {
@ Space between SP and N+AA in GATE poly direction when space in S/D direction < 0.087um at each SP corner, except INST and DIOMK2 region >= 0.061um
 y1 = (EXT [NACT_outside_SP_v_edges] SP < SP_S_8_val_hor ABUT<90 OPPOSITE EXTENDED 0.061) OR EDGE (EXT [NACT_outside_SP_h_edges] SP < 0.061 ABUT<90 OPPOSITE EXTENDED SP_S_8_val_hor)
 y2 = (EXT NACT_outside_SP_v_edges [SP] < SP_S_8_val_hor ABUT<90 OPPOSITE EXTENDED 0.061) OR EDGE (EXT NACT_outside_SP_h_edges [SP] < 0.061 ABUT<90 OPPOSITE EXTENDED SP_S_8_val_hor)
 y3 = EXT nact_convex_corner sp_concave_corner < SP_S_8_val_hor ABUT<90 OPPOSITE EXTENDED SP_S_8_val_hor
 y4 = EXT nact_concave_corner sp_convex_corner < SP_S_8_val_hor ABUT<90 OPPOSITE EXTENDED SP_S_8_val_hor
 err1_a = INT y1 < 0.001 ABUT==90 INTERSECTING ONLY
 err1_b = EXT y2 < 0.001 ABUT==90 INTERSECTING ONLY
 err2_a = INT y2 < 0.001 ABUT==90 INTERSECTING ONLY
 err2_b = EXT y1 < 0.001 ABUT==90 INTERSECTING ONLY

 err1_c = DFM PROPERTY y3 err1_a err1_b ABUT ALSO OVERLAP MULTI [-= (count(err1_a) > 0 && count(err1_b) > 0) ? 1 : 0] > 0
 err2_c = DFM PROPERTY y4 err2_a err2_b ABUT ALSO OVERLAP MULTI [-= (count(err2_a) > 0 && count(err2_b) > 0) ? 1 : 0] > 0
 err1 = DFM COPY err1_c REGION
 err2 = DFM COPY err2_c REGION
 err1 NOT INSIDE INST_DIOMK2
 err2 NOT INSIDE INST_DIOMK2
}

VARIABLE SP_S_8a_val_ver 0.061
VARIABLE SP_S_8a_val_hor 0.079

SP_S_8a {
@ Space between SP and N+AA (AA vertical edge extend 1/2 GT width) in S/D direction when space in GATE poly direction < 0.061um at each SP corner, except INST and DIOMK2 region >= 0.079um
 y1 = (EXT [NACT_outside_SP_v_edges_ov] SP < SP_S_8a_val_hor ABUT<90 OPPOSITE EXTENDED SP_S_8a_val_ver) OR EDGE (EXT [NACT_outside_SP_h_edges_ov] SP < SP_S_8a_val_ver ABUT<90 OPPOSITE EXTENDED SP_S_8a_val_hor)
 y2 = (EXT NACT_outside_SP_v_edges_ov [SP] < SP_S_8a_val_hor ABUT<90 OPPOSITE EXTENDED SP_S_8a_val_ver) OR EDGE (EXT NACT_outside_SP_h_edges_ov [SP] < SP_S_8a_val_ver ABUT<90 OPPOSITE EXTENDED SP_S_8a_val_hor)
 y3 = EXT nact_convex_corner_ov sp_concave_corner < SP_S_8a_val_hor ABUT<90 OPPOSITE EXTENDED SP_S_8a_val_hor
 y4 = EXT nact_concave_corner_ov sp_convex_corner < SP_S_8a_val_hor ABUT<90 OPPOSITE EXTENDED SP_S_8a_val_hor
 err1_a = INT y1 < 0.001 ABUT==90 INTERSECTING ONLY
 err1_b = EXT y2 < 0.001 ABUT==90 INTERSECTING ONLY
 err2_a = INT y2 < 0.001 ABUT==90 INTERSECTING ONLY
 err2_b = EXT y1 < 0.001 ABUT==90 INTERSECTING ONLY

 err1_c = DFM PROPERTY y3 err1_a err1_b ABUT ALSO OVERLAP MULTI [-= (count(err1_a) > 0 && count(err1_b) > 0) ? 1 : 0] > 0
 err2_c = DFM PROPERTY y4 err2_a err2_b ABUT ALSO OVERLAP MULTI [-= (count(err2_a) > 0 && count(err2_b) > 0) ? 1 : 0] > 0
 err1 = DFM COPY err1_c REGION
 err2 = DFM COPY err2_c REGION
 err1 NOT INSIDE INST_DIOMK2
 err2 NOT INSIDE INST_DIOMK2
}

SP_S_9 {
@ Space between SP vertical edge (edge length <= 0.296um between two concave corners with both sides length >= 0.09um) and AA (AA vertical edge extend 1/2 GT width) in S/D direction >= 0.079um
 EDG_RAW = CONVEX EDGE SP ANGLE1 == 270 LENGTH1 >= 0.09 ANGLE2 == 270 LENGTH2 >= 0.09 WITH LENGTH <= 0.296
 EDG_CHK = ANGLE EDG_RAW == 90
 err1 = EXT EDG_CHK edge_gate_AA_all < 0.079 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

#IFDEF DFM_RULES_PRIORITY_1 YES
SP_S_10_DFM1 {
@ For PMOS, Channel length <= 24nm:
@ Fin number <= 4, (SA = SB) <= 0.096um, suggest N/P boundary space to AA space >= 80nm
 SASB_96 = ((PACT ENCLOSE PGATE) INTERACT GATE_raw == 3) ENCLOSE TRGATE_LE_LT_24
 PMOS_SP = (SP ENCLOSE (SASB_96 INTERACT FIN <= 4)) COIN EDGE SN
 err1 = OR (EXT PMOS_SP NAA < 0.08 ABUT<90 REGION) (ENC SASB_96 PMOS_SP < 0.08 ABUT<90 REGION)
 err1 NOT INSIDE SealR_NOT_BULK
}
#ENDIF

SP_EN_5 {
@ SP enclosure of P+AA, except INST and DIOMK2 region >= 0.048um
 err1 = ENC PACT SP < 0.048 ABUT<90 REGION
 err1 NOT INSIDE INST_DIOMK2
}

SP_EN_5a {
@ SP enclosure of P+AA (AA vertical edge extend 1/2 GT width) in S/D direction, except INST and DIOMK2 region >= 0.065um
 err1 = ENC edge_gate_AA_pact SP_v_edges < 0.065 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE INST_DIOMK2
}

SP_EN_6 {
@ SP enclosure of P+ pick-up AA, except MARKS, INST and DIOMK2 regions >= 0.048um
 err1 = ENC PTAP_RAW SP < 0.048 ABUT<90 REGION
 err1 NOT INSIDE (OR MARKS_INST DIOMK2)
}

SP_EN_6a {
@ SP enclosure of P+ pick-up AA (AA vertical edge extend 1/2 GT width) in S/D direction, except INST and DIOMK2 region >= 0.065um
 err1 = ENC edge_gate_AA_ptap SP_v_edges < 0.065 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE INST_DIOMK2
}

SP_EN_7 {
@ SP enclosure of DOP_AA >= 0.048um
 err1 = ENC DOP_AA SP < 0.048 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

SP_EN_7a {
@ SP enclosure of DOP_AA (AA vertical edge extend 1/2 GT width) in S/D direction >= 0.065um
 err1 = ENC (edge_gate_dopAA_all AND SP) SP_v_edges < 0.065 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

VARIABLE SP_EN_8_val_ver 0.061
VARIABLE SP_EN_8_val_hor 0.087

SP_EN_8 {
@ SP enclosure of P+AA in GATE poly direction when enclosure in S/D direction < 0.087um at each SP corner, except INST and DIOMK2 region >= 0.061um
 y1 = (ENC [PACT_inside_SP_v_edges] SP < SP_EN_8_val_hor ABUT<90 OPPOSITE EXTENDED SP_EN_8_val_ver) OR EDGE (ENC [PACT_inside_SP_h_edges] SP < SP_EN_8_val_ver ABUT<90 OPPOSITE EXTENDED SP_EN_8_val_hor)
 y2 = (ENC PACT_inside_SP_v_edges [SP] < SP_EN_8_val_hor ABUT<90 OPPOSITE EXTENDED SP_EN_8_val_ver) OR EDGE (ENC PACT_inside_SP_h_edges [SP] < SP_EN_8_val_ver ABUT<90 OPPOSITE EXTENDED SP_EN_8_val_hor)
 y3 = ENC pact_convex_corner sp_convex_corner < SP_EN_8_val_hor ABUT<90 OPPOSITE EXTENDED SP_EN_8_val_hor
 y4 = ENC pact_concave_corner sp_concave_corner < SP_EN_8_val_hor ABUT<90 OPPOSITE EXTENDED SP_EN_8_val_hor
 err1_a = INT y1 < 0.001 ABUT==90 INTERSECTING ONLY
 err1_b = INT y2 < 0.001 ABUT==90 INTERSECTING ONLY
 err2_a = EXT y1 < 0.001 ABUT==90 INTERSECTING ONLY
 err2_b = EXT y2 < 0.001 ABUT==90 INTERSECTING ONLY

 err1_c = DFM PROPERTY y3 err1_a err1_b ABUT ALSO OVERLAP MULTI [-= (count(err1_a) > 0 && count(err1_b) > 0) ? 1 : 0] > 0
 err2_c = DFM PROPERTY y4 err2_a err2_b ABUT ALSO OVERLAP MULTI [-= (count(err2_a) > 0 && count(err2_b) > 0) ? 1 : 0] > 0
 err1 = DFM COPY err1_c REGION
 err2 = DFM COPY err2_c REGION
 err1 NOT INSIDE INST_DIOMK2
 err2 NOT INSIDE INST_DIOMK2
}

VARIABLE SP_EN_8a_val_ver 0.061
VARIABLE SP_EN_8a_val_hor 0.079

SP_EN_8a {
@ SP enclosure of P+AA (AA vertical edge extend 1/2 GT width) in S/D direction when enclosure in GATE poly direction < 0.061um at each SP corner, except INST and DIOMK2 region >= 0.079um
 y1 = (ENC [PACT_inside_SP_v_edges_ov] SP < SP_EN_8a_val_hor ABUT<90 OPPOSITE EXTENDED SP_EN_8a_val_ver) OR EDGE (ENC [PACT_inside_SP_h_edges_ov] SP < SP_EN_8a_val_ver ABUT<90 OPPOSITE EXTENDED SP_EN_8a_val_hor)
 y2 = (ENC PACT_inside_SP_v_edges_ov [SP] < SP_EN_8a_val_hor ABUT<90 OPPOSITE EXTENDED SP_EN_8a_val_ver) OR EDGE (ENC PACT_inside_SP_h_edges_ov [SP] < SP_EN_8a_val_ver ABUT<90 OPPOSITE EXTENDED SP_EN_8a_val_hor)
 y3 = ENC pact_convex_corner_ov sp_convex_corner < SP_EN_8a_val_hor ABUT<90 OPPOSITE EXTENDED SP_EN_8a_val_hor
 y4 = ENC pact_concave_corner_ov sp_concave_corner < SP_EN_8a_val_hor ABUT<90 OPPOSITE EXTENDED SP_EN_8a_val_hor
 err1_a = INT y1 < 0.001 ABUT==90 INTERSECTING ONLY
 err1_b = INT y2 < 0.001 ABUT==90 INTERSECTING ONLY
 err2_a = EXT y1 < 0.001 ABUT==90 INTERSECTING ONLY
 err2_b = EXT y2 < 0.001 ABUT==90 INTERSECTING ONLY

 err1_c = DFM PROPERTY y3 err1_a err1_b ABUT ALSO OVERLAP MULTI [-= (count(err1_a) > 0 && count(err1_b) > 0) ? 1 : 0] > 0
 err2_c = DFM PROPERTY y4 err2_a err2_b ABUT ALSO OVERLAP MULTI [-= (count(err2_a) > 0 && count(err2_b) > 0) ? 1 : 0] > 0
 err1 = DFM COPY err1_c REGION
 err2 = DFM COPY err2_c REGION
 err1 NOT INSIDE INST_DIOMK2
 err2 NOT INSIDE INST_DIOMK2
}

SP_EN_9 {
@ SP line-end (vertical width <= 0.296um between two consecutive 90-90 degree corners with both sides length >= 0.09um) enclosure of AA (AA vertical edge extend 1/2 GT width) in S/D direction, except INST region >= 0.079um
 chk_sp = CONVEX EDGE SP ANGLE1 == 90 LENGTH1 >= 0.09 ANGLE2 == 90 LENGTH2 >= 0.09 WITH LENGTH <= 0.296
 err1 = ENC edge_gate_AA_all_v_edges chk_sp < 0.079 ABUT<90 OPPOSITE REGION EXCLUDE SHIELDED
 err1 NOT INSIDE INST
}

SP_EX_1 {
@ SP extension outside of PMOS GATE for core region (Extension <= 0um is not allowed), except MARKS and INST regions >= 0.048um
 err1 = ENC (GATE_CORE AND SP) SP < 0.048 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE MARKS_INST
}

SP_EX_2 {
@ SP extension outside of PMOS GATE for I/O region (Extension <= 0um is not allowed), except DIOMK2 region >= 0.096um
 err1 = ENC (GATE_IO AND SP) SP < 0.096 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE DIOMK2
}

SP_A_1a {
@ SP area, except INST region >= 0.087um2
 err1 = AREA SP < SP_MiniArea
 err1 NOT INSIDE INST
}

SP_A_1b {
@ SP area, >= 0.087um2
@ (((((SP NOT ((DG OR VARMOS) OR DMPNP)) AND NW) su 0.095um) sd 0.19um) su 0.095um)
@ ((((((SP AND DG) AND NW) NOT (VARMOS OR DMPNP)) su 0.095um) sd 0.19um) su 0.095um)
 STEP_1a = SIZE ((SP NOT (OR DG VARMOS DMPNP)) AND NW) BY 0.095
 STEP_2a = SIZE (SIZE STEP_1a BY -0.190) BY 0.095
 err1 = AREA STEP_2a < SP_MiniArea
 err1 NOT INSIDE SealR_NOT_BULK

 STEP_1b = SIZE (((SP AND DG) AND NW) NOT (OR VARMOS DMPNP)) BY 0.095
 STEP_2b = SIZE (SIZE STEP_1b BY -0.190) BY 0.095
 err2 = AREA STEP_2b < SP_MiniArea
 err2 NOT INSIDE SealR_NOT_BULK
}

SP_A_2a {
@ SP enclosed area >= 0.087um2
 err1 = AREA ((HOLES SP INNER) NOT SP) < SP_MiniArea
 err1 NOT INSIDE SealR_NOT_BULK
}

SP_A_2b {
@ SP enclosed area, >= 0.087um2
@ (((((SP NOT ((DG OR VARMOS) OR DMPNP)) AND NW) su 0.095um) sd 0.19um) su 0.095um)
@ ((((((SP AND DG) AND NW) NOT (VARMOS OR DMPNP)) su 0.095um) sd 0.19um) su 0.095um)
 STEP_1a = SIZE (SIZE ((SP NOT (OR DG VARMOS DMPNP)) AND NW) BY 0.095) BY -0.190
 STEP_2a = SIZE STEP_1a BY 0.095
 STEP_3a = (HOLES STEP_2a INNER) NOT SP
 err1 = AREA STEP_3a < SP_MiniArea
 err1 NOT INSIDE SealR_NOT_BULK

 STEP_1b = SIZE (SIZE (((SP AND DG) AND NW) NOT (VARMOS OR DMPNP)) BY 0.095) BY -0.190
 STEP_2b = SIZE STEP_1b BY 0.095
 STEP_3b = (HOLES STEP_2b INNER) NOT SP
 err2 = AREA STEP_3b < SP_MiniArea
 err2 NOT INSIDE SealR_NOT_BULK
}




#IFDEF IP_LEVEL_DENSITY_CHECK YES
#IFDEF MINIMUM_DENSITY_CHECK YES
// =======================================================
// Strained S/D design rules
// =======================================================

GROUP GSSD SSD_?

SSD_DN_1_LowRatio {
@ PSR open ratio should be as uniform as possible over the chip >= 5.8%
@ PSR open ratio definition: (((((((((SP - INST) - PSRBL) su 0.095) sd 0.19) su 0.095) + (((((SP * INST) - PSRBL) su 0.086) sd 0.172) su 0.086)) + SPDUM) * ALL_AA) - ALL_GT) density across full chip
 STEP_1 = (SP NOT INST) NOT PSRBL
 STEP_2 = SIZE (SIZE (SIZE STEP_1 BY 0.095) BY -0.190) BY 0.095  //; (((((SP-INST)-PSRBL) su 0.095) sd 0.19) su 0.095)
 STEP_3 = (SP AND INST) NOT PSRBL
 STEP_4 = SIZE (SIZE (SIZE STEP_3 BY 0.086) BY -0.172) BY 0.086  //; (((((SP*INST)-PSRBL) su 0.086) sd 0.172) su 0.086)
 STEP_5 = (STEP_2 OR STEP_4) OR SPDUM
 STEP_6 = (STEP_5 AND ALL_AA) NOT ALL_GT

 check_pattern = STEP_6 NOT MARKS
 DENSITY check_pattern CHIP_NOT_MARKS [AREA(check_pattern)/AREA(CHIP_NOT_MARKS)] < 0.058 PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_SSD_DN_1_LowRatio.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_SSD_DN_1_LowRatio.rdb"
}

SSD_DN_1_HighRatio {
@ PSR open ratio should be as uniform as possible over the chip <= 18%
@ PSR open ratio definition: (((((((((SP - INST) - PSRBL) su 0.095) sd 0.19) su 0.095) + (((((SP * INST) - PSRBL) su 0.086) sd 0.172) su 0.086)) + SPDUM) * ALL_AA) - ALL_GT) density across full chip
 STEP_1 = (SP NOT INST) NOT PSRBL
 STEP_2 = SIZE (SIZE (SIZE STEP_1 BY 0.095) BY -0.190) BY 0.095  //; (((((SP-INST)-PSRBL) su 0.095) sd 0.19) su 0.095)
 STEP_3 = (SP AND INST) NOT PSRBL
 STEP_4 = SIZE (SIZE (SIZE STEP_3 BY 0.086) BY -0.172) BY 0.086  //; (((((SP*INST)-PSRBL) su 0.086) sd 0.172) su 0.086)
 STEP_5 = (STEP_2 OR STEP_4) OR SPDUM
 STEP_6 = (STEP_5 AND ALL_AA) NOT ALL_GT

 check_pattern = STEP_6 NOT MARKS
 DENSITY check_pattern CHIP_NOT_MARKS [AREA(check_pattern)/AREA(CHIP_NOT_MARKS)] > 0.18 PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_SSD_DN_1_HighRatio.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_SSD_DN_1_HighRatio.rdb"
}

SSD_DN_2_LowRatio {
@ NSR open ratio should be as uniform as possible over the chip >= 5.8%
@ NSR open ratio definition: (((((((((((!SP) - RESNW) - NSRBL) - INST) su 0.095) sd 0.19) su 0.095) + ((((((!SP) * INST) - NSRBL) su 0.086) sd 0.172) su 0.086)) - SPDUM) * ALL_AA) - ALL_GT) density across full chip
 chip_not_sp = DRC:1 NOT SP
 STEP_1 = ((chip_not_sp NOT RESNW) NOT NSRBL) NOT INST
 STEP_2 = SIZE (SIZE (SIZE STEP_1 BY 0.095) BY -0.190) BY 0.095  //; (((((((!SP)-RESNW)-NSRBL)-INST) su 0.095) sd 0.19) su 0.095)
 STEP_3 = (chip_not_sp AND INST) NOT NSRBL
 STEP_4 = SIZE (SIZE (SIZE STEP_3 BY 0.086) BY -0.172) BY 0.086
 STEP_5 = (STEP_2 OR STEP_4) NOT SPDUM
 STEP_6 = (STEP_5 AND ALL_AA) NOT ALL_GT

 check_pattern = STEP_6 NOT MARKS
 DENSITY check_pattern CHIP_NOT_MARKS [AREA(check_pattern)/AREA(CHIP_NOT_MARKS)] < 0.058 PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_SSD_DN_2_LowRatio.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_SSD_DN_2_LowRatio.rdb"
}

SSD_DN_2_HighRatio {
@ NSR open ratio should be as uniform as possible over the chip <= 18%
@ NSR open ratio definition: (((((((((((!SP) - RESNW) - NSRBL) - INST) su 0.095) sd 0.19) su 0.095) + ((((((!SP) * INST) - NSRBL) su 0.086) sd 0.172) su 0.086)) - SPDUM) * ALL_AA) - ALL_GT) density across full chip
 chip_not_sp = DRC:1 NOT SP
 STEP_1 = ((chip_not_sp NOT RESNW) NOT NSRBL) NOT INST
 STEP_2 = SIZE (SIZE (SIZE STEP_1 BY 0.095) BY -0.190) BY 0.095  //; (((((((!SP)-RESNW)-NSRBL)-INST) su 0.095) sd 0.19) su 0.095)
 STEP_3 = (chip_not_sp AND INST) NOT NSRBL
 STEP_4 = SIZE (SIZE (SIZE STEP_3 BY 0.086) BY -0.172) BY 0.086
 STEP_5 = (STEP_2 OR STEP_4) NOT SPDUM
 STEP_6 = (STEP_5 AND ALL_AA) NOT ALL_GT

 check_pattern = STEP_6 NOT MARKS
 DENSITY check_pattern CHIP_NOT_MARKS [AREA(check_pattern)/AREA(CHIP_NOT_MARKS)] > 0.18 PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_SSD_DN_2_HighRatio.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_SSD_DN_2_HighRatio.rdb"
}
#ENDIF

#ELSE

#IFDEF MINIMUM_DENSITY_CHECK YES
// =======================================================
// Strained S/D design rules
// =======================================================

GROUP GSSD SSD_?

SSD_DN_1_LowRatio {
@ PSR open ratio should be as uniform as possible over the chip >= 5.8%
@ PSR open ratio definition: (((((((((SP - INST) - PSRBL) su 0.095) sd 0.19) su 0.095) + (((((SP * INST) - PSRBL) su 0.086) sd 0.172) su 0.086)) + SPDUM) * ALL_AA) - ALL_GT) density across full chip
 STEP_1 = (SP NOT INST) NOT PSRBL
 STEP_2 = SIZE (SIZE (SIZE STEP_1 BY 0.095) BY -0.190) BY 0.095  //; (((((SP-INST)-PSRBL) su 0.095) sd 0.19) su 0.095)
 STEP_3 = (SP AND INST) NOT PSRBL
 STEP_4 = SIZE (SIZE (SIZE STEP_3 BY 0.086) BY -0.172) BY 0.086  //; (((((SP*INST)-PSRBL) su 0.086) sd 0.172) su 0.086)
 STEP_5 = (STEP_2 OR STEP_4) OR SPDUM
 STEP_6 = (STEP_5 AND ALL_AA) NOT ALL_GT

 check_pattern = STEP_6 NOT MARKS
 DENSITY check_pattern CHIP_NOT_MARKS [AREA(check_pattern)/AREA(CHIP_NOT_MARKS)] < 0.058 PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_SSD_DN_1_LowRatio.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_SSD_DN_1_LowRatio.rdb"
}

SSD_DN_1_HighRatio {
@ PSR open ratio should be as uniform as possible over the chip <= 18%
@ PSR open ratio definition: (((((((((SP - INST) - PSRBL) su 0.095) sd 0.19) su 0.095) + (((((SP * INST) - PSRBL) su 0.086) sd 0.172) su 0.086)) + SPDUM) * ALL_AA) - ALL_GT) density across full chip
 STEP_1 = (SP NOT INST) NOT PSRBL
 STEP_2 = SIZE (SIZE (SIZE STEP_1 BY 0.095) BY -0.190) BY 0.095  //; (((((SP-INST)-PSRBL) su 0.095) sd 0.19) su 0.095)
 STEP_3 = (SP AND INST) NOT PSRBL
 STEP_4 = SIZE (SIZE (SIZE STEP_3 BY 0.086) BY -0.172) BY 0.086  //; (((((SP*INST)-PSRBL) su 0.086) sd 0.172) su 0.086)
 STEP_5 = (STEP_2 OR STEP_4) OR SPDUM
 STEP_6 = (STEP_5 AND ALL_AA) NOT ALL_GT

 check_pattern = STEP_6 NOT MARKS
 DENSITY check_pattern CHIP_NOT_MARKS [AREA(check_pattern)/AREA(CHIP_NOT_MARKS)] > 0.18 PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_SSD_DN_1_HighRatio.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_SSD_DN_1_HighRatio.rdb"
}

SSD_DN_2_LowRatio {
@ NSR open ratio should be as uniform as possible over the chip >= 5.8%
@ NSR open ratio definition: (((((((((((!SP) - RESNW) - NSRBL) - INST) su 0.095) sd 0.19) su 0.095) + ((((((!SP) * INST) - NSRBL) su 0.086) sd 0.172) su 0.086)) - SPDUM) * ALL_AA) - ALL_GT) density across full chip
 chip_not_sp = DRC:1 NOT SP
 STEP_1 = ((chip_not_sp NOT RESNW) NOT NSRBL) NOT INST
 STEP_2 = SIZE (SIZE (SIZE STEP_1 BY 0.095) BY -0.190) BY 0.095  //; (((((((!SP)-RESNW)-NSRBL)-INST) su 0.095) sd 0.19) su 0.095)
 STEP_3 = (chip_not_sp AND INST) NOT NSRBL
 STEP_4 = SIZE (SIZE (SIZE STEP_3 BY 0.086) BY -0.172) BY 0.086
 STEP_5 = (STEP_2 OR STEP_4) NOT SPDUM
 STEP_6 = (STEP_5 AND ALL_AA) NOT ALL_GT

 check_pattern = STEP_6 NOT MARKS
 DENSITY check_pattern CHIP_NOT_MARKS [AREA(check_pattern)/AREA(CHIP_NOT_MARKS)] < 0.058 PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_SSD_DN_2_LowRatio.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_SSD_DN_2_LowRatio.rdb"
}

SSD_DN_2_HighRatio {
@ NSR open ratio should be as uniform as possible over the chip <= 18%
@ NSR open ratio definition: (((((((((((!SP) - RESNW) - NSRBL) - INST) su 0.095) sd 0.19) su 0.095) + ((((((!SP) * INST) - NSRBL) su 0.086) sd 0.172) su 0.086)) - SPDUM) * ALL_AA) - ALL_GT) density across full chip
 chip_not_sp = DRC:1 NOT SP
 STEP_1 = ((chip_not_sp NOT RESNW) NOT NSRBL) NOT INST
 STEP_2 = SIZE (SIZE (SIZE STEP_1 BY 0.095) BY -0.190) BY 0.095  //; (((((((!SP)-RESNW)-NSRBL)-INST) su 0.095) sd 0.19) su 0.095)
 STEP_3 = (chip_not_sp AND INST) NOT NSRBL
 STEP_4 = SIZE (SIZE (SIZE STEP_3 BY 0.086) BY -0.172) BY 0.086
 STEP_5 = (STEP_2 OR STEP_4) NOT SPDUM
 STEP_6 = (STEP_5 AND ALL_AA) NOT ALL_GT

 check_pattern = STEP_6 NOT MARKS
 DENSITY check_pattern CHIP_NOT_MARKS [AREA(check_pattern)/AREA(CHIP_NOT_MARKS)] > 0.18 PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_SSD_DN_2_HighRatio.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_SSD_DN_2_HighRatio.rdb"
}
#ENDIF
#ENDIF



// =====================
// M0DMP: M0 dummy rules
// =====================

GROUP GM0DMP M0DMP_?

M0DMP_040 = WITH WIDTH (RECTANGLE M0DMP ORTHOGONAL ONLY) == 0.040
M0DMP_042 = WITH WIDTH (RECTANGLE M0DMP ORTHOGONAL ONLY) == 0.042
M0DMP_054 = WITH WIDTH (RECTANGLE M0DMP ORTHOGONAL ONLY) == 0.054
M0DMP_040_042 = OR M0DMP_040 M0DMP_042

M0DMP_W_1 {
@ M0DMP width = 0.04, 0.042, 0.054um
 err1 = INT M0DMP < 0.001 ABUT<90 SINGULAR REGION
 err2 = M0DMP NOT (OR M0DMP_040 M0DMP_042 M0DMP_054)
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

M0DMP_040_L_edges = INT [M0DMP_040] == 0.040 OPPOSITE
M0DMP_042_L_edges = INT [M0DMP_042] == 0.042 OPPOSITE
M0DMP_054_L_edges = INT [M0DMP_054] == 0.054 OPPOSITE

M0DMP_L_1 {
@ M0DMP length (width = 0.054/0.042um) >= 0.158um
 err1 = LENGTH (OR EDGE M0DMP_042_L_edges M0DMP_054_L_edges) < 0.158
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

M0DMP_L_2 {
@ M0DMP length (width = 0.04um) >= 0.114um
 err1 = LENGTH M0DMP_040_L_edges < 0.114
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

M0DMP_L_3 {
@ Maximum length of (M0DMP (width = 0.04/0.042um) NOT M0CDMP) <= 5.1um
 err1 = LENGTH ((OR EDGE M0DMP_040_L_edges M0DMP_042_L_edges) OUTSIDE EDGE M0CDMP) > 5.1
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

M0DMP_S_1 {
@ Space between M0DMP and AOP_M0 (Overlap with M0 is not allowed) >= 0.05um
 err1 = EXT M0DMP AOP_M0 < 0.05 ABUT<90 SINGULAR REGION
 err2 = M0DMP AND M0
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

M0DMP_S_2 {
@ Space between M0DMP and AOP_GT (M0DMP width = 0.04/0.042um) (Overlap is not allowed) >= 0.015um
 err1 = EXT AOP_GT M0DMP_040_042 < 0.015 ABUT<90 SINGULAR REGION
 err2 = M0DMP AND AOP_GT
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

M0DMP_S_3 {
@ Space between M0DMP and AOP_GT (M0DMP width = 0.054um) (Overlap is not allowed) >= 0.032um
 err1 = EXT AOP_GT M0DMP_054 < 0.032 ABUT<90 SINGULAR REGION
 err2 = M0DMP AND AOP_GT
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

M0DMP_NOT_M0CDUM = M0DMP NOT M0CDUM
M0DMP_NOT_M0CDUM_h_edges = ANGLE M0DMP_NOT_M0CDUM == 0

M0DMP_S_4 {
@ Space between (M0DMP NOT M0CDUM) line-end and AOP_GT (Except AOP_GT jogs <= 0.003um) >= 0.046um
 err1_TMP = EXT [AOP_GT] M0DMP_NOT_M0CDUM_h_edges < 0.046 ABUT<90 MEASURE ALL
 err1 = err1_TMP NOT COIN EDGE AOP_GT_jog_lteq_003
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

M0DMP_S_5 {
@ Space between M0DMP and V0 (Overlap is not allowed) >= 0.039um
 err1 = EXT M0DMP V0 < 0.039 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

M0DMP_S_6 {
@ Space between (M0DMP NOT M0CDUM) and AOP_AA in GATE poly direction (Overlap with AA is not allowed) >= 0.037um
 err1 = EXT M0DMP_NOT_M0CDUM_h_edges AOP_AA_h_edges < 0.037 ABUT<90 OPPOSITE REGION
 err2 = M0DMP_NOT_M0CDUM INTERACT AOP_AA SINGULAR ONLY
 err3 = M0DMP AND AA
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
}

M0DMP_S_7 {
@ Space between M0DMP and AOP_M0G (Overlap with M0G is not allowed) >= 0.039um
 err1 = EXT M0DMP AOP_M0G < 0.039 ABUT<90 SINGULAR REGION MEASURE ALL
 err2 = AND M0DMP M0G
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

M0DMP_A_1 {
@ M0DMP area >= 0.0046um
 err1 = AREA M0DMP < 0.0046
 err1 NOT INSIDE SealR_NOT_BULK
}

M0DMP_R_1 {
@ M0DMP INTERACT M0 is not allowed
 err1 = M0DMP NOT OUTSIDE EDGE M0
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

// =========================
// M0GDMP: M0G dummy rules
// =========================

GROUP GM0GDMP M0GDMP_?

M0GDMP_040 = (RECTANGLE M0GDMP ORTHOGONAL ONLY) WITH WIDTH == 0.040
M0GDMP_050 = (RECTANGLE M0GDMP ORTHOGONAL ONLY) WITH WIDTH == 0.050
M0GDMP_060 = (RECTANGLE M0GDMP ORTHOGONAL ONLY) WITH WIDTH == 0.060

M0GDMP_W_1 {
@ M0GDMP width = 0.04/0.05/0.06um
 err1 = INT M0GDMP < 0.001 ABUT<90 SINGULAR REGION
 err2 = M0GDMP NOT (OR M0GDMP_040 M0GDMP_050 M0GDMP_060)
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

/*
M0GDMP_S_1 {
@ Space between M0GDMP (width = 0.040um) and AOP_M0G (Overlap with M0G is not allowed) >= 0.058um
 err1 = EXT M0GDMP_040 AOP_M0G < 0.058 ABUT<90 SINGULAR REGION
 err2 = AND M0GDMP M0G
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

M0GDMP_S_4 {
@ Center to center space between AOP_M0G (width = 0.050um) (Overlap with M0G is not allowed, Except M0G region) >= 0.105um
 chk_M0G = EXTENTS (AOP_M0G_050 NOT m0g_group) CENTERS 0.0002
 err1 = EXT chk_M0G < 0.105 - 0.0003 ABUT<90 REGION
 err2 = M0GDMP INTERACT (M0G NOT m0g_group) SINGULAR ALSO
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

M0GDMP_060_eq_060_edges = LENGTH M0GDMP_060 == 0.060

M0GDMP_S_5 {
@ Space between M0GDMP (width = 0.060um) to AOP_M0G (Except M0GDMP.S.6, Overlap with M0G is not allowed) >= 0.129um
 waive_S_6 = DFM COPY (EXT M0GDMP_060_eq_060_edges AOP_M0G_050 >= 0.107 < 0.129 ABUT<90 OPPOSITE EXTENDED 0.076) EDGE
 M0G_check_a = M0GDMP_060 NOT COIN EDGE waive_S_6
 M0G_check_b = AOP_M0G NOT COIN EDGE waive_S_6

 err1 = EXT M0G_check_a M0G_check_b < 0.129 ABUT<90 REGION
 err2 = M0GDMP INTERACT M0G SINGULAR ALSO
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

M0GDMP_S_6 {
@ Space between short-side of M0GDMP (width = 0.060um) and AOP_M0G (width = 0.050um, PRL in width direction >= -0.075um) >= 0.106um
 err1 = EXT M0GDMP_060_eq_060_edges AOP_M0G_050 < 0.106 ABUT<90 REGION OPPOSITE EXTENDED 0.076
 err1 NOT INSIDE SealR_NOT_BULK
}

M0GDMP_S_7a {
@ Space between M0GDMP and AOP_AA in GATE poly direction (Overlap with AA is not allowed) >= 0.013um
 err1 = (EXT M0GDMP AOP_AA_h_edges < 0.013 ABUT<90 OPPOSITE REGION) OR (EXT M0GDMP AOP_AA < 0.013 ABUT<90 SINGULAR REGION)
 err2 = AND M0GDMP AA
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

M0GDMP_S_7b {
@ Space between M0GDMP and AOP_AA (Except M0G.S.7a) >= 0.032um
 err1 = EXT M0GDMP_v_edges AOP_AA_v_edges < 0.032 ABUT<90 REGION
 err2 = M0GDMP INTERACT AOP_AA SINGULAR ONLY
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

M0GDMP_S_8 {
@ Space between M0GDMP and AOP_GT (Overlap with GT is not allowed) >= 0.028um
 err1 = EXT M0GDMP AOP_GT < 0.028 ABUT<90 SINGULAR REGION
 err2 = AND M0GDMP GT
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

M0GDMP_S_9 {
@ Space between M0GDMP and AOP_GT (width >= 0.07um) (Overlap with GT is not allowed) >= 0.038um
 err1 = EXT M0GDMP AOP_GT_eqgt_070 < 0.038 ABUT<90 SINGULAR REGION
 err2 = AND M0GDMP GT
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

M0GDMP_S_11 {
@ Space between M0GDMP (width = 0.060um) and AOP_GT (Overlap with GT is not allowed) >= 0.031um
 err1 = EXT M0GDMP_060 AOP_GT < 0.031 ABUT<90 SINGULAR REGION
 err2 = M0GDMP_060 AND GT
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}
*/

M0GDMP_S_1 {
@ Space between M0GDMP and (M0DMP NOT AOP_M0C) (Overlap with M0 is not allowed) >= 0.049um
 err1 = EXT M0GDMP (M0DMP NOT AOP_M0C) < 0.049 ABUT<90 SINGULAR REGION
 err2 = AND M0GDMP M0
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

M0GDMP_S_2 {
@ Space between M0GDMP and V0 (Overlap is not allowed) >= 0.039um
 err1 = EXT M0GDMP V0 < 0.039 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

M0GDMP_S_3 {
@ Space between M0GDMP and M0G >= 0.13um
 err1 = EXT M0GDMP M0G < 0.13 ABUT<90 SINGULAR REGION MEASURE ALL
 err1 NOT INSIDE SealR_NOT_BULK
}

M0GDMP_S_4 {
@ Space between M0GDMP and AA >= 0.07um
 err1 = EXT M0GDMP AA < 0.07 ABUT<90 SINGULAR REGION MEASURE ALL
 err1 NOT INSIDE SealR_NOT_BULK
}

M0GDMP_S_5 {
@ Space between M0GDMP and GT >= 0.055um
 err1 = EXT M0GDMP GT < 0.055 ABUT<90 SINGULAR REGION MEASURE ALL
 err1 NOT INSIDE SealR_NOT_BULK
}

M0GDMP_S_6 {
@ Space between M0GDMP and M0 >= 0.05um
 err1 = EXT M0GDMP M0 < 0.05 ABUT<90 SINGULAR REGION MEASURE ALL
 err1 NOT INSIDE SealR_NOT_BULK
}

/*
M0GDMP_EX_1 {
@ DOP_GT extension outside of M0GDMP in GATE poly direction (at least two opposite sides, extension <=0 is not allowed) >= 0.056um
 err1_TMP = ENC M0GDMP [DOP_GT_h_edges] < 0.056 ABUT<90 OPPOSITE INSIDE ALSO
 err1 = err1_TMP COIN EDGE DOP_GT
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

M0GDMP_040_L_edges = INT [M0GDMP_040] == 0.04 ABUT<90 OPPOSITE
M0GDMP_050_L_edges = INT [M0GDMP_050] == 0.05 ABUT<90 OPPOSITE
M0GDMP_060_L_edges = INT [M0GDMP_060] == 0.06 ABUT<90 OPPOSITE

M0GDMP_L_1 {
@ M0GDMP length (width = 0.04um) = 0.102~0.292um
 err1 = LENGTH (INT [M0GDMP] == 0.040 ABUT<90 OPPOSITE) < 0.102  //;based on M0GDMP.W.1
 err2 = LENGTH M0GDMP_040_L_edges > 0.292
 err1 NOT INSIDE EDGE SealR_NOT_BULK
 err2 NOT INSIDE EDGE SealR_NOT_BULK
}

M0GDMP_L_2 {
@ M0GDMP length (width = 0.05um) = 0.05um
 err1 = LENGTH (INT [M0GDMP] == 0.05 ABUT<90 OPPOSITE) != 0.05  //;based on M0GDMP.W.1
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

M0GDMP_L_3 {
@ M0GDMP length (width = 0.06um) >= 0.198um
 err1 = LENGTH (INT [M0GDMP] == 0.060 ABUT<90 OPPOSITE) < 0.198  //;based on M0GDMP.W.1
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
*/

M0GDMP_R_1 {
@ M0GDMP INTERACT M0G or P2 is not allowed
 err1 = M0GDMP INTERACT (OR P2 M0G)
 err1 NOT INSIDE SealR_NOT_BULK
}

M0GDMP_R_2 {
@ M0GDMP INTERACT AA or GT is not allowed
 err1 = M0GDMP INTERACT AA_OR_GT
 err1 NOT INSIDE SealR_NOT_BULK
}




// =======================================================
// M0: Local interconnect layer 1 design rules
// Contact on AA
// =======================================================

GROUP GM0 M0_?

#IFDEF MANUFACTURABILITY_ENHANCEMENT_RULES YES
M0_S_4_ME {
@ Short side space between AOP_M0 (width = 0.04/0.042um, PRL > -0.05um) except the following conditions and INST region: >= 0.1um
@ Short side space >= 0.086um (length >= 0.23um, either one short side INTERACT M0C (width = 0.054um), short side (NOT INTERACT M0C) space to M0G >= 0.04um)
 M0_L_230 = AOP_M0_040_042 WITH EDGE (LENGTH AOP_M0_040_042 >= 0.23)
 M0_L_230_W_edges = (LENGTH M0_L_230 == 0.04) OR EDGE (LENGTH M0_L_230 == 0.042)
 M0_L_230_W_edges_InM0C = M0_L_230_W_edges INSIDE EDGE M0C_054
 M0_L_230_W_edges_waive = DFM COPY (EXT M0_L_230_W_edges M0_L_230_W_edges_InM0C >= 0.086 < 0.100 ABUT<90 OPPOSITE EXTENDED 0.05) EDGE

 M0_L_230_waive = M0_L_230 WITH EDGE M0_L_230_W_edges_waive
 M0_L_230_waive_W_edges = (M0_L_230_waive COIN EDGE M0_L_230_W_edges) COIN EDGE M0_L_230_W_edges_waive
 M0_L_230_waive_W_edges_NoM0C = M0_L_230_waive_W_edges NOT INSIDE EDGE M0C_054
 M0_L_230_waive_W_edges_NoM0C_to_M0G = EXT [M0_L_230_waive_W_edges_NoM0C] M0G < 0.04 ABUT<90 OPPOSITE
 M0_L_230_waive_W_check = M0_L_230_waive_W_edges_NoM0C NOT TOUCH EDGE M0_L_230_waive_W_edges_NoM0C_to_M0G

 waive_a = EXT [M0_L_230_waive_W_check] M0_L_230_W_edges_InM0C >= 0.086 < 0.100 ABUT<90 OPPOSITE EXTENDED 0.05
 waive_b = EXT M0_L_230_waive_W_check [M0_L_230_W_edges_InM0C] >= 0.086 < 0.100 ABUT<90 OPPOSITE EXTENDED 0.05
 err1_TMP = EXT [AOP_M0_040_042_W_edges] < 0.100 ABUT<90 OPPOSITE EXTENDED 0.05
 err1 = err1_TMP NOT COIN EDGE (waive_a OR EDGE waive_b)
 err1 NOT INSIDE EDGE INST
}
#ENDIF

M0_W_1 {
@ M0 width, except MARKS and OCOVL regions = 0.04, 0.042, 0.054um
//; point touch will be flagged by M0_S_1
 chk_m0 = M0_h_edges OUTSIDE EDGE MARKS_OCOVL
 err1 = LENGTH chk_m0 < M0_MiniWidth  //;based on M0.R.1
 err2 = (LENGTH chk_m0 > M0_MiniWidth < 0.042) OR EDGE (LENGTH chk_m0 > 0.042 < 0.054)  //;based on M0.R.1
 err3 = LENGTH chk_m0 > 0.054
 err1 NOT INSIDE EDGE SealR_NOT_BULK
 err2 NOT INSIDE EDGE SealR_NOT_BULK
 err3 NOT INSIDE EDGE SealR_NOT_BULK
}

M0_W_2 {
@ M0 width in S/D direction when M0 INTERACT (AA INTERACT GT (width >= 0.07um)), except MARKS region = 0.054um
//;based on M0.R.1
 chk_m0 = (M0_h_edges COIN EDGE (M0 INTERACT (AA INTERACT GT_eqgt_070))) NOT INSIDE EDGE MARKS
 err1 = LENGTH chk_m0 < 0.054
 err2 = LENGTH chk_m0 > 0.054
 err1 NOT INSIDE EDGE SealR_NOT_BULK
 err2 NOT INSIDE EDGE SealR_NOT_BULK
}

M0_L_1 {
@ M0 length (width = 0.04um), except (M0 interact TRCMK) and OCOVL region >= 0.114um
 CHK_M0 = M0 NOT INTERACT TRCMK
 err1 = LENGTH (INT [CHK_M0] == 0.04 OPPOSITE) < 0.04
 err2 = LENGTH (M0_040 INTERACT CHK_M0) > 0.04 < 0.114
 err3 = RECTANGLE CHK_M0 ASPECT == 1
 err1 NOT INSIDE EDGE OCOVL
 err2 NOT INSIDE EDGE OCOVL
 err3 NOT INSIDE OCOVL
}

M0_L_1a {
@ M0 length (width = 0.042um), except OCOVL region >= 0.158um
 err1 = LENGTH (INT [M0] == 0.042 OPPOSITE) < 0.042
 err2 = LENGTH M0_042 > 0.042 < 0.158
 err3 = COPY (RECTANGLE M0 ASPECT == 1)
 err1 NOT INSIDE EDGE OCOVL
 err2 NOT INSIDE EDGE OCOVL
 err3 NOT INSIDE OCOVL
}

M0_L_2 {
@ M0 length (width = 0.054um) >= 0.158um
 err1 = LENGTH (INT [M0] == 0.054 OPPOSITE) < 0.054
 err2 = LENGTH M0_054 > 0.054 < 0.158
 err3 = RECTANGLE M0_054 ASPECT == 1
 err1 NOT INSIDE EDGE SealR_NOT_BULK
 err2 NOT INSIDE EDGE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
}

M0_L_3 {
@ M0 length (width = 0.04um, space = 0.063/0.066um) >= 0.158um
 sps_066 = EXT [M0_040] == 0.066 OPPOSITE
 sps_063 = EXT [M0_040] == 0.063 OPPOSITE
 chk_040_M0 = (M0_040 WITH EDGE sps_066) OR (M0_040 WITH EDGE sps_063)

 err1 = LENGTH chk_040_M0 > 0.04 < 0.158
 err2 = RECTANGLE chk_040_M0 ASPECT == 1 ORTHOGONAL ONLY
 err1 NOT INSIDE EDGE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

M0C_M0CDMP_054 = DMP_M0C WITH WIDTH == 0.054
M0C_M0CDMP_052 = DMP_M0C WITH WIDTH == 0.052
AOP_M0_OPP_040 = INT AOP_M0 == 0.04 OPPOSITE REGION
AOP_M0_OPP_040_042 = (INT AOP_M0 == 0.04 OPPOSITE REGION) OR (INT AOP_M0 == 0.042 OPPOSITE REGION)
M0_NOT_M0C_NOT_INTERACT_AA = ((AOP_M0_OPP_040_042 INTERACT M0C_M0CDMP_052) NOT M0C_M0CDMP_052) NOT INTERACT ALL_AA

M0_L_4 {
@ Length of (AOP_M0 NOT (M0C OR M0CDMP)) (AOP_M0 width = 0.04/0.042um), except INST region and ((AOP_M0 (width = 0.04/0.042um) NOT (M0C OR M0CDMP) (width = 0.052um)) NOT INTERACT ALL_AA), except RSPMK1 region >= 0.061um
 waive_area = OR INST RSPMK1
 m0_RAW = (AOP_M0_NOT_M0C AND AOP_M0_OPP_040_042) NOT M0CDMP
 m0_CHK = m0_RAW NOT M0_NOT_M0C_NOT_INTERACT_AA
 m0_EXC = ((EXPAND EDGE (LENGTH (AOP_M0_OPP_040_042 NOT M0C) == M0C_VerSpace_inPowerRail) OUTSIDE BY 0.001) INTERACT M0C == 2) INSIDE RSPMK_ALL  //M0C space = 0.014 is allowed in power rail

 err1 = LENGTH (m0_CHK NOT COIN OUTSIDE EDGE m0_EXC) < 0.04
 err2 = LENGTH (ANGLE m0_CHK == 90) > 0.04 < 0.061
 err3 = RECTANGLE m0_CHK ASPECT == 1
 err1 NOT INSIDE EDGE waive_area
 err2 NOT INSIDE EDGE waive_area
 err3 NOT INSIDE waive_area
}

M0_L_5 {
@ Length of (AOP_M0 NOT AOP_M0C) (AOP_M0 width = 0.04/0.042um) <= 5.1um
 err1 = LENGTH (AOP_M0_NOT_AOP_M0C INTERACT AOP_M0_040_042) > 5.1
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

M0_S_1 {
@ Space between M0 >= 0.05um
 err1 = EXT M0 < 0.05 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

M0_S_2 {
@ Space between M0 (width = 0.04um) and M0 (width = 0.042um) >= 0.192um
 err1 = EXT M0_040 M0_042 < 0.192 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

M0_S_3a {
@ Space between the short side of rectangular AOP_M0 (width = 0.054um) and AOP_M0 when PRL > -0.136um. >= 0.119um
 err1 = EXT AOP_M0_054_W_edges AOP_M0 < 0.119 ABUT<90 OPPOSITE EXTENDED 0.136 REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

M0_S_3b {
@ Space between the long side of rectangular AOP_M0 (width = 0.054um) and AOP_M0 when PRL >= -0.119um. >= 0.134um
 err1 = EXT AOP_M0_054_L_edges AOP_M0 < 0.134 ABUT<90 OPPOSITE EXTENDED 0.119+GLOBAL_TOLERANCE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

M0_S_4 {
@ Space between short side of AOP_M0 (width = 0.04/0.042um, PRL > -0.05um), except: Short side space >= 0.086um (length >= 0.229um, either one short side INTERACT M0C (width = 0.052um), short side (NOT INTERACT M0C) space to M0G >= 0.04um) >= 0.096um
 M0_L_230 = AOP_M0_040_042 WITH EDGE (LENGTH AOP_M0_040_042 >= 0.229)
 M0_L_230_W_edges = (LENGTH M0_L_230 == 0.04) OR EDGE (LENGTH M0_L_230 == 0.042)
 M0_L_230_W_edges_InM0C = M0_L_230_W_edges INSIDE EDGE M0C_052
 M0_L_230_W_edges_waive = DFM COPY (EXT M0_L_230_W_edges M0_L_230_W_edges_InM0C >= 0.086 < 0.096 ABUT<90 OPPOSITE EXTENDED 0.05) EDGE

 M0_L_230_waive = M0_L_230 WITH EDGE M0_L_230_W_edges_waive
 M0_L_230_waive_W_edges = (M0_L_230_waive COIN EDGE M0_L_230_W_edges) COIN EDGE M0_L_230_W_edges_waive
 M0_L_230_waive_W_edges_NoM0C = M0_L_230_waive_W_edges NOT INSIDE EDGE M0C_052
 M0_L_230_waive_W_edges_NoM0C_to_M0G = EXT [M0_L_230_waive_W_edges_NoM0C] M0G < 0.04 ABUT<90 OPPOSITE
 M0_L_230_waive_W_check = M0_L_230_waive_W_edges_NoM0C NOT TOUCH EDGE M0_L_230_waive_W_edges_NoM0C_to_M0G

 waive_a = EXT [M0_L_230_waive_W_check] M0_L_230_W_edges_InM0C >= 0.086 < 0.096 ABUT<90 OPPOSITE EXTENDED 0.05
 waive_b = EXT M0_L_230_waive_W_check [M0_L_230_W_edges_InM0C] >= 0.086 < 0.096 ABUT<90 OPPOSITE EXTENDED 0.05
 err1_TMP = EXT [AOP_M0_040_042_W_edges] < 0.096 ABUT<90 OPPOSITE EXTENDED 0.05
 err1 = err1_TMP NOT COIN EDGE (waive_a OR EDGE waive_b)
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

M0_S_4a {
@ Space between the long side of rectangular AOP_M0 and AOP_M0 (width = 0.04um) when PRL > -0.09um. >= 0.05um
 err1 = EXT AOP_M0_L_edges AOP_M0_040 < 0.05 ABUT<90 OPPOSITE EXTENDED 0.09 REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

M0_S_4b {
@ Space between the long side of rectangular AOP_M0 and AOP_M0 (width = 0.04um) when PRL > -0.096um INSIDE GT_P96 region >= 0.056um
 m0_L_sides = AOP_M0_040 COIN EDGE ALL_M0_L_edges
 m0_L_sides_chk = m0_L_sides NOT OUTSIDE EDGE GT_P96
 err1_TMP = EXT m0_L_sides m0_L_sides_chk < 0.056 ABUT<90 OPPOSITE EXTENDED 0.096 REGION
 err1 = err1_TMP NOT OUTSIDE GT_P96
 err1 NOT INSIDE SealR_NOT_BULK
}

//;M0_S_5a {
//;@ Space between the long side of rectangular AOP_M0 and AOP_M0 (width = 0.042um) when PRL > -0.09um. >= 0.048um
//; err1 = EXT AOP_M0_L_edges AOP_M0_042 < 0.048 ABUT<90 OPPOSITE EXTENDED 0.09 REGION
//; err1 NOT INSIDE SealR_NOT_BULK
//;}

M0_S_5b {
@ Space between the long side of rectangular AOP_M0 and AOP_M0 (width = 0.042um) when PRL > -0.096um inside GT_P96 region >= 0.054um
 m0_L_sides = AOP_M0_042 COIN EDGE ALL_M0_L_edges
 m0_L_sides_p96 = m0_L_sides NOT OUTSIDE EDGE GT_P96
 err1_TMP = EXT m0_L_sides m0_L_sides_p96 < 0.054 ABUT<90 OPPOSITE EXTENDED 0.096 REGION
 err1 = err1_TMP NOT OUTSIDE GT_P96
 err1 NOT INSIDE SealR_NOT_BULK
}

AOP_M0_040_W_edges_EX_015 = OR (EXPAND EDGE AOP_M0_040_W_edges OUTSIDE BY 0.015) AOP_M0_040
AOP_M0_042_W_edges_EX_015 = OR (EXPAND EDGE AOP_M0_042_W_edges OUTSIDE BY 0.015) AOP_M0_042

M0_S_6 {
@ Forbidden zones ((W1+S1+W1)+S2+(W1+S1+W1)) = 0.342um when W1 = 0.04um, S1 = 0.066um, S2 = 0.05um is not allowed
@ 1) W1 is AOP_M0 width
@ 2) S1 is horizontal space between two AOP_M0 (M0 line-end extend by 0.015um) with PRL > 0um
@ 3) S2 is space between two AOP_M0 P106 region
 m0_extend_v_edge = ANGLE AOP_M0_040_W_edges_EX_015 == 90
 m0_extend_h_s066 = EXT m0_extend_v_edge AOP_M0_040_W_edges_EX_015 == 0.066 ABUT<90 OPPOSITE REGION
 err1 = EXT (ANGLE m0_extend_h_s066 == 90) == 0.13 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

AOP_M0_040_REDUCE = AOP_M0_040 NOT INSIDE (OR GT_P96 INST)

M0_S_6a {
@ Space between AOP_M0 (width = 0.04um) and AOP_M0 in S/D direction when PRL > 0.01um, except GT_P96 and INST region = 0.05, 0.066, 0.14, 0.172, >= 0.23um
 WAIVE_AREA = OR GT_P96 INST
 err1 = (EXT AOP_M0_v_edges AOP_M0_040_REDUCE < 0.050 ABUT<90 OPPOSITE REGION) ENCLOSE RECTANGLE 0.011 0.001 ORTHOGONAL ONLY
 err2 = (EXT AOP_M0_v_edges AOP_M0_040_REDUCE > 0.050 < 0.066 ABUT<90 OPPOSITE REGION EXCLUDE SHIELDED) ENCLOSE RECTANGLE 0.011 0.04 ORTHOGONAL ONLY
 err3 = (EXT AOP_M0_v_edges AOP_M0_040_REDUCE > 0.066 < 0.140 ABUT<90 OPPOSITE REGION EXCLUDE SHIELDED) ENCLOSE RECTANGLE 0.011 0.04 ORTHOGONAL ONLY
 err4 = (EXT AOP_M0_v_edges AOP_M0_040_REDUCE > 0.140 < 0.172 ABUT<90 OPPOSITE REGION EXCLUDE SHIELDED) ENCLOSE RECTANGLE 0.011 0.04 ORTHOGONAL ONLY
 err5 = (EXT AOP_M0_v_edges AOP_M0_040_REDUCE > 0.172 < 0.230 ABUT<90 OPPOSITE REGION EXCLUDE SHIELDED) ENCLOSE RECTANGLE 0.011 0.04 ORTHOGONAL ONLY

 err1 NOT INSIDE WAIVE_AREA
 err2 NOT INSIDE WAIVE_AREA
 err3 NOT INSIDE WAIVE_AREA
 err4 NOT INSIDE WAIVE_AREA
 err5 NOT INSIDE WAIVE_AREA
}

AOP_M0_040_EX_015 = AOP_M0_040 OR AOP_M0_040_W_edges_EX_015
AOP_M0_042_EX_015 = AOP_M0_042 OR AOP_M0_042_W_edges_EX_015
AOP_M0_040_EX_015_REDUCE = AOP_M0_040_EX_015 INTERACT (GT_P96 OR (EXPAND EDGE GT_P96_v_edges OUTSIDE BY 0.3))
AOP_M0_042_EX_015_REDUCE = AOP_M0_042_EX_015 INTERACT (GT_P96 OR (EXPAND EDGE GT_P96_v_edges OUTSIDE BY 0.3))
AOP_M0_040_EX_015_v_edges = ANGLE AOP_M0_040_EX_015_REDUCE == 90
AOP_M0_042_EX_015_v_edges = ANGLE AOP_M0_042_EX_015_REDUCE == 90

M0_S_6c {
@ Space between AOP_M0 (width = 0.04um, line end extend 0.015um) and AOP_M0 in S/D direction inside GT_P96, except DMCB1 region = 0.056, 0.152, >= 0.248um
 err1 = (EXT AOP_M0_v_edges AOP_M0_040_EX_015_REDUCE < 0.056 ABUT<90 OPPOSITE REGION) AND GT_P96
 err2 = (EXT AOP_M0_v_edges AOP_M0_040_EX_015_REDUCE > 0.056 < 0.152 ABUT<90 OPPOSITE REGION) AND GT_P96
 err3 = (EXT AOP_M0_v_edges AOP_M0_040_EX_015_REDUCE > 0.152 < 0.248 ABUT<90 OPPOSITE REGION EXCLUDE SHIELDED) AND GT_P96
 err4 = (EXT AOP_M0_040_EX_015_v_edges AOP_M0_040_EX_015_REDUCE < 0.056 ABUT<90 OPPOSITE REGION) AND GT_P96
 err5 = (EXT AOP_M0_040_EX_015_v_edges AOP_M0_040_EX_015_REDUCE > 0.056 < 0.152 ABUT<90 OPPOSITE REGION) AND GT_P96
 err6 = (EXT AOP_M0_040_EX_015_v_edges AOP_M0_040_EX_015_REDUCE > 0.152 < 0.248 ABUT<90 OPPOSITE REGION EXCLUDE SHIELDED) AND GT_P96

 err1 NOT INSIDE DMCB1
 err2 NOT INSIDE DMCB1
 err3 NOT INSIDE DMCB1
 err4 NOT INSIDE DMCB1
 err5 NOT INSIDE DMCB1
 err6 NOT INSIDE DMCB1
}

M0_S_6d {
@ Space between AOP_M0 (width = 0.042um, line end extend 0.015um) and AOP_M0 in S/D direction (INSIDE GT_P96) = 0.054, 0.15, >= 0.246um
 err1 = (EXT AOP_M0_v_edges AOP_M0_042_EX_015_REDUCE < 0.054 ABUT<90 OPPOSITE REGION) AND GT_P96
 err2 = (EXT AOP_M0_v_edges AOP_M0_042_EX_015_REDUCE > 0.054 < 0.150 ABUT<90 OPPOSITE REGION) AND GT_P96
 err3 = (EXT AOP_M0_v_edges AOP_M0_042_EX_015_REDUCE > 0.150 < 0.246 ABUT<90 OPPOSITE REGION EXCLUDE SHIELDED) AND GT_P96
 err4 = (EXT AOP_M0_042_EX_015_v_edges AOP_M0_042_EX_015_REDUCE < 0.054 ABUT<90 OPPOSITE REGION) AND GT_P96
 err5 = (EXT AOP_M0_042_EX_015_v_edges AOP_M0_042_EX_015_REDUCE > 0.054 < 0.150 ABUT<90 OPPOSITE REGION) AND GT_P96
 err6 = (EXT AOP_M0_042_EX_015_v_edges AOP_M0_042_EX_015_REDUCE > 0.150 < 0.246 ABUT<90 OPPOSITE REGION EXCLUDE SHIELDED) AND GT_P96

 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
 err4 NOT INSIDE SealR_NOT_BULK
 err5 NOT INSIDE SealR_NOT_BULK
 err6 NOT INSIDE SealR_NOT_BULK
}

ALL_M0_NOT_M0C = ALL_M0 NOT M0C
ALL_M0_NOT_M0C_h_edges = ANGLE ALL_M0_NOT_M0C == 0
ALL_M0_NOT_M0C_v_edges = ANGLE ALL_M0_NOT_M0C == 90
ALL_M0_NOT_M0C_WL_edges_a = DFM PROPERTY ALL_M0_NOT_M0C ALL_M0_NOT_M0C_h_edges ALL_M0_NOT_M0C_v_edges OVERLAP ABUT ALSO MULTI [h_v_ratio = LENGTH(ALL_M0_NOT_M0C_h_edges) - LENGTH(ALL_M0_NOT_M0C_v_edges)] >= 0
ALL_M0_NOT_M0C_WL_edges_b = DFM PROPERTY ALL_M0_NOT_M0C ALL_M0_NOT_M0C_h_edges ALL_M0_NOT_M0C_v_edges OVERLAP ABUT ALSO MULTI [h_v_ratio = LENGTH(ALL_M0_NOT_M0C_v_edges) - LENGTH(ALL_M0_NOT_M0C_h_edges)] >= 0
ALL_M0_NOT_M0C_W_edges = (ALL_M0_NOT_M0C_v_edges COIN EDGE ALL_M0_NOT_M0C_WL_edges_a) OR EDGE (ALL_M0_NOT_M0C_h_edges COIN EDGE ALL_M0_NOT_M0C_WL_edges_b)
ALL_M0_NOT_M0C_L_edges = (ALL_M0_NOT_M0C_h_edges COIN EDGE ALL_M0_NOT_M0C_WL_edges_a) OR EDGE (ALL_M0_NOT_M0C_v_edges COIN EDGE ALL_M0_NOT_M0C_WL_edges_b)

M0_S_7 {
@ Space between (ALL_M0 NOT M0C) line-end and AOP_AA when PRL > -0.025um, except INST region >= 0.037um
 err1 = EXT ALL_M0_NOT_M0C_W_edges AOP_AA < 0.037 ABUT<90 OPPOSITE EXTENDED 0.025 REGION
 err1 NOT INSIDE INST
}

M0_S_8 {
@ Space between AOP_M0 (width = 0.04/0.042um) and AOP_GT (Overlap is not allowed) >= 0.015um
 err1 = EXT AOP_M0_040_042 AOP_GT < 0.015 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

M0_S_8a {
@ Space between AOP_M0 (width = 0.04um) and AOP_GT (width = 0.016/0.032um) >= 0.017um
 err1 = EXT AOP_M0_040 (OR AOP_GT_016 AOP_GT_032) < 0.017 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

M0_S_8b {
@ Space between AOP_M0 (width = 0.04um) and AOP_GT (width = 0.018um) >= 0.016um
 err1 = EXT AOP_M0_040 AOP_GT_018 < 0.016 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

M0_S_8c {
@ Space between AOP_M0 (width = 0.04um) and AOP_GT (width = 0.02um) >= 0.015um
 err1 = EXT AOP_M0_040 AOP_GT_020 < 0.015 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

/*
M0_S_7d {
@ Space between AOP_M0 (width = 0.04um) and AOP_GT (width = 0.032um) >= 0.017um
 err1 = EXT AOP_M0_040 AOP_GT_032 < 0.017 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

M0_S_7e {
@ Space between AOP_M0 (width = 0.042um) and AOP_GT (width = 0.016/0.032um) >= 0.016um
 err1 = EXT AOP_M0_042 (OR AOP_GT_016 AOP_GT_032) < 0.016 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

M0_S_7f {
@ Space between AOP_M0 (width = 0.042um) and AOP_GT (width = 0.018um) >= 0.015um
 err1 = EXT AOP_M0_042 AOP_GT_018 < 0.015 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
*/

AOP_M0_W040_inside_GT_P96 = AOP_M0_040 INSIDE GT_P96
AOP_M0_W042_inside_GT_P96 = AOP_M0_042 INSIDE GT_P96
AOP_M0_W040_042_inside_GT_P96 = AOP_M0_040_042 INSIDE GT_P96

M0_S_9 {
@ Space between AOP_M0 (width = 0.04/0.042um, INSIDE GT_P96) and AOP_GT (Overlap is not allowed), except DMCB1 region >= 0.016um
 err1 = EXT AOP_M0_W040_042_inside_GT_P96 AOP_GT < 0.016 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE DMCB1
}

M0_S_9a {
@ Space between AOP_M0 (width = 0.04um, INSIDE GT_P96) and AOP_GT (width = 0.016um) >= 0.02um
 err1 = EXT AOP_M0_W040_inside_GT_P96 AOP_GT_016 < 0.020 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

M0_S_9b {
@ Space between AOP_M0 (width = 0.04um, INSIDE GT_P96) and AOP_GT (width = 0.018um) >= 0.019um
 err1 = EXT AOP_M0_W040_inside_GT_P96 AOP_GT_018 < 0.019 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

M0_S_9c {
@ Space between AOP_M0 (width = 0.04um, INSIDE GT_P96) and AOP_GT (width = 0.02um) >= 0.018um
 err1 = EXT AOP_M0_W040_inside_GT_P96 AOP_GT_020 < 0.018 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

M0_S_9d {
@ Space between AOP_M0 (width = 0.04um, INSIDE GT_P96) and AOP_GT (width = 0.022um) >= 0.017um
 err1 = EXT AOP_M0_W040_inside_GT_P96 AOP_GT_022 < 0.017 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

M0_S_9e {
@ Space between AOP_M0 (width = 0.04um, INSIDE GT_P96) and AOP_GT (width = 0.024um) >= 0.016um
 err1 = EXT AOP_M0_W040_inside_GT_P96 AOP_GT_024 < 0.016 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

M0_S_9f {
@ Space between AOP_M0 (width = 0.042um, INSIDE GT_P96) and AOP_GT (width = 0.016um) >= 0.019um
 err1 = EXT AOP_M0_W042_inside_GT_P96 AOP_GT_016 < 0.019 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

M0_S_9g {
@ Space between AOP_M0 (width = 0.042um, INSIDE GT_P96) and AOP_GT (width = 0.018um) >= 0.018um
 err1 = EXT AOP_M0_W042_inside_GT_P96 AOP_GT_018 < 0.018 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

M0_S_9h {
@ Space between AOP_M0 (width = 0.042um, INSIDE GT_P96) and AOP_GT (width = 0.02um) >= 0.017um
 err1 = EXT AOP_M0_W042_inside_GT_P96 AOP_GT_020 < 0.017 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

M0_S_9i {
@ Space between AOP_M0 (width = 0.042um, INSIDE GT_P96) and AOP_GT (width = 0.022um) >= 0.016um
 err1 = EXT AOP_M0_W042_inside_GT_P96 AOP_GT_022 < 0.016 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

M0_S_10 {
@ Space between AOP_M0 and AOP_GT (width >= 0.07um) >= 0.032um
 err1 = EXT AOP_M0 AOP_GT_eqgt_070 < 0.032 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

M0_S_10a {
@ Space between AOP_M0 (width = 0.054um) and AOP_GT (Overlap is not allowed) >= 0.032um
 err1 = EXT AOP_M0_054 AOP_GT < 0.032 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

M0_S_10b {
@ Space between (AOP_M0 NOT AOP_M0C) and AOP_GT line-end, except small AOP_GT jog <= 0.004um and DMCMK1 region >= 0.046um
 AOP_GT_lend_m0_S_10 = ANGLE (CONVEX EDGE AOP_GT >= 1) == 0
 err1_TMP = EXT AOP_M0_NOT_AOP_M0C [AOP_GT_lend_m0_S_10] < 0.046 ABUT<90
 err1 = err1_TMP NOT COIN EDGE AOP_GT_jog_lteq_004
 err1 NOT INSIDE EDGE DMCMK1
}

m0_s_11_m0 = M0_040 OUTSIDE GT_P96
m0_s_11_Y1 = EXT m0_s_11_m0 [AOP_GT_016_v_edges] < 0.031 ABUT<90 OPPOSITE
m0_s_11_Y2 = EXT m0_s_11_m0 [AOP_GT_018_v_edges] < 0.029 ABUT<90 OPPOSITE
m0_s_11_Y3 = EXT m0_s_11_m0 [AOP_GT_020_v_edges] < 0.027 ABUT<90 OPPOSITE
m0_s_11_err1 = EXT (m0_s_11_Y1) AOP_GT < 0.08 ABUT<90 OPPOSITE
m0_s_11_err2 = EXT (m0_s_11_Y2) AOP_GT < 0.08 ABUT<90 OPPOSITE
m0_s_11_err3 = EXT (m0_s_11_Y3) AOP_GT < 0.08 ABUT<90 OPPOSITE

M0_S_11 {
@ Space between M0 (width = 0.04um, OUTSIDE GT_P96) and AOP_GT (one side poly space >= 0.08um, width = 0.016/0.018/0.02um respectively) >= 0.031, 0.029, 0.027um
//; DRC not exclude P2 in this check
 err1 = COPY m0_s_11_err1
 err2 = COPY m0_s_11_err2
 err3 = COPY m0_s_11_err3
 err1 NOT INSIDE EDGE SealR_NOT_BULK
 err2 NOT INSIDE EDGE SealR_NOT_BULK
 err3 NOT INSIDE EDGE SealR_NOT_BULK
}

m0_s_11a_m0 = M0_040_042 NOT OUTSIDE GT_P96
m0_s_11a_Y1 = EXT m0_s_11a_m0 [AOP_GT_016_v_edges] < 0.034 ABUT<90 OPPOSITE
m0_s_11a_Y2 = EXT m0_s_11a_m0 [AOP_GT_018_v_edges] < 0.032 ABUT<90 OPPOSITE
m0_s_11a_Y3 = EXT m0_s_11a_m0 [AOP_GT_020_v_edges] < 0.030 ABUT<90 OPPOSITE
m0_s_11a_Y4 = EXT m0_s_11a_m0 [AOP_GT_022_v_edges] < 0.028 ABUT<90 OPPOSITE
m0_s_11a_Y5 = EXT m0_s_11a_m0 [AOP_GT_024_v_edges] < 0.026 ABUT<90 OPPOSITE
m0_s_11a_err1 = EXT (m0_s_11a_Y1) AOP_GT <= 0.08 ABUT<90 OPPOSITE
m0_s_11a_err2 = EXT (m0_s_11a_Y2) AOP_GT <= 0.08 ABUT<90 OPPOSITE
m0_s_11a_err3 = EXT (m0_s_11a_Y3) AOP_GT <= 0.08 ABUT<90 OPPOSITE
m0_s_11a_err4 = EXT (m0_s_11a_Y4) AOP_GT <= 0.08 ABUT<90 OPPOSITE
m0_s_11a_err5 = EXT (m0_s_11a_Y5) AOP_GT <= 0.08 ABUT<90 OPPOSITE

M0_S_11a {
@ Space between M0 (width = 0.04/0.042um, INSIDE GT_P96) and AOP_GT (one side poly space > 0.080um, width = 0.016/0.018/0.02/0.022/0.024um, respectively >= 0.034, 0.032, 0.030, 0.028, 0.026um
 err1 = COPY m0_s_11a_err1
 err2 = COPY m0_s_11a_err2
 err3 = COPY m0_s_11a_err3
 err4 = COPY m0_s_11a_err4
 err5 = COPY m0_s_11a_err5
 err1 NOT INSIDE EDGE SealR_NOT_BULK
 err2 NOT INSIDE EDGE SealR_NOT_BULK
 err3 NOT INSIDE EDGE SealR_NOT_BULK
 err4 NOT INSIDE EDGE SealR_NOT_BULK
 err5 NOT INSIDE EDGE SealR_NOT_BULK
}

M0_S_12 {
@ Space between M0 (width = 0.054um) and AOP_GT (one side poly space >= 0.118um, width = 0.016/0.018/0.02um respectively) >= 0.05, 0.048, 0.046um
 bad_016_sps = EXT M0_054 [AOP_GT_016_v_edges] < 0.050 ABUT<90 OPPOSITE
 bad_018_sps = EXT M0_054 [AOP_GT_018_v_edges] < 0.048 ABUT<90 OPPOSITE
 bad_020_sps = EXT M0_054 [AOP_GT_020_v_edges] < 0.046 ABUT<90 OPPOSITE

 err1 = EXT (bad_016_sps) AOP_GT < 0.118 ABUT<90 OPPOSITE
 err2 = EXT (bad_018_sps) AOP_GT < 0.118 ABUT<90 OPPOSITE
 err3 = EXT (bad_020_sps) AOP_GT < 0.118 ABUT<90 OPPOSITE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
 err2 NOT INSIDE EDGE SealR_NOT_BULK
 err3 NOT INSIDE EDGE SealR_NOT_BULK
}

M0_S_13 {
@ Space between FIELD (AOP_GT NOT P2) and AOP_M0 (FIELD (AOP_GT NOT P2) width < 0.096um, one side space to ((GT (INSIDE DG) SIZING 0.041um) AND GT) = 0.118~0.119um, the other side space to (AOP_GT NOT P2) >= 0.15um) >= 0.054um
 GT_size_041_IO = (SIZE (GT_0 AND DG) BY 0.041) AND GT
 GT_sps_eg_150 = EXT (AOP_GT_NOT_P2_lt_096) AOP_GT_NOT_P2 < 0.15 ABUT<90 OPPOSITE
 GT_sps_eq_118_OPP = EXT [AOP_GT_NOT_P2_lt_096] GT_size_041_IO >= 0.118 <= 0.119 ABUT<90 OPPOSITE
 GT_sps_eg_150_EDG = INT GT_sps_eq_118_OPP [GT_sps_eg_150] < 0.096 OPPOSITE
 err1 = EXT GT_sps_eg_150_EDG AOP_M0 < 0.054 ABUT<90 REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

M0_EX_1 {
@ AA extention outside of the short side of M0 (Extension <= 0um is allowed), except INST region <= 0.007um
 chk_M0 = (M0_W_edges TOUCH EDGE (M0 INTERACT AA)) INSIDE EDGE AA
 err1 = ENC (chk_M0) AA <= 0.007 ABUT<90 OPPOSITE
 err1 NOT INSIDE EDGE INST
}

M0_EX_2 {
@ AA extension outside of the long side of M0 (Extension <= 0um is not allowed) >= 0.025
 err1 = ENC M0_L_edges AA < 0.025 ABUT<90 OPPOSITE REGION
 err2 = AA_v_edges NOT OUTSIDE EDGE M0
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE EDGE SealR_NOT_BULK
}

M0_EX_3 {
@ AA extension outside of M0 in S/D direction inside GT_P96 (Extention <= 0um is not allowed) >= 0.028um
 chk_M0 = M0 INTERACT GT_P96
 err1 = (ENC chk_M0 AA_v_edges < 0.028 ABUT<90 OPPOSITE REGION) NOT OUTSIDE GT_P96
 err2 = (AA_v_edges NOT OUTSIDE EDGE chk_M0) NOT OUTSIDE EDGE GT_P96

 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE EDGE SealR_NOT_BULK
}

M0_EX_4 {
@ AA (INTERACT ALL_GT (width >= 0.07um)) extension outside of the long side of M0 (Extension <= 0um is not allowed) >= 0.067um
 chk_AA = AA INTERACT ALL_GT_eqgt_070
 err1 = ENC M0_L_edges chk_AA < 0.067 ABUT<90 OPPOSITE REGION
 err2 = (ANGLE chk_AA == 90) NOT OUTSIDE EDGE M0
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE EDGE SealR_NOT_BULK
}

M0_A_1 {
@ M0 area, except (M0 interact TRCMK) region >= 0.0046um2
 err1 = AREA (M0 NOT INTERACT TRCMK) < 0.0046
 err1 NOT INSIDE SealR_NOT_BULK
}

#IFDEF IP_LEVEL_DENSITY_CHECK YES
#IFDEF MINIMUM_DENSITY_CHECK YES
VARIABLE M0_D_1_val 5.3
VARIABLE M0_D_1_window 125

M0_D_1 {
@ ALL_M0 density (window 125um*125um, stepping 125um/step_number), except MARKS, RESP1, LOGO regions >= 5.3%
 check_region = CHIP_NOT_MARKS NOT (OR RESP1 LOGO)
 check_pattern = ALL_M0 AND check_region

 check_window1 = check_region WITH WIDTH >= M0_D_1_window/4
 err1_TMP1 = DENSITY check_pattern check_window1 check_region [!AREA(check_window1) + !!AREA(check_window1)*AREA(check_pattern)/AREA(check_region)] < M0_D_1_val/100 WINDOW M0_D_1_window STEP M0_D_1_window/step_number BACKUP INSIDE OF LAYER DRC:1 BY POLYGON

 check_window2 = WITH WIDTH (check_region AND err1_TMP1) >= M0_D_1_window/4
 err1_TMP2 = DENSITY check_pattern check_window2 check_region [!AREA(check_window2) + !!AREA(check_window2)*AREA(check_pattern)/AREA(check_region)] < M0_D_1_val/100 WINDOW M0_D_1_window STEP M0_D_1_window/step_number BACKUP INSIDE OF LAYER err1_TMP1 BY POLYGON

 check_window3 = WITH WIDTH (check_region AND err1_TMP2) >= M0_D_1_window/4
 DENSITY check_pattern check_window3 check_region [!AREA(check_window3) + !!AREA(check_window3)*AREA(check_pattern)/AREA(check_region)] < M0_D_1_val/100 WINDOW M0_D_1_window STEP M0_D_1_window/step_number BACKUP INSIDE OF LAYER err1_TMP2 BY POLYGON PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_M0_D_1.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_M0_D_1.rdb"
}

VARIABLE M0_D_2_val 1.3
VARIABLE M0_D_2_window 20

M0_D_2 {
@ ALL_M0 density (window 20um*20um, stepping 20um/step_number), except MARKS, LOGO, OCOVL, RESP1, (NODMF su 1um) regions >= 1.3%
 check_region = CHIP_NOT_MARKS NOT (OR MARKS_OCOVL LOGO RESP1 NODMF_SIZE_1)
 check_pattern = ALL_M0 AND check_region

 check_window1 = check_region WITH WIDTH >= M0_D_2_window/4
 err1_TMP1 = DENSITY check_pattern check_window1 check_region [!AREA(check_window1) + !!AREA(check_window1)*AREA(check_pattern)/AREA(check_region)] < M0_D_2_val/100 WINDOW M0_D_2_window STEP M0_D_2_window/step_number BACKUP INSIDE OF LAYER DRC:1 BY POLYGON

 check_window2 = WITH WIDTH (check_region AND err1_TMP1) >= M0_D_2_window/4
 err1_TMP2 = DENSITY check_pattern check_window2 check_region [!AREA(check_window2) + !!AREA(check_window2)*AREA(check_pattern)/AREA(check_region)] < M0_D_2_val/100 WINDOW M0_D_2_window STEP M0_D_2_window/step_number BACKUP INSIDE OF LAYER err1_TMP1 BY POLYGON

 check_window3 = WITH WIDTH (check_region AND err1_TMP2) >= M0_D_2_window/4
 DENSITY check_pattern check_window3 check_region [!AREA(check_window3) + !!AREA(check_window3)*AREA(check_pattern)/AREA(check_region)] < M0_D_2_val/100 WINDOW M0_D_2_window STEP M0_D_2_window/step_number BACKUP INSIDE OF LAYER err1_TMP2 BY POLYGON PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_M0_D_2.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_M0_D_2.rdb"
}
#ENDIF

VARIABLE M0_D_3_val 40
VARIABLE M0_D_3_window 20

M0_D_3 {
@ ALL_M0 density (window 20um*20um, stepping 20um/step_number), except INST, OCOVL regions <= 40%
 check_region = CHIP_NOT_MARKS NOT (OR INST OCOVL)
 check_pattern = ALL_M0 AND check_region

 check_window1 = check_region WITH WIDTH >= M0_D_3_window/4
 err1_TMP1 = DENSITY check_pattern check_window1 check_region [!!AREA(check_window1)*AREA(check_pattern)/AREA(check_region)] > M0_D_3_val/100 WINDOW M0_D_3_window STEP M0_D_3_window/step_number BACKUP INSIDE OF LAYER DRC:1 BY POLYGON

 check_window2 = WITH WIDTH (check_region AND err1_TMP1) >= M0_D_3_window/4
 err1_TMP2 = DENSITY check_pattern check_window2 check_region [!!AREA(check_window2)*AREA(check_pattern)/AREA(check_region)] > M0_D_3_val/100 WINDOW M0_D_3_window STEP M0_D_3_window/step_number BACKUP INSIDE OF LAYER err1_TMP1 BY POLYGON

 check_window3 = WITH WIDTH (check_region AND err1_TMP2) >= M0_D_3_window/4
 DENSITY check_pattern check_window3 check_region [!!AREA(check_window3)*AREA(check_pattern)/AREA(check_region)] > M0_D_3_val/100 WINDOW M0_D_3_window STEP M0_D_3_window/step_number BACKUP INSIDE OF LAYER err1_TMP2 BY POLYGON PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_M0_D_3.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_M0_D_3.rdb"
}
#ELSE

#IFDEF MINIMUM_DENSITY_CHECK YES
VARIABLE M0_D_1_val 5
VARIABLE M0_D_1_window 125

M0_D_1 {
@ ALL_M0 density (window 125um*125um, stepping 62.5um), except MARKS, RESP1, LOGO regions >= 5%
 check_region = CHIP_NOT_MARKS NOT (OR RESP1 LOGO)
 check_pattern = ALL_M0 AND check_region

 check_window1 = check_region WITH WIDTH >= M0_D_1_window/4
 err1_TMP1 = DENSITY check_pattern check_window1 check_region [!AREA(check_window1) + !!AREA(check_window1)*AREA(check_pattern)/AREA(check_region)] < M0_D_1_val/100 WINDOW M0_D_1_window STEP M0_D_1_window/2 BACKUP INSIDE OF LAYER DRC:1 BY POLYGON

 check_window2 = WITH WIDTH (check_region AND err1_TMP1) >= M0_D_1_window/4
 err1_TMP2 = DENSITY check_pattern check_window2 check_region [!AREA(check_window2) + !!AREA(check_window2)*AREA(check_pattern)/AREA(check_region)] < M0_D_1_val/100 WINDOW M0_D_1_window STEP M0_D_1_window/2 BACKUP INSIDE OF LAYER err1_TMP1 BY POLYGON

 check_window3 = WITH WIDTH (check_region AND err1_TMP2) >= M0_D_1_window/4
 DENSITY check_pattern check_window3 check_region [!AREA(check_window3) + !!AREA(check_window3)*AREA(check_pattern)/AREA(check_region)] < M0_D_1_val/100 WINDOW M0_D_1_window STEP M0_D_1_window/2 BACKUP INSIDE OF LAYER err1_TMP2 BY POLYGON PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_M0_D_1.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_M0_D_1.rdb"
}

VARIABLE M0_D_2_val 1.2
VARIABLE M0_D_2_window 20

M0_D_2 {
@ ALL_M0 density (window 20um*20um, stepping 10um), except MARKS, LOGO, OCOVL, RESP1, (NODMF su 1um) regions >= 1.2%
 check_region = CHIP_NOT_MARKS NOT (OR MARKS_OCOVL LOGO RESP1 NODMF_SIZE_1)
 check_pattern = ALL_M0 AND check_region

 check_window1 = check_region WITH WIDTH >= M0_D_2_window/4
 err1_TMP1 = DENSITY check_pattern check_window1 check_region [!AREA(check_window1) + !!AREA(check_window1)*AREA(check_pattern)/AREA(check_region)] < M0_D_2_val/100 WINDOW M0_D_2_window STEP M0_D_2_window/2 BACKUP INSIDE OF LAYER DRC:1 BY POLYGON

 check_window2 = WITH WIDTH (check_region AND err1_TMP1) >= M0_D_2_window/4
 err1_TMP2 = DENSITY check_pattern check_window2 check_region [!AREA(check_window2) + !!AREA(check_window2)*AREA(check_pattern)/AREA(check_region)] < M0_D_2_val/100 WINDOW M0_D_2_window STEP M0_D_2_window/2 BACKUP INSIDE OF LAYER err1_TMP1 BY POLYGON

 check_window3 = WITH WIDTH (check_region AND err1_TMP2) >= M0_D_2_window/4
 DENSITY check_pattern check_window3 check_region [!AREA(check_window3) + !!AREA(check_window3)*AREA(check_pattern)/AREA(check_region)] < M0_D_2_val/100 WINDOW M0_D_2_window STEP M0_D_2_window/2 BACKUP INSIDE OF LAYER err1_TMP2 BY POLYGON PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_M0_D_2.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_M0_D_2.rdb"
}
#ENDIF

VARIABLE M0_D_3_val 40
VARIABLE M0_D_3_window 20

M0_D_3 {
@ ALL_M0 density (window 20um*20um, stepping 10um), except INST, OCOVL regions <= 40%
 check_region = CHIP_NOT_MARKS NOT (OR INST OCOVL)
 check_pattern = ALL_M0 AND check_region

 check_window1 = check_region WITH WIDTH >= M0_D_3_window/4
 err1_TMP1 = DENSITY check_pattern check_window1 check_region [!!AREA(check_window1)*AREA(check_pattern)/AREA(check_region)] > M0_D_3_val/100 WINDOW M0_D_3_window STEP M0_D_3_window/2 BACKUP INSIDE OF LAYER DRC:1 BY POLYGON

 check_window2 = WITH WIDTH (check_region AND err1_TMP1) >= M0_D_3_window/4
 err1_TMP2 = DENSITY check_pattern check_window2 check_region [!!AREA(check_window2)*AREA(check_pattern)/AREA(check_region)] > M0_D_3_val/100 WINDOW M0_D_3_window STEP M0_D_3_window/2 BACKUP INSIDE OF LAYER err1_TMP1 BY POLYGON

 check_window3 = WITH WIDTH (check_region AND err1_TMP2) >= M0_D_3_window/4
 DENSITY check_pattern check_window3 check_region [!!AREA(check_window3)*AREA(check_pattern)/AREA(check_region)] > M0_D_3_val/100 WINDOW M0_D_3_window STEP M0_D_3_window/2 BACKUP INSIDE OF LAYER err1_TMP2 BY POLYGON PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_M0_D_3.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_M0_D_3.rdb"
}
#ENDIF

M0_R_1 {
@ ALL_M0 must be rectangular and orthogonal to grid, except MARKS region
 err1 = (NOT RECTANGLE ALL_M0 ORTHOGONAL ONLY) NOT MARKS
 err1 NOT INSIDE SealR_NOT_BULK
}

M0_R_2 {
@ ALL_M0 must be GATE poly direction and parallel to GT, except OCOVL region
 waive_bar = (DONUT ALL_M0) INSIDE MARKS
 err1 = (ANGLE ALL_M0_L_edges != 90) NOT COIN EDGE waive_bar
 err1 NOT INSIDE EDGE OCOVL
}

M0_R_3 {
@ M0 (width = 0.04/0.042um) overlap with (DG OR NW resistor) is not allowed
 err1 = M0_040_042 AND DG_RESNW
 err2 = (M0 INTERACT DG_RESNW) NOT (M0_054 INTERACT DG_RESNW)
 err3 = (M0 INTERACT AA_NWR) NOT (M0_054 INTERACT AA_NWR) //;M0_040 can be used for NW resistor terminal

 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
}

ALL_M0_040_L_eqlt_150 = ALL_M0_040 NOT WITH EDGE (LENGTH ALL_M0_L_edges > 0.148)
ALL_M0_040_042_L_eqlt_150 = ALL_M0_040_042 NOT WITH EDGE (LENGTH ALL_M0_L_edges > 0.148)

M0_R_4 {
@ The number of ALL_M0 (width = 0.04/0.042um and at least one ALL_M0 length <= 0.148um) in one group >= 5
@ ALL_M0 group definition:
@ 1) ALL_M0 space <= 0.066um
@ 2) ALL_M0 PRL >= 0.065um
@ DRC flags ((ALL_M0 SIZING 0.043um) SIZING -0.043um) in ALL_M0 short side direction
 M0_EXP_all = (EXPAND EDGE ALL_M0_W_edges OUTSIDE BY 0.043) OR ALL_M0_040_042
 M0_EXP_all_END = (LENGTH M0_EXP_all == 0.04) OR EDGE (LENGTH M0_EXP_all == 0.042)
 M0_EXP_all_SRK = M0_EXP_all NOT (EXPAND EDGE M0_EXP_all_END INSIDE BY 0.043)

 M0_EXP_sps = EXT M0_EXP_all_SRK <= 0.066 ABUT<90 OPPOSITE REGION
 M0_EXP_sps_EDG = EXT [M0_EXP_all_SRK] <= 0.066 ABUT<90 OPPOSITE
 M0_EXP_sps_PRL = M0_EXP_sps WITH EDGE (LENGTH M0_EXP_sps_EDG < 0.065)
 M0_EXP_grp_TMP = (M0_EXP_sps NOT M0_EXP_sps_PRL) OR ALL_M0_040_042
 err1 = (M0_EXP_grp_TMP INTERACT ALL_M0_040_042_L_eqlt_150) INTERACT ALL_M0_040_042 >= 1 < 5
 err1 NOT INSIDE SealR_NOT_BULK
}

M0_R_6 {
@ (AOP_M0 INTERACT AOP_GT) is not allowed
 err1 = (AOP_M0 AND AOP_GT) OR (EXPAND EDGE (AOP_M0 COIN EDGE AOP_GT) BY 0.001)
 err1 NOT INSIDE SealR_NOT_BULK
}

M0_R_7 {
@ ((AA INTERACT GT) NOT GT) must INTERACT M0, except INST region
 err1 = ((AA_INTERACT_GT NOT GT) NOT INSIDE INST) NOT INTERACT M0
 err1 NOT INSIDE INST
}

M0_R_8 {
@ Only one M0 is allowed on single S/D region, except ESDIO1 and ESDIO2 regions
 except_area = COPY ESDIO_ALL
 err1 = SD INTERACT M0 > 1
 err1 NOT INSIDE except_area

 A = SD INTERACT M0
 B = M0 INTERACT A
 C = (M0_L_edges TOUCH EDGE B) NOT INSIDE EDGE except_area
 D = GTEIAA NOT INSIDE EDGE except_area
 C_90 = ANGLE C == 90
 C_00 = ANGLE C == 0
 D_90 = ANGLE D == 90
 D_00 = ANGLE D == 0
 D_random = ANGLE D > 0 < 90

 err2 = DFM PROPERTY SD C_00 D_90 OVERLAP ABUT ALSO MULTI [-= LENGTH(C_00)/LENGTH(D_90)] > 0
 err3 = DFM PROPERTY SD C_90 D_00 OVERLAP ABUT ALSO MULTI [-= LENGTH(C_90)/LENGTH(D_00)] > 0
 err4 = DFM PROPERTY SD C_00 D_random OVERLAP ABUT ALSO MULTI [-= LENGTH(C_00)/LENGTH(D_random)] > 0
 err5 = DFM PROPERTY SD C_90 D_random OVERLAP ABUT ALSO MULTI [-= LENGTH(C_90)/LENGTH(D_random)] > 0
 err2 NOT INSIDE except_area
 err3 NOT INSIDE except_area
 err4 NOT INSIDE except_area
 err5 NOT INSIDE except_area
}

M0_R_9 {
@ M0 (width = 0.042um) must inside GT_P96
 err1 = M0_042 NOT GT_P96
 err1 NOT INSIDE SealR_NOT_BULK
}

M0_040_L_edges = M0_L_edges COIN EDGE M0_040
M0_040_L_edges_gt_1_pitch = EXT (M0_040_L_edges) M0 <= 0.120 ABUT<90 OPPOSITE EXCLUDE SHIELDED
M0_040_L_edges_eq_1_pitch = EXT [M0_040_L_edges] M0 <= 0.120 ABUT<90 OPPOSITE EXCLUDE SHIELDED
M0_040_L_edges_lt_3_pitch = (EXT [M0_040_L_edges] M0 < 0.300 ABUT<90 OPPOSITE EXCLUDE SHIELDED) NOT COIN EDGE M0_040_L_edges_eq_1_pitch

M0_040_042_L_edges = M0_L_edges COIN EDGE (OR M0_040 M0_042)
M0_040_042_L_edges_gt_1_pitch = EXT (M0_040_042_L_edges) M0 <= 0.120 ABUT<90 OPPOSITE EXCLUDE SHIELDED
M0_040_042_L_edges_eq_1_pitch = EXT [M0_040_042_L_edges] M0 <= 0.120 ABUT<90 OPPOSITE EXCLUDE SHIELDED
M0_040_042_L_edges_lt_3_pitch = (EXT [M0_040_042_L_edges] M0 < 0.300 ABUT<90 OPPOSITE EXCLUDE SHIELDED) NOT COIN EDGE M0_040_042_L_edges_eq_1_pitch

M0_054_L_edges = M0_L_edges COIN EDGE M0_054
M0_054_L_edges_gt_1_pitch = EXT (M0_054_L_edges) M0 <= 0.200 ABUT<90 OPPOSITE EXCLUDE SHIELDED
M0_054_L_edges_eq_1_pitch = EXT [M0_054_L_edges] M0 <= 0.200 ABUT<90 OPPOSITE EXCLUDE SHIELDED
M0_054_L_edges_lt_3_pitch = (EXT [M0_054_L_edges] M0 < 0.360 ABUT<90 OPPOSITE EXCLUDE SHIELDED) NOT COIN EDGE M0_054_L_edges_eq_1_pitch

adjacent_M0 = (OR M0_040 M0_042) INSIDE EDGE (AA_SD_all INTERACT edge_gate)
adjacent_sd = ((((AA_SD_all INTERACT edge_gate) NOT M0) OR (edge_gate AND AA)) WITH EDGE adjacent_M0) NOT TAP_RAW
adjacent_sd_v_edges = AA_v_edges COIN EDGE adjacent_sd
adjacent_M0_end_inside_AA_EXP = EXPAND EDGE (M0_W_edges COIN EDGE (CONVEX EDGE adjacent_sd == 0)) OUTSIDE BY 0.010

M0_R_11_waive_one_M0_pkup = M0 INTERACT ((TAP_RAW INTERACT M0 == 1) INTERACT GT == 2)

#IFDEF DFM_RULES_PRIORITY_1 YES
M0_R_10_DFM1 {
@ It's not recommended to use M0 P-to-N routing with M0G on adjacent GT, except INST
@ DRC flag condition:
@ (M0 not M0C) electrically connect both P+AA and N+AA and with M0G on adjacent GT
@ DRC waive if M0G and M0 PRL < 0um in GATE poly direction
 chk_po = GT_0 AND M0G
 chk_mn = (M0_NOT_M0C INTERACT NACT) INTERACT PACT
 chk_mn_v_edges = ANGLE ((M0_NOT_M0C INTERACT NACT) INTERACT PACT) == 90
 err1 = chk_mn WITH EDGE (EXT [chk_mn_v_edges] chk_po < 0.05 ABUT<90 OPPOSITE)
 err1 NOT INSIDE INST
}

M0_R_11_DFM1 {
@ It is not allowed M0 (M0 width = 0.04/0.042um) ΔL > 0.1um, except single M0 pickup case
@ DRC highlight M0 segment (length > 0.1um) without an adjacent M0
 iso_m0_a = INT M0_040_042_L_edges_eq_1_pitch M0_040_042_L_edges_lt_3_pitch >= 0.040 <= 0.042 ABUT<90 OPPOSITE REGION
 iso_m0_b = INT M0_040_042_L_edges_gt_1_pitch >= 0.040 <= 0.042 ABUT<90 OPPOSITE REGION
 err1 = (iso_m0_a ENCLOSE RECTANGLE 0.002 0.100+GLOBAL_TOLERANCE ORTHOGONAL ONLY) NOT M0_R_11_waive_one_M0_pkup
 err2 = (iso_m0_b ENCLOSE RECTANGLE 0.002 0.100+GLOBAL_TOLERANCE ORTHOGONAL ONLY) NOT M0_R_11_waive_one_M0_pkup
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

M0_R_12_DFM1 {
@ It is not allowed the outmost (M0 on AA) (M0 width = 0.04/0.042um) without an adjacent (M0 on STI)
@ DRC searching region: 0~0.12um from AA in S/D direction, except pick-up and DSTR region
 waive_end_cut_aa = LENGTH (ENC adjacent_M0_end_inside_AA_EXP [adjacent_sd_v_edges] < 0.100 ABUT<90 OPPOSITE EXCLUDE SHIELDED) <= 0.007 //;based on M0.EX.1
 waive_l_aa = LENGTH (ANGLE (CONVEX EDGE AA == 1) == 90) <= 0.100 //;waive L-shape corner M0 of good M0_R_11_DFM1
 err1 = ((EXT (adjacent_sd_v_edges) M0 <= 0.120 ABUT<90 OPPOSITE MEASURE ALL) NOT COIN EDGE waive_l_aa) NOT COIN EDGE waive_end_cut_aa
 err1 NOT INSIDE EDGE DSTR
}
#ENDIF


// =======================================================
// M0C: Local interconnect layer 2 design rules
// M0C is a drawn layer and used for M0 cut
// =======================================================

GROUP GM0C M0C_?

M0C_W_1 {
@ M0C width in GATE poly direction, except INST and OCOVL regions = 0.048, 0.051, 0.052, 0.082, 0.108um
 err1 = (DFM COPY (DFM SPACE M0C < M0C_MiniWidth BY INT VERTICAL) REGION) OR (INT M0C < 0.01 ABUT<90 SINGULAR REGION)
 err2 = DFM COPY (DFM SPACE M0C > M0C_MiniWidth < 0.051 BY INT VERTICAL) REGION
 err3 = DFM COPY (DFM SPACE M0C > 0.052 < 0.082 BY INT VERTICAL) REGION
 err4 = DFM COPY (DFM SPACE M0C > 0.082 < 0.108 BY INT VERTICAL) REGION
 err5 = M0C_h_edges NOT COIN EDGE (DFM SPACE [M0C] <= 0.108 BY INT VERTICAL)

 err1 NOT INSIDE INST_OCOVL
 err2 NOT INSIDE INST_OCOVL
 err3 NOT INSIDE INST_OCOVL
 err4 NOT INSIDE INST_OCOVL
 err5 NOT INSIDE EDGE INST_OCOVL
}

M0C_W_2 {
@ AOP_M0C width in GATE poly direction when INTERACT ALL_M0 (width = 0.054um) = 0.082, 0.108um
 in_Layer = AOP_M0C INTERACT ALL_M0_054 //; point touch flagged by M0C_S_7
 err1 = DFM COPY (DFM SPACE in_Layer < 0.082 BY INT VERTICAL) REGION
 err2 = DFM COPY (DFM SPACE in_Layer > 0.082 < 0.108 BY INT VERTICAL) REGION
 err3 = (ANGLE in_Layer == 0) NOT COIN EDGE (DFM SPACE [in_Layer] <= 0.108 BY INT VERTICAL)

 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE EDGE SealR_NOT_BULK
}

M0C_W_3 {
@ DOP_M0C width in GATE poly direction = 0.052, 0.082, 0.360um
 err1 = DFM COPY (DFM SPACE DOP_M0C < 0.052 BY INT VERTICAL) REGION
 err2 = DFM COPY (DFM SPACE DOP_M0C > 0.052 < 0.082 BY INT VERTICAL) REGION
 err3 = DFM COPY (DFM SPACE DOP_M0C > 0.082 < 0.360 BY INT VERTICAL) REGION
 err4 = DOP_M0C_h_edges NOT COIN EDGE (DFM SPACE [DOP_M0C] <= 0.36 BY INT VERTICAL)

 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
 err4 NOT INSIDE EDGE SealR_NOT_BULK
}

M0C_W_4 {
@ M0C width when M0C interact RSPMK1 = 0.051um
 err1 = (M0C INTERACT RSPMK1) NOT M0C_051
 err1 NOT INSIDE SealR_NOT_BULK
}

M0C_L_1 {
@ AOP_M0C edge length in S/D direction >= 0.09um
 err1 = LENGTH AOP_M0C_h_edges < 0.090
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

M0C_L_2 {
@ AOP_M0C (width = 0.048um) edge length in S/D direction, except INST region >= 0.36um
 err1 = LENGTH (ANGLE AOP_M0C_048 == 0) < 0.36
 err1 NOT INSIDE EDGE INST
}

M0C_L_3 {
@ AOP_M0C (width = 0.052um) edge length in S/D direction >= 0.18um
 err1 = LENGTH (ANGLE AOP_M0C_052 == 0) < 0.18
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

M0C_L_4 {
@ AOP_M0C edge length in S/D direction (AOP_M0C width = 0.082/0.108um, INTERACT AOP_M0 (width = 0.054um)) >= 0.36um
 err1 = LENGTH (ANGLE (AOP_M0C_082 INTERACT AOP_M0_054) == 0) < 0.36
 err2 = LENGTH (ANGLE (AOP_M0C_108 INTERACT AOP_M0_054) == 0) < 0.36
 err1 NOT INSIDE EDGE SealR_NOT_BULK
 err2 NOT INSIDE EDGE SealR_NOT_BULK
}

M0C_051_h_edges = ANGLE M0C_051 == 0
M0C_042_h_edges = ANGLE M0C_042 == 0
M0C_whole_M0C_051_h_edges = M0C TOUCH EDGE M0C_051_h_edges
M0C_whole_M0C_042_h_edges = M0C TOUCH EDGE M0C_042_h_edges

M0C_L_5 {
@ M0C (width = 0.051um) length in S/D direction, except GT_P96 region = 0.090*(n+1)um
 err1 = LENGTH M0C_whole_M0C_051_h_edges < 0.09
 err1 NOT INSIDE EDGE GT_P96

 err2 = DFM PROPERTY M0C_whole_M0C_051_h_edges M0C OVERLAP ABUT ALSO MULTI [-= ABS(REMAINDER((LENGTH(M0C_whole_M0C_051_h_edges) - 0.09), 0.09))] > 0
 err2 NOT INSIDE EDGE GT_P96
}

M0C_L_5a {
@ AOP_M0C (width = 0.051um) length in S/D direction INSIDE GT_P96 region = 0.096*(n+1)um
 chk_M0 = AOP_M0C_051 COIN EDGE AOP_M0C_h_edges
 err1 = (LENGTH chk_M0 < 0.096) NOT OUTSIDE EDGE GT_P96
 err1 NOT INSIDE EDGE SealR_NOT_BULK

 err2 = DFM PROPERTY chk_M0 AOP_M0C GT_P96 OVERLAP ABUT ALSO MULTI [-= ABS(REMAINDER((LENGTH(chk_M0) - 0.096), 0.096))] > 0 [+= count(GT_P96)] > 0
 err2 NOT INSIDE EDGE SealR_NOT_BULK
}

DOP_M0C_400_h_edges = ANGLE DOP_M0C_400 == 0
DOP_M0C_360_h_edges = ANGLE DOP_M0C_360 == 0
DOP_M0C_400_v_edges = ANGLE DOP_M0C_400 == 90
DOP_M0C_360_v_edges = ANGLE DOP_M0C_360 == 90

M0C_L_6 {
@ DOP_M0C (width = 0.36um) edge length in S/D direction = 0.18um
 err1 = LENGTH DOP_M0C_360_h_edges != 0.18
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

M0C_S_1 {
@ Space between AOP_M0C, except RSPMK1, INST, M0C (width = 0.051um) to M0C (width = 0.052um) space = 0.043um (in GATE poly direction, PRL=0um)) (overlap is not allowed) >= 0.044um
 err1 = (EXT AOP_M0C < 0.044 ABUT<90 SINGULAR REGION) NOT INTERACT (EXT M0C_051 M0C_052 == 0.043 OPPOSITE EXTENDED 0.001 PROJ == 0 REGION)
 err2 = M0C AND DOP_M0C
 err3 = M0CDMP AND M0CDOP

 err1 NOT INSIDE (OR RSPMK1 INST)
 err2 NOT INSIDE INST
 err3 NOT INSIDE INST
}

M0C_S_2 {
@ Space between AOP_M0C in GATE poly direction when PRL > 0um, except M0C space = 0.014um in RSPMK1 region >= 0.054um
 waive_typeA = (EXT M0C == 0.014 OPPOSITE REGION) INSIDE RSPMK1
 err1 = EXT AOP_M0C_h_edges AOP_M0C < 0.054 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE waive_typeA
}

M0C_S_3 {
@ Space between M0C and AOP_M0C (width = 0.048, 0.082, 0.108um) in GATE poly direction when PRL > 0um. >= 0.073um
//; waive_TMP = EXT (M0C_048 COIN EDGE M0C_h_edges) (M0C_054 COIN EDGE M0C_h_edges) == 0.065 ABUT<90 OPPOSITE REGION
 err1 = EXT M0C_h_edges ((AOP_M0C_048 OR AOP_M0C_082) OR AOP_M0C_108) < 0.073 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

M0C_S_4 {
@ Space between AOP_M0C in S/D direction >= 0.09um
 err1 = EXT AOP_M0C_v_edges AOP_M0C < 0.09 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

M0C_S_5 {
@ Space between M0C and (M0C OR M0CDMP) (width = 0.048um) in S/D direction, except INST region >= 0.18um
 err1 = EXT M0C_v_edges (DMP_M0C AND AOP_M0C_048) < 0.18 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE INST
}

M0C_S_6 {
@ Space between M0C and (M0C OR M0CDMP) (width = 0.051um) in S/D direction, except GT_P96 region = 0.09, 0.18, >= 0.27um
 err1 = EXT M0C_v_edges (AOP_M0C_051 AND DMP_M0C) < 0.090 ABUT<90 OPPOSITE REGION
 err2 = EXT M0C_v_edges (AOP_M0C_051 AND DMP_M0C) > 0.090 < 0.180 ABUT<90 OPPOSITE REGION EXCLUDE SHIELDED
 err3 = EXT M0C_v_edges (AOP_M0C_051 AND DMP_M0C) > 0.180 < 0.270 ABUT<90 OPPOSITE REGION EXCLUDE SHIELDED
 err1 NOT INSIDE GT_P96
 err2 NOT INSIDE GT_P96
 err3 NOT INSIDE GT_P96
}

M0C_S_6a {
@ Space between M0C and (M0C OR M0CDMP) (width = 0.051um) in S/D direction, INSIDE GT_P96 region = 0.096, 0.192, >= 0.288um
 err1 = (EXT M0C_v_edges (AOP_M0C_051 AND DMP_M0C) < 0.096 ABUT<90 OPPOSITE REGION) NOT OUTSIDE GT_P96
 err2 = (EXT M0C_v_edges (AOP_M0C_051 AND DMP_M0C) > 0.096 < 0.192 ABUT<90 OPPOSITE REGION EXCLUDE SHIELDED) NOT OUTSIDE GT_P96
 err3 = (EXT M0C_v_edges (AOP_M0C_051 AND DMP_M0C) > 0.192 < 0.288 ABUT<90 OPPOSITE REGION EXCLUDE SHIELDED) NOT OUTSIDE GT_P96
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
}

M0C_S_6b {
@ Space between DOP_M0C (width = 0.36um) in S/D direction when PRL > -0.36um. >= 0.18um
 err1 = EXT DOP_M0C_360_v_edges DOP_M0C_360 < 0.180 ABUT<90 OPPOSITE EXTENDED 0.36 REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

M0C_S_6c {
@ Space between DOP_M0C (width = 0.36um) in GATE poly direction when PRL > -0.18um. >= 0.36um
 err1 = EXT DOP_M0C_360_h_edges DOP_M0C_360 < 0.360 ABUT<90 OPPOSITE EXTENDED 0.18 REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

M0C_S_6d {
@ Space between DOP_M0C (width = 0.36um) and AOP_M0C (width = 0.052/0.082um) or M0CDUM >= 0.74um
 err1 = EXT (OR AOP_M0C_082 AOP_M0C_052) DOP_M0C_360 < 0.74 ABUT<90 SINGULAR REGION
 err2 = EXT M0CDUM DOP_M0C_360 < 0.74 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

M0C_S_7 {
@ Space between AOP_M0C and ALL_M0 >= 0.012um
 err1 = EXT AOP_M0C ALL_M0 < 0.012 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

M0C_S_8 {
@ Space between AOP_M0C and ALL_M0 in S/D direction >= 0.025um
 err1 = EXT ALL_M0 AOP_M0C_v_edges < 0.025 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

M0C_S_8a {
@ Space between AOP_M0C and AOP_M0 in S/D direction INSIDE GT_P96 region, except DMCB1 region >= 0.028um
 err1 = (EXT AOP_M0C_v_edges AOP_M0 < 0.028 ABUT<90 OPPOSITE REGION) NOT OUTSIDE GT_P96
 err1 NOT INSIDE DMCB1
}

M0C_S_9 {
@ Space between AOP_M0C (width = 0.082/0.108um) and ALL_M0 (width = 0.054um) in S/D direction >= 0.067um
 chk_M0C = ANGLE (AOP_M0C_082 OR AOP_M0C_108) == 90
 err1 = EXT chk_M0C ALL_M0_054 < 0.067 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

M0C_S_10 {
@ Space between DOP_M0C (width = 0.36um) and ALL_M0 (overlap is not allowed) >= 0.148um
 err1 = EXT DOP_M0C_360 ALL_M0 < 0.148 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

M0C_S_11 {
@ Space between DOP_M0C (width = 0.36um) and ALL_M0G (overlap is not allowed) >= 0.148um
 err1 = EXT DOP_M0C_360 ALL_M0G < 0.148 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

M0C_S_12 {
@ Space between M0C concave corner and (M0 AND AA), except M0C jog <= 0.002um. >= 0.054um
 M0C_rvs = DRC:1 NOT M0C
 ERR_TMP = ENC M0_AND_AA [M0C_rvs] < 0.054 ABUT<90 EXCLUDE SHIELDED
 ERR_EDG = ERR_TMP NOT COIN EDGE (LENGTH M0C_rvs <= 0.002)
 err1 = INT ERR_EDG < 0.001 ABUT==90 INTERSECTING ONLY REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

VARIABLE M0C_O_1_overlap_a 0.024
VARIABLE M0C_O_1_overlap_b 0.048

M0C_O_1 {
@ M0C (width = 0.048um) overlap ALL_M0 in GATE poly direction = 0.024, 0.048um
 err1_TMP = DFM SPACE M0C_048 ALL_M0 < M0C_O_1_overlap_a BY INT VERTICAL
 err2_TMP = DFM SPACE M0C_048 ALL_M0 > M0C_O_1_overlap_a < M0C_O_1_overlap_b BY INT VERTICAL
 err1 = DFM COPY err1_TMP REGION
 err2 = DFM COPY err2_TMP REGION  //; space = 0 is flagged by M0C_S_7
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

VARIABLE M0C_O_2_overlap_a 0.026
VARIABLE M0C_O_2_overlap_b 0.051

M0C_O_2 {
@ M0C (width = 0.051um) overlap ALL_M0 in GATE poly direction = 0.026, 0.051um
 err1_TMP = DFM SPACE M0C_051 ALL_M0 < M0C_O_2_overlap_a BY INT VERTICAL
 err2_TMP = DFM SPACE M0C_051 ALL_M0 > M0C_O_2_overlap_a < M0C_O_2_overlap_b BY INT VERTICAL
 err1 = DFM COPY err1_TMP REGION
 err2 = DFM COPY err2_TMP REGION  //; space = 0 is flagged by M0C_S_7
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

VARIABLE M0C_O_3_overlap_a 0.026
VARIABLE M0C_O_3_overlap_b 0.052

M0C_O_3 {
@ AOP_M0C (width = 0.052um) overlap ALL_M0 in GATE poly direction = 0.026, 0.052um
 err1_TMP = DFM SPACE AOP_M0C_052 ALL_M0 < M0C_O_3_overlap_a BY INT VERTICAL
 err2_TMP = DFM SPACE AOP_M0C_052 ALL_M0 > M0C_O_3_overlap_a < M0C_O_3_overlap_b BY INT VERTICAL
 err1 = DFM COPY err1_TMP REGION
 err2 = DFM COPY err2_TMP REGION  //; space = 0 is flagged by M0C_S_7
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

VARIABLE M0C_O_4_overlap_a 0.041
VARIABLE M0C_O_4_overlap_b 0.082

M0C_O_4 {
@ AOP_M0C (width = 0.082um) overlap ALL_M0 in GATE poly direction = 0.041, 0.082um
 err1_TMP = DFM SPACE AOP_M0C_082 ALL_M0 < M0C_O_4_overlap_a BY INT VERTICAL
 err2_TMP = DFM SPACE AOP_M0C_082 ALL_M0 > M0C_O_4_overlap_a < M0C_O_4_overlap_b BY INT VERTICAL
 err1 = DFM COPY err1_TMP REGION
 err2 = DFM COPY err2_TMP REGION  //; space = 0 is flagged by M0C_S_7
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

VARIABLE M0C_O_5_overlap_a 0.054
VARIABLE M0C_O_5_overlap_b 0.108

M0C_O_5 {
@ M0C (width = 0.108um) overlap ALL_M0 in GATE poly direction = 0.054, 0.108um
 err1_TMP = DFM SPACE M0C_108 ALL_M0 < M0C_O_5_overlap_a BY INT VERTICAL
 err2_TMP = DFM SPACE M0C_108 ALL_M0 > M0C_O_5_overlap_a < M0C_O_5_overlap_b BY INT VERTICAL
 err1 = DFM COPY err1_TMP REGION
 err2 = DFM COPY err2_TMP REGION  //; space = 0 is flagged by M0C_S_7
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

M0C_O_6 {
@ AOP_M0C overlap AOP_AA (INTERACT the same AOP_M0) in GATE poly direction <= 0.01um
 m0c_EDGE = AOP_M0C INSIDE EDGE AOP_AA
 m0c_GOOD = DFM SPACE AOP_AA [m0c_EDGE] <= 0.010 BY INT VERTICAL

 err1_TMP = (ANGLE m0c_EDGE == 0) NOT COIN EDGE m0c_GOOD
 err1 = err1_TMP TOUCH EDGE (err1_TMP NOT OUTSIDE EDGE AOP_M0)
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

M0C_EX_1 {
@ AOP_M0C extension outside of AOP_M0 in S/D direction, except OCOVL region = 0.025~0.102um
@ DRC only flags the outermost M0 along M0C length direction
 good_enclsure = ENC AOP_M0 [AOP_M0C_with_AOP_M0] >= 0.025 <= 0.102 OPPOSITE EXCLUDE SHIELDED  //;enclosure <= 0 is forbidden,so remove 'ABUT<90'
 err1 = (AOP_M0C_with_AOP_M0 NOT TOUCH EDGE good_enclsure) COIN EDGE AOP_M0C_v_edges
 err2 = ENC AOP_M0_v_edges AOP_M0C_with_AOP_M0 < 0.025 ABUT<90 OPPOSITE REGION EXCLUDE SHIELDED
 err1 NOT INSIDE EDGE OCOVL
 err2 NOT INSIDE OCOVL
}

AOP_M0C_GT_P96_with_M0 = AOP_M0C_GT_P96 INTERACT AOP_M0
RAW_M0C_GT_P96_with_M0 = M0C_GT_P96 INTERACT M0

M0C_EX_1a {
@ AOP_M0C extension outside of AOP_M0 in S/D direction inside GT_P96 region = 0.028~0.105um
@ DRC only flags the outermost M0 along M0C length direction
 good_enclsure = ENC AOP_M0 [AOP_M0C_GT_P96_with_M0] >= 0.028 <= 0.105 ABUT<90 OPPOSITE EXCLUDE SHIELDED
 err1 = (AOP_M0C_GT_P96_with_M0 NOT TOUCH EDGE good_enclsure) COIN EDGE AOP_M0C_v_edges
 err2 = ENC AOP_M0_v_edges AOP_M0C_GT_P96_with_M0 < 0.028 ABUT<90 OPPOSITE REGION EXCLUDE SHIELDED
 err1 NOT OUTSIDE EDGE GT_P96
 err2 NOT OUTSIDE GT_P96
}

M0C_EX_2 {
@ AOP_M0C (width = 0.048um) extension outside of AOP_M0 in S/D direction, except INST region >= 0.049um
 err1 = ENC AOP_M0_v_edges AOP_M0C_048 < 0.049 ABUT<90 OPPOSITE REGION EXCLUDE SHIELDED
 err1 NOT INSIDE INST
}

M0C_EX_3 {
@ AOP_M0C (width = 0.082/0.108um) extension outside of AOP_M0 (width = 0.054um) in S/D direction >= 0.067um
 err1 = ENC (AOP_M0_054 COIN EDGE AOP_M0_v_edges) (OR AOP_M0C_082 AOP_M0C_108) < 0.067 ABUT<90 OPPOSITE REGION EXCLUDE SHIELDED
 err1 NOT INSIDE SealR_NOT_BULK
}

M0C_EX_4 {
@ AOP_M0C extension outside of AOP_M0 in GATE poly direction, except (M0C interact TRCMK), OCOVL region >= 0.024um
 CHK_M0C = AOP_M0C NOT (M0C INTERACT TRCMK)
 err1 = ENC AOP_M0_h_edges CHK_M0C < 0.024 ABUT<90 OPPOSITE REGION EXCLUDE SHIELDED
 err1 NOT INSIDE OCOVL
}

M0C_EX_5 {
@ AOP_M0C extension outside of AOP_M0 (width = 0.054um) in GATE poly direction >= 0.041um
 err1 = ENC (AOP_M0_054 COIN EDGE AOP_M0_h_edges) AOP_M0C < 0.041 ABUT<90 OPPOSITE REGION EXCLUDE SHIELDED
 err1 NOT INSIDE SealR_NOT_BULK
}

M0C_EX_6 {
@ AOP_M0 extension outside of AOP_M0C in GATE poly direction, except OCOVL region >= 0.061um
 err1 = ENC AOP_M0C_h_edges AOP_M0 < 0.061 ABUT<90 OPPOSITE REGION EXCLUDE SHIELDED
 err1 NOT INSIDE OCOVL
}

M0C_EX_7 {
@ M0 extension outside of AOP_M0C (width = 0.048um) in GATE poly direction, except INST region >= 0.113um
 err1 = ENC AOP_M0C_048 M0_h_edges < 0.113 ABUT<90 OPPOSITE REGION EXCLUDE SHIELDED
 err1 NOT INSIDE INST
}

M0C_EX_8 {
@ AOP_M0 extension outside of AOP_M0C (width >= 0.052um) in GATE poly direction, except INST and OCOVL regions >= 0.079um
 err1 = ENC (AOP_M0C WITH WIDTH >= 0.052) AOP_M0_h_edges < 0.079 ABUT<90 OPPOSITE REGION EXCLUDE SHIELDED
 err1 NOT INSIDE INST_OCOVL
}

M0C_A_1 {
@ AOP_M0C area, except RSPMK1 and INST regions >= 0.0072um2
 err1_TMP = AREA (AOP_M0C NOT INSIDE INST) < 0.0072
 err1 = err1_TMP NOT INTERACT RSPMK1  //; AOP_M0C is allowed to straddle on RSPMK1
 err1 NOT INSIDE INST
}

M0C_A_2 {
@ AOP_M0C area when interact RSPMK1 >= 0.004um2
 err1 = AREA (AOP_M0C NOT OUTSIDE RSPMK1) < 0.004
 err1 NOT INSIDE SealR_NOT_BULK
}

AOP_M0C_NOT_MARKS = AOP_M0C NOT MARKS
ALL_M0C_NOT_MARKS = ALL_M0C NOT MARKS

#IFDEF IP_LEVEL_DENSITY_CHECK YES
#IFDEF MINIMUM_DENSITY_CHECK YES
M0C_D_1 {
@ Full chip ALL_M0C density >= 5%
 DENSITY ALL_M0C_NOT_MARKS CHIP_NOT_MARKS [AREA(ALL_M0C_NOT_MARKS)/AREA(CHIP_NOT_MARKS)] < 0.05 PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_M0C_D_1.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_M0C_D_1.rdb"
}

VARIABLE M0C_D_2_val 5.3
VARIABLE M0C_D_2_window 125

M0C_D_2 {
@ ALL_M0C density (window 125um*125um, stepping 125um/step_number), except LOGO region >= 5.3%
 check_region = CHIP_NOT_MARKS NOT LOGO
 check_pattern = ALL_M0C AND check_region

 check_window1 = check_region WITH WIDTH >= M0C_D_2_window/4
 err1_TMP1 = DENSITY check_pattern check_window1 check_region [!AREA(check_window1) + !!AREA(check_window1)*AREA(check_pattern)/AREA(check_region)] < M0C_D_2_val/100 WINDOW M0C_D_2_window STEP M0C_D_2_window/step_number BACKUP INSIDE OF LAYER DRC:1 BY POLYGON

 check_window2 = WITH WIDTH (check_region AND err1_TMP1) >= M0C_D_2_window/4
 err1_TMP2 = DENSITY check_pattern check_window2 check_region [!AREA(check_window2) + !!AREA(check_window2)*AREA(check_pattern)/AREA(check_region)] < M0C_D_2_val/100 WINDOW M0C_D_2_window STEP M0C_D_2_window/step_number BACKUP INSIDE OF LAYER err1_TMP1 BY POLYGON

 check_window3 = WITH WIDTH (check_region AND err1_TMP2) >= M0C_D_2_window/4
 DENSITY check_pattern check_window3 check_region [!AREA(check_window3) + !!AREA(check_window3)*AREA(check_pattern)/AREA(check_region)] < M0C_D_2_val/100 WINDOW M0C_D_2_window STEP M0C_D_2_window/step_number BACKUP INSIDE OF LAYER err1_TMP2 BY POLYGON PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_M0C_D_2.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_M0C_D_2.rdb"
}
#ENDIF

VARIABLE M0C_D_3_val 38
VARIABLE M0C_D_3_window 125

M0C_D_3 {
@ ALL_M0C density in window 125um*125um, stepping 125um/step_number), except INST region <= 38%
 check_region = DRC:1 NOT MARKS_INST
 check_pattern = (ALL_M0C NOT MARKS_INST) AND check_region

 check_window1 = check_region WITH WIDTH >= M0C_D_3_window/4
 err1_TMP1 = DENSITY check_pattern check_window1 check_region [!!AREA(check_window1)*AREA(check_pattern)/AREA(check_region)] > M0C_D_3_val/100 WINDOW M0C_D_3_window STEP M0C_D_3_window/step_number BACKUP INSIDE OF LAYER DRC:1 BY POLYGON

 check_window2 = WITH WIDTH (check_region AND err1_TMP1) >= M0C_D_3_window/4
 err1_TMP2 = DENSITY check_pattern check_window2 check_region [!!AREA(check_window2)*AREA(check_pattern)/AREA(check_region)] > M0C_D_3_val/100 WINDOW M0C_D_3_window STEP M0C_D_3_window/step_number BACKUP INSIDE OF LAYER err1_TMP1 BY POLYGON

 check_window3 = WITH WIDTH (check_region AND err1_TMP2) >= M0C_D_3_window/4
 DENSITY check_pattern check_window3 check_region [!!AREA(check_window3)*AREA(check_pattern)/AREA(check_region)] > M0C_D_3_val/100 WINDOW M0C_D_3_window STEP M0C_D_3_window/step_number BACKUP INSIDE OF LAYER err1_TMP2 BY POLYGON PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_M0C_D_3.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_M0C_D_3.rdb"
}
#ELSE

#IFDEF MINIMUM_DENSITY_CHECK YES
M0C_D_1 {
@ Full chip ALL_M0C density >= 5%
 DENSITY ALL_M0C_NOT_MARKS CHIP_NOT_MARKS [AREA(ALL_M0C_NOT_MARKS)/AREA(CHIP_NOT_MARKS)] < 0.05 PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_M0C_D_1.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_M0C_D_1.rdb"
}

VARIABLE M0C_D_2_val 5
VARIABLE M0C_D_2_window 125

M0C_D_2 {
@ ALL_M0C density (window 125um*125um, stepping 62.5um), except LOGO region >= 5%
 check_region = CHIP_NOT_MARKS NOT LOGO
 check_pattern = ALL_M0C AND check_region

 check_window1 = check_region WITH WIDTH >= M0C_D_2_window/4
 err1_TMP1 = DENSITY check_pattern check_window1 check_region [!AREA(check_window1) + !!AREA(check_window1)*AREA(check_pattern)/AREA(check_region)] < M0C_D_2_val/100 WINDOW M0C_D_2_window STEP M0C_D_2_window/2 BACKUP INSIDE OF LAYER DRC:1 BY POLYGON

 check_window2 = WITH WIDTH (check_region AND err1_TMP1) >= M0C_D_2_window/4
 err1_TMP2 = DENSITY check_pattern check_window2 check_region [!AREA(check_window2) + !!AREA(check_window2)*AREA(check_pattern)/AREA(check_region)] < M0C_D_2_val/100 WINDOW M0C_D_2_window STEP M0C_D_2_window/2 BACKUP INSIDE OF LAYER err1_TMP1 BY POLYGON

 check_window3 = WITH WIDTH (check_region AND err1_TMP2) >= M0C_D_2_window/4
 DENSITY check_pattern check_window3 check_region [!AREA(check_window3) + !!AREA(check_window3)*AREA(check_pattern)/AREA(check_region)] < M0C_D_2_val/100 WINDOW M0C_D_2_window STEP M0C_D_2_window/2 BACKUP INSIDE OF LAYER err1_TMP2 BY POLYGON PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_M0C_D_2.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_M0C_D_2.rdb"
}
#ENDIF

VARIABLE M0C_D_3_val 40
VARIABLE M0C_D_3_window 125

M0C_D_3 {
@ ALL_M0C density in window 125um*125um, stepping 62.5um), except INST region <= 40%
 check_region = DRC:1 NOT MARKS_INST
 check_pattern = (ALL_M0C NOT MARKS_INST) AND check_region

 check_window1 = check_region WITH WIDTH >= M0C_D_3_window/4
 err1_TMP1 = DENSITY check_pattern check_window1 check_region [!!AREA(check_window1)*AREA(check_pattern)/AREA(check_region)] > M0C_D_3_val/100 WINDOW M0C_D_3_window STEP M0C_D_3_window/2 BACKUP INSIDE OF LAYER DRC:1 BY POLYGON

 check_window2 = WITH WIDTH (check_region AND err1_TMP1) >= M0C_D_3_window/4
 err1_TMP2 = DENSITY check_pattern check_window2 check_region [!!AREA(check_window2)*AREA(check_pattern)/AREA(check_region)] > M0C_D_3_val/100 WINDOW M0C_D_3_window STEP M0C_D_3_window/2 BACKUP INSIDE OF LAYER err1_TMP1 BY POLYGON

 check_window3 = WITH WIDTH (check_region AND err1_TMP2) >= M0C_D_3_window/4
 DENSITY check_pattern check_window3 check_region [!!AREA(check_window3)*AREA(check_pattern)/AREA(check_region)] > M0C_D_3_val/100 WINDOW M0C_D_3_window STEP M0C_D_3_window/2 BACKUP INSIDE OF LAYER err1_TMP2 BY POLYGON PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_M0C_D_3.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_M0C_D_3.rdb"
}
#ENDIF

M0C_R_1 {
@ (ALL_M0 AND (ALL_AA (expanding horizontal edge by -0.01um))) overlap with ALL_M0C is not allowed, except INST region
 chk_M0 = ALL_M0 AND (SHRINK ALL_AA TOP BY 0.01 BOTTOM BY 0.01)
 err1 = chk_M0 AND ALL_M0C
 err1 NOT INSIDE INST
}

M0C_R_2 {
@ Any vertex of AOP_M0C inside ALL_M0 is not allowed, except OCOVL region
 err1 = AOP_M0C_v_edges NOT OUTSIDE EDGE ALL_M0
 err1 NOT INSIDE EDGE OCOVL
}

M0C_R_3 {
@ ALL_M0C point touch is not allowed
 err1 = EXT ALL_M0C < 0.001 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

ltu_M0C = NOT RECTANGLE ALL_M0C
ltu_M0C_convex_90_90_v_edges = ANGLE (ltu_M0C CONVEX EDGE == 2) == 90
ltu_M0C_convex_90_270_v_edges = ANGLE (ltu_M0C CONVEX EDGE == 1) == 90

VARIABLE M0C_R_4_W1 0.052
VARIABLE M0C_R_4_W2 0.108
VARIABLE M0C_R_4_JOG1 M0C_R_4_W2-M0C_R_4_W1+0.001
VARIABLE M0C_R_4_JOG2 M0C_R_4_W2-M0C_R_4_W1+0.002

M0C_R_4 {
@ ALL_M0C must be a rectangle orthogonal to grid or single L-, T-, U-, or combined L/T/U shape and at least two ALL_M0 INTERACT every segment of single L-, T-, U-, or combined L/T/U shape M0C. Single L-, T-, U-, or combined L/T/U shape M0C jog must = 0.056/0um or 0.057/0.001um or 0.058/0.002um for M0C width = 0.052/0.108um, except OCOVL region
//;all segment must combined with M0C width = 0.052/0.108um
//;rectangular M0C with one M0 is ok
//;pure L with >= 2 ALL_M0 on any one of the segment is ok
//;non-pure L: each segment must interact with >= 2 ALL_M0
//;each jog length must = 0.058/0um or 0.059/0.001um or 0.060/0.002um
//;each segment with >= 1 jog must interact with >= 2 ALL_M0
 ltu_052_branch = ltu_M0C AND M0C_052
 ltu_108_branch = (ltu_M0C NOT ltu_052_branch) AND M0C_108
 ltu_v_edges_eq_052 = LENGTH ltu_M0C_convex_90_90_v_edges == M0C_R_4_W1
 ltu_v_edges_eq_108 = LENGTH ltu_M0C_convex_90_90_v_edges == M0C_R_4_W2
 ltu_v_edges_eq_all = OR EDGE ltu_v_edges_eq_052 ltu_v_edges_eq_108

 ltu_good_edges_jog = (ltu_052_branch TOUCH EDGE ltu_108_branch) NOT COIN EDGE ltu_108_branch
 ltu_good_edges_108 = (ltu_108_branch TOUCH EDGE ltu_052_branch) LENGTH == M0C_R_4_W2
 ltu_good_edges_001 = LENGTH ltu_good_edges_jog == 0.001
 ltu_good_edges_002 = LENGTH ltu_good_edges_jog == 0.002
 ltu_good_edges_all = OR EDGE ltu_good_edges_108 (ltu_good_edges_001 OR EDGE ltu_good_edges_002)
 ltu_good_width_all = ((ltu_M0C INTERACT ltu_052_branch) INTERACT ltu_108_branch) NOT INTERACT (ltu_M0C NOT (OR M0C_052 M0C_108))
 ltu_good_width_052 = ltu_052_branch INTERACT ltu_good_width_all
 ltu_good_width_108 = ltu_108_branch INTERACT ltu_good_width_all

//;whole branch with jog
 ltu_108_branch_stagger_a = (ltu_good_width_108 WITH EDGE (LENGTH ltu_M0C_convex_90_270_v_edges >= M0C_R_4_JOG1 <= M0C_R_4_JOG2) == 1) WITH EDGE ltu_v_edges_eq_108
 ltu_108_branch_stagger_b = ltu_good_width_108 WITH EDGE (LENGTH ltu_M0C_convex_90_270_v_edges >= M0C_R_4_JOG1 <= M0C_R_4_JOG2) == 2
 ltu_108_branch_stagger = OR ltu_108_branch_stagger_a ltu_108_branch_stagger_b

 ltu_052_branch_stagger_a = (ltu_good_width_052 WITH EDGE (LENGTH ltu_M0C_convex_90_270_v_edges <= 0.002) == 1) WITH EDGE ltu_v_edges_eq_052
 ltu_052_branch_stagger_b = ltu_good_width_052 WITH EDGE (LENGTH ltu_M0C_convex_90_270_v_edges <= 0.002) == 2
 ltu_052_branch_stagger = OR ltu_052_branch_stagger_a ltu_052_branch_stagger_b

//;whole branch without any jog
 ltu_orth_part_a = (ltu_good_width_all INTERACT ltu_108_branch_stagger) NOT ltu_108_branch_stagger
 ltu_orth_part_b = (ltu_good_width_all INTERACT ltu_052_branch_stagger) NOT ltu_052_branch_stagger

 err1 = ltu_M0C NOT (OR M0C_052 M0C_108) //;segment width != 0.052/108
 err1 NOT INSIDE OCOVL

 err2 = (ltu_M0C COIN EDGE (M0C_v_edges COIN EDGE (OR M0C_052 M0C_108))) NOT COIN EDGE (ltu_v_edges_eq_all OR EDGE ltu_good_edges_all) //;segment width != 0.052/108/0.001/0.002
 err2 NOT INSIDE EDGE OCOVL

 err3 = ltu_108_branch WITH EDGE (LENGTH ltu_M0C_convex_90_270_v_edges < 0.056)  //;the 0.108um segment jog length != 0.056/0.060
 err3 NOT INSIDE OCOVL

 err4 = ltu_good_width_all NOT (ltu_good_width_all INTERACT ALL_M0 >= 2)  //;not interact any M0
 err4 NOT INSIDE OCOVL

 err5 = (ltu_good_width_052 INTERACT ALL_M0 == 1) OR (ltu_good_width_108 INTERACT ALL_M0 == 1)  //;each segment interact one M0
 err5 NOT INSIDE OCOVL

 err6 = ltu_108_branch_stagger NOT (ltu_108_branch_stagger INTERACT ALL_M0 >= 2)
 err6 NOT INSIDE OCOVL

 err7 = ltu_052_branch_stagger NOT (ltu_052_branch_stagger INTERACT ALL_M0 >= 2)
 err7 NOT INSIDE OCOVL

 err8 = ltu_orth_part_a NOT (ltu_orth_part_a INTERACT ALL_M0 >= 2)
 err9 = ltu_orth_part_b NOT (ltu_orth_part_b INTERACT ALL_M0 >= 2)
 err8 NOT INSIDE OCOVL
 err9 NOT INSIDE OCOVL

 err0 = NOT RECTANGLE (ALL_M0C NOT M0C) ORTHOGONAL ONLY
 err0 NOT INSIDE OCOVL

 ALL_M0C_h_edges_corner = ALL_M0C_h_edges COIN EDGE (EXT [ALL_M0C] < 0.0001 ABUT==90 INTERSECTING ONLY)
 ALL_M0C_h_edges_insideExtend = EXPAND EDGE ALL_M0C_h_edges_corner INSIDE BY 0.001
 ALL_M0C_h_edges_insideExtend_T = ALL_M0C_h_edges_insideExtend TOUCH ((GROW ALL_M0C TOP BY 0.001) NOT ALL_M0C)
 ALL_M0C_h_edges_insideExtend_B = ALL_M0C_h_edges_insideExtend TOUCH ((GROW ALL_M0C BOTTOM BY 0.001) NOT ALL_M0C)
 ALL_M0C_JOINT_A = ENC ALL_M0C_h_edges_insideExtend_T ALL_M0C_h_edges < 0.2 OPPOSITE REGION EXCLUDE SHIELDED
 ALL_M0C_JOINT_B = ENC ALL_M0C_h_edges_insideExtend_B ALL_M0C_h_edges < 0.2 OPPOSITE REGION EXCLUDE SHIELDED
 ALL_M0C_TP = ltu_M0C NOT (OR ALL_M0C_JOINT_A ALL_M0C_JOINT_B ALL_M0C_h_edges_insideExtend)
 err11 = OR (ALL_M0C_TP NOT INTERACT ALL_M0) (ALL_M0C_TP INTERACT ALL_M0 < 2)
 err11 NOT INSIDE OCOVL
}

M0C_R_5 {
@ DUM_M0C must be a rectangle orthogonal to grid
 err1 = NOT RECTANGLE DUM_M0C ORTHOGONAL ONLY
 err1 NOT INSIDE SealR_NOT_BULK
}

M0C_R_6 {
@ AOP_M0 (width = 0.04/0.042um, length <= 0.17um) line-end must interact AOP_M0C, except INST region
 chk_M0_040 = CONVEX EDGE AOP_M0 ANGLE1 == 90 LENGTH1 <= 0.17 ANGLE2 == 90 LENGTH2 <= 0.17 WITH LENGTH == 0.040
 chk_M0_042 = CONVEX EDGE AOP_M0 ANGLE1 == 90 LENGTH1 <= 0.17 ANGLE2 == 90 LENGTH2 <= 0.17 WITH LENGTH == 0.042
 err1 = (OR EDGE chk_M0_040 chk_M0_042) OUTSIDE EDGE AOP_M0C
 err1 NOT INSIDE EDGE INST
}

M0C_R_7 {
@ M0C (width = 0.051um) must interact RSPMK1
 err1 = M0C_051 NOT INTERACT RSPMK1
 err1 NOT INSIDE SealR_NOT_BULK
}

M0C_R_8 {
@ M0C must interact M0, floating M0C is not allowed, except OCOVL region
 err1 = M0C NOT INTERACT M0
 err1 NOT INSIDE OCOVL
}

// =======================================================
// M0G: Local interconnect layer 3 design rules
// =======================================================

GROUP GM0G M0G_?

#IFDEF MANUFACTURABILITY_ENHANCEMENT_RULES YES
M0G_S_1c_ME {
@ Space between the short side of AOP_M0G (width = 0.04um) when PRL > -0.02um (DOP_M0G overlap with M0G is not allowed), except INST region >= 0.078um
 err1 = EXT AOP_M0G_040_W_sides < 0.078 ABUT<90 OPPOSITE EXTENDED 0.02 REGION
 err2 = DOP_M0G AND M0G
 err1 NOT INSIDE INST
 err2 NOT INSIDE INST
}

M0G_S_3a_ME {
@ Center-to-center space between M0G (width = 0.05um), except INST region. DRC only flag opposite space >= 0.102um
 err1_corner = EXT m0g_050_center < 0.102-0.0002 ABUT<90 OPPOSITE REGION
 err1 = (EXT m0g_050_center < 0.102-0.0003 ABUT<90 CORNER TO CORNER REGION) OR err1_corner
 err1 NOT INSIDE INST
}

M0G_S_3b_ME {
@ Center-to-center space between M0G (width = 0.05um) when PRL < 0.05um, except INST region >= 0.106um
 err1_corner = EXT m0g_050_center < 0.106-0.0002 ABUT<90 OPPOSITE REGION PROJ<0.0002
 err1 = (EXT m0g_050_center < 0.106-0.0003 ABUT<90 CORNER TO CORNER REGION) OR err1_corner
 err1 NOT INSIDE INST
}

M0G_S_7a_ME {
@ Space between M0G and AOP_AA (Overlap is not allowed, except OCCD or ((M0G AND AOP_AA) INTERACT M0)) (Except M0G.S.7b.ME, INST region) >= 0.039um
 EDG_WAIVE_7b = ANGLE M0G_S_7a_7b_Chk == 0
 EDG_WAIVE_M0 = EXT [EDG_WAIVE_7b] AOP_AA >= 0.019 < 0.039 ABUT<90
 EDG_WAIVE_AA = EXT EDG_WAIVE_7b [AOP_AA] >= 0.019 < 0.039 ABUT<90
 EDG_CHECK = (M0G_S_7a_7b_Chk NOT COIN EDGE EDG_WAIVE_M0) NOT COIN EDGE M0G_in_AOP_AA_interact_M0
 err1 = EXT (ANGLE EDG_CHECK == 90) (AOP_AA NOT COIN EDGE EDG_WAIVE_AA) < 0.039 ABUT<90 REGION
 err1 NOT INSIDE INST_OCCD

 err2 = M0G_S_7a_7b_Chk AND AOP_AA
 err2 NOT INSIDE INST_OCCD
}

M0G_S_7b_ME {
@ Space between M0G and AOP_AA in GATE poly direction (Overlap is not allowed) >= 0.019um
@ Except OCCD, INST, or M0G and AA interact same (M0 NOT M0C)
 waive_1 = (ANGLE (CONVEX EDGE (OR M0G AA M0_NOT_M0C) == 0) == 90) COIN EDGE M0_NOT_M0C
 waive_2 = ((EXPAND EDGE waive_1 OUTSIDE BY 0.001) TOUCH AA) TOUCH M0G
 waive_3 = AOP_AA NOT TOUCH EDGE waive_2
 waive_4 = (ANGLE M0G_S_7a_7b_Chk == 0) NOT TOUCH EDGE waive_2
 err1 = (EXT (ANGLE M0G_S_7a_7b_Chk == 0) waive_3 < 0.019 ABUT>0<90 REGION) OR (EXT waive_4 AOP_AA < 0.019 ABUT>0<90 REGION)
 err1 NOT INSIDE INST_OCCD

 err2 = (M0G_S_7a_7b_Chk COIN EDGE M0G) COIN EDGE AA_h_edges
 err2 NOT INSIDE EDGE INST_OCCD

 err3 = M0G_S_7a_7b_Chk AND AOP_AA
 err3 NOT INSIDE INST_OCCD

 err4 = M0G INTERACT AOP_AA SINGULAR ONLY
 err4 NOT INSIDE INST_OCCD
}

M0G_S_10a_ME {
@ Space between M0G (width = 0.04/0.06um, not interact AA) to AOP_GT in GT_P96 region, except INST region >= 0.031um
 err1_TMP = EXT AOP_GT ((OR M0G_040 M0G_060) NOT INTERACT AA) < 0.031 ABUT<90 SINGULAR REGION
 err1 = err1_TMP NOT OUTSIDE GT_P96
 err1 NOT INSIDE INST
}

M0G_S_21a_ME {
@ Space between long side of M0G (width = 0.04/0.06/0.09um) and short side of M0 (short side NOT INTERACT M0C) when PRL >= -0.018um. >= 0.035um
@ Which rule is not applied for INST region and 7.5T standard cell design
 err1_TMP = EXT M0G_040_L_edges M0_W_edges_outside_M0C < 0.035 ABUT<90 OPPOSITE EXTENDED 0.018+GLOBAL_TOLERANCE REGION
 err2_TMP = EXT M0G_060_L_edges M0_W_edges_outside_M0C < 0.035 ABUT<90 OPPOSITE EXTENDED 0.018+GLOBAL_TOLERANCE REGION
 err3_TMP = EXT M0G_090_L_edges M0_W_edges_outside_M0C < 0.035 ABUT<90 OPPOSITE EXTENDED 0.018+GLOBAL_TOLERANCE REGION
 err1 = err1_TMP NOT INSIDE (PowerRail_Area_75T AND STDB_all)
 err2 = err2_TMP NOT INSIDE (PowerRail_Area_75T AND STDB_all)
 err3 = err3_TMP NOT INSIDE (PowerRail_Area_75T AND STDB_all)
 err1 NOT INSIDE INST
 err2 NOT INSIDE INST
 err3 NOT INSIDE INST
}

M0G_S_21a1_ME {
@ Space between long side of M0G (width = 0.04/0.06/0.09um) and short side of M0 (short side NOT INTERACT M0C) when PRL >= -0.018um, for 7.5T standard cell design >= 0.032um
@ Which rule is not applied for INST region
 err1_TMP = EXT M0G_040_L_edges M0_W_edges_outside_M0C < 0.032 ABUT<90 OPPOSITE EXTENDED 0.018+GLOBAL_TOLERANCE REGION
 err2_TMP = EXT M0G_060_L_edges M0_W_edges_outside_M0C < 0.032 ABUT<90 OPPOSITE EXTENDED 0.018+GLOBAL_TOLERANCE REGION
 err3_TMP = EXT M0G_090_L_edges M0_W_edges_outside_M0C < 0.032 ABUT<90 OPPOSITE EXTENDED 0.018+GLOBAL_TOLERANCE REGION
 err1 = err1_TMP NOT OUTSIDE (PowerRail_Area_75T AND STDB_all)
 err2 = err2_TMP NOT OUTSIDE (PowerRail_Area_75T AND STDB_all)
 err3 = err3_TMP NOT OUTSIDE (PowerRail_Area_75T AND STDB_all)
 err1 NOT INSIDE INST
 err2 NOT INSIDE INST
 err3 NOT INSIDE INST
}

M0G_S_25a_ME {
@ Space between M0G (width = 0.05um) and the short side of M0 (short side NOT INTERACT M0C) when PRL >= -0.018um. >= 0.03um
@ Which rule is not applied for INST region
 err1 = EXT M0G_050 (M0_W_edges OUTSIDE EDGE M0C) < 0.03 ABUT<90 OPPOSITE EXTENDED 0.018+GLOBAL_TOLERANCE REGION
 err1 NOT INSIDE INST
}
#ENDIF

M0G_W_1 {
@ M0G width, except OCOVL region = 0.04, 0.05~0.055, 0.06, 0.088um
 check_M0G = M0G NOT INSIDE OCOVL
 err1 = INT check_M0G < 0.04 ABUT<90 SINGULAR REGION
 err2 = WITH WIDTH check_M0G > 0.040 < 0.050
 err3 = WITH WIDTH check_M0G > 0.055 < 0.060
 err4 = WITH WIDTH check_M0G > 0.060 < 0.088
 err5 = WITH WIDTH check_M0G > 0.088

 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
 err4 NOT INSIDE SealR_NOT_BULK
 err5 NOT INSIDE SealR_NOT_BULK
}

M0G_L_1 {
@ AOP_M0G (width = 0.04um) length, except INST region = 0.102~0.33um
 err1 = OR (AOP_M0G_WIDTH_040 NOT WITH EDGE (LENGTH AOP_M0G >= 0.102 <= 0.33)) ((AOP_M0G WITH EDGE (LENGTH AOP_M0G == 0.040)) WITH EDGE (LENGTH AOP_M0G < 0.040))
 err1 NOT INSIDE INST
}

M0G_L_2_2_1 {
@ M0G.L.2: M0G (width = 0.05um) length (in S/D direction), except GT_P96 region = 0.050, 0.057~0.058um
@ M0G.L.2a: M0G (width = 0.05um) length (in S/D direction), inside GT_P96 = 0.050, 0.060~0.061um
@ M0G.L.2b: AOP_M0G (width = 0.05um) length, except 0.05*(0.057~0.058)um and 0.05*(0.06~0.061)um M0G = 0.05um
 good_GTP90 = (M0G_050_VERTICAL WITH EDGE (OR EDGE (LENGTH M0G_h_edges == 0.050) (LENGTH M0G_h_edges >= 0.057 <= 0.058))) NOT INSIDE GT_P96
 good_GTP96 = (M0G_050_VERTICAL WITH EDGE (OR EDGE (LENGTH M0G_h_edges == 0.050) (LENGTH M0G_h_edges >= 0.060 <= 0.061))) NOT OUTSIDE GT_P96
 good_DUM_M0G = (AOP_M0G_050 NOT M0G_050) NOT WITH EDGE (LENGTH AOP_M0G != 0.050)
 err1 = M0G_050_VERTICAL NOT (OR good_GTP90 good_GTP96)  //;based on M0G.R.2a
 err2 = (AOP_M0G_050 NOT M0G_050) NOT good_DUM_M0G
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

M0G_L_3 {
@ AOP_M0G (width = 0.06um) length, except length = 0.148~200um M0G inside RESP1 = 0.095~0.096, 0.198~200um
 WAIVE_AREA = (M0G_WIDTH_060 WITH EDGE (LENGTH AOP_M0G >= 0.148 <= 200)) INSIDE RESP1
 err1 = (AOP_M0G_WIDTH_060 NOT WAIVE_AREA) NOT WITH EDGE ((LENGTH AOP_M0G >= 0.095 <= 0.096) OR EDGE (LENGTH AOP_M0G >= 0.198 <= 200))
 err1 NOT INSIDE SealR_NOT_BULK
}

M0G_L_4_4_1 {
@ M0G.L.4: M0G (width = 0.088um) length (in S/D direction), except GT_P96 region = 0.102~0.104um
@ M0G.L.5: M0G (width = 0.088um) length (in S/D direction), inside GT_P96 = 0.108~0.110um
 good_GTP90 = (M0G_088_VERTICAL WITH EDGE (OR EDGE (LENGTH M0G_h_edges == 0.051) (LENGTH M0G_h_edges >= 0.102 <= 0.104))) NOT INSIDE GT_P96
 good_GTP96 = (M0G_088_VERTICAL WITH EDGE (OR EDGE (LENGTH M0G_h_edges == 0.054) (LENGTH M0G_h_edges >= 0.108 <= 0.110))) NOT OUTSIDE GT_P96
 err1 = (M0G_088_VERTICAL NOT good_GTP90) NOT good_GTP96
 err2 = INT M0G_v_edges == 0.088 OPPOSITE REGION EXCLUDE SHIELDED  //;based on M0G.R.2a/2b
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

AOP_M0G_v_edges_eq_090 = LENGTH AOP_M0G_v_edges == 0.090
AOP_M0G_v_edges_eq_091 = LENGTH AOP_M0G_v_edges == 0.091
AOP_M0G_v_edges_eq_065 = LENGTH AOP_M0G_v_edges == 0.065

M0G_L_6 {
@ AOP_M0G (width = 0.051~0.055um) length in GATE poly direction = 0.09~0.091um
 err1 = (INT AOP_M0G_v_edges >= 0.051 <= 0.055 OPPOSITE REGION) NOT WITH EDGE (OR EDGE AOP_M0G_v_edges_eq_090 AOP_M0G_v_edges_eq_091)
 err2 = INT M0G_h_edges >= 0.051 <= 0.055 OPPOSITE REGION  //; based on M0G.R.2b
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

M0G_S_1 {
@ Space between AOP_M0G (except width = 0.05um) to AOP_M0G >= 0.058um
 err1 = EXT (AOP_M0G NOT AOP_M0G_050) AOP_M0G < 0.058 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

M0G_S_1a {
@ Space between AOP_M0Gs (width = 0.04um) >= 0.058um
 err1 = EXT AOP_M0G_040 < 0.058 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

M0G_S_1b {
@ Space between AOP_M0G (width = 0.04um) and AOP_M0G (with = 0.04um) when PRL >= -0.019um, except INST region >= 0.065um
 err1 = EXT AOP_M0G_040 < 0.065 ABUT<90 OPPOSITE EXTENDED 0.019+GLOBAL_TOLERANCE REGION
 err1 NOT INSIDE INST
}

AOP_M0G_040_L_sides = INT [AOP_M0G_040] == 0.04 ABUT<90 OPPOSITE
AOP_M0G_040_W_sides = AOP_M0G_040 NOT TOUCH EDGE AOP_M0G_040_L_sides
M0G_040_L_sides = INT [M0G_040] == 0.04 ABUT<90 OPPOSITE
M0G_040_W_sides = M0G_040 NOT TOUCH EDGE M0G_040_L_sides

M0G_S_1c {
@ Space between the short side of AOP_M0G (width = 0.04um) when PRL >= -0.019um. >= 0.076um
 err1 = EXT AOP_M0G_040_W_sides < 0.076 ABUT<90 OPPOSITE EXTENDED 0.019+GLOBAL_TOLERANCE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

M0G_S_1d {
@ Space between the short side of M0G (width = 0.04um, and length = 0.121~0.161um or 0.223~0.249um, and PRL >= -0.02um) >= 0.082um
@ Except:
@ Space between the short side of M0G (width = 0.04um, and length = 0.121~0.161um or 0.223~0.249um, and PRL >= -0.02um) and (M0 NOT M0C) >= 0.03um
 good_M0G_L1 = LENGTH M0G_040_L_sides >= 0.121 <= 0.161
 good_M0G_L2 = LENGTH M0G_040_L_sides >= 0.223 <= 0.249
 good_M0G_W = M0G_040 WITH EDGE (good_M0G_L1 OR EDGE good_M0G_L2)
 chk_M0G_W = EXT [good_M0G_W] M0_NOT_M0C < 0.03 ABUT<90 OPPOSITE EXTENDED 0.02+GLOBAL_TOLERANCE
 err1 = EXT (good_M0G_W TOUCH EDGE chk_M0G_W) good_M0G_W < 0.082 ABUT<90 OPPOSITE EXTENDED 0.02+GLOBAL_TOLERANCE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

M0G_S_1e {
@ Space between AOP_M0G (width = 0.04um and length >= 0.12um) long side and AOP_M0G (width = 0.04um) when PRL >= -0.019um. >= 0.084um
 chk_M0G_L = LENGTH AOP_M0G_040_L_sides >= 0.12
 err1 = EXT chk_M0G_L AOP_M0G_040 < 0.084 ABUT<90 OPPOSITE EXTENDED 0.019+GLOBAL_TOLERANCE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

M0G_S_1f {
@ Space between AOP_M0G (width = 0.04um) and AOP_M0G (width = 0.05um), except M0G.S.1g >= 0.064um
 err1 = EXT (AOP_M0G_040 NOT M0G) AOP_M0G_050 < 0.064 ABUT<90 SINGULAR REGION
 err2 = EXT (AOP_M0G_050 NOT M0G) AOP_M0G_040 < 0.064 ABUT<90 SINGULAR REGION
 err3 = EXT M0G_040 M0G_050 < 0.064 ABUT<90 SINGULAR REGION PROJ>=0
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
}

M0G_S_1g {
@ Space between M0G (width = 0.04um) to M0G (width = 0.05um) when PRL < 0um. >= 0.058um
 err1 = EXT M0G_040 M0G_050 < 0.058 ABUT<90 SINGULAR REGION NOT PROJ
 err1 NOT INSIDE SealR_NOT_BULK
}

M0G_S_1h {
@ Space between the short side of M0G (width = 0.04um) and AOP_M0G (with = 0.05um) when PRL >= -0.016um. >= 0.068um
 err1 = EXT M0G_040_W_sides AOP_M0G_050 < 0.068 ABUT<90 OPPOSITE EXTENDED 0.016+GLOBAL_TOLERANCE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

M0G_S_2 {
@ Space between M0G (width = 0.05, length = 0.057~0.058um) and AOP_M0G when PRL >= -0.074um. >= 0.073um
 err1 = EXT (OR M0G_W050_L057 M0G_W050_L058) AOP_M0G < 0.073 ABUT<90 OPPOSITE EXTENDED 0.074+GLOBAL_TOLERANCE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

M0G_S_3a {
@ Space between the center of AOP_M0G (width = 0.05um) and center of AOP_M0G (width = 0.05um) (Except M0G group in M0G.S.3c) >= 0.105um
 chk_center = EXTENTS (AOP_M0G_050 NOT m0g_group) CENTERS 0.0002
 err1 = EXT chk_center < 0.105-0.0002 ABUT<90 PROJ>=0 REGION
 err2 = EXT chk_center < 0.105-0.0003 ABUT<90 CORNER TO CORNER REGION
 err3_special = (EXT m0g_050_center < 0.105-0.0002 ABUT<90 PROJ>=0 REGION) INTERACT m0g_group_TMP > 1  //;space between M0G in two diff M0G group
 err3 = ((EXT m0g_050_center < 0.105-0.0003 ABUT<90 CORNER TO CORNER REGION) INTERACT m0g_group_TMP > 1) OR err3_special  //;space between M0G in two diff M0G group
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
}

M0G_S_3b {
@ Space between the center of M0G (width = 0.05um) and any one center of 3-neighboring M0G (width = 0.05um, center to center space <= 0.119um) >= 0.119um
 err1 = WITH NEIGHBOR m0g_050_center >= 3 SPACE < 0.119-0.0002
 err1 NOT INSIDE SealR_NOT_BULK
}

//;Definition of M0G group
m0g_050_center = EXTENTS M0G_050 CENTERS 0.0002
m0g_050_center_edge = EXT [m0g_050_center] >= 0.098-0.0002 <= 0.104-0.0002 ABUT<90
m0g_group_STEP_1 = M0G_050 ENCLOSE (EXPAND EDGE m0g_050_center_edge OUTSIDE BY 0.005)
m0g_group_STEP_2 = ANGLE m0g_group_STEP_1 == 90
m0g_group_STEP_3 = EXT [m0g_group_STEP_2] > 0.001 <= 0.104-0.05 ABUT<90 OPPOSITE
m0g_group_STEP_4 = DFM PROPERTY m0g_group_STEP_3 m0g_group_STEP_1 OVERLAP ABUT ALSO MULTI [-= LENGTH(m0g_group_STEP_3)] == 0.05
m0g_group_STEP_5 = EXT m0g_group_STEP_4 > 0.001 <= 0.104-0.05 OPPOSITE REGION
m0g_group_TMP = (m0g_group_STEP_1 OR m0g_group_STEP_5) INTERACT m0g_group_STEP_1 > 1 <= 5
m0g_group = m0g_group_STEP_1 INTERACT m0g_group_TMP

m0g_group_v_edges = ANGLE m0g_group == 90
m0g_group_h_edges = ANGLE m0g_group == 0

M0G_S_3c {
@ Space between M0G group and AOP_M0G >= 0.079um
@ Definition of M0G group:
@ 1) M0G width = 0.05um, and
@ 2) M0G with PRL = 0.05um in vertical direction
@ 3) 0.098um <= Center to center space <= 0.104um
@ 4) The maximum M0G number in one group is 5
//;Only check the opposite spacing PRL>=0
 chk_M0G = LENGTH m0g_group_TMP > 0  //; == 0.05
 err1 = EXT chk_M0G (M0G NOT INTERACT m0g_group_TMP) < 0.079 ABUT<90 OPPOSITE EXTENDED 0.0002 REGION
 err2 = EXT chk_M0G DOP_M0G < 0.079 ABUT<90 OPPOSITE EXTENDED 0.0002 REGION
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

M0G_S_3d {
@ Space between M0G group and AOP_M0G (width = 0.04um) in horizontal direction when PRL >= -0.079um. >= 0.114um
@ Definition of M0G group follows M0G.S.3c
 err1 = EXT m0g_group_v_edges AOP_M0G_040 < 0.114 ABUT<90 OPPOSITE EXTENDED 0.079+GLOBAL_TOLERANCE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

M0G_S_3e {
@ Space between M0G group and AOP_M0G (width = 0.04/0.05um) in vertical direction when PRL >= -0.079um. >= 0.103um
@ Definition of M0G group follows M0G.S.3c
 err1 = EXT m0g_group_h_edges AOP_M0G_040 < 0.103 ABUT<90 OPPOSITE EXTENDED 0.079+GLOBAL_TOLERANCE REGION
 err2 = (EXT m0g_group_h_edges AOP_M0G_050 < 0.103 ABUT<90 OPPOSITE EXTENDED 0.079+GLOBAL_TOLERANCE REGION) NOT INSIDE m0g_group_TMP
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

M0G_060_L_v_edges = ANGLE M0G_060_L_edges == 90
M0G_060_L_h_edges = ANGLE M0G_060_L_edges == 0

M0G_S_4a {
@ Space between M0G (width = 0.06um) and M0G, except OCOVL region >= 0.129um
@ (Except M0G_S_4b, and the space between M0G (width = 0.06um) long side and M0G when PRL >= -0.08um < 0um)
//; Exclude space between M0G (width = 0.06um) long side and M0G when PRL >= -0.080um < 0um
 y1 = EXT M0G_060 M0G >= 0.102 < 0.129 ABUT<90 CORNER TO CORNER
 y2 = DFM PROPERTY y1 M0G_060_L_v_edges M0G_060_L_h_edges ABUT ALSO OVERLAP MULTI
  [-= ((EWXP(y1) >= 0.08 && count(M0G_060_L_v_edges) > 0) || (EWYP(y1) >= 0.08 && count(M0G_060_L_h_edges) > 0)) ? 1 : 0] > 0
 err1 = DFM COPY y2 REGION
 err2 = EXT M0G_060_L_edges M0G < 0.129 ABUT<90 REGION PROJ>=0
 err1 NOT INSIDE OCOVL
 err2 NOT INSIDE OCOVL
}

M0G_S_4b {
@ Space between M0G (width = 0.06um) short side and M0G when PRL in width direction >= -0.08um. >= 0.101um
 err1 = EXT M0G_060_eq_060_edges M0G < 0.101 ABUT<90 OPPOSITE EXTENDED 0.08+GLOBAL_TOLERANCE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

M0G_S_4c {
@ Space between DOP_M0G (width = 0.06um) and AOP_M0G >= 0.129um
 err1 = EXT DOP_M0G_060 AOP_M0G < 0.129 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

M0G_S_4d {
@ Space between short side of M0G (width = 0.06um) and AOP_M0G (width = 0.05um) when PRL >= -0.075um. >= 0.106um
 err1 = EXT M0G_060_eq_060_edges AOP_M0G_050 < 0.106 ABUT<90 OPPOSITE EXTENDED 0.075+GLOBAL_TOLERANCE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

M0G_S_4e {
@ Space between AOP_M0G (width/length = 0.06/0.095~0.096um) and ALL_M0G >= 0.142um
 err1 = EXT AOP_M0G_W060_L095_L096 ALL_M0G < 0.142 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

M0G_S_5a {
@ Space between M0G (width = 0.051~0.053/0.054~0.055/0.088um) and AOP_M0G (width = 0.05um) in vertical direction when PRL >= -0.015um. >= 0.069um
 err1 = EXT M0G_051_To_055_088_h_edges AOP_M0G_050 < 0.069 ABUT<90 OPPOSITE EXTENDED 0.015+GLOBAL_TOLERANCE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

M0G_S_5b {
@ Space between M0G (width = 0.051~0.053/0.054~0.055/0.088um) and AOP_M0G (width = 0.04um, PRL >= -0.015) in vertical direction >= 0.065um
 err1 = EXT M0G_051_To_055_088_h_edges AOP_M0G_040 < 0.065 ABUT<90 OPPOSITE EXTENDED 0.015+GLOBAL_TOLERANCE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

M0G_S_5c {
@ Space between M0G (width = 0.051~0.053/0.054~0.055/0.088um) and AOP_M0G (width = 0.05/0.088um) in horizontal direction when PRL > 0um. >= 0.077um
 err1 = EXT M0G_051_To_055_088_v_edges AOP_M0G_050 < 0.077 ABUT<90 OPPOSITE REGION
 err2 = EXT M0G_051_To_055_088_v_edges AOP_M0G_088 < 0.077 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

M0G_S_5d {
@ Space between M0G (width = 0.051~0.053/0.054~0.055/0.088um) and AOP_M0G (width = 0.04um, PRL >= -0.015) in horizontal direction >= 0.077um
 err1 = EXT M0G_051_To_055_088_v_edges AOP_M0G_040 < 0.077 ABUT<90 OPPOSITE EXTENDED 0.015+GLOBAL_TOLERANCE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

M0G_S_5e {
@ Space between M0G (width = 0.051~0.053/0.054~0.055/0.088um) in vertical direction when PRL > 0um. >= 0.083um
 err1 = EXT M0G_051_To_055_088_h_edges < 0.083 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

M0G_S_5f {
@ Corner space between M0G (width = 0.051~0.053/0.054~0.055/0.088um) and AOP_M0G (width = 0.04um, PRL <= -0.016um) >= 0.069um
 err1_RAW = EXT M0G_051_To_055_088 AOP_M0G_040 < 0.069 ABUT<90
 err1_TMP = DFM PROPERTY err1_RAW [-= (EWXP(err1_RAW) >= 0.016 && EWYP(err1_RAW) >= 0.016) ? 1 : 0] > 0
 err1 = DFM COPY err1_TMP REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

M0G_S_5g {
@ Corner space between M0G (width = 0.051~0.053/0.054~0.055/0.088um) when PRL <= 0um. >= 0.091um
 err1 = EXT M0G_051_To_055_088 < 0.091 ABUT<90 CORNER TO CORNER SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

M0G_S_6a {
@ Space between DOP_M0G and (AOP_M0G INSIDE DG) >= 0.046um
 err1 = EXT DOP_M0G (AOP_M0G INSIDE DG) < 0.046 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

M0G_in_AOP_AA_interact_M0 = AOP_M0G_AND_AOP_AA INTERACT M0
M0G_S_7a_7b_Chk = AOP_M0G NOT INTERACT M0G_in_AOP_AA_interact_M0

M0G_S_7a {
@ Space between AOP_M0G and AOP_AA (AA vertical edge extend 1/2 GT) >= 0.029um
@ (Overlap is not allowed, except (AOP_M0G AND AOP_AA) INTERACT M0), except (the space >= 0.013 in GATE poly direction) and INST region
@ DRC waive the space or overlap between DUM_M0G and DUM_AA
 EDG_WAIVE_7b = ANGLE M0G_S_7a_7b_Chk == 0
 EDG_WAIVE_M0 = EXT [EDG_WAIVE_7b] edge_gate_aopAA_all >= 0.013 < 0.029 ABUT<90
 EDG_WAIVE_AA = EXT EDG_WAIVE_7b [edge_gate_aopAA_all] >= 0.013 < 0.029 ABUT<90
 M0G_CHECK = (M0G_S_7a_7b_Chk NOT COIN EDGE EDG_WAIVE_M0) NOT COIN EDGE M0G_in_AOP_AA_interact_M0
 AAs_CHECK = edge_gate_aopAA_all NOT COIN EDGE EDG_WAIVE_AA
 err1 = OR (EXT (M0G_CHECK COIN EDGE M0G) AAs_CHECK < 0.029 ABUT<90 REGION) (EXT (M0G_CHECK NOT COIN EDGE M0G) (AAs_CHECK COIN EDGE edge_gate_AA_all) < 0.029 ABUT<90 REGION)
 err1 NOT INSIDE INST

 err2 = OR ((M0G_S_7a_7b_Chk INTERACT M0G) AND AOP_AA) ((M0G_S_7a_7b_Chk NOT INTERACT M0G) AND AA)
 err2 NOT INSIDE INST
}

M0G_S_7b {
@ Space between AOP_M0G and AOP_AA in GATE poly direction (Overlap is not allowed, except (AOP_M0G AND AOP_AA) INTERACT M0), except INST region >= 0.013um
@ DRC waive the space or overlap between DUM_M0G and DUM_AA
 M0G_CHECK = ANGLE M0G_S_7a_7b_Chk == 0
 err1 = OR (EXT (M0G_CHECK COIN EDGE M0G) AOP_AA < 0.013 ABUT>0<90 REGION) (EXT (M0G_CHECK NOT COIN EDGE M0G) AA < 0.013 ABUT>0<90 REGION)
 err2 = OR EDGE ((M0G_S_7a_7b_Chk COIN EDGE M0G) COIN EDGE AOP_AA_h_edges) ((M0G_S_7a_7b_Chk NOT COIN EDGE M0G) COIN EDGE AA_h_edges)
 err1 NOT INSIDE INST
 err2 NOT INSIDE EDGE INST

 err3 = OR ((M0G_S_7a_7b_Chk INTERACT M0G) AND AOP_AA) ((M0G_S_7a_7b_Chk NOT INTERACT M0G) AND AA)
 err4 = M0G INTERACT AOP_AA SINGULAR ONLY
 err3 NOT INSIDE INST
 err4 NOT INSIDE INST
}

M0G_S_8a {
@ Space between M0G (width = 0.06um) and AOP_AA (AA vertical edge extend 1/2 GT), except (the space >= 0.031 in GATE poly direction) >= 0.049um
 WAIVE_M0_side = EXT [M0G_060_h_edges] edge_gate_aopAA_all >= 0.031 <= 0.049 ABUT<90
 WAIVE_AA_side = EXT M0G_060_h_edges [edge_gate_aopAA_all] >= 0.031 <= 0.049 ABUT<90
 CHECK_M0 = M0G_060 NOT COIN EDGE WAIVE_M0_side
 err1 = EXT (edge_gate_aopAA_all NOT COIN EDGE WAIVE_AA_side) CHECK_M0 < 0.049 ABUT<90 REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

M0G_S_8b {
@ Space between M0G (width = 0.06um) and AOP_AA in GATE poly direction >= 0.031um
 err1 = EXT M0G_060_h_edges AOP_AA < 0.031 ABUT<90 REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

M0G_S_9 {
@ Space between M0G (width = 0.06um) and concave edge of L-shape AA edge (AA vertical edge extend 1/2GT) in S/D direction >= 0.069um
 err1 = EXT (CONVEX EDGE edge_gate_AA_all == 1) M0G_060_v_edges < 0.069 ABUT<90 REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

M0G_S_10a {
@ Space between AOP_M0G and AOP_GT, except AOP_GT jog <= 0.004um and OCOVL region >= 0.028um
 err1 = EXT AOP_M0G (AOP_GT NOT COIN EDGE AOP_GT_jog_lteq_004) < 0.028 ABUT<90 REGION
 err2 = AOP_M0G INTERACT AOP_GT SINGULAR ONLY
 err1 NOT INSIDE OCOVL
 err2 NOT INSIDE OCOVL
}

pitch090_centerline = INT AOP_GT >= 0.018 <= 0.020 OPPOSITE REGION CENTERLINE 0.002
pitch106_centerline = INT AOP_GT == 0.036 OPPOSITE REGION CENTERLINE 0.002
pitch090_design = DFM COPY (DFM SPACE pitch090_centerline == 0.090-0.002 BY EXT HORIZONTAL) REGION
pitch106_design = DFM COPY (DFM SPACE pitch106_centerline == 0.106-0.002 BY EXT HORIZONTAL) REGION

M0G_S_10b {
@ Space between AOP_M0G and AOP_GT (width >= 0.07um) >= 0.038um
 err1 = EXT AOP_M0G AOP_GT_eqgt_070 < 0.038 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

M0G_S_10c {
@ Space between AOP_M0G and AOP_GT line end >= 0.034um
 err1 = EXT AOP_M0G AOP_GT_h_edges < 0.034 ABUT<90 REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

M0G_S_11 {
@ Space between M0G and ALL_GT (width <= 0.024um, the side space to ALL_GT >= 0.08um), except GT_P96 and small AOP_GT jog <= 0.004um. >= 0.049um
 chk_GT_sides_space_eqgt_080 = EXT (ALL_GT_eqlt_024_edges) ALL_GT < 0.080 ABUT<90 OPPOSITE
 // chk_GT_sides_space_eqlt_080 = EXT [ALL_GT_eqlt_024_edges] ALL_GT < 0.080 ABUT<90 OPPOSITE
 chk_GT_sides_region_eqgt_080 = INT chk_GT_sides_space_eqgt_080 <= 0.024 OPPOSITE REGION
 // chk_GT_sides_region_eqlt_080 = INT chk_GT_sides_space_eqgt_080 chk_GT_sides_space_eqlt_080 <= 0.024 OPPOSITE REGION
 chk_M0G_sides = ((M0G NOT ALL_GT) TOUCH (M0G AND ALL_GT)) COIN EDGE M0G_v_edges
 chk_GT_sides = (ALL_GT_eqlt_024_edges COIN EDGE chk_GT_sides_region_eqgt_080) NOT COIN EDGE AOP_GT_jog_lteq_004
 err1 = EXT chk_M0G_sides chk_GT_sides < 0.049 ABUT<90 REGION
 err1 NOT INSIDE GT_P96
}

M0G_S_11a {
@ Space between M0G and ALL_GT (width = 0.032um, the side space to ALL_GT >= 0.08um), except GT_P96 and small AOP_GT jog <= 0.004um. >= 0.051um
 chk_GT_sides_space_eqgt_080 = EXT (ALL_GT_032_v_edges) ALL_GT < 0.080 ABUT<90 OPPOSITE
 // chk_GT_sides_space_eqlt_080 = EXT [ALL_GT_032_v_edges] ALL_GT < 0.080 ABUT<90 OPPOSITE
 chk_GT_sides_region_eqgt_080 = INT chk_GT_sides_space_eqgt_080 == 0.032 OPPOSITE REGION
 // chk_GT_sides_region_eqlt_080 = INT chk_GT_sides_space_eqgt_080 chk_GT_sides_space_eqlt_080 == 0.032 OPPOSITE REGION
 chk_M0G_sides = ((M0G NOT ALL_GT) TOUCH (M0G AND ALL_GT)) COIN EDGE M0G_v_edges
 chk_GT_sides = (ALL_GT_032_v_edges COIN EDGE chk_GT_sides_region_eqgt_080) NOT COIN EDGE AOP_GT_jog_lteq_004
 err1 = EXT chk_M0G_sides chk_GT_sides < 0.051 ABUT<90 REGION
 err1 NOT INSIDE GT_P96
}

M0G_S_12 {
@ Space between AOP_M0G and (AOP_GT NOT P2) (width <= 0.09um, one side space to ((GATE (INSIDE DG) SIZING 0.041um) AND GT) = 0.118/0.119um, the other side space to (AOP_GT NOT P2) >= 0.15um)
@ (Except the regions of only one M0G space to DOP_GT < 0.055um, and DOP_GT space to DOP_M0G) >= 0.054um
 y1 = (SIZE GATE_in_DG BY 0.041) AND GT
 y2 = EXT (AOP_GT_NOT_P2_eqlt_090) AOP_GT < 0.15 ABUT<90 OPPOSITE  //; not exclude P2 in this spacing check
 y3 = EXT [AOP_GT_NOT_P2_eqlt_090] y1 >= 0.118 <= 0.119 ABUT<90 OPPOSITE EXCLUDE SHIELDED
 y4 = INT [y2] y3 <= 0.090 ABUT<90 OPPOSITE EXCLUDE SHIELDED
 y5 = EXT (y4 COIN EDGE DOP_GT) M0G_v_edges < 0.054 ABUT<90 OPPOSITE REGION

 err1 = EXT (y4 COIN EDGE GT) M0G_v_edges < 0.054 ABUT<90 OPPOSITE REGION  //;exclude space between DOP_GT and DOP_M0G
 err2 = EXT (y4 COIN EDGE GT) AOP_M0G_v_edges < 0.054 ABUT<90 OPPOSITE REGION
 err3 = (EXPAND EDGE (y4 COIN EDGE DOP_GT) INSIDE BY 0.002) INTERACT y5 > 1
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
}

M0G_S_13 {
@ Space between AOP_M0G (width = 0.06um) and AOP_GT, except small AOP_GT jog <= 0.004um and OCOVL region >= 0.031um
 err1 = EXT AOP_M0G_060 (AOP_GT NOT COIN EDGE AOP_GT_jog_lteq_004) < 0.031 ABUT<90 REGION
 err1 NOT INSIDE OCOVL
}

M0G_S_14 {
@ Space between AOP_M0G (width = 0.06um) and AOP_GT line end >= 0.039um
 err1 = EXT AOP_M0G_060 AOP_GT_h_edges < 0.039 ABUT<90 REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

M0G_S_15a {
@ Space between M0G and (M0 NOT M0C), except (M0G (width = 0.051~0.053/0.088um) AND GT) space to M0 = 0.025um, and INST region >= 0.026um
 waive_M0G_TEMP = (OR M0G_WIDTH_051 M0G_WIDTH_052 M0G_WIDTH_053 M0G_WIDTH_088) AND GT
 waive_M0G_EDGE = EXT [waive_M0G_TEMP] M0 == 0.025 ABUT<90 OPPOSITE
 check_M0G = (EXT [M0G] M0_NOT_M0C < 0.026 ABUT<90) NOT TOUCH EDGE waive_M0G_EDGE
 err1 = EXT check_M0G M0_NOT_M0C < 0.026 ABUT<90 REGION
 err1 NOT INSIDE INST
}

M0G_S_15b {
@ Space between M0G and (M0 NOT M0C) in S/D direction when PRL > -0.016um, except (M0G (width = 0.051~0.053/0.088um) AND GT) space to M0 = 0.025um and INST region >= 0.026um
 check_M0G_TEMP = EXT [M0G] M0_NOT_M0C < 0.026 ABUT<90 OPPOSITE EXTENDED 0.016
 waive_M0G_TEMP = (OR M0G_WIDTH_051 M0G_WIDTH_052 M0G_WIDTH_053 M0G_WIDTH_088) AND GT
 waive_M0G_EDGE = EXT [waive_M0G_TEMP] M0 == 0.025 ABUT<90 OPPOSITE
 check_M0G = ANGLE (check_M0G_TEMP NOT TOUCH EDGE waive_M0G_EDGE) == 90
 err1 = EXT check_M0G M0_NOT_M0C < 0.026 ABUT<90 OPPOSITE EXTENDED 0.016 REGION
 err1 NOT INSIDE INST
}

M0G_S_15c {
@ Space between M0G and (M0 NOT M0C) in S/D direction when PRL > -0.016um, except poly center-to-center space = 0.09um design and INST region >= 0.028um
 waive_TMP = INT GT_v_edges <= 0.036 OPPOSITE REGION CENTERLINE 0.0002
 waive = (EXT waive_TMP == 0.09-0.0002 ABUT<90 OPPOSITE REGION) OR waive_TMP
 err1 = (EXT M0G M0_NOT_M0C_L_edges < 0.028 ABUT<90 OPPOSITE EXTENDED 0.016 REGION) NOT INSIDE waive
 err1 NOT INSIDE INST
}

M0G_S_16a {
@ Space between M0G (width = 0.06um) and (M0 NOT M0C) >= 0.028um
 err1 = EXT M0G_060 M0_NOT_M0C < 0.028 ABUT<90 REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

AOP_M0_040_W_edge_outer_AOP_M0C = AOP_M0_040_W_edges NOT INSIDE EDGE AOP_M0C
AOP_M0_042_W_edge_outer_AOP_M0C = AOP_M0_042_W_edges NOT INSIDE EDGE AOP_M0C

M0G_S_17a {
@ Space between M0G and short side of AOP_M0, except INST region >= 0.035um
@ 1. M0 width = 0.04/0.042um
@ 2. M0 short side NOT INTERACT AOP_M0C
@ 3. Space between AOP_M0 short side > 0.32um
@ 4. PRL > 0
 err1_TMP_a = EXT [AOP_M0_040_W_edge_outer_AOP_M0C] M0G < 0.035 ABUT<90 OPPOSITE //;only check non-shielded M0G
 err1_TMP_b = EXT [AOP_M0_042_W_edge_outer_AOP_M0C] M0G < 0.035 ABUT<90 OPPOSITE
 err1_TMP = OR EDGE err1_TMP_a err1_TMP_b
 err1 = EXT (err1_TMP) AOP_M0 <= 0.32 ABUT<90 //;OPPOSITE
 err1 NOT INSIDE EDGE INST
}

M0G_S_17b {
@ Space between M0G and short side of AOP_M0, except INST region >= 0.049um
@ 1. M0 width = 0.04/0.042um
@ 2. M0 short side NOT INTERACT AOP_M0C
@ 3. Space between AOP_M0 short side > 0.41um
@ 4. PRL > 0
 err1_TMP_a = EXT [AOP_M0_040_W_edge_outer_AOP_M0C] M0G < 0.049 ABUT<90 OPPOSITE //;only check non-shielded M0G
 err1_TMP_b = EXT [AOP_M0_042_W_edge_outer_AOP_M0C] M0G < 0.049 ABUT<90 OPPOSITE
 err1_TMP = OR EDGE err1_TMP_a err1_TMP_b
 err1 = EXT (err1_TMP) AOP_M0 <= 0.41 ABUT<90 //;OPPOSITE
 err1 NOT INSIDE EDGE INST
}

M0G_S_17c {
@ Corner space between M0G and short side of AOP_M0, except INST region >= 0.031um
@ 1. M0 width = 0.04/0.042um
@ 2. M0 short side NOT INTERACT AOP_M0C
@ 3. Space between AOP_M0 short side > 0.32um
@ 4. PRL <= 0
 err1_TMP_a = OR EDGE (EXT [AOP_M0_040_W_edge_outer_AOP_M0C] M0G < 0.031 ABUT<90 PROJ==0) (EXT [AOP_M0_040_W_edge_outer_AOP_M0C] M0G < 0.031 ABUT<90 NOT PROJ)  //;only check non-shielded M0G
 err1_TMP_b = OR EDGE (EXT [AOP_M0_042_W_edge_outer_AOP_M0C] M0G < 0.031 ABUT<90 PROJ==0) (EXT [AOP_M0_042_W_edge_outer_AOP_M0C] M0G < 0.031 ABUT<90 NOT PROJ)
 err1_TMP = OR EDGE err1_TMP_a err1_TMP_b
 err1 = EXT (err1_TMP) AOP_M0 <= 0.32 ABUT<90 //;OPPOSITE
 err1 NOT INSIDE EDGE INST
}

M0G_S_18 {
@ Space between M0G and short side of (M0 NOT M0C (M0C width = 0.051um, M0 short side interact M0C)) in GATE poly direction when PRL >= 0um. >= 0.039um
 err1 = EXT M0G (M0_NOT_M0C_h_edges TOUCH EDGE M0C_051) < 0.039 ABUT<90 PROJ>=0 REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

M0G_S_19 {
@ Space between long side of M0G (width = 0.04um) and short side of (M0 NOT M0C) (M0 width = 0.04/0.042um) when PRL >= 0um, except INST region >= 0.028um
 err1 = EXT M0G_040_L_edges M0_NOT_M0C_040_042_W_edges < 0.028 ABUT<90 PROJ>=0 REGION
 err1 NOT INSIDE INST
}

M0G_S_20 {
@ Space between long side of M0G (width = 0.04/0.06um) and short side of (M0 NOT M0C) (M0 width = 0.054um) when PRL >= 0um. >= 0.034um
 err1 = EXT M0G_040_L_edges M0_NOT_M0C_054_W_edges < 0.034 ABUT<90 PROJ>=0 REGION
 err2 = EXT M0G_060_L_edges M0_NOT_M0C_054_W_edges < 0.034 ABUT<90 PROJ>=0 REGION
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

M0_W_edges_outside_M0C = (M0 NOT INSIDE EDGE M0C) TOUCH EDGE M0_W_edges
M0_W_054_edges_outside_M0C = (M0_054 NOT INSIDE EDGE M0C) TOUCH EDGE M0_W_edges

M0G_S_21a {
@ Space between long side of M0G (width = 0.04/0.06/0.088um) and short side of M0 (short side NOT INTERACT M0C) when PRL >= -0.018um. >= 0.031um
 err1 = EXT M0G_040_L_edges M0_W_edges_outside_M0C < 0.031 ABUT<90 OPPOSITE EXTENDED 0.018+GLOBAL_TOLERANCE REGION
 err2 = EXT M0G_060_L_edges M0_W_edges_outside_M0C < 0.031 ABUT<90 OPPOSITE EXTENDED 0.018+GLOBAL_TOLERANCE REGION
 err3 = EXT M0G_088_L_edges M0_W_edges_outside_M0C < 0.031 ABUT<90 OPPOSITE EXTENDED 0.018+GLOBAL_TOLERANCE REGION
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
}

M0G_S_21b {
@ Space between long side of M0G (width = 0.04/0.06/0.088um) and short side of M0 (width = 0.054um, short side NOT INTERACT M0C) when PRL >= -0.018um. >= 0.047um
 err1 = EXT M0G_040_L_edges M0_W_054_edges_outside_M0C < 0.047 ABUT<90 OPPOSITE EXTENDED 0.018+GLOBAL_TOLERANCE REGION
 err2 = EXT M0G_060_L_edges M0_W_054_edges_outside_M0C < 0.047 ABUT<90 OPPOSITE EXTENDED 0.018+GLOBAL_TOLERANCE REGION
 err3 = EXT M0G_088_L_edges M0_W_054_edges_outside_M0C < 0.047 ABUT<90 OPPOSITE EXTENDED 0.018+GLOBAL_TOLERANCE REGION
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
}

M0G_S_22 {
@ Space between long side of M0G (width = 0.06um) and long side of (M0 NOT M0C) when PRL > 0um and M0G and M0 are both in vertical direction >= 0.049um
 err1_CHK = M0_L_edges NOT INSIDE EDGE M0C
 err1 = EXT err1_CHK M0G_060_L_edges < 0.049 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

M0G_S_23 {
@ Space between short side of M0G (width = 0.06um) and short side of (M0 NOT M0C) when PRL >= 0um. >= 0.049um
 err1_CHK = LENGTH M0G_WIDTH_060 == 0.060
 err1 = EXT err1_CHK M0_NOT_M0C_W_edges < 0.049 ABUT<90 PROJ>=0 REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

M0G_S_24 {
@ Space between short side of M0G (width = 0.04/0.06um) and long side of (M0 NOT M0C) (M0 width = 0.054um) when PRL >= 0um. >= 0.032um
 err1 = EXT M0G_040_eq_040_edges M0_NOT_M0C_054_L_edges < 0.032 ABUT<90 PROJ>=0 REGION
 err2 = EXT M0G_060_eq_060_edges M0_NOT_M0C_054_L_edges < 0.032 ABUT<90 PROJ>=0 REGION
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

M0G_S_25a {
@ Space between M0G (width = 0.05um) and the short side of M0 (short side NOT INTERACT M0C) when PRL > -0.018um. >= 0.029um
 err1 = EXT M0G_050 (M0_W_edges OUTSIDE EDGE M0C) < 0.029 ABUT<90 OPPOSITE EXTENDED 0.018 REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

M0G_S_25b {
@ Space between M0G (width = 0.05um) and the short side of (M0 NOT M0C) (M0 width = 0.04/0.042um) when PRL >= 0.02um, except INST region >= 0.049um
 err1 = EXT M0G_050 M0_NOT_M0C_040_042_W_edges < 0.049 ABUT<90 OPPOSITE REGION PROJ>=0.02
 err1 NOT INSIDE INST
}

M0G_S_25c {
@ Space between M0G (width = 0.05um) and (M0 NOT M0C) (M0 width = 0.054um) when PRL >= 0um. >= 0.049um
 err1 = EXT M0_NOT_M0C_054 M0G_050 < 0.049 ABUT<90 PROJ>=0 REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

M0G_W051To053_L090To091_W054To055_L090To091 = ((M0G WITH EDGE (LENGTH M0G >= 0.051 <= 0.053)) WITH EDGE (LENGTH M0G >= 0.090 <= 0.091)) OR ((M0G WITH EDGE (LENGTH M0G >= 0.054 <= 0.055)) WITH EDGE (LENGTH M0G >= 0.090 <= 0.091))

M0G_S_26 {
@ Space between M0G (width/length = 0.051~0.053/0.09~0.091um, 0.054~0.055/0.09~0.091um) and long side of M0 in S/D direction when PRL > -0.025um. >= 0.032um
@ DRC flags M0 line-end (NOT INTERACT M0C) inside the space region
@ //;This rule only checks the space between the nearest point of (M0 line-end [NOT INTERACT M0C] from the M0 long side) and M0G
 chk_M0G_v_edges = M0G_v_edges COIN EDGE M0G_W051To053_L090To091_W054To055_L090To091
 chk_M0_W_edges = M0_W_edges NOT INSIDE EDGE M0C
 chk_M0_L_sides = EXPAND EDGE chk_M0_W_edges INSIDE BY 0.0005 OUTSIDE BY 0.0005
 err1 = EXT chk_M0G_v_edges chk_M0_L_sides < 0.032 ABUT<90 OPPOSITE EXTENDED 0.025-0.0005 REGION //;special spacing check
 err1 NOT INSIDE SealR_NOT_BULK
}

M0G_S_27 {
@ Space between M0G (width = 0.051~0.053/0.054~0.055/0.088um) and (M0 NOT M0C) (M0 width = 0.04/0.042um) in GATE poly direction >= 0.029um
 err1 = EXT M0G_051_To_055_088_h_edges M0_NOT_M0C_040_042 < 0.029 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

M0G_S_28 {
@ Space between M0G (width = 0.06um) and (M0 NOT M0C) in S/D direction when PRL > -0.016um. >= 0.029um
 err1 = EXT M0_NOT_M0C_v_edges M0G_060 < 0.029 ABUT<90 OPPOSITE EXTENDED 0.016 REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

M0G_S_29 {
@ Corner space between M0G and (M0 NOT M0C) when PRL < -0.014um, except INST region >= 0.028um
 err1_RAW = EXT M0G M0_NOT_M0C < 0.028 ABUT CORNER TO CORNER
 err1_TMP = DFM PROPERTY err1_RAW [-= (EWXP(err1_RAW) > 0.014 && EWYP(err1_RAW) > 0.014) ? 1 : 0] > 0
 err1 = DFM COPY err1_TMP REGION
 err1 NOT INSIDE INST
}

M0G_S_30 {
@ Space between M0G and P2 in GATE poly direction when INTERACT the same GT (P2 (width = 0.048um, 0.068um) overlap (GT AND M0G) is not allowed) >= 0.016um
@ Except M0G width/length = 0.06/0.095~0.096um, INST region
 CHECK_GTs = (GT INTERACT P2) INTERACT M0G
 CHECK_M0G = (M0G INTERACT CHECK_GTs) NOT (OR M0G_W060_L095 M0G_W060_L096)
 CHECK_P2s_TMP = (P2 INTERACT CHECK_GTs) INSIDE EDGE CHECK_GTs
 CHECK_P2s = CHECK_P2s_TMP COIN EDGE P2_h_edges

 err1 = EXT CHECK_M0G CHECK_P2s < 0.016 ABUT<90 OPPOSITE REGION
 err2 = (OR P2_W_048 P2_W_068) AND (GT AND CHECK_M0G)
 err1 NOT INSIDE INST
 err2 NOT INSIDE INST
}

M0G_S_31a {
@ Space between the long side of M0G (width = 0.04/0.06um) and the short side of (M0 NOT M0C) when PRL >= 0um. >= 0.033um
@ 1) M0C width = 0.048/0.052um, space to neighboring M0C (width = 0.048/0.052um) = 0.044um, PRL = 0um
@ 2) M0 and M0G interact same M0C
 CHECK_M0C_corner = M0C_048_052 COIN EDGE (INT [M0C] < 0.001 ABUT==90 INTERSECTING ONLY)
 CHECK_M0C_CRN = EXT [CHECK_M0C_corner] == 0.044 OPPOSITE EXTENDED 0.0005 PROJ == 0
 CHECK_M0C = M0C_048_052 WITH EDGE CHECK_M0C_CRN
 CHECK_M0G_side = (M0G_040_L_edges OR EDGE M0G_060_L_edges) INSIDE EDGE CHECK_M0C
 CHECK_M0s_side = M0_NOT_M0C TOUCH EDGE CHECK_M0C
 err1 = EXT CHECK_M0G_side CHECK_M0s_side < 0.033 ABUT<90 REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

//;M0G_S_31b_31c_M0G_W_edge = M0G_051_eq_051_edges OR EDGE M0G_054_eq_054_edges
M0G_S_31b_31c_M0G_W_edge = LENGTH (WITH WIDTH M0G >= 0.051 <= 0.055) >= 0.051 <= 0.055

M0G_S_31b {
@ Space between the short side of M0G (width = 0.051~0.053/0.054~0.055um) and the short side of M0 (short side not interact M0C) when PRL >= -0.018um. >= 0.031um
 chk_M0 = M0_W_edges OUTSIDE EDGE M0C
 err1 = EXT chk_M0 M0G_S_31b_31c_M0G_W_edge < 0.031 ABUT<90 OPPOSITE EXTENDED 0.018+GLOBAL_TOLERANCE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

M0G_S_31c {
@ Space between the short side of M0G (width = 0.051~0.053/0.054~0.055um) and the short side of M0 (width = 0.054um, short side not interact M0C) when PRL >= -0.018um. >= 0.047um
 chk_M0 = (M0_W_edges COIN EDGE M0_054) NOT INSIDE EDGE M0C
 err1 = EXT chk_M0 M0G_S_31b_31c_M0G_W_edge < 0.047 ABUT<90 OPPOSITE EXTENDED 0.018+GLOBAL_TOLERANCE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

//; M0G.S.32a ~ M0G.S.35: delta voltage rule

M0G_EX_1 {
@ AOP_GT short side (width <= 0.032um, and short side not interact P2) extension outside of AOP_M0G (extension <= 0um is not allowed), except AOP_GT jog <= 0.004um. >= 0.056um
 chk_AOP_GT_L_sides = INT [AOP_GT_eqlt_032] <= 0.032 ABUT<90 OPPOSITE
 chk_AOP_GT_W_sides = (AOP_GT_eqlt_032 NOT TOUCH EDGE chk_AOP_GT_L_sides) NOT INSIDE EDGE P2
 err1_TMP = ENC AOP_M0G [chk_AOP_GT_W_sides] < 0.056 ABUT<90 OPPOSITE INSIDE ALSO
 err1 = err1_TMP NOT COIN EDGE AOP_GT_jog_lteq_004
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

M0G_EX_2 {
@ AOP_GT short side (width >= 0.07um, and short side not interact P2) extension outside of AOP_M0G long side (width = 0.04/0.06um) (extension <= 0um is not allowed) >= 0.023um
 chk_AOP_GT_W_sides = (ANGLE AOP_GT_eqgt_070 == 0) NOT INSIDE EDGE P2
 chk_M0G_L_sides = AOP_M0G_040_L_edges OR EDGE AOP_M0G_060_L_edges
 err1 = ENC chk_M0G_L_sides [chk_AOP_GT_W_sides] < 0.023 ABUT<90 OPPOSITE
 err1 NOT INSIDE EDGE SealR_NOT_BULK

 err2 = chk_AOP_GT_W_sides INSIDE EDGE AOP_M0G_040_060
 err2 NOT INSIDE EDGE SealR_NOT_BULK
}

M0G_EX_3 {
@ M0G short side (width = 0.06um) extension outside of AOP_GT (extension <= 0um is not allowed), except OCOVL region >= 0.008um
//;@ Except M0G width/length = 0.060/0.096um
 chk_M0G = M0G_060_eq_060_edges NOT COIN EDGE M0G_W060_L096
 err1 = ENC AOP_GT [chk_M0G] < 0.008 ABUT<90 OPPOSITE INSIDE ALSO
 err1 NOT INSIDE EDGE OCOVL
}

M0G_EX_4 {
@ M0 short side (width = 0.04/0.042um, and short side not interact M0C) extension outside of M0G (extension <= 0um is not allowed), except INST region >= 0.01um
 err1_TMP = ENC M0G [M0_NOT_M0C_040_042_W_edges] < 0.01 ABUT<90 OPPOSITE INSIDE ALSO
 err1 = err1_TMP OUTSIDE EDGE M0C
 err1 NOT INSIDE EDGE INST
}

M0G_EX_4a {
@ (M0 NOT M0C) short side (width = 0.04/0.042um) extension outside of M0G (extension <= 0um is not allowed), except INST region >= 0.008um
 err1 = ENC M0G [M0_NOT_M0C_040_042_W_edges] < 0.008 ABUT<90 OPPOSITE INSIDE ALSO
 err1 NOT INSIDE EDGE INST
}

M0G_EX_5 {
@ (M0 NOT M0C) short side (width = 0.054um) extension outside of M0G (extension <= 0um is not allowed) >= 0.01um
 err1 = ENC M0G [M0_NOT_M0C_054_W_edges] < 0.01 ABUT<90 OPPOSITE INSIDE ALSO
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

M0G_EX_6 {
@ M0G (width = 0.051~0.053/0.054~0.055/0.088um) extension outside of AA (horizontal edge extend -0.019um) in GATE poly direction, except INST region >= 0.007um
 chk_AA = SHRINK AA TOP BY 0.019 BOTTOM BY 0.019
 err1 = ENC chk_AA M0G_051_To_055_088_h_edges < 0.007 ABUT<90 OPPOSITE REGION EXCLUDE SHIELDED
 err1 NOT INSIDE INST
}

M0C_W090_L112 = (M0C WITH EDGE (LENGTH M0C_v_edges == 0.112)) WITH EDGE (LENGTH M0C_h_edges == 0.090)
M0C_W090_L108 = (M0C WITH EDGE (LENGTH M0C_v_edges == 0.108)) WITH EDGE (LENGTH M0C_h_edges == 0.090)
M0C_W090_L112_h_edges = ANGLE M0C_W090_L112 == 0
M0C_W090_L108_h_edges = ANGLE M0C_W090_L108 == 0

M0G_EX_7 {
@ M0C (width/length = 0.108/0.09um) extension outside of M0G (width = 0.040/0.05um) in GATE poly direction = 0.034/0.029um
 good_enc_1 = EXPAND EDGE M0C_W090_L108_h_edges INSIDE BY 0.034
 good_enc_2 = EXPAND EDGE M0C_W090_L108_h_edges INSIDE BY 0.029
 err1 = (ANGLE ((M0C_W090_L108 INTERACT M0G_040) NOT good_enc_1) == 0) NOT TOUCH EDGE M0G
 err2 = (ANGLE ((M0C_W090_L108 INTERACT M0G_050) NOT good_enc_2) == 0) NOT TOUCH EDGE M0G

 err1 NOT INSIDE EDGE SealR_NOT_BULK
 err2 NOT INSIDE EDGE SealR_NOT_BULK
}

M0G_O_1 {
@ M0G and (M0 NOT M0C) (width = 0.04/0.042um) overlap in S/D direction, except INST region >= 0.026um
 err1 = INT M0G_v_edges M0_NOT_M0C_040_042 < 0.026 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE INST
}

M0_NOT_M0C_040_042_inside_AA = (M0_040_042 AND M0_NOT_M0C) AND AA
M0_NOT_M0C_040_inside_AA = (M0_040 AND M0_NOT_M0C) AND AA
M0_NOT_M0C_054_inside_AA = (M0_054 AND M0_NOT_M0C) AND AA

M0G_O_1a {
@ M0G and ((M0 NOT M0C) AND AA) (M0 width = 0.04/0.042um) overlap in S/D direction (M0G cross M0 is not allowed), except (pick-up NOT VARMOS) and INST region. = 0.026, 0.027um
 chk_M0G = M0G_v_edges NOT OUTSIDE EDGE M0_NOT_M0C_040_042_inside_AA
 err1 = (INT (chk_M0G) M0_NOT_M0C_040_042_inside_AA >= 0.026 <= 0.027 ABUT<90 OPPOSITE) OUTSIDE EDGE TAP_NOT_VARMOS
 err2 = (ANGLE (LENGTH (M0G AND M0_NOT_M0C_040_042_inside_AA) >= 0.04) == 0) OUTSIDE EDGE TAP_NOT_VARMOS
 err3 = (M0G_v_edges COIN OUTSIDE EDGE M0_NOT_M0C_040_042_inside_AA) OUTSIDE EDGE TAP_NOT_VARMOS

 err1 NOT INSIDE EDGE INST
 err2 NOT INSIDE EDGE INST
 err3 NOT INSIDE EDGE INST
}

M0G_O_2a {
@ M0G and ((M0 NOT M0C) AND AA) (M0 width = 0.054um) overlap in S/D direction (M0G cross M0 is not allowed), except (pick-up NOT VARMOS), and INST region. = 0.04, 0.041um
 chk_M0G = M0G_v_edges NOT OUTSIDE EDGE M0_NOT_M0C_054_inside_AA
 err1 = (INT (chk_M0G) M0_NOT_M0C_054_inside_AA >= 0.04 <= 0.041 ABUT<90 OPPOSITE) OUTSIDE EDGE TAP_NOT_VARMOS
 err2 = (ANGLE (LENGTH (M0G AND M0_NOT_M0C_054_inside_AA) >= 0.054) == 0) OUTSIDE EDGE TAP_NOT_VARMOS
 err3 = (M0G_v_edges COIN OUTSIDE EDGE M0_NOT_M0C_054_inside_AA) OUTSIDE EDGE TAP_NOT_VARMOS

 err1 NOT INSIDE EDGE INST
 err2 NOT INSIDE EDGE INST
 err3 NOT INSIDE EDGE INST
}

M0G_O_2 {
@ M0G and (M0 NOT M0C) (width = 0.054um) overlap in S/D direction, except M0G.O.2a >= 0.046um
 err1 = (INT M0G_v_edges M0_NOT_M0C_054 < 0.046 ABUT<90 OPPOSITE REGION) NOT (INT M0G_v_edges M0_NOT_M0C_054_inside_AA >= 0.04 <= 0.041 ABUT<90 OPPOSITE REGION)
 err1 NOT INSIDE SealR_NOT_BULK
}

M0G_O_3 {
@ M0G and (M0 NOT M0C) overlap in length direction, M0G and M0 are both in vertical direction >= 0.059um
 chk_M0 = M0_NOT_M0C_h_edges TOUCH EDGE M0_W_edges  //; M0G.O.3 conflict with M0G.EX.4/4a
 err1 = INT chk_M0 M0G_W_edges < 0.059 ABUT<90 OPPOSITE REGION EXCLUDE SHIELDED
 err1 NOT INSIDE SealR_NOT_BULK
}

GT_0_014 = GT_014 AND GT_0
GT_0_016 = GT_016 AND GT_0
GT_0_018 = GT_018 AND GT_0
GT_0_020 = GT_020 AND GT_0
GT_0_022 = GT_022 AND GT_0
GT_0_024 = GT_024 AND GT_0

M0G_O_4a {
@ M0G (width = 0.04/0.05um) and (GT NOT P2) (GT width = 0.016um) overlap in S/D direction >= 0.014um
 err1 = DFM COPY (DFM SPACE GT_0_016 M0G_040_050 < 0.014 BY INT HORIZONTAL) REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

M0G_O_4b {
@ M0G (width = 0.04/0.05um) and (GT NOT P2) (GT width = 0.018um) overlap in S/D direction >= 0.015um
 err1 = DFM COPY (DFM SPACE GT_0_018 M0G_040_050 < 0.015 BY INT HORIZONTAL) REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

M0G_O_4c {
@ M0G (width = 0.04/0.05um) and (GT NOT P2) (GT width = 0.02um) overlap in S/D direction, except INST region >= 0.016um
 err1 = DFM COPY (DFM SPACE GT_0_020 M0G_040_050 < 0.016 BY INT HORIZONTAL) REGION
 err1 NOT INSIDE INST
}

M0G_O_4d {
@ M0G (width = 0.04/0.05um) overlap with (GT width = 0.022um, INSIDE GT_P96) in S/D direction >= 0.017um
 err1 = DFM COPY (DFM SPACE M0G_040_050 ((GT_022 NOT OUTSIDE GT_P96) AND GT_0) < 0.017 BY INT) REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

M0G_O_4e {
@ M0G (width = 0.04/0.05um) overlap with (GT width = 0.024um, INSIDE GT_P96) in S/D direction >= 0.018um
 err1 = DFM COPY (DFM SPACE M0G_040_050 ((GT_024 NOT OUTSIDE GT_P96) AND GT_0) < 0.018 BY INT) REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

M0G_O_4f {
@ M0G (width = 0.04/0.05um) and (GT NOT P2) (GT width = 0.032um) overlap in S/D direction >= 0.018um
 err1 = DFM COPY (DFM SPACE (GT_032 AND GT_0) M0G_040_050 < 0.018 BY INT HORIZONTAL) REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

M0G_O_4g {
@ M0G (width = 0.04um) and (GT NOT P2) (GT width >= 0.07um) overlap in S/D direction >= 0.07um
 err1 = DFM COPY (DFM SPACE (GT_eqgt_070 AND GT_0) M0G_040 < 0.07 BY INT HORIZONTAL) REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

M0G_O_4h {
@ M0G (width = 0.05um) and (GT NOT P2) (GT width >= 0.07um) overlap in S/D direction >= 0.02um
 err1 = DFM COPY (DFM SPACE (GT_eqgt_070 AND GT_0) M0G_050 < 0.02 BY INT HORIZONTAL) REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

M0G_O_5a {
@ M0G (width = 0.051~0.053/0.054~0.055/0.088um) and (GT NOT P2) (GT width = 0.016um) overlap in S/D direction >= 0.008um
 err1 = INT GT_0_016 M0G_051_To_055_088_v_edges < 0.008 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

M0G_O_5b {
@ M0G (width = 0.051~0.053/0.054~0.055/0.088um) and (GT NOT P2) (GT width = 0.018um) overlap in S/D direction >= 0.009um
 err1 = INT GT_0_018 M0G_051_To_055_088_v_edges < 0.009 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

M0G_O_5c {
@ M0G (width = 0.051~0.053/0.054~0.055/0.088um) and (GT NOT P2) (GT width = 0.02um) overlap in S/D direction >= 0.01um
 err1 = INT GT_0_020 M0G_051_To_055_088_v_edges < 0.010 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

M0G_O_5d {
@ M0G (width = 0.051~0.053/0.054~0.055/0.088um) and (GT NOT P2) (GT width = 0.022um) overlap in S/D direction >= 0.011um
 err1 = INT GT_0_022 M0G_051_To_055_088_v_edges < 0.011 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

M0G_O_5e {
@ M0G (width = 0.051~0.053/0.054~0.055/0.088um) and (GT NOT P2) (GT width = 0.024um) overlap in S/D direction >= 0.012um
 err1 = INT GT_0_024 M0G_051_To_055_088_v_edges < 0.012 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

M0G_O_6 {
@ M0G (width/length = 0.06/0.095~0.096um) and (GT NOT P2) overlap in GATE poly direction >= 0.024um
 err1 = INT GT_0 (ANGLE (OR M0G_W060_L095 M0G_W060_L096) == 0) < 0.024 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

#IFDEF IP_LEVEL_DENSITY_CHECK YES
#IFDEF MINIMUM_DENSITY_CHECK YES
VARIABLE M0G_D_1_val 1.1
VARIABLE M0G_D_1_window 125

M0G_D_1 {
@ ALL_M0G density (window 125um*125um, stepping 125um/step_number) >= 1.1%
@ Except:
@ 1) NODMF su 1um region
@ 2) MARKS su 1um region
@ 3) LOGO, RESP1 region
 waive_area = OR NODMF_SIZE_1 MARKS_SIZE_1 LOGO RESP1
 check_region = DRC:1 NOT waive_area
 check_pattern = ALL_M0G AND check_region

 check_window1 = check_region WITH WIDTH >= M0G_D_1_window/4
 err1_TMP1 = DENSITY check_pattern check_window1 check_region [!AREA(check_window1) + !!AREA(check_window1)*AREA(check_pattern)/AREA(check_region)] < M0G_D_1_val/100 WINDOW M0G_D_1_window STEP M0G_D_1_window/step_number BACKUP INSIDE OF LAYER DRC:1 BY POLYGON

 check_window2 = WITH WIDTH (check_region AND err1_TMP1) >= M0G_D_1_window/4
 err1_TMP2 = DENSITY check_pattern check_window2 check_region [!AREA(check_window2) + !!AREA(check_window2)*AREA(check_pattern)/AREA(check_region)] < M0G_D_1_val/100 WINDOW M0G_D_1_window STEP M0G_D_1_window/step_number BACKUP INSIDE OF LAYER err1_TMP1 BY POLYGON

 check_window3 = WITH WIDTH (check_region AND err1_TMP2) >= M0G_D_1_window/4
 DENSITY check_pattern check_window3 check_region [!AREA(check_window3) + !!AREA(check_window3)*AREA(check_pattern)/AREA(check_region)] < M0G_D_1_val/100 WINDOW M0G_D_1_window STEP M0G_D_1_window/step_number BACKUP INSIDE OF LAYER err1_TMP2 BY POLYGON PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_M0G_D_1.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_M0G_D_1.rdb"
}

VARIABLE M0G_D_2_val 6.3
VARIABLE M0G_D_2_window 125

M0G_D_2 {
@ ((ALL_M0 NOT ALL_M0C) OR ALL_M0G) density (window 125um*125um, stepping 125um/step_number), except RESP1 and LOGO region >= 6.3%
 check_region = CHIP_NOT_MARKS NOT (OR RESP1 LOGO)
 check_pattern = ALL_M0_NOT_M0C_OR_M0G AND check_region

 check_window1 = check_region WITH WIDTH >= M0G_D_2_window/4
 err1_TMP1 = DENSITY check_pattern check_window1 check_region [!AREA(check_window1) + !!AREA(check_window1)*AREA(check_pattern)/AREA(check_region)] < M0G_D_2_val/100 WINDOW M0G_D_2_window STEP M0G_D_2_window/step_number BACKUP INSIDE OF LAYER DRC:1 BY POLYGON

 check_window2 = WITH WIDTH (check_region AND err1_TMP1) >= M0G_D_2_window/4
 err1_TMP2 = DENSITY check_pattern check_window2 check_region [!AREA(check_window2) + !!AREA(check_window2)*AREA(check_pattern)/AREA(check_region)] < M0G_D_2_val/100 WINDOW M0G_D_2_window STEP M0G_D_2_window/step_number BACKUP INSIDE OF LAYER err1_TMP1 BY POLYGON

 check_window3 = WITH WIDTH (check_region AND err1_TMP2) >= M0G_D_2_window/4
 DENSITY check_pattern check_window3 check_region [!AREA(check_window3) + !!AREA(check_window3)*AREA(check_pattern)/AREA(check_region)] < M0G_D_2_val/100 WINDOW M0G_D_2_window STEP M0G_D_2_window/step_number BACKUP INSIDE OF LAYER err1_TMP2 BY POLYGON PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_M0G_D_2.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_M0G_D_2.rdb"
}

VARIABLE M0G_D_3_val 5
VARIABLE M0G_D_3_window 125

M0G_D_3 {
@ ((ALL_M0 NOT ALL_M0C) OR ALL_M0G) density in RESP1 region (window 125um*125um, stepping 125um/step_number) >= 5%
 check_region = COPY RESP1
 check_pattern = ALL_M0_NOT_M0C_OR_M0G AND check_region

 check_window1 = check_region WITH WIDTH >= M0G_D_3_window/4
 err1_TMP1 = DENSITY check_pattern check_window1 check_region [!AREA(check_window1) + !!AREA(check_window1)*AREA(check_pattern)/AREA(check_region)] < M0G_D_3_val/100 WINDOW M0G_D_3_window STEP M0G_D_3_window/step_number BACKUP INSIDE OF LAYER DRC:1 BY POLYGON

 check_window2 = WITH WIDTH (check_region AND err1_TMP1) >= M0G_D_3_window/4
 err1_TMP2 = DENSITY check_pattern check_window2 check_region [!AREA(check_window2) + !!AREA(check_window2)*AREA(check_pattern)/AREA(check_region)] < M0G_D_3_val/100 WINDOW M0G_D_3_window STEP M0G_D_3_window/step_number BACKUP INSIDE OF LAYER err1_TMP1 BY POLYGON

 check_window3 = WITH WIDTH (check_region AND err1_TMP2) >= M0G_D_3_window/4
 DENSITY check_pattern check_window3 check_region [!AREA(check_window3) + !!AREA(check_window3)*AREA(check_pattern)/AREA(check_region)] < M0G_D_3_val/100 WINDOW M0G_D_3_window STEP M0G_D_3_window/step_number BACKUP INSIDE OF LAYER err1_TMP2 BY POLYGON PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_M0G_D_3.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_M0G_D_3.rdb"
}
#ENDIF

VARIABLE M0G_D_4_val 19
VARIABLE M0G_D_4_window 20

M0G_D_4 {
@ ALL_M0G density (window 20um x20um, stepping 20um/step_number), except OCOVL region <= 19%
 check_region = CHIP_NOT_MARKS NOT OCOVL
 check_pattern = ALL_M0G AND check_region

 check_window1 = check_region WITH WIDTH >= M0G_D_4_window/4
 err1_TMP1 = DENSITY check_pattern check_window1 check_region [!!AREA(check_window1)*AREA(check_pattern)/AREA(check_region)] > M0G_D_4_val/100 WINDOW M0G_D_4_window STEP M0G_D_4_window/step_number BACKUP INSIDE OF LAYER DRC:1 BY POLYGON

 check_window2 = WITH WIDTH (check_region AND err1_TMP1) >= M0G_D_4_window/4
 err1_TMP2 = DENSITY check_pattern check_window2 check_region [!!AREA(check_window2)*AREA(check_pattern)/AREA(check_region)] > M0G_D_4_val/100 WINDOW M0G_D_4_window STEP M0G_D_4_window/step_number BACKUP INSIDE OF LAYER err1_TMP1 BY POLYGON

 check_window3 = WITH WIDTH (check_region AND err1_TMP2) >= M0G_D_4_window/4
 DENSITY check_pattern check_window3 check_region [!!AREA(check_window3)*AREA(check_pattern)/AREA(check_region)] > M0G_D_4_val/100 WINDOW M0G_D_4_window STEP M0G_D_4_window/step_number BACKUP INSIDE OF LAYER err1_TMP2 BY POLYGON PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_M0G_D_4.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_M0G_D_4.rdb"
}

VARIABLE M0G_D_5_val 42.8
VARIABLE M0G_D_5_window 20

M0G_D_5 {
@ ((ALL_M0 NOT ALL_M0C) OR ALL_M0G) density (window 20um*20um, stepping 20um/step_number), except OCOVL region <= 42.8%
 check_region = CHIP_NOT_MARKS NOT OCOVL
 check_pattern = ALL_M0_NOT_M0C_OR_M0G AND check_region

 check_window1 = check_region WITH WIDTH >= M0G_D_5_window/4
 err1_TMP1 = DENSITY check_pattern check_window1 check_region [!!AREA(check_window1)*AREA(check_pattern)/AREA(check_region)] > M0G_D_5_val/100 WINDOW M0G_D_5_window STEP M0G_D_5_window/step_number BACKUP INSIDE OF LAYER DRC:1 BY POLYGON

 check_window2 = WITH WIDTH (check_region AND err1_TMP1) >= M0G_D_5_window/4
 err1_TMP2 = DENSITY check_pattern check_window2 check_region [!!AREA(check_window2)*AREA(check_pattern)/AREA(check_region)] > M0G_D_5_val/100 WINDOW M0G_D_5_window STEP M0G_D_5_window/step_number BACKUP INSIDE OF LAYER err1_TMP1 BY POLYGON

 check_window3 = WITH WIDTH (check_region AND err1_TMP2) >= M0G_D_5_window/4
 DENSITY check_pattern check_window3 check_region [!!AREA(check_window3)*AREA(check_pattern)/AREA(check_region)] > M0G_D_5_val/100 WINDOW M0G_D_5_window STEP M0G_D_5_window/step_number BACKUP INSIDE OF LAYER err1_TMP2 BY POLYGON PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_M0G_D_5.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_M0G_D_5.rdb"
}
#ELSE

#IFDEF MINIMUM_DENSITY_CHECK YES
VARIABLE M0G_D_1_val 1
VARIABLE M0G_D_1_window 125

M0G_D_1 {
@ ALL_M0G density (window 125um*125um, stepping 62.5um) >= 1%
@ Except:
@ 1) NODMF su 1um region
@ 2) MARKS su 1um region
@ 3) LOGO, RESP1 region
 waive_area = OR NODMF_SIZE_1 MARKS_SIZE_1 LOGO RESP1
 check_region = DRC:1 NOT waive_area
 check_pattern = ALL_M0G AND check_region

 check_window1 = check_region WITH WIDTH >= M0G_D_1_window/4
 err1_TMP1 = DENSITY check_pattern check_window1 check_region [!AREA(check_window1) + !!AREA(check_window1)*AREA(check_pattern)/AREA(check_region)] < M0G_D_1_val/100 WINDOW M0G_D_1_window STEP M0G_D_1_window/2 BACKUP INSIDE OF LAYER DRC:1 BY POLYGON

 check_window2 = WITH WIDTH (check_region AND err1_TMP1) >= M0G_D_1_window/4
 err1_TMP2 = DENSITY check_pattern check_window2 check_region [!AREA(check_window2) + !!AREA(check_window2)*AREA(check_pattern)/AREA(check_region)] < M0G_D_1_val/100 WINDOW M0G_D_1_window STEP M0G_D_1_window/2 BACKUP INSIDE OF LAYER err1_TMP1 BY POLYGON

 check_window3 = WITH WIDTH (check_region AND err1_TMP2) >= M0G_D_1_window/4
 DENSITY check_pattern check_window3 check_region [!AREA(check_window3) + !!AREA(check_window3)*AREA(check_pattern)/AREA(check_region)] < M0G_D_1_val/100 WINDOW M0G_D_1_window STEP M0G_D_1_window/2 BACKUP INSIDE OF LAYER err1_TMP2 BY POLYGON PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_M0G_D_1.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_M0G_D_1.rdb"
}

VARIABLE M0G_D_2_val 6
VARIABLE M0G_D_2_window 125

M0G_D_2 {
@ ((ALL_M0 NOT ALL_M0C) OR ALL_M0G) density (window 125um*125um, stepping 62.5um), except RESP1 and LOGO region >= 6%
 check_region = CHIP_NOT_MARKS NOT (OR RESP1 LOGO)
 check_pattern = ALL_M0_NOT_M0C_OR_M0G AND check_region

 check_window1 = check_region WITH WIDTH >= M0G_D_2_window/4
 err1_TMP1 = DENSITY check_pattern check_window1 check_region [!AREA(check_window1) + !!AREA(check_window1)*AREA(check_pattern)/AREA(check_region)] < M0G_D_2_val/100 WINDOW M0G_D_2_window STEP M0G_D_2_window/2 BACKUP INSIDE OF LAYER DRC:1 BY POLYGON

 check_window2 = WITH WIDTH (check_region AND err1_TMP1) >= M0G_D_2_window/4
 err1_TMP2 = DENSITY check_pattern check_window2 check_region [!AREA(check_window2) + !!AREA(check_window2)*AREA(check_pattern)/AREA(check_region)] < M0G_D_2_val/100 WINDOW M0G_D_2_window STEP M0G_D_2_window/2 BACKUP INSIDE OF LAYER err1_TMP1 BY POLYGON

 check_window3 = WITH WIDTH (check_region AND err1_TMP2) >= M0G_D_2_window/4
 DENSITY check_pattern check_window3 check_region [!AREA(check_window3) + !!AREA(check_window3)*AREA(check_pattern)/AREA(check_region)] < M0G_D_2_val/100 WINDOW M0G_D_2_window STEP M0G_D_2_window/2 BACKUP INSIDE OF LAYER err1_TMP2 BY POLYGON PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_M0G_D_2.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_M0G_D_2.rdb"
}

VARIABLE M0G_D_3_val 5
VARIABLE M0G_D_3_window 125

M0G_D_3 {
@ ((ALL_M0 NOT ALL_M0C) OR ALL_M0G) density in RESP1 region (window 125um*125um, stepping 62.5um) >= 5%
 check_region = COPY RESP1
 check_pattern = ALL_M0_NOT_M0C_OR_M0G AND check_region

 check_window1 = check_region WITH WIDTH >= M0G_D_3_window/4
 err1_TMP1 = DENSITY check_pattern check_window1 check_region [!AREA(check_window1) + !!AREA(check_window1)*AREA(check_pattern)/AREA(check_region)] < M0G_D_3_val/100 WINDOW M0G_D_3_window STEP M0G_D_3_window/2 BACKUP INSIDE OF LAYER DRC:1 BY POLYGON

 check_window2 = WITH WIDTH (check_region AND err1_TMP1) >= M0G_D_3_window/4
 err1_TMP2 = DENSITY check_pattern check_window2 check_region [!AREA(check_window2) + !!AREA(check_window2)*AREA(check_pattern)/AREA(check_region)] < M0G_D_3_val/100 WINDOW M0G_D_3_window STEP M0G_D_3_window/2 BACKUP INSIDE OF LAYER err1_TMP1 BY POLYGON

 check_window3 = WITH WIDTH (check_region AND err1_TMP2) >= M0G_D_3_window/4
 DENSITY check_pattern check_window3 check_region [!AREA(check_window3) + !!AREA(check_window3)*AREA(check_pattern)/AREA(check_region)] < M0G_D_3_val/100 WINDOW M0G_D_3_window STEP M0G_D_3_window/2 BACKUP INSIDE OF LAYER err1_TMP2 BY POLYGON PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_M0G_D_3.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_M0G_D_3.rdb"
}
#ENDIF

VARIABLE M0G_D_4_val 20
VARIABLE M0G_D_4_window 20

M0G_D_4 {
@ ALL_M0G density (window 20um x20um, stepping 10um), except OCOVL region <= 20%
 check_region = CHIP_NOT_MARKS NOT OCOVL
 check_pattern = ALL_M0G AND check_region

 check_window1 = check_region WITH WIDTH >= M0G_D_4_window/4
 err1_TMP1 = DENSITY check_pattern check_window1 check_region [!!AREA(check_window1)*AREA(check_pattern)/AREA(check_region)] > M0G_D_4_val/100 WINDOW M0G_D_4_window STEP M0G_D_4_window/2 BACKUP INSIDE OF LAYER DRC:1 BY POLYGON

 check_window2 = WITH WIDTH (check_region AND err1_TMP1) >= M0G_D_4_window/4
 err1_TMP2 = DENSITY check_pattern check_window2 check_region [!!AREA(check_window2)*AREA(check_pattern)/AREA(check_region)] > M0G_D_4_val/100 WINDOW M0G_D_4_window STEP M0G_D_4_window/2 BACKUP INSIDE OF LAYER err1_TMP1 BY POLYGON

 check_window3 = WITH WIDTH (check_region AND err1_TMP2) >= M0G_D_4_window/4
 DENSITY check_pattern check_window3 check_region [!!AREA(check_window3)*AREA(check_pattern)/AREA(check_region)] > M0G_D_4_val/100 WINDOW M0G_D_4_window STEP M0G_D_4_window/2 BACKUP INSIDE OF LAYER err1_TMP2 BY POLYGON PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_M0G_D_4.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_M0G_D_4.rdb"
}

VARIABLE M0G_D_5_val 45
VARIABLE M0G_D_5_window 20

M0G_D_5 {
@ ((ALL_M0 NOT ALL_M0C) OR ALL_M0G) density (window 20um*20um, stepping 10um), except OCOVL region <= 45%
 check_region = CHIP_NOT_MARKS NOT OCOVL
 check_pattern = ALL_M0_NOT_M0C_OR_M0G AND check_region

 check_window1 = check_region WITH WIDTH >= M0G_D_5_window/4
 err1_TMP1 = DENSITY check_pattern check_window1 check_region [!!AREA(check_window1)*AREA(check_pattern)/AREA(check_region)] > M0G_D_5_val/100 WINDOW M0G_D_5_window STEP M0G_D_5_window/2 BACKUP INSIDE OF LAYER DRC:1 BY POLYGON

 check_window2 = WITH WIDTH (check_region AND err1_TMP1) >= M0G_D_5_window/4
 err1_TMP2 = DENSITY check_pattern check_window2 check_region [!!AREA(check_window2)*AREA(check_pattern)/AREA(check_region)] > M0G_D_5_val/100 WINDOW M0G_D_5_window STEP M0G_D_5_window/2 BACKUP INSIDE OF LAYER err1_TMP1 BY POLYGON

 check_window3 = WITH WIDTH (check_region AND err1_TMP2) >= M0G_D_5_window/4
 DENSITY check_pattern check_window3 check_region [!!AREA(check_window3)*AREA(check_pattern)/AREA(check_region)] > M0G_D_5_val/100 WINDOW M0G_D_5_window STEP M0G_D_5_window/2 BACKUP INSIDE OF LAYER err1_TMP2 BY POLYGON PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_M0G_D_5.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_M0G_D_5.rdb"
}
#ENDIF

M0G_R_1 {
@ ALL_M0G (width = 0.04um) must be horizontal
 err1 = INT [ALL_M0G_v_edges] == 0.04 ABUT<90 OPPOSITE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

M0G_R_2a {
@ M0G (width/length = 0.05/0.057~0.058, 0.05/0.06~0.061, 0.088/0.102~0.104, 0.088/0.108~0.11um) must be horizontal direction
 bad_1 = ANGLE (LENGTH M0G_W050_L057 == 0.057) == 90
 bad_2 = ANGLE (LENGTH M0G_W050_L058 == 0.058) == 90
 bad_3 = ANGLE (LENGTH M0G_W050_L060 == 0.060) == 90
 bad_4 = ANGLE (LENGTH M0G_W050_L061 == 0.061) == 90
 bad_5 = ANGLE (LENGTH M0G_W088_L102_To_L104 >= 0.102 <= 0.104) == 90
 bad_6 = ANGLE (LENGTH M0G_W088_L108_To_L110 >= 0.108 <= 0.110) == 90
 err1 = OR EDGE ((bad_1 OR EDGE bad_2) OR EDGE (bad_3 OR EDGE bad_4)) (bad_5 OR EDGE bad_6)
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

M0G_R_2b {
@ M0G (width/length = 0.051~0.053/0.09~0.091, 0.054~0.055/0.09~0.091, 0.06/0.095~0.096um) must be vertical direction
 bad_1 = ANGLE (LENGTH M0G_W051To053_L090To091_W054To055_L090To091 >= 0.09 <= 0.091) == 0
 bad_2 = ANGLE (LENGTH (OR M0G_W060_L095 M0G_W060_L096) >= 0.095 <= 0.096) == 0
 err1 = bad_1 OR EDGE bad_2
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

M0G_R_3 {
@ M0G interact with AA is not allowed, except M0G (INTERACT (M0 AND AA)) and INST region
 err1 = (M0G NOT INTERACT M0_AND_AA) INTERACT AA
 err1 NOT INSIDE INST
}

M0G_R_3a {
@ M0G (width = 0.06um) interact with AA is not allowed, except pickup and VARMOS region
 err1 = M0G_060 INTERACT (AA NOT (OR TAP_RAW VARMOS))
 err1 NOT INSIDE SealR_NOT_BULK
}

M0G_R_4 {
@ ALL_M0G must be rectangular, and orthogonal to grid
 err1 = NOT RECTANGLE ALL_M0G ORTHOGONAL ONLY
 err1 NOT INSIDE SealR_NOT_BULK
}

M0G_R_5 {
@ M0G (width/length = 0.05/0.057~0.058, 0.05/0.06~0.061um) and M0G (width/length = 0.051~0.053/0.09~0.091, 0.054~0.055/0.09~0.091um and INTERACT AA) must INTERACT both GT (width <= 0.024um) and (M0 NOT M0C) (M0 width = 0.04/0.042um)
 out1 = (M0G_W050_L057_L058 INTERACT GT_eqlt_024) INTERACT M0_NOT_M0C_040_042
 out2 = (M0G_W050_L060_L061 INTERACT GT_eqlt_024) INTERACT M0_NOT_M0C_040_042
 err1 = M0G_W050_L057_L058 NOT out1
 err2 = M0G_W050_L060_L061 NOT out2

 out3_TMP = M0G_W051To053_L090To091_W054To055_L090To091 INTERACT AA
 out3 = (out3_TMP INTERACT GT_eqlt_024) INTERACT M0_NOT_M0C_040_042
 err3 = out3_TMP NOT out3

 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
}

M0G_R_6 {
@ The maximum number of M0G (width/length = 0.05/0.057~0.058, 0.05/0.06~0.061um) within M0G su 0.0615um, except INST region <= 2
 chk_M0G = OR M0G_W050_L057 M0G_W050_L058 M0G_W050_L060 M0G_W050_L061
 err1 = ((SIZE M0G_W050_L057_L058 BY 0.0615) INTERACT chk_M0G > 2) ENCLOSE (chk_M0G NOT INSIDE INST)
 err2 = ((SIZE M0G_W050_L060_L061 BY 0.0615) INTERACT chk_M0G > 2) ENCLOSE (chk_M0G NOT INSIDE INST)
 err1 NOT INSIDE INST
 err2 NOT INSIDE INST
}

M0G_R_6_1 {
@ The number of M0G (width/length = 0.06/0.095~0.096um) within M0G su 0.21um. >= 2
 err1 = (SIZE M0G_W060_L095_L096 BY 0.21) INTERACT M0G_W060_L095_L096 < 2
 err1 NOT INSIDE SealR_NOT_BULK
}

M0G_R_7 {
@ M0G (width = 0.05um) INTERACT GT (width >= 0.07um) is not allowed
 err1 = M0G_050 INTERACT GT_eqgt_070
 err1 NOT INSIDE SealR_NOT_BULK
}

M0G_R_8 {
@ M0G (width/length = 0.088/0.102~0.104, 0.088/0.108~0.11um) must overlap AA
 err1 = M0G_W088_L102_To_L104 NOT INTERACT (M0G_W088_L102_To_L104 AND AA)
 err2 = M0G_W088_L108_To_L110 NOT INTERACT (M0G_W088_L108_To_L110 AND AA)
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

M0G_R_9 {
@ (M0G (width/length = 0.088/0.102~0.104, 0.088/0.108~0.11um) NOT M0) interact V0 is not allowed
 err1 = V0 AND ((M0G_W088_L102_To_L104 NOT M0) INTERACT V0)
 err2 = V0 AND ((M0G_W088_L108_To_L110 NOT M0) INTERACT V0)
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

M0G_R_10 {
@ M0G (width/length = 0.088/0.102~0.104, 0.088/0.108~0.11um) must INTERACT two (M0 NOT M0C) (M0 width = 0.04/0.042um)
 err1 = (M0G_W088_L102_To_L104 INTERACT M0_NOT_M0C_040_042 != 2) OR (M0G_W088_L102_To_L104 NOT INTERACT M0_NOT_M0C_040_042)
 err2 = (M0G_W088_L108_To_L110 INTERACT M0_NOT_M0C_040_042 != 2) OR (M0G_W088_L108_To_L110 NOT INTERACT M0_NOT_M0C_040_042)
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

M0G_W060_VERTICAL = M0G_060 WITH EDGE (LENGTH M0G_v_edges > 0.06)
M0G_W060_VERTICAL_with_M0 = M0G_W060_VERTICAL INTERACT M0_NOT_M0C
M0G_W060_VERTICAL_with_M0_centerline = DFM COPY (DFM SPACE M0G_W060_VERTICAL_with_M0 <= 0.096 BY INT HORIZONTAL) CENTERLINE

M0G_R_11 {
@ M0G (width = 0.06um) extension outside of (M0 NOT M0C) must be equal at both side of M0, when M0G and M0 are both in vertical direction
 M0C_errorLayer = DFM SPACE (M0_NOT_M0C INTERACT M0G_W060_VERTICAL) <= 0.096 BY INT HORIZONTAL
 M0C_centerline = DFM COPY (DFM PROPERTY M0C_errorLayer [-= ABS(REMAINDER(EW(M0C_errorLayer), 0.002))] == 0) CENTERLINE
 err1 = M0G_W060_VERTICAL_with_M0_centerline NOT TOUCH EDGE M0C_centerline
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

M0G_W060_L096_with_GT = M0G_W060_L096 INTERACT GT_0
M0G_W060_L095_L096_with_GT = M0G_W060_L095_L096 INTERACT GT_0
M0G_W060_L096_with_GT_centerline = DFM COPY (DFM SPACE M0G_W060_L096_with_GT <= 0.096 BY INT HORIZONTAL) CENTERLINE
M0G_W060_L095_L096_with_GT_centerline = DFM COPY (DFM SPACE M0G_W060_L095_L096_with_GT <= 0.096 BY INT HORIZONTAL) CENTERLINE

M0G_R_12 {
@ M0G (width/length = 0.06/0.095~0.096um) extension on (GT NOT P2) must be equal at both side of GT, when M0G and GT are both in vertical direction
 GT_errorLayer = DFM SPACE (GT_0 INTERACT M0G_W060_L095_L096) <= 0.096 BY INT HORIZONTAL
 GT_centerline = DFM COPY (DFM PROPERTY GT_errorLayer [-= ABS(REMAINDER(EW(GT_errorLayer), 0.002))] == 0) CENTERLINE
 err1 = M0G_W060_L095_L096_with_GT_centerline NOT TOUCH EDGE GT_centerline
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

M0G_R_13 {
@ M0G (width = 0.04/0.06um) must INTERACT at least one of the following options, except OCOVL region:
@ 1) two (GT NOT P2)
@ 2) two (M0 NOT M0C)
@ 3) one (M0 NOT M0C) and one (GT NOT P2)
@ 4) one V0 and one (M0 NOT M0C)
@ 5) one V0 and one (GT NOT P2)
@ 6) two V0
@ 7) one rectangle V0 and DIR (width <= 0.145um)
 good_TYPE_1 = M0G_040_060 INTERACT GT_0 >= 2
 good_TYPE_2 = M0G_040_060 INTERACT M0_NOT_M0C >= 2
 good_TYPE_3 = (M0G_040_060 INTERACT M0_NOT_M0C) INTERACT GT_0

 good_TYPE_4_5_TMP = M0G_040_060 INTERACT V0
 good_TYPE_4 = good_TYPE_4_5_TMP INTERACT M0_NOT_M0C
 good_TYPE_5 = good_TYPE_4_5_TMP INTERACT GT_0
 good_TYPE_6 = good_TYPE_4_5_TMP INTERACT V0 >= 2
 good_TYPE_7 = (M0G_040_060 INTERACT RV0) NOT OUTSIDE (DIR WITH WIDTH <= 0.145)
 err1 = M0G_040_060 NOT (OR good_TYPE_1 good_TYPE_2 good_TYPE_3 good_TYPE_4 good_TYPE_5 good_TYPE_6 good_TYPE_7)
 err1 NOT INSIDE OCOVL
}

M0G_R_14 {
@ M0G INTERACT GATE is not allowed, except in pick-up, MARKG, MARKS, DSTR, DMPNP, DIOMK1, DIOMK2, VARMOS and M0G (width = 0.04/0.051~0.055/0.088um)
 waive_AREA = OR TAP_RAW MARKG MARKS DSTR DMPNP DIOMK1 DIOMK2 VARMOS
 waive_M0G = OR M0G_040 M0G_WIDTH_051_To_055 M0G_088
 check_M0G = ((M0G NOT INTERACT waive_M0G) NOT waive_AREA) NOT INTERACT TAP_RAW
 err1 = (check_M0G INTERACT GATE) NOT waive_AREA
 err1 NOT INSIDE SealR_NOT_BULK
}

M0G_R_15 {
@ M0G interact with (DUM_GT NOT P2) is not allowed
 err1 = M0G INTERACT DUM_GT_NOT_P2
 err1 NOT INSIDE SealR_NOT_BULK
}

M0G_R_17 {
@ DOP_M0G overlap with M0G is not allowed
 err1 = DOP_M0G AND M0G
 err1 NOT INSIDE SealR_NOT_BULK
}


// =======================================================
// Square Via-0 design rules
// =======================================================

GROUP GV0 V0_?

MARKS_MARKG_INDMY_LOGO = OR MARKS MARKG INDMY LOGO
MARKS_MARKG_LOGO = OR MARKS MARKG LOGO
V0_BAR = V0_BAR_100_all INSIDE MARKS_MARKG

#IFDEF MANUFACTURABILITY_ENHANCEMENT_RULES YES
V0_S_10_ME {
@ Projection space between square V0 and the M1 concave corner (square V0 enclosure of M1 edge < 0.003um at opposite side of M1 concave corner, the concave corner with M1 width <= 0.034um and jog height >= 0.004um), except INST region >= 0.012um
// for via not totally inside cross region
 min_enc_met_side = M1 TOUCH EDGE (ENC V0N [M1] < 0.003 ABUT<90 OPPOSITE)
 min_wid_met_side = M1 TOUCH EDGE (INT min_enc_met_side [M1_convex_lt_two_edges] <= 0.034 OPPOSITE)
 min_wid_met_corn = EXT min_wid_met_side (LENGTH M1_convex_lt_two_edges >= 0.004) < 0.001 ABUT INTERSECTING ONLY REGION
 min_wid_met_side_c = min_wid_met_side TOUCH EDGE min_wid_met_corn
 min_wid_met_corn_c = M1 TOUCH EDGE min_wid_met_corn
 min_wid_met_side_opp = M1 TOUCH EDGE (INT min_wid_met_side_c [M1] <= 0.034 OPPOSITE)
 min_wid_met_area_opp = INT min_wid_met_side_c M1 <= 0.034 OPPOSITE REGION

 min_enc_via_s = ENC [V0N] min_wid_met_side_opp < 0.003 ABUT<90 OPPOSITE
 min_enc_via_c = V0N WITH EDGE min_enc_via_s
 min_met_corn = min_wid_met_corn_c COIN EDGE (M1 ENCLOSE min_enc_via_c)
 via_err_edge_outer = EXT [min_enc_via_c] min_met_corn < 0.012 ABUT<90 OPPOSITE EXTENDED 0.005 MEASURE ALL
 via_err_edge_inner = EXT [min_enc_via_c] min_wid_met_corn < 0.012 ABUT<90 OPPOSITE EXTENDED 0.005 EXCLUDE SHIELDED
 via_err_edge_all = OR EDGE via_err_edge_outer via_err_edge_inner
 err1 = min_enc_via_c WITH EDGE via_err_edge_all
 err1 NOT INSIDE INST

 min_wid_met_all = INT M1 M1_convex_lt_two_edges <= 0.034 OPPOSITE REGION
 // min_wid_met_rvs = DRC:1 NOT M1
 err2 = ENC (V0N INTERACT min_wid_met_all SINGULAR ALSO) M1 < 0.0005 SINGULAR REGION   // point touch via
 err2 NOT INSIDE INST

 met_corner_corss = (EXT M1_convex_lt_two_edges M1 < 0.001 ABUT==90 INTERSECTING ONLY REGION) COIN EDGE min_wid_met_all
 via_inside_corss = ((V0N NOT WITH EDGE (ENC [V0N] M1 < 0.001 ABUT>0<90 SINGULAR)) NOT WITH EDGE via_err_edge_all) NOT INSIDE min_wid_met_all
 via_inside_corss_enc = EXT [via_inside_corss] met_corner_corss <= 0.001 PROJ==0 PARA ONLY OPPOSITE EXTENDED 0.002
 err3 = via_inside_corss INTERACT (INT via_inside_corss_enc == V0_MiniWidth OPPOSITE REGION) // via inside cross must be enclosed by the short side of metal (width<= 0.034) >= 0.001
 err3 NOT INSIDE INST
}

V0_EN_17a_ME {
@ V0 enclosure by M1 (short side of M1 width > 0.046um and <= 0.056um) for two opposite sides with the other two sides >= 0.009um when V0 interact with M0G (width = 0.05um), for 9T standard cell design, except INST region >= 0.025um
 err1_TMP = RECTANGLE ENCLOSURE via_V0_17a M1 ABUT<90 SINGULAR
 GOOD 0.009 0.025 OPPOSITE 0.009 0.025 OPPOSITE
 err1 = err1_TMP NOT OUTSIDE PowerRail_Area_90T
 err1 NOT INSIDE INST
}

V0_EN_17a1_ME {
@ V0 enclosure by M1 (short side of M1 width > 0.046um and <= 0.056um) for two opposite sides with the other two sides >= 0.006um when V0 interact with M0G (width = 0.05um), for 7.5T standard cell design, except INST region >= 0.025um
 err1_TMP = RECTANGLE ENCLOSURE via_V0_17a M1 ABUT<90 SINGULAR
 GOOD 0.006 0.025 OPPOSITE 0.006 0.025 OPPOSITE
 err1 = err1_TMP NOT OUTSIDE PowerRail_Area_75T
 err1 NOT INSIDE INST
}

V0_EN_27_ME {
@ V0 enclosure by M1 edge at opposite side of M1 inner vertex (projection space between V0 and the M1 inner vertex = 0~ 0.012um
@ the inner vertex with width = 0.035~0.046um and jog height >= 0.004um), except INST region >= 0.003um
 tar_enc1 = M1 TOUCH EDGE (ENC V0N [M1] < 0.003 ABUT<90 OPPOSITE)
 tar_enc2 = M1 TOUCH EDGE (INT tar_enc1 [M1_convex_lt_two_edges] >= 0.035 <= 0.046 PARA ONLY OPPOSITE)
 tar_corner = EXT tar_enc2 (LENGTH M1_convex_lt_two_edges >= 0.004) < 0.001 ABUT INTERSECTING ONLY REGION

 tar_enc3 = tar_enc2 TOUCH EDGE tar_corner
 tar_enc4 = M1 TOUCH EDGE tar_corner
 tar_wide = INT tar_enc3 M1 >= 0.035 <= 0.046 PARA ONLY OPPOSITE REGION
 tar_side = M1 TOUCH EDGE (INT tar_enc3 [M1] >= 0.035 <= 0.046 PARA ONLY OPPOSITE)

 tar_vias = V0N WITH EDGE (ENC [V0N] tar_side < 0.003 ABUT<90 OPPOSITE)
 tar_vias_corner = tar_enc4 COIN EDGE (M1 ENCLOSE tar_vias)
 tar_vias_apart = EXT [tar_vias] tar_vias_corner < 0.012 ABUT<90 OPPOSITE EXTENDED 0.046-V0_MiniWidth+GLOBAL_TOLERANCE MEASURE ALL
 tar_vias_cross = SIZE ((tar_vias NOT WITH EDGE tar_vias_apart) NOT INSIDE tar_wide) BY 0.046-V0_MiniWidth+GLOBAL_TOLERANCE
 tar_vias_touch = SIZE (((tar_vias NOT WITH EDGE tar_vias_apart) INSIDE tar_wide) WITH EDGE (tar_vias COIN EDGE (tar_wide NOT COIN EDGE M1))) BY 0.046-V0_MiniWidth+GLOBAL_TOLERANCE
 err1 = tar_vias WITH EDGE tar_vias_apart
 err2 = tar_vias INTERACT (tar_vias_cross INTERACT (tar_vias_cross AND tar_corner))
 err3 = tar_vias INTERACT (tar_vias_touch INTERACT (tar_vias_touch AND tar_corner))
 err1 NOT INSIDE INST
 err2 NOT INSIDE INST
 err3 NOT INSIDE INST
}
#ENDIF

V0_W_1 {
@ V0 width and length, except 0.032*0.08um RV0, MARKS, MARKG, OCOVL and LOGO regions = 0.032um
 WAIVE_AREA = OR MARKS_MARKG_INDMY_LOGO OCOVL
 err1 = (V0 NOT V0N) NOT RV0
 err1 NOT INSIDE WAIVE_AREA
}

V0_W_2 {
@ V0 bar width, and V0 bar is only allowed in MARKS, MARKG, INDMY and LOGO region = 0.100um
@ It allows 0.002um DRC checking telerance in 45-degree region
//;Follow SRC.2a/2b
 Seal_Ring_all = V0 AND MARKS_MARKG_INDMY_LOGO
 Seal_Ring_orth = RECTANGLE Seal_Ring_all
 Seal_Ring_real = NOT RECTANGLE Seal_Ring_all
 Seal_Ring_joint = CONVEX EDGE Seal_Ring_all ANGLE1>269<271 ANGLE2>224<226

 Y1 = Seal_Ring_real COIN EDGE V0_v_edges
 Y2 = Seal_Ring_real COIN EDGE V0_h_edges
 Y3 = INT [Y1] == 0.100 ABUT<90 OPPOSITE
 Y4 = INT [Y2] == 0.100 ABUT<90 OPPOSITE
 err1 = (Y1 NOT TOUCH EDGE Y3) NOT COIN EDGE Seal_Ring_joint
 err2 = (Y2 NOT TOUCH EDGE Y4) NOT COIN EDGE Seal_Ring_joint
 err1 NOT INSIDE EDGE SealR_NOT_BULK
 err2 NOT INSIDE EDGE SealR_NOT_BULK

 Seal_Ring_real_SKEW = ANGLE Seal_Ring_real > 44 < 46
 Seal_Ring_real_SKEW_good = INT [Seal_Ring_real] >= 0.100-0.002 <= 0.141+0.002 ABUT<90 OPPOSITE ANGLED==2
 err3 = (Seal_Ring_real_SKEW NOT TOUCH EDGE Seal_Ring_real_SKEW_good) NOT COIN EDGE Seal_Ring_joint
 err3 NOT INSIDE EDGE SealR_NOT_BULK
}

V0_S_1 {
@ Space between two V0s >= 0.04um
 err1 = EXT V0N < 0.04 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

V0_S_2 {
@ Space between two V0s when PRL >= -0.026um, except INST region >= 0.051um
@ DRC only flag the point-to-point space when PRL <= 0
//; Only flag the point-to-point space < 0.051 when abs(PRL) < Minimum space value
 err1 = EXT V0N < 0.051 ABUT<90 OPPOSITE EXTENDED 0.001 REGION
 err1 NOT INSIDE INST

 err2_RAW = EXT V0N < 0.051 ABUT<90 CORNER TO CORNER
 err2_TMP = DFM PROPERTY err2_RAW [-= (EWXP(err2_RAW) <= 0.026 || EWYP(err2_RAW) <= 0.026) ? 1 : 0] > 0
 err2 = DFM COPY err2_TMP REGION
 err2 NOT INSIDE INST
}

V0_S_3 {
@ Space between V0 bar and V0 bar, square V0 or rectangular V0 >= 0.59um
 err1 = EXT V0_BAR_100_all < 0.59 ABUT<90 SINGULAR REGION
 err2 = EXT V0_BAR_100_all V0_SR < 0.59 ABUT<90 SINGULAR REGION

 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

V0_S_4 {
@ Space between V0 and M0G at different net >= 0.029um
 err1 = EXT (V0 INTERACT V0N) M0G < 0.029 ABUT<90 SINGULAR REGION NOT CONNECTED MEASURE ALL //;based on M0G.S.1
 err1 NOT INSIDE SealR_NOT_BULK
}

V0_S_5 {
@ Space between V0 and M0G at different net when PRL > -0.012um. >= 0.032um
 err1 = EXT (V0 INTERACT V0N) M0G < 0.032 ABUT<90 REGION NOT CONNECTED OPPOSITE EXTENDED 0.012 MEASURE ALL //;based on M0G.S.1
 err1 NOT INSIDE SealR_NOT_BULK
}

V0_S_7 {
@ Space between V0 and (M0 NOT M0C) at different net in S/D direction when PRL > -0.016um. >= 0.025um
 err1 = EXT (V0 INTERACT V0N) M0_NOT_M0C_v_edges < 0.025 REGION NOT CONNECTED OPPOSITE EXTENDED 0.016 MEASURE ALL //;based on M0.S.1
 err1 NOT INSIDE SealR_NOT_BULK
}

V0_S_8 {
@ Space between V0 and (M0 NOT M0C) at different net in S/D direction when PRL > -0.016um. >= 0.027um
@ DRC only check space along M1 enclosure V0 > 0um in S/D direction
 chk_V0 = (V0 INTERACT V0N) NOT COIN INSIDE EDGE M1
 err1 = EXT chk_V0 M0_NOT_M0C_v_edges < 0.027 REGION NOT CONNECTED OPPOSITE EXTENDED 0.016 MEASURE ALL //;based on M0.S.1
 err1 NOT INSIDE SealR_NOT_BULK
}

V0_S_9 {
@ Space between V0 and (M0 NOT M0C) line-end at different net when PRL > 0.01um, except INST region >= 0.025um
 err1 = EXT (V0 INTERACT V0N) (M0_NOT_M0C COIN EDGE M0_NOT_M0C_W_edges) < 0.025 ABUT<90 OPPOSITE PROJ>0.01 NOT CONNECTED REGION MEASURE ALL //;based on M0.S.1
 err1 NOT INSIDE INST
}

// V0.S.10(purposely blank)
// V0_S_10 {
// @ Space between V0 and INST (V0 cut INST is not allowed) >= 0.083um
//  err1 = EXT INST V0N < 0.083 ABUT<90 SINGULAR REGION MEASURE ALL
//  err2 = V0N CUT INST
//  err1 NOT INSIDE SealR_NOT_BULK
//  err2 NOT INSIDE SealR_NOT_BULK
// }

#IFDEF DFM_RULES_PRIORITY_1 YES
V0_S_5_DFM1 {
@ Space between V0 and M0G at different net when PRL > -0.012um. >= 0.04um
 err1 = EXT (V0 INTERACT V0N) M0G < 0.04 ABUT<90 SINGULAR REGION NOT CONNECTED OPPOSITE EXTENDED 0.012 MEASURE ALL //;based on M0G.S.1
 err1 NOT INSIDE SealR_NOT_BULK
}

V0_S_23_DFM1 {
@ Recommended protection space between square V0 and the M1 concave corner (square V0 enclosure by M1 edge < 0.003um at opposite side of M1 concave corner,
@ the concave corner with M1 width <= 0.034um and jog length >= 0.004um) >= 0.03
// for via not totally inside cross region
 min_enc_met_side = M1 TOUCH EDGE (ENC V0N [M1] < 0.003 ABUT<90 OPPOSITE)
 min_wid_met_side = M1 TOUCH EDGE (INT min_enc_met_side [M1_convex_lt_two_edges] <= 0.034 OPPOSITE)
 min_wid_met_corn = EXT min_wid_met_side (LENGTH M1_convex_lt_two_edges >= 0.004) < 0.001 ABUT INTERSECTING ONLY REGION
 min_wid_met_side_c = min_wid_met_side TOUCH EDGE min_wid_met_corn
 min_wid_met_corn_c = M1 TOUCH EDGE min_wid_met_corn
 min_wid_met_side_opp = M1 TOUCH EDGE (INT min_wid_met_side_c [M1] <= 0.034 OPPOSITE)
 min_wid_met_area_opp = INT min_wid_met_side_c M1 <= 0.034 OPPOSITE REGION

 min_enc_via_s = ENC [V0N] min_wid_met_side_opp < 0.003 ABUT<90 OPPOSITE
 min_enc_via_c = V0N WITH EDGE min_enc_via_s
 min_met_corn = min_wid_met_corn_c COIN EDGE (M1 ENCLOSE min_enc_via_c)
 via_err_edge_outer = EXT [min_enc_via_c] min_met_corn < 0.03 ABUT<90 OPPOSITE EXTENDED 0.005 MEASURE ALL
 via_err_edge_inner = EXT [min_enc_via_c] min_wid_met_corn < 0.03 ABUT<90 OPPOSITE EXTENDED 0.005 EXCLUDE SHIELDED
 via_err_edge_all = OR EDGE via_err_edge_outer via_err_edge_inner
 err1 = min_enc_via_c WITH EDGE via_err_edge_all
 err1 NOT INSIDE SealR_NOT_BULK

 min_wid_met_all = INT M1 M1_convex_lt_two_edges <= 0.034 OPPOSITE REGION
 // min_wid_met_rvs = DRC:1 NOT M1
 err2 = ENC (V0N INTERACT min_wid_met_all SINGULAR ALSO) M1 < 0.0005 SINGULAR REGION  //;INTERACT min_wid_met_rvs SINGULAR ONLY // point touch via
 err2 NOT INSIDE SealR_NOT_BULK

 met_corner_corss = (EXT M1_convex_lt_two_edges M1 < 0.001 ABUT==90 INTERSECTING ONLY REGION) COIN EDGE min_wid_met_all
 via_inside_corss = ((V0N NOT WITH EDGE (ENC [V0N] M1 < 0.001 ABUT>0<90 SINGULAR)) NOT WITH EDGE via_err_edge_all) NOT INSIDE min_wid_met_all
 via_inside_corss_enc = EXT [via_inside_corss] met_corner_corss <= 0.001 PROJ==0 PARA ONLY OPPOSITE EXTENDED 0.002
 err3 = via_inside_corss INTERACT (INT via_inside_corss_enc == V0_MiniWidth OPPOSITE REGION) // via inside cross must be enclosed by the short side of metal (width<= 0.034) >= 0.001
 err3 NOT INSIDE SealR_NOT_BULK
}
#ENDIF

//;M0C_vertex_area = EXT M0C < 0.001 ABUT REGION
V0N_intact_M0_040 = V0N INTERACT M0_040_042
V0N_intact_M0_054 = V0N INTERACT M0_054

M0_040_with_V0 = M0_040_042 INTERACT V0N_intact_M0_040
M0_054_with_V0 = M0_054 INTERACT V0N_intact_M0_054

M0C_with_M0_040_V0 = M0C INTERACT M0_040_with_V0
M0C_with_M0_054_V0 = M0C INTERACT M0_054_with_V0

M0C_with_M0_040_V0_concave_edges = CONVEX EDGE M0C_with_M0_040_V0 <= 1
M0C_with_M0_054_V0_concave_edges = CONVEX EDGE M0C_with_M0_054_V0 <= 1

VARIABLE V0_S_11_val 0.038
VARIABLE V0_S_12_val 0.082

V0_S_11 {
@ Space between V0 (INTERACT M0 width = 0.04/0.042um) and M0C concave corner when V0 and M0C interact same M0 >= 0.038um
 M0C_reversed = DRC:1 NOT (M0C_with_M0_040_V0 WITH EDGE M0C_with_M0_040_V0_concave_edges)
 M0C_corner_space_TMP = ENC (V0N_intact_M0_040 AND M0C_reversed) [M0C_reversed] < V0_S_11_val ABUT
 M0C_corner_TMP = INT [M0C_reversed] M0C_corner_space_TMP < 0.0001 ABUT==90 INTERSECTING ONLY
 M0C_M0_interface = (M0_040_with_V0 NOT M0C) COIN EDGE M0C_with_M0_040_V0_concave_edges
 VIA_corner_error_TMP = ENC [V0N_intact_M0_040] M0C_M0_interface < V0_S_11_val ABUT
 M0C_corner_error_TMP = M0C_reversed COIN EDGE (M0C_corner_TMP COIN EDGE M0C_with_M0_040_V0_concave_edges)
 err1 = ENC VIA_corner_error_TMP M0C_corner_error_TMP < V0_S_11_val ABUT REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

V0_S_12 {
@ Space between V0 (INTERACT M0 width = 0.054um) and M0C concave corner when V0 and M0C interact same M0 >= 0.082um
 M0C_reversed = DRC:1 NOT (M0C_with_M0_054_V0 WITH EDGE M0C_with_M0_054_V0_concave_edges)
 M0C_corner_space_TMP = ENC (V0N_intact_M0_054 AND M0C_reversed) [M0C_reversed] < V0_S_12_val ABUT EXCLUDE SHIELDED
 M0C_corner_TMP = INT [M0C_reversed] M0C_corner_space_TMP < 0.0001 ABUT==90 INTERSECTING ONLY
 M0C_M0_interface = (M0_054_with_V0 NOT M0C) COIN EDGE M0C_with_M0_054_V0_concave_edges
 VIA_corner_error_TMP = ENC [V0N_intact_M0_054] M0C_M0_interface < V0_S_12_val ABUT EXCLUDE SHIELDED
 M0C_corner_error_TMP = M0C_reversed COIN EDGE (M0C_corner_TMP COIN EDGE M0C_with_M0_054_V0_concave_edges)
 err1 = ENC VIA_corner_error_TMP M0C_corner_error_TMP < V0_S_12_val ABUT REGION EXCLUDE SHIELDED
 err1 NOT INSIDE SealR_NOT_BULK
}

//; V0.S.13 ~ V0.S.22: delta voltage rule

V0_EN_1 {
@ V0 must be fully covered by (M0 NOT M0C) or M0G, and must follow V0.EN.2, V0.EN.2a, or V0.EN.3, or V0.EN.4, or (V0.EN.5a and V0.EN.5b), or V0.EN.6, or V0.EN.7 as below
@ DRC waive the violation either V0/M0 or V0/M0G pass the enclosure rules when V0 INTERACT (M0 AND M0G)
 err1 = (V0N NOT INSIDE M0_NOT_M0C) NOT INSIDE M0G
 err1 NOT INSIDE SealR_NOT_BULK
}

//;beginning of the V0.EN.2 derivations
 met_V0_2_gen = COPY M0_NOT_M0C_040
 via_V0_2_gen = V0N INTERACT met_V0_2_gen
 via_V0_2_bad = RECTANGLE ENCLOSURE via_V0_2_gen M0_NOT_M0C ABUT<90 SINGULAR
 GOOD 0.004 OPPOSITE 0.014 OPPOSITE 0.004 OPPOSITE 0.014 OPPOSITE

 met_V0_2a_gen = COPY M0_NOT_M0C_042
 via_V0_2a_gen = V0N INTERACT met_V0_2a_gen
 via_V0_2a_bad = RECTANGLE ENCLOSURE via_V0_2a_gen M0_NOT_M0C ABUT<90 SINGULAR
 GOOD 0.005 OPPOSITE 0.014 OPPOSITE 0.005 OPPOSITE 0.014 OPPOSITE
 via_V0_2_good = OR (via_V0_2_gen NOT via_V0_2_bad) (via_V0_2a_gen NOT via_V0_2a_bad)
//;end of the V0.EN.2 derivations

V0_EN_2 {
@ V0.EN.2: V0 enclosure by (M0 NOT M0C) (M0 width = 0.04um) for two opposite sides with other two sides = 0.004um, except INST region >= 0.014um
@ V0.EN.2a: V0 enclosure by (M0 NOT M0C) (M0 width = 0.042um) for two opposite sides with other two sides = 0.005um, except INSTregion >= 0.014um
 err1 = (OR via_V0_2_bad via_V0_2a_bad) NOT (OR via_V0_3_good via_V0_4_good via_V0_5a_good via_V0_5b_good via_V0_6_good via_V0_7_good)
 err1 NOT INSIDE INST
}

//;beginning of the V0.EN.3 derivations
 met_V0_3_gen = COPY M0_NOT_M0C_054
 via_V0_3_gen = V0N INTERACT met_V0_3_gen
 via_V0_3_bad = RECTANGLE ENCLOSURE via_V0_3_gen M0_NOT_M0C ABUT<90 SINGULAR
 GOOD 0.011 OPPOSITE 0.017 OPPOSITE 0.011 OPPOSITE 0.017 OPPOSITE
 via_V0_3_good = via_V0_3_gen NOT via_V0_3_bad
//;end of the V0.EN.3 derivations

V0_EN_3 {
@ V0 enclosure by (M0 NOT M0C) (M0 width = 0.054um) for two opposite sides with other two sides = 0.011um. >= 0.017um
 err1 = via_V0_3_bad NOT (OR via_V0_2_good via_V0_4_good via_V0_5a_good via_V0_5b_good via_V0_6_good via_V0_7_good)
 err1 NOT INSIDE SealR_NOT_BULK
}

//;beginning of the V0.EN.4 derivations
 met_V0_4_gen = M0G_WIDTH_040 OR M0G_040
 via_V0_4_gen = V0N INTERACT met_V0_4_gen
 via_V0_4_bad = RECTANGLE ENCLOSURE via_V0_4_gen M0G ABUT<90 SINGULAR
 GOOD 0.004 OPPOSITE 0.011 OPPOSITE 0.004 OPPOSITE 0.011 OPPOSITE
 via_V0_4_good = via_V0_4_gen NOT via_V0_4_bad
//;end of the V0.EN.4 derivations

V0_EN_4 {
@ V0 enclosure by M0G (width = 0.04um) for two opposite sides with other two sides = 0.004um, except INST region >= 0.011um
 err1 = via_V0_4_bad NOT (OR via_V0_2_good via_V0_3_good via_V0_5a_good via_V0_5b_good via_V0_6_good via_V0_7_good)
 err1 NOT INSIDE INST
}

//;beginning of the V0.EN.5a derivations
 met_V0_5a_gen = COPY M0G_W050_L050  //; only check 50x50 M0G
 via_V0_5a_gen = V0N INTERACT met_V0_5a_gen
 via_V0_5a_bad = RECTANGLE ENCLOSURE via_V0_5a_gen M0G ABUT<90 SINGULAR
 GOOD 0 0.008 OPPOSITE 0 0.008 OPPOSITE
 via_V0_5a_good = via_V0_5a_gen NOT via_V0_5a_bad
//;end of the V0.EN.5a derivations

V0_EN_5a {
@ V0 enclosure by M0G (width = 0.05um) for two opposite sides with other two sides >= 0um. >= 0.008um
 err1 = via_V0_5a_bad NOT (OR via_V0_2_good via_V0_3_good via_V0_4_good via_V0_5b_good via_V0_6_good via_V0_7_good)
 err1 NOT INSIDE SealR_NOT_BULK
}

//;beginning of the V0.EN.5b derivations
 met_V0_5b_gen = OR M0G_W050_L057 M0G_W050_L058 M0G_W050_L060 M0G_W050_L061
 via_V0_5b_gen = V0N INTERACT met_V0_5b_gen
 via_V0_5b_bad = RECTANGLE ENCLOSURE via_V0_5b_gen M0G ABUT<90 SINGULAR
 GOOD 0.009 OPPOSITE 0.011 OPPOSITE 0.009 OPPOSITE 0.011 OPPOSITE
 via_V0_5b_good = via_V0_5b_gen NOT via_V0_5b_bad
//;end of the V0.EN.5b derivations

V0_EN_5b {
@ V0 enclosure by M0G (width = 0.05um, length = 0.057~0.058/0.06~0.061um) for two opposite sides with other two sides >= 0.009um. >= 0.011um
 err1 = via_V0_5b_bad NOT (OR via_V0_2_good via_V0_3_good via_V0_4_good via_V0_5a_good via_V0_6_good via_V0_7_good)
 err1 NOT INSIDE SealR_NOT_BULK
}

//;beginning of the V0.EN.6 derivations
 met_V0_6_gen = M0G_WIDTH_060 OR M0G_060
 via_V0_6_gen = V0N INTERACT met_V0_6_gen
 via_V0_6_bad = RECTANGLE ENCLOSURE via_V0_6_gen M0G ABUT<90 SINGULAR
 GOOD 0.014 OPPOSITE 0.029 OPPOSITE 0.014 OPPOSITE 0.029 OPPOSITE
 via_V0_6_good = via_V0_6_gen NOT via_V0_6_bad
//;end of the V0.EN.6 derivations

V0_EN_6 {
@ V0 enclosure by M0G (width = 0.06um) for two opposite sides with other two sides >= 0.014um. >= 0.029um
 err1 = via_V0_6_bad NOT (OR via_V0_2_good via_V0_3_good via_V0_4_good via_V0_5a_good via_V0_5b_good via_V0_7_good)
 err1 NOT INSIDE SealR_NOT_BULK
}

//;beginning of the V0.EN.7 derivations
 met_V0_7_gen = copy M0G_WIDTH_051_To_055
 via_V0_7_gen = V0N INTERACT met_V0_7_gen
 via_V0_7_bad = RECTANGLE ENCLOSURE via_V0_7_gen M0G ABUT<90 SINGULAR
 GOOD 0.009 OPPOSITE 0.028 OPPOSITE 0.009 OPPOSITE 0.028 OPPOSITE
 via_V0_7_good = via_V0_7_gen NOT via_V0_7_bad
//;end of the V0.EN.7 derivations

V0_EN_7 {
@ V0 enclosure by M0G (width = 0.051~0.053/0.054~0.055um) for two opposite sides with the other two sides >= 0.009um. >= 0.028um
 err1 = via_V0_7_bad NOT (OR via_V0_2_good via_V0_3_good via_V0_4_good via_V0_5a_good via_V0_5b_good via_V0_6_good)
 err1 NOT INSIDE SealR_NOT_BULK
}

#IFDEF DFM_RULES_PRIORITY_1 YES
V0_EN_1_DFM1 {
@ Recommended square V0 enclosure of M0 (width = 0.04/0.042/0.054um) is defined by V0.EN.2.DFM/V0.EN.3.DFM respectively
@ Recommended square V0 enclosure of M0G (width = 0.04/0.05um) is defined by V0.EN.4.DFM/V0.EN.5.DFM respectively
@ DRC waive the violation either V0/M0 or V0/M0G pass the enclosure rules whenV0 INTERACT (M0 AND M0G)
 err1 = (V0N NOT INSIDE M0) NOT INSIDE M0G
 err1 NOT INSIDE SealR_NOT_BULK
}

//;beginning of the V0.EN.2.DFM derivations
 met_V0_2_R = OR M0_NOT_M0C_040 M0_NOT_M0C_042
 via_V0_2_R = V0N INTERACT met_V0_2_R
 via_V0_2_R_bad = RECTANGLE ENCLOSURE via_V0_2_R M0_NOT_M0C ABUT<90 SINGULAR
 GOOD 0.004 OPPOSITE 0.020 OPPOSITE 0.004 OPPOSITE 0.020 OPPOSITE
 via_V0_2_R_good = via_V0_2_R NOT via_V0_2_R_bad
//;end of the V0.EN.2.DFM derivations

V0_EN_2_DFM1 {
@ Recommended square V0 enclosure by (M0 NOT M0C) which M0 width = 0.04/0.042um for two opposite sides with the other two sides >= 0.004um. >= 0.020um
 err1 = via_V0_2_R_bad NOT (OR via_V0_3_R_good via_V0_4_R_good via_V0_5_R_good)
 err1 NOT INSIDE SealR_NOT_BULK
}

//;beginning of the V0.EN.3.DFM derivations
 met_V0_3_R = COPY M0_NOT_M0C_054
 via_V0_3_R = V0N INTERACT met_V0_3_R
 via_V0_3_R_bad = RECTANGLE ENCLOSURE via_V0_3_R M0_NOT_M0C ABUT<90 SINGULAR
 GOOD 0.011 OPPOSITE 0.025 OPPOSITE 0.011 OPPOSITE 0.025 OPPOSITE
 via_V0_3_R_good = via_V0_3_R NOT via_V0_3_R_bad
//;end of the V0.EN.3.DFM derivations

V0_EN_3_DFM1 {
@ Recommended square V0 enclosure by (M0 NOT MOC) which M0 width = 0.054um for two opposite sides with the other two sides >= 0.011um. >= 0.025um
 err1 = via_V0_3_R_bad NOT (OR via_V0_2_R_good via_V0_4_R_good via_V0_5_R_good)
 err1 NOT INSIDE SealR_NOT_BULK
}

//;beginning of the V0.EN.4.DFM derivations
 met_V0_4_R = M0G_WIDTH_040 OR M0G_040
 via_V0_4_R = V0N INTERACT met_V0_4_R
 via_V0_4_R_bad = RECTANGLE ENCLOSURE via_V0_4_R M0G ABUT<90 SINGULAR
 GOOD 0.004 OPPOSITE 0.018 OPPOSITE 0.004 OPPOSITE 0.018 OPPOSITE
 via_V0_4_R_good = via_V0_4_R NOT via_V0_4_R_bad
//;end of the V0.EN.4.DFM derivations

V0_EN_4_DFM1 {
@ Recommended square V0 enclosure by M0G with width = 0.04um for two opposite sides with the other two sides >= 0.004um. >= 0.018um
 err1 = via_V0_4_R_bad NOT (OR via_V0_2_R_good via_V0_3_R_good via_V0_5_R_good)
 err1 NOT INSIDE SealR_NOT_BULK
}

//;beginning of the V0.EN.5.DFM derivations
 met_V0_5_R = M0G_WIDTH_050 OR M0G_050
 via_V0_5_R = V0N INTERACT met_V0_5_R
 via_V0_5_R_bad = RECTANGLE ENCLOSURE via_V0_5_R M0G ABUT<90 SINGULAR
 GOOD 0.009 OPPOSITE 0.005 OPPOSITE 0.009 OPPOSITE 0.005 OPPOSITE
 via_V0_5_R_good = via_V0_5_R NOT via_V0_5_R_bad
//;end of the V0.EN.5.DFM derivations

V0_EN_5_DFM1 {
@ Recommended square V0 enclosure by M0G with width = 0.05um for two opposite sides with the other two sides >= 0.009um. >= 0.005um
 err1 = via_V0_5_R_bad NOT (OR via_V0_2_R_good via_V0_3_R_good via_V0_4_R_good)
 err1 NOT INSIDE SealR_NOT_BULK
}

V0_EN_9_DFM1 {
@ Recommended square V0 enclosure by M1 is defined by either V0.EN.10.DFM or V0.EN.13.DFM or V0.EN.13a.DFM
 err1 = V0N NOT INSIDE M1
 err1 NOT INSIDE SealR_NOT_BULK
}

//;beginning of the V0.EN.10.DFM derivations
 met_V0_10_R = COPY M1
 via_V0_10_R = V0N INTERACT met_V0_10_R
 via_V0_10_R_bad = RECTANGLE ENCLOSURE via_V0_10_R M1 ABUT<90 SINGULAR
 GOOD 0.020 0.020 0.020 0.020 OPPOSITE
 via_V0_10_R_good = via_V0_10_R NOT via_V0_10_R_bad
//;end of the V0.EN.10.DFM derivations

V0_EN_10_DFM1 {
@ Recommended square V0 enclosure by M1 for all sides to avoid high Rc >= 0.02um
 err1 = via_V0_10_R_bad NOT (OR via_V0_13_R_good via_V0_13a_R_good)
 err1 NOT INSIDE SealR_NOT_BULK
}

//;beginning of the V0.EN.13.DFM derivations
 met_V0_13_R = M1 WITH WIDTH < 0.05
 via_V0_13_R = V0N INTERACT met_V0_13_R
 via_V0_13_R_bad = RECTANGLE ENCLOSURE via_V0_13_R M1 ABUT<90 SINGULAR
 GOOD 0.007 0.050 OPPOSITE 0.007 0.050 OPPOSITE
 via_V0_13_R_good = via_V0_13_R NOT via_V0_13_R_bad
//;end of the V0.EN.13.DFM derivations

V0_EN_13_DFM1 {
@ Recommended square V0 enclosure by M1(width < 0.05um) for two opposite sides with the other two sides >= 0.007um. >= 0.05um
 err1 = via_V0_13_R_bad NOT (OR via_V0_10_R_good via_V0_13a_R_good)
 err1 NOT INSIDE SealR_NOT_BULK
}

//;beginning of the V0.EN.13a.DFM derivations
 met_V0_13a_R = COPY M1
 via_V0_13a_R = (V0N INTERACT met_V0_13a_R) NOT INSIDE met_V0_13_R
 via_V0_13a_R_bad = RECTANGLE ENCLOSURE via_V0_13a_R M1 ABUT<90 SINGULAR
 GOOD 0.009 0.050 OPPOSITE 0.009 0.050 OPPOSITE
 via_V0_13a_R_good = via_V0_13a_R NOT via_V0_13a_R_bad
//;end of the V0.EN.13a.DFM derivations

V0_EN_13a_DFM1 {
@ Recommended square V0 enclosure by M1(width >= 0.05um) for two opposite sides with the other two sides >= 0.009um. >= 0.05um
 err1 = via_V0_13a_R_bad NOT (OR via_V0_10_R_good via_V0_13_R_good)
 err1 NOT INSIDE SealR_NOT_BULK
}
#ENDIF

V0_EN_8 {
@ V0 must be fully covered by M1, and must follow V0.EN.9, or V0.EN.11, or V0.EN.12, or V0.EN.13, or V0.EN.14, or V0.EN.15, or V0.EN.16c, or (V0.EN.17a and V0.EN.17b), or V0.EN.18, or (V0.EN.19a and V0.EN.19b), or V0.EN.20, or (V0.EN.21a and V0.EN.21b), or V0.EN.22, or V0.EN.23 as below
 err1 = V0N NOT M1
 err1 NOT INSIDE SealR_NOT_BULK
}

VARIABLE V0_EN_9_val 0.015

//;beginning of the V0.EN.10 derivations
 via_V0_10_bad = RECTANGLE ENCLOSURE V0N M1 ABUT<90 SINGULAR
 GOOD V0_EN_9_val V0_EN_9_val V0_EN_9_val V0_EN_9_val OPPOSITE
 via_V0_10_good = V0N NOT via_V0_10_bad
//;end of the V0.EN.10 derivations

V0_EN_9 {
@ V0 enclosure by M1 for all sides >= 0.015um
 err1 = COPY (V0N NOT M1)
 err1 NOT INSIDE SealR_NOT_BULK
}

//;beginning of the V0.EN.11, V0.EN.12 derivations
 met_V0_11_12_t = M1 WITH WIDTH == 0.032
 met_V0_11_12 = met_V0_11_12_t INTERACT V0N
 met_V0_11_12_side = INT [met_V0_11_12] == 0.032 ABUT<90 OPPOSITE
 via_V0_11_12_TMP = V0N NOT OUTSIDE met_V0_11_12
 via_V0_11_12 = via_V0_11_12_TMP NOT via_V0_10_good

 v0_11_12_non_iso_end = via_V0_11_12 NOT TOUCH EDGE met_V0_11_12_side
 v0_11_12_non_iso_side = via_V0_11_12 TOUCH EDGE met_V0_11_12_side
 v0_11_12_non_iso_s1 = EXT [v0_11_12_non_iso_end] M1 <= V0_EN_11_denseV0_LengthDirection ABUT<90 OPPOSITE MEASURE ALL
 v0_11_12_non_iso_s2 = EXT [v0_11_12_non_iso_side] M1 <= V0_EN_11_denseV0_WidthDirection ABUT<90 OPPOSITE EXTENDED V0_EN_11_denseV0_LengthDirection+GLOBAL_TOLERANCE MEASURE ALL
 v0_11_12_non_iso_via = via_V0_11_12 WITH EDGE (OR EDGE v0_11_12_non_iso_s1 v0_11_12_non_iso_s2)
 v0_11_12_iso_via = via_V0_11_12 NOT v0_11_12_non_iso_via

//;V0_EN_11 non_iso via
 v0_11_bad_1 = RECTANGLE ENCLOSURE v0_11_12_non_iso_via M1 ABUT<90 SINGULAR
 GOOD 0 V0_EN_11_E1E2 OPPOSITE 0 V0_EN_11_E1E2 OPPOSITE
 v0_11_bad_2 = RECTANGLE ENCLOSURE v0_11_12_non_iso_via M1 ABUT<90 SINGULAR
 GOOD 0 0.035 OPPOSITE 0 0.044 OPPOSITE
 GOOD 0 0.036 OPPOSITE 0 0.043 OPPOSITE
 GOOD 0 0.037 OPPOSITE 0 0.042 OPPOSITE
 GOOD 0 0.038 OPPOSITE 0 0.041 OPPOSITE
 GOOD 0 0.039 OPPOSITE 0 0.040 OPPOSITE
 v0_11_good = v0_11_12_non_iso_via NOT (OR v0_11_bad_1 v0_11_bad_2)

//;V0_EN_12 iso via
 v0_12_bad_1 = RECTANGLE ENCLOSURE v0_11_12_iso_via M1 ABUT<90 SINGULAR
 GOOD 0 V0_EN_12_E1E2 OPPOSITE 0 V0_EN_12_E1E2 OPPOSITE
 v0_12_bad_2 = RECTANGLE ENCLOSURE v0_11_12_iso_via M1 ABUT<90 SINGULAR
 GOOD 0 0.030 OPPOSITE 0 0.039 OPPOSITE
 GOOD 0 0.031 OPPOSITE 0 0.038 OPPOSITE
 GOOD 0 0.032 OPPOSITE 0 0.037 OPPOSITE
 GOOD 0 0.033 OPPOSITE 0 0.036 OPPOSITE
 GOOD 0 0.034 OPPOSITE 0 0.035 OPPOSITE
 v0_12_good = v0_11_12_iso_via NOT (OR v0_12_bad_1 v0_12_bad_2)

 via_V0_11_12_bad = OR v0_11_bad_1 v0_11_bad_2 v0_12_bad_1 v0_12_bad_2
//;end of the V0.EN.11, V0.EN.12 derivations

via_V0_11_12_good = OR v0_11_good v0_12_good

VARIABLE V0_EN_11_E1E2 0.035
VARIABLE V0_EN_12_E1E2 0.030
VARIABLE V0_EN_11_val 0.079
VARIABLE V0_EN_12_val 0.069
VARIABLE V0_EN_11_denseV0_LengthDirection 0.129
VARIABLE V0_EN_11_denseV0_WidthDirection 0.089

V0_EN_11 {
@ Total V0 enclosure (E1+E2) by M1 (short side of M1 width = 0.032um, both two opposite sides (E1/E2) >= 0.035um) with the other two sides >= 0um, except INST region >= 0.079um
@ When meet either one of below conditions:
@ 1. Space between V0 and metal in metal length direction <= 0.129um
@ 2. Space between V0 and metal in metal width direction <= 0.089um
 err1 = COPY v0_11_bad_1
 err2 = COPY v0_11_bad_2
 err1 NOT INSIDE INST
 err2 NOT INSIDE INST
}

V0_EN_12 {
@ Total enclosure (E1+E2) by M1 (short side of M1 width = 0.032um, both two opposite sides (E1/E2) >= 0.03um) with the other two sides >= 0um for isolated V0 condition >= 0.069um
@ Isolated V0 condition:
@ Space between V0 and metal in metal length direction > 0.129um and in metal width direction > 0.089um
 err1 = COPY v0_12_bad_1
 err2 = COPY v0_12_bad_2
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

//;beginning of the V0.EN.13 ~ V0.EN.15 derivations
 met_V0_13_14_15 = M1 WITH WIDTH > 0.032 <= 0.046
 via_V0_13_14_15 = V0N INTERACT met_V0_13_14_15

 via_V0_13_14_15_bad = RECTANGLE ENCLOSURE via_V0_13_14_15 M1 ABUT<90 SINGULAR
 GOOD 0.003 0.032 OPPOSITE 0.003 0.047 OPPOSITE
 GOOD 0.0 0.036 OPPOSITE 0.0 0.043 OPPOSITE
 GOOD 0.0 0.039 OPPOSITE 0.0 0.039 OPPOSITE
 via_V0_13_14_15_good = via_V0_13_14_15 NOT via_V0_13_14_15_bad
 via_V0_10_11_12_13_14_15_good = OR via_V0_10_good via_V0_11_12_good via_V0_13_14_15_good
//;end of the V0.EN.13 ~ V0.EN.15 derivations

V0_EN_13_14_15 {
@ V0.EN.13: V0 enclosure by M1 (short side of M1 width > 0.032um and <= 0.046um) for opposite side >= 0.032um with the other two sides >= 0.003um. >= 0.047um
@ V0.EN.14: V0 enclosure by M1 (short side of M1 width > 0.032um and <= 0.046um) for opposite side >= 0.036um with the other two sides >= 0um. >= 0.043um
@ V0.EN.15: V0 enclosure by M1 (short side of M1 width > 0.032um and <= 0.046um) for two opposite sides with the other two sides >= 0um. >= 0.039um
 err1 = via_V0_13_14_15_bad NOT (OR via_V0_10_good via_V0_11_12_good via_V0_16b_16c_16d_good)  //;exclude V0.EN.16 (V0.EN.16a can't be excluded)
 err1 NOT INSIDE SealR_NOT_BULK
}

//;beginning of the V0.EN.16a derivations
 met_V0_16a = M1 WITH WIDTH > 0.032 <= 0.046
 via_V0_16a_raw = V0N INTERACT met_V0_16a
 via_V0_16a_edges = INT [met_V0_16a] > 0.032 <= 0.046 OPPOSITE
 via_V0_16a_met_space_match_1 = EXT via_V0_16a_edges M1 >= 0.058 < 0.063 OPPOSITE REGION
 via_V0_16a_met_space_match_2 = via_V0_16a_met_space_match_1 ENCLOSE RECTANGLE 0.001 0.113 ORTHOGONAL ONLY
 via_V0_16a_met_space_match = via_V0_16a_edges COIN EDGE via_V0_16a_met_space_match_2
 via_V0_16a = via_V0_16a_raw INTERACT (met_V0_16a WITH EDGE via_V0_16a_met_space_match)
 via_V0_16a_bad_edge = ENC [via_V0_16a] via_V0_16a_met_space_match < 0.003 ABUT<90 OPPOSITE
 via_V0_16a_bad = via_V0_16a WITH EDGE via_V0_16a_bad_edge

 via_V0_16a_good = via_V0_16a NOT via_V0_16a_bad
//;end of the V0.EN.16a derivations

V0_EN_16a {
@ V0 enclosure by M1 in adjacent S1 side, when
@ 1. 0.032um < short side of M1 width <= 0.046
@ 2. 0.058um <= S1 < 0.063um, PRL >= 0.113um >= 0.003um
 err1 = via_V0_16a_bad NOT (OR via_V0_10_good via_V0_11_12_good) //;additional restriction, so V0_13_14_15_16a_16c can't be excluded
 err1 NOT INSIDE SealR_NOT_BULK
}

//;beginning of the V0.EN.16_c derivations
 met_V0_16_b_c_d = M1 WITH WIDTH == 0.036
 met_V0_16_b_c_d_edges = M1 COIN EDGE (INT [met_V0_16_b_c_d] == 0.036 OPPOSITE)
 via_V0_16_b_c_d_raw = V0N INTERACT met_V0_16_b_c_d
 met_V0_16_b_c_d_meet_s = met_V0_16_b_c_d_edges COIN EDGE (EXT (M1) >= 0.058 < 0.063 ABUT<90 OPPOSITE)
 met_V0_16_b_c_d_meet = (INT met_V0_16_b_c_d_meet_s == 0.036 OPPOSITE REGION) OR (INT met_V0_16_b_c_d_meet_s M1 == 0.036 OPPOSITE REGION)
 via_V0_16_b_c_d = via_V0_16_b_c_d_raw INTERACT met_V0_16_b_c_d_meet

 via_V0_16b_16c_16d_bad = RECTANGLE ENCLOSURE via_V0_16_b_c_d M1 ABUT<90 SINGULAR
 GOOD 0.002 0.032 OPPOSITE 0.002 0.047 OPPOSITE

 via_V0_16b_16c_16d_good = via_V0_16_b_c_d NOT via_V0_16b_16c_16d_bad //; 0.002 is minimum requirement
//;end of the V0.EN.16_c derivations

V0_EN_16c {
@ V0 enclosure by M1 at least one side (short side of M1 width = 0.036um, space < 0.058um or >= 0.063um) for the opposite side >= 0.032um and the other two sides >= 0.002um. >= 0.047um
 err1 = via_V0_16b_16c_16d_bad NOT via_V0_10_11_12_13_14_15_good  //;V0.EN.16a can't be excluded
 err1 NOT INSIDE SealR_NOT_BULK
}

//;beginning of the V0.EN.17 derivations
 met_V0_17 = M1 WITH WIDTH > 0.046 <= 0.056
 via_V0_17 = V0N INTERACT met_V0_17
 via_V0_17a = via_V0_17 INTERACT M0G_050_ALL
 via_V0_17b = via_V0_17 NOT via_V0_17a

 via_V0_17a_bad_1 = RECTANGLE ENCLOSURE via_V0_17a M1 ABUT<90 SINGULAR
 GOOD V0_EN_9_val V0_EN_9_val V0_EN_9_val V0_EN_9_val OPPOSITE
 GOOD 0.006 V0_EN_17a_val OPPOSITE 0.006 V0_EN_17a_val OPPOSITE
 via_V0_17b_bad_1 = RECTANGLE ENCLOSURE via_V0_17b M1 ABUT<90 SINGULAR
 GOOD V0_EN_9_val V0_EN_9_val V0_EN_9_val V0_EN_9_val OPPOSITE
 GOOD 0.009 V0_EN_17b_val OPPOSITE 0.009 V0_EN_17b_val OPPOSITE

 via_V0_17a_bad = via_V0_17a_bad_1 NOT via_V0_18_good
 via_V0_17b_bad = via_V0_17b_bad_1 NOT via_V0_18_good
 via_V0_17a_good = via_V0_17a NOT via_V0_17a_bad
 via_V0_17b_good = via_V0_17b NOT via_V0_17b_bad
  via_V0_17a_17b_good = OR via_V0_17a_good via_V0_17b_good
//;end of the V0.EN.17 derivations

//;beginning of the V0.EN.18 derivations
 met_V0_18 = M1 WITH WIDTH == 0.056
 via_V0_18 = V0N INTERACT met_V0_18
 via_V0_18a = via_V0_18 INTERACT M0G_050_ALL
 via_V0_18b = via_V0_18 NOT via_V0_18a

 via_V0_18_bad_1 = RECTANGLE ENCLOSURE via_V0_18a M1 ABUT<90 SINGULAR
 GOOD V0_EN_9_val V0_EN_9_val V0_EN_9_val V0_EN_9_val OPPOSITE
 GOOD 0.006 V0_EN_17a_val OPPOSITE 0.006 V0_EN_17a_val OPPOSITE  //;exclude good V0.EN.17a
 GOOD 0.012 V0_EN_18_val OPPOSITE 0.012 V0_EN_18_val OPPOSITE
 via_V0_18_bad_2 = RECTANGLE ENCLOSURE via_V0_18b M1 ABUT<90 SINGULAR
 GOOD V0_EN_9_val V0_EN_9_val V0_EN_9_val V0_EN_9_val OPPOSITE
 GOOD 0.009 V0_EN_17b_val OPPOSITE 0.009 V0_EN_17b_val OPPOSITE  //;exclude good V0.EN.17b
 GOOD 0.012 V0_EN_18_val OPPOSITE 0.012 V0_EN_18_val OPPOSITE

 via_V0_18_bad = OR via_V0_18_bad_1 via_V0_18_bad_2
 via_V0_18_good_1 = via_V0_18a NOT via_V0_18_bad_1
 via_V0_18_good_2 = via_V0_18b NOT via_V0_18_bad_2
 via_V0_18_good = OR via_V0_18_good_1 via_V0_18_good_2
//;end of the V0.EN.18 derivations

VARIABLE V0_EN_17a_val 0.023
VARIABLE V0_EN_17b_val 0.024
VARIABLE V0_EN_18_val 0.023

V0_EN_17a {
@ V0 enclosure by M1 (short side of M1 width > 0.046um and <= 0.056um) for two opposite sides with the other two sides >= 0.006um when V0 interact with M0G (width = 0.05um) >= 0.023um
 err1 = via_V0_17a_bad NOT (OR via_V0_10_11_12_13_14_15_good via_V0_16b_16c_16d_good via_V0_18_good)
 err1 NOT INSIDE SealR_NOT_BULK
}

V0_EN_17b {
@ V0 enclosure by M1 (short side of M1 width > 0.046um and <= 0.056um) for two opposite sides with the other two sides >= 0.009um, except V0 interact with M0G (width = 0.05um) and INST region >= 0.024um
 err1 = via_V0_17b_bad NOT (OR via_V0_10_11_12_13_14_15_good via_V0_16b_16c_16d_good via_V0_18_good)
 err1 NOT INSIDE INST
}

V0_EN_18 {
@ V0 enclosure by M1 (short side of M1 width = 0.056um) for two opposite sides with the other two sides = 0.012um. >= 0.023um
 err1 = via_V0_18_bad NOT (OR via_V0_10_11_12_13_14_15_good via_V0_16b_16c_16d_good via_V0_17a_17b_good)
 err1 NOT INSIDE SealR_NOT_BULK
}

//;V0.EN.19a/19b derivations
 met_V0_19 = M1 WITH WIDTH > 0.056 <= 0.090
 via_V0_19 = V0N INTERACT met_V0_19

//;beginning of the V0.EN.19a derivations
 via_V0_19a = via_V0_19 INTERACT M0G_050_ALL
 via_V0_19a_bad = RECTANGLE ENCLOSURE via_V0_19a M1 ABUT<90 SINGULAR
 GOOD V0_EN_9_val V0_EN_9_val V0_EN_9_val V0_EN_9_val OPPOSITE
 GOOD 0.006 V0_EN_19a_val OPPOSITE 0.006 V0_EN_19a_val OPPOSITE
 via_V0_19a_good = via_V0_19a NOT via_V0_19a_bad
//;end of the V0.EN.19a derivations

//;beginning of the V0.EN.19b derivations
 via_V0_19b = via_V0_19 NOT via_V0_19a
 via_V0_19b_bad = RECTANGLE ENCLOSURE via_V0_19b M1 ABUT<90 SINGULAR
 GOOD V0_EN_9_val V0_EN_9_val V0_EN_9_val V0_EN_9_val OPPOSITE
 GOOD 0.009 V0_EN_19b_val OPPOSITE 0.009 V0_EN_19b_val OPPOSITE
 via_V0_19b_good = via_V0_19b NOT via_V0_19b_bad
//;end of the V0.EN.19b derivations

via_V0_19a_19b_good = OR via_V0_19a_good via_V0_19b_good
via_V0_10_11_12_13_14_15_16_17_18 = OR via_V0_10_11_12_13_14_15_good via_V0_16b_16c_16d_good via_V0_17a_17b_good via_V0_18_good

VARIABLE V0_EN_19a_val 0.023
VARIABLE V0_EN_19b_val 0.024

V0_EN_19a {
@ V0 enclosure by M1 (short side of M1 width > 0.056um and <= 0.09um) for two opposite sides with the other two sides >= 0.006um when V0 interact with M0G (width = 0.05um) >= 0.023um
 err1 = via_V0_19a_bad NOT (OR via_V0_10_11_12_13_14_15_16_17_18 via_V0_19b_good via_V0_20_good)
 err1 NOT INSIDE SealR_NOT_BULK
}

V0_EN_19b {
@ V0 enclosure by M1 (short side of M1 width > 0.056um and <= 0.09um) for two opposite sides with the other two sides >= 0.009um, except V0 interact with M0G (width = 0.05um), INST region >= 0.024um
 err1 = via_V0_19b_bad NOT (OR via_V0_10_11_12_13_14_15_16_17_18 via_V0_19a_good via_V0_20_good)
 err1 NOT INSIDE INST
}

//;beginning of the V0.EN.20 derivations
 met_V0_20 = (M1 WITH WIDTH == 0.084) OR (M1 WITH WIDTH == 0.09)
 met_V0_20_l_side = met_V0_20 TOUCH EDGE ((INT [met_V0_20] == 0.084 OPPOSITE EXCLUDE SHIELDED) OR EDGE (INT [met_V0_20] == 0.09 OPPOSITE EXCLUDE SHIELDED))
 via_V0_20 = V0N INTERACT met_V0_20
//;end of the V0.EN.20 derivations

 
//;condition 1 
via_V0_20_enc_0.005 = ENC [via_V0_20] met_V0_20 == 0.005 ABUT<90 OPPOSITE
via_V0_20_ext_0.005_condition_1 = EXT (via_V0_20_enc_0.005) M1 >= 0.058+0.005 <= 0.062+0.005 ABUT<90 OPPOSITE EXTENDED 0.015 MEASURE ALL
via_V0_20_0.005_condition_1 = via_V0_20 WITH EDGE via_V0_20_ext_0.005_condition_1
via_V0_20_bad_0.005_condition_1 = RECTANGLE ENCLOSURE via_V0_20_0.005_condition_1 M1 ABUT<90 SINGULAR 
GOOD 0.005 0.059 OPPOSITE 0.005 0.059 OPPOSITE
//;condition 2 
via_V0_20_ext_0.005_condition_2_min = EXT [via_V0_20_enc_0.005] M1 >= 0.058+0.005 <= 0.062+0.005 ABUT<90 OPPOSITE EXTENDED 0.015 MEASURE ALL
via_V0_20_ext_0.005_condition_2_max = EXT [via_V0_20_enc_0.005] M1 >= 0.058+0.005 <= 0.062+0.005 ABUT<90 OPPOSITE EXTENDED 0.154 MEASURE ALL
via_V0_20_ext_0.005_condition_2_prl = via_V0_20_ext_0.005_condition_2_max NOT TOUCH EDGE (via_V0_20 TOUCH EDGE via_V0_20_ext_0.005_condition_2_min)
via_V0_20_0.005_condition_2 = via_V0_20 WITH EDGE via_V0_20_ext_0.005_condition_2_prl
via_V0_20_bad_0.005_condition_2 = RECTANGLE ENCLOSURE via_V0_20_0.005_condition_2 M1 ABUT<90 SINGULAR 
GOOD 0.005 0.059 OPPOSITE 0.005 0.059 OPPOSITE
via_V0_20_bad_0.005 = OR via_V0_20_bad_0.005_condition_1 via_V0_20_bad_0.005_condition_2
via_V0_20_good_0.005 = (OR via_V0_20_0.005_condition_1 via_V0_20_0.005_condition_2) NOT via_V0_20_bad_0.005
 
//;condition 1 
via_V0_20_enc_0.006 = ENC [via_V0_20] met_V0_20 == 0.006 ABUT<90 OPPOSITE
via_V0_20_ext_0.006_condition_1 = EXT (via_V0_20_enc_0.006) M1 >= 0.058+0.006 <= 0.062+0.006 ABUT<90 OPPOSITE EXTENDED 0.015 MEASURE ALL
via_V0_20_0.006_condition_1 = via_V0_20 WITH EDGE via_V0_20_ext_0.006_condition_1
via_V0_20_bad_0.006_condition_1 = RECTANGLE ENCLOSURE via_V0_20_0.006_condition_1 M1 ABUT<90 SINGULAR 
GOOD 0.006 0.059 OPPOSITE 0.006 0.059 OPPOSITE
//;condition 2 
via_V0_20_ext_0.006_condition_2_min = EXT [via_V0_20_enc_0.006] M1 >= 0.058+0.006 <= 0.062+0.006 ABUT<90 OPPOSITE EXTENDED 0.015 MEASURE ALL
via_V0_20_ext_0.006_condition_2_max = EXT [via_V0_20_enc_0.006] M1 >= 0.058+0.006 <= 0.062+0.006 ABUT<90 OPPOSITE EXTENDED 0.154 MEASURE ALL
via_V0_20_ext_0.006_condition_2_prl = via_V0_20_ext_0.006_condition_2_max NOT TOUCH EDGE (via_V0_20 TOUCH EDGE via_V0_20_ext_0.006_condition_2_min)
via_V0_20_0.006_condition_2 = via_V0_20 WITH EDGE via_V0_20_ext_0.006_condition_2_prl
via_V0_20_bad_0.006_condition_2 = RECTANGLE ENCLOSURE via_V0_20_0.006_condition_2 M1 ABUT<90 SINGULAR 
GOOD 0.006 0.059 OPPOSITE 0.006 0.059 OPPOSITE
via_V0_20_bad_0.006 = OR via_V0_20_bad_0.006_condition_1 via_V0_20_bad_0.006_condition_2
via_V0_20_good_0.006 = (OR via_V0_20_0.006_condition_1 via_V0_20_0.006_condition_2) NOT via_V0_20_bad_0.006
 
//;condition 1 
via_V0_20_enc_0.007 = ENC [via_V0_20] met_V0_20 == 0.007 ABUT<90 OPPOSITE
via_V0_20_ext_0.007_condition_1 = EXT (via_V0_20_enc_0.007) M1 >= 0.058+0.007 <= 0.062+0.007 ABUT<90 OPPOSITE EXTENDED 0.015 MEASURE ALL
via_V0_20_0.007_condition_1 = via_V0_20 WITH EDGE via_V0_20_ext_0.007_condition_1
via_V0_20_bad_0.007_condition_1 = RECTANGLE ENCLOSURE via_V0_20_0.007_condition_1 M1 ABUT<90 SINGULAR 
GOOD 0.007 0.059 OPPOSITE 0.007 0.059 OPPOSITE
//;condition 2 
via_V0_20_ext_0.007_condition_2_min = EXT [via_V0_20_enc_0.007] M1 >= 0.058+0.007 <= 0.062+0.007 ABUT<90 OPPOSITE EXTENDED 0.015 MEASURE ALL
via_V0_20_ext_0.007_condition_2_max = EXT [via_V0_20_enc_0.007] M1 >= 0.058+0.007 <= 0.062+0.007 ABUT<90 OPPOSITE EXTENDED 0.154 MEASURE ALL
via_V0_20_ext_0.007_condition_2_prl = via_V0_20_ext_0.007_condition_2_max NOT TOUCH EDGE (via_V0_20 TOUCH EDGE via_V0_20_ext_0.007_condition_2_min)
via_V0_20_0.007_condition_2 = via_V0_20 WITH EDGE via_V0_20_ext_0.007_condition_2_prl
via_V0_20_bad_0.007_condition_2 = RECTANGLE ENCLOSURE via_V0_20_0.007_condition_2 M1 ABUT<90 SINGULAR 
GOOD 0.007 0.059 OPPOSITE 0.007 0.059 OPPOSITE
via_V0_20_bad_0.007 = OR via_V0_20_bad_0.007_condition_1 via_V0_20_bad_0.007_condition_2
via_V0_20_good_0.007 = (OR via_V0_20_0.007_condition_1 via_V0_20_0.007_condition_2) NOT via_V0_20_bad_0.007
 
//;condition 1 
via_V0_20_enc_0.008 = ENC [via_V0_20] met_V0_20 == 0.008 ABUT<90 OPPOSITE
via_V0_20_ext_0.008_condition_1 = EXT (via_V0_20_enc_0.008) M1 >= 0.058+0.008 <= 0.062+0.008 ABUT<90 OPPOSITE EXTENDED 0.015 MEASURE ALL
via_V0_20_0.008_condition_1 = via_V0_20 WITH EDGE via_V0_20_ext_0.008_condition_1
via_V0_20_bad_0.008_condition_1 = RECTANGLE ENCLOSURE via_V0_20_0.008_condition_1 M1 ABUT<90 SINGULAR 
GOOD 0.008 0.059 OPPOSITE 0.008 0.059 OPPOSITE
//;condition 2 
via_V0_20_ext_0.008_condition_2_min = EXT [via_V0_20_enc_0.008] M1 >= 0.058+0.008 <= 0.062+0.008 ABUT<90 OPPOSITE EXTENDED 0.015 MEASURE ALL
via_V0_20_ext_0.008_condition_2_max = EXT [via_V0_20_enc_0.008] M1 >= 0.058+0.008 <= 0.062+0.008 ABUT<90 OPPOSITE EXTENDED 0.154 MEASURE ALL
via_V0_20_ext_0.008_condition_2_prl = via_V0_20_ext_0.008_condition_2_max NOT TOUCH EDGE (via_V0_20 TOUCH EDGE via_V0_20_ext_0.008_condition_2_min)
via_V0_20_0.008_condition_2 = via_V0_20 WITH EDGE via_V0_20_ext_0.008_condition_2_prl
via_V0_20_bad_0.008_condition_2 = RECTANGLE ENCLOSURE via_V0_20_0.008_condition_2 M1 ABUT<90 SINGULAR 
GOOD 0.008 0.059 OPPOSITE 0.008 0.059 OPPOSITE
via_V0_20_bad_0.008 = OR via_V0_20_bad_0.008_condition_1 via_V0_20_bad_0.008_condition_2
via_V0_20_good_0.008 = (OR via_V0_20_0.008_condition_1 via_V0_20_0.008_condition_2) NOT via_V0_20_bad_0.008

via_V0_20_good = OR via_V0_20_good_0.005 via_V0_20_good_0.006 via_V0_20_good_0.007 via_V0_20_good_0.008
via_V0_19_20_good = OR via_V0_19a_19b_good via_V0_20_good

via_V0_10_11_12_13_14_15_16_17_18_19 = OR via_V0_10_11_12_13_14_15_16_17_18 via_V0_19a_19b_good

V0_EN_20 {
@ V0 enclosure by M1 (short side of M1 width = 0.084 or 0.09um) for two opposite sides, when
@ 1. M1 space: S < 0.058um or > 0.062um and the adjacent side enclosure 0.005 <= E <= 0.008um, with PRL > -0.015
@ 2. At most one M1 polygon (0.058um <= M1 space <= 0.062um, and the adjacent side enclosure 0.005 <= E <= 0.008um, -0.154um < PRL <= -0.015um) >= 0.059um
 err1_0.005 = via_V0_20_bad_0.005 NOT via_V0_10_11_12_13_14_15_16_17_18_19
 err1_0.005 NOT INSIDE SealR_NOT_BULK
 err1_0.006 = via_V0_20_bad_0.006 NOT via_V0_10_11_12_13_14_15_16_17_18_19
 err1_0.006 NOT INSIDE SealR_NOT_BULK
 err1_0.007 = via_V0_20_bad_0.007 NOT via_V0_10_11_12_13_14_15_16_17_18_19
 err1_0.007 NOT INSIDE SealR_NOT_BULK
 err1_0.008 = via_V0_20_bad_0.008 NOT via_V0_10_11_12_13_14_15_16_17_18_19
 err1_0.008 NOT INSIDE SealR_NOT_BULK
}

//;beginning of the V0.EN.21 ~ V0.EN.23 derivations
 met_V0_21 = M1 WITH WIDTH > 0.09
 via_V0_21 = V0N INTERACT met_V0_21
 via_V0_21a = via_V0_21 INTERACT M0G_050_ALL
 via_V0_21b = via_V0_21 NOT via_V0_21a

 via_V0_21a_bad = RECTANGLE ENCLOSURE via_V0_21a M1 ABUT<90 SINGULAR
 GOOD V0_EN_9_val V0_EN_9_val V0_EN_9_val V0_EN_9_val OPPOSITE
 GOOD 0.015 V0_EN_21a_val OPPOSITE 0.015 V0_EN_21a_val OPPOSITE
 via_V0_21b_bad = RECTANGLE ENCLOSURE via_V0_21b M1 ABUT<90 SINGULAR
 GOOD V0_EN_9_val V0_EN_9_val V0_EN_9_val V0_EN_9_val OPPOSITE
 GOOD 0.014 V0_EN_21b_val OPPOSITE 0.014 V0_EN_21b_val OPPOSITE

via_V0_21a_good = via_V0_21a NOT via_V0_21a_bad
via_V0_21b_good = via_V0_21b NOT via_V0_21b_bad
//;end of the V0.EN.21 ~ V0.EN.23 derivations

VARIABLE V0_EN_21a_val 0.023
VARIABLE V0_EN_21b_val 0.024

V0_EN_21a {
@ V0 enclosure by M1 (short side of M1 width > 0.09um) for two opposite sides with the other two sides >= 0.015um when V0 interact with M0G (width = 0.05um) >= 0.023um
 err1 = via_V0_21a_bad NOT (OR via_V0_10_11_12_13_14_15_16_17_18_19 via_V0_20_good via_V0_21b_good via_V0_22_23_good)  //;can't exclude
 err1 NOT INSIDE SealR_NOT_BULK
}

V0_EN_21b {
@ V0 enclosure by M1 (short side of M1 width > 0.09um) for two opposite sides with the other two sides >= 0.014um, except V0 interact with M0G (width = 0.05um) >= 0.024um
 err1 = via_V0_21b_bad NOT (OR via_V0_10_11_12_13_14_15_16_17_18_19 via_V0_20_good via_V0_21a_good via_V0_22_23_good)
 err1 NOT INSIDE SealR_NOT_BULK
}

//;beginning of the V0.EN.22 derivations
 met_V0_22 = met_V0_21 WITH WIDTH > 0.09 <= 0.2
 via_V0_22 = (V0N INTERACT met_V0_22) INTERACT M0G_050_ALL

 via_V0_22_bad = RECTANGLE ENCLOSURE via_V0_22 M1 ABUT<90 SINGULAR
 GOOD V0_EN_9_val V0_EN_9_val V0_EN_9_val V0_EN_9_val OPPOSITE
 GOOD 0.015 V0_EN_21a_val OPPOSITE 0.015 V0_EN_21a_val OPPOSITE  //;exclude V0_EN_21a
 GOOD 0.024 OPPOSITE 0.009 OPPOSITE V0_EN_22_val OPPOSITE V0_EN_22_val OPPOSITE
 GOOD 0.009 OPPOSITE 0.024 OPPOSITE V0_EN_22_val OPPOSITE V0_EN_22_val OPPOSITE

 via_V0_22_good = (via_V0_22 NOT via_V0_22_bad) NOT WITH EDGE (ENC [via_V0_22] M1 < 0.009 ABUT<90 SINGULAR)
//;beginning of the V0.EN.22 derivations

VARIABLE V0_EN_22_val 0.059
VARIABLE V0_EN_23_val 0.059

V0_EN_22 {
@ V0 enclosure by M1 (short side of M1 width > 0.09um and <= 0.2um) for at least two adjacent edges with the other two sides >= 0.024um and >= 0.009um when V0 interact with M0G (width = 0.05um) >= 0.059um
 err1 = via_V0_22_bad NOT (OR via_V0_10_11_12_13_14_15_16_17_18_19 via_V0_20_good via_V0_21a_good via_V0_23_good)
 err2 = ENC (via_V0_22 NOT (OR via_V0_10_11_12_13_14_15_16_17_18_19 via_V0_20_good via_V0_21a_good via_V0_23_good)) M1 < 0.009 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

//;beginning of the V0.EN.23 derivations
 met_V0_23 = met_V0_21 WITH WIDTH > 0.09 <= 0.2
 via_V0_23 = (V0N INTERACT met_V0_23) NOT INTERACT M0G_050_ALL

 via_V0_23_bad = RECTANGLE ENCLOSURE via_V0_23 M1 ABUT<90 SINGULAR
 GOOD V0_EN_9_val V0_EN_9_val V0_EN_9_val V0_EN_9_val OPPOSITE
 GOOD 0.014 V0_EN_21b_val OPPOSITE 0.014 V0_EN_21b_val OPPOSITE  //;exclude V0_EN_21b
 GOOD 0.025 OPPOSITE 0.009 OPPOSITE V0_EN_23_val OPPOSITE V0_EN_23_val OPPOSITE
 GOOD 0.009 OPPOSITE 0.025 OPPOSITE V0_EN_23_val OPPOSITE V0_EN_23_val OPPOSITE

 via_V0_23_good = (via_V0_23 NOT via_V0_23_bad) NOT WITH EDGE (ENC [via_V0_23] M1 < 0.009 ABUT<90 SINGULAR)
 via_V0_22_23_good = OR via_V0_22_good via_V0_23_good
//;beginning of the V0.EN.23 derivations

V0_EN_23 {
@ V0 enclosure by M1 (short side of M1 width > 0.09um and <= 0.2um) for at least two adjacent edges with the other two sides >= 0.025um and >= 0.009um, except V0 interact with M0G (width = 0.05um) >= 0.059um
 err1 = via_V0_23_bad NOT (OR via_V0_10_11_12_13_14_15_16_17_18_19 via_V0_20_good via_V0_21b_good via_V0_22_good)
 err2 = ENC (via_V0_23 NOT (OR via_V0_10_11_12_13_14_15_16_17_18_19 via_V0_20_good via_V0_21b_good via_V0_22_good)) M1 < 0.009 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

V0_EN_24 {
@ V0 enclosure by M1 for two opposite sides (projection space between V0 and M1 inner vertex = -0.007 ~ -0.026um, enclosure by M1 edge < 0.003um at opposite side of M1 inner vertex, the inner vertex with M1 width <= 0.046um and jog height > 0.014um) >= 0.039um
 tar_CHK_JOG = LENGTH M1_convex_270_90_edges > 0.014
 tar_CHK_MET_SIDE = CONVEX EDGE M1 ANGLE1 >= 90 LENGTH1 > 0 ANGLE2 == 270 LENGTH2 > 0.014
 tar_CHK_PRL_MET_SIDE = LENGTH (ENC V0N [tar_CHK_MET_SIDE] <= 0.046-V0_MiniWidth ABUT<90 OPPOSITE PARA) >= (V0_MiniWidth - 0.026) <= (V0_MiniWidth - 0.007)
 tar_CHK_PRL_VIA_SIDE = LENGTH (ENC [V0N] tar_CHK_MET_SIDE <= 0.046-V0_MiniWidth ABUT<90 OPPOSITE PARA) >= (V0_MiniWidth - 0.026) <= (V0_MiniWidth - 0.007)
 tar_CHK_PRL_VIA = V0N WITH EDGE tar_CHK_PRL_VIA_SIDE

 tar_ENC_JOG_TMP = ENC [tar_CHK_PRL_VIA] tar_CHK_JOG <= 0.046-V0_MiniWidth+0.0001 PERP ONLY
 tar_ENC_JOG = tar_ENC_JOG_TMP TOUCH EDGE (tar_CHK_PRL_VIA TOUCH EDGE (ENC [V0N] tar_CHK_MET_SIDE <= 0.046-V0_MiniWidth ABUT<90 OPPOSITE PARA))
 tar_ENC_VIA_SIDE = tar_CHK_PRL_VIA TOUCH EDGE tar_ENC_JOG
 tar_ENC_VIA_CHECK = tar_CHK_PRL_VIA TOUCH EDGE (ENC [tar_ENC_VIA_SIDE] M1 <= 0.046-V0_MiniWidth ABUT<90 OPPOSITE)
 tar_TWO_JOG_BESIDE = INT [tar_ENC_VIA_CHECK] <= V0_MiniWidth OPPOSITE
 tar_ONE_JOG_BESIDE = (INT tar_ENC_VIA_CHECK [tar_CHK_PRL_VIA] <= V0_MiniWidth OPPOSITE) NOT TOUCH EDGE tar_TWO_JOG_BESIDE

 tar_CHK_AREA = INT M1 (tar_CHK_MET_SIDE TOUCH EDGE tar_CHK_PRL_MET_SIDE) <= 0.046 ABUT<90 OPPOSITE REGION
 tar_CHK_VIAS = tar_CHK_PRL_VIA NOT OUTSIDE tar_CHK_AREA
 tar_CHK_TYPE_1 = tar_CHK_VIAS WITH EDGE (ENC [tar_ONE_JOG_BESIDE] M1 < 0.003 ABUT<90 OPPOSITE)
 tar_CHK_TYPE_2 = tar_CHK_VIAS WITH EDGE (ENC [tar_TWO_JOG_BESIDE] M1 < 0.003 ABUT<90 OPPOSITE)
 tar_CHK = (OR tar_CHK_TYPE_1 tar_CHK_TYPE_2) WITH EDGE tar_ENC_VIA_SIDE
 err1 = RECTANGLE ENCLOSURE tar_CHK M1 ABUT<90 SINGULAR GOOD 0 0.039 OPPOSITE 0 0.039 OPPOSITE
 err1 NOT INSIDE SealR_NOT_BULK
}
 
V0_EN_25 {
@ V0 enclosure by M1 for the long side edge (0.036um <= M1 width <= 0.041um, and the long side space >= 0.058um and < 0.063um, and the opposite long side space >= 0.068um, PRL > 0.136um) >= 0.005um
 met_wid_all = M1 WITH WIDTH > 0.036-GLOBAL_TOLERANCE <= 0.041
 met_err_RAW_a = EXT [met_wid_all] M1 >= 0.058 < 0.063 ABUT<90 OPPOSITE MEASURE ALL
 met_err_RAW_b = EXT met_wid_all M1 >= 0.058 < 0.063 ABUT<90 OPPOSITE MEASURE ALL
 met_err_RAW_c = EXT met_wid_all [M1] >= 0.058 < 0.063 ABUT<90 OPPOSITE MEASURE ALL
 met_err_PRL = DFM PROPERTY met_err_RAW_b met_err_RAW_c OVERLAP ABUT ALSO MULTI [-= max(LENGTH(met_err_RAW_c))] >= 0.136+GLOBAL_TOLERANCE
 // 
 met_err_EGE_a = met_err_RAW_a COIN EDGE (DFM COPY met_err_PRL EDGE)
 met_err_EGE_b = ENC V0N [met_err_EGE_a] < 0.005 ABUT<90 OPPOSITE
 met_err_EGE_c = INT met_err_EGE_b [M1] > 0.036-GLOBAL_TOLERANCE <= 0.041 ABUT<90 OPPOSITE MEASURE COIN
 met_err_EGE_d = EXT (met_err_EGE_c) M1 < 0.068 ABUT<90 OPPOSITE
 met_err_EGE_e = met_err_EGE_b COIN EDGE M1
 err1 = INT met_err_EGE_d [met_err_EGE_e] > 0.036-GLOBAL_TOLERANCE <= 0.041 ABUT<90 OPPOSITE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

VARIABLE V0_D_1_val 7.7
VARIABLE V0_D_1_window 5

#IFDEF RECOMMENDED_CHECK YES
V0_D_1_R {
@ (V0 OR RV0) density (window 5um*5um, stepping 2.5um) < 7.7%
 check_region = COPY CHIP_NOT_MARKS
 check_pattern = (V0 NOT V0_BAR) AND check_region

 check_window1 = check_region WITH WIDTH >= V0_D_1_window/4
 err1_TMP1 = DENSITY check_pattern check_window1 check_region [!!AREA(check_window1)*AREA(check_pattern)/AREA(check_region)] >= V0_D_1_val/100 WINDOW V0_D_1_window STEP V0_D_1_window/2 BACKUP INSIDE OF LAYER DRC:1 BY POLYGON

 check_window2 = WITH WIDTH (check_region AND err1_TMP1) >= V0_D_1_window/4
 err1_TMP2 = DENSITY check_pattern check_window2 check_region [!!AREA(check_window2)*AREA(check_pattern)/AREA(check_region)] >= V0_D_1_val/100 WINDOW V0_D_1_window STEP V0_D_1_window/2 BACKUP INSIDE OF LAYER err1_TMP1 BY POLYGON

 check_window3 = WITH WIDTH (check_region AND err1_TMP2) >= V0_D_1_window/4
 DENSITY check_pattern check_window3 check_region [!!AREA(check_window3)*AREA(check_pattern)/AREA(check_region)] >= V0_D_1_val/100 WINDOW V0_D_1_window STEP V0_D_1_window/2 BACKUP INSIDE OF LAYER err1_TMP2 BY POLYGON PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_V0_D_1_R.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_V0_D_1_R.rdb"
}
#ENDIF

#IFDEF DFM_RULES_PRIORITY_1 YES
V0_EN_27_DFM1 {
@ Enclosure by M1 edge at opposite side of M1 inner vertex (projection space between V0 and the M1 inner vertex < 0.012um,
@ the inner vertex with width = 0.035~0.046um and jog height >= 0.004um) >= 0.003um
 tar_enc1 = M1 TOUCH EDGE (ENC V0N [M1] < 0.003 ABUT<90 OPPOSITE)
 tar_enc2 = M1 TOUCH EDGE (INT tar_enc1 [M1_convex_lt_two_edges] >= 0.035 <= 0.046 PARA ONLY OPPOSITE)
 tar_corner = EXT tar_enc2 (LENGTH M1_convex_lt_two_edges >= 0.004) < 0.001 ABUT INTERSECTING ONLY REGION

 tar_enc3 = tar_enc2 TOUCH EDGE tar_corner
 tar_enc4 = M1 TOUCH EDGE tar_corner
 tar_wide = INT tar_enc3 M1 >= 0.035 <= 0.046 PARA ONLY OPPOSITE REGION
 tar_side = M1 TOUCH EDGE (INT tar_enc3 [M1] >= 0.035 <= 0.046 PARA ONLY OPPOSITE)

 tar_vias = V0N WITH EDGE (ENC [V0N] tar_side < 0.003 ABUT<90 OPPOSITE)
 tar_vias_corner = tar_enc4 COIN EDGE (M1 ENCLOSE tar_vias)
 tar_vias_apart = EXT [tar_vias] tar_vias_corner < 0.012 ABUT<90 OPPOSITE EXTENDED 0.046-V0_MiniWidth+GLOBAL_TOLERANCE MEASURE ALL
 tar_vias_cross = SIZE ((tar_vias NOT WITH EDGE tar_vias_apart) NOT INSIDE tar_wide) BY 0.046-V0_MiniWidth+GLOBAL_TOLERANCE
 tar_vias_touch = SIZE (((tar_vias NOT WITH EDGE tar_vias_apart) INSIDE tar_wide) WITH EDGE (tar_vias COIN EDGE (tar_wide NOT COIN EDGE M1))) BY 0.046-V0_MiniWidth+GLOBAL_TOLERANCE
 err1 = tar_vias WITH EDGE tar_vias_apart
 err2 = tar_vias INTERACT (tar_vias_cross INTERACT (tar_vias_cross AND tar_corner))
 err3 = tar_vias INTERACT (tar_vias_touch INTERACT (tar_vias_touch AND tar_corner))
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
}
#ENDIF

#IFDEF DOUBLE_PATTERNING_RULES_CHECK YES
#IFDEF DFM_RULES_PRIORITY_2 YES
#IFDEF DOUBLE_PATTERNING_RULES_CHECK_ONLY YES
DRC SELECT CHECK V0_R_1_DFM2
#ENDIF
V0_R_1_DFM2 {
@ Only one same color square V0 in 0.5*0.5um area is not allowed
@ DRC waive if >= 5 V0 exist in the 0.5*0.5um area
 color_a = copy V0_mask0
 color_b = copy V0_mask1
 waive_via = V0_SR WITH NEIGHBOR >= 4 SPACE <= 0.5
 err1 = V0N INTERACT ((V0_SR INTERACT color_a) WITH NEIGHBOR == 1 SPACE <= 0.5)
 err2 = V0N INTERACT ((V0_SR INTERACT color_b) WITH NEIGHBOR == 1 SPACE <= 0.5)
 err1 NOT INSIDE waive_via
 err2 NOT INSIDE waive_via
}
#ENDIF
#ENDIF

V0_R_1 {
@ 45-degree V0 and RV0 is not allowed, except V0 bar in MARKS/MARKG/INDMY/LOGO regions
 err1 = ANGLE (V0 NOT MARKS_MARKG_INDMY_LOGO) > 44.5 < 45.5
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
V0_R_2 {
@ Single V0 is not allowed in "H-shape" M1, when:
@ M1 has "H-shape" interacting with two metal holes:
@ 1. Both two holes length <= 4.5um and area <= 4.05um2
@ 2. The V0 overlaps the center metal bar of this "H-shape" M1
@ 3. The center metal bar length <= 0.9um and width <= 0.12um
 // DRC doesn't check when one or more square V0 is also on H-shape M1 region
 hole_area_meet = AREA (HOLES M1 INNER) <= 4.05
 hole_area_meet_len = (hole_area_meet WITH EDGE (LENGTH hole_area_meet <= 0.9)) NOT WITH EDGE (LENGTH hole_area_meet > 4.5)
 hole_area_real = (hole_area_meet_len NOT ENCLOSE RECTANGLE 0.9+GLOBAL_TOLERANCE 4.5) NOT ENCLOSE RECTANGLE 0.9 4.5+GLOBAL_TOLERANCE
 hole_bars_len = M1 COIN EDGE hole_area_real
 // 
 hole_bars = INT hole_bars_len <= 0.12 ABUT<90 OPPOSITE REGION EXCLUDE SHIELDED
 hole_bars_real = hole_bars WITH EDGE (LENGTH hole_bars_len <= 0.9)
 hole_bars_vias_sq = V0N INTERACT ((hole_bars_real INTERACT hole_area_real == 2) NOT ENCLOSE RV0)
 err1 = hole_bars_real INTERACT hole_bars_vias_sq == 1
 err1 NOT INSIDE SealR_NOT_BULK
}

V0_R_3 {
@ V0 and RV0 overlap with (DUM_AA OR DUM_GT) is not allowed
 err1 = AND V0 (DUM_AA OR DUM_GT)
 err1 NOT INSIDE SealR_NOT_BULK
}

V0_R_5 {
@ It's not allowed (V0 OR RV0) overlap with the M1 resistor
 err1 = V0 AND M1RES
 err1 NOT INSIDE SealR_NOT_BULK
}

#IFDEF RECOMMENDED_CHECK YES
V0_R_6_R {
@ Recommend space between a square V0 and another (V0 OR RV0 OR DUM_V0) < 4um to avoid single square V0
 ALL_VIA_CHECK = OR V0_SR DUM_V0
 STEP_1 = SIZE V0_SR BY 1.4  //;4/1.414 = 2.828
 STEP_1_GOOD = STEP_1 INTERACT ALL_VIA_CHECK > 1
 STEP_1_FILTER = V0N NOT INTERACT STEP_1_GOOD
 err1 = STEP_1_FILTER NOT WITH EDGE (EXT [STEP_1_FILTER] ALL_VIA_CHECK < 4 PERP ALSO)
 err1 NOT INSIDE SealR_NOT_BULK
}
#ENDIF

//;V0.R.4: delta voltage rule
//------------------------------------------------------------------------------------------------------------------------------------------
//	V0.OR[NC]	Odd ring conflict space definition: 
//	1. Odd ring conflict space (ORCS): pitch space < 0.108um
//	odd ring conflict line definition:
//	2. Odd ring conflict line (ORCL): The line between two VIAs with ORCS
//	3. ORCLs are independent to all other ones, even if they are overlapped or crossed
//	4. Including square V0 and rectangular V0
//	OR-AREA definition: 
//	1. Odd ring line area (ORLA): The projection area between two edges with ORLS
//	2. Odd ring corner area (ORCA): The line between two corners with ORCS
//	3. ORLA or ORCA region are independent to all other ones, even if they are overlapped or crossed
//	Loop:
//	   1. A loop is formed when polygons of (V0 OR RV0) are connected in a cycle sequence with OR-AREA in between
//	   2. A loop cannot contain any sub-loops which share one or more polygons with it
//	Path:
//	   A path is formed when polygons of (V0 OR RV0) are connected one by one from one marker to another marker with OR-AREA in between
//------------------------------------------------------------------------------------------------------------------------------------------

RV0_cen_edges = DFM COPY (DFM SPACE (RV0 NOT (EXPAND EDGE RV0_W INSIDE BY 0.0159)) == 0.032 BY INT) CENTERLINE
V0_RN_cen = OR (EXTENTS V0N CENTERS 0.0002) (EXTENTS (EXPAND EDGE RV0_cen_edges INSIDE BY 0.0001 OUTSIDE BY 0.0001))
V0_ORCS_1 = EXT V0_RN_cen < 0.108-0.0002 ABUT<90

#IFDEF DOUBLE_PATTERNING_RULES_CHECK YES
#IFDEF DOUBLE_PATTERNING_RULES_CHECK_ONLY YES
GROUP GV0DP V0_OR_?
DRC SELECT CHECK GV0DP
#ENDIF

V0_conflict = DFM DP RING V0_RN_cen V0_ORCS_1 (OPPOSITE 0)
V0_warning = DFM DP WARNING V0_RN_cen V0_ORCS_1 (OPPOSITE 0)
V0_mask0 = DFM DP MASK0 V0_RN_cen V0_ORCS_1 (OPPOSITE 0)
V0_mask1 = DFM DP MASK1 V0_RN_cen V0_ORCS_1 (OPPOSITE 0)
V0_conflict_anchor = DFM DP ANCHOR_CONFLICT V0 V0_ORCS_1 (OPPOSITE 0) V0CA(anchor mask0) V0CB(anchor mask1) UNFILTERED

V0_OR_1_2 {
@ V0.OR.1: ORCL cannot cross other ORCL or touch other ORCLs
@ V0.OR.2: ORCL count of the closed loop formed by original polygons and ORCLs cannot be odd number
@ V0.OR.10: ORCA cross another ORCA or touch ORLA is not allowed
@ V0.OR.11: OR-AREA count of the close loop formed by original polygons and OR-AREA cannot be odd number
 err1 = COPY V0_conflict
 err1 NOT INSIDE SealR_NOT_BULK
}

V0_OR_2_warning {
@ V0 DP even cycles associated with an odd cycle violation
@ Avoid fixing odd cycle locations that touch a warning ring
 err1 = COPY V0_warning
 err1 NOT INSIDE SealR_NOT_BULK
}

V0_OR_3 {
@ V0DPMK must be drawn identically to V0 or RV0
 err1 = (V0_SR INTERACT V0DPMK) XOR V0DPMK
 err2 = V0DPMK NOT COIN EDGE V0_SR
 err3 = V0DPMK NOT V0_SR
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE EDGE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
}

//;Flag (V0CA, V0CB or V0DPMK) interact ORCS
V0CA_RN_cen = V0_RN_cen INTERACT V0CA
V0CB_RN_cen = V0_RN_cen INTERACT V0CB
V0DPMK_RN_cen = V0_RN_cen INTERACT V0DPMK

V0_OR_4 {
@ (V0 INTERACT V0DPMK) cannot have ORCS with V0 (including square V0 and rectangular V0)
 err1 = EXT V0CA_RN_cen < 0.108 - 0.0002 REGION
 err2 = EXT V0CB_RN_cen < 0.108 - 0.0002 REGION
 err3 = EXT V0DPMK_RN_cen < 0.108 - 0.0002 REGION
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
 }

V0_OR_5 {
@ (V0 INTERACT INST) INTERACT V0DPMK is not allowed (including square V0 and rectangular V0)
 err1 = (V0_SR INTERACT INST) INTERACT V0DPMK SINGULAR ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

V0_OR_6 {
@ Pre-coloring marker V0CA and V0CB must be drawn identically to (V0 OR RV0)
 err1 = V0CA NOT COIN INSIDE EDGE V0
 err2 = V0CB NOT COIN INSIDE EDGE V0
 err1 NOT INSIDE EDGE SealR_NOT_BULK
 err2 NOT INSIDE EDGE SealR_NOT_BULK
}

V0_OR_7 {
@ V0CA INTERACT V0CB is not allowed
 err1 = V0CA INTERACT V0CB SINGULAR ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

V0_OR_8 {
@ (V0 INTERACT INST) INTERACT (V0CA OR V0CB) is not allowed
 err1 = (V0CA OR V0CB) INTERACT (V0 INTERACT INST) SINGULAR ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

V0_OR_9 {
@ (V0CA OR V0CB) INTERACT V0DPMK is not allowed
 err1 = (V0CA OR V0CB) INTERACT V0DPMK SINGULAR ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

V0_OR_12_13_14 {
@ OR-AREA count of any path starting from V0CA and ending at V0CA must not be a odd number
@ OR-AREA count of any path starting from V0CB and ending at V0CB must not be a odd number
@ OR-AREA count of any path starting from V0CA and ending at V0CB must not be a even number
 err1 = COPY V0_conflict_anchor
 err1 NOT INSIDE SealR_NOT_BULK
}

V0_OR_15 {
@ Maximum pre-coloring ratio of ((V0CA + V0CB + V0DPMK)/(V0 OR RV0)) before decomposition < 16%
 check_pattern = (V0CA OR V0CB) OR V0DPMK
 check_region = COPY V0
 DENSITY check_pattern check_region [AREA(check_pattern)/AREA(check_region)] >= 0.16 PRINT "./SMIC_14SFPLUS_DRC_logFile/pre_coloring_ratio_V0_OR_15.log" RDB "./SMIC_14SFPLUS_DRC_logFile/pre_coloring_ratio_V0_OR_15.rdb"
}

#IFDEF SHOW_DOUBLE_PATTERNING_CONFLICT_SPACE YES
V0_ORCS_1 {
@ (V0 OR RV0) Pitch space >= 0.108um
 err1 = DFM COPY V0_ORCS_1 REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
#ENDIF
#ENDIF


// =======================================================
// Rectangular Via-0 design rules
// =======================================================

GROUP GRV0 RV0_?

RV0_W_1_L_1 {
@ RV0.W.1: Rectangular V0 width, except OCOVL, MARKS and MARKG region = 0.032um
@ RV0.L.1: Rectangular V0 length, except OCOVL, MARKS and MARKG region = 0.080um
 WAIVE_AREA = OR MARKS_MARKG_INDMY_LOGO OCOVL
 err1 = (V0 NOT RV0) NOT V0N
 err1 NOT INSIDE WAIVE_AREA
}

RV0_L_2 {
@ V0 bar length (width = 0.1um) >= 0.35um
 err1 = LENGTH (INT [V0_BAR_100] == 0.1 OPPOSITE) < 0.35
 err1 NOT INSIDE EDGE SealR_NOT_BULK

 check_VIA = V0 INSIDE MARKS_MARKG_INDMY_LOGO
 check_EDG = INT [check_VIA] == 0.1 ABUT<90 OPPOSITE ANGLED==0
 err2 = LENGTH check_EDG < 0.35
 err2 NOT INSIDE EDGE SealR_NOT_BULK
}

RV0_S_1 {
@ Space between square V0 and rectangular V0 >= 0.049um
 err1 = EXT V0N RV0 < 0.049 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

RV0_S_2 {
@ Space between two rectangular V0s >= 0.047um
 err1 = EXT RV0 < 0.047 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

RV0_S_3 {
@ Space between rectangular V0 and square or rectangular V0 when PRL >= -0.026um, DRC only flag the point-to-point space when PRL <= 0. >= 0.051um
 err1 = EXT V0_SR RV0 < 0.051 ABUT<90 OPPOSITE EXTENDED 0.001 REGION
 err1 NOT INSIDE SealR_NOT_BULK

 err2_RAW = EXT V0_SR RV0 < 0.051 ABUT<90 CORNER TO CORNER
 err2_TMP = DFM PROPERTY err2_RAW [-= (EWXP(err2_RAW) <= 0.026 || EWYP(err2_RAW) <= 0.026) ? 1 : 0] > 0
 err2 = DFM COPY err2_TMP REGION
 err2 NOT INSIDE SealR_NOT_BULK
}

VARIABLE RV0_S_4_val 0.074

RV0_S_4 {
@ Space between rectangular V0 to square or rectangular V0 when PRL > -0.032um for the short side of rectangular V0 >= 0.074um
 err1 = EXT V0N RV0_W < RV0_S_4_val ABUT<90 OPPOSITE EXTENDED 0.001 REGION
 err2 = EXT RV0_W RV0 < RV0_S_4_val ABUT<90 OPPOSITE EXTENDED 0.001 REGION
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK

 Y1 = EXT V0N (ANGLE RV0_W == 0) < RV0_S_4_val ABUT<90 NOT PROJ
 Y2 = DFM PROPERTY Y1 GLOBALXY [-= (EWXP(Y1) < 0.032) ? 1 : 0] > 0
 err3 = DFM COPY Y2 REGION
 err3 NOT INSIDE SealR_NOT_BULK

 Y3 = EXT V0N (ANGLE RV0_W == 90) < RV0_S_4_val ABUT<90 NOT PROJ
 Y4 = DFM PROPERTY Y3 GLOBALXY [-= (EWYP(Y3) < 0.032) ? 1 : 0] > 0
 err4 = DFM COPY Y4 REGION
 err4 NOT INSIDE SealR_NOT_BULK

 Z1 = EXT (ANGLE RV0_W == 0) < RV0_S_4_val ABUT<90 NOT PROJ
 Z2 = DFM PROPERTY Z1 GLOBALXY [-= (EWXP(Z1) < 0.032) ? 1 : 0] > 0
 err5 = DFM COPY Z2 REGION
 err5 NOT INSIDE SealR_NOT_BULK

 Z3 = EXT (ANGLE RV0_W == 90) < RV0_S_4_val ABUT<90 NOT PROJ
 Z4 = DFM PROPERTY Z3 GLOBALXY [-= (EWYP(Z3) < 0.032) ? 1 : 0] > 0
 err6 = DFM COPY Z4 REGION
 err6 NOT INSIDE SealR_NOT_BULK

 Z5 = EXT (ANGLE RV0_L == 0) (ANGLE RV0_W == 0) < RV0_S_4_val ABUT<90 NOT PROJ
 Z6 = DFM PROPERTY Z5 GLOBALXY [-= (EWXP(Z5) < 0.032) ? 1 : 0] > 0
 err7 = DFM COPY Z6 REGION
 err7 NOT INSIDE SealR_NOT_BULK

 Z7 = EXT (ANGLE RV0_L == 90) (ANGLE RV0_W == 90) < RV0_S_4_val ABUT<90 NOT PROJ
 Z8 = DFM PROPERTY Z7 GLOBALXY [-= (EWYP(Z7) < 0.032) ? 1 : 0] > 0
 err8 = DFM COPY Z8 REGION
 err8 NOT INSIDE SealR_NOT_BULK
}

RV0_S_4a {
@ Space between short side of rectangular V0 when PRL > 0um. = 0.074~0.082, >= 0.1um
 err1 = EXT RV0_W < 0.074 ABUT<90 OPPOSITE REGION
 err2 = EXT RV0_W > 0.082 < 0.100 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

RV0_S_5 {
@ Corner space between rectangular V0 and square or rectangular V0 when PRL <= -0.032um. >= 0.051um
 err1_RAW = EXT V0_SR RV0 < 0.051 ABUT<90 CORNER TO CORNER
 err1_TMP = DFM PROPERTY err1_RAW [-= (EWXP(err1_RAW) >= 0.032 && EWYP(err1_RAW) >= 0.032) ? 1 : 0] > 0
 err1 = DFM COPY err1_TMP REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

RV0_S_6 {
@ Space between the long side of RV0 when PRL > 0um and with one M1 between two RV0s >= 0.115um
 y1 = EXT RV0_L < 0.115 ABUT<90 OPPOSITE REGION
 y2 = EXT [RV0_L] < 0.115 ABUT<90 OPPOSITE
 y3 = EXPAND EDGE y2 INSIDE BY 0.001
 y4 = (y1 or y3) AND M1
 err1_TMP = (y1 or y3) INTERACT y4 >= 3
 err1 = y1 AND err1_TMP
 err1 NOT INSIDE SealR_NOT_BULK
}

RV0_S_7 {
@ Space between RV0 and M0G at different net >= 0.029um
 err1 = EXT (V0 INTERACT RV0) M0G < 0.029 ABUT<90 SINGULAR NOT CONNECTED REGION MEASURE ALL //;based on M0.S.1
 err1 NOT INSIDE SealR_NOT_BULK
}

RV0_S_8 {
@ Space between RV0 and M0G at different net when PRL > -0.012um. >= 0.032um
 err1 = EXT (V0 INTERACT RV0) M0G < 0.032 ABUT<90 OPPOSITE EXTENDED 0.012 NOT CONNECTED REGION MEASURE ALL //;based on M0.S.1
 err1 NOT INSIDE SealR_NOT_BULK
}

RV0_S_9 {
@ Space between RV0 and (M0 NOT M0C) at different net in S/D direction when PRL > -0.016um. >= 0.025um
 err1 = EXT (V0 INTERACT RV0) M0_NOT_M0C_v_edges < 0.025 ABUT<90 OPPOSITE EXTENDED 0.016 NOT CONNECTED REGION MEASURE ALL //;based on M0.S.1
 err1 NOT INSIDE SealR_NOT_BULK
}

RV0_S_10 {
@ Space between RV0 and (M0 NOT M0C) line-end at different net when PRL > 0.01um. >= 0.025um
 err1 = EXT (V0 INTERACT RV0) (M0_NOT_M0C COIN EDGE M0_NOT_M0C_W_edges) < 0.025 ABUT<90 OPPOSITE PROJ>0.01 NOT CONNECTED REGION MEASURE ALL //;based on M0.S.1
 err1 NOT INSIDE SealR_NOT_BULK
}

// RV0.S.11 (purposely blank)

RV0_intact_M0_040 = RV0 INTERACT M0_040_042
RV0_intact_M0_054 = RV0 INTERACT M0_054

M0_040_with_RV0 = M0_040_042 INTERACT RV0_intact_M0_040
M0_054_with_RV0 = M0_054 INTERACT RV0_intact_M0_054

M0C_with_M0_040_RV0 = M0C INTERACT M0_040_with_RV0
M0C_with_M0_054_RV0 = M0C INTERACT M0_054_with_RV0

M0C_with_M0_040_RV0_concave_edges = CONVEX EDGE M0C_with_M0_040_RV0 <= 1
M0C_with_M0_054_RV0_concave_edges = CONVEX EDGE M0C_with_M0_054_RV0 <= 1

VARIABLE RV0_S_12_val 0.038
VARIABLE RV0_S_13_val 0.082

RV0_S_12 {
@ Space between rectangular V0 (INTERACT M0 width = 0.04/0.042um) and M0C concave corner when rectangular V0 and M0C interact same M0 >= 0.038um
 M0C_reversed = DRC:1 NOT (M0C_with_M0_040_RV0 WITH EDGE M0C_with_M0_040_RV0_concave_edges)
 M0C_corner_space_TMP = ENC (RV0_intact_M0_040 AND M0C_reversed) [M0C_reversed] < RV0_S_12_val ABUT
 M0C_corner_TMP = INT [M0C_reversed] M0C_corner_space_TMP < 0.0001 ABUT==90 INTERSECTING ONLY
 M0C_M0_interface = (M0_040_with_RV0 NOT M0C) COIN EDGE M0C_with_M0_040_RV0_concave_edges
 VIA_corner_error_TMP = ENC [RV0_intact_M0_040] M0C_M0_interface < RV0_S_12_val ABUT
 M0C_corner_error_TMP = M0C_reversed COIN EDGE (M0C_corner_TMP COIN EDGE M0C_with_M0_040_RV0_concave_edges)
 err1 = ENC VIA_corner_error_TMP M0C_corner_error_TMP < RV0_S_12_val ABUT REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

RV0_S_13 {
@ Space between rectangular V0 (INTERACT M0 width = 0.054um) and M0C concave corner when rectangular V0 and M0C interact same M0 >= 0.082um
 M0C_reversed = DRC:1 NOT (M0C_with_M0_054_RV0 WITH EDGE M0C_with_M0_054_RV0_concave_edges)
 M0C_corner_space_TMP = ENC (RV0_intact_M0_054 AND M0C_reversed) [M0C_reversed] < RV0_S_13_val ABUT EXCLUDE SHIELDED
 M0C_corner_TMP = INT [M0C_reversed] M0C_corner_space_TMP < 0.0001 ABUT==90 INTERSECTING ONLY
 M0C_M0_interface = (M0_054_with_RV0 NOT M0C) COIN EDGE M0C_with_M0_054_RV0_concave_edges
 VIA_corner_error_TMP = ENC [RV0_intact_M0_054] M0C_M0_interface < RV0_S_13_val ABUT EXCLUDE SHIELDED
 M0C_corner_error_TMP = M0C_reversed COIN EDGE (M0C_corner_TMP COIN EDGE M0C_with_M0_054_RV0_concave_edges)
 err1 = ENC VIA_corner_error_TMP M0C_corner_error_TMP < RV0_S_13_val ABUT REGION EXCLUDE SHIELDED
 err1 NOT INSIDE SealR_NOT_BULK
}

RV0_EN_1 {
@ RV0 must be fully covered by (M0 NOT M0C) or M0G, and must follow RV0.EN.2, or RV0.EN.2a, or RV0.EN.3, or RV0.EN.4, or RV0.EN.5 as below
 err1 = (RV0 NOT INSIDE M0_NOT_M0C) NOT INSIDE M0G
 err1 NOT INSIDE SealR_NOT_BULK
}

//;beginning of the RV0.EN.2~3 derivations
 via_RV0_2_gen = RV0 NOT OUTSIDE M0_NOT_M0C_040
 via_RV0_2_bad = RECTANGLE ENCLOSURE via_RV0_2_gen M0_NOT_M0C ABUT<90 SINGULAR
 GOOD 0.004 OPPOSITE 0.019 OPPOSITE 0.004 OPPOSITE 0.019 OPPOSITE
 via_RV0_2_good = via_RV0_2_gen NOT via_RV0_2_bad

 via_RV0_2a_gen = RV0 NOT OUTSIDE M0_NOT_M0C_042
 via_RV0_2a_bad = RECTANGLE ENCLOSURE via_RV0_2a_gen M0_NOT_M0C ABUT<90 SINGULAR
 GOOD 0.005 OPPOSITE 0.019 OPPOSITE 0.005 OPPOSITE 0.019 OPPOSITE
 via_RV0_2a_good = via_RV0_2a_gen NOT via_RV0_2a_bad
 via_RV0_2_2a_good = OR via_RV0_2_good via_RV0_2a_good

 via_RV0_3_gen = RV0 NOT OUTSIDE M0_NOT_M0C_054
 via_RV0_3_bad = RECTANGLE ENCLOSURE via_RV0_3_gen M0_NOT_M0C ABUT<90 SINGULAR
 GOOD 0.011 OPPOSITE 0.019 OPPOSITE 0.011 OPPOSITE 0.019 OPPOSITE
 via_RV0_3_good = via_RV0_3_gen NOT via_RV0_3_bad
//;end of the RV0.EN.2~3 derivations

RV0_EN_2 {
@ RV0.EN.2: RV0 enclosure by (M0 NOT M0C) (M0 width = 0.04um at least two opposite sides) for two opposite sides with other two sides = 0.004um. >= 0.019um
@ RV0.EN.2a: RV0 enclosure by (M0 NOT M0C) (M0 width = 0.042um at least two opposite sides) for two opposite sides with other two sides = 0.005um. >= 0.019um
 err1 = (OR via_RV0_2_bad via_RV0_2a_bad) NOT (OR via_RV0_3_good via_RV0_4_good via_RV0_5_good)
 err1 NOT INSIDE SealR_NOT_BULK
}

RV0_EN_3 {
@ RV0 enclosure by (M0 NOT M0C) (M0 width = 0.054um at least two opposite sides) for two opposite sides with other two sides = 0.011um. >= 0.019um
 err1 = via_RV0_3_bad NOT (OR via_RV0_2_2a_good via_RV0_4_good via_RV0_5_good)
 err1 NOT INSIDE SealR_NOT_BULK
}

//;beginning of the RV0.EN.4~5 derivations
 via_RV0_4_gen = (RV0 NOT OUTSIDE M0G_040) OR (RV0 NOT OUTSIDE M0G_WIDTH_040)
 via_RV0_4_bad = RECTANGLE ENCLOSURE via_RV0_4_gen M0G ABUT<90 SINGULAR
 GOOD 0.004 OPPOSITE 0.019 OPPOSITE 0.004 OPPOSITE 0.019 OPPOSITE
 via_RV0_4_good = via_RV0_4_gen NOT via_RV0_4_bad

 via_RV0_5_gen = (RV0 NOT OUTSIDE M0G_060) OR (RV0 NOT OUTSIDE M0G_WIDTH_060)
 via_RV0_5_bad = RECTANGLE ENCLOSURE via_RV0_5_gen M0G ABUT<90 SINGULAR
 GOOD 0.014 OPPOSITE 0.029 OPPOSITE 0.014 OPPOSITE 0.029 OPPOSITE
 via_RV0_5_good = via_RV0_5_gen NOT via_RV0_5_bad
//;end of the RV0.EN.4~5 derivations

RV0_EN_4 {
@ RV0 enclosure by M0G (width = 0.04um at least two opposite sides) for two opposite sides with other two sides = 0.004um. >= 0.019um
 err1 = via_RV0_4_bad NOT (OR via_RV0_2_2a_good via_RV0_3_good via_RV0_5_good)
 err1 NOT INSIDE SealR_NOT_BULK
}

RV0_EN_5 {
@ RV0 enclosure by M0G (width = 0.06um at least two opposite sides) for two opposite sides with other two sides = 0.014um. >= 0.029um
 err1 = via_RV0_5_bad NOT (OR via_RV0_2_2a_good via_RV0_3_good via_RV0_4_good)
 err1 NOT INSIDE SealR_NOT_BULK
}

#IFDEF DFM_RULES_PRIORITY_1 YES
RV0_EN_1_DFM1 {
@ Recommended rectangular V0 enclosure of M0 (width = 0.04/0.042/0.054um) is defined by RV0.EN.2.DFM/RV0.EN.3.DFM respectively
@ Recommended rectangular V0 enclosure of M0G (width = 0.04/0.06um) is defined by RV0.EN.4.DFM/ RV0.EN.6.DFM respectively
@ DRC waive the violation either V0/M0 or V0/M0G pass the enclosure rules whenV0 INTERACT (M0 AND M0G).
 err1 = (RV0 NOT INSIDE M0) NOT INSIDE M0G
 err1 NOT INSIDE SealR_NOT_BULK
}

//;beginning of the RV0.EN.2.DFM~3.DFM derivations
 via_RV0_2_R = RV0 NOT OUTSIDE (OR M0_NOT_M0C_040 M0_NOT_M0C_042)
 via_RV0_2_R_bad = RECTANGLE ENCLOSURE via_RV0_2_R M0_NOT_M0C ABUT<90 SINGULAR
 GOOD 0.004 OPPOSITE 0.022 OPPOSITE 0.004 OPPOSITE 0.022 OPPOSITE
 via_RV0_2_R_good = via_RV0_2_R NOT via_RV0_2_R_bad

 via_RV0_3_R = RV0 NOT OUTSIDE M0_NOT_M0C_054
 via_RV0_3_R_bad = RECTANGLE ENCLOSURE via_RV0_3_R M0_NOT_M0C ABUT<90 SINGULAR
 GOOD 0.011 OPPOSITE 0.022 OPPOSITE 0.011 OPPOSITE 0.022 OPPOSITE
 via_RV0_3_R_good = via_RV0_3_R NOT via_RV0_3_R_bad
//;end of the RV0.EN.2.DFM~3.DFM derivations

RV0_EN_2_DFM1 {
@ Recommended rectangular V0 long side enclosure by (M0 NOT MOC) which M0 width = 0.04/0.042um for two opposite sides with the other two sides = 0.004um. >= 0.022um
 err1 = via_RV0_2_R_bad NOT (OR via_RV0_3_R_good via_RV0_4_R_good via_RV0_5_R_good)
 err1 NOT INSIDE SealR_NOT_BULK
}

RV0_EN_3_DFM1 {
@ Recommended rectangular V0 long side enclosure by (M0 NOT MOC) which M0 width = 0.054um for two opposite sides with the other two sides = 0.011um. >= 0.022um
 err1 = via_RV0_3_R_bad NOT (OR via_RV0_2_R_good via_RV0_4_R_good via_RV0_5_R_good)
 err1 NOT INSIDE SealR_NOT_BULK
}

//;beginning of the RV0.EN.4.DFM derivations
 via_RV0_4_R = (RV0 NOT OUTSIDE M0G_040) OR (RV0 NOT OUTSIDE M0G_WIDTH_040)
 via_RV0_4_R_bad = RECTANGLE ENCLOSURE via_RV0_4_R M0G ABUT<90 SINGULAR
 GOOD 0.004 OPPOSITE 0.022 OPPOSITE 0.004 OPPOSITE 0.022 OPPOSITE
 via_RV0_4_R_good = via_RV0_4_R NOT via_RV0_4_R_bad
//;end of the RV0.EN.4.DFM derivations

RV0_EN_4_DFM1 {
@ Recommended rectangular V0 enclosure by M0G with width = 0.04um for two opposite sides with the other two sides = 0.004um. >= 0.022um
 err1 = via_RV0_4_R_bad NOT (OR via_RV0_2_R_good via_RV0_3_R_good via_RV0_5_R_good)
 err1 NOT INSIDE SealR_NOT_BULK
}

//;beginning of the RV0.EN.5.DFM derivations
 via_RV0_5_R = (RV0 NOT OUTSIDE M0G_060) OR (RV0 NOT OUTSIDE M0G_WIDTH_060)
 via_RV0_5_R_bad = RECTANGLE ENCLOSURE via_RV0_5_R M0G ABUT<90 SINGULAR
 GOOD 0.014 OPPOSITE 0.033 OPPOSITE 0.014 OPPOSITE 0.033 OPPOSITE
 via_RV0_5_R_good = via_RV0_5_R NOT via_RV0_5_R_bad
//;end of the RV0.EN.5.DFM derivations

RV0_EN_5_DFM1 {
@ Recommended V0 enclosure by M0G with width = 0.06um for two opposite sides with the other two sides = 0.014um. >= 0.033um
 err1 = via_RV0_5_R_bad NOT (OR via_RV0_2_R_good via_RV0_3_R_good via_RV0_4_R_good)
 err1 NOT INSIDE SealR_NOT_BULK
}

RV0_EN_7_DFM1 {
@ Recommended RV0 enclosure by M1 is defined by either V0.EN.8.DFM or V0.EN.9.DFM
 err1 = RV0 NOT INSIDE M1
 err1 NOT INSIDE SealR_NOT_BULK
}

//;beginning of the RV0.EN.8.DFM derivations
 met_RV0_8_R = COPY M1
 via_RV0_8_R = RV0 INTERACT met_RV0_8_R
 via_RV0_8_R_bad = RECTANGLE ENCLOSURE via_RV0_8_R M1 ABUT<90 SINGULAR
 GOOD 0.020 0.020 0.020 0.020 OPPOSITE
 via_RV0_8_R_good = via_RV0_8_R NOT via_RV0_8_R_bad
//;end of the RV0.EN.8.DFM derivations

RV0_EN_8_DFM1 {
@ Recommended RV0 enclosure by M1 for all sides to avoid high Rc >= 0.020um
 err1 = via_RV0_8_R_bad NOT via_RV0_9_R_good
 err2 = (ENC [via_RV0_8_R] M1 < 0.02 ABUT<90 SINGULAR) NOT TOUCH EDGE via_RV0_9_R_good
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE EDGE SealR_NOT_BULK
}

//;beginning of the RV0.EN.9.DFM derivations
 met_RV0_9_R = COPY M1
 via_RV0_9_R = RV0 INTERACT met_RV0_9_R
 via_RV0_9_R_bad = RECTANGLE ENCLOSURE via_RV0_9_R M1 ABUT<90 SINGULAR
 GOOD 0.007 0.025 OPPOSITE 0.007 0.025 OPPOSITE
 via_RV0_9_R_good = via_RV0_9_R NOT via_RV0_9_R_bad
//;end of the RV0.EN.9.DFM derivations

RV0_EN_9_DFM1 {
@ Recommended RV0 enclosure by M1 for two opposite sides with the other two sides >= 0.007um. >= 0.025um
 err1 = via_RV0_9_R_bad NOT via_RV0_8_R_good
 err1 NOT INSIDE SealR_NOT_BULK
}
#ENDIF

RV0_EN_6_7_8_9 {
@ RV0.EN.6: RV0 must be fully covered by M1, and must follow RV0.EN.7 or RV0.EN.8, or RV0.EN.9 as below, where M1 is the metal layer directly above rectangular V0
@ RV0.EN.7: RV0 enclosure by M1 >= 0.015um
@ RV0.EN.8: RV0 enclosure by M1 for two opposite sides with the other two sides >= 0.005um. >= 0.019um
@ RV0.EN.9: Short side of rectangular V0 enclosure by M1 with the other two sides >= 0um. >= 0.024um
 err1 = RECTANGLE ENCLOSURE RV0 M1 ABUT<90 SINGULAR OUTSIDE ALSO
 GOOD 0.005 0.019 OPPOSITE 0.005 0.019 OPPOSITE
 GOOD 0.015 0.015 0.015 0.015 OPPOSITE
 GOOD 0 0.024 OPPOSITE 0 0.024 OPPOSITE
 err1 NOT INSIDE SealR_NOT_BULK

 RV0_EN_10_W_sides = ENC [RV0_W] M1 < 0.005 ABUT<90 OPPOSITE
 RV0_EN_10_L_sides = ENC (RV0_L) M1 < 0.024 ABUT<90 OPPOSITE
 err2 = (RV0 WITH EDGE RV0_EN_10_W_sides) WITH EDGE RV0_EN_10_L_sides == 2
 err2 NOT INSIDE SealR_NOT_BULK
}

RV0_EN_10 {
@ V0 bar must be fully covered by (M0 NOT M0C) or M0G
 err1 = V0_BAR_100_all NOT M0_0
 err1 NOT INSIDE SealR_NOT_BULK
}

RV0_R_1 {
@ Redundant via requirement must be obeyed by one of following conditions for M1 connection (M1 plate with length and width >= 0.162um) (two square vias are equal to one rectangular via for below conditions) (Except VIA bar)
@ 1) At least one rectangular via
@ 2) At least two square vias with space <= 0.091um
@ 3) At least four square vias with space <= 0.415um
//;two V0N can be relpaced by one RV0
 X1a = WITH WIDTH M1 >= 0.162 < 0.272
 WIDE_all = X1a ENCLOSE V0_SR
 WIDE_all_raw = COPY WIDE_all

//; condition 1
 Y1_good_step1 = COPY RV0
 Y1_good = WIDE_all_raw AND Y1_good_step1

//; condition 2
 Y2_wide_all = WIDE_all_raw NOT INTERACT Y1_good
 Y2_wide = (M1 INTERACT Y2_wide_all) INTERACT V0_SR >= 2
 Y2_wide_chk_1 = Y2_wide INTERACT (WIDE_all_raw NOT INTERACT Y1_good_step1)
 Y2_comb_step1 = SIZE V0N BY 0.091/2 INSIDE OF Y2_wide_chk_1 STEP 0.030
 Y2_good_step1 = Y2_comb_step1 INTERACT V0N >= 2
 Y2_good = WIDE_all_raw AND Y2_good_step1

//; condition 3
 Y3_wide_all = WIDE_all_raw NOT INTERACT (OR Y1_good Y2_good)
 Y3_wide = (M1 INTERACT Y3_wide_all) INTERACT V0_SR >= 2   //;rectangle array 0.415/2=0.2075
 Y3_vias_input = V0_SR AND Y3_wide
 Y3_wide_chk_1 = Y3_wide INTERACT Y3_wide_all
 Y3_comb_step1 = SIZE Y3_vias_input BY 0.030 INSIDE OF Y3_wide_chk_1 STEP 0.030
 Y3_good_step1 = OR (Y3_comb_step1 INTERACT V0N >= 4) ((Y3_comb_step1 INTERACT RV0 == 1) INTERACT V0N >= 2)  //; step1: 0.030

//; Y3_wide_chk_2 = Y3_wide_chk_1 NOT INTERACT Y3_good_step1
 Y3_wide_chk_2 = Y3_wide_chk_1 INTERACT (WIDE_all_raw NOT INTERACT Y3_good_step1)
 Y3_comb_step2 = SIZE Y3_comb_step1 BY 0.030 INSIDE OF Y3_wide_chk_2 STEP 0.030
 Y3_good_step2 = OR (Y3_comb_step2 INTERACT V0N >= 4) ((Y3_comb_step2 INTERACT RV0 == 1) INTERACT V0N >= 2)  //; step2: 0.030

//; Y3_wide_chk_3 = Y3_wide_chk_2 NOT INTERACT Y3_good_step2
 Y3_wide_chk_3 = Y3_wide_chk_2 INTERACT (WIDE_all_raw NOT INTERACT Y3_good_step2)
 Y3_comb_step3 = SIZE Y3_comb_step2 BY 0.030 INSIDE OF Y3_wide_chk_3 STEP 0.030
 Y3_good_step3 = OR (Y3_comb_step3 INTERACT V0N >= 4) ((Y3_comb_step3 INTERACT RV0 == 1) INTERACT V0N >= 2)  //; step3: 0.030

//; Y3_wide_chk_4 = Y3_wide_chk_3 NOT INTERACT Y3_good_step3
 Y3_wide_chk_4 = Y3_wide_chk_3 INTERACT (WIDE_all_raw NOT INTERACT Y3_good_step3)
 Y3_comb_step4 = SIZE Y3_comb_step3 BY 0.030 INSIDE OF Y3_wide_chk_4 STEP 0.030
 Y3_good_step4 = OR (Y3_comb_step4 INTERACT V0N >= 4) ((Y3_comb_step4 INTERACT RV0 == 1) INTERACT V0N >= 2)  //; step4: 0.030

//; Y3_wide_chk_5 = Y3_wide_chk_4 NOT INTERACT Y3_good_step4
 Y3_wide_chk_5 = Y3_wide_chk_4 INTERACT (WIDE_all_raw NOT INTERACT Y3_good_step4)
 Y3_comb_step5 = SIZE Y3_comb_step4 BY 0.030 INSIDE OF Y3_wide_chk_5 STEP 0.030
 Y3_good_step5 = OR (Y3_comb_step5 INTERACT V0N >= 4) ((Y3_comb_step5 INTERACT RV0 == 1) INTERACT V0N >= 2)  //; step5: 0.030

//; Y3_wide_chk_6 = Y3_wide_chk_5 NOT INTERACT Y3_good_step5
 Y3_wide_chk_6 = Y3_wide_chk_5 INTERACT (WIDE_all_raw NOT INTERACT Y3_good_step5)
 Y3_comb_step6 = SIZE Y3_comb_step5 BY 0.030 INSIDE OF Y3_wide_chk_6 STEP 0.030
 Y3_good_step6 = OR (Y3_comb_step6 INTERACT V0N >= 4) ((Y3_comb_step6 INTERACT RV0 == 1) INTERACT V0N >= 2)  //; step6: 0.030

//; Y3_wide_chk_7 = Y3_wide_chk_6 NOT INTERACT Y3_good_step6
 Y3_wide_chk_7 = Y3_wide_chk_6 INTERACT (WIDE_all_raw NOT INTERACT Y3_good_step6)
 Y3_comb_step7 = SIZE Y3_comb_step6 BY 0.0275 INSIDE OF Y3_wide_chk_7 STEP 0.025
 Y3_good_step7 = OR (Y3_comb_step7 INTERACT V0N >= 4) ((Y3_comb_step7 INTERACT RV0 == 1) INTERACT V0N >= 2)  //; step7: 0.2075-0.03*6 = 0.0275
 Y3_good = WIDE_all_raw AND (OR Y3_good_step1 Y3_good_step2 Y3_good_step3 Y3_good_step4 Y3_good_step5 Y3_good_step6 Y3_good_step7)

 err1 = ((WIDE_all_raw OUTSIDE (OR Y1_good Y2_good Y3_good)) INTERACT V0_SR) NOT INTERACT V0_BAR
 err1 NOT INSIDE SealR_NOT_BULK
}

RV0_R_2 {
@ Redundant via requirement must be obeyed by one of following conditions for M1 connection (M1 plate with length and width >= 0.272um) (two square vias are equal to one rectangular via for below conditions) (Except VIA bar and OCCD)
@ 1) At least 4 square vias with space <= 0.091um
@ 2) At least 9 square vias with space <= 0.545um
@ 3) At least 5 rectangular vias with space <= 0.545um
//;two V0N can be relpaced by one RV0 (DRM will remove it 20180918)
 X1a = WITH WIDTH M1 >= 0.272
 WIDE_all = X1a ENCLOSE V0_SR
 WIDE_all_raw = COPY WIDE_all

//;condition 1
 Y1_wide = (M1 INTERACT WIDE_all_raw) INTERACT V0_SR >= 2
 Y1_vias_input = V0_SR AND Y1_wide
 Y1_wide_chk_1 = COPY Y1_wide  //;rectangle array 0.091/2=0.0455
 Y1_comb_step1 = SIZE Y1_vias_input BY 0.030 INSIDE OF Y1_wide_chk_1 STEP 0.030
 Y1_good_step1_a = Y1_comb_step1 INTERACT V0N >= 4
 Y1_good_step1_b = (Y1_comb_step1 INTERACT RV0 == 1) INTERACT V0N >= 2
 Y1_good_step1_c = Y1_comb_step1 INTERACT RV0 >= 2
 Y1_good_step1 = OR Y1_good_step1_a Y1_good_step1_b Y1_good_step1_c //; step1: 0.03

 Y1_wide_chk_2 = Y1_wide_chk_1 INTERACT (WIDE_all_raw NOT INTERACT Y1_good_step1)
 Y1_comb_step2 = SIZE Y1_comb_step1 BY 0.0155 INSIDE OF Y1_wide_chk_2 STEP 0.015
 Y1_good_step2_a = Y1_comb_step2 INTERACT V0N >= 4
 Y1_good_step2_b = (Y1_comb_step2 INTERACT RV0 == 1) INTERACT V0N >= 2
 Y1_good_step2_c = Y1_comb_step2 INTERACT RV0 >= 2
 Y1_good_step2 = OR Y1_good_step2_a Y1_good_step2_b Y1_good_step2_c //; step2: 0.045-0.03
 Y1_good = WIDE_all_raw AND (OR Y1_good_step1 Y1_good_step2)

//;condition 2 & condition 3
 Y2_wide_all = WIDE_all_raw NOT INTERACT Y1_good
 Y2_wide = (M1 INTERACT Y2_wide_all) INTERACT V0_SR >= 5
 Y2_vias_input = V0_SR AND Y2_wide
 Y2_wide_chk_1 = Y2_wide INTERACT Y2_wide_all  //; rectangle array 0.545/2=0.2725
 Y2_comb_step1 = SIZE Y2_vias_input BY 0.030 INSIDE OF Y2_wide_chk_1 STEP 0.030
 Y2_good_step1_a = Y2_comb_step1 INTERACT V0N >= 9
 Y2_good_step1_b = (Y2_comb_step1 INTERACT RV0 == 1) INTERACT V0N >= 7
 Y2_good_step1_c = (Y2_comb_step1 INTERACT RV0 == 2) INTERACT V0N >= 5
 Y2_good_step1_d = (Y2_comb_step1 INTERACT RV0 == 3) INTERACT V0N >= 3
 //Y2_good_step1_e = (Y2_comb_step1 INTERACT RV0 == 4) INTERACT V0N >= 1
 Y2_good_step1_f = Y2_comb_step1 INTERACT RV0 >= 5
 Y2_good_step1 = OR Y2_good_step1_a Y2_good_step1_b Y2_good_step1_c Y2_good_step1_d Y2_good_step1_f //; step1: 0.030

 Y2_wide_chk_2 = Y2_wide_chk_1 INTERACT (WIDE_all_raw NOT INTERACT Y2_good_step1)
 Y2_comb_step2 = SIZE Y2_comb_step1 BY 0.030 INSIDE OF Y2_wide_chk_2 STEP 0.030
 Y2_good_step2_a = Y2_comb_step2 INTERACT V0N >= 9
 Y2_good_step2_b = (Y2_comb_step2 INTERACT RV0 == 1) INTERACT V0N >= 7
 Y2_good_step2_c = (Y2_comb_step2 INTERACT RV0 == 2) INTERACT V0N >= 5
 Y2_good_step2_d = (Y2_comb_step2 INTERACT RV0 == 3) INTERACT V0N >= 3
 //Y2_good_step2_e = (Y2_comb_step2 INTERACT RV0 == 4) INTERACT V0N >= 1
 Y2_good_step2_f = Y2_comb_step2 INTERACT RV0 >= 5
 Y2_good_step2 = OR Y2_good_step2_a Y2_good_step2_b Y2_good_step2_c Y2_good_step2_d Y2_good_step2_f //; step2: 0.030

 Y2_wide_chk_3 = Y2_wide_chk_2 INTERACT (WIDE_all_raw NOT INTERACT Y2_good_step2)
 Y2_comb_step3 = SIZE Y2_comb_step2 BY 0.030 INSIDE OF Y2_wide_chk_3 STEP 0.030
 Y2_good_step3_a = Y2_comb_step3 INTERACT V0N >= 9
 Y2_good_step3_b = (Y2_comb_step3 INTERACT RV0 == 1) INTERACT V0N >= 7
 Y2_good_step3_c = (Y2_comb_step3 INTERACT RV0 == 2) INTERACT V0N >= 5
 Y2_good_step3_d = (Y2_comb_step3 INTERACT RV0 == 3) INTERACT V0N >= 3
 //Y2_good_step3_e = (Y2_comb_step3 INTERACT RV0 == 4) INTERACT V0N >= 1
 Y2_good_step3_f = Y2_comb_step3 INTERACT RV0 >= 5
 Y2_good_step3 = OR Y2_good_step3_a Y2_good_step3_b Y2_good_step3_c Y2_good_step3_d Y2_good_step3_f //; step3: 0.030

 Y2_wide_chk_4 = Y2_wide_chk_3 INTERACT (WIDE_all_raw NOT INTERACT Y2_good_step3)
 Y2_comb_step4 = SIZE Y2_comb_step3 BY 0.030 INSIDE OF Y2_wide_chk_4 STEP 0.030
 Y2_good_step4_a = Y2_comb_step4 INTERACT V0N >= 9
 Y2_good_step4_b = (Y2_comb_step4 INTERACT RV0 == 1) INTERACT V0N >= 7
 Y2_good_step4_c = (Y2_comb_step4 INTERACT RV0 == 2) INTERACT V0N >= 5
 Y2_good_step4_d = (Y2_comb_step4 INTERACT RV0 == 3) INTERACT V0N >= 3
 //Y2_good_step4_e = (Y2_comb_step4 INTERACT RV0 == 4) INTERACT V0N >= 1
 Y2_good_step4_f = Y2_comb_step4 INTERACT RV0 >= 5
 Y2_good_step4 = OR Y2_good_step4_a Y2_good_step4_b Y2_good_step4_c Y2_good_step4_d Y2_good_step4_f //; step4: 0.030

 Y2_wide_chk_5 = Y2_wide_chk_4 INTERACT (WIDE_all_raw NOT INTERACT Y2_good_step4)
 Y2_comb_step5 = SIZE Y2_comb_step4 BY 0.030 INSIDE OF Y2_wide_chk_5 STEP 0.030
 Y2_good_step5_a = Y2_comb_step5 INTERACT V0N >= 9
 Y2_good_step5_b = (Y2_comb_step5 INTERACT RV0 == 1) INTERACT V0N >= 7
 Y2_good_step5_c = (Y2_comb_step5 INTERACT RV0 == 2) INTERACT V0N >= 5
 Y2_good_step5_d = (Y2_comb_step5 INTERACT RV0 == 3) INTERACT V0N >= 3
 //Y2_good_step5_e = (Y2_comb_step5 INTERACT RV0 == 4) INTERACT V0N >= 1
 Y2_good_step5_f = Y2_comb_step5 INTERACT RV0 >= 5
 Y2_good_step5 = OR Y2_good_step5_a Y2_good_step5_b Y2_good_step5_c Y2_good_step5_d Y2_good_step5_f //; step5: 0.030

 Y2_wide_chk_6 = Y2_wide_chk_5 INTERACT (WIDE_all_raw NOT INTERACT Y2_good_step5)
 Y2_comb_step6 = SIZE Y2_comb_step5 BY 0.030 INSIDE OF Y2_wide_chk_6 STEP 0.030
 Y2_good_step6_a = Y2_comb_step6 INTERACT V0N >= 9
 Y2_good_step6_b = (Y2_comb_step6 INTERACT RV0 == 1) INTERACT V0N >= 7
 Y2_good_step6_c = (Y2_comb_step6 INTERACT RV0 == 2) INTERACT V0N >= 5
 Y2_good_step6_d = (Y2_comb_step6 INTERACT RV0 == 3) INTERACT V0N >= 3
 //Y2_good_step6_e = (Y2_comb_step6 INTERACT RV0 == 4) INTERACT V0N >= 1
 Y2_good_step6_f = Y2_comb_step6 INTERACT RV0 >= 5
 Y2_good_step6 = OR Y2_good_step6_a Y2_good_step6_b Y2_good_step6_c Y2_good_step6_d Y2_good_step6_f //; step6: 0.030

 Y2_wide_chk_7 = Y2_wide_chk_6 INTERACT (WIDE_all_raw NOT INTERACT Y2_good_step6)
 Y2_comb_step7 = SIZE Y2_comb_step6 BY 0.030 INSIDE OF Y2_wide_chk_7 STEP 0.030
 Y2_good_step7_a = Y2_comb_step7 INTERACT V0N >= 9
 Y2_good_step7_b = (Y2_comb_step7 INTERACT RV0 == 1) INTERACT V0N >= 7
 Y2_good_step7_c = (Y2_comb_step7 INTERACT RV0 == 2) INTERACT V0N >= 5
 Y2_good_step7_d = (Y2_comb_step7 INTERACT RV0 == 3) INTERACT V0N >= 3
 //Y2_good_step7_e = (Y2_comb_step7 INTERACT RV0 == 4) INTERACT V0N >= 1
 Y2_good_step7_f = Y2_comb_step7 INTERACT RV0 >= 5
 Y2_good_step7 = OR Y2_good_step7_a Y2_good_step7_b Y2_good_step7_c Y2_good_step7_d Y2_good_step7_f //; step7: 0.030

 Y2_wide_chk_8 = Y2_wide_chk_7 INTERACT (WIDE_all_raw NOT INTERACT Y2_good_step7)
 Y2_comb_step8 = SIZE Y2_comb_step7 BY 0.030 INSIDE OF Y2_wide_chk_8 STEP 0.030
 Y2_good_step8_a = Y2_comb_step8 INTERACT V0N >= 9
 Y2_good_step8_b = (Y2_comb_step8 INTERACT RV0 == 1) INTERACT V0N >= 7
 Y2_good_step8_c = (Y2_comb_step8 INTERACT RV0 == 2) INTERACT V0N >= 5
 Y2_good_step8_d = (Y2_comb_step8 INTERACT RV0 == 3) INTERACT V0N >= 3
 //Y2_good_step8_e = (Y2_comb_step8 INTERACT RV0 == 4) INTERACT V0N >= 1
 Y2_good_step8_f = Y2_comb_step8 INTERACT RV0 >= 5
 Y2_good_step8 = OR Y2_good_step8_a Y2_good_step8_b Y2_good_step8_c Y2_good_step8_d Y2_good_step8_f //; step8: 0.030

 Y2_wide_chk_9 = Y2_wide_chk_8 INTERACT (WIDE_all_raw NOT INTERACT Y2_good_step8)
 Y2_comb_step9 = SIZE Y2_comb_step8 BY 0.0325 INSIDE OF Y2_wide_chk_9 STEP 0.030
 Y2_good_step9_a = Y2_comb_step9 INTERACT V0N >= 9
 Y2_good_step9_b = (Y2_comb_step9 INTERACT RV0 == 1) INTERACT V0N >= 7
 Y2_good_step9_c = (Y2_comb_step9 INTERACT RV0 == 2) INTERACT V0N >= 5
 Y2_good_step9_d = (Y2_comb_step9 INTERACT RV0 == 3) INTERACT V0N >= 3
 //Y2_good_step9_e = (Y2_comb_step9 INTERACT RV0 == 4) INTERACT V0N >= 1
 Y2_good_step9_f = Y2_comb_step9 INTERACT RV0 >= 5
 Y2_good_step9 = OR Y2_good_step9_a Y2_good_step9_b Y2_good_step9_c Y2_good_step9_d Y2_good_step9_f //; step9: 0.2725-0.03*8=0.0325
 Y2_Y3_good = WIDE_all_raw AND (OR Y2_good_step1 Y2_good_step2 Y2_good_step3 Y2_good_step4 Y2_good_step5 Y2_good_step6 Y2_good_step7 Y2_good_step8 Y2_good_step9)

 err1 = ((WIDE_all_raw OUTSIDE (OR Y1_good Y2_Y3_good)) INTERACT V0_SR) NOT INTERACT V0_BAR
 err1 NOT INSIDE OCCD
}

VARIABLE RV0_R_3_m1_width 0.162
VARIABLE RV0_R_3_m1_distance 0.5

RV0_R_3 {
@ There should be at least two square V0 or one rectangular V0 in the intersection area of bottom metal and upper metal, when either wide M1 width and length >= 0.162um, the space between either via and wide metal is <= 0.5um (S, S is the shortest running path length from Via to the wide metal) (except via bar)
@ DRC doesn't check M0G or M0 region that with at least two square or one rectangular V0 at the boundary of wide metal and branch
//;DRC flags the overlapped region with one via, no matter the region is a part of any whole M0/M0G region
 wide_M1 = (WITH WIDTH M1 >= RV0_R_3_m1_width) ENCLOSE RECTANGLE RV0_R_3_m1_width RV0_R_3_m1_width
 wide_M1_real = wide_M1 NOT OUTSIDE ((SIZE wide_M1 BY RV0_R_3_m1_distance+GLOBAL_TOLERANCE) INTERACT V0)
 all_down_and_up = (M1 INTERACT wide_M1) AND M0_0
 dis_down_and_up = SIZE wide_M1_real BY RV0_R_3_m1_distance+GLOBAL_TOLERANCE INSIDE OF M1 STEP 0.022
 dis_down_arm = (dis_down_and_up NOT wide_M1) AND M1
 dis_down_arm_corner = (dis_down_arm AND M0_0) INTERACT wide_M1

 dis_down_arm_good_a = (dis_down_arm INTERACT V0N >= 2) OR (dis_down_arm INTERACT RV0)
 dis_down_arm_good_b = (all_down_and_up INTERACT dis_down_arm_corner) INTERACT V0N >= 2
 dis_down_arm_good_c = (all_down_and_up INTERACT dis_down_arm_corner) INTERACT RV0
 dis_down_arm_good = OR dis_down_arm_good_a dis_down_arm_good_b dis_down_arm_good_c
 dis_down_arm_bad = dis_down_arm NOT dis_down_arm_good

 err1_down_arm_TMP = dis_down_arm INTERACT ((dis_down_arm_bad INTERACT V0N) AND dis_down_arm)
 err1_down_arm = err1_down_arm_TMP INTERACT (V0N NOT OUTSIDE err1_down_arm_TMP)
 err1 = err1_down_arm INTERACT wide_M1 == 1
 err1 NOT INTERACT V0_BAR
}

VARIABLE RV0_R_4_m1_width 0.272
VARIABLE RV0_R_4_m1_distance 1

RV0_R_4 {
@ There should be at least two square V0 or one rectangular V0 in the intersection area of bottom metal and upper metal, when either wide M1 width and length >= 0.272um, the space between either via and wide metal is <= 1um (S, S is the shortest running path length from Via to the wide metal) (except via bar)
@ DRC doesn't check M0G or M0 region that with at least two square or one rectangular V0 at the boundary of wide metal and branch
 wide_M1 = (WITH WIDTH M1 >= RV0_R_4_m1_width) ENCLOSE RECTANGLE RV0_R_4_m1_width RV0_R_4_m1_width
 wide_M1_real = wide_M1 NOT OUTSIDE ((SIZE wide_M1 BY RV0_R_4_m1_distance+GLOBAL_TOLERANCE) INTERACT V0)
 all_down_and_up = (M1 INTERACT wide_M1) AND M0_0
 dis_down_and_up = SIZE wide_M1_real BY RV0_R_4_m1_distance+GLOBAL_TOLERANCE INSIDE OF M1 STEP 0.022
 dis_down_arm = (dis_down_and_up NOT wide_M1) AND M1
 dis_down_arm_corner = (dis_down_arm AND M0_0) INTERACT wide_M1

 dis_down_arm_good_a = (dis_down_arm INTERACT V0N >= 2) OR (dis_down_arm INTERACT RV0)
 dis_down_arm_good_b = (all_down_and_up INTERACT dis_down_arm_corner) INTERACT V0N >= 2
 dis_down_arm_good_c = (all_down_and_up INTERACT dis_down_arm_corner) INTERACT RV0
 dis_down_arm_good = OR dis_down_arm_good_a dis_down_arm_good_b dis_down_arm_good_c
 dis_down_arm_bad = dis_down_arm NOT dis_down_arm_good

 err1_down_arm_TMP = dis_down_arm INTERACT ((dis_down_arm_bad INTERACT V0N) AND dis_down_arm)
 err1_down_arm = err1_down_arm_TMP INTERACT (V0N NOT OUTSIDE err1_down_arm_TMP)
 err1 = err1_down_arm INTERACT wide_M1 == 1
 err1 NOT INTERACT V0_BAR
}

VARIABLE RV0_R_5_m1_width 0.542
VARIABLE RV0_R_5_m1_distance 3

RV0_R_5 {
@ There should be at least two square V0 or one rectangular V0 in the intersection area of bottom metal and upper metal, when either wide metal M1 width and length >= 0.542um, the space between either via and wide metal is <= 3um (S, S is the shortest running path length from Via to the wide metal) (except via bar)
@ DRC doesn't check M0G or M0 region that with at least two square or one rectangular V0 at the boundary of wide metal and branch
 wide_M1 = (WITH WIDTH M1 >= RV0_R_5_m1_width) ENCLOSE RECTANGLE RV0_R_5_m1_width RV0_R_5_m1_width
 wide_M1_real = wide_M1 NOT OUTSIDE ((SIZE wide_M1 BY RV0_R_5_m1_distance+GLOBAL_TOLERANCE) INTERACT V0)
 all_down_and_up = (M1 INTERACT wide_M1) AND M0_0
 dis_down_and_up = SIZE wide_M1_real BY RV0_R_5_m1_distance+GLOBAL_TOLERANCE INSIDE OF M1 STEP 0.022
 dis_down_arm = (dis_down_and_up NOT wide_M1) AND M1
 dis_down_arm_corner = (dis_down_arm AND M0_0) INTERACT wide_M1

 dis_down_arm_good_a = (dis_down_arm INTERACT V0N >= 2) OR (dis_down_arm INTERACT RV0)
 dis_down_arm_good_b = (all_down_and_up INTERACT dis_down_arm_corner) INTERACT V0N >= 2
 dis_down_arm_good_c = (all_down_and_up INTERACT dis_down_arm_corner) INTERACT RV0
 dis_down_arm_good = OR dis_down_arm_good_a dis_down_arm_good_b dis_down_arm_good_c
 dis_down_arm_bad = dis_down_arm NOT dis_down_arm_good

 err1_down_arm_TMP = dis_down_arm INTERACT ((dis_down_arm_bad INTERACT V0N) AND dis_down_arm)
 err1_down_arm = err1_down_arm_TMP INTERACT (V0N NOT OUTSIDE err1_down_arm_TMP)
 err1 = err1_down_arm INTERACT wide_M1 == 1
 err1 NOT INTERACT V0_BAR
}

VARIABLE RV0_R_6_m1_width 1.010
VARIABLE RV0_R_6_m1_distance 5

RV0_R_6 {
@ There should be at least two square V0 or one rectangular V0 in the intersection area of bottom metal and upper metal, when either wide metal M1 width and length >= 1.01um, the space between either via and wide metal is <= 5um (S, S is the shortest running path length from Via to the wide metal) (except via bar)
@ DRC doesn't check M0G or M0 region that with at least two square or one rectangular V0 at the boundary of wide metal and branch
 wide_M1 = (WITH WIDTH M1 >= RV0_R_6_m1_width) ENCLOSE RECTANGLE RV0_R_6_m1_width RV0_R_6_m1_width
 wide_M1_real = wide_M1 NOT OUTSIDE ((SIZE wide_M1 BY RV0_R_6_m1_distance+GLOBAL_TOLERANCE) INTERACT V0)
 all_down_and_up = (M1 INTERACT wide_M1) AND M0_0
 dis_down_and_up = SIZE wide_M1_real BY RV0_R_6_m1_distance+GLOBAL_TOLERANCE INSIDE OF M1 STEP 0.022
 dis_down_arm = (dis_down_and_up NOT wide_M1) AND M1
 dis_down_arm_corner = (dis_down_arm AND M0_0) INTERACT wide_M1

 dis_down_arm_good_a = (dis_down_arm INTERACT V0N >= 2) OR (dis_down_arm INTERACT RV0)
 dis_down_arm_good_b = (all_down_and_up INTERACT dis_down_arm_corner) INTERACT V0N >= 2
 dis_down_arm_good_c = (all_down_and_up INTERACT dis_down_arm_corner) INTERACT RV0
 dis_down_arm_good = OR dis_down_arm_good_a dis_down_arm_good_b dis_down_arm_good_c
 dis_down_arm_bad = dis_down_arm NOT dis_down_arm_good

 err1_down_arm_TMP = dis_down_arm INTERACT ((dis_down_arm_bad INTERACT V0N) AND dis_down_arm)
 err1_down_arm = err1_down_arm_TMP INTERACT (V0N NOT OUTSIDE err1_down_arm_TMP)
 err1 = err1_down_arm INTERACT wide_M1 == 1
 err1 NOT INTERACT V0_BAR
}

RV0_R_8 {
@ Rectangular V0 overlap with (M0G width = 0.05um) is not allowed
 err1 = RV0 AND (OR M0G_050 M0G_WIDTH_050)
 err1 NOT INSIDE SealR_NOT_BULK
}

// =======================================================
// Metal-1 design rules (double patterning process)
// =======================================================

GROUP GM1 M1_?

M1_end_0.046_0.051 = LENGTH M1_convex_90_90_edges >= 0.046 <= 0.051
M1_end_0.046_0.052 = LENGTH M1_convex_90_90_edges >= 0.046 < 0.052
M1_end_0.051 = LENGTH M1_convex_90_90_edges <= 0.051
M1_end_0.052 = LENGTH M1_convex_90_90_edges < 0.052
M1_end_0.048 = LENGTH M1_convex_90_90_edges < 0.048
M1_end_0.046 = LENGTH M1_convex_90_90_edges < 0.046
M1_end_0.055 = LENGTH M1_convex_90_90_edges < 0.055
M1_end_0.040 = LENGTH M1_convex_90_90_edges <= 0.040
M1_end_0.050 = LENGTH M1_convex_90_90_edges <= 0.050
M1_end_0.046_0.049 = LENGTH M1_convex_90_90_edges >= 0.046 <= 0.049

M1_COLORA = M1 INTERACT M1CA
M1_COLORB = M1 INTERACT M1CB

met_wide_eqgt_150 = M1 WITH WIDTH >= 0.15
M1_vertex_edges = INT [M1] < 0.002 ABUT INTERSECTING ONLY SINGULAR
M1_width_lt_037_opp_edges = INT [M1] < 0.037 ABUT<90 OPPOSITE PARA ONLY
M1_width_lt_034_opp_edges = INT [M1] < 0.034 ABUT<90 OPPOSITE PARA ONLY

M1_oppo_space_eqgt_032_lt_037 = EXT [M1] >= 0.032 < 0.037 ABUT<90 OPPOSITE
M1_oppo_space_eqgt_058_lt_068 = EXT [M1] >= 0.058 < 0.068 ABUT<90 OPPOSITE
M1_oppo_space_eqgt_032_lt_037_or_058_lt_068 = M1 COIN EDGE (OR EDGE M1_oppo_space_eqgt_032_lt_037 M1_oppo_space_eqgt_058_lt_068)
M1_oppo_space_s1_s3_edges_TMP = INT M1 M1_oppo_space_eqgt_032_lt_037_or_058_lt_068 < 0.034 ABUT<90 OPPOSITE PARA ONLY REGION
M1_oppo_space_s1_s3_edges = M1_width_lt_034_opp_edges COIN EDGE M1_oppo_space_s1_s3_edges_TMP

#IFDEF MANUFACTURABILITY_ENHANCEMENT_RULES YES
M1_S_13_ME {
@ Space between M1 and line-end (width < 0.046um) when PRL > -0.016um except INST region >= 0.07
 err1 = EXT M1_line M1_end_0.046 < 0.070 ABUT<90 OPPOSITE EXTENDED 0.016 REGION
 err1 NOT INSIDE INST
}

M1_S_13a_ME {
@ Space between M1 and line-end (0.046um <= M1 width <= 0.049um), when PRL > -0.016um, except INST region >= 0.036um
 err1 = EXT M1_line M1_end_0.046_0.049 < 0.036 ABUT<90 OPPOSITE EXTENDED 0.016 REGION
 err1 NOT INSIDE INST
}

M1_S_14_ME {
@ Space between M1 line-end and line-end (width < 0.046um) when PRL > -0.016um, except INST region >= 0.081um
 err1 = EXT M1_end_0.046 < 0.081 ABUT<90 OPPOSITE EXTENDED 0.016 REGION
 err1 NOT INSIDE INST
}

M1_S_50_ME {
@ Space between M1 outside vertex (M1 line-end outer vertex or L-shape outer vertex) and nearby L-shape inner vertex >= 0.047um
@ DRC flag if both projection space < 0.036um, except INST region
 Y1 = (EXT [M1_v_edges] < 0.036 ABUT<90 OPPOSITE EXTENDED 0.047) OR EDGE (EXT [M1_h_edges] < 0.036 ABUT<90 OPPOSITE EXTENDED 0.047)
 Y2 = EXT M1_convex_corner M1_concave_corner < 0.047 ABUT<90
 err1_a = INT Y1 < 0.001 ABUT==90 INTERSECTING ONLY
 err1_b = EXT Y1 < 0.001 ABUT==90 INTERSECTING ONLY
 err1_c = DFM PROPERTY Y2 err1_a err1_b ABUT ALSO OVERLAP MULTI [-= (count(err1_a) > 0 && count(err1_b) > 0) ? 1 : 0] > 0
 err1 = DFM COPY err1_c REGION
 err1 NOT INSIDE INST
}

M1_R_6_RV0_ME {
@ It’s not allowed to use U-shape M1, except INST region
@ DRC check condition:
@ 1. With at least one RV0 or RV1
@ 2. M1 width W <= 0.038um
@ 3. S <= 0.12um
 ushape_opp = LENGTH M1_convex_270_270_edges <= 0.120
 ushape_wid = INT ushape_opp M1_convex_gt_one_edges <= 0.038 OPPOSITE
 ushape_edg = ushape_opp COIN EDGE (DFM COPY ushape_wid EDGE)
 ushape_met = (M1 WITH EDGE ushape_edg) INTERACT RV0
 ushape_chk = ushape_edg COIN EDGE ushape_met
 ushape_038 = (EXPAND EDGE ushape_chk INSIDE BY 0.038) AND M1
 ushape_via = (SIZE ushape_038 BY 0.12 INSIDE OF M1 STEP 0.01) INTERACT RV0
 ushape_err = DFM PROPERTY ushape_wid ushape_via OVERLAP ABUT ALSO MULTI [s= area(ushape_via)] > 0 [w= min(ew(ushape_wid))] > 0

 err1 = copy (DFM COPY ushape_err REGION)
 err1 NOT INSIDE INST
}

M1_R_6_RV1_ME {
@ It’s not allowed to use U-shape M1, except INST region
@ DRC check condition:
@ 1. With at least one RV0 or RV1
@ 2. M1 width W <= 0.038um
@ 3. S <= 0.12um
 ushape_opp = LENGTH M1_convex_270_270_edges <= 0.120
 ushape_wid = INT ushape_opp M1_convex_gt_one_edges <= 0.038 OPPOSITE
 ushape_edg = ushape_opp COIN EDGE (DFM COPY ushape_wid EDGE)
 ushape_met = (M1 WITH EDGE ushape_edg) INTERACT RV1
 ushape_chk = ushape_edg COIN EDGE ushape_met
 ushape_038 = (EXPAND EDGE ushape_chk INSIDE BY 0.038) AND M1
 ushape_via = (SIZE ushape_038 BY 0.12 INSIDE OF M1 STEP 0.01) INTERACT RV1
 ushape_err = DFM PROPERTY ushape_wid ushape_via OVERLAP ABUT ALSO MULTI [s= area(ushape_via)] > 0 [w= min(ew(ushape_wid))] > 0

 err1 = copy (DFM COPY ushape_err REGION)
 err1 NOT INSIDE INST
}

M1_R_7_V0_ME {
@ It’s not allowed to use Hook-shape M1, except INST region
@ Hook-shape M1 definition:
@ (1) Hook-end line width (W1) is <= 0.05um, length (L1) <= 0.15um, ΔL > 0.1um and Hook-end interact one via
@ (2) W2/W3 width <= 0.072um
@ (3) Space between two M1 arms (S1) <= 0.1um
@ (4) Space between via and another M1 S2 <= 0.038um when PRL > -0.015um
@ DRC waive if hook-end enclosure V0/V1 >= 0.05um
 hook_neck = CONVEX EDGE M1 ANGLE1==270 LENGTH1<=0.15 ANGLE2==270 LENGTH2>0 WITH LENGTH <= 0.100
 hook_neck_ege = hook_neck NOT TOUCH EDGE (INT (hook_neck) M1 <= 0.072 ABUT<90 OPPOSITE)
 hook_neck_exd = EXPAND EDGE hook_neck_ege OUTSIDE BY 0.01
 hook_neck_sid = M1 COIN EDGE hook_neck_exd

 hook_seek = (M1 WITH EDGE hook_neck_ege) WITH EDGE M1_end_0.050
 hook_head_sid = INT [hook_seek] <= 0.05 ABUT<90 OPPOSITE
 hook_head_end = M1_end_0.050 TOUCH EDGE hook_seek
 hook_head_end_r = M1_end_0.050 TOUCH EDGE (OR EDGE (ENC V0 [hook_head_end] < 0.05 ABUT<90 OPPOSITE) (ENC V1 [hook_head_end] < 0.05 ABUT<90 OPPOSITE))
 hook_head_via_b = V0 WITH EDGE (ENC [V0] hook_head_end < 0.05 ABUT<90 OPPOSITE)
 hook_head_via_u = V1 WITH EDGE (ENC [V1] hook_head_end < 0.05 ABUT<90 OPPOSITE)
 hook_head_via_b_sid = ENC [hook_head_via_b] hook_head_sid <= 0.050-V0_MiniWidth ABUT<90 OPPOSITE
 hook_head_via_u_sid = ENC [hook_head_via_u] hook_head_sid <= 0.050-V0_MiniWidth ABUT<90 OPPOSITE
 hook_head_via = hook_head_via_b WITH EDGE (EXT M1 [hook_head_via_b_sid] < 0.038+GLOBAL_TOLERANCE ABUT<90 OPPOSITE EXTENDED 0.015 MEASURE ALL)

 hook_seek_met = hook_seek ENCLOSE hook_head_via
 hook_neck_cor = EXT [hook_seek_met] < 0.005 ABUT==90 INTERSECTING ONLY
 hook_neck_err = EXT hook_neck_cor <= 0.100 ABUT<90 OPPOSITE
 hook_neck_arm = hook_seek_met TOUCH EDGE hook_neck_cor
 hook_neck_dtl = DFM PROPERTY hook_neck_err hook_neck_arm OVERLAP ABUT ALSO MULTI [dt_l = max(length(hook_neck_arm)) - min(length(hook_neck_arm))]

 hook_head_a = (INT (M1_convex_gt_one_edges TOUCH EDGE hook_seek_met) <= 0.05 OPPOSITE REGION) WITH EDGE hook_head_end_r
 hook_head_b = NOT ENCLOSE RECTANGLE hook_head_a 0.001 0.150+GLOBAL_TOLERANCE ORTHOGONAL ONLY
 hook_head = hook_head_b NOT OUTSIDE hook_head_via
 hook_tail = INT (hook_neck_sid) M1 <= 0.072 ABUT<90 OPPOSITE
 hook_gain = DFM PROPERTY hook_neck_err hook_tail hook_head hook_neck_dtl OVERLAP ABUT ALSO MULTI
 [-= (count(hook_head) > 0 && count(hook_tail) == 0) ? 1 : 0] > 0 [dt_l = property(hook_neck_dtl,dt_l)] > 0.10
 err1 = DFM COPY hook_gain REGION
 err1 NOT INSIDE INST
}

M1_R_7_V1_ME {
@ It’s not allowed to use Hook-shape M1, except INST region
@ Hook-shape M1 definition:
@ (1) Hook-end line width (W1) is <= 0.05um, length (L1) <= 0.15um, ΔL > 0.1um and Hook-end interact one via
@ (2) W2/W3 width <= 0.072um
@ (3) Space between two M1 arms (S1) <= 0.1um
@ (4) Space between via and another M1 S2 <= 0.038um when PRL > -0.015um
@ DRC waive if hook-end enclosure V0/V1 >= 0.05um
 hook_neck = CONVEX EDGE M1 ANGLE1==270 LENGTH1<=0.15 ANGLE2==270 LENGTH2>0 WITH LENGTH <= 0.100
 hook_neck_ege = hook_neck NOT TOUCH EDGE (INT (hook_neck) M1 <= 0.072 ABUT<90 OPPOSITE)
 hook_neck_exd = EXPAND EDGE hook_neck_ege OUTSIDE BY 0.01
 hook_neck_sid = M1 COIN EDGE hook_neck_exd

 hook_seek = (M1 WITH EDGE hook_neck_ege) WITH EDGE M1_end_0.050
 hook_head_sid = INT [hook_seek] <= 0.05 ABUT<90 OPPOSITE
 hook_head_end = M1_end_0.050 TOUCH EDGE hook_seek
 hook_head_end_r = M1_end_0.050 TOUCH EDGE (OR EDGE (ENC V0 [hook_head_end] < 0.05 ABUT<90 OPPOSITE) (ENC V1 [hook_head_end] < 0.05 ABUT<90 OPPOSITE))
 hook_head_via_b = V0 WITH EDGE (ENC [V0] hook_head_end < 0.05 ABUT<90 OPPOSITE)
 hook_head_via_u = V1 WITH EDGE (ENC [V1] hook_head_end < 0.05 ABUT<90 OPPOSITE)
 hook_head_via_b_sid = ENC [hook_head_via_b] hook_head_sid <= 0.050-V1_MiniWidth ABUT<90 OPPOSITE
 hook_head_via_u_sid = ENC [hook_head_via_u] hook_head_sid <= 0.050-V1_MiniWidth ABUT<90 OPPOSITE
 hook_head_via = hook_head_via_u WITH EDGE (EXT M1 [hook_head_via_u_sid] < 0.038+GLOBAL_TOLERANCE ABUT<90 OPPOSITE EXTENDED 0.015 MEASURE ALL)

 hook_seek_met = hook_seek ENCLOSE hook_head_via
 hook_neck_cor = EXT [hook_seek_met] < 0.005 ABUT==90 INTERSECTING ONLY
 hook_neck_err = EXT hook_neck_cor <= 0.100 ABUT<90 OPPOSITE
 hook_neck_arm = hook_seek_met TOUCH EDGE hook_neck_cor
 hook_neck_dtl = DFM PROPERTY hook_neck_err hook_neck_arm OVERLAP ABUT ALSO MULTI [dt_l = max(length(hook_neck_arm)) - min(length(hook_neck_arm))]

 hook_head_a = (INT (M1_convex_gt_one_edges TOUCH EDGE hook_seek_met) <= 0.05 OPPOSITE REGION) WITH EDGE hook_head_end_r
 hook_head_b = NOT ENCLOSE RECTANGLE hook_head_a 0.001 0.150+GLOBAL_TOLERANCE ORTHOGONAL ONLY
 hook_head = hook_head_b NOT OUTSIDE hook_head_via
 hook_tail = INT (hook_neck_sid) M1 <= 0.072 ABUT<90 OPPOSITE
 hook_gain = DFM PROPERTY hook_neck_err hook_tail hook_head hook_neck_dtl OVERLAP ABUT ALSO MULTI
 [-= (count(hook_head) > 0 && count(hook_tail) == 0) ? 1 : 0] > 0 [dt_l = property(hook_neck_dtl,dt_l)] > 0.10
 err1 = DFM COPY hook_gain REGION
 err1 NOT INSIDE INST
}

#IFDEF DOUBLE_PATTERNING_RULES_CHECK YES
#IFDEF DOUBLE_PATTERNING_RULES_CHECK_ONLY YES
DRC SELECT CHECK M1_ORCS_2_ME
#ENDIF
M1_ORCS_2_ME {
@ Continuous three or more same color M1 spacing < 0.063um is not allowed, except INST region
@ DRC flag if all these M1 space < 0.063um
 color_a = M1 INTERACT M1_mask0
 color_b = M1 INTERACT M1_mask1
 err1 = WITH NEIGHBOR color_a >= 2 SPACE < 0.063
 err2 = WITH NEIGHBOR color_b >= 2 SPACE < 0.063
 err1 NOT INSIDE INST
 err2 NOT INSIDE INST
}
#ENDIF
#ENDIF

#IFDEF DFM_RULES_PRIORITY_1 YES
M1_W_1_DFM1 {
@ Recommended M1 width to reduce the line open possibility, except MOMDMY and FUSEMK1 region >= 0.046um
 err1 = INT M1 < 0.046 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE (OR MOMDMY FUSEMK1)
}

M1_S_1_DFM1 {
@ Recommended M1 space to reduce the short possibility, except MOMDMY region >= 0.044um
 err1 = EXT M1 < 0.044 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE MOMDMY
}

M1_S_7_DFM1 {
@ Recommended M1 space when either one M1 width > 0.09um. >= 0.072um
 chk_M1 = M1 WITH WIDTH > 0.09
 err1 = EXT chk_M1 M1 < 0.072 ABUT<90 REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

M1_S_8_DFM1 {
@ Recommended M1 space when either one M1 width > 0.12um. >= 0.106um
 chk_M1 = M1 WITH WIDTH > 0.12
 err1 = EXT chk_M1 M1 < 0.106 ABUT<90 REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

M1_S_9_DFM1 {
@ Recommended M1 space when either one M1 width > 0.18um. >= 0.126um
 chk_M1 = M1 WITH WIDTH > 0.18
 err1 = EXT chk_M1 M1 < 0.126 ABUT<90 REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

M1_S_10_DFM1 {
@ Recommended M1 space when either one M1 width > 0.27um. >= 0.144um
 chk_M1 = M1 WITH WIDTH > 0.27
 err1 = EXT chk_M1 M1 < 0.144 ABUT<90 REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
#ENDIF

#IFDEF DFM_RULES_PRIORITY_1 YES
M1_S_13a_DFM1 {
@ Space between M1 and line-end (W < 0.046um, PRL > -0.022um) >= 0.07um
 err1 = EXT M1 M1_end_0.046 < 0.070 ABUT<90 OPPOSITE EXTENDED 0.022 REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

M1_S_13b_DFM1 {
@ Space between M1 and line-end (0.046 < W <= 0.051um, PRL > -0.022um) >= 0.063um
 err1 = EXT M1 M1_end_0.046_0.051 < 0.063 ABUT<90 OPPOSITE EXTENDED 0.022 REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

M1_S_13c_DFM1 {
@ Space between M1 line-end (W <= 0.051um) and line-end (W < 0.048um, PRL > -0.022um) >= 0.081um
 err1 = EXT M1_end_0.051 M1_end_0.048 < 0.081 ABUT<90 OPPOSITE EXTENDED 0.022 REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

M1_S_17_V0_DFM1 {
@ Space between M1 line and (V0 or V1) enclosed by dense M1 line-end (when PRL (L1) > -0.025um; E <= 0.045um) >= 0.117um
@ Dense M1 line end definition: (W+S) < 0.11um, the PRL (L2) of (V0 or V1) and neighboring M1 line > 0um
@ This rule isn't applicable for SRAM region
 v0_lend_enc = ENC [V0] M1_end <= 0.045 ABUT<90 OPPOSITE
 v0_lend_enc_e = V0 WITH EDGE v0_lend_enc
 v0_lend_full_e = v0_lend_enc_e TOUCH EDGE v0_lend_enc
 v0_lend_full_c = v0_lend_enc_e TOUCH EDGE (INT v0_lend_full_e [v0_lend_enc_e] < 0.005 ABUT==90)

 v0_side_met_s = EXT v0_lend_full_c M1 < 0.11-V0_MiniWidth OPPOSITE MEASURE ALL
 v0_side_met_e = M1 TOUCH EDGE (DFM COPY v0_side_met_s EDGE)
 v0_side_met_e_o = EXT M1_line v0_side_met_e < 0.005 ABUT INTERSECTING ONLY
 v0_side_met_e_c = v0_side_met_e TOUCH EDGE (DFM COPY v0_side_met_e_o EDGE)
 v0_side_met_s_c = EXT v0_lend_full_c v0_side_met_e_c < 0.11-V0_MiniWidth OPPOSITE MEASURE ALL
 v0_side_met = M1 TOUCH EDGE ((DFM COPY v0_side_met_e_o EDGE) NOT TOUCH EDGE v0_side_met_e)
 v0_real_met = v0_lend_full_e TOUCH EDGE (v0_lend_enc_e WITH EDGE (DFM COPY v0_side_met_s_c EDGE))
 err1 = EXT v0_real_met v0_side_met < 0.117 ABUT<90 REGION MEASURE ALL OPPOSITE EXTENDED 0.025
 err1 NOT INSIDE INST
}

M1_S_17_V1_DFM1 {
@ Space between M1 line and (V0 or V1) enclosed by dense M1 line-end (when PRL (L1) > -0.025um; E <= 0.045um) >= 0.117um
@ Dense M1 line end definition: (W+S) < 0.11um, the PRL (L2) of (V0 or V1) and neighboring M1 line > 0um
@ This rule isn't applicable for SRAM region
 v1_lend_enc = ENC [V1] M1_end <= 0.045 ABUT<90 OPPOSITE
 v1_lend_enc_e = V1 WITH EDGE v1_lend_enc
 v1_lend_full_e = v1_lend_enc_e TOUCH EDGE v1_lend_enc
 v1_lend_full_c = v1_lend_enc_e TOUCH EDGE (INT v1_lend_full_e [v1_lend_enc_e] < 0.005 ABUT==90)

 v1_side_met_s = EXT v1_lend_full_c M1 < 0.11-V1_MiniWidth OPPOSITE MEASURE ALL
 v1_side_met_e = M1 TOUCH EDGE (DFM COPY v1_side_met_s EDGE)
 v1_side_met_e_o = EXT M1_line v1_side_met_e < 0.005 ABUT INTERSECTING ONLY
 v1_side_met_e_c = v1_side_met_e TOUCH EDGE (DFM COPY v1_side_met_e_o EDGE)
 v1_side_met_s_c = EXT v1_lend_full_c v1_side_met_e_c < 0.11-V1_MiniWidth OPPOSITE MEASURE ALL
 v1_side_met = M1 TOUCH EDGE ((DFM COPY v1_side_met_e_o EDGE) NOT TOUCH EDGE v1_side_met_e)
 v1_real_met = v1_lend_full_e TOUCH EDGE (v1_lend_enc_e WITH EDGE (DFM COPY v1_side_met_s_c EDGE))
 err1 = EXT v1_real_met v1_side_met < 0.117 ABUT<90 REGION MEASURE ALL OPPOSITE EXTENDED 0.025
 err1 NOT INSIDE INST
}

M1_S_19_DFM1 {
@ Recommended M1 forbidden zone of ((W1+S1+W2+S2) or (S1+W2+S2+W3)) = 0.14~0.159um
@ When M1 width is < 0.037um
@ DRC flags edge of forbidden zone, and waive the violation in same polygon
 M1_NOTCH = EXT [M1] <= 0.159+GLOBAL_TOLERANCE-2*M1_MiniWidth-M1_MiniSpace
 M1_NOTCH_A = EXT (M1_v_edges COIN EDGE M1_NOTCH) <= 0.159+GLOBAL_TOLERANCE-2*M1_MiniWidth ABUT<90 OPPOSITE PARA ONLY NOTCH REGION EXCLUDE SHIELDED
 M1_NOTCH_A_all = M1_v_edges OR EDGE (M1_NOTCH_A COIN EDGE M1_v_edges)
 M1_ERR_P1 = DFM SPACE M1_NOTCH_A_all M1_width_lt_037_opp_edges >= 0.140 <= 0.159 BY ENC MEASURE ALL COUNT == 3 BY LAYER M1_NOTCH_A_all
 M1_ERR_P2 = DFM SPACE M1_width_lt_037_opp_edges M1_NOTCH_A_all >= 0.140 <= 0.159 BY ENC MEASURE ALL COUNT == 3 BY LAYER M1_NOTCH_A_all
 err1 = DFM PROPERTY M1_ERR_P1 M1_COLORA M1_COLORB M1_width_lt_037_opp_edges OVERLAP ABUT ALSO MULTI
  [+= count(M1_width_lt_037_opp_edges)] > 0
  [-= (EC(M1_ERR_P1) > 0 && (count(M1_COLORA) > 1 || count(M1_COLORB) > 1 || count(M1_COLORA) == 0 || count(M1_COLORB) == 0)) ? 1 : 0 ] > 0
 err2 = DFM PROPERTY M1_ERR_P2 M1_COLORA M1_COLORB M1_width_lt_037_opp_edges OVERLAP ABUT ALSO MULTI
  [+= count(M1_width_lt_037_opp_edges)] > 0
  [-= (EC(M1_ERR_P2) > 0 && (count(M1_COLORA) > 1 || count(M1_COLORB) > 1 || count(M1_COLORA) == 0 || count(M1_COLORB) == 0)) ? 1 : 0 ] > 0
 DFM COPY err1 err2

 M1_NOTCH_B = EXT (M1_h_edges COIN EDGE M1_NOTCH) <= 0.159+GLOBAL_TOLERANCE-2*M1_MiniWidth ABUT<90 OPPOSITE PARA ONLY NOTCH REGION EXCLUDE SHIELDED
 M1_NOTCH_B_all = M1_h_edges OR EDGE (M1_NOTCH_B COIN EDGE M1_h_edges)
 M1_ERR_P3 = DFM SPACE M1_NOTCH_B_all M1_width_lt_037_opp_edges >= 0.140 <= 0.159 BY ENC MEASURE ALL COUNT == 3 BY LAYER M1_NOTCH_B_all
 M1_ERR_P4 = DFM SPACE M1_width_lt_037_opp_edges M1_NOTCH_B_all >= 0.140 <= 0.159 BY ENC MEASURE ALL COUNT == 3 BY LAYER M1_NOTCH_B_all
 err3 = DFM PROPERTY M1_ERR_P3 M1_COLORA M1_COLORB M1_width_lt_037_opp_edges OVERLAP ABUT ALSO MULTI
  [+= count(M1_width_lt_037_opp_edges)] > 0
  [-= (EC(M1_ERR_P3) > 0 && (count(M1_COLORA) > 1 || count(M1_COLORB) > 1 || count(M1_COLORA) == 0 || count(M1_COLORB) == 0)) ? 1 : 0 ] > 0
 err4 = DFM PROPERTY M1_ERR_P4 M1_COLORA M1_COLORB M1_width_lt_037_opp_edges OVERLAP ABUT ALSO MULTI
  [+= count(M1_width_lt_037_opp_edges)] > 0
  [-= (EC(M1_ERR_P4) > 0 && (count(M1_COLORA) > 1 || count(M1_COLORB) > 1 || count(M1_COLORA) == 0 || count(M1_COLORB) == 0)) ? 1 : 0 ] > 0
 DFM COPY err3 err4
}

M1_S_35_DFM1 {
@ Space between M1 outside vertex (M1 line-end outer vertex or L-shape outer vertex) and nearby L-shape inner vertex >= 0.047um
@ DRC flag if both projection space < 0.036um
 Y1 = (EXT [M1_v_edges] < 0.036 ABUT<90 OPPOSITE EXTENDED 0.047) OR EDGE (EXT [M1_h_edges] < 0.036 ABUT<90 OPPOSITE EXTENDED 0.047)
 Y2 = EXT M1_convex_corner M1_concave_corner < 0.047 ABUT<90

 err1_a = INT Y1 < 0.001 ABUT==90 INTERSECTING ONLY
 err1_b = EXT Y1 < 0.001 ABUT==90 INTERSECTING ONLY
 err1_c = DFM PROPERTY Y2 err1_a err1_b ABUT ALSO OVERLAP MULTI [-= (count(err1_a) > 0 && count(err1_b) > 0) ? 1 : 0] > 0
 err1 = DFM COPY err1_c REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

M1_A_1_DFM1 {
@ M1 area, except INST region >= 0.01um2
 err1 = AREA M1 < 0.01
 err1 NOT INSIDE INST
}

M1_R_6_RV0_DFM1 {
@ It's not recommended to use U-shape M1
@ DRC check condition:
@ 1. With at least one RV0 or RV1
@ 2. M1 width W <= 0.038um
@ 3. S <= 0.12um
@ This rule is not applied for INST region
 ushape_opp = LENGTH M1_convex_270_270_edges <= 0.120
 ushape_wid = INT ushape_opp M1_convex_gt_one_edges <= 0.038 OPPOSITE
 ushape_edg = ushape_opp COIN EDGE (DFM COPY ushape_wid EDGE)
 ushape_met = (M1 WITH EDGE ushape_edg) INTERACT RV0
 ushape_chk = ushape_edg COIN EDGE ushape_met
 ushape_038 = (EXPAND EDGE ushape_chk INSIDE BY 0.038) AND M1
 ushape_via = (SIZE ushape_038 BY 0.12 INSIDE OF M1 STEP 0.01) INTERACT RV0
 ushape_err = DFM PROPERTY ushape_wid ushape_via OVERLAP ABUT ALSO MULTI [s= area(ushape_via)] > 0 [w= min(ew(ushape_wid))] > 0

 err1 = DFM COPY ushape_err REGION
 err1 NOT INSIDE INST
}

M1_R_6_RV1_DFM1 {
@ It's not recommended to use U-shape M1
@ DRC check condition:
@ 1. With at least one RV0 or RV1
@ 2. M1 width W <= 0.038um
@ 3. S <= 0.12um
@ This rule is not applied for INST region
 ushape_opp = LENGTH M1_convex_270_270_edges <= 0.120
 ushape_wid = INT ushape_opp M1_convex_gt_one_edges <= 0.038 OPPOSITE
 ushape_edg = ushape_opp COIN EDGE (DFM COPY ushape_wid EDGE)
 ushape_met = (M1 WITH EDGE ushape_edg) INTERACT RV1
 ushape_chk = ushape_edg COIN EDGE ushape_met
 ushape_038 = (EXPAND EDGE ushape_chk INSIDE BY 0.038) AND M1
 ushape_via = (SIZE ushape_038 BY 0.12 INSIDE OF M1 STEP 0.01) INTERACT RV1
 ushape_err = DFM PROPERTY ushape_wid ushape_via OVERLAP ABUT ALSO MULTI [s= area(ushape_via)] > 0 [w= min(ew(ushape_wid))] > 0

 err1 = DFM COPY ushape_err REGION
 err1 NOT INSIDE INST
}

M1_R_7_V0_DFM1 {
@ It's not recommended to use Hook-shape M1
@ Hook-shape M1 definition:
@ (1) Hook-end line width (W1) is <= 0.05um, length (L1) <= 0.15um, ΔL > 0.1um and Hook-end interact one via/rectangle via
@ (2) W2/W3 width <= 0.072um
@ (3) Space between two M1 arms (S1) <= 0.1um
@ (4) Space between via and another M1 S2 <= 0.038um when PRL > -0.015um
@ DRC waive if hook-end enclosure V0/V1 >= 0.05um
@ This rule is not applied for INST region
 hook_neck = CONVEX EDGE M1 ANGLE1==270 LENGTH1<=0.15 ANGLE2==270 LENGTH2>0 WITH LENGTH <= 0.100
 hook_neck_ege = hook_neck NOT TOUCH EDGE (INT (hook_neck) M1 <= 0.072 ABUT<90 OPPOSITE)
 hook_neck_exd = EXPAND EDGE hook_neck_ege OUTSIDE BY 0.01
 hook_neck_sid = M1 COIN EDGE hook_neck_exd

 hook_seek = (M1 WITH EDGE hook_neck_ege) WITH EDGE M1_end_0.050
 hook_head_sid = INT [hook_seek] <= 0.05 ABUT<90 OPPOSITE
 hook_head_end = M1_end_0.050 TOUCH EDGE hook_seek
 hook_head_end_r = M1_end_0.050 TOUCH EDGE (OR EDGE (ENC V0 [hook_head_end] < 0.05 ABUT<90 OPPOSITE) (ENC V1 [hook_head_end] < 0.05 ABUT<90 OPPOSITE))
 hook_head_via_b = V0 WITH EDGE (ENC [V0] hook_head_end < 0.05 ABUT<90 OPPOSITE)
 hook_head_via_u = V1 WITH EDGE (ENC [V1] hook_head_end < 0.05 ABUT<90 OPPOSITE)
 hook_head_via_b_sid = ENC [hook_head_via_b] hook_head_sid <= 0.050-V0_MiniWidth ABUT<90 OPPOSITE
 hook_head_via_u_sid = ENC [hook_head_via_u] hook_head_sid <= 0.050-V0_MiniWidth ABUT<90 OPPOSITE
 hook_head_via = hook_head_via_b WITH EDGE (EXT M1 [hook_head_via_b_sid] < 0.038+GLOBAL_TOLERANCE ABUT<90 OPPOSITE EXTENDED 0.015 MEASURE ALL)

 hook_seek_met = hook_seek ENCLOSE hook_head_via
 hook_neck_cor = EXT [hook_seek_met] < 0.005 ABUT==90 INTERSECTING ONLY
 hook_neck_err = EXT hook_neck_cor <= 0.100 ABUT<90 OPPOSITE
 hook_neck_arm = hook_seek_met TOUCH EDGE hook_neck_cor
 hook_neck_dtl = DFM PROPERTY hook_neck_err hook_neck_arm OVERLAP ABUT ALSO MULTI [dt_l = max(length(hook_neck_arm)) - min(length(hook_neck_arm))]

 hook_head_a = (INT (M1_convex_gt_one_edges TOUCH EDGE hook_seek_met) <= 0.05 OPPOSITE REGION) WITH EDGE hook_head_end_r
 hook_head_b = NOT ENCLOSE RECTANGLE hook_head_a 0.001 0.150+GLOBAL_TOLERANCE ORTHOGONAL ONLY
 hook_head = hook_head_b NOT OUTSIDE hook_head_via
 hook_tail = INT (hook_neck_sid) M1 <= 0.072 ABUT<90 OPPOSITE
 hook_gain = DFM PROPERTY hook_neck_err hook_tail hook_head hook_neck_dtl OVERLAP ABUT ALSO MULTI
 [-= (count(hook_head) > 0 && count(hook_tail) == 0) ? 1 : 0] > 0 [dt_l = property(hook_neck_dtl,dt_l)] > 0.10
 err1 = DFM COPY hook_gain REGION
 err1 NOT INSIDE INST
}

M1_R_7_V1_DFM1 {
@ It's not recommended to use Hook-shape M1
@ Hook-shape M1 definition:
@ (1) Hook-end line width (W1) is <= 0.05um, length (L1) <= 0.15um, ΔL > 0.1um and Hook-end interact one via/rectangle via
@ (2) W2/W3 width <= 0.072um
@ (3) Space between two M1 arms (S1) <= 0.1um
@ (4) Space between via and another M1 S2 <= 0.038um when PRL > -0.015um
@ DRC waive if hook-end enclosure V0/V1 >= 0.05um
@ This rule is not applied for INST region
 hook_neck = CONVEX EDGE M1 ANGLE1==270 LENGTH1<=0.15 ANGLE2==270 LENGTH2>0 WITH LENGTH <= 0.100
 hook_neck_ege = hook_neck NOT TOUCH EDGE (INT (hook_neck) M1 <= 0.072 ABUT<90 OPPOSITE)
 hook_neck_exd = EXPAND EDGE hook_neck_ege OUTSIDE BY 0.01
 hook_neck_sid = M1 COIN EDGE hook_neck_exd

 hook_seek = (M1 WITH EDGE hook_neck_ege) WITH EDGE M1_end_0.050
 hook_head_sid = INT [hook_seek] <= 0.05 ABUT<90 OPPOSITE
 hook_head_end = M1_end_0.050 TOUCH EDGE hook_seek
 hook_head_end_r = M1_end_0.050 TOUCH EDGE (OR EDGE (ENC V0 [hook_head_end] < 0.05 ABUT<90 OPPOSITE) (ENC V1 [hook_head_end] < 0.05 ABUT<90 OPPOSITE))
 hook_head_via_b = V0 WITH EDGE (ENC [V0] hook_head_end < 0.05 ABUT<90 OPPOSITE)
 hook_head_via_u = V1 WITH EDGE (ENC [V1] hook_head_end < 0.05 ABUT<90 OPPOSITE)
 hook_head_via_b_sid = ENC [hook_head_via_b] hook_head_sid <= 0.050-V1_MiniWidth ABUT<90 OPPOSITE
 hook_head_via_u_sid = ENC [hook_head_via_u] hook_head_sid <= 0.050-V1_MiniWidth ABUT<90 OPPOSITE
 hook_head_via = hook_head_via_u WITH EDGE (EXT M1 [hook_head_via_u_sid] < 0.038+GLOBAL_TOLERANCE ABUT<90 OPPOSITE EXTENDED 0.015 MEASURE ALL)

 hook_seek_met = hook_seek ENCLOSE hook_head_via
 hook_neck_cor = EXT [hook_seek_met] < 0.005 ABUT==90 INTERSECTING ONLY
 hook_neck_err = EXT hook_neck_cor <= 0.100 ABUT<90 OPPOSITE
 hook_neck_arm = hook_seek_met TOUCH EDGE hook_neck_cor
 hook_neck_dtl = DFM PROPERTY hook_neck_err hook_neck_arm OVERLAP ABUT ALSO MULTI [dt_l = max(length(hook_neck_arm)) - min(length(hook_neck_arm))]

 hook_head_a = (INT (M1_convex_gt_one_edges TOUCH EDGE hook_seek_met) <= 0.05 OPPOSITE REGION) WITH EDGE hook_head_end_r
 hook_head_b = NOT ENCLOSE RECTANGLE hook_head_a 0.001 0.150+GLOBAL_TOLERANCE ORTHOGONAL ONLY
 hook_head = hook_head_b NOT OUTSIDE hook_head_via
 hook_tail = INT (hook_neck_sid) M1 <= 0.072 ABUT<90 OPPOSITE
 hook_gain = DFM PROPERTY hook_neck_err hook_tail hook_head hook_neck_dtl OVERLAP ABUT ALSO MULTI
 [-= (count(hook_head) > 0 && count(hook_tail) == 0) ? 1 : 0] > 0 [dt_l = property(hook_neck_dtl,dt_l)] > 0.10
 err1 = DFM COPY hook_gain REGION
 err1 NOT INSIDE INST
}

M1_end_0.038 = LENGTH M1_convex_90_90_edges <= 0.038
M1_end_0.064 = LENGTH M1_convex_90_90_edges <= 0.064
met1_38_side = INT [M1] <= 0.038 ABUT<90 OPPOSITE
met1_48_side = INT [M1] <= 0.048 ABUT<90 OPPOSITE
met1_64_side = INT [M1] <= 0.064 ABUT<90 OPPOSITE

M1_R_8_DFM1 {
@ It's not recommended to use dense M1 line end pattern
@ DRC flage conditions:
@ (1) Middle line width(W1) <= 0.038um, both two neighbour M1 lines width <= 0.064um
@ (2) Both the V0 dense region (dense region definition: region formed by V0 horizontal edge extension 0.038um, vertical edge extension 0.05um) horizontal edges interact neighbour M1 line-end
@ DRC waive if M1 enclosure V0 > 0.05um
@ This rule is not applied for INST region
 via_met = V0_SR NOT OUTSIDE (M1 WITH WIDTH <= 0.038)
 via_end = via_met TOUCH EDGE (ENC [via_met] M1_end_0.038 <= 0.05 ABUT<90 OPPOSITE)
 via_lin = (via_met NOT TOUCH EDGE via_end) TOUCH EDGE (ENC [via_met] met1_38_side <= 0.038-V0_MiniWidth ABUT<90 OPPOSITE)
 via_mid = (via_met WITH EDGE via_end) WITH EDGE via_lin == 2
 via_sid = via_mid TOUCH EDGE via_lin

 nei_end = LENGTH M1_convex_90_90_edges <= 0.064
 nei_sid = LENGTH (EXPAND EDGE nei_end OUTSIDE BY 0.001) == 0.001
 nei_via = EXT [via_sid] nei_sid < 0.038+GLOBAL_TOLERANCE ABUT<90 OPPOSITE EXTENDED 0.050 MEASURE ALL
 err1 = via_mid WITH EDGE (via_mid TOUCH EDGE nei_via) >= 2
 err1 NOT INSIDE INST
}

M1_R_9_V0_DFM1 {
@ It's not recommended to use dense M1 3-bar pattern
@ DRC flag conditions:
@ (1) Middle M1 line width (W1) is <= 0.048um, both two neighbour M1 line width <= 0.064um and interact square or rectangle V0 or V1
@ (2) M1 Space to both via (S1/S2) = 0.058~0.063um
@ (3) The via PRL: -0.1 < PRL < 0.1um
@ (4) Both neighbour M1 enclosure V0 or V1 < 0.05um
@ This rule is not applied for INST region
 via_d_met = V0_SR NOT OUTSIDE (M1 WITH WIDTH <= 0.064)
 via_d_end = via_d_met TOUCH EDGE (ENC [via_d_met] M1_end_0.064 < 0.05 ABUT<90 OPPOSITE)
 via_d_lin = (via_d_met NOT TOUCH EDGE via_d_end) TOUCH EDGE (ENC [via_d_met] met1_64_side <= 0.064-V0_MiniWidth ABUT<90 OPPOSITE)
 via_d_mid = (via_d_met WITH EDGE via_d_end) WITH EDGE via_d_lin >= 2
 via_d_sid = via_d_mid TOUCH EDGE via_d_lin
 via_d_sps = (EXT [met1_48_side] via_d_sid >= 0.058 <= 0.063 OPPOSITE EXTENDED 0.100 MEASURE ALL) TOUCH EDGE (EXT [met1_48_side] via_d_sid >= 0.058 <= 0.063 OPPOSITE MEASURE ALL)
 err1 = INT via_d_sps <= 0.048 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE INST
}

M1_R_9_V1_DFM1 {
@ It's not recommended to use dense M1 3-bar pattern
@ DRC flag conditions:
@ (1) Middle M1 line width (W1) is <= 0.048um, both two neighbour M1 line width <= 0.064um and interact square or rectangle V0 or V1
@ (2) M1 Space to both via (S1/S2) = 0.058~0.063um
@ (3) The via PRL: -0.1 < PRL < 0.1um
@ (4) Both neighbour M1 enclosure V0 or V1 < 0.05um
@ This rule is not applied for INST region
 via_u_met = V1_SR NOT OUTSIDE (M1 WITH WIDTH <= 0.064)
 via_u_end = via_u_met TOUCH EDGE (ENC [via_u_met] M1_end_0.064 < 0.05 ABUT<90 OPPOSITE)
 via_u_lin = (via_u_met NOT TOUCH EDGE via_u_end) TOUCH EDGE (ENC [via_u_met] met1_64_side <= 0.064-V1_MiniWidth ABUT<90 OPPOSITE)
 via_u_mid = (via_u_met WITH EDGE via_u_end) WITH EDGE via_u_lin >= 2
 via_u_sid = via_u_mid TOUCH EDGE via_u_lin
 via_u_sps = (EXT [met1_48_side] via_u_sid >= 0.058 <= 0.063 OPPOSITE EXTENDED 0.100 MEASURE ALL) TOUCH EDGE (EXT [met1_48_side] via_u_sid >= 0.058 <= 0.063 OPPOSITE MEASURE ALL)
 err1 = INT via_u_sps <= 0.048 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE INST
}
#ENDIF

#IFDEF DOUBLE_PATTERNING_RULES_CHECK YES
#IFDEF DFM_RULES_PRIORITY_2 YES
#IFDEF DOUBLE_PATTERNING_RULES_CHECK_ONLY YES
DRC SELECT CHECK M1_OR_15_DFM2
#ENDIF
M1_OR_15_DFM2 {
@ Continuous 3 or more M1 with spacing < 0.063um is not allowed
@ DRC flag if all these M1 space < 0.063um
 color_a = M1 INTERACT M1_mask0
 color_b = M1 INTERACT M1_mask1
 err1 = WITH NEIGHBOR color_a >= 2 SPACE < 0.063
 err2 = WITH NEIGHBOR color_b >= 2 SPACE < 0.063
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}
#ENDIF
#ENDIF

M1_W_1 {
@ M1 width >= 0.032um
 err1 = INT M1 < 0.032 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

M1_W_2 {
@ M1 maximum width, except MARKS and LOGO regions <= 2.1um
 err1 = (M1 NOT INSIDE MARKS_LOGO) WITH WIDTH > 2.1
 err1 NOT INSIDE MARKS_LOGO
}

M1_W_3 {
@ M1 width when both side spaces are >= 0.058um and <= 0.062um, PRL of two spaces >= -0.099um and PRL of both side of metal <= 0.111um when metal A/B/C all in same color >= 0.036um
 met_side_space = (EXT M1 >= 0.058 <= 0.062 ABUT<90 OPPOSITE REGION) NOT ENCLOSE RECTANGLE 0.001 0.111+GLOBAL_TOLERANCE ORTHOGONAL ONLY
 met_side_waive = EXT M1CA M1CB >= 0.058 <= 0.062 ABUT<90 OPPOSITE REGION
 met_edge_check = (EXT [M1] >= 0.058 <= 0.062 ABUT<90 OPPOSITE) COIN EDGE (met_side_space NOT met_side_waive)
 err1 = INT met_edge_check < 0.036 ABUT<90 OPPOSITE EXTENDED 0.099+GLOBAL_TOLERANCE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

M1_W_4 {
@ M1 branch width when connected to wide M1 (width > 2um) which enclosed inner hole ((M1 OR M1-hole) area >= 3050um2) >= 0.037um
@ DRC checks the M1 interact (((M1 OR M1-hole) sd 1um) su 1um) su 1um)
 area_including_holes = AREA (M1 OR (HOLES M1 INNER EMPTY)) >= 3050
 met_WIDTH_gt_2 = SIZE area_including_holes BY 1 UNDEROVER
 met_SPACE_lt_2 = SIZE met_WIDTH_gt_2 BY 1

 err1_TMP = WITH WIDTH (M1 INTERACT met_SPACE_lt_2) < 0.037
 err1 = err1_TMP INTERACT met_SPACE_lt_2
 err1 NOT INSIDE SealR_NOT_BULK
}
 
M1_W_5 {
@ M1 branch width when connected to wide M1 with both width and length >= 0.27um. >= 0.065um
 dorian_large = M1 WITH WIDTH >= 0.27
 dorian_whole = M1 INTERACT dorian_large
 dorian_large_exp = SIZE dorian_large BY 0.005 INSIDE OF dorian_whole
 dorian_branch_0 = dorian_whole NOT dorian_large
 dorian_branch_1 = dorian_branch_0 NOT COIN EDGE dorian_large
 dorian_branch_2 = dorian_branch_1 TOUCH EDGE dorian_large_exp
 err1 = INT dorian_branch_2 < 0.065 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

M1_W_6 {
@ Width of 45-degree bent M1 >= 0.152um
 err1 = INT M1_45_skew_edges < 0.152 OPPOSITE REGION EXCLUDE SHIELDED
 err1 NOT INSIDE SealR_NOT_BULK
}

M1_S_1 {
@ Space between two M1s, except LOGO region >= 0.032um
 err1 = EXT M1 < 0.032 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE LOGO
}

M1_S_2 {
@ Space between two M1s when one or both M1 enclosure of long side edge of RV0 < 0.005um
@ DRC flag the space between M1 and the long sides of RV0 >= 0.035um
 err1_c = ENC RV0_L [M1] < 0.005 ABUT<90 OPPOSITE
 err1 = EXT err1_c M1 < 0.035 ABUT<90 REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

M1_S_3 {
@ Space between two M1s when one or both M1 enclosure of long side edge of RV0 < 0.003um
@ DRC flag the space between M1 and the long sides of RV0 >= 0.044um
 err1_c = ENC RV0_L [M1] < 0.003 ABUT<90 OPPOSITE
 err1 = EXT err1_c M1 < 0.044 ABUT<90 REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

// M1.S.4 (purposely blank)
// M1_S_4 {
// @ Space between M1 and INST (except M1 cross INST boundary) >= 0.08um
//  err1 = EXT M1 INST < 0.08 ABUT>0<90 SINGULAR REGION
//  err1 NOT INSIDE SealR_NOT_BULK
// }

M1_S_6 {
@ 45-degree bent M1 space to M1 >= 0.152um
 err1 = OR (EXT M1_45_skew_edges M1 < 0.152 ABUT<90 OPPOSITE REGION) (EXT M1_45_skew_edges M1 < 0.152 ABUT<90 OPPOSITE1 REGION)
 err1 NOT INSIDE SealR_NOT_BULK
}
 
M1_S_7 {
@ Space between M1 when one or both M1 width >= 0.091um when PRL >= 0.141um. = 0.041~0.057, >= 0.072um
 met_wid_all = M1 WITH WIDTH >= 0.091
 met_err_RAW = (EXT [met_wid_all] M1 < 0.041 ABUT<90 OPPOSITE MEASURE ALL) OR EDGE (EXT [met_wid_all] M1 >= 0.058 < 0.072 ABUT<90 OPPOSITE MEASURE ALL)
 met_jog_ALL = (CONVEX EDGE M1 == 1) NOT COIN EDGE met_err_RAW
 met_jog_EXP_a = EXPAND EDGE met_jog_ALL INSIDE BY 0.0005
 met_jog_EXP_b = EXPAND EDGE met_jog_ALL OUTSIDE BY 0.0005
 met_jog_TMP = (met_jog_ALL COIN EDGE (met_jog_EXP_a WITH EDGE met_err_RAW)) COIN EDGE (met_jog_EXP_b WITH EDGE met_err_RAW)
 met_jog_EXP = ((VERTEX (EXPAND EDGE met_jog_TMP OUTSIDE BY 0.001 EXTEND BY 0.001) == 4) OR (EXPAND EDGE met_err_RAW OUTSIDE BY 0.001)) NOT M1
 // 
 met_err_PRL = DFM PROPERTY met_jog_EXP met_err_RAW OVERLAP ABUT ALSO MULTI [-= LENGTH(met_err_RAW)] > 0.141-GLOBAL_TOLERANCE
 met_err_EGE = met_err_RAW TOUCH EDGE met_err_PRL
 err1 = (EXT met_err_EGE M1 < 0.041 ABUT<90 OPPOSITE REGION MEASURE ALL) OR (EXT met_err_EGE M1 >= 0.058 < 0.072 ABUT<90 OPPOSITE REGION MEASURE ALL)
 err1 NOT INSIDE SealR_NOT_BULK
}
 
M1_S_8 {
@ Space between M1 when one or both M1 width >= 0.121um when PRL >= 0.141um, except OCOVL region = 0.041~0.057, >= 0.106um
 met_wid_all = M1 WITH WIDTH >= 0.121
 met_err_RAW = (EXT [met_wid_all] M1 < 0.041 ABUT<90 OPPOSITE MEASURE ALL) OR EDGE (EXT [met_wid_all] M1 >= 0.058 < 0.106 ABUT<90 OPPOSITE MEASURE ALL)
 met_jog_ALL = (CONVEX EDGE M1 == 1) NOT COIN EDGE met_err_RAW
 met_jog_EXP_a = EXPAND EDGE met_jog_ALL INSIDE BY 0.0005
 met_jog_EXP_b = EXPAND EDGE met_jog_ALL OUTSIDE BY 0.0005
 met_jog_TMP = (met_jog_ALL COIN EDGE (met_jog_EXP_a WITH EDGE met_err_RAW)) COIN EDGE (met_jog_EXP_b WITH EDGE met_err_RAW)
 met_jog_EXP = ((VERTEX (EXPAND EDGE met_jog_TMP OUTSIDE BY 0.001 EXTEND BY 0.001) == 4) OR (EXPAND EDGE met_err_RAW OUTSIDE BY 0.001)) NOT M1
 // 
 met_err_PRL = DFM PROPERTY met_jog_EXP met_err_RAW OVERLAP ABUT ALSO MULTI [-= LENGTH(met_err_RAW)] > 0.141-GLOBAL_TOLERANCE
 met_err_EGE = met_err_RAW TOUCH EDGE met_err_PRL
 err1 = (EXT met_err_EGE M1 < 0.041 ABUT<90 OPPOSITE REGION MEASURE ALL) OR (EXT met_err_EGE M1 >= 0.058 < 0.106 ABUT<90 OPPOSITE REGION MEASURE ALL)
 err1 NOT INSIDE OCOVL
}
 
M1_S_9 {
@ Space between M1 when one or both M1 width >= 0.181um when PRL >= 0.189um. >= 0.125um
 met_wid_all = M1 WITH WIDTH >= 0.181
 met_err_RAW = EXT M1 met_wid_all < 0.125 OPPOSITE REGION MEASURE ALL
 met_err_CRN = EXT (ANGLE M1 > 44 < 46) met_wid_all < 0.125 OPPOSITE1 REGION MEASURE ALL
 err1 = met_err_RAW ENCLOSE RECTANGLE 0.001 0.189 ORTHOGONAL ONLY
 err2 = met_err_CRN ENCLOSE RECTANGLE 0.032 0.189
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}
 
M1_S_10 {
@ Space between M1 when one or both M1 width >= 0.271um when PRL >= 0.289um. >= 0.143um
 met_wid_all = M1 WITH WIDTH >= 0.271
 met_err_RAW = EXT M1 met_wid_all < 0.143 OPPOSITE REGION MEASURE ALL
 met_err_CRN = EXT (ANGLE M1 > 44 < 46) met_wid_all < 0.143 OPPOSITE1 REGION MEASURE ALL
 err1 = met_err_RAW ENCLOSE RECTANGLE 0.001 0.289 ORTHOGONAL ONLY
 err2 = met_err_CRN ENCLOSE RECTANGLE 0.032 0.289
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

M1_S_11 {
@ Space between M1 when one or both M1 width >= 0.542um, except LOGO region >= 0.188um
 met_wid = M1 WITH WIDTH >= 0.542
 err1 = EXT met_wid M1 < 0.188 ABUT<90 REGION
 err1 NOT INSIDE LOGO
}

M1_S_12 {
@ Space between M1 when one or both M1 width >= 1.36um, except LOGO region >= 0.305um
 met_wid = (M1 WITH WIDTH >= 0.542) WITH WIDTH >= 1.36
 err1 = EXT met_wid M1 < 0.305 ABUT<90 REGION
 err1 NOT INSIDE LOGO
}

M1_S_13 {
@ Space between M1 and M1 line-end (width < 0.046um) when PRL > -0.016um. >= 0.049um
 err1 = EXT M1 M1_end_0.046 < 0.049 ABUT<90 OPPOSITE EXTENDED 0.016 REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

M1_S_14 {
@ Space between M1 line-end and line-end (width < 0.046um) when PRL > -0.016um, except INST region >= 0.058um
 err1 = EXT M1_end_0.046 < 0.058 ABUT<90 OPPOSITE EXTENDED 0.016 REGION
 err1 NOT INSIDE INST
}
 
M1_S_15 {
@ Space between M1 and dense M1 line-end (width < 0.046um, neighboring edge >= 0.048um), when PRL > -0.016um, except INST region >= 0.069um
@ Dense M1 line end definition:
@ (W+S1) < 0.09um, other metal must be in the region R, T and D is the extension from metal line end, T < 0.016um, D < 0.048um, S1 should be the space between separate metal.
@ (Except small jog with edge length < 0.032um)
 end_check_TMP = CONVEX EDGE M1 ANGLE1 == 90 LENGTH1 >= 0.048 ANGLE2 == 90 LENGTH2 >= 0.048 WITH LENGTH < 0.046
 end_space_TMP = EXT end_check_TMP M1 < 0.069 ABUT<90 OPPOSITE EXTENDED 0.016 REGION
 end_space_EGE = end_check_TMP TOUCH EDGE end_space_TMP
 end_inner_EXD = EXPAND EDGE end_space_EGE INSIDE BY 0.048 OUTSIDE BY 0.016
 end_sides_EGE = (end_inner_EXD TOUCH EDGE M1) NOT COIN EDGE end_check_TMP
 // 
 end_sides_ERR = EXT end_sides_EGE M1 < 0.09-0.032 OPPOSITE
 end_width_ERR = INT end_inner_EXD < 0.046 OPPOSITE EXCLUDE SHIELDED
 end_sides_CHK = DFM PROPERTY end_sides_EGE end_sides_ERR end_width_ERR OVERLAP ABUT ALSO MULTI [-= MIN(EW(end_sides_ERR)) + MIN(EW(end_width_ERR))] < 0.09
 end_check_EXD = (end_inner_EXD AND M1) WITH EDGE end_sides_CHK
 end_check = end_space_EGE TOUCH EDGE end_check_EXD
 err1 = EXT end_check M1 < 0.069 ABUT<90 OPPOSITE EXTENDED 0.016 REGION
 err1 NOT INSIDE INST
}

M1_line_end_046_054_edges = CONVEX EDGE M1 == 2 WITH LENGTH >= 0.046 <= 0.054
M1_line_end_046_054_prl_gt_135 = INT (M1_line_end_046_054_edges) M1 < 0.135 OPPOSITE EXCLUDE SHIELDED
M1_line_end_046_054_prl_gt_135_all = M1_line_end_046_054_edges TOUCH EDGE M1_line_end_046_054_prl_gt_135

M1_S_16 {
@ Space between M1 and M1 line-end space in metal array >= 0.072um
@ Metal array definition:
@ 1) M1 width (W): 0.046um <= W <= 0.054um
@ 2) M1 length (L) >= 0.135um
@ 3) Searching distance (D) of M1 line-end edge: 0.048um
@ 4) M1 space (S1) 0.058um <= S1 <= 0.076um for both long sides
@ 5) M1 PRL > 0um for short side (L1)
@ 6) Line end space (S2) of both neighboring M1: 0.058um <= S2 <= 0.076um with PRL > 0um
@ DRC doesn't flag at least one S1 >= 0.058~ <= 0.063um with PRL > 0.112um. And DRC flags forbidden space that has PRL > 0um with both S2
 distance_D_M = EXPAND EDGE M1_line_end_046_054_prl_gt_135_all INSIDE BY 0.048
 distance_D_W = (distance_D_M AND M1) COIN EDGE M1_line_end_046_054_prl_gt_135_all  //; W edge
 distance_D_W_edge = EXT [distance_D_W] M1 >= 0.058 <= 0.076 ABUT<90 OPPOSITE
 distance_D_W_058_076 = distance_D_W TOUCH EDGE distance_D_W_edge

//;for 58~63 region: exclude special orcs.2 dp shape
 distance_D_seg_twin = (EXPAND EDGE distance_D_W_058_076 INSIDE BY 0.112+0.048 EXTEND BY 0.054-0.046) AND (INT M1 >= 0.046 <= 0.054 OPPOSITE REGION)
 distance_D_seg_twin_l_sides = (distance_D_seg_twin NOT TOUCH EDGE distance_D_W_058_076) NOT INSIDE EDGE M1
 distance_D_seg_twin_l_sides_real = distance_D_seg_twin_l_sides NOT TOUCH EDGE (INT [distance_D_seg_twin_l_sides] distance_D_W_058_076 <= 0.112 + 0.048 ABUT<90 OPPOSITE)

 distance_D_side_058_062_space = EXT distance_D_seg_twin_l_sides_real >= 0.058 <= 0.062 ABUT<90 OPPOSITE REGION
 distance_D_side_058_062_space_orcs = distance_D_side_058_062_space NOT ENCLOSE RECTANGLE 0.005 0.112+GLOBAL_TOLERANCE ORTHOGONAL ONLY
 distance_D_side_058_062_edges = distance_D_seg_twin_l_sides_real COIN EDGE distance_D_side_058_062_space_orcs
 distance_D_side_058_062_both = INT distance_D_side_058_062_edges >= 0.046 <= 0.054 ABUT<90 OPPOSITE REGION

//;for 63~76 region
 distance_D_side_063_076_edges = EXT [distance_D_seg_twin_l_sides_real] >= 0.063 <= 0.076 ABUT<90 OPPOSITE
 distance_D_side_063_076 = INT distance_D_side_063_076_edges >= 0.046 <= 0.054 ABUT<90 OPPOSITE REGION
 distance_D_side_058_076 = distance_D_side_058_062_both OR distance_D_side_063_076  //;all 058~062,063~076

 distance_D_seg_midd_part = M1 AND (EXPAND EDGE distance_D_W_058_076 INSIDE BY 0.112 + 0.048 EXTEND BY -0.01)
 distance_D_seg_side_part = distance_D_seg_twin NOT distance_D_seg_midd_part
 distance_D_seg_side_part_c = distance_D_seg_side_part INTERACT distance_D_side_058_076
 distance_D_seg_midd_part_c = distance_D_seg_midd_part INTERACT distance_D_seg_side_part_c >= 2
 distance_D_seg_twin_058_076_c = (distance_D_seg_twin INTERACT distance_D_side_058_076) INTERACT distance_D_seg_midd_part_c

 distance_D_seg_twin_opp = INT distance_D_seg_twin_058_076_c <= 0.112 + 0.048 ABUT<90 OPPOSITE EXCLUDE SHIELDED
 distance_D_seg_twin_opp_ew = DFM PROPERTY distance_D_seg_twin_opp distance_D_seg_twin_058_076_c OVERLAP ABUT ALSO MULTI
 [max_ew = ew(distance_D_seg_twin_opp)] >= 0.135
 [cal_ew = (property_ref(max_ew) == ew(distance_D_seg_twin_opp)) ? 1 : 0] > 0

 distance_D_sp1 = distance_D_seg_twin_058_076_c NOT COIN EDGE (DFM COPY distance_D_seg_twin_opp_ew EDGE)
 distance_D_sp2 = (EXPAND EDGE distance_D_sp1 INSIDE BY 0.002 CORNER FILL) INTERACT distance_D_side_058_076
 distance_D_sp3 = distance_D_W_058_076 COIN EDGE (distance_D_seg_twin_058_076_c INTERACT distance_D_sp2 >= 2)

 distance_D_sp_forbidden = EXT distance_D_sp3 M1 < 0.072 ABUT<90 OPPOSITE REGION
 distance_D_sp_forbidden_ove = EXPAND EDGE (distance_D_W_058_076 TOUCH EDGE distance_D_sp_forbidden) OUTSIDE BY 0.005
 distance_D_sp_forbidden_all = EXTENTS (OR distance_D_sp_forbidden distance_D_sp_forbidden_ove)
 distance_D_sp_forbidden_side = distance_D_sp_forbidden_all NOT TOUCH EDGE M1
 distance_D_sp_forbidden_side_prl = EXT (distance_D_sp_forbidden_side) M1 >= 0.058 <= 0.076 ABUT<90 OPPOSITE
 distance_D_sp_forbidden_side_prl_both = distance_D_sp_forbidden_all WITH EDGE distance_D_sp_forbidden_side_prl >= 2
 err1 = distance_D_sp_forbidden AND distance_D_sp_forbidden_side_prl_both  //; flag error region has prl with the beside error region
 err1 NOT INSIDE SealR_NOT_BULK
}

M1_S_18 {
@ M1 forbidden space when one M1 width >= 0.15um and PRL > 0.135um, except M1 jog width <= 0.135um. = 0.058~0.062um
@ DRC searching range is from 0.106um to 0.729um
@ DRC flags the forbidden space that totally inside the searching range along the space direction, and the PRL between forbidden space and the wide metal is > 0.135um
 SPACE_Forbidden_PRE = EXT M1 >= 0.058 <= 0.062 ABUT<90 OPPOSITE REGION
 SPACE_Forbidden_TMP = SPACE_Forbidden_PRE ENCLOSE RECTANGLE 0.001 0.135+GLOBAL_TOLERANCE ORTHOGONAL ONLY
 SPACE_Forbidden_TMP_in_SearchR = EXT (M1 COIN EDGE SPACE_Forbidden_TMP) met_wide_eqgt_150 >= 0.106 <= 0.729 ABUT>0<90 OPPOSITE MEASURE ALL
 SPACE_Forbidden_TMP_in_SearchR_EDGE = M1 COIN EDGE (DFM COPY SPACE_Forbidden_TMP_in_SearchR EDGE)
 SPACE_Forbidden_real = EXT SPACE_Forbidden_TMP_in_SearchR_EDGE M1 >= 0.058 <= 0.062 ABUT<90 OPPOSITE REGION
 err1 = ENCLOSE RECTANGLE SPACE_Forbidden_real 0.001 0.135+GLOBAL_TOLERANCE ORTHOGONAL ONLY
 err1 NOT INSIDE SealR_NOT_BULK
}

#IFDEF DOUBLE_PATTERNING_RULES_CHECK YES
#IFDEF DOUBLE_PATTERNING_RULES_CHECK_ONLY YES
DRC SELECT CHECK M1_S_19 M1_S_20
#ENDIF
M1_a = M1 INTERACT M1_mask0
M1_b = M1 INTERACT M1_mask1
M1_a_v_edges = M1_v_edges TOUCH EDGE M1_a
M1_b_v_edges = M1_v_edges TOUCH EDGE M1_b
M1_a_h_edges = M1_h_edges TOUCH EDGE M1_a
M1_b_h_edges = M1_h_edges TOUCH EDGE M1_b
M1_a_width_lt_037_opp_edges = M1_width_lt_037_opp_edges COIN EDGE M1_a
M1_b_width_lt_037_opp_edges = M1_width_lt_037_opp_edges COIN EDGE M1_b
M1_a_width_lt_034_opp_edges = M1_width_lt_034_opp_edges COIN EDGE M1_a
M1_b_width_lt_034_opp_edges = M1_width_lt_034_opp_edges COIN EDGE M1_b

M1_S_19 {
@ M1 forbidden space for single mask when M1 width < 0.037um and PRL with neighboring M1 (W3) > 0.117um
@ DRC flags edge of ((W1+S1+W2+S2) or (S1+W2+S2+W3)) = 0.141~0.159um
@ DRC waive when:
@ (1) A/B or B/C are same polygons
@ (2) A/C in different masks
@ (3) INST region
 M1_NOTCH = EXT [M1] <= 0.159+GLOBAL_TOLERANCE-2*M1_MiniWidth-M1_MiniSpace ABUT<90 OPPOSITE
 M1_NOTCH_A = EXT (M1_v_edges COIN EDGE M1_NOTCH) <= 0.159+GLOBAL_TOLERANCE-2*M1_MiniWidth ABUT<90 OPPOSITE PARA ONLY NOTCH REGION EXCLUDE SHIELDED
 M1_NOTCH_A_all = M1_v_edges OR EDGE (M1_NOTCH_A COIN EDGE M1_v_edges)
 M1_ERR_P1 = DFM SPACE M1_NOTCH_A_all M1_width_lt_037_opp_edges >= 0.141 <= 0.159 BY ENC MEASURE ALL COUNT == 3 BY LAYER M1_NOTCH_A_all
 M1_ERR_P2 = DFM SPACE M1_width_lt_037_opp_edges M1_NOTCH_A_all >= 0.141 <= 0.159 BY ENC MEASURE ALL COUNT == 3 BY LAYER M1_NOTCH_A_all
 err1 = DFM PROPERTY M1_ERR_P1 M1_COLORA M1_COLORB M1_width_lt_037_opp_edges INST M1_a_v_edges M1_b_v_edges OVERLAP ABUT ALSO MULTI
  [s = count(INST)] == 0
  [+= (count(M1_width_lt_037_opp_edges) > 0 && (count(M1_a_v_edges) == 0 || count(M1_b_v_edges) == 0)) ? 1 : 0] > 0
  [-= (EC(M1_ERR_P1) > 0.117 && (count(M1_COLORA) > 1 || count(M1_COLORB) > 1 || count(M1_COLORA) == 0 || count(M1_COLORB) == 0)) ? 1 : 0 ] > 0
 err2 = DFM PROPERTY M1_ERR_P2 M1_COLORA M1_COLORB M1_width_lt_037_opp_edges INST M1_a_v_edges M1_b_v_edges OVERLAP ABUT ALSO MULTI
  [s = count(INST)] == 0
  [+= (count(M1_width_lt_037_opp_edges) > 0 && (count(M1_a_v_edges) == 0 || count(M1_b_v_edges) == 0)) ? 1 : 0] > 0
  [-= (EC(M1_ERR_P2) > 0.117 && (count(M1_COLORA) > 1 || count(M1_COLORB) > 1 || count(M1_COLORA) == 0 || count(M1_COLORB) == 0)) ? 1 : 0 ] > 0

 err3 = DFM PROPERTY M1_ERR_P1 M1_COLORA M1_COLORB M1_width_lt_037_opp_edges DRC:1_NOT_INST M1_a_v_edges M1_b_v_edges OVERLAP ABUT ALSO MULTI
  [s = count(DRC:1_NOT_INST)] > 0
  [+= (count(M1_width_lt_037_opp_edges) > 0 && (count(M1_a_v_edges) == 0 || count(M1_b_v_edges) == 0)) ? 1 : 0] > 0
  [-= (EC(M1_ERR_P1) > 0.117 && (count(M1_COLORA) > 1 || count(M1_COLORB) > 1 || count(M1_COLORA) == 0 || count(M1_COLORB) == 0)) ? 1 : 0 ] > 0
 err4 = DFM PROPERTY M1_ERR_P2 M1_COLORA M1_COLORB M1_width_lt_037_opp_edges DRC:1_NOT_INST M1_a_v_edges M1_b_v_edges OVERLAP ABUT ALSO MULTI
  [s = count(DRC:1_NOT_INST)] > 0
  [+= (count(M1_width_lt_037_opp_edges) > 0 && (count(M1_a_v_edges) == 0 || count(M1_b_v_edges) == 0)) ? 1 : 0] > 0
  [-= (EC(M1_ERR_P2) > 0.117 && (count(M1_COLORA) > 1 || count(M1_COLORB) > 1 || count(M1_COLORA) == 0 || count(M1_COLORB) == 0)) ? 1 : 0 ] > 0

 M1_NOTCH_B = EXT (M1_h_edges COIN EDGE M1_NOTCH) <= 0.159+GLOBAL_TOLERANCE-2*M1_MiniWidth ABUT<90 OPPOSITE PARA ONLY NOTCH REGION EXCLUDE SHIELDED
 M1_NOTCH_B_all = M1_h_edges OR EDGE (M1_NOTCH_B COIN EDGE M1_h_edges)
 M1_ERR_P3 = DFM SPACE M1_NOTCH_B_all M1_width_lt_037_opp_edges >= 0.141 <= 0.159 BY ENC MEASURE ALL COUNT == 3 BY LAYER M1_NOTCH_B_all
 M1_ERR_P4 = DFM SPACE M1_width_lt_037_opp_edges M1_NOTCH_B_all >= 0.141 <= 0.159 BY ENC MEASURE ALL COUNT == 3 BY LAYER M1_NOTCH_B_all
 err5 = DFM PROPERTY M1_ERR_P3 M1_COLORA M1_COLORB M1_width_lt_037_opp_edges INST M1_a_h_edges M1_b_h_edges OVERLAP ABUT ALSO MULTI
  [s = count(INST)] == 0
  [+= (count(M1_width_lt_037_opp_edges) > 0 && (count(M1_a_h_edges) == 0 || count(M1_b_h_edges) == 0)) ? 1 : 0] > 0
  [-= (EC(M1_ERR_P3) > 0.117 && (count(M1_COLORA) > 1 || count(M1_COLORB) > 1 || count(M1_COLORA) == 0 || count(M1_COLORB) == 0)) ? 1 : 0 ] > 0
 err6 = DFM PROPERTY M1_ERR_P4 M1_COLORA M1_COLORB M1_width_lt_037_opp_edges INST M1_a_h_edges M1_b_h_edges OVERLAP ABUT ALSO MULTI
  [s = count(INST)] == 0
  [+= (count(M1_width_lt_037_opp_edges) > 0 && (count(M1_a_h_edges) == 0 || count(M1_b_h_edges) == 0)) ? 1 : 0] > 0
  [-= (EC(M1_ERR_P4) > 0.117 && (count(M1_COLORA) > 1 || count(M1_COLORB) > 1 || count(M1_COLORA) == 0 || count(M1_COLORB) == 0)) ? 1 : 0 ] > 0

 err7 = DFM PROPERTY M1_ERR_P3 M1_COLORA M1_COLORB M1_width_lt_037_opp_edges DRC:1_NOT_INST M1_a_h_edges M1_b_h_edges OVERLAP ABUT ALSO MULTI
  [s = count(DRC:1_NOT_INST)] > 0
  [+= (count(M1_width_lt_037_opp_edges) > 0 && (count(M1_a_h_edges) == 0 || count(M1_b_h_edges) == 0)) ? 1 : 0] > 0
  [-= (EC(M1_ERR_P3) > 0.117 && (count(M1_COLORA) > 1 || count(M1_COLORB) > 1 || count(M1_COLORA) == 0 || count(M1_COLORB) == 0)) ? 1 : 0 ] > 0
 err8 = DFM PROPERTY M1_ERR_P4 M1_COLORA M1_COLORB M1_width_lt_037_opp_edges DRC:1_NOT_INST M1_a_h_edges M1_b_h_edges OVERLAP ABUT ALSO MULTI
  [s = count(DRC:1_NOT_INST)] > 0
  [+= (count(M1_width_lt_037_opp_edges) > 0 && (count(M1_a_h_edges) == 0 || count(M1_b_h_edges) == 0)) ? 1 : 0] > 0
  [-= (EC(M1_ERR_P4) > 0.117 && (count(M1_COLORA) > 1 || count(M1_COLORB) > 1 || count(M1_COLORA) == 0 || count(M1_COLORB) == 0)) ? 1 : 0 ] > 0
 DFM COPY err1 err2 err3 err4 err5 err6 err7 err8
}

M1_S_20 {
@ M1 forbidden space for single mask = 0.161~0.174um
@ when
@ 1. M1 width < 0.034um and PRL with neighboring M1 (W2) > 0.117um
@ 2. M1 space: 0.032um <= S1 < 0.037um or 0.058um <= S1 < 0.068um, or 0.032um <= S3 < 0.037um or 0.058um <= S3 < 0.068um
@ DRC flags edge of ((W1+S1+W2+S2) or (S1+W2+S2+W3)) = 0.161~0.174
@ DRC waive when:
@ (1) A/B or B/C are same polygons
@ (2) A/C in different masks
@ (3) INST region
 M1_NOTCH = EXT [M1] <= 0.174+GLOBAL_TOLERANCE-2*M1_MiniWidth-M1_MiniSpace ABUT<90 OPPOSITE
 M1_NOTCH_A = EXT (M1_v_edges COIN EDGE M1_NOTCH) <= 0.174+GLOBAL_TOLERANCE-2*M1_MiniSpace ABUT<90 OPPOSITE PARA ONLY NOTCH REGION EXCLUDE SHIELDED
 M1_NOTCH_A_all = M1_v_edges OR EDGE (M1_NOTCH_A COIN EDGE M1_v_edges)
 M1_ERR_P1 = DFM SPACE M1_NOTCH_A_all M1_width_lt_034_opp_edges >= 0.161 <= 0.174 BY ENC MEASURE ALL COUNT == 3 BY LAYER M1_NOTCH_A_all
 M1_ERR_P2 = DFM SPACE M1_width_lt_034_opp_edges M1_NOTCH_A_all >= 0.161 <= 0.174 BY ENC MEASURE ALL COUNT == 3 BY LAYER M1_NOTCH_A_all
 err1 = DFM PROPERTY M1_ERR_P1 M1_COLORA M1_COLORB M1_width_lt_034_opp_edges M1_oppo_space_s1_s3_edges INST M1_a_v_edges M1_b_v_edges OVERLAP ABUT ALSO MULTI
  [s = count(INST)] == 0
  [+= count(M1_width_lt_034_opp_edges)] > 0
  [p= (count(M1_oppo_space_s1_s3_edges) > 0 && (count(M1_a_v_edges) == 0 || count(M1_b_v_edges) == 0)) ? 1 : 0] > 0
  [-= (EC(M1_ERR_P1) > 0.117 && (count(M1_COLORA) > 1 || count(M1_COLORB) > 1 || count(M1_COLORA) == 0 || count(M1_COLORB) == 0)) ? 1 : 0 ] > 0
 err2 = DFM PROPERTY M1_ERR_P2 M1_COLORA M1_COLORB M1_width_lt_034_opp_edges M1_oppo_space_s1_s3_edges INST M1_a_v_edges M1_b_v_edges OVERLAP ABUT ALSO MULTI
  [s = count(INST)] == 0
  [+= count(M1_width_lt_034_opp_edges)] > 0
  [p= (count(M1_oppo_space_s1_s3_edges) > 0 && (count(M1_a_v_edges) == 0 || count(M1_b_v_edges) == 0)) ? 1 : 0] > 0
  [-= (EC(M1_ERR_P2) > 0.117 && (count(M1_COLORA) > 1 || count(M1_COLORB) > 1 || count(M1_COLORA) == 0 || count(M1_COLORB) == 0)) ? 1 : 0 ] > 0

 err3 = DFM PROPERTY M1_ERR_P1 M1_COLORA M1_COLORB M1_width_lt_034_opp_edges M1_oppo_space_s1_s3_edges DRC:1_NOT_INST M1_a_v_edges M1_b_v_edges OVERLAP ABUT ALSO MULTI
  [s = count(DRC:1_NOT_INST)] > 0
  [+= count(M1_width_lt_034_opp_edges)] > 0
  [p= (count(M1_oppo_space_s1_s3_edges) > 0 && (count(M1_a_v_edges) == 0 || count(M1_b_v_edges) == 0)) ? 1 : 0] > 0
  [-= (EC(M1_ERR_P1) > 0.117 && (count(M1_COLORA) > 1 || count(M1_COLORB) > 1 || count(M1_COLORA) == 0 || count(M1_COLORB) == 0)) ? 1 : 0 ] > 0
 err4 = DFM PROPERTY M1_ERR_P2 M1_COLORA M1_COLORB M1_width_lt_034_opp_edges M1_oppo_space_s1_s3_edges DRC:1_NOT_INST M1_a_v_edges M1_b_v_edges OVERLAP ABUT ALSO MULTI
  [s = count(DRC:1_NOT_INST)] > 0
  [+= count(M1_width_lt_034_opp_edges)] > 0
  [p= (count(M1_oppo_space_s1_s3_edges) > 0 && (count(M1_a_v_edges) == 0 || count(M1_b_v_edges) == 0)) ? 1 : 0] > 0
  [-= (EC(M1_ERR_P2) > 0.117 && (count(M1_COLORA) > 1 || count(M1_COLORB) > 1 || count(M1_COLORA) == 0 || count(M1_COLORB) == 0)) ? 1 : 0 ] > 0

 M1_NOTCH_B = EXT (M1_h_edges COIN EDGE M1_NOTCH) <= 0.174+GLOBAL_TOLERANCE-2*M1_MiniWidth ABUT<90 OPPOSITE PARA ONLY NOTCH REGION EXCLUDE SHIELDED
 M1_NOTCH_B_all = M1_h_edges OR EDGE (M1_NOTCH_B COIN EDGE M1_h_edges)
 M1_ERR_P3 = DFM SPACE M1_NOTCH_B_all M1_width_lt_034_opp_edges >= 0.161 <= 0.174 BY ENC MEASURE ALL COUNT == 3 BY LAYER M1_NOTCH_B_all
 M1_ERR_P4 = DFM SPACE M1_width_lt_034_opp_edges M1_NOTCH_B_all >= 0.161 <= 0.174 BY ENC MEASURE ALL COUNT == 3 BY LAYER M1_NOTCH_B_all
 err5 = DFM PROPERTY M1_ERR_P3 M1_COLORA M1_COLORB M1_width_lt_034_opp_edges M1_oppo_space_s1_s3_edges M1_a_h_edges M1_b_h_edges INST OVERLAP ABUT ALSO MULTI
  [s = count(INST)] == 0
  [+= count(M1_width_lt_034_opp_edges)] > 0
  [p= (count(M1_oppo_space_s1_s3_edges) > 0 && (count(M1_a_h_edges) == 0 || count(M1_b_h_edges) == 0)) ? 1 : 0] > 0
  [-= (EC(M1_ERR_P3) > 0.117 && (count(M1_COLORA) > 1 || count(M1_COLORB) > 1 || count(M1_COLORA) == 0 || count(M1_COLORB) == 0)) ? 1 : 0 ] > 0
 err6 = DFM PROPERTY M1_ERR_P4 M1_COLORA M1_COLORB M1_width_lt_034_opp_edges M1_oppo_space_s1_s3_edges INST M1_a_h_edges M1_b_h_edges OVERLAP ABUT ALSO MULTI
  [s = count(INST)] == 0
  [+= count(M1_width_lt_034_opp_edges)] > 0
  [p= (count(M1_oppo_space_s1_s3_edges) > 0 && (count(M1_a_h_edges) == 0 || count(M1_b_h_edges) == 0)) ? 1 : 0] > 0
  [-= (EC(M1_ERR_P4) > 0.117 && (count(M1_COLORA) > 1 || count(M1_COLORB) > 1 || count(M1_COLORA) == 0 || count(M1_COLORB) == 0)) ? 1 : 0 ] > 0

 err7 = DFM PROPERTY M1_ERR_P3 M1_COLORA M1_COLORB M1_width_lt_034_opp_edges M1_oppo_space_s1_s3_edges DRC:1_NOT_INST M1_a_h_edges M1_b_h_edges OVERLAP ABUT ALSO MULTI
  [s = count(DRC:1_NOT_INST)] > 0
  [+= count(M1_width_lt_034_opp_edges)] > 0
  [p= (count(M1_oppo_space_s1_s3_edges) > 0 && (count(M1_a_h_edges) == 0 || count(M1_b_h_edges) == 0)) ? 1 : 0] > 0
  [-= (EC(M1_ERR_P3) > 0.117 && (count(M1_COLORA) > 1 || count(M1_COLORB) > 1 || count(M1_COLORA) == 0 || count(M1_COLORB) == 0)) ? 1 : 0 ] > 0
 err8 = DFM PROPERTY M1_ERR_P4 M1_COLORA M1_COLORB M1_width_lt_034_opp_edges M1_oppo_space_s1_s3_edges DRC:1_NOT_INST M1_a_h_edges M1_b_h_edges OVERLAP ABUT ALSO MULTI
  [s = count(DRC:1_NOT_INST)] > 0
  [+= count(M1_width_lt_034_opp_edges)] > 0
  [p= (count(M1_oppo_space_s1_s3_edges) > 0 && (count(M1_a_h_edges) == 0 || count(M1_b_h_edges) == 0)) ? 1 : 0] > 0
  [-= (EC(M1_ERR_P4) > 0.117 && (count(M1_COLORA) > 1 || count(M1_COLORB) > 1 || count(M1_COLORA) == 0 || count(M1_COLORB) == 0)) ? 1 : 0 ] > 0
  DFM COPY err1 err2 err3 err4 err5 err6 err7 err8
}
#ENDIF
//; M1.S.21 ~ M1.S.34: delta voltage rule

 
M1_L_1 {
@ M1 branch length when M1 branch width >= 0.065um and <= 0.269um, and connected to M1 plate with both width and length >= 0.27um
@ DRC waive the branch that can enclose at least one (0.005um*design value) orthogonal rectangle >= 0.139um
 // based on M1.W.5
 dorian_large = M1 WITH WIDTH >= 0.27
 dorian_whole = M1 INTERACT dorian_large
 dorian_large_ep = SIZE dorian_large BY 0.005 INSIDE OF dorian_whole
 dorian_branch_1 = M1 WITH WIDTH >= 0.065 < 0.27
 dorian_branch_2 = dorian_branch_1 NOT OUTSIDE dorian_large_ep
 dorian_branch_3 = ENCLOSE RECTANGLE dorian_branch_2 0.005 0.139 ORTHOGONAL ONLY
 err1 = dorian_branch_2 NOT dorian_branch_3
 err1 NOT INSIDE SealR_NOT_BULK
}
 
M1_L_2 {
@ M1 branch length when M1 branch width >= 0.065um and <= 0.269um, and connected to M1 plate with both width and length >= 0.542um
@ DRC waive the branch that can enclose at least one (0.005um* design value) orthogonal rectangle >= 0.248um
 // based on M1.W.5
 dorian_large = M1 WITH WIDTH >= 0.542
 dorian_whole = M1 INTERACT dorian_large
 dorian_large_ep = SIZE dorian_large BY 0.005 INSIDE OF dorian_whole
 dorian_branch_1 = M1 WITH WIDTH >= 0.065 < 0.27
 dorian_branch_2 = dorian_branch_1 NOT OUTSIDE dorian_large_ep
 dorian_branch_3 = ENCLOSE RECTANGLE dorian_branch_2 0.005 0.248 ORTHOGONAL ONLY
 err1 = dorian_branch_2 NOT dorian_branch_3
 err1 NOT INSIDE SealR_NOT_BULK
}
 
M1_L_3 {
@ M1 branch length when M1 branch width >= 0.065um and <= 0.269um, and connected to M1 plate with both width and length >= 1um
@ DRC waive the branch that can enclose at least one (0.005um* design value) orthogonal rectangle >= 0.495um
 // based on M1.W.5
 dorian_large = M1 WITH WIDTH >= 1.00
 dorian_whole = M1 INTERACT dorian_large
 dorian_large_ep = SIZE dorian_large BY 0.005 INSIDE OF dorian_whole
 dorian_branch_1 = M1 WITH WIDTH >= 0.065 < 0.27
 dorian_branch_2 = dorian_branch_1 NOT OUTSIDE dorian_large_ep
 dorian_branch_3 = ENCLOSE RECTANGLE dorian_branch_2 0.005 0.495 ORTHOGONAL ONLY
 err1 = dorian_branch_2 NOT dorian_branch_3
 err1 NOT INSIDE SealR_NOT_BULK
}
 
M1_L_4 {
@ M1 edge length with adjacent edge < 0.032um
@ (these two edges formed by 3 consecutive 270-90-270 degree inner angles,
@ DRC don't flag if there is M1 within the area formed by 0.125um extension from these two edges and vertex >= 0.063um)
 L1 = CONVEX EDGE M1 ANGLE1 == 90 ANGLE2 == 270 WITH LENGTH < 0.032
 L2 = CONVEX EDGE M1 ANGLE1 == 90 ANGLE2 == 270 WITH LENGTH < 0.063
 L3_corner = INT L1 L2 < 0.005 ABUT==90 INTERSECTING ONLY REGION
 L1_c_edge = L1 TOUCH EDGE L3_corner
 L2_c_edge = L2 TOUCH EDGE L3_corner
 L1_c_s125 = EXPAND EDGE L1_c_edge OUTSIDE BY 0.125
 L2_c_s125 = EXPAND EDGE L2_c_edge OUTSIDE BY 0.125
 // 
 SQ_corner_raw = (EXT L1_c_s125 L2_c_s125 < 0.125 ABUT==90 INTERSECTING ONLY REGION EXTENTS) NOT INSIDE M1
 SQ_corner = (SQ_corner_raw NOT COIN EDGE L1_c_s125) NOT COIN EDGE L2_c_s125
 // 
 RM_step_1 = INT SQ_corner <= 0.586*0.125 ABUT==90 INTERSECTING ONLY REGION
 SQ_step_1 = SQ_corner_raw NOT RM_step_1
 RM_step_2 = INT SQ_step_1 <= 0.215*0.125 ABUT>134.8 <135.2 INTERSECTING ONLY REGION
 SQ_step_2 = SQ_step_1 NOT RM_step_2
 SQ_step_3 = (SQ_step_2 OR L1_c_s125) OR L2_c_s125
 SQ_real = SQ_step_3 NOT INTERACT (SQ_step_3 AND M1)
 err1_TMP = L3_corner TOUCH SQ_real
 err1 = EXPAND EDGE (M1 TOUCH EDGE err1_TMP) INSIDE BY 0.001
 err1 NOT INSIDE SealR_NOT_BULK
}

M1_end_L_5_6 = CONVEX EDGE M1 ANGLE1 == 90 ANGLE2 == 90 WITH LENGTH <= 0.051
M1_convex_90_270_lt_032 = CONVEX EDGE M1 ANGLE1 == 90 ANGLE2 == 270 WITH LENGTH < 0.032
M1_convex_90_270_lt_045 = CONVEX EDGE M1 ANGLE1 == 90 ANGLE2 == 270 WITH LENGTH < 0.045
M1_convex_90_270_lt_046 = CONVEX EDGE M1 ANGLE1 == 90 ANGLE2 == 270 WITH LENGTH < 0.046
M1_convex_90_270_lt_054 = CONVEX EDGE M1 ANGLE1 == 90 ANGLE2 == 270 WITH LENGTH < 0.054
M1_convex_90_270_lt_055 = CONVEX EDGE M1 ANGLE1 == 90 ANGLE2 == 270 WITH LENGTH < 0.055
M1_enclosure_V0_lt_040_V0_edge = ENC V0 [M1] < 0.04 ABUT<90 OPPOSITE

M1_L_5 {
@ M1 edge length with adjacent edge < 0.032um. >= 0.045um
@ These two edges are formed by 3 consecutive 90-270-90 degree inner angles
@ DRC flags the edge which meets all the below conditions:
@ 1. Another adjacent edge is line-end (width <= 0.051um, 90-90 inner angles)
@ 2. Enclosure of V0 by another adjacent edge < 0.04um
 errorArea_lt32_ltCHKvalue = EXT M1_convex_90_270_lt_032 M1_convex_90_270_lt_045 < 0.005 ABUT==90 INTERSECTING ONLY REGION
 condition_1 = M1_convex_90_270_lt_032 TOUCH EDGE errorArea_lt32_ltCHKvalue
 condition_2 = M1_convex_90_270_lt_045 TOUCH EDGE errorArea_lt32_ltCHKvalue
 condition_all = condition_1 OR EDGE condition_2
 enclosure_sid = (M1_end_L_5_6 TOUCH EDGE M1_enclosure_V0_lt_040_V0_edge) NOT TOUCH EDGE condition_all  //; enc side edge

 err1_TMP = INT condition_all enclosure_sid < 0.002 ABUT==90 INTERSECTING ONLY REGION
 err1 = condition_all TOUCH EDGE err1_TMP
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

M1_L_6 {
@ M1 edge length with adjacent edge < 0.032um
@ These two edges are formed by 3 consecutive 90-270-90 degree inner angles
@ DRC flags the edge which meets all the below conditions
@ 1. Another adjacent edge is line-end (width <= 0.051um, 90-90 inner angles)
@ 2. Enclosure of V0 by another adjacent edge < 0.04um
@ 3. There is no M1 within the area formed by adjacent edge < 0.032um expand edge 0.063um, extend 0.031um. >= 0.054um
 errorArea_lt32_ltCHKvalue = EXT M1_convex_90_270_lt_032 M1_convex_90_270_lt_054 < 0.005 ABUT==90 INTERSECTING ONLY REGION
 condition_1 = M1_convex_90_270_lt_032 TOUCH EDGE errorArea_lt32_ltCHKvalue
 condition_2 = M1_convex_90_270_lt_054 TOUCH EDGE errorArea_lt32_ltCHKvalue
 condition_all = condition_1 OR EDGE condition_2
 enclosure_sid = (M1_end_L_5_6 TOUCH EDGE M1_enclosure_V0_lt_040_V0_edge) NOT TOUCH EDGE condition_all  //; enc side edge

 y1 = INT condition_all enclosure_sid < 0.005 ABUT==90 INTERSECTING ONLY REGION
 y2 = condition_all TOUCH EDGE y1
 y3 = EXT y2 condition_all < 0.005 ABUT==90 INTERSECTING ONLY REGION
 y4 = (condition_all NOT TOUCH EDGE y2) TOUCH EDGE y3

 x1 = EXPAND EDGE y4 OUTSIDE BY 0.063
 x2 = EXPAND EDGE ((LENGTH x1 == 0.063) NOT TOUCH EDGE y2) OUTSIDE BY 0.031
 x3 = (x1 or x2) AND M1
 x4 = (x1 or x2) NOT ENCLOSE x3
 err1 = condition_all COIN EDGE x4
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

M1_L_7 {
@ Length of 45-degree bent M1, except MARKS region >= 0.445um
 err1 = LENGTH M1_45_skew_edges < 0.445
 err1 NOT INSIDE EDGE MARKS
}

M1_A_1 {
@ M1 area, except INST region >= 0.0061um2
 err1 = AREA M1 < 0.0061
 err1 NOT INSIDE INST
}

M1_A_2 {
@ M1 area (with all of edge lengths < 0.203um, any edge length >= 0.117um) >= 0.0072um2
@ Except:
@ 1) The pattern can fill 0.045um*0.117um rectangular pattern
@ 2) M1 edge of length >= 0.046um if this edge have another neighboring edge of length < 0.032um
@ 3) INST region
 M1_check = AREA M1 < 0.0072
 M1_check_a = LENGTH M1_check >= 0.046
 M1_check_b = LENGTH M1_check < 0.032
 M1_edge_any = LENGTH M1_check >= 0.117
 M1_edge_all = LENGTH M1_check >= 0.203

 M1_waive_1 = ENCLOSE RECTANGLE M1 0.045 0.117 ORTHOGONAL ONLY
 M1_waive_2 = M1_check INTERACT ((INT M1_check_a M1_check_b < 0.005 ABUT INTERSECTING ONLY REGION) OR (EXT M1_check_a M1_check_b < 0.005 ABUT INTERSECTING ONLY REGION))
 M1_waive = M1_waive_1 OR M1_waive_2
 err1 = ((M1_check WITH EDGE M1_edge_any) NOT WITH EDGE M1_edge_all) NOT M1_waive
 err1 NOT INSIDE INST
}

M1_A_3 {
@ M1 area when all of edge lengths < 0.081um, except a M1 filling 0.077um*0.077um rectangular pattern, except INST region >= 0.0176um2
 M1_waive = ENCLOSE RECTANGLE M1 0.077 0.077 ORTHOGONAL ONLY
 M1_check = AREA M1 < 0.0176
 M1_edge_all = LENGTH M1_check >= 0.081
 err1 = (M1_check NOT WITH EDGE M1_edge_all) NOT M1_waive
 err1 NOT INSIDE INST
}

M1_A_4 {
@ M1 enclosed area >= 0.16um2
 err1 = AREA ((HOLES M1 INNER) NOT M1) < 0.16
 err1 NOT INSIDE SealR_NOT_BULK
}

M1_all_NOT_MARKS = M1_all NOT MARKS
M1_all_in_ck_area = M1_all_NOT_MARKS AND CHIP_NOT_MARKS

#IFDEF IP_LEVEL_DENSITY_CHECK YES
#IFDEF MINIMUM_DENSITY_CHECK YES
VARIABLE M1_D_1_val 10.5
VARIABLE M1_D_1_window 125

M1_D_1 {
@ M1 density (window 125um*125um, stepping 125um/step_number) >= 10.5%
 check_region = COPY CHIP_NOT_MARKS
 check_pattern = M1_all AND check_region

 check_window1 = check_region WITH WIDTH >= M1_D_1_window/4
 err1_TMP1 = DENSITY check_pattern check_window1 check_region [!AREA(check_window1) + !!AREA(check_window1)*AREA(check_pattern)/AREA(check_region)] < M1_D_1_val/100 WINDOW M1_D_1_window STEP M1_D_1_window/step_number BACKUP INSIDE OF LAYER DRC:1 BY POLYGON

 check_window2 = WITH WIDTH (check_region AND err1_TMP1) >= M1_D_1_window/4
 err1_TMP2 = DENSITY check_pattern check_window2 check_region [!AREA(check_window2) + !!AREA(check_window2)*AREA(check_pattern)/AREA(check_region)] < M1_D_1_val/100 WINDOW M1_D_1_window STEP M1_D_1_window/step_number BACKUP INSIDE OF LAYER err1_TMP1 BY POLYGON

 check_window3 = WITH WIDTH (check_region AND err1_TMP2) >= M1_D_1_window/4
 DENSITY check_pattern check_window3 check_region [!AREA(check_window3) + !!AREA(check_window3)*AREA(check_pattern)/AREA(check_region)] < M1_D_1_val/100 WINDOW M1_D_1_window STEP M1_D_1_window/step_number BACKUP INSIDE OF LAYER err1_TMP2 BY POLYGON PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_M1_D_1.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_M1_D_1.rdb"
}
#ENDIF

VARIABLE M1_D_2_val 80.8
VARIABLE M1_D_2_window 125

M1_D_2 {
@ M1 maximum density (window 125um*125um, stepping 125um/step_number) <= 80.8%
 check_region = COPY CHIP_NOT_MARKS
 check_pattern = M1_all AND check_region

 check_window1 = check_region WITH WIDTH >= M1_D_2_window/4
 err1_TMP1 = DENSITY check_pattern check_window1 check_region [!!AREA(check_window1)*AREA(check_pattern)/AREA(check_region)] > M1_D_2_val/100 WINDOW M1_D_2_window STEP M1_D_2_window/step_number BACKUP INSIDE OF LAYER DRC:1 BY POLYGON

 check_window2 = WITH WIDTH (check_region AND err1_TMP1) >= M1_D_2_window/4
 err1_TMP2 = DENSITY check_pattern check_window2 check_region [!!AREA(check_window2)*AREA(check_pattern)/AREA(check_region)] > M1_D_2_val/100 WINDOW M1_D_2_window STEP M1_D_2_window/step_number BACKUP INSIDE OF LAYER err1_TMP1 BY POLYGON

 check_window3 = WITH WIDTH (check_region AND err1_TMP2) >= M1_D_2_window/4
 DENSITY check_pattern check_window3 check_region [!!AREA(check_window3)*AREA(check_pattern)/AREA(check_region)] > M1_D_2_val/100 WINDOW M1_D_2_window STEP M1_D_2_window/step_number BACKUP INSIDE OF LAYER err1_TMP2 BY POLYGON PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_M1_D_2.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_M1_D_2.rdb"
}

#IFDEF MINIMUM_DENSITY_CHECK YES
VARIABLE M1_D_3_less_than_15_val 15.8
VARIABLE M1_D_3_less_than_15_window 50
VARIABLE M1_D_3_between_15_25_val 26.3
VARIABLE M1_D_3_between_15_25_window 50

M1_D_3_less_than_15 {
@ M1 density (window 50um*50um, stepping 50um/step_number), except the window (15.8% <= metal density < 26.3%) not interact 3um*3um empty area, except OCOVL, (NODMF su 1um) region >= 26.3%
 check_region = CHIP_NOT_MARKS NOT (or OCOVL NODMF_SIZE_1)
 check_pattern = M1_all AND check_region

 check_window1 = check_region WITH WIDTH >= M1_D_3_less_than_15_window/4
 err1_TMP1 = DENSITY check_pattern check_window1 check_region [!AREA(check_window1) + !!AREA(check_window1)*AREA(check_pattern)/AREA(check_region)] < M1_D_3_less_than_15_val/100 WINDOW M1_D_3_less_than_15_window STEP M1_D_3_less_than_15_window/step_number BACKUP INSIDE OF LAYER DRC:1 BY POLYGON

 check_window2 = WITH WIDTH (check_region AND err1_TMP1) >= M1_D_3_less_than_15_window/4
 err1_TMP2 = DENSITY check_pattern check_window2 check_region [!AREA(check_window2) + !!AREA(check_window2)*AREA(check_pattern)/AREA(check_region)] < M1_D_3_less_than_15_val/100 WINDOW M1_D_3_less_than_15_window STEP M1_D_3_less_than_15_window/step_number BACKUP INSIDE OF LAYER err1_TMP1 BY POLYGON

 check_window3 = WITH WIDTH (check_region AND err1_TMP2) >= M1_D_3_less_than_15_window/4
 DENSITY check_pattern check_window3 check_region [!AREA(check_window3) + !!AREA(check_window3)*AREA(check_pattern)/AREA(check_region)] < M1_D_3_less_than_15_val/100 WINDOW M1_D_3_less_than_15_window STEP M1_D_3_less_than_15_window/step_number BACKUP INSIDE OF LAYER err1_TMP2 BY POLYGON PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_M1_D_3_less_than_15.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_M1_D_3_less_than_15.rdb"
}

M1_D_3_between_15_25 {
@ M1 density (window 50um*50um, stepping 50um/step_number), except the window (15.8% <= metal density < 26.3%) not interact 3um*3um empty area, except OCOVL, (NODMF su 1um) region >= 26.3%
 ck3x3_window = WITH WIDTH (check_region NOT M1_all) >= 3
 check_region = CHIP_NOT_MARKS NOT (or OCOVL NODMF_SIZE_1)
 check_pattern = M1_all AND check_region

 check_window1 = check_region WITH WIDTH >= M1_D_3_between_15_25_window/4
 err1_TMP1 = DENSITY check_pattern check_window1 check_region ck3x3_window [!AREA(ck3x3_window) + !AREA(check_window1) + !!AREA(ck3x3_window)*!!AREA(check_window1)*AREA(check_pattern)/AREA(check_region)] >= M1_D_3_less_than_15_val/100 < M1_D_3_between_15_25_val/100 WINDOW M1_D_3_between_15_25_window STEP M1_D_3_between_15_25_window/step_number BACKUP INSIDE OF LAYER DRC:1 BY POLYGON

 check_window2 = WITH WIDTH (check_region AND err1_TMP1) >= M1_D_3_between_15_25_window/4
 err1_TMP2 = DENSITY check_pattern check_window2 check_region ck3x3_window [!AREA(ck3x3_window) + !AREA(check_window2) + !!AREA(ck3x3_window)*!!AREA(check_window2)*AREA(check_pattern)/AREA(check_region)] >= M1_D_3_less_than_15_val/100 < M1_D_3_between_15_25_val/100 WINDOW M1_D_3_between_15_25_window STEP M1_D_3_between_15_25_window/step_number BACKUP INSIDE OF LAYER err1_TMP1 BY POLYGON

 check_window3 = WITH WIDTH (check_region AND err1_TMP2) >= M1_D_3_between_15_25_window/4
 DENSITY check_pattern check_window3 check_region ck3x3_window [!AREA(ck3x3_window) + !AREA(check_window3) + !!AREA(ck3x3_window)*!!AREA(check_window3)*AREA(check_pattern)/AREA(check_region)] >= M1_D_3_less_than_15_val/100 < M1_D_3_between_15_25_val/100 WINDOW M1_D_3_between_15_25_window STEP M1_D_3_between_15_25_window/step_number BACKUP INSIDE OF LAYER err1_TMP2 BY POLYGON PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_M1_D_3_between_15_25.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_M1_D_3_between_15_25.rdb"
}
#ENDIF

VARIABLE M1_D_4_val 65
VARIABLE M1_D_4_window 50

M1_D_4 {
@ M1 maximum density (window 50um*50um, stepping 25), except dummy metal <= 65%
 check_region = COPY CHIP_NOT_MARKS
 check_pattern = (M1 OR M1DP) AND check_region

 check_window1 = check_region WITH WIDTH >= M1_D_4_window/4
 err1_TMP1 = DENSITY check_pattern check_window1 check_region [!!AREA(check_window1)*AREA(check_pattern)/AREA(check_region)] > M1_D_4_val/100 WINDOW M1_D_4_window STEP M1_D_4_window/2 BACKUP INSIDE OF LAYER DRC:1 BY POLYGON

 check_window2 = WITH WIDTH (check_region AND err1_TMP1) >= M1_D_4_window/4
 err1_TMP2 = DENSITY check_pattern check_window2 check_region [!!AREA(check_window2)*AREA(check_pattern)/AREA(check_region)] > M1_D_4_val/100 WINDOW M1_D_4_window STEP M1_D_4_window/2 BACKUP INSIDE OF LAYER err1_TMP1 BY POLYGON

 check_window3 = WITH WIDTH (check_region AND err1_TMP2) >= M1_D_4_window/4
 DENSITY check_pattern check_window3 check_region [!!AREA(check_window3)*AREA(check_pattern)/AREA(check_region)] > M1_D_4_val/100 WINDOW M1_D_4_window STEP M1_D_4_window/2 BACKUP INSIDE OF LAYER err1_TMP2 BY POLYGON PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_M1_D_4.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_M1_D_4.rdb"
}

VARIABLE M1_D_5_val 71.3
VARIABLE M1_D_5_window 50

M1_D_5 {
@ M1 maximum density (window 50um*50um, stepping 50um/step_number) <= 71.3%
 check_region = COPY CHIP_NOT_MARKS
 check_pattern = M1_all AND check_region

 check_window1 = check_region WITH WIDTH >= M1_D_5_window/4
 err1_TMP1 = DENSITY check_pattern check_window1 check_region [!!AREA(check_window1)*AREA(check_pattern)/AREA(check_region)] > M1_D_5_val/100 WINDOW M1_D_5_window STEP M1_D_5_window/step_number BACKUP INSIDE OF LAYER DRC:1 BY POLYGON

 check_window2 = WITH WIDTH (check_region AND err1_TMP1) >= M1_D_5_window/4
 err1_TMP2 = DENSITY check_pattern check_window2 check_region [!!AREA(check_window2)*AREA(check_pattern)/AREA(check_region)] > M1_D_5_val/100 WINDOW M1_D_5_window STEP M1_D_5_window/step_number BACKUP INSIDE OF LAYER err1_TMP1 BY POLYGON

 check_window3 = WITH WIDTH (check_region AND err1_TMP2) >= M1_D_5_window/4
 DENSITY check_pattern check_window3 check_region [!!AREA(check_window3)*AREA(check_pattern)/AREA(check_region)] > M1_D_5_val/100 WINDOW M1_D_5_window STEP M1_D_5_window/step_number BACKUP INSIDE OF LAYER err1_TMP2 BY POLYGON PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_M1_D_5.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_M1_D_5.rdb"
}

M1_D_6 {
@ M1 density difference between any two neighboring checking windows (window 180um*180um, stepping 360um/step_number) <= 38%
 DENSITY M1_all_NOT_MARKS CHIP_NOT_MARKS [AREA(M1_all_NOT_MARKS)/AREA(CHIP_NOT_MARKS)] >= 0 WINDOW 180 STEP 360/step_number GRADIENT > 0.38 ABSOLUTE BACKUP PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_M1_D_6.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_M1_D_6.rdb"
}

VARIABLE M1_D_7_val 28.5
VARIABLE M1_D_7_window 72

M1_D_7 {
@ M1 maximum density ratio of ((M1 or dummy M1) INTERACT M1DPMK) to (M1 or dummy M1) (window 72um*72um, stepping 72um/step_number) <= 28.5%
 check_pattern = ((M1_all INTERACT M1DPMK) NOT MARKS) AND M1_all_NOT_MARKS
 DENSITY check_pattern M1_all_NOT_MARKS [AREA(check_pattern)/AREA(M1_all_NOT_MARKS)] > M1_D_7_val/100 WINDOW M1_D_7_window STEP M1_D_7_window/step_number BACKUP INSIDE OF LAYER DRC:1 BY POLYGON PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_M1_D_7.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_M1_D_7.rdb"
}
#ENDIF


#IFDEF IP_LEVEL_DENSITY_CHECK NO
#IFDEF MINIMUM_DENSITY_CHECK YES
VARIABLE M1_D_1_val 10
VARIABLE M1_D_1_window 125

M1_D_1 {
@ M1 density (window 125um*125um, stepping 62.5um) >= 10%
 check_region = COPY CHIP_NOT_MARKS
 check_pattern = M1_all AND check_region

 check_window1 = check_region WITH WIDTH >= M1_D_1_window/4
 err1_TMP1 = DENSITY check_pattern check_window1 check_region [!AREA(check_window1) + !!AREA(check_window1)*AREA(check_pattern)/AREA(check_region)] < M1_D_1_val/100 WINDOW M1_D_1_window STEP M1_D_1_window/2 BACKUP INSIDE OF LAYER DRC:1 BY POLYGON

 check_window2 = WITH WIDTH (check_region AND err1_TMP1) >= M1_D_1_window/4
 err1_TMP2 = DENSITY check_pattern check_window2 check_region [!AREA(check_window2) + !!AREA(check_window2)*AREA(check_pattern)/AREA(check_region)] < M1_D_1_val/100 WINDOW M1_D_1_window STEP M1_D_1_window/2 BACKUP INSIDE OF LAYER err1_TMP1 BY POLYGON

 check_window3 = WITH WIDTH (check_region AND err1_TMP2) >= M1_D_1_window/4
 DENSITY check_pattern check_window3 check_region [!AREA(check_window3) + !!AREA(check_window3)*AREA(check_pattern)/AREA(check_region)] < M1_D_1_val/100 WINDOW M1_D_1_window STEP M1_D_1_window/2 BACKUP INSIDE OF LAYER err1_TMP2 BY POLYGON PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_M1_D_1.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_M1_D_1.rdb"
}
#ENDIF

VARIABLE M1_D_2_val 85
VARIABLE M1_D_2_window 125

M1_D_2 {
@ M1 maximum density (window 125um*125um, stepping 62.5um) <= 85%
 check_region = COPY CHIP_NOT_MARKS
 check_pattern = M1_all AND check_region

 check_window1 = check_region WITH WIDTH >= M1_D_2_window/4
 err1_TMP1 = DENSITY check_pattern check_window1 check_region [!!AREA(check_window1)*AREA(check_pattern)/AREA(check_region)] > M1_D_2_val/100 WINDOW M1_D_2_window STEP M1_D_2_window/2 BACKUP INSIDE OF LAYER DRC:1 BY POLYGON

 check_window2 = WITH WIDTH (check_region AND err1_TMP1) >= M1_D_2_window/4
 err1_TMP2 = DENSITY check_pattern check_window2 check_region [!!AREA(check_window2)*AREA(check_pattern)/AREA(check_region)] > M1_D_2_val/100 WINDOW M1_D_2_window STEP M1_D_2_window/2 BACKUP INSIDE OF LAYER err1_TMP1 BY POLYGON

 check_window3 = WITH WIDTH (check_region AND err1_TMP2) >= M1_D_2_window/4
 DENSITY check_pattern check_window3 check_region [!!AREA(check_window3)*AREA(check_pattern)/AREA(check_region)] > M1_D_2_val/100 WINDOW M1_D_2_window STEP M1_D_2_window/2 BACKUP INSIDE OF LAYER err1_TMP2 BY POLYGON PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_M1_D_2.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_M1_D_2.rdb"
}

#IFDEF MINIMUM_DENSITY_CHECK YES
VARIABLE M1_D_3_less_than_15_val 15
VARIABLE M1_D_3_less_than_15_window 50
VARIABLE M1_D_3_between_15_25_val 25
VARIABLE M1_D_3_between_15_25_window 50

M1_D_3_less_than_15 {
@ M1 density (window 50um*50um, stepping 25um), except the window (15% <= metal density < 25%) not interact 3um*3um empty area, except OCOVL, (NODMF su 1um) region >= 25%
 check_region = CHIP_NOT_MARKS NOT (or OCOVL NODMF_SIZE_1)
 check_pattern = M1_all AND check_region

 check_window1 = check_region WITH WIDTH >= M1_D_3_less_than_15_window/4
 err1_TMP1 = DENSITY check_pattern check_window1 check_region [!AREA(check_window1) + !!AREA(check_window1)*AREA(check_pattern)/AREA(check_region)] < M1_D_3_less_than_15_val/100 WINDOW M1_D_3_less_than_15_window STEP M1_D_3_less_than_15_window/2 BACKUP INSIDE OF LAYER DRC:1 BY POLYGON

 check_window2 = WITH WIDTH (check_region AND err1_TMP1) >= M1_D_3_less_than_15_window/4
 err1_TMP2 = DENSITY check_pattern check_window2 check_region [!AREA(check_window2) + !!AREA(check_window2)*AREA(check_pattern)/AREA(check_region)] < M1_D_3_less_than_15_val/100 WINDOW M1_D_3_less_than_15_window STEP M1_D_3_less_than_15_window/2 BACKUP INSIDE OF LAYER err1_TMP1 BY POLYGON

 check_window3 = WITH WIDTH (check_region AND err1_TMP2) >= M1_D_3_less_than_15_window/4
 DENSITY check_pattern check_window3 check_region [!AREA(check_window3) + !!AREA(check_window3)*AREA(check_pattern)/AREA(check_region)] < M1_D_3_less_than_15_val/100 WINDOW M1_D_3_less_than_15_window STEP M1_D_3_less_than_15_window/2 BACKUP INSIDE OF LAYER err1_TMP2 BY POLYGON PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_M1_D_3_less_than_15.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_M1_D_3_less_than_15.rdb"
}

M1_D_3_between_15_25 {
@ M1 density (window 50um*50um, stepping 25um), except the window (15% <= metal density < 25%) not interact 3um*3um empty area, except OCOVL, (NODMF su 1um) region >= 25%
 ck3x3_window = WITH WIDTH (check_region NOT M1_all) >= 3
 check_region = CHIP_NOT_MARKS NOT (or OCOVL NODMF_SIZE_1)
 check_pattern = M1_all AND check_region

 check_window1 = check_region WITH WIDTH >= M1_D_3_between_15_25_window/4
 err1_TMP1 = DENSITY check_pattern check_window1 check_region ck3x3_window [!AREA(ck3x3_window) + !AREA(check_window1) + !!AREA(ck3x3_window)*!!AREA(check_window1)*AREA(check_pattern)/AREA(check_region)] >= M1_D_3_less_than_15_val/100 < M1_D_3_between_15_25_val/100 WINDOW M1_D_3_between_15_25_window STEP M1_D_3_between_15_25_window/2 BACKUP INSIDE OF LAYER DRC:1 BY POLYGON

 check_window2 = WITH WIDTH (check_region AND err1_TMP1) >= M1_D_3_between_15_25_window/4
 err1_TMP2 = DENSITY check_pattern check_window2 check_region ck3x3_window [!AREA(ck3x3_window) + !AREA(check_window2) + !!AREA(ck3x3_window)*!!AREA(check_window2)*AREA(check_pattern)/AREA(check_region)] >= M1_D_3_less_than_15_val/100 < M1_D_3_between_15_25_val/100 WINDOW M1_D_3_between_15_25_window STEP M1_D_3_between_15_25_window/2 BACKUP INSIDE OF LAYER err1_TMP1 BY POLYGON

 check_window3 = WITH WIDTH (check_region AND err1_TMP2) >= M1_D_3_between_15_25_window/4
 DENSITY check_pattern check_window3 check_region ck3x3_window [!AREA(ck3x3_window) + !AREA(check_window3) + !!AREA(ck3x3_window)*!!AREA(check_window3)*AREA(check_pattern)/AREA(check_region)] >= M1_D_3_less_than_15_val/100 < M1_D_3_between_15_25_val/100 WINDOW M1_D_3_between_15_25_window STEP M1_D_3_between_15_25_window/2 BACKUP INSIDE OF LAYER err1_TMP2 BY POLYGON PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_M1_D_3_between_15_25.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_M1_D_3_between_15_25.rdb"
}
#ENDIF

VARIABLE M1_D_4_val 65
VARIABLE M1_D_4_window 50

M1_D_4 {
@ M1 maximum density (window 50um*50um, stepping 25um), except dummy metal <= 65%
 check_region = COPY CHIP_NOT_MARKS
 check_pattern = (M1 OR M1DP) AND check_region

 check_window1 = check_region WITH WIDTH >= M1_D_4_window/4
 err1_TMP1 = DENSITY check_pattern check_window1 check_region [!!AREA(check_window1)*AREA(check_pattern)/AREA(check_region)] > M1_D_4_val/100 WINDOW M1_D_4_window STEP M1_D_4_window/2 BACKUP INSIDE OF LAYER DRC:1 BY POLYGON

 check_window2 = WITH WIDTH (check_region AND err1_TMP1) >= M1_D_4_window/4
 err1_TMP2 = DENSITY check_pattern check_window2 check_region [!!AREA(check_window2)*AREA(check_pattern)/AREA(check_region)] > M1_D_4_val/100 WINDOW M1_D_4_window STEP M1_D_4_window/2 BACKUP INSIDE OF LAYER err1_TMP1 BY POLYGON

 check_window3 = WITH WIDTH (check_region AND err1_TMP2) >= M1_D_4_window/4
 DENSITY check_pattern check_window3 check_region [!!AREA(check_window3)*AREA(check_pattern)/AREA(check_region)] > M1_D_4_val/100 WINDOW M1_D_4_window STEP M1_D_4_window/2 BACKUP INSIDE OF LAYER err1_TMP2 BY POLYGON PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_M1_D_4.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_M1_D_4.rdb"
}

VARIABLE M1_D_5_val 75
VARIABLE M1_D_5_window 50

M1_D_5 {
@ M1 maximum density (window 50um*50um, stepping 25um) <= 75%
 check_region = COPY CHIP_NOT_MARKS
 check_pattern = M1_all AND check_region

 check_window1 = check_region WITH WIDTH >= M1_D_5_window/4
 err1_TMP1 = DENSITY check_pattern check_window1 check_region [!!AREA(check_window1)*AREA(check_pattern)/AREA(check_region)] > M1_D_5_val/100 WINDOW M1_D_5_window STEP M1_D_5_window/2 BACKUP INSIDE OF LAYER DRC:1 BY POLYGON

 check_window2 = WITH WIDTH (check_region AND err1_TMP1) >= M1_D_5_window/4
 err1_TMP2 = DENSITY check_pattern check_window2 check_region [!!AREA(check_window2)*AREA(check_pattern)/AREA(check_region)] > M1_D_5_val/100 WINDOW M1_D_5_window STEP M1_D_5_window/2 BACKUP INSIDE OF LAYER err1_TMP1 BY POLYGON

 check_window3 = WITH WIDTH (check_region AND err1_TMP2) >= M1_D_5_window/4
 DENSITY check_pattern check_window3 check_region [!!AREA(check_window3)*AREA(check_pattern)/AREA(check_region)] > M1_D_5_val/100 WINDOW M1_D_5_window STEP M1_D_5_window/2 BACKUP INSIDE OF LAYER err1_TMP2 BY POLYGON PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_M1_D_5.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_M1_D_5.rdb"
}

M1_D_6 {
@ M1 density difference between any two neighboring checking windows (window 180um*180um, stepping 180um) <= 40%
 DENSITY M1_all_NOT_MARKS CHIP_NOT_MARKS [AREA(M1_all_NOT_MARKS)/AREA(CHIP_NOT_MARKS)] >= 0 WINDOW 180 STEP 180 GRADIENT > 0.4 ABSOLUTE BACKUP PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_M1_D_6.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_M1_D_6.rdb"
}

VARIABLE M1_D_7_val 30
VARIABLE M1_D_7_window 72

M1_D_7 {
@ M1 maximum density ratio of ((M1 or dummy M1) INTERACT M1DPMK) to (M1 or dummy M1) (window 72um*72um, stepping 36um) <= 30%
 check_pattern = ((M1_all INTERACT M1DPMK) NOT MARKS) AND M1_all_NOT_MARKS
 DENSITY check_pattern M1_all_NOT_MARKS [AREA(check_pattern)/AREA(M1_all_NOT_MARKS)] > M1_D_7_val/100 WINDOW M1_D_7_window STEP M1_D_7_window/2 BACKUP INSIDE OF LAYER DRC:1 BY POLYGON PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_M1_D_7.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_M1_D_7.rdb"
}
#ENDIF


#IFDEF METAL_DECOMPOSITION_RESULT YES
M1_D_8 {
@ M1 maximum density difference of ABS (((M1 OR M1DUM OR M1DOP) – (M1DP OR M1DPDUM OR M1DPDOP))/((M1 OR M1DUM OR M1DOP) + (M1DP OR M1DPDUM OR M1DPDOP))) <= 11%
@ This rule is applied post M1 layout decomposition
 FM_all = (M1 OR M1DUM) OR M1DOP
 GM_all = (M1DP OR M1DPDUM) OR M1DPDOP
 FM_chk = FM_all NOT MARKS
 GM_chk = GM_all NOT MARKS
 err1 = DENSITY FM_chk GM_chk [AREA(FM_chk) - AREA(GM_chk) -0.11*(AREA(FM_chk) + AREA(GM_chk))] > 0 PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_M1_D_8_1.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_M1_D_8_1.rdb"
 err2 = DENSITY FM_chk GM_chk [AREA(GM_chk) - AREA(FM_chk) -0.11*(AREA(FM_chk) + AREA(GM_chk))] > 0 PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_M1_D_8_2.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_M1_D_8_2.rdb"
 err1 OR err2
}
#ENDIF

#IFDEF MINIMUM_DENSITY_CHECK YES
/*
M1_D_9_great_than_6000 {
@ Maximum M1 area of merged low density windows must follow item (1) and (2)
@ The definition of low density window: window size 10um*10um, step size: 5um, density < 1%
@ (1) Maximum area of merged low density window <= 6000um2, except merged low density windows width <= 30um
@ (2) Maximum area of merged low density window <= 16000um2
@ DRC don't check:
@ Chip corner triangle region (NODMF) sizing up 0.4um if seal ring is added by SMIC
@ DRC only check the region with width of (checking window NOT above excluding region) >= 5um. >= 1%
 except_area = OR NODMF_SIZE_0.4 LDNMK1 MARKS
 check_region = (DRC:1 NOT except_area) WITH WIDTH >= 5
 check_pattern = (M1_all NOT except_area) AND check_region
 merged_window_all = DENSITY check_pattern check_region [AREA(check_pattern)/AREA(check_region)] < 0.01 WINDOW 10 STEP 5 BACKUP INSIDE OF LAYER DRC:1 BY POLYGON PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_M1_D_9_great_than_6000.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_M1_D_9_great_than_6000.rdb"
 AREA (merged_window_all WITH WIDTH > 30) > 6000
}

M1_D_9_great_than_16000 {
@ Maximum M1 area of merged low density windows must follow item (1) and (2)
@ The definition of low density window: window size 10um*10um, step size: 5um, density < 1%
@ (1) Maximum area of merged low density window <= 6000um2, except merged low density windows width <= 30um
@ (2) Maximum area of merged low density window <= 16000um2
@ DRC don't check:
@ Chip corner triangle region (NODMF) sizing up 0.4um if seal ring is added by SMIC
@ DRC only check the region with width of (checking window NOT above excluding region) >= 5um. >= 1%
 except_area = OR NODMF_SIZE_0.4 LDNMK1 MARKS
 check_region = (DRC:1 NOT except_area) WITH WIDTH >= 5
 check_pattern = (M1_all NOT except_area) AND check_region
 merged_window_all = DENSITY check_pattern check_region [AREA(check_pattern)/AREA(check_region)] < 0.01 WINDOW 10 STEP 5 BACKUP INSIDE OF LAYER DRC:1 BY POLYGON PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_M1_D_9_great_than_16000.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_M1_D_9_great_than_16000.rdb"
 AREA (merged_window_all WITH WIDTH >= 5) > 16000
}
*/
#ENDIF

//;M1_R_1 {
//;@ M1 overlap MTFUSE is not allowed
//; err1 = M1 AND MTFUSE
//; err1 NOT INSIDE SealR_NOT_BULK
//;}

M1_R_4 {
@ U-shape M1 pitch (W+S1) or (W+S2) must be >= 0.072um and V1 enclosure by M1 line-end (E) must be >= 0.032um,
@ When:
@ (1) Both PRL1 and PRL2 >= -0.015um
@ (2) Space (S) < 0.05um along length direction
@ (3) W < 0.04um
@ DRC waive if S1 or S2 > 0.04um
@ This rule is not applied for INST region
 end_enc = M1_end_0.040 NOT TOUCH EDGE (ENC V1 [M1_end_0.040] < 0.032 ABUT<90 OPPOSITE)
 end_sps = end_enc TOUCH EDGE (EXT [end_enc] M1_convex_270_270_edges < 0.05 ABUT<90 OPPOSITE)
 end_epd = EXPAND EDGE end_sps OUTSIDE BY 0.016
 end_sid = LENGTH (end_epd NOT TOUCH EDGE M1) == 0.016
 end_wid = INT end_sid < 0.040 ABUT<90 OPPOSITE
 end_sds = EXT end_sid M1 < 0.04 ABUT<90 OPPOSITE
 err1 = DFM PROPERTY end_epd end_wid end_sds OVERLAP ABUT ALSO MULTI [+= (count(end_wid) > 0 && count(end_sds) > 0) ? 1 : 0] > 0 [-= min(ew(end_wid)) + min(ew(end_sds))] < 0.072
 err1 NOT INSIDE INST
}

M1_R_5 {
@ U-shape M1 pitch (W+S1) or (W+S2) must be >= 0.072um
@ When:
@ (1) Both PRL1 and PRL2 >= -0.015um
@ (2) Space (S) < 0.05um along length direction
@ (3) W < 0.04um
@ (4) M1 interact V0 and enclosure E < 0.032um
@ DRC waive if S1 or S2 > 0.04um
@ This rule is not applied for INST region
 end_enc = M1_end_0.040 TOUCH EDGE (ENC V0 [M1_end_0.040] < 0.032 ABUT<90 OPPOSITE)
 end_sps = end_enc TOUCH EDGE (EXT [end_enc] M1_convex_270_270_edges < 0.05 ABUT<90 OPPOSITE)
 end_epd = EXPAND EDGE end_sps OUTSIDE BY 0.016
 end_sid = LENGTH (end_epd NOT TOUCH EDGE M1) == 0.016
 end_wid = INT end_sid < 0.040 ABUT<90 OPPOSITE
 end_sds = EXT end_sid M1 < 0.04 ABUT<90 OPPOSITE
 err1 = DFM PROPERTY end_epd end_wid end_sds OVERLAP ABUT ALSO MULTI [+= (count(end_wid) > 0 && count(end_sds) > 0) ? 1 : 0] > 0 [-= min(ew(end_wid)) + min(ew(end_sds))] < 0.072
 err1 NOT INSIDE INST
}

M1_RSP_1_2a_2b_met = ENCLOSE RECTANGLE (M1 INTERACT (M1 WITH WIDTH > 0.09)) 0.091 0.271 ORTHOGONAL ONLY
M1_RSP_1_2a_2b_wid = INT (M1_RSP_1_2a_2b_met) <= 0.09 OPPOSITE EXCLUDE SHIELDED
M1_RSP_1_2a_2b_wan = LENGTH (M1_convex_270_90_edges COIN EDGE M1_RSP_1_2a_2b_met) < 0.108 - 0.032
M1_RSP_1_2a_2b_sps = M1_RSP_1_2a_2b_met COIN EDGE (EXT M1_RSP_1_2a_2b_met M1 < 0.108 OPPOSITE REGION EXCLUDE SHIELDED)
// 
M1_RSP_1_2a_2b_sps_sides_A = (M1_RSP_1_2a_2b_wid COIN EDGE M1_RSP_1_2a_2b_sps) NOT COIN EDGE (LENGTH (M1_RSP_1_2a_2b_wid NOT TOUCH EDGE 
(INT [M1_RSP_1_2a_2b_wid] M1_RSP_1_2a_2b_wan < 0.001 ABUT==90 INTERSECTING ONLY)) <= 0.27)
M1_RSP_1_2a_2b_sps_sides_B = (M1_RSP_1_2a_2b_wid COIN EDGE M1_RSP_1_2a_2b_sps) NOT COIN EDGE (LENGTH (M1_RSP_1_2a_2b_wid NOT TOUCH EDGE 
(EXT [M1_RSP_1_2a_2b_wid] M1_RSP_1_2a_2b_wan < 0.001 ABUT==90 INTERSECTING ONLY)) <= 0.27)
M1_RSP_1_2a_2b_sps_sides = M1_RSP_1_2a_2b_sps_sides_A OR EDGE M1_RSP_1_2a_2b_sps_sides_B
M1_RSP_1_2a_2b_sps_sides_PRL = M1_RSP_1_2a_2b_sps_sides COIN EDGE (PATH LENGTH (M1_RSP_1_2a_2b_wan OR EDGE M1_RSP_1_2a_2b_sps_sides) > 0.27)
// 
M1_RSP_1_2a_2b_S1_side = EXT M1 M1_RSP_1_2a_2b_sps_sides_PRL < 0.108 OPPOSITE EXCLUDE SHIELDED
M1_RSP_1_2a_2b_S1_area = EXT M1 M1_RSP_1_2a_2b_sps_sides_PRL < 0.108 OPPOSITE EXCLUDE SHIELDED REGION
M1_RSP_1_2a_2b_S1_rlen = M1_RSP_1_2a_2b_S1_area ENCLOSE RECTANGLE 0.001 0.271 ORTHOGONAL ONLY
M1_RSP_1_2a_2b_L1_side = M1 COIN EDGE ((DFM COPY M1_RSP_1_2a_2b_S1_side EDGE) COIN EDGE M1_RSP_1_2a_2b_S1_rlen)
M1_RSP_1_2a_2b_L1_side_jog_sum = M1_RSP_1_2a_2b_wan OR EDGE M1_RSP_1_2a_2b_L1_side
M1_RSP_1_2a_2b_L1_side_jog_sum_EXP = EXPAND EDGE M1_RSP_1_2a_2b_L1_side_jog_sum INSIDE BY 0.001 CORNER FILL
// 
M1_RSP_1_2a_2b_Q1 = EXPAND EDGE (M1_RSP_1_2a_2b_L1_side COIN EDGE M1_RSP_1_2a_2b_L1_side_jog_sum) INSIDE BY 0.001
M1_RSP_1_2a_2b_Q2 = M1_RSP_1_2a_2b_L1_side_jog_sum_EXP INTERACT (AREA M1_RSP_1_2a_2b_Q1 > 0.27 * 0.001)
M1_RSP_1_2a_2b_Q3 = M1_RSP_1_2a_2b_L1_side_jog_sum TOUCH EDGE (LENGTH (M1_RSP_1_2a_2b_Q1 INTERACT M1_RSP_1_2a_2b_Q2) > 0.001)
// 
M1_RSP_1_2a_2b_y1 = DFM COPY (EXT M1 M1_RSP_1_2a_2b_Q3 < 0.108 OPPOSITE EXCLUDE SHIELDED) EDGE
M1_RSP_1_2a_2b_y2 = DFM COPY (EXT M1 M1_RSP_1_2a_2b_Q3 < 0.108 OPPOSITE EXCLUDE SHIELDED) REGION
M1_RSP_1_2a_2b_y3 = M1_RSP_1_2a_2b_y1 TOUCH EDGE (INT M1 [M1_RSP_1_2a_2b_y1] <= 0.001 ABUT==90 INTERSECTING ONLY MEASURE ALL)
M1_RSP_1_2a_2b_y4 = EXT M1_RSP_1_2a_2b_y3 M1_RSP_1_2a_2b_y1 < 0.072 OPPOSITE PROJ <= 0.078 REGION
M1_RSP_1_2a_2b_y5 = EXT M1_RSP_1_2a_2b_y3 M1_RSP_1_2a_2b_y1 < 0.072 OPPOSITE PROJ <= 0.078
M1_RSP_1_2a_2b_y6 = RECTANGLE (DFM PROPERTY M1_RSP_1_2a_2b_y4 M1_RSP_1_2a_2b_y5 OVERLAP ABUT ALSO MULTI [-= EC(M1_RSP_1_2a_2b_y5)] <= 0.078)
// 
M1_RSP_1_2a_2b_y2_c = OR M1EMPTY9696 M1_RSP_1_2a_2b_y2
M1_RSP_1_2a_2b_y6_c = OR M1EMPTY9696 M1_RSP_1_2a_2b_y6
CONNECT M1_RSP_1_2a_2b_y2_c M1_RSP_1_2a_2b_y6_c
// 
M1_RSP_1_2a_2b_ERR1_CHK = EXT M1_RSP_1_2a_2b_y1 >= 0.072 < 0.108 OPPOSITE REGION EXCLUDE SHIELDED
M1_RSP_1_2a_2b_ERR1_TMP = EXT ((M1_RSP_1_2a_2b_y6_c NOT COIN EDGE M1) COIN EDGE M1_RSP_1_2a_2b_ERR1_CHK) < 0.298 CONNECTED REGION
M1_RSP_1_2a_2b_ERR1 = M1_RSP_1_2a_2b_ERR1_TMP OR (M1_RSP_1_2a_2b_y6 INTERACT (COPY M1_RSP_1_2a_2b_y6) >= 3 SINGULAR ALSO)
// 
M1_RSP_1_2a_2b_CA = EXT M1_RSP_1_2a_2b_y3 M1_RSP_1_2a_2b_y1 < 0.041 OPPOSITE REGION
M1_RSP_1_2a_2b_CA_side = M1_RSP_1_2a_2b_CA NOT COIN EDGE M1
M1_RSP_1_2a_2b_CA_area = INT M1_RSP_1_2a_2b_CA_side M1_RSP_1_2a_2b_CA <= 0.078 REGION
// 
M1_RSP_1_2a_2b_ERR2_CHK = M1_RSP_1_2a_2b_CA_side NOT TOUCH EDGE M1_RSP_1_2a_2b_CA_area
M1_RSP_1_2a_2b_ERR2_TMP = (NOT RECTANGLE M1_RSP_1_2a_2b_y2) OR ((RECTANGLE M1_RSP_1_2a_2b_y2) ENCLOSE RECTANGLE 0.001 0.269)
M1_RSP_1_2a_2b_ERR2 = (M1_RSP_1_2a_2b_CA WITH EDGE M1_RSP_1_2a_2b_ERR2_CHK) INSIDE M1_RSP_1_2a_2b_ERR2_TMP
// 
M1_RSP_1_2a_2b_CB = EXT M1_RSP_1_2a_2b_y3 M1_RSP_1_2a_2b_y1 < 0.032 OPPOSITE REGION
M1_RSP_1_2a_2b_CB_side = M1_RSP_1_2a_2b_CB NOT COIN EDGE M1
M1_RSP_1_2a_2b_CB_area = INT M1_RSP_1_2a_2b_CB_side <= 0.078 REGION
// 
M1_RSP_1_2a_2b_ERR3_CHK = M1_RSP_1_2a_2b_CB_side TOUCH EDGE M1_RSP_1_2a_2b_CB_area
M1_RSP_1_2a_2b_ERR3_TMP = (NOT RECTANGLE M1_RSP_1_2a_2b_y2) OR ((RECTANGLE M1_RSP_1_2a_2b_y2) ENCLOSE RECTANGLE 0.001 0.269)
M1_RSP_1_2a_2b_ERR3 = (M1_RSP_1_2a_2b_CB WITH EDGE M1_RSP_1_2a_2b_ERR3_CHK) INSIDE M1_RSP_1_2a_2b_ERR3_TMP
 
M1_RSP_1 {
@ Space between metal space segments with S2 < 0.072 and L2 <= 0.078um
@ Metal space segments definition:
@ 1) At least one metal line width > 0.09um (W1) and the parallel run length > 0.27um (L1) in metal space < 0.108um (S1) region
@ 2) Metal space segments within metal space (S1) region and are generated by space cut line which is perpendicular with L1 direction formed by all vertex in metal space region (S1)
@ 3) Metal space segments at least abut one metal with width > 0.09um (W1)
@ 4) L2 is the width of metal space segments which is parallel with L1 direction
@ 5) S2 is the width of metal space segments which is perpendicular with L1 direction. >= 0.298um
 M1_RSP_1_2a_2b_ERR1 NOT INSIDE SealR_NOT_BULK
}
 
M1_RSP_2a {
@ Width (S2) of metal space segments with L2 > 0.078um (0.058um <= S < 0.072um is forbidden)
@ Metal space segments definition:
@ 1) At least one metal line width > 0.09um (W1) and the parallel run length > 0.27um (L1) in metal space < 0.108um (S1) region
@ 2) Metal space segments within metal space (S1) region and are generated by space cut line which is perpendicular with L1 direction formed by all vertex in metal space region (S1)
@ 3) Metal space segments at least abut one metal with width > 0.09um (W1)
@ 4) L2 is the width of metal space segments which is parallel with L1 direction
@ 5) S2 is the width of metal space segments which is perpendicular with L1 direction. >= 0.041um
 M1_RSP_1_2a_2b_ERR2 NOT INSIDE SealR_NOT_BULK
 // 
 forbidden_RSP_1_2a_2b_A1 = EXT M1_RSP_1_2a_2b_Y3 M1_RSP_1_2a_2b_Y1 >= 0.058 < 0.072 OPPOSITE REGION
 forbidden_RSP_1_2a_2b_A1_edge = forbidden_RSP_1_2a_2b_A1 NOT COIN EDGE M1
 forbidden_RSP_1_2a_2b_A1_area = INT forbidden_RSP_1_2a_2b_A1_edge forbidden_RSP_1_2a_2b_A1 <= 0.078 REGION
 forbidden_RSP_1_2a_2b_A1_1 = forbidden_RSP_1_2a_2b_A1_edge NOT TOUCH EDGE forbidden_RSP_1_2a_2b_A1_area
 forbidden_RSP_1_2a_2b_ERR2 = (NOT RECTANGLE M1_RSP_1_2a_2b_Y2) OR ((RECTANGLE M1_RSP_1_2a_2b_Y2) ENCLOSE RECTANGLE 0.001 0.269)
 err2 = (forbidden_RSP_1_2a_2b_A1 WITH EDGE forbidden_RSP_1_2a_2b_A1_1) INSIDE forbidden_RSP_1_2a_2b_ERR2
 err2 NOT INSIDE SealR_NOT_BULK
}
 
M1_RSP_2b {
@ Width (S2) of metal space segments with L2 <= 0.078um
@ Metal space segments definition:
@ 1) At least one metal line width > 0.09um (W1) and the parallel run length > 0.27um (L1) in metal space < 0.108um (S1) region
@ 2) Metal space segments within metal space (S1) region and are generated by space cut line which is perpendicular with L1 direction formed by all vertex in metal space region (S1)
@ 3) Metal space segments at least abut one metal with width > 0.09um (W1)
@ 4) L2 is the width of metal space segments which is parallel with L1 direction
@ 5) S2 is the width of metal space segments which is perpendicular with L1 direction. >= 0.032um
 M1_RSP_1_2a_2b_ERR3 NOT INSIDE SealR_NOT_BULK
}
 
M1_RSP_3_4a_4b_met = ENCLOSE RECTANGLE (M1 INTERACT (M1 WITH WIDTH > 0.12)) 0.121 0.271 ORTHOGONAL ONLY
M1_RSP_3_4a_4b_wid = INT (M1_RSP_3_4a_4b_met) <= 0.12 OPPOSITE EXCLUDE SHIELDED
M1_RSP_3_4a_4b_wan = LENGTH (M1_convex_270_90_edges COIN EDGE M1_RSP_3_4a_4b_met) < 0.126 - 0.032
M1_RSP_3_4a_4b_sps = M1_RSP_3_4a_4b_met COIN EDGE (EXT M1_RSP_3_4a_4b_met M1 < 0.126 OPPOSITE REGION EXCLUDE SHIELDED)
// 
M1_RSP_3_4a_4b_sps_sides_A = (M1_RSP_3_4a_4b_wid COIN EDGE M1_RSP_3_4a_4b_sps) NOT COIN EDGE (LENGTH (M1_RSP_3_4a_4b_wid NOT TOUCH EDGE 
(INT [M1_RSP_3_4a_4b_wid] M1_RSP_3_4a_4b_wan < 0.001 ABUT==90 INTERSECTING ONLY)) <= 0.270)
M1_RSP_3_4a_4b_sps_sides_B = (M1_RSP_3_4a_4b_wid COIN EDGE M1_RSP_3_4a_4b_sps) NOT COIN EDGE (LENGTH (M1_RSP_3_4a_4b_wid NOT TOUCH EDGE 
(EXT [M1_RSP_3_4a_4b_wid] M1_RSP_3_4a_4b_wan < 0.001 ABUT==90 INTERSECTING ONLY)) <= 0.270)
M1_RSP_3_4a_4b_sps_sides = M1_RSP_3_4a_4b_sps_sides_A OR EDGE M1_RSP_3_4a_4b_sps_sides_B
M1_RSP_3_4a_4b_sps_sides_PRL = M1_RSP_3_4a_4b_sps_sides COIN EDGE (PATH LENGTH (M1_RSP_3_4a_4b_wan OR EDGE M1_RSP_3_4a_4b_sps_sides) > 0.270)
// 
M1_RSP_3_4a_4b_S1_side = EXT M1 M1_RSP_3_4a_4b_sps_sides_PRL < 0.126 OPPOSITE EXCLUDE SHIELDED
M1_RSP_3_4a_4b_S1_area = EXT M1 M1_RSP_3_4a_4b_sps_sides_PRL < 0.126 OPPOSITE EXCLUDE SHIELDED REGION
M1_RSP_3_4a_4b_S1_rlen = M1_RSP_3_4a_4b_S1_area ENCLOSE RECTANGLE 0.001 0.271 ORTHOGONAL ONLY
M1_RSP_3_4a_4b_L1_side = M1 COIN EDGE ((DFM COPY M1_RSP_3_4a_4b_S1_side EDGE) COIN EDGE M1_RSP_3_4a_4b_S1_rlen)
M1_RSP_3_4a_4b_L1_side_jog_sum = M1_RSP_3_4a_4b_wan OR EDGE M1_RSP_3_4a_4b_L1_side
M1_RSP_3_4a_4b_L1_side_jog_sum_EXP = EXPAND EDGE M1_RSP_3_4a_4b_L1_side_jog_sum INSIDE BY 0.001 CORNER FILL
// 
M1_RSP_3_4a_4b_Q1 = EXPAND EDGE (M1_RSP_3_4a_4b_L1_side COIN EDGE M1_RSP_3_4a_4b_L1_side_jog_sum) INSIDE BY 0.001
M1_RSP_3_4a_4b_Q2 = M1_RSP_3_4a_4b_L1_side_jog_sum_EXP INTERACT (AREA M1_RSP_3_4a_4b_Q1 > 0.270 * 0.001)
M1_RSP_3_4a_4b_Q3 = M1_RSP_3_4a_4b_L1_side_jog_sum TOUCH EDGE (LENGTH (M1_RSP_3_4a_4b_Q1 INTERACT M1_RSP_3_4a_4b_Q2) > 0.001)
// 
M1_RSP_3_4a_4b_y1 = DFM COPY (EXT M1 M1_RSP_3_4a_4b_Q3 < 0.126 OPPOSITE EXCLUDE SHIELDED) EDGE
M1_RSP_3_4a_4b_y2 = DFM COPY (EXT M1 M1_RSP_3_4a_4b_Q3 < 0.126 OPPOSITE EXCLUDE SHIELDED) REGION
M1_RSP_3_4a_4b_y3 = M1_RSP_3_4a_4b_y1 TOUCH EDGE (INT M1 [M1_RSP_3_4a_4b_y1] <= 0.001 ABUT==90 INTERSECTING ONLY MEASURE ALL)
M1_RSP_3_4a_4b_y4 = EXT M1_RSP_3_4a_4b_y3 M1_RSP_3_4a_4b_y1 < 0.106 OPPOSITE PROJ <= 0.078 REGION
M1_RSP_3_4a_4b_y5 = EXT M1_RSP_3_4a_4b_y3 M1_RSP_3_4a_4b_y1 < 0.106 OPPOSITE PROJ <= 0.078
M1_RSP_3_4a_4b_y6 = RECTANGLE (DFM PROPERTY M1_RSP_3_4a_4b_y4 M1_RSP_3_4a_4b_y5 OVERLAP ABUT ALSO MULTI [-= EC(M1_RSP_3_4a_4b_y5)] <= 0.078)
// 
M1_RSP_3_4a_4b_y2_c = OR M1EMPTY9696 M1_RSP_3_4a_4b_y2
M1_RSP_3_4a_4b_y6_c = OR M1EMPTY9696 M1_RSP_3_4a_4b_y6
CONNECT M1_RSP_3_4a_4b_y2_c M1_RSP_3_4a_4b_y6_c
// 
M1_RSP_3_4a_4b_ERR1_CHK = EXT M1_RSP_3_4a_4b_y1 >= 0.106 < 0.126 OPPOSITE REGION EXCLUDE SHIELDED
M1_RSP_3_4a_4b_ERR1_TMP = EXT ((M1_RSP_3_4a_4b_y6_c NOT COIN EDGE M1) COIN EDGE M1_RSP_3_4a_4b_ERR1_CHK) < 0.298 CONNECTED REGION
M1_RSP_3_4a_4b_ERR1 = M1_RSP_3_4a_4b_ERR1_TMP OR (M1_RSP_3_4a_4b_y6 INTERACT (COPY M1_RSP_3_4a_4b_y6) >= 3 SINGULAR ALSO)
// 
M1_RSP_3_4a_4b_CA = EXT M1_RSP_3_4a_4b_y3 M1_RSP_3_4a_4b_y1 < 0.041 OPPOSITE REGION
M1_RSP_3_4a_4b_CA_side = M1_RSP_3_4a_4b_CA NOT COIN EDGE M1
M1_RSP_3_4a_4b_CA_area = INT M1_RSP_3_4a_4b_CA_side M1_RSP_3_4a_4b_CA <= 0.078 REGION
// 
M1_RSP_3_4a_4b_ERR2_CHK = M1_RSP_3_4a_4b_CA_side NOT TOUCH EDGE M1_RSP_3_4a_4b_CA_area
M1_RSP_3_4a_4b_ERR2_TMP = (NOT RECTANGLE M1_RSP_3_4a_4b_y2) OR ((RECTANGLE M1_RSP_3_4a_4b_y2) ENCLOSE RECTANGLE 0.001 0.269)
M1_RSP_3_4a_4b_ERR2 = (M1_RSP_3_4a_4b_CA WITH EDGE M1_RSP_3_4a_4b_ERR2_CHK) INSIDE M1_RSP_3_4a_4b_ERR2_TMP
// 
M1_RSP_3_4a_4b_CB = EXT M1_RSP_3_4a_4b_y3 M1_RSP_3_4a_4b_y1 < 0.041 OPPOSITE REGION
M1_RSP_3_4a_4b_CB_side = M1_RSP_3_4a_4b_CB NOT COIN EDGE M1
M1_RSP_3_4a_4b_CB_area = INT M1_RSP_3_4a_4b_CB_side <= 0.078 REGION
// 
M1_RSP_3_4a_4b_ERR3_CHK = M1_RSP_3_4a_4b_CB_side TOUCH EDGE M1_RSP_3_4a_4b_CB_area
M1_RSP_3_4a_4b_ERR3_TMP = (NOT RECTANGLE M1_RSP_3_4a_4b_y2) OR ((RECTANGLE M1_RSP_3_4a_4b_y2) ENCLOSE RECTANGLE 0.001 0.269)
M1_RSP_3_4a_4b_ERR3 = (M1_RSP_3_4a_4b_CB WITH EDGE M1_RSP_3_4a_4b_ERR3_CHK) INSIDE M1_RSP_3_4a_4b_ERR3_TMP
 
M1_RSP_3 {
@ Space between metal space segments with S2 < 0.106um and L2 <= 0.078um
@ Metal space segments definition:
@ 1) At least one metal line width > 0.12um (W1) and the parallel run length > 0.27um (L1) in metal space < 0.126um (S1) region
@ 2) Metal space segments within metal space (S1) region and are generated by space cut line which is perpendicular with L1 direction formed by all vertex in metal space region (S1)
@ 3) Metal space segments at least abut one metal with width > 0.12um (W1)
@ 4) L2 is the width of metal space segments which is parallel with L1 direction
@ 5) S2 is the width of metal space segments which is perpendicular with L1 direction. >= 0.298um
 M1_RSP_3_4a_4b_ERR1 NOT INSIDE SealR_NOT_BULK
}
 
M1_RSP_4a {
@ Width (S2) of metal space segments with L2 > 0.078um, (0.058um <= S < 0.106um is forbidden), except OCOVL region
@ Metal space segments definition:
@ 1) At least one metal line width > 0.12um (W1) and the parallel run length > 0.27um (L1) in metal space < 0.126um (S1) region
@ 2) Metal space segments within metal space (S1) region and are generated by space cut line which is perpendicular with L1 direction formed by all vertex in metal space region (S1)
@ 3) Metal space segments at least abut one metal with width > 0.12um (W1)
@ 4) L2 is the width of metal space segments which is parallel with L1 direction
@ 5) S2 is the width of metal space segments which is perpendicular with L1 direction. >= 0.041um
 M1_RSP_3_4a_4b_ERR2 NOT INSIDE OCOVL
 // 
 forbidden_RSP_3_4a_4b_A1 = EXT M1_RSP_3_4a_4b_Y3 M1_RSP_3_4a_4b_Y1 >= 0.058 < 0.106 OPPOSITE REGION
 forbidden_RSP_3_4a_4b_A1_edge = forbidden_RSP_3_4a_4b_A1 NOT COIN EDGE M1
 forbidden_RSP_3_4a_4b_A1_area = INT forbidden_RSP_3_4a_4b_A1_edge forbidden_RSP_3_4a_4b_A1 <= 0.078 REGION
 forbidden_RSP_3_4a_4b_A1_1 = forbidden_RSP_3_4a_4b_A1_edge NOT TOUCH EDGE forbidden_RSP_3_4a_4b_A1_area
 forbidden_RSP_3_4a_4b_ERR2 = (NOT RECTANGLE M1_RSP_3_4a_4b_Y2) OR ((RECTANGLE M1_RSP_3_4a_4b_Y2) ENCLOSE RECTANGLE 0.001 0.269)
 err2 = (forbidden_RSP_3_4a_4b_A1 WITH EDGE forbidden_RSP_3_4a_4b_A1_1) INSIDE forbidden_RSP_3_4a_4b_ERR2
 err2 NOT INSIDE OCOVL
}
 
M1_RSP_4b {
@ Width (S2) of metal space segments with L2 <= 0.078um (0.058um <= S < 0.072um is forbidden)
@ Metal space segments definition:
@ 1) At least one metal line width > 0.12um (W1) and the parallel run length > 0.27um (L1) in metal space < 0.126um (S1) region
@ 2) Metal space segments within metal space (S1) region and are generated by space cut line which is perpendicular with L1 direction formed by all vertex in metal space region (S1)
@ 3) Metal space segments at least abut one metal with width > 0.12um (W1)
@ 4) L2 is the width of metal space segments which is parallel with L1 direction
@ 5) S2 is the width of metal space segments which is perpendicular with L1 direction. >= 0.041um
 M1_RSP_3_4a_4b_ERR3 NOT INSIDE SealR_NOT_BULK
 // 
 forbidden_RSP_3_4a_4b_A2 = EXT M1_RSP_3_4a_4b_Y3 M1_RSP_3_4a_4b_Y1 >= 0.058 < 0.072 OPPOSITE REGION
 forbidden_RSP_3_4a_4b_A2_edge = forbidden_RSP_3_4a_4b_A2 NOT COIN EDGE M1
 forbidden_RSP_3_4a_4b_A2_area = INT forbidden_RSP_3_4a_4b_A2_edge <= 0.078 REGION
 forbidden_RSP_3_4a_4b_A2_2 = forbidden_RSP_3_4a_4b_A2_edge TOUCH EDGE forbidden_RSP_3_4a_4b_A2_area
 forbidden_RSP_3_4a_4b_ERR3 = (NOT RECTANGLE M1_RSP_3_4a_4b_Y2) OR ((RECTANGLE M1_RSP_3_4a_4b_Y2) ENCLOSE RECTANGLE 0.001 0.269)
 err2 = (forbidden_RSP_3_4a_4b_A2 WITH EDGE forbidden_RSP_3_4a_4b_A2_2) INSIDE forbidden_RSP_3_4a_4b_ERR3
 err2 NOT INSIDE SealR_NOT_BULK
}
 
M1_RSP_5_6a_6b_met = ENCLOSE RECTANGLE (M1 INTERACT (M1 WITH WIDTH > 0.180)) 0.181 0.271 ORTHOGONAL ONLY
M1_RSP_5_6a_6b_wid = INT (M1_RSP_5_6a_6b_met) <= 0.180 OPPOSITE EXCLUDE SHIELDED
M1_RSP_5_6a_6b_wan = LENGTH (M1_convex_270_90_edges COIN EDGE M1_RSP_5_6a_6b_met) < 0.144 - 0.032
M1_RSP_5_6a_6b_sps = M1_RSP_5_6a_6b_met COIN EDGE (EXT M1_RSP_5_6a_6b_met M1 < 0.144 OPPOSITE REGION EXCLUDE SHIELDED)
// 
M1_RSP_5_6a_6b_sps_sides_A = (M1_RSP_5_6a_6b_wid COIN EDGE M1_RSP_5_6a_6b_sps) NOT COIN EDGE (LENGTH (M1_RSP_5_6a_6b_wid NOT TOUCH EDGE 
(INT [M1_RSP_5_6a_6b_wid] M1_RSP_5_6a_6b_wan < 0.001 ABUT==90 INTERSECTING ONLY)) <= 0.270)
M1_RSP_5_6a_6b_sps_sides_B = (M1_RSP_5_6a_6b_wid COIN EDGE M1_RSP_5_6a_6b_sps) NOT COIN EDGE (LENGTH (M1_RSP_5_6a_6b_wid NOT TOUCH EDGE 
(EXT [M1_RSP_5_6a_6b_wid] M1_RSP_5_6a_6b_wan < 0.001 ABUT==90 INTERSECTING ONLY)) <= 0.270)
M1_RSP_5_6a_6b_sps_sides = M1_RSP_5_6a_6b_sps_sides_A OR EDGE M1_RSP_5_6a_6b_sps_sides_B
M1_RSP_5_6a_6b_sps_sides_PRL = M1_RSP_5_6a_6b_sps_sides COIN EDGE (PATH LENGTH (M1_RSP_5_6a_6b_wan OR EDGE M1_RSP_5_6a_6b_sps_sides) > 0.270)
// 
M1_RSP_5_6a_6b_S1_side = EXT M1 M1_RSP_5_6a_6b_sps_sides_PRL < 0.144 OPPOSITE EXCLUDE SHIELDED
M1_RSP_5_6a_6b_S1_area = EXT M1 M1_RSP_5_6a_6b_sps_sides_PRL < 0.144 OPPOSITE EXCLUDE SHIELDED REGION
M1_RSP_5_6a_6b_S1_rlen = M1_RSP_5_6a_6b_S1_area ENCLOSE RECTANGLE 0.001 0.271 ORTHOGONAL ONLY
M1_RSP_5_6a_6b_L1_side = M1 COIN EDGE ((DFM COPY M1_RSP_5_6a_6b_S1_side EDGE) COIN EDGE M1_RSP_5_6a_6b_S1_rlen)
M1_RSP_5_6a_6b_L1_side_jog_sum = M1_RSP_5_6a_6b_wan OR EDGE M1_RSP_5_6a_6b_L1_side
M1_RSP_5_6a_6b_L1_side_jog_sum_EXP = EXPAND EDGE M1_RSP_5_6a_6b_L1_side_jog_sum INSIDE BY 0.001 CORNER FILL
// 
M1_RSP_5_6a_6b_Q1 = EXPAND EDGE (M1_RSP_5_6a_6b_L1_side COIN EDGE M1_RSP_5_6a_6b_L1_side_jog_sum) INSIDE BY 0.001
M1_RSP_5_6a_6b_Q2 = M1_RSP_5_6a_6b_L1_side_jog_sum_EXP INTERACT (AREA M1_RSP_5_6a_6b_Q1 > 0.270 * 0.001)
M1_RSP_5_6a_6b_Q3 = M1_RSP_5_6a_6b_L1_side_jog_sum TOUCH EDGE (LENGTH (M1_RSP_5_6a_6b_Q1 INTERACT M1_RSP_5_6a_6b_Q2) > 0.001)
// 
M1_RSP_5_6a_6b_y1 = DFM COPY (EXT M1 M1_RSP_5_6a_6b_Q3 < 0.144 OPPOSITE EXCLUDE SHIELDED) EDGE
M1_RSP_5_6a_6b_y2 = DFM COPY (EXT M1 M1_RSP_5_6a_6b_Q3 < 0.144 OPPOSITE EXCLUDE SHIELDED) REGION
M1_RSP_5_6a_6b_y3 = M1_RSP_5_6a_6b_y1 TOUCH EDGE (INT M1 [M1_RSP_5_6a_6b_y1] <= 0.001 ABUT==90 INTERSECTING ONLY MEASURE ALL)
M1_RSP_5_6a_6b_y4 = EXT M1_RSP_5_6a_6b_y3 M1_RSP_5_6a_6b_y1 < 0.126 OPPOSITE PROJ <= 0.078 REGION
M1_RSP_5_6a_6b_y5 = EXT M1_RSP_5_6a_6b_y3 M1_RSP_5_6a_6b_y1 < 0.126 OPPOSITE PROJ <= 0.078
M1_RSP_5_6a_6b_y6 = RECTANGLE (DFM PROPERTY M1_RSP_5_6a_6b_y4 M1_RSP_5_6a_6b_y5 OVERLAP ABUT ALSO MULTI [-= EC(M1_RSP_5_6a_6b_y5)] <= 0.078)
// 
M1_RSP_5_6a_6b_y2_c = OR M1EMPTY9696 M1_RSP_5_6a_6b_y2
M1_RSP_5_6a_6b_y6_c = OR M1EMPTY9696 M1_RSP_5_6a_6b_y6
CONNECT M1_RSP_5_6a_6b_y2_c M1_RSP_5_6a_6b_y6_c
// 
M1_RSP_5_6a_6b_ERR1_CHK = EXT M1_RSP_5_6a_6b_y1 >= 0.126 < 0.144 OPPOSITE REGION EXCLUDE SHIELDED
M1_RSP_5_6a_6b_ERR1_TMP = EXT ((M1_RSP_5_6a_6b_y6_c NOT COIN EDGE M1) COIN EDGE M1_RSP_5_6a_6b_ERR1_CHK) < 0.298 CONNECTED REGION
M1_RSP_5_6a_6b_ERR1 = M1_RSP_5_6a_6b_ERR1_TMP OR (M1_RSP_5_6a_6b_y6 INTERACT (COPY M1_RSP_5_6a_6b_y6) >= 3 SINGULAR ALSO)
// 
M1_RSP_5_6a_6b_CA = EXT M1_RSP_5_6a_6b_y3 M1_RSP_5_6a_6b_y1 < 0.125 OPPOSITE REGION
M1_RSP_5_6a_6b_CA_side = M1_RSP_5_6a_6b_CA NOT COIN EDGE M1
M1_RSP_5_6a_6b_CA_area = INT M1_RSP_5_6a_6b_CA_side M1_RSP_5_6a_6b_CA <= 0.078 REGION
// 
M1_RSP_5_6a_6b_ERR2_CHK = M1_RSP_5_6a_6b_CA_side NOT TOUCH EDGE M1_RSP_5_6a_6b_CA_area
M1_RSP_5_6a_6b_ERR2_TMP = (NOT RECTANGLE M1_RSP_5_6a_6b_y2) OR ((RECTANGLE M1_RSP_5_6a_6b_y2) ENCLOSE RECTANGLE 0.001 0.269)
M1_RSP_5_6a_6b_ERR2 = (M1_RSP_5_6a_6b_CA WITH EDGE M1_RSP_5_6a_6b_ERR2_CHK) INSIDE M1_RSP_5_6a_6b_ERR2_TMP
// 
M1_RSP_5_6a_6b_CB = EXT M1_RSP_5_6a_6b_y3 M1_RSP_5_6a_6b_y1 < 0.107 OPPOSITE REGION
M1_RSP_5_6a_6b_CB_side = M1_RSP_5_6a_6b_CB NOT COIN EDGE M1
M1_RSP_5_6a_6b_CB_area = INT M1_RSP_5_6a_6b_CB_side <= 0.078 REGION
// 
M1_RSP_5_6a_6b_ERR3_CHK = M1_RSP_5_6a_6b_CB_side TOUCH EDGE M1_RSP_5_6a_6b_CB_area
M1_RSP_5_6a_6b_ERR3_TMP = (NOT RECTANGLE M1_RSP_5_6a_6b_y2) OR ((RECTANGLE M1_RSP_5_6a_6b_y2) ENCLOSE RECTANGLE 0.001 0.269)
M1_RSP_5_6a_6b_ERR3 = (M1_RSP_5_6a_6b_CB WITH EDGE M1_RSP_5_6a_6b_ERR3_CHK) INSIDE M1_RSP_5_6a_6b_ERR3_TMP
 
M1_RSP_5 {
@ Space between metal space segments with S2 < 0.126um and L2 <= 0.078um
@ Metal space segments definition:
@ 1) At least one metal line width > 0.180um (W1) and the parallel run length > 0.27um (L1) in metal space < 0.144um (S1) region
@ 2) Metal space segments within metal space (S1) region and are generated by space cut line which is perpendicular with L1 direction formed by all vertex in metal space region (S1)
@ 3) Metal space segments at least abut one metal with width > 0.18um (W1)
@ 4) L2 is the width of metal space segments which is parallel with L1 direction
@ 5) S2 is the width of metal space segments which is perpendicular with L1 direction. >= 0.298um
 M1_RSP_5_6a_6b_ERR1 NOT INSIDE SealR_NOT_BULK
}
 
M1_RSP_6a {
@ Width (S2) of metal space segments with L2 > 0.078um
@ Metal space segments definition:
@ 1) At least one metal line width > 0.18um (W1) and the parallel run length > 0.27um (L1) in metal space < 0.144um (S1) region
@ 2) Metal space segments within metal space (S1) region and are generated by space cut line which is perpendicular with L1 direction formed by all vertex in metal space region (S1)
@ 3) Metal space segments at least abut one metal with width > 0.18um (W1)
@ 4) L2 is the width of metal space segments which is parallel with L1 direction
@ 5) S2 is the width of metal space segments which is perpendicular with L1 direction. >= 0.125um
 M1_RSP_5_6a_6b_ERR2 NOT INSIDE SealR_NOT_BULK
}
 
M1_RSP_6b {
@ Width (S2) of metal space segments with L2 <= 0.078um
@ Metal space segments definition:
@ 1) At least one metal line width > 0.18um (W1) and the parallel run length > 0.27um (L1) in metal space < 0.144um (S1) region
@ 2) Metal space segments within metal space (S1) region and are generated by space cut line which is perpendicular with L1 direction formed by all vertex in metal space region (S1)
@ 3) Metal space segments at least abut one metal with width > 0.18um (W1)
@ 4) L2 is the width of metal space segments which is parallel with L1 direction
@ 5) S2 is the width of metal space segments which is perpendicular with L1 direction. >= 0.107um
 M1_RSP_5_6a_6b_ERR3 NOT INSIDE SealR_NOT_BULK
}
 
M1_RSP_7_8a_8b_met = ENCLOSE RECTANGLE (M1 INTERACT (M1 WITH WIDTH > 0.27)) 0.271 0.271 ORTHOGONAL ONLY
M1_RSP_7_8a_8b_wid = INT (M1_RSP_7_8a_8b_met) <= 0.27 OPPOSITE EXCLUDE SHIELDED
M1_RSP_7_8a_8b_wan = LENGTH (M1_convex_270_90_edges COIN EDGE M1_RSP_7_8a_8b_met) < 0.261 - 0.032
M1_RSP_7_8a_8b_sps = M1_RSP_7_8a_8b_met COIN EDGE (EXT M1_RSP_7_8a_8b_met M1 < 0.261 OPPOSITE REGION EXCLUDE SHIELDED)
// 
M1_RSP_7_8a_8b_sps_sides_A = (M1_RSP_7_8a_8b_wid COIN EDGE M1_RSP_7_8a_8b_sps) NOT COIN EDGE (LENGTH (M1_RSP_7_8a_8b_wid NOT TOUCH EDGE 
(INT [M1_RSP_7_8a_8b_wid] M1_RSP_7_8a_8b_wan < 0.001 ABUT==90 INTERSECTING ONLY)) <= 0.27)
M1_RSP_7_8a_8b_sps_sides_B = (M1_RSP_7_8a_8b_wid COIN EDGE M1_RSP_7_8a_8b_sps) NOT COIN EDGE (LENGTH (M1_RSP_7_8a_8b_wid NOT TOUCH EDGE 
(EXT [M1_RSP_7_8a_8b_wid] M1_RSP_7_8a_8b_wan < 0.001 ABUT==90 INTERSECTING ONLY)) <= 0.27)
M1_RSP_7_8a_8b_sps_sides = M1_RSP_7_8a_8b_sps_sides_A OR EDGE M1_RSP_7_8a_8b_sps_sides_B
M1_RSP_7_8a_8b_sps_sides_PRL = M1_RSP_7_8a_8b_sps_sides COIN EDGE (PATH LENGTH (M1_RSP_7_8a_8b_wan OR EDGE M1_RSP_7_8a_8b_sps_sides) > 0.27)
// 
M1_RSP_7_8a_8b_S1_side = EXT M1 M1_RSP_7_8a_8b_sps_sides_PRL < 0.261 OPPOSITE EXCLUDE SHIELDED
M1_RSP_7_8a_8b_S1_area = EXT M1 M1_RSP_7_8a_8b_sps_sides_PRL < 0.261 OPPOSITE EXCLUDE SHIELDED REGION
M1_RSP_7_8a_8b_S1_rlen = M1_RSP_7_8a_8b_S1_area ENCLOSE RECTANGLE 0.001 0.271 ORTHOGONAL ONLY
M1_RSP_7_8a_8b_L1_side = M1 COIN EDGE ((DFM COPY M1_RSP_7_8a_8b_S1_side EDGE) COIN EDGE M1_RSP_7_8a_8b_S1_rlen)
M1_RSP_7_8a_8b_L1_side_jog_sum = M1_RSP_7_8a_8b_wan OR EDGE M1_RSP_7_8a_8b_L1_side
M1_RSP_7_8a_8b_L1_side_jog_sum_EXP = EXPAND EDGE M1_RSP_7_8a_8b_L1_side_jog_sum INSIDE BY 0.001 CORNER FILL
// 
M1_RSP_7_8a_8b_Q1 = EXPAND EDGE (M1_RSP_7_8a_8b_L1_side COIN EDGE M1_RSP_7_8a_8b_L1_side_jog_sum) INSIDE BY 0.001
M1_RSP_7_8a_8b_Q2 = M1_RSP_7_8a_8b_L1_side_jog_sum_EXP INTERACT (AREA M1_RSP_7_8a_8b_Q1 > 0.27 * 0.001)
M1_RSP_7_8a_8b_Q3 = M1_RSP_7_8a_8b_L1_side_jog_sum TOUCH EDGE (LENGTH (M1_RSP_7_8a_8b_Q1 INTERACT M1_RSP_7_8a_8b_Q2) > 0.001)
// 
M1_RSP_7_8a_8b_y1 = DFM COPY (EXT M1 M1_RSP_7_8a_8b_Q3 < 0.261 OPPOSITE EXCLUDE SHIELDED) EDGE
M1_RSP_7_8a_8b_y2 = DFM COPY (EXT M1 M1_RSP_7_8a_8b_Q3 < 0.261 OPPOSITE EXCLUDE SHIELDED) REGION
M1_RSP_7_8a_8b_y3 = M1_RSP_7_8a_8b_y1 TOUCH EDGE (INT M1 [M1_RSP_7_8a_8b_y1] <= 0.001 ABUT==90 INTERSECTING ONLY MEASURE ALL)
M1_RSP_7_8a_8b_y4 = EXT M1_RSP_7_8a_8b_y3 M1_RSP_7_8a_8b_y1 < 0.144 OPPOSITE PROJ <= 0.078 REGION
M1_RSP_7_8a_8b_y5 = EXT M1_RSP_7_8a_8b_y3 M1_RSP_7_8a_8b_y1 < 0.144 OPPOSITE PROJ <= 0.078
M1_RSP_7_8a_8b_y6 = RECTANGLE (DFM PROPERTY M1_RSP_7_8a_8b_y4 M1_RSP_7_8a_8b_y5 OVERLAP ABUT ALSO MULTI [-= EC(M1_RSP_7_8a_8b_y5)] <= 0.078)
// 
M1_RSP_7_8a_8b_y2_c = OR M1EMPTY9696 M1_RSP_7_8a_8b_y2
M1_RSP_7_8a_8b_y6_c = OR M1EMPTY9696 M1_RSP_7_8a_8b_y6
CONNECT M1_RSP_7_8a_8b_y2_c M1_RSP_7_8a_8b_y6_c
// 
M1_RSP_7_8a_8b_ERR1_CHK = EXT M1_RSP_7_8a_8b_y1 >= 0.144 < 0.261 OPPOSITE REGION EXCLUDE SHIELDED
M1_RSP_7_8a_8b_ERR1_TMP = EXT ((M1_RSP_7_8a_8b_y6_c NOT COIN EDGE M1) COIN EDGE M1_RSP_7_8a_8b_ERR1_CHK) < 0.298 CONNECTED REGION
M1_RSP_7_8a_8b_ERR1 = M1_RSP_7_8a_8b_ERR1_TMP OR (M1_RSP_7_8a_8b_y6 INTERACT (COPY M1_RSP_7_8a_8b_y6) >= 3 SINGULAR ALSO)
// 
M1_RSP_7_8a_8b_CA = EXT M1_RSP_7_8a_8b_y3 M1_RSP_7_8a_8b_y1 < 0.142 OPPOSITE REGION
M1_RSP_7_8a_8b_CA_side = M1_RSP_7_8a_8b_CA NOT COIN EDGE M1
M1_RSP_7_8a_8b_CA_area = INT M1_RSP_7_8a_8b_CA_side M1_RSP_7_8a_8b_CA <= 0.078 REGION
// 
M1_RSP_7_8a_8b_ERR2_CHK = M1_RSP_7_8a_8b_CA_side NOT TOUCH EDGE M1_RSP_7_8a_8b_CA_area
M1_RSP_7_8a_8b_ERR2_TMP = (NOT RECTANGLE M1_RSP_7_8a_8b_y2) OR ((RECTANGLE M1_RSP_7_8a_8b_y2) ENCLOSE RECTANGLE 0.001 0.269)
M1_RSP_7_8a_8b_ERR2 = (M1_RSP_7_8a_8b_CA WITH EDGE M1_RSP_7_8a_8b_ERR2_CHK) INSIDE M1_RSP_7_8a_8b_ERR2_TMP
// 
M1_RSP_7_8a_8b_CB = EXT M1_RSP_7_8a_8b_y3 M1_RSP_7_8a_8b_y1 < 0.125 OPPOSITE REGION
M1_RSP_7_8a_8b_CB_side = M1_RSP_7_8a_8b_CB NOT COIN EDGE M1
M1_RSP_7_8a_8b_CB_area = INT M1_RSP_7_8a_8b_CB_side <= 0.078 REGION
// 
M1_RSP_7_8a_8b_ERR3_CHK = M1_RSP_7_8a_8b_CB_side TOUCH EDGE M1_RSP_7_8a_8b_CB_area
M1_RSP_7_8a_8b_ERR3_TMP = (NOT RECTANGLE M1_RSP_7_8a_8b_y2) OR ((RECTANGLE M1_RSP_7_8a_8b_y2) ENCLOSE RECTANGLE 0.001 0.269)
M1_RSP_7_8a_8b_ERR3 = (M1_RSP_7_8a_8b_CB WITH EDGE M1_RSP_7_8a_8b_ERR3_CHK) INSIDE M1_RSP_7_8a_8b_ERR3_TMP
 
M1_RSP_7 {
@ Space between metal space segments with S2 < 0.144 and L2 <= 0.078um
@ Metal space segments definition:
@ 1) At least one metal line width > 0.270um (W1) and the parallel run length > 0.27um (L1) in metal space < 0.261um (S1) region
@ 2) Metal space segments within metal space (S1) region and are generated by space cut line which is perpendicular with L1 direction formed by all vertex in metal space region (S1)
@ 3) Metal space segments at least abut one metal with width > 0.270um (W1)
@ 4) L2 is the width of metal space segments which is parallel with L1 direction
@ 5) S2 is the width of metal space segments which is perpendicular with L1 direction. >= 0.298um
 M1_RSP_7_8a_8b_ERR1 NOT INSIDE SealR_NOT_BULK
}
 
M1_RSP_8a {
@ Width (S2) of metal space segments with L2 > 0.078um
@ Metal space segments definition:
@ 1) At least one metal line width > 0.27um (W1) and the parallel run length > 0.270um (L1) in metal space < 0.261um (S1) region
@ 2) Metal space segments within metal space (S1) region and are generated by space cut line which is perpendicular with L1 direction formed by all vertex in metal space region (S1)
@ 3) Metal space segments at least abut one metal with width > 0.270um (W1)
@ 4) L2 is the width of metal space segments which is parallel with L1 direction
@ 5) S2 is the width of metal space segments which is perpendicular with L1 direction. >= 0.142um
 M1_RSP_7_8a_8b_ERR2 NOT INSIDE SealR_NOT_BULK
}
 
M1_RSP_8b {
@ Width (S2) of metal space segments with L2 <= 0.078um
@ Metal space segments definition:
@ 1) At least one metal line width > 0.27um (W1) and the parallel run length > 0.270um (L1) in metal space < 0.261um (S1) region
@ 2) Metal space segments within metal space (S1) region and are generated by space cut line which is perpendicular with L1 direction formed by all vertex in metal space region (S1)
@ 3) Metal space segments at least abut one metal with width > 0.270um (W1)
@ 4) L2 is the width of metal space segments which is parallel with L1 direction
@ 5) S2 is the width of metal space segments which is perpendicular with L1 direction. >= 0.125um
 M1_RSP_7_8a_8b_ERR3 NOT INSIDE SealR_NOT_BULK
}

VARIABLE M1_ORCS_3_val 0.08
#IFDEF DOUBLE_PATTERNING_RULES_CHECK YES
#IFDEF DOUBLE_PATTERNING_RULES_CHECK_ONLY YES
GROUP GM1DP M1_OR_?
DRC SELECT CHECK GM1DP
#ENDIF
//-----------------------------------------------------------------------------------------------------------------//
//	M1_OR_0_NC: Odd ring conflict space definition: 							   //
//	OR Line Space (ORLS): polygons violate any one of the odd ring space rules from M1.ORCS.1 to M1.ORCS.3     //
//	OR Corner Space (ORCS): polygons violate any one of the odd ring space rule M1.ORCS.1a			   //
//	OR-AREA definition: 											   //
//	1.Odd ring line area (ORLA): The projection area between 2 edges with ORLS				   //
//	2.Odd ring corner area (ORCA): The line between 2 corners with ORCS					   //
//	3.ORLA or ORCA region are independent to all other ones, even if they are overlapped or crossed		   //
//	Loop:													   //
//	1.A loop is formed when polygons of M1 are connected in a cycle sequence with OR-AREA in between	   //
//	2.A loop cannot contain any sub-loops which share one or more polygons with it				   //
//	Path:													   //
//	A path is formed when polygons of M1 are connected one by one from one marker to another marker with       //
//      OR-AREA in between											   //
//-----------------------------------------------------------------------------------------------------------------//

//;beginning of M1.ORCS.1 derivations
M1_ORCS_1_final = EXT M1 < 0.058 OPPOSITE EXTENDED 0.015 SPACE
//;end of M1.ORCS.1 derivations

VARIABLE M1_ORCS_PRL 0.015
VARIABLE M1_OVER_VAL 0.016

M1_end_DP = LENGTH M1_convex_90_90_edges < 0.046
M1_end_DP_046_056 = LENGTH M1_convex_90_90_edges >= 0.046 < 0.056
M1_line_DP = (M1 NOT TOUCH EDGE M1_end_DP) NOT TOUCH EDGE M1_45_skew_edges

//;M1.ORCS.2 waive condition
M1_ORCS_2_line_W047 = INT M1_line_DP < 0.047 OPPOSITE REGION
M1_ORCS_2_line_area = EXT M1_line_DP >= 0.058 < 0.063 OPPOSITE EXTENDED 0.015 EXCLUDE SHIELDED SPACE REGION
M1_ORCS_2_line_errs = EXT M1_line_DP >= 0.058 < 0.063 OPPOSITE EXTENDED 0.015 EXCLUDE SHIELDED SPACE
M1_ORCS_2_line_side = EXPAND EDGE (M1_ORCS_2_line_area NOT TOUCH EDGE M1) INSIDE BY 0.001 EXTEND BY -0.001

M1_ORCS_2_line_II_condition112_PRL = DFM PROPERTY M1_ORCS_2_line_area M1_ORCS_2_line_errs OVERLAP ABUT ALSO MULTI [-= EC(M1_ORCS_2_line_errs)] > 0.112
M1_ORCS_2_line_II_condition210_PRL = DFM PROPERTY M1_ORCS_2_line_area M1_ORCS_2_line_errs OVERLAP ABUT ALSO MULTI [-= EC(M1_ORCS_2_line_errs)] > 0.210
M1_ORCS_2_line_al_condition_PRL_pure = M1_ORCS_2_line_II_condition112_PRL NOT M1_ORCS_2_line_II_condition210_PRL
M1_ORCS_2_line_al_condition_PRL_true = M1_ORCS_2_line_al_condition_PRL_pure NOT INTERACT M1_ORCS_2_line_W047

M1_ORCS_2_line_TRUE = M1_ORCS_2_line_II_condition112_PRL NOT M1_ORCS_2_line_al_condition_PRL_true
M1_ORCS_2_line_lend = EXT M1_line_DP M1_end_DP_046_056 >= 0.058 < 0.063 OPPOSITE EXTENDED 0.015 REGION SPACE

M1_ORCS_1_line_line = EXT M1_line_DP < 0.058 OPPOSITE EXTENDED 0.015 REGION SPACE
M1_ORCS_3_line_lend = EXT M1_line_DP M1_end_DP < M1_ORCS_3_val OPPOSITE EXTENDED 0.015 REGION SPACE
M1_ORCS_3_lend_lend = EXT M1_end_DP < M1_ORCS_3_val OPPOSITE EXTENDED 0.015 REGION SPACE
M1_ORCS_1_2_3_common = OR M1_ORCS_1_line_line M1_ORCS_2_line_lend M1_ORCS_2_line_TRUE M1_ORCS_3_lend_lend M1_ORCS_3_line_lend

//;beginning of M1.ORCS.4 derivations
M1_ORCS_1a_raw = EXT M1 < 0.058 CORNER TO CORNER SPACE
M1_ORCS_1a_final = DFM PROPERTY M1_ORCS_1a_raw [-= (EWXP(M1_ORCS_1a_raw) >= 0.015 && EWYP(M1_ORCS_1a_raw) >= 0.015) ? 1 : 0] > 0
M1_ORCS_1a_final_area = DFM COPY M1_ORCS_1a_final REGION
//;end of M1.ORCS.4 derivations

M1_ORCS_2_true_CHK = M1 COIN EDGE (OR M1_ORCS_2_line_TRUE M1_ORCS_2_line_lend)
M1_ORCS_2_final_TMP = EXT M1_ORCS_2_true_CHK < 0.063 OPPOSITE EXTENDED 0.015
M1_ORCS_2_final = DFM PROPERTY M1_ORCS_2_final_TMP DRC:1_NOT_INST OVERLAP MULTI [-= (count(DRC:1_NOT_INST) > 0) ? 1 : 0] > 0

M1_ORCS_3_final_TMP = EXT M1_end_DP M1 < M1_ORCS_3_val OPPOSITE EXTENDED 0.015 SPACE
M1_ORCS_3_final = DFM PROPERTY M1_ORCS_3_final_TMP DRC:1_NOT_INST OVERLAP MULTI [-= (count(DRC:1_NOT_INST) > 0) ? 1 : 0] > 0

//;output of all ORCS
M1_ORCS_1 = DFM COPY M1_ORCS_1_final
M1_ORCS_2 = DFM COPY M1_ORCS_2_final
M1_ORCS_3 = DFM COPY M1_ORCS_3_final
M1_ORCS_1a = DFM COPY M1_ORCS_1a_final

M1_ORCS_1_AREA = DFM COPY M1_ORCS_1 REGION
M1_ORCS_2_AREA = DFM COPY M1_ORCS_2 REGION
M1_ORCS_3_AREA = DFM COPY M1_ORCS_3 REGION
M1_ORCS_1a_AREA = DFM COPY M1_ORCS_1a REGION
M1_ORCS_AREA_raw = OR M1_ORCS_1_AREA M1_ORCS_2_AREA M1_ORCS_3_AREA M1_ORCS_1a_AREA

M1_critical_case_edge = CONVEX EDGE M1 == 1 WITH LENGTH <= 0.002
M1_critical_case = EXT M1 M1_critical_case_edge < 0.002 ABUT==90 INTERSECTING ONLY REGION
M1_ORCS_AREA = M1_ORCS_AREA_raw NOT M1_critical_case

//;litho file output
LITHO FILE M1dpcfile [
resolve ;

action M1_ORCS_1 has nicety of -1 and requires opposite masks;
action M1_ORCS_2 has nicety of -1 and requires opposite masks;
action M1_ORCS_3 has nicety of -1 and requires opposite masks;
action M1_ORCS_1a has nicety of -1 and requires opposite masks;

anchor M1CA has nicety of -1 is for mask0;
anchor M1CB has nicety of -1 is for mask1;
output all conflicts;
]

M1_conflict_rings = DFM DP RING M1 M1_ORCS_1 M1_ORCS_2 M1_ORCS_3 M1_ORCS_1a (OPPOSITE 0)
M1_warning_rings = DFM DP WARNING M1 M1_ORCS_1 M1_ORCS_2 M1_ORCS_3 M1_ORCS_1a (OPPOSITE 0)
M1_conflict_anchor = DFM DP ANCHOR_CONFLICT M1 M1_ORCS_1 M1_ORCS_2 M1_ORCS_3 M1_ORCS_1a (OPPOSITE 0) M1CA(anchor mask0) M1CB(anchor mask1) UNFILTERED
M1_mask0 = DFM DP MASK0 M1 M1_ORCS_1 M1_ORCS_2 M1_ORCS_3 M1_ORCS_1a (OPPOSITE 0)
M1_mask1 = DFM DP MASK1 M1 M1_ORCS_1 M1_ORCS_2 M1_ORCS_3 M1_ORCS_1a (OPPOSITE 0)

//M1_conflict_rings = RET NMDPC M1_ORCS_1 M1 M1_ORCS_2 M1_ORCS_3 M1_ORCS_1a M1CA M1CB FILE M1dpcfile MAP ring
//M1_warning_rings = RET NMDPC M1_ORCS_1 M1 M1_ORCS_2 M1_ORCS_3 M1_ORCS_1a M1CA M1CB FILE M1dpcfile MAP warning
//M1_conflict_anchor = RET NMDPC M1_ORCS_1 M1 M1_ORCS_2 M1_ORCS_3 M1_ORCS_1a M1CA M1CB FILE M1dpcfile MAP anchor_path

M1_WIDTH_lt_056 = M1 WITH WIDTH < 0.056
M1_WIDTH_eqgt_056 = M1 WITH WIDTH >= 0.056
M1_ORCS_2_x = EXT M1_WIDTH_lt_056 < 0.063 OPPOSITE
M1_ORCS_2_y_tmp = EXT M1 M1_WIDTH_eqgt_056 < 0.063 OPPOSITE
M1_ORCS_2_y = DFM PROPERTY M1_ORCS_2_y_tmp [-= EC(M1_ORCS_2_y_tmp)] > 112 <= 210

#IFDEF SHOW_DOUBLE_PATTERNING_CONFLICT_SPACE YES
M1_ORCS_1 {
@ Space between M1s when PRL > -0.015um. >= 0.058um
 err1 = COPY M1_ORCS_1_AREA
 err1 NOT INSIDE SealR_NOT_BULK
}

M1_ORCS_1a {
@ Corner space between M1s when PRL <= -0.015um. >= 0.058um
 err1 = COPY M1_ORCS_1a_AREA
 err1 NOT INSIDE SealR_NOT_BULK
}

M1_ORCS_2 {
@ Space between M1s when PRL > -0.015um. >= 0.063um
@ Except the following conditions (these two conditions are only applied to different polygons)
@ 1) M1 space perpendicular to width direction (M1 width >= 0.056um and PRL <= 0.112um)
@ 2) M1 space parallel to width direction (M1 width >= 0.047um (both sides) and PRL <= 0.21um)
@ 3) INST region
//;1) at least one lend (line ends of width < 0.056 metal) to any metal line & PRL <= 0.112
//;2) at least one line (long side of width < 0.047 metal) to any metal line & PRL > 112 <= 210
//;3) at lease one line (long/short edge of width >= 0.047 metal) to any metal line & PRL > 210
//;4) at lease one line (long/short edge of width <= 0.046 metal) to any metal line & PRL > 210
//;x) width < 0.056 (both) ??
//;y) width >= 0.056 PRL > 112 <= 210 ??
 err1 = COPY M1_ORCS_2_AREA
 err1 NOT INSIDE SealR_NOT_BULK
}

M1_ORCS_3 {
@ Space between M1 line-end and M1 when PRL > -0.015um. >= 0.08um
@ M1 line-end definition: (width < 0.046um, 90-90 inner angles), except INST region
 err1 = COPY M1_ORCS_3_AREA
 err1 NOT INSIDE SealR_NOT_BULK
}
#ENDIF

M1_ORCS_1_single = EXT M1 < 0.058 OPPOSITE EXTENDED 0.015 NOTCH
M1_ORCS_2_single_TMP = EXT M1_ORCS_2_true_CHK < 0.063 OPPOSITE EXTENDED 0.015 NOTCH
M1_ORCS_3_single_TMP = EXT (M1 TOUCH EDGE M1_end_DP) M1 < M1_ORCS_3_val OPPOSITE EXTENDED 0.015 NOTCH
M1_ORCS_1a_single_TMP = EXT M1 < 0.058 CORNER TO CORNER NOTCH
M1_ORCS_2_single = DFM PROPERTY M1_ORCS_2_single_TMP DRC:1_NOT_INST OVERLAP ABUT ALSO MULTI [-= (count(DRC:1_NOT_INST) > 0) ? 1 : 0] > 0
M1_ORCS_3_single = DFM PROPERTY M1_ORCS_3_single_TMP DRC:1_NOT_INST OVERLAP ABUT ALSO MULTI [-= (count(DRC:1_NOT_INST) > 0) ? 1 : 0] > 0
M1_ORCS_1a_single = DFM PROPERTY M1_ORCS_1a_single_TMP [-= (EWXP(M1_ORCS_1a_single_TMP) >= 0.015 && EWYP(M1_ORCS_1a_single_TMP) >= 0.015) ? 1 : 0] > 0

M1_OR_1 {
@ OR-AREA formed by single polygon is not allowed, except LOGO region
 err1 = DFM COPY M1_ORCS_1_single M1_ORCS_2_single M1_ORCS_3_single M1_ORCS_1a_single REGION
 err2 = EXT M1 < 0.058 ABUT<90 NOTCH REGION
 err1 NOT INSIDE LOGO
 err2 NOT INSIDE LOGO
}

M1_OR_3 {
@ M1.OR.3: OR-AREA count of the close loop formed by original polygons and OR-AREA cannot be odd number
@ M1.OR.2: ORCA cross another ORCA or touch ORLA is not allowed
//;M1.OR.2 never happen in calibre mp engine
 err1 = COPY M1_conflict_rings
 err1 NOT INSIDE SealR_NOT_BULK
}

M1_OR_3_warning {
@ M1 DP even cycles associated with an odd cycle violation
@ Avoid fixing odd cycle locations that touch a warning ring
 err1 = M1_warning_rings INTERACT M1_conflict_rings
 err1 NOT INSIDE SealR_NOT_BULK
}

M1_OR_4 {
@ M1DPMK must be drawn identically to M1
 err1 = M1DPMK NOT COIN EDGE M1
 err2 = M1DPMK NOT M1
 err1 NOT INSIDE EDGE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

M1_OR_5 {
@ (M1 INTERACT M1DPMK) INTERACT ORLS or ORCS is not allowed
 err1 = M1_ORCS_AREA INTERACT (M1 INTERACT M1DPMK) SINGULAR ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

M1_OR_6 {
@ (M1 INTERACT INST) INTERACT M1DPMK is not allowed
 err1 = (M1 INTERACT INST) INTERACT M1DPMK SINGULAR ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

M1_OR_7 {
@ Pre-coloring marker M1CA and M1CB must be drawn identically to M1
 err1 = M1CA NOT COIN EDGE M1
 err2 = M1CB NOT COIN EDGE M1
 err3 = M1CA NOT M1
 err4 = M1CB NOT M1
 err1 NOT INSIDE EDGE SealR_NOT_BULK
 err2 NOT INSIDE EDGE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
 err4 NOT INSIDE SealR_NOT_BULK
}

M1_OR_8 {
@ M1CA INTERACT M1CB is not allowed
 err1 = M1CA INTERACT M1CB SINGULAR ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

M1_OR_9 {
@ (M1 INTERACT INST) INTERACT (M1CA OR M1CB) is not allowed
 err1 = (M1CA OR M1CB) INTERACT (M1 INTERACT INST) SINGULAR ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

M1_OR_10 {
@ (M1CA OR M1CB) INTERACT M1DPMK is not allowed
 err1 = (M1CA OR M1CB) INTERACT M1DPMK SINGULAR ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

M1_OR_11_12_13 {
@ OR-AREA count of any path starting from M1CA and ending at M1CA must not be an odd number
@ OR-AREA count of any path starting from M1CB and ending at M1CB must not be an odd number
@ OR-AREA count of any path starting from M1CA and ending at M1CB must not be an even number
 err1 = COPY M1_conflict_anchor
 err1 NOT INSIDE SealR_NOT_BULK
}

M1_OR_14 {
@ Maximum pre-coloring ratio of ((M1CA + M1CB + M1DPMK)/M1) before decomposition < 16%
 check_pattern = (M1CA OR M1CB) OR M1DPMK
 check_region = COPY M1
 DENSITY check_pattern check_region [AREA(check_pattern)/AREA(check_region)] >= 0.16 PRINT "./SMIC_14SFPLUS_DRC_logFile/pre_coloring_ratio_M1_OR_14.log" RDB "./SMIC_14SFPLUS_DRC_logFile/pre_coloring_ratio_M1_OR_14.rdb"
}
#ENDIF


#IFDEF DOUBLE_PATTERNING_RULES_CHECK YES


LITHO FILE M2dpcfile [
resolve;
action M2_ORCS_1 has nicety of -1 and requires opposite masks;
action M2_ORCS_2 has nicety of -1 and requires opposite masks;
action M2_ORCS_3 has nicety of -1 and requires opposite masks;

anchor M2CA has nicety of -1 is for mask0;
anchor M2CB has nicety of -1 is for mask1;
output all conflicts;
]


LITHO FILE M3dpcfile [
resolve;
action M3_ORCS_1 has nicety of -1 and requires opposite masks;
action M3_ORCS_2 has nicety of -1 and requires opposite masks;
action M3_ORCS_3 has nicety of -1 and requires opposite masks;

anchor M3CA has nicety of -1 is for mask0;
anchor M3CB has nicety of -1 is for mask1;
output all conflicts;
]


#ENDIF


// =======================================================
// Mxy design rules (double patterning process)
// =======================================================

 //;---------------M${j} design rules --------------- 
GROUP GM2 M2_?
// 
M2_end_0.050 = LENGTH M2_end <= 0.05
M2_end_0.038 = LENGTH M2_end <= 0.038
M2_end_0.064 = LENGTH M2_convex_90_90_edges <= 0.064
met2_38_side = INT [M2] <= 0.038 ABUT<90 OPPOSITE
met2_48_side = INT [M2] <= 0.048 ABUT<90 OPPOSITE
met2_64_side = INT [M2] <= 0.064 ABUT<90 OPPOSITE
met2_wide_eqgt_150 = M2 WITH WIDTH >= 0.15
// 
M2_end_0.052 = LENGTH M2_end < 0.052
M2_end_0.055 = LENGTH M2_end < 0.055
M2_end_0.048 = LENGTH M2_end < 0.048
M2_end_0.046 = LENGTH M2_end < 0.046
M2_end_0.046_0.051 = LENGTH M2_end > 0.046 <= 0.051
M2_end_0.032_0.047 = LENGTH M2_end >= 0.032 <= 0.047
M2_end_0.032_0.051 = LENGTH M2_end >= 0.032 <= 0.051
M2_end_0.048_0.051 = LENGTH M2_end >= 0.048 <= 0.051
// 
M2_WIDTH_eq_024 = M2 WITH WIDTH == 0.024
M2_WIDTH_eq_028 = M2 WITH WIDTH == 0.028
M2_WIDTH_eq_032 = M2 WITH WIDTH == 0.032
M2_WIDTH_gt_024 = M2 WITH WIDTH >= 0.024
M2_WIDTH_gt_028 = M2_WIDTH_gt_024 WITH WIDTH >= 0.028
M2_WIDTH_gt_032 = M2_WIDTH_gt_028 WITH WIDTH >= 0.032
M2_WIDTH_gt_048 = M2_WIDTH_gt_032 WITH WIDTH >= 0.048
M2_WIDTH_lt_032 = M2 WITH WIDTH < 0.032
M2_WIDTH_eq_024_028 = OR M2_WIDTH_eq_024 M2_WIDTH_eq_028
// 
M2_eq_024_end = LENGTH M2_convex_90_90_edges == 0.024
M2_eq_028_end = LENGTH M2_convex_90_90_edges == 0.028
M2_eq_048_end = LENGTH M2_convex_90_90_edges == 0.048
M2_eq_024_028_end = OR EDGE M2_eq_024_end M2_eq_028_end
M2_eq_024_048_end = OR EDGE M2_eq_024_end M2_eq_048_end
// 
M2_lt_050_end = LENGTH M2_convex_90_90_edges < 0.050
M2_lt_052_end = LENGTH M2_convex_90_90_edges < 0.052
M2_lt_072_end = LENGTH M2_convex_90_90_edges <= 0.072
M2_eq_032_lt_048_end = LENGTH M2_convex_90_90_edges >= 0.032 < 0.048
M2_eq_048_lt_052_end = LENGTH M2_convex_90_90_edges >= 0.048 < 0.052
// 
M2_width_lt_037_opp_edges = INT [M2] < 0.037 ABUT<90 OPPOSITE PARA ONLY
M2_width_lt_032_opp_edges = INT [M2] < 0.032 ABUT<90 OPPOSITE PARA ONLY
// 
Mxy2_GROUP_48 = SIZE (SIZE (SIZE M2_WIDTH_eq_024 BY 0.012) BY -0.024) BY 0.012
Mxy2_GROUP_64 = SIZE (SIZE (SIZE M2_WIDTH_eq_032 BY 0.016) BY -0.032) BY 0.016
 

#IFDEF MANUFACTURABILITY_ENHANCEMENT_RULES YES

M2_S_9_ME {
@ Space between Mxy line and line-end (W < 0.046um) when PRL > -0.022um, except INST region >= 0.07um
 err1 = EXT M2 M2_end_0.046 < 0.07 ABUT<90 OPPOSITE EXTENDED 0.022 REGION
 err1 NOT INSIDE INST
}
 
M2_A_1_ME {
@ M2 Area, except INST region >= 0.0066um2
 err1 = AREA M2 < 0.0066
 err1 NOT INSIDE INST
}
 
M2_R_6_RV1_ME {
@ U-shape Mxy is not allowed, except INST region
@ DRC check condition:
@ 1. With at least one RVy or RVy-1
@ 2. Mxy width W <= 0.038um
@ 3. S <= 0.12um
 ushape_opp = LENGTH M2_convex_270_270_edges <= 0.120
 ushape_wid = INT ushape_opp M2_convex_gt_one_edges <= 0.038 OPPOSITE
 ushape_edg = ushape_opp COIN EDGE (DFM COPY ushape_wid EDGE)
 ushape_met = (M2 WITH EDGE ushape_edg) INTERACT RV1
 ushape_chk = ushape_edg COIN EDGE ushape_met
 ushape_038 = (EXPAND EDGE ushape_chk INSIDE BY 0.038) AND M2
 ushape_via = (SIZE ushape_038 BY 0.12 INSIDE OF M2 STEP 0.01) INTERACT RV1
 ushape_err = DFM PROPERTY ushape_wid ushape_via OVERLAP ABUT ALSO MULTI [s= area(ushape_via)] > 0 [w= min(ew(ushape_wid))] > 0
 // 
 err1 = copy (DFM COPY ushape_err REGION)
 err1 NOT INSIDE INST
}
 
M2_R_6_RV2_ME {
@ U-shape Mxy is not allowed, except INST region
@ DRC check condition:
@ 1. With at least one RVy or RVy-1
@ 2. Mxy width W <= 0.038um
@ 3. S <= 0.12um
 ushape_opp = LENGTH M2_convex_270_270_edges <= 0.120
 ushape_wid = INT ushape_opp M2_convex_gt_one_edges <= 0.038 OPPOSITE
 ushape_edg = ushape_opp COIN EDGE (DFM COPY ushape_wid EDGE)
 ushape_met = (M2 WITH EDGE ushape_edg) INTERACT RV2
 ushape_chk = ushape_edg COIN EDGE ushape_met
 ushape_038 = (EXPAND EDGE ushape_chk INSIDE BY 0.038) AND M2
 ushape_via = (SIZE ushape_038 BY 0.12 INSIDE OF M2 STEP 0.01) INTERACT RV2
 ushape_err = DFM PROPERTY ushape_wid ushape_via OVERLAP ABUT ALSO MULTI [s= area(ushape_via)] > 0 [w= min(ew(ushape_wid))] > 0
 // 
 err1 = copy (DFM COPY ushape_err REGION)
 err1 NOT INSIDE INST
}
 
M2_R_6_RV3_ME {
@ U-shape Mxy is not allowed, except INST region
@ DRC check condition:
@ 1. With at least one RVy or RVy-1
@ 2. Mxy width W <= 0.038um
@ 3. S <= 0.12um
 ushape_opp = LENGTH M2_convex_270_270_edges <= 0.120
 ushape_wid = INT ushape_opp M2_convex_gt_one_edges <= 0.038 OPPOSITE
 ushape_edg = ushape_opp COIN EDGE (DFM COPY ushape_wid EDGE)
 ushape_met = (M2 WITH EDGE ushape_edg) INTERACT RV3
 ushape_chk = ushape_edg COIN EDGE ushape_met
 ushape_038 = (EXPAND EDGE ushape_chk INSIDE BY 0.038) AND M2
 ushape_via = (SIZE ushape_038 BY 0.12 INSIDE OF M2 STEP 0.01) INTERACT RV3
 ushape_err = DFM PROPERTY ushape_wid ushape_via OVERLAP ABUT ALSO MULTI [s= area(ushape_via)] > 0 [w= min(ew(ushape_wid))] > 0
 // 
 err1 = DFM COPY ushape_err REGION
 err1 NOT INSIDE INST
}
 
M2_R_7_V1_ME {
@ It's not allowed to use Hook-shape Mxy, except INST region
@ Hook-shape Mxy definition:
@ (1) Hook-end line width(W1) is <= 0.05um, length(L1) <= 0.15um, ΔL > 0.1um and Hook-end interact one via
@ (2) W2/W3 width <= 0.072um
@ (3) Space between two Mxy arms(S1) <= 0.1um
@ (4) Space between via and another Mxy S2 <= 0.038um when PRL > -0.015um
@ DRC waive if hook-end enclosure via >= 0.05um
 hook_neck = CONVEX EDGE M2 ANGLE1==270 LENGTH1<=0.15 ANGLE2==270 LENGTH2>0 WITH LENGTH <= 0.100
 hook_neck_ege = hook_neck NOT TOUCH EDGE (INT (hook_neck) M2 <= 0.072 ABUT<90 OPPOSITE)
 hook_neck_exd = EXPAND EDGE hook_neck_ege OUTSIDE BY 0.01
 hook_neck_sid = M2 COIN EDGE hook_neck_exd
 // 
 hook_seek = (M2 WITH EDGE hook_neck_ege) WITH EDGE M2_end_0.050
 hook_head_sid = INT [hook_seek] <= 0.05 ABUT<90 OPPOSITE
 hook_head_end = M2_end_0.050 TOUCH EDGE hook_seek
 hook_head_end_r = M2_end_0.050 TOUCH EDGE (OR EDGE (ENC V1 [hook_head_end] < 0.05 ABUT<90 OPPOSITE) (ENC V2 [hook_head_end] < 0.05 ABUT<90 OPPOSITE))
 hook_head_via_b = V1 WITH EDGE (ENC [V1] hook_head_end < 0.05 ABUT<90 OPPOSITE)
 hook_head_via_u = V2 WITH EDGE (ENC [V2] hook_head_end < 0.05 ABUT<90 OPPOSITE)
 hook_head_via_b_sid = ENC [hook_head_via_b] hook_head_sid <= 0.018 ABUT<90 OPPOSITE
 hook_head_via_u_sid = ENC [hook_head_via_u] hook_head_sid <= 0.018 ABUT<90 OPPOSITE
 hook_head_via = hook_head_via_b WITH EDGE (EXT M2 [hook_head_via_b_sid] < 0.038+GLOBAL_TOLERANCE ABUT<90 OPPOSITE EXTENDED 0.015 MEASURE ALL)
 // 
 hook_seek_met = hook_seek ENCLOSE hook_head_via
 hook_neck_cor = EXT [hook_seek_met] < 0.005 ABUT==90 INTERSECTING ONLY
 hook_neck_err = EXT hook_neck_cor <= 0.100 ABUT<90 OPPOSITE
 hook_neck_arm = hook_seek_met TOUCH EDGE hook_neck_cor
 hook_neck_dtl = DFM PROPERTY hook_neck_err hook_neck_arm OVERLAP ABUT ALSO MULTI [dt_l = max(length(hook_neck_arm)) - min(length(hook_neck_arm))]
 // 
 hook_head_a = (INT (M2_convex_gt_one_edges TOUCH EDGE hook_seek_met) <= 0.05 OPPOSITE REGION) WITH EDGE hook_head_end_r
 hook_head_b = NOT ENCLOSE RECTANGLE hook_head_a 0.001 0.150+GLOBAL_TOLERANCE ORTHOGONAL ONLY
 hook_head = hook_head_b NOT OUTSIDE hook_head_via
 hook_tail = INT (hook_neck_sid) M2 <= 0.072 ABUT<90 OPPOSITE
 hook_gain = DFM PROPERTY hook_neck_err hook_tail hook_head hook_neck_dtl OVERLAP ABUT ALSO MULTI 
 [-= (count(hook_head) > 0 && count(hook_tail) == 0) ? 1 : 0] > 0 [dt_l = property(hook_neck_dtl,dt_l)] > 0.10
 err1 = copy (DFM COPY hook_gain REGION)
 err1 NOT INSIDE INST
}
 
M2_R_7_V2_ME {
@ It's not allowed to use Hook-shape Mxy, except INST region
@ Hook-shape Mxy definition:
@ (1) Hook-end line width(W1) is <= 0.05um, length(L1) <= 0.15um, ΔL > 0.1um and Hook-end interact one via
@ (2) W2/W3 width <= 0.072um
@ (3) Space between two Mxy arms(S1) <= 0.1um
@ (4) Space between via and another Mxy S2 <= 0.038um when PRL > -0.015um
@ DRC waive if hook-end enclosure via >= 0.05um
 hook_neck = CONVEX EDGE M2 ANGLE1==270 LENGTH1<=0.15 ANGLE2==270 LENGTH2>0 WITH LENGTH <= 0.100
 hook_neck_ege = hook_neck NOT TOUCH EDGE (INT (hook_neck) M2 <= 0.072 ABUT<90 OPPOSITE)
 hook_neck_exd = EXPAND EDGE hook_neck_ege OUTSIDE BY 0.01
 hook_neck_sid = M2 COIN EDGE hook_neck_exd
 // 
 hook_seek = (M2 WITH EDGE hook_neck_ege) WITH EDGE M2_end_0.050
 hook_head_sid = INT [hook_seek] <= 0.05 ABUT<90 OPPOSITE
 hook_head_end = M2_end_0.050 TOUCH EDGE hook_seek
 hook_head_end_r = M2_end_0.050 TOUCH EDGE (OR EDGE (ENC V1 [hook_head_end] < 0.05 ABUT<90 OPPOSITE) (ENC V2 [hook_head_end] < 0.05 ABUT<90 OPPOSITE))
 hook_head_via_b = V1 WITH EDGE (ENC [V1] hook_head_end < 0.05 ABUT<90 OPPOSITE)
 hook_head_via_u = V2 WITH EDGE (ENC [V2] hook_head_end < 0.05 ABUT<90 OPPOSITE)
 hook_head_via_b_sid = ENC [hook_head_via_b] hook_head_sid <= 0.018 ABUT<90 OPPOSITE
 hook_head_via_u_sid = ENC [hook_head_via_u] hook_head_sid <= 0.018 ABUT<90 OPPOSITE
 hook_head_via = hook_head_via_u WITH EDGE (EXT M2 [hook_head_via_u_sid] < 0.038+GLOBAL_TOLERANCE ABUT<90 OPPOSITE EXTENDED 0.015 MEASURE ALL)
 // 
 hook_seek_met = hook_seek ENCLOSE hook_head_via
 hook_neck_cor = EXT [hook_seek_met] < 0.005 ABUT==90 INTERSECTING ONLY
 hook_neck_err = EXT hook_neck_cor <= 0.100 ABUT<90 OPPOSITE
 hook_neck_arm = hook_seek_met TOUCH EDGE hook_neck_cor
 hook_neck_dtl = DFM PROPERTY hook_neck_err hook_neck_arm OVERLAP ABUT ALSO MULTI [dt_l = max(length(hook_neck_arm)) - min(length(hook_neck_arm))]
 // 
 hook_head_a = (INT (M2_convex_gt_one_edges TOUCH EDGE hook_seek_met) <= 0.05 OPPOSITE REGION) WITH EDGE hook_head_end_r
 hook_head_b = NOT ENCLOSE RECTANGLE hook_head_a 0.001 0.150+GLOBAL_TOLERANCE ORTHOGONAL ONLY
 hook_head = hook_head_b NOT OUTSIDE hook_head_via
 hook_tail = INT (hook_neck_sid) M2 <= 0.072 ABUT<90 OPPOSITE
 hook_gain = DFM PROPERTY hook_neck_err hook_tail hook_head hook_neck_dtl OVERLAP ABUT ALSO MULTI 
 [-= (count(hook_head) > 0 && count(hook_tail) == 0) ? 1 : 0] > 0 [dt_l = property(hook_neck_dtl,dt_l)] > 0.10
 err1 = copy (DFM COPY hook_gain REGION)
 err1 NOT INSIDE INST
}

#ENDIF

 

#IFDEF DFM_RULES_PRIORITY_1 YES

M2_W_1_DFM1 {
@ Recommended Mxy width to reduce the line open possibility, except MOMDMY and EFUSE regions >= 0.046um
 err1 = INT M2 < 0.046 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE (OR MOMDMY EFUSE)
}
 
M2_S_1_DFM1 {
@ Recommend Mxy space to reduce the short possibility, except MOMDMY region >= 0.044um
 err1 = EXT M2 < 0.044 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE MOMDMY
}
 
chk_M2_070 = M2 WITH WIDTH > 0.07
chk_M2_088 = chk_M2_070 WITH WIDTH > 0.088
chk_M2_112 = chk_M2_088 WITH WIDTH > 0.112
chk_M2_180 = chk_M2_112 WITH WIDTH > 0.180
chk_M2_270 = chk_M2_180 WITH WIDTH > 0.270
 
M2_S_2_DFM1 {
@ Recommended Mxy space when either one Mxy width > 0.07um. >= 0.072um
 err1 = EXT chk_M2_070 M2 < 0.072 ABUT<90 REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
M2_S_3_DFM1 {
@ Recommended Mxy space when either one Mxy width > 0.088um. >= 0.081um
 err1 = EXT chk_M2_088 M2 < 0.081 ABUT<90 REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
M2_S_4_DFM1 {
@ Recommended Mxy space when either one Mxy width > 0.112um, except EFUSE region >= 0.106um
 err1 = EXT chk_M2_112 M2 < 0.106 ABUT<90 REGION
 err1 NOT INSIDE EFUSE
}
 
M2_S_5_DFM1 {
@ Recommended Mxy space when either one Mxy width > 0.18um, except EFUSE region >= 0.126um
 err1 = EXT chk_M2_180 M2 < 0.126 ABUT<90 REGION
 err1 NOT INSIDE EFUSE
}
 
M2_S_6_DFM1 {
@ Recommended Mxy space when either one Mxy width > 0.27um. >= 0.144um
 err1 = EXT chk_M2_270 M2 < 0.144 ABUT<90 REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
M2_S_9a_DFM1 {
@ Space between Mxy line and line-end (W < 0.046um, PRL > -0.022um) >= 0.070um
 err1 = EXT M2 M2_end_0.046 < 0.070 ABUT<90 OPPOSITE EXTENDED 0.022 REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
M2_S_9b_DFM1 {
@ Space between Mxy line and line-end (0.046 < W <= 0.051um, PRL > -0.022um) >= 0.063um
 err1 = EXT M2 M2_end_0.046_0.051 < 0.063 ABUT<90 OPPOSITE EXTENDED 0.022 REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
M2_S_10_DFM1 {
@ Recommended space between Mxy line-end (width <= 0.051um) and line-end (width < 0.048um) when PRL > -0.022um. >= 0.081um
 err1 = EXT M2_end_0.052 M2_end_0.048 < 0.081 ABUT<90 OPPOSITE EXTENDED 0.022 REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
M2_A_1_DFM1 {
@ Recommended Mxy area >= 0.01um2
 err1 = AREA M2 < 0.01
 err1 NOT INSIDE SealR_NOT_BULK
}
 
M2_R_2_DFM1 {
@ Recommended M2 forbidden zone of ((W1+S1+W2+S2) or (S1+W2+S2+W3)) when Mxy width < 0.037um. = 0.14~0.175um
@ DRC flags the edge of forbidden zone and waive the violation in same polygon
 M2_NOTCH = EXT [M2] <= 0.08 ABUT<90 OPPOSITE
 M2_NOTCH_A = EXT (M2_v_edges COIN EDGE M2_NOTCH) <= 0.112 ABUT<90 OPPOSITE PARA ONLY NOTCH REGION EXCLUDE SHIELDED
 M2_NOTCH_A_all = M2_v_edges OR EDGE (M2_NOTCH_A COIN EDGE M2_v_edges)
 M2_ERR_P1 = DFM SPACE M2_NOTCH_A_all M2_width_lt_037_opp_edges >= 0.140 <= 0.175 BY ENC MEASURE ALL COUNT == 3 BY LAYER M2_NOTCH_A_all
 M2_ERR_P2 = DFM SPACE M2_width_lt_037_opp_edges M2_NOTCH_A_all >= 0.140 <= 0.175 BY ENC MEASURE ALL COUNT == 3 BY LAYER M2_NOTCH_A_all
 err1 = DFM PROPERTY M2_ERR_P1 M2_COLORA M2_COLORB M2_width_lt_037_opp_edges OVERLAP ABUT ALSO MULTI 
 [+= count(M2_width_lt_037_opp_edges)] > 0 
 [-= (EC(M2_ERR_P1) > 0 && (count(M2_COLORA) > 1 || count(M2_COLORB) > 1 || count(M2_COLORA) == 0 || count(M2_COLORB) == 0)) ? 1 : 0 ] > 0
 err2 = DFM PROPERTY M2_ERR_P2 M2_COLORA M2_COLORB M2_width_lt_037_opp_edges OVERLAP ABUT ALSO MULTI 
 [+= count(M2_width_lt_037_opp_edges)] > 0 
 [-= (EC(M2_ERR_P2) > 0 && (count(M2_COLORA) > 1 || count(M2_COLORB) > 1 || count(M2_COLORA) == 0 || count(M2_COLORB) == 0)) ? 1 : 0 ] > 0
 DFM COPY err1 err2
 // 
 M2_NOTCH_B = EXT (M2_h_edges COIN EDGE M2_NOTCH) <= 0.112 ABUT<90 OPPOSITE PARA ONLY NOTCH REGION EXCLUDE SHIELDED
 M2_NOTCH_B_all = M2_h_edges OR EDGE (M2_NOTCH_B COIN EDGE M2_h_edges)
 M2_ERR_P3 = DFM SPACE M2_NOTCH_B_all M2_width_lt_037_opp_edges >= 0.140 <= 0.175 BY ENC MEASURE ALL COUNT == 3 BY LAYER M2_NOTCH_B_all
 M2_ERR_P4 = DFM SPACE M2_width_lt_037_opp_edges M2_NOTCH_B_all >= 0.140 <= 0.175 BY ENC MEASURE ALL COUNT == 3 BY LAYER M2_NOTCH_B_all
 err3 = DFM PROPERTY M2_ERR_P3 M2_COLORA M2_COLORB M2_width_lt_037_opp_edges OVERLAP ABUT ALSO MULTI 
 [+= count(M2_width_lt_037_opp_edges)] > 0 
 [-= (EC(M2_ERR_P3) > 0 && (count(M2_COLORA) > 1 || count(M2_COLORB) > 1 || count(M2_COLORA) == 0 || count(M2_COLORB) == 0)) ? 1 : 0 ] > 0
 err4 = DFM PROPERTY M2_ERR_P4 M2_COLORA M2_COLORB M2_width_lt_037_opp_edges OVERLAP ABUT ALSO MULTI 
 [+= count(M2_width_lt_037_opp_edges)] > 0 
 [-= (EC(M2_ERR_P4) > 0 && (count(M2_COLORA) > 1 || count(M2_COLORB) > 1 || count(M2_COLORA) == 0 || count(M2_COLORB) == 0)) ? 1 : 0 ] > 0
 DFM COPY err3 err4
}
 
M2_R_6_RV1_DFM1 {
@ It's not recommended to use U-shape Mxy
@ DRC check condition:
@ 1. With at least one RVy or RVy-1
@ 2. Mxy width W <= 0.038um
@ 3. S <= 0.12um
@ Which rule is not applied for INST region
 ushape_opp = LENGTH M2_convex_270_270_edges <= 0.120
 ushape_wid = INT ushape_opp M2_convex_gt_one_edges <= 0.038 OPPOSITE
 ushape_edg = ushape_opp COIN EDGE (DFM COPY ushape_wid EDGE)
 ushape_met = (M2 WITH EDGE ushape_edg) INTERACT RV1
 ushape_chk = ushape_edg COIN EDGE ushape_met
 ushape_038 = (EXPAND EDGE ushape_chk INSIDE BY 0.038) AND M2
 ushape_via = (SIZE ushape_038 BY 0.12 INSIDE OF M2 STEP 0.01) INTERACT RV1
 ushape_err = DFM PROPERTY ushape_wid ushape_via OVERLAP ABUT ALSO MULTI [s= area(ushape_via)] > 0 [w= min(ew(ushape_wid))] > 0
 // 
 err1 = DFM COPY ushape_err REGION
 err1 NOT INSIDE INST
}
 
M2_R_6_RV2_DFM1 {
@ It's not recommended to use U-shape Mxy
@ DRC check condition:
@ 1. With at least one RVy or RVy-1
@ 2. Mxy width W <= 0.038um
@ 3. S <= 0.12um
@ Which rule is not applied for INST region
 ushape_opp = LENGTH M2_convex_270_270_edges <= 0.120
 ushape_wid = INT ushape_opp M2_convex_gt_one_edges <= 0.038 OPPOSITE
 ushape_edg = ushape_opp COIN EDGE (DFM COPY ushape_wid EDGE)
 ushape_met = (M2 WITH EDGE ushape_edg) INTERACT RV2
 ushape_chk = ushape_edg COIN EDGE ushape_met
 ushape_038 = (EXPAND EDGE ushape_chk INSIDE BY 0.038) AND M2
 ushape_via = (SIZE ushape_038 BY 0.12 INSIDE OF M2 STEP 0.01) INTERACT RV2
 ushape_err = DFM PROPERTY ushape_wid ushape_via OVERLAP ABUT ALSO MULTI [s= area(ushape_via)] > 0 [w= min(ew(ushape_wid))] > 0
 // 
 err1 = DFM COPY ushape_err REGION
 err1 NOT INSIDE INST
}
 
M2_R_7_V1_DFM1 {
@ It's not recommended to use Hook-shape Mxy
@ Hook-shape Mxy definition:
@ (1) Hook-end line width(W1) is <= 0.05um, length(L1) <= 0.15um, ΔL > 0.1um and Hook-end interact one via
@ (2) W2/W3 width <= 0.072um
@ (3) Space between two Mxy arms(S1) <= 0.1um
@ (4) Space between via and another Mxy S2 <= 0.038um when PRL > -0.015um
@ DRC waive if hook-end enclosure via >= 0.05um
@ This rule is not applied for INST region
 hook_neck = CONVEX EDGE M2 ANGLE1==270 LENGTH1<=0.15 ANGLE2==270 LENGTH2>0 WITH LENGTH <= 0.100
 hook_neck_ege = hook_neck NOT TOUCH EDGE (INT (hook_neck) M2 <= 0.072 ABUT<90 OPPOSITE)
 hook_neck_exd = EXPAND EDGE hook_neck_ege OUTSIDE BY 0.01
 hook_neck_sid = M2 COIN EDGE hook_neck_exd
 // 
 hook_seek = (M2 WITH EDGE hook_neck_ege) WITH EDGE M2_end_0.050
 hook_head_sid = INT [hook_seek] <= 0.05 ABUT<90 OPPOSITE
 hook_head_end = M2_end_0.050 TOUCH EDGE hook_seek
 hook_head_end_r = M2_end_0.050 TOUCH EDGE (OR EDGE (ENC V1 [hook_head_end] < 0.05 ABUT<90 OPPOSITE) (ENC V2 [hook_head_end] < 0.05 ABUT<90 OPPOSITE))
 hook_head_via_b = V1 WITH EDGE (ENC [V1] hook_head_end < 0.05 ABUT<90 OPPOSITE)
 hook_head_via_u = V2 WITH EDGE (ENC [V2] hook_head_end < 0.05 ABUT<90 OPPOSITE)
 hook_head_via_b_sid = ENC [hook_head_via_b] hook_head_sid <= 0.018 ABUT<90 OPPOSITE
 hook_head_via_u_sid = ENC [hook_head_via_u] hook_head_sid <= 0.018 ABUT<90 OPPOSITE
 hook_head_via = hook_head_via_b WITH EDGE (EXT M2 [hook_head_via_b_sid] < 0.038+GLOBAL_TOLERANCE ABUT<90 OPPOSITE EXTENDED 0.015 MEASURE ALL)
 // 
 hook_seek_met = hook_seek ENCLOSE hook_head_via
 hook_neck_cor = EXT [hook_seek_met] < 0.005 ABUT==90 INTERSECTING ONLY
 hook_neck_err = EXT hook_neck_cor <= 0.100 ABUT<90 OPPOSITE
 hook_neck_arm = hook_seek_met TOUCH EDGE hook_neck_cor
 hook_neck_dtl = DFM PROPERTY hook_neck_err hook_neck_arm OVERLAP ABUT ALSO MULTI [dt_l = max(length(hook_neck_arm)) - min(length(hook_neck_arm))]
 // 
 hook_head_a = (INT (M2_convex_gt_one_edges TOUCH EDGE hook_seek_met) <= 0.05 OPPOSITE REGION) WITH EDGE hook_head_end_r
 hook_head_b = NOT ENCLOSE RECTANGLE hook_head_a 0.001 0.150+GLOBAL_TOLERANCE ORTHOGONAL ONLY
 hook_head = hook_head_b NOT OUTSIDE hook_head_via
 hook_tail = INT (hook_neck_sid) M2 <= 0.072 ABUT<90 OPPOSITE
 hook_gain = DFM PROPERTY hook_neck_err hook_tail hook_head hook_neck_dtl OVERLAP ABUT ALSO MULTI 
 [-= (count(hook_head) > 0 && count(hook_tail) == 0) ? 1 : 0] > 0 [dt_l = property(hook_neck_dtl,dt_l)] > 0.10
 err1 = DFM COPY hook_gain REGION
 err1 NOT INSIDE INST
}
 
M2_R_7_V2_DFM1 {
@ It's not recommended to use Hook-shape Mxy
@ Hook-shape Mxy definition:
@ (1) Hook-end line width(W1) is <= 0.05um, length(L1) <= 0.15um, ΔL > 0.1um and Hook-end interact one via
@ (2) W2/W3 width <= 0.072um
@ (3) Space between two Mxy arms(S1) <= 0.1um
@ (4) Space between via and another Mxy S2 <= 0.038um when PRL > -0.015um
@ DRC waive if hook-end enclosure via >= 0.05um
@ This rule is not applied for INST region
 hook_neck = CONVEX EDGE M2 ANGLE1==270 LENGTH1<=0.15 ANGLE2==270 LENGTH2>0 WITH LENGTH <= 0.100
 hook_neck_ege = hook_neck NOT TOUCH EDGE (INT (hook_neck) M2 <= 0.072 ABUT<90 OPPOSITE)
 hook_neck_exd = EXPAND EDGE hook_neck_ege OUTSIDE BY 0.01
 hook_neck_sid = M2 COIN EDGE hook_neck_exd
 // 
 hook_seek = (M2 WITH EDGE hook_neck_ege) WITH EDGE M2_end_0.050
 hook_head_sid = INT [hook_seek] <= 0.05 ABUT<90 OPPOSITE
 hook_head_end = M2_end_0.050 TOUCH EDGE hook_seek
 hook_head_end_r = M2_end_0.050 TOUCH EDGE (OR EDGE (ENC V1 [hook_head_end] < 0.05 ABUT<90 OPPOSITE) (ENC V2 [hook_head_end] < 0.05 ABUT<90 OPPOSITE))
 hook_head_via_b = V1 WITH EDGE (ENC [V1] hook_head_end < 0.05 ABUT<90 OPPOSITE)
 hook_head_via_u = V2 WITH EDGE (ENC [V2] hook_head_end < 0.05 ABUT<90 OPPOSITE)
 hook_head_via_b_sid = ENC [hook_head_via_b] hook_head_sid <= 0.018 ABUT<90 OPPOSITE
 hook_head_via_u_sid = ENC [hook_head_via_u] hook_head_sid <= 0.018 ABUT<90 OPPOSITE
 hook_head_via = hook_head_via_u WITH EDGE (EXT M2 [hook_head_via_u_sid] < 0.038+GLOBAL_TOLERANCE ABUT<90 OPPOSITE EXTENDED 0.015 MEASURE ALL)
 // 
 hook_seek_met = hook_seek ENCLOSE hook_head_via
 hook_neck_cor = EXT [hook_seek_met] < 0.005 ABUT==90 INTERSECTING ONLY
 hook_neck_err = EXT hook_neck_cor <= 0.100 ABUT<90 OPPOSITE
 hook_neck_arm = hook_seek_met TOUCH EDGE hook_neck_cor
 hook_neck_dtl = DFM PROPERTY hook_neck_err hook_neck_arm OVERLAP ABUT ALSO MULTI [dt_l = max(length(hook_neck_arm)) - min(length(hook_neck_arm))]
 // 
 hook_head_a = (INT (M2_convex_gt_one_edges TOUCH EDGE hook_seek_met) <= 0.05 OPPOSITE REGION) WITH EDGE hook_head_end_r
 hook_head_b = NOT ENCLOSE RECTANGLE hook_head_a 0.001 0.150+GLOBAL_TOLERANCE ORTHOGONAL ONLY
 hook_head = hook_head_b NOT OUTSIDE hook_head_via
 hook_tail = INT (hook_neck_sid) M2 <= 0.072 ABUT<90 OPPOSITE
 hook_gain = DFM PROPERTY hook_neck_err hook_tail hook_head hook_neck_dtl OVERLAP ABUT ALSO MULTI 
 [-= (count(hook_head) > 0 && count(hook_tail) == 0) ? 1 : 0] > 0 [dt_l = property(hook_neck_dtl,dt_l)] > 0.10
 err1 = DFM COPY hook_gain REGION
 err1 NOT INSIDE INST
}
 
M2_R_8_DFM1 {
@ It's not recommended to use dense Mxy line end pattern
@ DRC flage conditions:
@ (1) Middle Mxy line width(W1) <= 0.038um, both two neighbour Mxy lines width <= 0.064um
@ (2) Both the Vy-1 dense region (dense region definition: region formed by Vy-1 horizontal edge extension 0.038um, vertical edge extension 0.05um) horizontal edges neighbour Mxy line-end
@ DRC waive if Mxy enclosure Vy-1 > 0.05um. (Vy-1 is the via underneath Mxy)
@ This rule is not applied for INST region
 via_met = V1_SR NOT OUTSIDE (M2 WITH WIDTH <= 0.038)
 via_end = via_met TOUCH EDGE (ENC [via_met] M2_end_0.038 <= 0.05 ABUT<90 OPPOSITE)
 via_lin = (via_met NOT TOUCH EDGE via_end) TOUCH EDGE (ENC [via_met] met2_38_side <= 0.006 ABUT<90 OPPOSITE)
 via_mid = (via_met WITH EDGE via_end) WITH EDGE via_lin == 2
 via_sid = via_mid TOUCH EDGE via_lin
 // 
 nei_end = LENGTH M2_convex_90_90_edges <= 0.064
 nei_sid = LENGTH (EXPAND EDGE nei_end OUTSIDE BY 0.001) == 0.001
 nei_via = EXT [via_sid] nei_sid < 0.038+GLOBAL_TOLERANCE ABUT<90 OPPOSITE EXTENDED 0.050 MEASURE ALL
 err1 = via_mid WITH EDGE (via_mid TOUCH EDGE nei_via) >= 2
 err1 NOT INSIDE INST
}
 
M2_R_9_V1_DFM1 {
@ It's not recommended to use dense Mxy 3-bar pattern
@ DRC flag conditions:
@ (1) Middle Mxy line width(W1) is <= 0.048um, both two neighbour Mxy line width <= 0.064um and interact square or rectangle Vy or Vy-1
@ (2) Mxy Space to both via (S1/S2) = 0.058~0.063um
@ (3) The via PRL: -0.1 < PRL < 0.1um
@ (4) Both neighbour Mxy enclosure Vy or Vy-1 < 0.05um
@ This rule is not applied for INST region
 via_d_met = V1_SR NOT OUTSIDE (M2 WITH WIDTH <= 0.064)
 via_d_end = via_d_met TOUCH EDGE (ENC [via_d_met] M2_end_0.064 < 0.05 ABUT<90 OPPOSITE)
 via_d_lin = (via_d_met NOT TOUCH EDGE via_d_end) TOUCH EDGE (ENC [via_d_met] met2_64_side <= 0.032 ABUT<90 OPPOSITE)
 via_d_mid = (via_d_met WITH EDGE via_d_end) WITH EDGE via_d_lin >= 2
 via_d_sid = via_d_mid TOUCH EDGE via_d_lin
 via_d_sps = (EXT [met2_48_side] via_d_sid >= 0.058 <= 0.063 OPPOSITE EXTENDED 0.1 MEASURE ALL) TOUCH EDGE (EXT [met2_48_side] via_d_sid >= 0.058 <= 0.063 OPPOSITE MEASURE ALL)
 err1 = INT via_d_sps <= 0.048 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE INST
}
 
M2_R_9_V2_DFM1 {
@ It's not recommended to use dense Mxy 3-bar pattern
@ DRC flag conditions:
@ (1) Middle Mxy line width(W1) is <= 0.048um, both two neighbour Mxy line width <= 0.064um and interact square or rectangle Vy or Vy-1
@ (2) Mxy Space to both via (S1/S2) = 0.058~0.063um
@ (3) The via PRL: -0.1 < PRL < 0.1um
@ (4) Both neighbour Mxy enclosure Vy or Vy-1 < 0.05um
@ This rule is not applied for INST region
 via_u_met = V2_SR NOT OUTSIDE (M2 WITH WIDTH <= 0.064)
 via_u_end = via_u_met TOUCH EDGE (ENC [via_u_met] M2_end_0.064 < 0.05 ABUT<90 OPPOSITE)
 via_u_lin = (via_u_met NOT TOUCH EDGE via_u_end) TOUCH EDGE (ENC [via_u_met] met2_64_side <= 0.032 ABUT<90 OPPOSITE)
 via_u_mid = (via_u_met WITH EDGE via_u_end) WITH EDGE via_u_lin >= 2
 via_u_sid = via_u_mid TOUCH EDGE via_u_lin
 via_u_sps = (EXT [met2_48_side] via_u_sid >= 0.058 <= 0.063 OPPOSITE EXTENDED 0.1 MEASURE ALL) TOUCH EDGE (EXT [met2_48_side] via_u_sid >= 0.058 <= 0.063 OPPOSITE MEASURE ALL)
 err1 = INT via_u_sps <= 0.048 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE INST
}

#ENDIF

 
M2_W_1 {
@ Mxy width >= 0.032um
 err1 = INT M2 < 0.032 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
M2_W_2 {
@ Mxy width, except MARKS, and LOGO regions <= 2.1um
 err1 = (M2 NOT INSIDE MARKS_LOGO) WITH WIDTH > 2.1
 err1 NOT INSIDE MARKS_LOGO
}
 
M2_W_3 {
@ Metal branch width when connected to wide metal with both width and length >= 0.27um. >= 0.065um
 dorian_large = M2 WITH WIDTH >= 0.27
 dorian_whole = M2 INTERACT dorian_large
 dorian_large_exp = SIZE dorian_large BY 0.005 INSIDE OF dorian_whole
 dorian_branch_0 = dorian_whole NOT dorian_large
 dorian_branch_1 = dorian_branch_0 NOT COIN EDGE dorian_large
 dorian_branch_2 = dorian_branch_1 TOUCH EDGE dorian_large_exp
 err1 = INT dorian_branch_2 < 0.065 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
M2_W_4 {
@ Mxy branch width when connected to wide Mxy (width > 2um) which enclosed inner hole ((Mxy OR Mxy-hole) area >= 3050um2)
@ DRC checks the Mxy interact ((((Mxy OR Mxy-hole) sd 1um) su 1um) su 1um) >= 0.037um
 area_including_holes = AREA (M2 OR (HOLES M2 INNER EMPTY)) >= 3050
 met_WIDTH_gt_2 = SIZE area_including_holes BY 1 UNDEROVER
 met_SPACE_lt_2 = SIZE met_WIDTH_gt_2 BY 1
 // 
 err1_TMP = WITH WIDTH (M2 INTERACT met_SPACE_lt_2) < 0.037
 err1 = err1_TMP INTERACT met_SPACE_lt_2
 err1 NOT INSIDE SealR_NOT_BULK
}
 
M2_W_5 {
@ Width of 45-degree bent Mxy >= 0.152um
 err1 = INT M2_45_skew_edges < 0.152 OPPOSITE REGION EXCLUDE SHIELDED
 err1 NOT INSIDE SealR_NOT_BULK
}
 
M2_S_1 {
@ Space between two Mxy, except LOGO region >= 0.032um
 err1 = EXT M2 < 0.032 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE LOGO
}
 
M2_S_2 {
@ Space between Mxy when one or both Mxy width >= 0.071um and the PRL >= 0.14um. = 0.041~0.062, >= 0.072um
 met_wid_all = M2 WITH WIDTH >= 0.071
 met_err_RAW = (EXT [met_wid_all] M2 < 0.041 ABUT<90 OPPOSITE MEASURE ALL) OR EDGE (EXT [met_wid_all] M2 >= 0.063 < 0.072 ABUT<90 OPPOSITE MEASURE ALL)
 met_jog_ALL = (CONVEX EDGE M2 == 1) NOT COIN EDGE met_err_RAW
 met_jog_EXP_a = EXPAND EDGE met_jog_ALL INSIDE BY 0.0005
 met_jog_EXP_b = EXPAND EDGE met_jog_ALL OUTSIDE BY 0.0005
 met_jog_TMP = (met_jog_ALL COIN EDGE (met_jog_EXP_a WITH EDGE met_err_RAW)) COIN EDGE (met_jog_EXP_b WITH EDGE met_err_RAW)
 met_jog_EXP = ((VERTEX (EXPAND EDGE met_jog_TMP OUTSIDE BY 0.001 EXTEND BY 0.001) == 4) OR (EXPAND EDGE met_err_RAW OUTSIDE BY 0.001)) NOT M2
 // 
 met_err_PRL = DFM PROPERTY met_jog_EXP met_err_RAW OVERLAP ABUT ALSO MULTI [-= LENGTH(met_err_RAW)] > 0.140-GLOBAL_TOLERANCE
 met_err_EGE = met_err_RAW TOUCH EDGE met_err_PRL
 err1 = (EXT met_err_EGE M2 < 0.041 ABUT<90 OPPOSITE REGION MEASURE ALL) OR (EXT met_err_EGE M2 >= 0.063 < 0.072 ABUT<90 OPPOSITE REGION MEASURE ALL)
 err1 NOT INSIDE SealR_NOT_BULK
}
 
M2_S_3 {
@ Space between Mxy when one or both width >= 0.09um and PRL >= 0.14um. = 0.041~0.062, >= 0.081um
 met_wid_all = M2 WITH WIDTH >= 0.09
 met_err_RAW = (EXT [met_wid_all] M2 < 0.041 ABUT<90 OPPOSITE MEASURE ALL) OR EDGE (EXT [met_wid_all] M2 >= 0.063 < 0.081 ABUT<90 OPPOSITE MEASURE ALL)
 met_jog_ALL = (CONVEX EDGE M2 == 1) NOT COIN EDGE met_err_RAW
 met_jog_EXP_a = EXPAND EDGE met_jog_ALL INSIDE BY 0.0005
 met_jog_EXP_b = EXPAND EDGE met_jog_ALL OUTSIDE BY 0.0005
 met_jog_TMP = (met_jog_ALL COIN EDGE (met_jog_EXP_a WITH EDGE met_err_RAW)) COIN EDGE (met_jog_EXP_b WITH EDGE met_err_RAW)
 met_jog_EXP = ((VERTEX (EXPAND EDGE met_jog_TMP OUTSIDE BY 0.001 EXTEND BY 0.001) == 4) OR (EXPAND EDGE met_err_RAW OUTSIDE BY 0.001)) NOT M2
 // 
 met_err_PRL = DFM PROPERTY met_jog_EXP met_err_RAW OVERLAP ABUT ALSO MULTI [-= LENGTH(met_err_RAW)] > 0.140-GLOBAL_TOLERANCE
 met_err_EGE = met_err_RAW TOUCH EDGE met_err_PRL
 err1 = (EXT met_err_EGE M2 < 0.041 ABUT<90 OPPOSITE REGION MEASURE ALL) OR (EXT met_err_EGE M2 >= 0.063 < 0.081 ABUT<90 OPPOSITE REGION MEASURE ALL)
 err1 NOT INSIDE SealR_NOT_BULK
}
 
M2_S_4 {
@ Space between Mxy when one or both width >= 0.114um and PRL >= 0.14um, except LOGO region = 0.041~0.062, >= 0.106um
 met_wid_all = M2 WITH WIDTH >= 0.114
 met_err_RAW = (EXT [met_wid_all] M2 < 0.041 ABUT<90 OPPOSITE MEASURE ALL) OR EDGE (EXT [met_wid_all] M2 >= 0.063 < 0.106 ABUT<90 OPPOSITE MEASURE ALL)
 met_jog_ALL = (CONVEX EDGE M2 == 1) NOT COIN EDGE met_err_RAW
 met_jog_EXP_a = EXPAND EDGE met_jog_ALL INSIDE BY 0.0005
 met_jog_EXP_b = EXPAND EDGE met_jog_ALL OUTSIDE BY 0.0005
 met_jog_TMP = (met_jog_ALL COIN EDGE (met_jog_EXP_a WITH EDGE met_err_RAW)) COIN EDGE (met_jog_EXP_b WITH EDGE met_err_RAW)
 met_jog_EXP = ((VERTEX (EXPAND EDGE met_jog_TMP OUTSIDE BY 0.001 EXTEND BY 0.001) == 4) OR (EXPAND EDGE met_err_RAW OUTSIDE BY 0.001)) NOT M2
 // 
 met_err_PRL = DFM PROPERTY met_jog_EXP met_err_RAW OVERLAP ABUT ALSO MULTI [-= LENGTH(met_err_RAW)] > 0.140-GLOBAL_TOLERANCE
 met_err_EGE = met_err_RAW TOUCH EDGE met_err_PRL
 err1 = (EXT met_err_EGE M2 < 0.041 ABUT<90 OPPOSITE REGION MEASURE ALL) OR (EXT met_err_EGE M2 >= 0.063 < 0.106 ABUT<90 OPPOSITE REGION MEASURE ALL)
 err1 NOT INSIDE LOGO
}
 
M2_S_5 {
@ Space between Mxy when one or both width >= 0.181um and PRL >= 0.19um. >= 0.125um
 met_wid_all = M2 WITH WIDTH >= 0.181
 met_err_RAW = EXT M2 met_wid_all < 0.125 OPPOSITE REGION MEASURE ALL
 met_err_CRN = EXT (ANGLE M2 > 44 < 46) met_wid_all < 0.125 OPPOSITE1 REGION MEASURE ALL
 err1 = met_err_RAW ENCLOSE RECTANGLE 0.001 0.19 ORTHOGONAL ONLY
 err2 = met_err_CRN ENCLOSE RECTANGLE 0.032 0.19
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}
 
M2_S_6 {
@ Space between Mxy when one or both width >= 0.272um and PRL >= 0.288um. >= 0.143um
 met_wid_all = M2 WITH WIDTH >= 0.272
 met_err_RAW = EXT M2 met_wid_all < 0.143 OPPOSITE REGION MEASURE ALL
 met_err_CRN = EXT (ANGLE M2 > 44 < 46) met_wid_all < 0.143 OPPOSITE1 REGION MEASURE ALL
 err1 = met_err_RAW ENCLOSE RECTANGLE 0.001 0.288 ORTHOGONAL ONLY
 err2 = met_err_CRN ENCLOSE RECTANGLE 0.032 0.288
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}
 
M2_S_7 {
@ Space between Mxy when one or both width >= 0.542um, except LOGO region >= 0.188um
 chk_Mn = M2 WITH WIDTH >= 0.542
 err1 = EXT M2 chk_Mn < 0.188 ABUT<90 REGION
 err1 NOT INSIDE LOGO
}
 
M2_S_8 {
@ Space between Mxy when one or both width >= 1.352um, except LOGO region >= 0.304um
 chk_Mn = (M2 WITH WIDTH >= 0.542) WITH WIDTH >= 1.352
 err1 = EXT M2 chk_Mn < 0.304 ABUT<90 REGION
 err1 NOT INSIDE LOGO
}
 
M2_S_9 {
@ Space between Mxy line and line-end (W <= 0.051um) when PRL >= -0.021um. >= 0.049um
 err1 = EXT M2_line M2_end_0.052 < 0.049 ABUT<90 OPPOSITE EXTENDED 0.021+GLOBAL_TOLERANCE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
M2_S_10 {
@ Space between Mxy line-end (0.032um <= width <= 0.051um) and line-end (0.032um <= width <= 0.047um) when PRL >= -0.021um. >= 0.058um
 err1 = EXT M2_end_0.032_0.051 M2_end_0.032_0.047 < 0.058 ABUT<90 OPPOSITE EXTENDED 0.021+GLOBAL_TOLERANCE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
M2_S_11 {
@ Space between Mxy line-end (0.032um <= width <= 0.051um) and line-end (0.048um <= width <= 0.051um) when PRL >= -0.021um. >= 0.055um
 err1 = EXT M2_end_0.032_0.051 M2_end_0.048_0.051 < 0.055 ABUT<90 OPPOSITE EXTENDED 0.021+GLOBAL_TOLERANCE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
M2_S_12 {
@ Space between Mxy and dense Mxy line-end (0.032um >= W <= 0.047um), when PRL > -0.022um. Dense Mxy line end definition:
@ (W+S1) < 0.09um, other metal must be in the region R, T and D is the extension from metal line end, T <= 0.021um, D <= 0.051um, S1 should be the space between separate metal
@ (Except small jog with edge length <= 0.031um) >= 0.07um
 end_check_TMP = CONVEX EDGE M2 ANGLE1 == 90 LENGTH1 >= 0.001 ANGLE2 == 90 LENGTH2 >= 0.001 WITH LENGTH < 0.047+GLOBAL_TOLERANCE
 end_space_TMP = EXT end_check_TMP M2 < 0.07 ABUT<90 OPPOSITE EXTENDED 0.021+GLOBAL_TOLERANCE REGION
 end_space_EGE = end_check_TMP TOUCH EDGE end_space_TMP
 end_inner_EXD = EXPAND EDGE end_space_EGE INSIDE BY 0.051+GLOBAL_TOLERANCE OUTSIDE BY 0.021+GLOBAL_TOLERANCE
 end_sides_EGE = (end_inner_EXD TOUCH EDGE M2) NOT COIN EDGE end_check_TMP
 // 
 end_sides_ERR = EXT end_sides_EGE M2 < 0.09-0.024 OPPOSITE
 end_width_ERR = INT end_inner_EXD < 0.047+GLOBAL_TOLERANCE OPPOSITE EXCLUDE SHIELDED
 end_sides_CHK = DFM PROPERTY end_sides_EGE end_sides_ERR end_width_ERR OVERLAP ABUT ALSO MULTI [-= MIN(EW(end_sides_ERR)) + MIN(EW(end_width_ERR))] < 0.09
 end_check_EXD = (end_inner_EXD AND M2) WITH EDGE end_sides_CHK
 end_check = end_space_EGE TOUCH EDGE end_check_EXD
 err1 = EXT end_check M2 < 0.07 ABUT<90 OPPOSITE EXTENDED 0.021+GLOBAL_TOLERANCE REGION
 err2 = err1 NOT WITH EDGE (LENGTH M2_end <= 0.031)
 err2 NOT INSIDE SealR_NOT_BULK
}
 
M2_S_13 {
@ Space between Mxy and dense Mxy line-end (0.048um <= W <= 0.051um), when PRL > -0.022um. Dense Mxy line end definition:
@ (W+S1) < 0.09um, other metal must be in the region R, T and D is the extension from metal line end, T <= 0.021um, D <= 0.051um, S1 should be the space between separate metal
@ (Except small jog with edge length <= 0.031um) >= 0.056um
 end_check_TMP = CONVEX EDGE M2 ANGLE1 == 90 LENGTH1 >= 0.001 ANGLE2 == 90 LENGTH2 >= 0.001 WITH LENGTH >= 0.048 <= 0.051
 end_space_TMP = EXT end_check_TMP M2 < 0.056 ABUT<90 OPPOSITE EXTENDED 0.022 REGION
 end_space_EGE = end_check_TMP TOUCH EDGE end_space_TMP
 end_inner_EXD = EXPAND EDGE end_space_EGE INSIDE BY 0.051+GLOBAL_TOLERANCE OUTSIDE BY 0.021+GLOBAL_TOLERANCE
 end_sides_EGE = (end_inner_EXD TOUCH EDGE M2) NOT COIN EDGE end_check_TMP
 // 
 end_sides_ERR = EXT end_sides_EGE M2 < 0.058 OPPOSITE
 end_width_ERR = INT end_inner_EXD >= 0.048 <= 0.051 OPPOSITE EXCLUDE SHIELDED
 end_sides_CHK = DFM PROPERTY end_sides_EGE end_sides_ERR end_width_ERR OVERLAP ABUT ALSO MULTI [-= MIN(EW(end_sides_ERR)) + MIN(EW(end_width_ERR))] < 0.09
 end_check_EXD = (end_inner_EXD AND M2) WITH EDGE end_sides_CHK
 end_check = end_space_EGE TOUCH EDGE end_check_EXD
 err1 = EXT end_check M2 < 0.056 ABUT<90 OPPOSITE EXTENDED 0.022 REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
M2_line_end_046_054_edges = CONVEX EDGE M2 == 2 WITH LENGTH >= 0.046 <= 0.054
M2_line_end_046_054_prl_gt_L = INT (M2_line_end_046_054_edges) M2 < 0.134 OPPOSITE EXCLUDE SHIELDED
M2_line_end_046_054_prl_gt_L_all = M2_line_end_046_054_edges TOUCH EDGE M2_line_end_046_054_prl_gt_L
 
M2_S_14 {
@ Mxy line-end space in metal array >= 0.072um
@ Metal array definition:
@ 1. Mxy width (W): 0.046um <= W <= 0.054um
@ 2. Mxy length (L) >= 0.134um
@ 3. Searching distance (D) of Mxy line-end edge: 0.048um
@ 4. Mxy space (S1) 0.058um <= S1 <= 0.076um for both long sides
@ 5. Mxy PRL > 0um for short side (L1)
@ 6. Line end space (S2) of both neighboring Mxy: 0.058um <= S2 <= 0.076um with PRL > 0um
@ DRC doesn't flag at least one S1 >= 0.058~ <= 0.063um with PRL > 0.112um. And DRC flags forbidden space that has PRL > 0um with both S2
 distance_D_M = EXPAND EDGE M2_line_end_046_054_prl_gt_L_all INSIDE BY 0.048
 distance_D_W = (distance_D_M AND M2) COIN EDGE M2_line_end_046_054_prl_gt_L_all // W edge
 distance_D_W_edge = EXT [distance_D_W] M2 >= 0.058 <= 0.076 ABUT<90 OPPOSITE
 distance_D_W_058_076 = distance_D_W TOUCH EDGE distance_D_W_edge
 // for 58~76 region
 distance_D_seg_twin = (EXPAND EDGE distance_D_W_058_076 INSIDE BY 0.112+0.048 EXTEND BY 0.054-0.046) AND (INT M2 >= 0.046 <= 0.054 OPPOSITE REGION) // include jogs
 distance_D_seg_twin_l_sides = (distance_D_seg_twin NOT TOUCH EDGE distance_D_W_058_076) NOT INSIDE EDGE M2
 distance_D_seg_twin_l_sides_real = distance_D_seg_twin_l_sides NOT TOUCH EDGE (INT [distance_D_seg_twin_l_sides] distance_D_W_058_076 <= 0.112 + 0.048 ABUT<90 OPPOSITE)
 // 
 distance_D_side_058_076_edges = EXT [distance_D_seg_twin_l_sides_real] >= 0.058 <= 0.076 ABUT<90 OPPOSITE
 distance_D_side_058_076 = INT distance_D_side_058_076_edges >= 0.046 <= 0.054 ABUT<90 OPPOSITE REGION
 // 
 distance_D_seg_midd_part = M2 AND (EXPAND EDGE distance_D_W_058_076 INSIDE BY 0.112 + 0.048 EXTEND BY -0.01)
 distance_D_seg_side_part = distance_D_seg_twin NOT distance_D_seg_midd_part
 distance_D_seg_side_part_c = distance_D_seg_side_part INTERACT distance_D_side_058_076
 distance_D_seg_midd_part_c = distance_D_seg_midd_part INTERACT distance_D_seg_side_part_c >= 2
 distance_D_seg_twin_058_076_c = (distance_D_seg_twin INTERACT distance_D_side_058_076) INTERACT distance_D_seg_midd_part_c
 // 
 distance_D_seg_twin_opp = INT distance_D_seg_twin_058_076_c <= 0.112 + 0.048 ABUT<90 OPPOSITE EXCLUDE SHIELDED
 distance_D_seg_twin_opp_ew = DFM PROPERTY distance_D_seg_twin_opp distance_D_seg_twin_058_076_c OVERLAP ABUT ALSO MULTI [max_ew = ew(distance_D_seg_twin_opp)] >= 0.134 [cal_ew = (property_ref(max_ew) == ew(distance_D_seg_twin_opp)) ? 1 : 0] > 0
 // 
 distance_D_sp1 = distance_D_seg_twin_058_076_c NOT COIN EDGE (DFM COPY distance_D_seg_twin_opp_ew EDGE)
 distance_D_sp2 = (EXPAND EDGE distance_D_sp1 INSIDE BY 0.002 CORNER FILL) INTERACT distance_D_side_058_076
 distance_D_sp3 = distance_D_W_058_076 COIN EDGE (distance_D_seg_twin_058_076_c INTERACT distance_D_sp2 >= 2)
 // 
 distance_D_sp_forbidden = EXT distance_D_sp3 M2 < 0.072 ABUT<90 OPPOSITE REGION
 distance_D_sp_forbidden_ove = EXPAND EDGE (distance_D_W_058_076 TOUCH EDGE distance_D_sp_forbidden) OUTSIDE BY 0.005
 distance_D_sp_forbidden_all = EXTENTS (OR distance_D_sp_forbidden distance_D_sp_forbidden_ove)
 distance_D_sp_forbidden_side = distance_D_sp_forbidden_all NOT TOUCH EDGE M2
 distance_D_sp_forbidden_side_prl = EXT (distance_D_sp_forbidden_side) M2 >= 0.058 <= 0.076 ABUT<90 OPPOSITE
 distance_D_sp_forbidden_side_prl_both = distance_D_sp_forbidden_all WITH EDGE distance_D_sp_forbidden_side_prl >= 2
 err1 = distance_D_sp_forbidden AND distance_D_sp_forbidden_side_prl_both // flag error region has prl with the beside error region
 err1 NOT INSIDE SealR_NOT_BULK
}
 
M2_S_15 {
@ Space between two Mxy when one or both Mxy enclosure of long side edge of RVy-1 is < 0.007um, Mxy is the metal layer directly above RVy-1
@ DRC flag the space between Mxy and the long sides of RVy-1. >= 0.035um
 err1_c = ENC RV1_L [M2] < 0.007 ABUT<90 OPPOSITE
 err1 = EXT err1_c M2 < 0.035 ABUT<90 REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
M2_S_16 {
@ Space between two Mxy when one or both Mxy enclosure of long side edge of RVy-1 are < 0.003um, Mxy is the metal layer directly above RVy-1
@ DRC flag the space between Mxy and the long sides of RVy-1. >= 0.044um
 err1_c = ENC RV1_L [M2] < 0.003 ABUT<90 OPPOSITE
 err1 = EXT err1_c M2 < 0.044 ABUT<90 REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
M2_S_17 {
@ Space between Mxy and 45-degree bent Mxy, DRC check 45-degree direction >= 0.152um
 err1 = EXT M2 M2_45_skew_edges < 0.152 ABUT<90 OPPOSITE2 REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
M2_S_18 {
@ Space between Mxy and INST, space = 0 is allowed >= 0.08um
 err1 = EXT M2 INST < 0.08 ABUT>0<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
M2_L_1 {
@ Mxy edge length with adjacent edge < 0.032um (these two edges formed by three consecutive 270-90-270 degree corner) >= 0.064um
@ DRC doesn't flag if there is Mxy in the region which is formed by 0.125um extension from these two edges and the 90-degree outer vertex
 L1 = CONVEX EDGE M2 ANGLE1 == 90 ANGLE2 == 270 WITH LENGTH < 0.032
 L2 = CONVEX EDGE M2 ANGLE1 == 90 ANGLE2 == 270 WITH LENGTH < 0.064
 L3_corner = INT L1 L2 < 0.005 ABUT==90 INTERSECTING ONLY REGION
 L1_c_edge = L1 TOUCH EDGE L3_corner
 L2_c_edge = L2 TOUCH EDGE L3_corner
 L1_c_s125 = EXPAND EDGE L1_c_edge OUTSIDE BY 0.125
 L2_c_s125 = EXPAND EDGE L2_c_edge OUTSIDE BY 0.125
 // 
 SQ_corner_raw = (EXT L1_c_s125 L2_c_s125 < 0.125 ABUT==90 INTERSECTING ONLY REGION EXTENTS) NOT INSIDE M2
 SQ_corner = (SQ_corner_raw NOT COIN EDGE L1_c_s125) NOT COIN EDGE L2_c_s125
 // 
 RM_step_1 = INT SQ_corner <= 0.586*0.125 ABUT==90 INTERSECTING ONLY REGION
 SQ_step_1 = SQ_corner_raw NOT RM_step_1
 RM_step_2 = INT SQ_step_1 <= 0.215*0.125 ABUT>134.8 <135.2 INTERSECTING ONLY REGION
 SQ_step_2 = SQ_step_1 NOT RM_step_2
 SQ_step_3 = (SQ_step_2 OR L1_c_s125) OR L2_c_s125
 SQ_real = SQ_step_3 NOT INTERACT (SQ_step_3 AND M2)
 err1_TMP = L3_corner TOUCH SQ_real
 err1 = EXPAND EDGE (M2 TOUCH EDGE err1_TMP) INSIDE BY 0.001
 err1 NOT INSIDE SealR_NOT_BULK
}
 
M2_L_2 {
@ Mxy edge length with adjacent edge < 0.032um (these two edges formed by three consecutive 90-270-90 degree corners), except EFUSE region >= 0.064um
 chk_EDG = LENGTH M2_convex_270_90_edges < 0.032
 err_EDG = LENGTH M2_convex_270_90_edges < 0.064
 err1 = EXT chk_EDG err_EDG < 0.005 ABUT==90 INTERSECTING ONLY REGION
 err1 NOT INSIDE EFUSE
}
 
M2_L_3 {
@ Mxy branch length when Mxy branch width <= 0.269um, and connected to wide metal with both width and length >= 0.27um. >= 0.139um
@ DRC waive if the branch region can fill at least one (0.005um*design value) rectangle
 // 0.065 based on Mxy.W.3
 dorian_large = M2 WITH WIDTH >= 0.27
 dorian_whole = M2 INTERACT dorian_large
 dorian_large_ep = SIZE dorian_large BY 0.005 INSIDE OF dorian_whole
 dorian_branch_1 = M2 WITH WIDTH >= 0.065 < 0.269+GLOBAL_TOLERANCE
 dorian_branch_2 = dorian_branch_1 NOT OUTSIDE dorian_large_ep
 dorian_branch_3 = ENCLOSE RECTANGLE dorian_branch_2 0.005 0.139 ORTHOGONAL ONLY
 err1 = dorian_branch_2 NOT dorian_branch_3
 err1 NOT INSIDE SealR_NOT_BULK
}
 
M2_L_4 {
@ Mxy branch length when Mxy branch width <= 0.269um, and connected to wide metal with both width and length >= 0.542um. >= 0.248um
@ DRC waive if the branch region can fill at least one (0.005um*design value) rectangle
 // 0.065 based on Mxy.W.3
 dorian_large = M2 WITH WIDTH >= 0.542
 dorian_whole = M2 INTERACT dorian_large
 dorian_large_ep = SIZE dorian_large BY 0.005 INSIDE OF dorian_whole
 dorian_branch_1 = M2 WITH WIDTH >= 0.065 < 0.269+GLOBAL_TOLERANCE
 dorian_branch_2 = dorian_branch_1 NOT OUTSIDE dorian_large_ep
 dorian_branch_3 = ENCLOSE RECTANGLE dorian_branch_2 0.005 0.248 ORTHOGONAL ONLY
 err1 = dorian_branch_2 NOT dorian_branch_3
 err1 NOT INSIDE SealR_NOT_BULK
}
 
M2_L_5 {
@ Length of Mxy branch when Mxy branch width <= 0.269um, and connected to wide metal e with both width and length >= 1um. >= 0.495um
@ DRC waive if the branch region can fill at least one (0.005um*design value) rectangle
 // 0.065 based on Mxy.W.3
 dorian_large = M2 WITH WIDTH >= 1.00
 dorian_whole = M2 INTERACT dorian_large
 dorian_large_ep = SIZE dorian_large BY 0.005 INSIDE OF dorian_whole
 dorian_branch_1 = M2 WITH WIDTH >= 0.065 < 0.269+GLOBAL_TOLERANCE
 dorian_branch_2 = dorian_branch_1 NOT OUTSIDE dorian_large_ep
 dorian_branch_3 = ENCLOSE RECTANGLE dorian_branch_2 0.005 0.495 ORTHOGONAL ONLY
 err1 = dorian_branch_2 NOT dorian_branch_3
 err1 NOT INSIDE SealR_NOT_BULK
}
 
M2_L_6 {
@ Length of 45-degree bent metal, except MARKS region >= 0.44um
 err1 = LENGTH M2_45_skew_edges < 0.44
 err1 NOT INSIDE EDGE MARKS
}
 
M2_NOT_MARKS = (M2 OR M2DP) NOT MARKS
M2_in_ck_area = M2_NOT_MARKS AND CHIP_NOT_MARKS
M2_all_NOT_MARKS = M2_all NOT MARKS
M2_all_in_ck_area = M2_all_NOT_MARKS AND CHIP_NOT_MARKS
 

#IFDEF IP_LEVEL_DENSITY_CHECK YES
#IFDEF MINIMUM_DENSITY_CHECK YES

M2_D_1_less_than_15 {
@ Mxy density (window 50um*50um, stepping 50um/step_number), except the window (15.8% <= metal density < 26.3%) not interact 3um*3um empty area, except OCOVL region, (NODMF su 1um) >= 26.3%
 check_region = CHIP_NOT_MARKS NOT (or OCOVL NODMF_SIZE_1)
 check_pattern = M2_all AND check_region
 // 
 check_window1 = check_region WITH WIDTH >= 50/4
 err1_TMP1 = DENSITY check_pattern check_window1 check_region [!AREA(check_window1) + !!AREA(check_window1)*AREA(check_pattern)/AREA(check_region)] < 0.158 WINDOW 50 STEP 50/step_number BACKUP INSIDE OF LAYER DRC:1 BY POLYGON
 // 
 check_window2 = WITH WIDTH (check_region AND err1_TMP1) >= 50/4
 err1_TMP2 = DENSITY check_pattern check_window2 check_region [!AREA(check_window2) + !!AREA(check_window2)*AREA(check_pattern)/AREA(check_region)] < 0.158 WINDOW 50 STEP 50/step_number BACKUP INSIDE OF LAYER err1_TMP1 BY POLYGON
 // 
 check_window3 = WITH WIDTH (check_region AND err1_TMP2) >= 50/4
 DENSITY check_pattern check_window3 check_region [!AREA(check_window3) + !!AREA(check_window3)*AREA(check_pattern)/AREA(check_region)] < 0.158 WINDOW 50 STEP 50/step_number BACKUP INSIDE OF LAYER err1_TMP2 BY POLYGON PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_M2_D_1_less_than_15.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_M2_D_1_less_than_15.rdb"
}
 
M2_D_1_between_15_25 {
@ Mxy density (window 50um*50um, stepping 50um/step_number), except the window (15.8% <= metal density < 26.3%) not interact 3um*3um empty area, except OCOVL region, (NODMF su 1um) >= 26.3%
 ck3x3_window = WITH WIDTH (check_region NOT M2_all) >= 3
 check_region = CHIP_NOT_MARKS NOT (or OCOVL NODMF_SIZE_1)
 check_pattern = M2_all AND check_region
 // 
 check_window1 = check_region WITH WIDTH >= 50/4
 err1_TMP1 = DENSITY check_pattern check_window1 check_region ck3x3_window [!AREA(ck3x3_window) + !AREA(check_window1) + !!AREA(ck3x3_window)*!!AREA(check_window1)*AREA(check_pattern)/AREA(check_region)] >= 0.158 < 0.263 WINDOW 50 STEP 50/step_number BACKUP INSIDE OF LAYER DRC:1 BY POLYGON
 // 
 check_window2 = WITH WIDTH (check_region AND err1_TMP1) >= 50/4
 err1_TMP2 = DENSITY check_pattern check_window2 check_region ck3x3_window [!AREA(ck3x3_window) + !AREA(check_window2) + !!AREA(ck3x3_window)*!!AREA(check_window2)*AREA(check_pattern)/AREA(check_region)] >= 0.158 < 0.263 WINDOW 50 STEP 50/step_number BACKUP INSIDE OF LAYER err1_TMP1 BY POLYGON
 // 
 check_window3 = WITH WIDTH (check_region AND err1_TMP2) >= 50/4
 DENSITY check_pattern check_window3 check_region ck3x3_window [!AREA(ck3x3_window) + !AREA(check_window3) + !!AREA(ck3x3_window)*!!AREA(check_window3)*AREA(check_pattern)/AREA(check_region)] >= 0.158 < 0.263 WINDOW 50 STEP 50/step_number BACKUP INSIDE OF LAYER err1_TMP2 BY POLYGON PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_M2_D_1_between_15_25.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_M2_D_1_between_15_25.rdb"
}

#ENDIF

 
M2_D_2 {
@ Mxy maximum density (window 50um*50um, stepping 25um), except dummy metal <= 65%
 check_region = COPY CHIP_NOT_MARKS
 check_pattern = (M2 OR M2DP) AND check_region
 // 
 check_window1 = check_region WITH WIDTH >= 50/4
 err1_TMP1 = DENSITY check_pattern check_window1 check_region [!!AREA(check_window1)*AREA(check_pattern)/AREA(check_region)] > 0.65 WINDOW 50 STEP 25 BACKUP INSIDE OF LAYER DRC:1 BY POLYGON
 // 
 check_window2 = WITH WIDTH (check_region AND err1_TMP1) >= 50/4
 err1_TMP2 = DENSITY check_pattern check_window2 check_region [!!AREA(check_window2)*AREA(check_pattern)/AREA(check_region)] > 0.65 WINDOW 50 STEP 25 BACKUP INSIDE OF LAYER err1_TMP1 BY POLYGON
 // 
 check_window3 = WITH WIDTH (check_region AND err1_TMP2) >= 50/4
 DENSITY check_pattern check_window3 check_region [!!AREA(check_window3)*AREA(check_pattern)/AREA(check_region)] > 0.65 WINDOW 50 STEP 25 BACKUP INSIDE OF LAYER err1_TMP2 BY POLYGON PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_M2_D_2.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_M2_D_2.rdb"
}
 
M2_D_3 {
@ Mxy maximum density (window 50um*50um, stepping 50um/step_number) <= 71.3%
 check_region = COPY CHIP_NOT_MARKS
 check_pattern = M2_all AND check_region
 // 
 check_window1 = check_region WITH WIDTH >= 50/4
 err1_TMP1 = DENSITY check_pattern check_window1 check_region [!!AREA(check_window1)*AREA(check_pattern)/AREA(check_region)] > 0.713 WINDOW 50 STEP 50/step_number BACKUP INSIDE OF LAYER DRC:1 BY POLYGON
 // 
 check_window2 = WITH WIDTH (check_region AND err1_TMP1) >= 50/4
 err1_TMP2 = DENSITY check_pattern check_window2 check_region [!!AREA(check_window2)*AREA(check_pattern)/AREA(check_region)] > 0.713 WINDOW 50 STEP 50/step_number BACKUP INSIDE OF LAYER err1_TMP1 BY POLYGON
 // 
 check_window3 = WITH WIDTH (check_region AND err1_TMP2) >= 50/4
 DENSITY check_pattern check_window3 check_region [!!AREA(check_window3)*AREA(check_pattern)/AREA(check_region)] > 0.713 WINDOW 50 STEP 50/step_number BACKUP INSIDE OF LAYER err1_TMP2 BY POLYGON PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_M2_D_3.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_M2_D_3.rdb"
}
 
M2_D_4 {
@ Mxy density difference between any two neighboring checking windows (window 180um*180um, stepping 180um/step_number) <= 38%
 DENSITY M2_all_NOT_MARKS CHIP_NOT_MARKS [AREA(M2_all_NOT_MARKS)/AREA(CHIP_NOT_MARKS)] >= 0 WINDOW 180 STEP 180/step_number GRADIENT > 0.38 ABSOLUTE BACKUP PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_M2_D_4.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_M2_D_4.rdb"
}
 

#IFDEF MINIMUM_DENSITY_CHECK YES


#ENDIF

 
M2_D_7 {
@ Mxy density ratio of ((Mxy or dummy Mxy) INTERACT ((MxyDPMK OR MxyCA) OR MxyCB)) to (Mxy or dummy Mxy) in window 72um*72um, step size: 72um/step_number, except OCOVL region <= 28.5%
 check_pattern = (M2_all INTERACT (OR M2DPMK M2CA M2CB)) NOT (OR MARKS OCOVL)
 check_region = M2_all NOT (OR MARKS OCOVL)
 DENSITY check_pattern check_region [AREA(check_pattern)/AREA(check_region)] > 0.285 WINDOW 72 STEP 72/step_number BACKUP PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_M2_D_7.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_M2_D_7.rdb"
}

#ENDIF

 

#IFDEF IP_LEVEL_DENSITY_CHECK NO
#IFDEF MINIMUM_DENSITY_CHECK YES

M2_D_1_less_than_15 {
@ Mxy density (window 50um*50um, stepping 25um), except the window (15% <= metal density < 25%) not interact 3um*3um empty area, except OCOVL region, (NODMF su 1um) >= 25%
 check_region = CHIP_NOT_MARKS NOT (or OCOVL NODMF_SIZE_1)
 check_pattern = M2_all AND check_region
 // 
 check_window1 = check_region WITH WIDTH >= 50/4
 err1_TMP1 = DENSITY check_pattern check_window1 check_region [!AREA(check_window1) + !!AREA(check_window1)*AREA(check_pattern)/AREA(check_region)] < 0.15 WINDOW 50 STEP 25 BACKUP INSIDE OF LAYER DRC:1 BY POLYGON
 // 
 check_window2 = WITH WIDTH (check_region AND err1_TMP1) >= 50/4
 err1_TMP2 = DENSITY check_pattern check_window2 check_region [!AREA(check_window2) + !!AREA(check_window2)*AREA(check_pattern)/AREA(check_region)] < 0.15 WINDOW 50 STEP 25 BACKUP INSIDE OF LAYER err1_TMP1 BY POLYGON
 // 
 check_window3 = WITH WIDTH (check_region AND err1_TMP2) >= 50/4
 DENSITY check_pattern check_window3 check_region [!AREA(check_window3) + !!AREA(check_window3)*AREA(check_pattern)/AREA(check_region)] < 0.15 WINDOW 50 STEP 25 BACKUP INSIDE OF LAYER err1_TMP2 BY POLYGON PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_M2_D_1_less_than_15.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_M2_D_1_less_than_15.rdb"
}
 
M2_D_1_between_15_25 {
@ Mxy density (window 50um*50um, stepping 25um), except the window (15% <= metal density < 25%) not interact 3um*3um empty area, except OCOVL, (NODMF su 1um) region >= 25%
 ck3x3_window = WITH WIDTH (check_region NOT M2_all) >= 3
 check_region = CHIP_NOT_MARKS NOT (or OCOVL NODMF_SIZE_1)
 check_pattern = M2_all AND check_region
 // 
 check_window1 = check_region WITH WIDTH >= 50/4
 err1_TMP1 = DENSITY check_pattern check_window1 check_region ck3x3_window [!AREA(ck3x3_window) + !AREA(check_window1) + !!AREA(ck3x3_window)*!!AREA(check_window1)*AREA(check_pattern)/AREA(check_region)] >= 0.15 < 0.25 WINDOW 50 STEP 25 BACKUP INSIDE OF LAYER DRC:1 BY POLYGON
 // 
 check_window2 = WITH WIDTH (check_region AND err1_TMP1) >= 50/4
 err1_TMP2 = DENSITY check_pattern check_window2 check_region ck3x3_window [!AREA(ck3x3_window) + !AREA(check_window2) + !!AREA(ck3x3_window)*!!AREA(check_window2)*AREA(check_pattern)/AREA(check_region)] >= 0.15 < 0.25 WINDOW 50 STEP 25 BACKUP INSIDE OF LAYER err1_TMP1 BY POLYGON
 // 
 check_window3 = WITH WIDTH (check_region AND err1_TMP2) >= 50/4
 DENSITY check_pattern check_window3 check_region ck3x3_window [!AREA(ck3x3_window) + !AREA(check_window3) + !!AREA(ck3x3_window)*!!AREA(check_window3)*AREA(check_pattern)/AREA(check_region)] >= 0.15 < 0.25 WINDOW 50 STEP 25 BACKUP INSIDE OF LAYER err1_TMP2 BY POLYGON PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_M2_D_1_between_15_25.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_M2_D_1_between_15_25.rdb"
}

#ENDIF

 
M2_D_2 {
@ Mxy maximum density (window 50um*50um, stepping 25um), except dummy metal <= 65%
 check_region = COPY CHIP_NOT_MARKS
 check_pattern = (M2 OR M2DP) AND check_region
 // 
 check_window1 = check_region WITH WIDTH >= 50/4
 err1_TMP1 = DENSITY check_pattern check_window1 check_region [!!AREA(check_window1)*AREA(check_pattern)/AREA(check_region)] > 0.65 WINDOW 50 STEP 25 BACKUP INSIDE OF LAYER DRC:1 BY POLYGON
 // 
 check_window2 = WITH WIDTH (check_region AND err1_TMP1) >= 50/4
 err1_TMP2 = DENSITY check_pattern check_window2 check_region [!!AREA(check_window2)*AREA(check_pattern)/AREA(check_region)] > 0.65 WINDOW 50 STEP 25 BACKUP INSIDE OF LAYER err1_TMP1 BY POLYGON
 // 
 check_window3 = WITH WIDTH (check_region AND err1_TMP2) >= 50/4
 DENSITY check_pattern check_window3 check_region [!!AREA(check_window3)*AREA(check_pattern)/AREA(check_region)] > 0.65 WINDOW 50 STEP 25 BACKUP INSIDE OF LAYER err1_TMP2 BY POLYGON PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_M2_D_2.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_M2_D_2.rdb"
}
 
M2_D_3 {
@ Mxy maximum density (window 50um*50um, stepping 25um) <= 75%
 check_region = COPY CHIP_NOT_MARKS
 check_pattern = M2_all AND check_region
 // 
 check_window1 = check_region WITH WIDTH >= 50/4
 err1_TMP1 = DENSITY check_pattern check_window1 check_region [!!AREA(check_window1)*AREA(check_pattern)/AREA(check_region)] > 0.75 WINDOW 50 STEP 25 BACKUP INSIDE OF LAYER DRC:1 BY POLYGON
 // 
 check_window2 = WITH WIDTH (check_region AND err1_TMP1) >= 50/4
 err1_TMP2 = DENSITY check_pattern check_window2 check_region [!!AREA(check_window2)*AREA(check_pattern)/AREA(check_region)] > 0.75 WINDOW 50 STEP 25 BACKUP INSIDE OF LAYER err1_TMP1 BY POLYGON
 // 
 check_window3 = WITH WIDTH (check_region AND err1_TMP2) >= 50/4
 DENSITY check_pattern check_window3 check_region [!!AREA(check_window3)*AREA(check_pattern)/AREA(check_region)] > 0.75 WINDOW 50 STEP 25 BACKUP INSIDE OF LAYER err1_TMP2 BY POLYGON PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_M2_D_3.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_M2_D_3.rdb"
}
 
M2_D_4 {
@ Mxy density difference between any two neighboring checking windows (window 180um*180um, stepping 90um) <= 40%
 DENSITY M2_all_NOT_MARKS CHIP_NOT_MARKS [AREA(M2_all_NOT_MARKS)/AREA(CHIP_NOT_MARKS)] >= 0 WINDOW 180 STEP 90 GRADIENT > 0.4 ABSOLUTE BACKUP PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_M2_D_4.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_M2_D_4.rdb"
}
 

#IFDEF MINIMUM_DENSITY_CHECK YES


#ENDIF

 
M2_D_7 {
@ Mxy density ratio of ((Mxy or dummy Mxy) INTERACT ((MxyDPMK OR MxyCA) OR MxyCB)) to (Mxy or dummy Mxy) in window 72um*72um, step size: 36um, except OCOVL region <= 30%
 check_pattern = (M2_all INTERACT (OR M2DPMK M2CA M2CB)) NOT (OR MARKS OCOVL)
 check_region = M2_all NOT (OR MARKS OCOVL)
 DENSITY check_pattern check_region [AREA(check_pattern)/AREA(check_region)] > 0.3 WINDOW 72 STEP 36 BACKUP PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_M2_D_7.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_M2_D_7.rdb"
}

#ENDIF

 

#IFDEF METAL_DECOMPOSITION_RESULT YES

 
M2_D_8 {
@ Mxy density difference of ABS (((Mxy OR MxyDUM OR MxyDOP) - (MxyDP OR MxyDPDUM OR MxyDPDOP)) / ((Mxy OR MxyDUM OR MxyDOP) + (MxyDP OR MxyDPDUM OR MxyDPDOP)))
@ This rule is applied post Mxy layout decomposition <= 10%
 FM_all = (M2 OR M2DUM) OR M2DOP
 GM_all = (M2DP OR M2DPDUM) OR M2DPDOP
 FM_chk = FM_all NOT MARKS
 GM_chk = GM_all NOT MARKS
 err1 = DENSITY FM_chk GM_chk [AREA(FM_chk) - AREA(GM_chk) - 0.1*(AREA(FM_chk) + AREA(GM_chk))] > 0 PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_M2_D_8_1.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_M2_D_8_1.rdb"
 err2 = DENSITY FM_chk GM_chk [AREA(GM_chk) - AREA(FM_chk) - 0.1*(AREA(FM_chk) + AREA(GM_chk))] > 0 PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_M2_D_8_2.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_M2_D_8_2.rdb"
 err1 OR err2
}

#ENDIF

 
M2_A_1 {
@ M2 area >= 0.0061um2
 err1 = AREA M2 < 0.0061
 err1 NOT INSIDE SealR_NOT_BULK
}
 
M2_A_3 {
@ M2 Area (with all of edge length < 0.204um, any edge length >= 0.117um) >= 0.0072um2
@ Except:
@ 1) The patterns filling 0.046um*0.117um rectangular pattern or
@ 2) M2 edge of length >= 0.046um if this edge have another adjacent edge of length < 0.032um
 Mn_check = AREA M2 < 0.0072
 Mn_check_a = LENGTH Mn_check >= 0.046
 Mn_check_b = LENGTH Mn_check < 0.032
 Mn_edge_any = LENGTH Mn_check >= 0.117
 Mn_edge_all = LENGTH Mn_check >= 0.204
 // 
 Mn_waive_1 = ENCLOSE RECTANGLE M2 0.046 0.117 ORTHOGONAL ONLY
 Mn_waive_2 = Mn_check INTERACT ((INT Mn_check_a Mn_check_b < 0.005 ABUT INTERSECTING ONLY REGION) OR (EXT Mn_check_a Mn_check_b < 0.005 ABUT INTERSECTING ONLY REGION))
 Mn_waive = Mn_waive_1 OR Mn_waive_2
 err1 = ((Mn_check WITH EDGE Mn_edge_any) NOT WITH EDGE Mn_edge_all) NOT Mn_waive
 err1 NOT INSIDE SealR_NOT_BULK
}
 
M2_A_4 {
@ Mxy area (with all of edge lengths < 0.082um) (Except a pattern filling 0.078um*0.078um rectangular pattern) >= 0.0178um2
 Mn_waive = ENCLOSE RECTANGLE M2 0.078 0.078 ORTHOGONAL ONLY
 Mn_check = AREA M2 < 0.0178
 Mn_edge_all = LENGTH Mn_check >= 0.082
 err1 = (Mn_check NOT WITH EDGE Mn_edge_all) NOT Mn_waive
 err1 NOT INSIDE SealR_NOT_BULK
}
 
M2_A_5 {
@ Mxy enclosed area >= 0.161um2
 err1 = AREA ((HOLES M2 INNER) NOT M2) < 0.161
 err1 NOT INSIDE SealR_NOT_BULK
}
 
M2_R_1 {
@ Mxy forbidden space (Mxy width >= 0.15um and PRL > 0.135um), except Mxy jog width <= 0.135um. = 0.058~0.062um
@ DRC searching range is from 0.106um to 0.729um
@ DRC flags the forbidden space that totally inside the searching range along the space direction, and the PRL between forbidden space and the wide metal is > 0.135um
 SPACE_Forbidden_PRE = EXT M2 >= 0.058 <= 0.062 ABUT<90 OPPOSITE REGION
 SPACE_Forbidden_TMP = SPACE_Forbidden_PRE ENCLOSE RECTANGLE 0.001 0.135+GLOBAL_TOLERANCE ORTHOGONAL ONLY
 SPACE_Forbidden_TMP_in_SearchR = EXT (M2 COIN EDGE SPACE_Forbidden_TMP) met2_wide_eqgt_150 >= 0.106 <= 0.729 ABUT>0<90 OPPOSITE MEASURE ALL
 SPACE_Forbidden_TMP_in_SearchR_EDGE = M2 COIN EDGE (DFM COPY SPACE_Forbidden_TMP_in_SearchR EDGE)
 SPACE_Forbidden_real = EXT SPACE_Forbidden_TMP_in_SearchR_EDGE M2 >= 0.058 <= 0.062 ABUT<90 OPPOSITE REGION
 err1 = ENCLOSE RECTANGLE SPACE_Forbidden_real 0.001 0.135+GLOBAL_TOLERANCE ORTHOGONAL ONLY
 err1 NOT INSIDE SealR_NOT_BULK
}
 
M2_COLORA = M2 INTERACT M2CA
M2_COLORB = M2 INTERACT M2CB

#IFDEF DOUBLE_PATTERNING_RULES_CHECK YES

M2_a = M2 INTERACT M2_mask0
M2_b = M2 INTERACT M2_mask1
M2_a_v_edges = M2_v_edges TOUCH EDGE M2_a
M2_b_v_edges = M2_v_edges TOUCH EDGE M2_b
M2_a_h_edges = M2_h_edges TOUCH EDGE M2_a
M2_b_h_edges = M2_h_edges TOUCH EDGE M2_b
M2_a_width_lt_037_opp_edges = M2_width_lt_037_opp_edges COIN EDGE M2_a
M2_b_width_lt_037_opp_edges = M2_width_lt_037_opp_edges COIN EDGE M2_b
 

#IFDEF DOUBLE_PATTERNING_RULES_CHECK_ONLY YES

DRC SELECT CHECK M2_R_2

#ENDIF

M2_R_2 {
@ Mxy forbidden space for single mask when Mxy width < 0.037um and PRL with neighboring Mxy (W2) > 0.117um, for M2
@ DRC flags edge of ((W1+S1+W2+S2) or (S1+W2+S2+W3)) = 0.141~0.175um
@ DRC waive when:
@ (1) A/B or B/C are same polygons
@ (2) A/C in different masks
 M2_NOTCH = EXT [M2] <= 0.08 ABUT<90 OPPOSITE
 M2_NOTCH_A = EXT (M2_v_edges COIN EDGE M2_NOTCH) <= 0.112 ABUT<90 OPPOSITE PARA ONLY NOTCH REGION EXCLUDE SHIELDED
 M2_NOTCH_A_all = M2_v_edges OR EDGE (M2_NOTCH_A COIN EDGE M2_v_edges)
 M2_ERR_P1 = DFM SPACE M2_NOTCH_A_all M2_width_lt_037_opp_edges >= 0.141 <= 0.175 BY ENC MEASURE ALL COUNT == 3 BY LAYER M2_NOTCH_A_all
 M2_ERR_P2 = DFM SPACE M2_width_lt_037_opp_edges M2_NOTCH_A_all >= 0.141 <= 0.175 BY ENC MEASURE ALL COUNT == 3 BY LAYER M2_NOTCH_A_all
 err1 = DFM PROPERTY M2_ERR_P1 M2_COLORA M2_COLORB M2_width_lt_037_opp_edges OVERLAP ABUT ALSO MULTI 
 [+= (count(M2_width_lt_037_opp_edges) > 0) ? 1 : 0] > 0 
 [-= (EC(M2_ERR_P1) > 0.117 && (count(M2_COLORA) > 1 || count(M2_COLORB) > 1 || count(M2_COLORA) == 0 || count(M2_COLORB) == 0)) ? 1 : 0 ] > 0
 err2 = DFM PROPERTY M2_ERR_P2 M2_COLORA M2_COLORB M2_width_lt_037_opp_edges OVERLAP ABUT ALSO MULTI 
 [+= (count(M2_width_lt_037_opp_edges) > 0) ? 1 : 0] > 0 
 [-= (EC(M2_ERR_P2) > 0.117 && (count(M2_COLORA) > 1 || count(M2_COLORB) > 1 || count(M2_COLORA) == 0 || count(M2_COLORB) == 0)) ? 1 : 0 ] > 0
 DFM COPY err1 err2
 // 
 M2_NOTCH_B = EXT (M2_h_edges COIN EDGE M2_NOTCH) <= 0.112 ABUT<90 OPPOSITE PARA ONLY NOTCH REGION EXCLUDE SHIELDED
 M2_NOTCH_B_all = M2_h_edges OR EDGE (M2_NOTCH_B COIN EDGE M2_h_edges)
 M2_ERR_P3 = DFM SPACE M2_NOTCH_B_all M2_width_lt_037_opp_edges >= 0.141 <= 0.175 BY ENC MEASURE ALL COUNT == 3 BY LAYER M2_NOTCH_B_all
 M2_ERR_P4 = DFM SPACE M2_width_lt_037_opp_edges M2_NOTCH_B_all >= 0.141 <= 0.175 BY ENC MEASURE ALL COUNT == 3 BY LAYER M2_NOTCH_B_all
 err3 = DFM PROPERTY M2_ERR_P3 M2_COLORA M2_COLORB M2_width_lt_037_opp_edges OVERLAP ABUT ALSO MULTI 
 [+= (count(M2_width_lt_037_opp_edges) > 0) ? 1 : 0] > 0 
 [-= (EC(M2_ERR_P3) > 0.117 && (count(M2_COLORA) > 1 || count(M2_COLORB) > 1 || count(M2_COLORA) == 0 || count(M2_COLORB) == 0)) ? 1 : 0 ] > 0
 err4 = DFM PROPERTY M2_ERR_P4 M2_COLORA M2_COLORB M2_width_lt_037_opp_edges OVERLAP ABUT ALSO MULTI 
 [+= (count(M2_width_lt_037_opp_edges) > 0) ? 1 : 0] > 0 
 [-= (EC(M2_ERR_P4) > 0.117 && (count(M2_COLORA) > 1 || count(M2_COLORB) > 1 || count(M2_COLORA) == 0 || count(M2_COLORB) == 0)) ? 1 : 0 ] > 0
 DFM COPY err3 err4
}

#ENDIF

 
M2_R_4 {
@ Mxy overlap of MTFUSE is not allowed
 err1 = M2 AND MTFUSE
 err1 NOT INSIDE SealR_NOT_BULK
}
// Mxy.R.6[NC] Mxy pattern must be drawn on data type 0
 
M2_R_7 {
@ U-shape metal pitch (W+S1) or (W+S2) must be >= 0.072um except M2 in INST region
@ Vy enclosure by Mxy line-end (E) must be >= 0.032um (Mxy is the metal underneath Vy)
@ When:
@ (1) Both PRL1 and PRL2 >= -0.015um
@ (2) Space (S) < 0.070um along length direction
@ (3) W < 0.046um
@ DRC waive if S1 or S2 > 0.04um
 end_enc = M2_end_0.046 NOT TOUCH EDGE (ENC V2 [M2_end_0.046] < 0.032 ABUT<90 OPPOSITE)
 end_sps = end_enc TOUCH EDGE (EXT [end_enc] M2_convex_270_270_edges < 0.07 ABUT<90 OPPOSITE)
 end_epd = EXPAND EDGE end_sps OUTSIDE BY 0.016
 end_sid = LENGTH (end_epd NOT TOUCH EDGE M2) == 0.016
 end_wid = INT end_sid < 0.046 ABUT<90 OPPOSITE
 end_sds = EXT end_sid M2 < 0.04 ABUT<90 OPPOSITE
 err1 = DFM PROPERTY end_epd end_wid end_sds OVERLAP ABUT ALSO MULTI 
 [+= (count(end_wid) > 0 && count(end_sds) > 0) ? 1 : 0] > 0 [-= min(ew(end_wid)) + min(ew(end_sds))] < 0.072
 err1 NOT INSIDE INST
}
 
M2_R_8 {
@ U-shape metal pitch (W+S1) or (W+S2) must be >= 0.072um, except M2 in INST region
@ When:
@ 1) Both PRL1 and PRL2 >= -0.015um
@ 2) Space (S) < 0.070um along length direction
@ 3) W < 0.046um
@ 4) Mxy interact Vy-1 and enclosure E < 0.05um. (Mxy is the metal above Vy-1)
@ DRC waive if S1 or S2 > 0.04um
 end_enc = M2_end_0.046 TOUCH EDGE (ENC V1 [M2_end_0.046] < 0.05 ABUT<90 OPPOSITE)
 end_sps = end_enc TOUCH EDGE (EXT [end_enc] M2_convex_270_270_edges < 0.07 ABUT<90 OPPOSITE)
 end_epd = EXPAND EDGE end_sps OUTSIDE BY 0.016
 end_sid = LENGTH (end_epd NOT TOUCH EDGE M2) == 0.016
 end_wid = INT end_sid < 0.046 ABUT<90 OPPOSITE
 end_sds = EXT end_sid M2 < 0.04 ABUT<90 OPPOSITE
 err1 = DFM PROPERTY end_epd end_wid end_sds OVERLAP ABUT ALSO MULTI 
 [+= (count(end_wid) > 0 && count(end_sds) > 0) ? 1 : 0] > 0 [-= min(ew(end_wid)) + min(ew(end_sds))] < 0.072
 err1 NOT INSIDE INST
}
 
// Mxy_R_8: It is a must to use SMIC utility to insert dummy metal Don't change any dimension and variable in utility
Mxy_2_RSP_1_2a_2b_met = ENCLOSE RECTANGLE (M2 INTERACT (M2 WITH WIDTH > 0.07)) 0.071 0.271 ORTHOGONAL ONLY
Mxy_2_RSP_1_2a_2b_wid = INT (Mxy_2_RSP_1_2a_2b_met) <= 0.07 OPPOSITE EXCLUDE SHIELDED
Mxy_2_RSP_1_2a_2b_wan = LENGTH (M2_convex_270_90_edges COIN EDGE Mxy_2_RSP_1_2a_2b_met) < 0.09 - 0.032
Mxy_2_RSP_1_2a_2b_sps = Mxy_2_RSP_1_2a_2b_met COIN EDGE (EXT Mxy_2_RSP_1_2a_2b_met M2 < 0.09 OPPOSITE REGION EXCLUDE SHIELDED)
// 
Mxy_2_RSP_1_2a_2b_sps_sides_A = (Mxy_2_RSP_1_2a_2b_wid COIN EDGE Mxy_2_RSP_1_2a_2b_sps) NOT COIN EDGE (LENGTH (Mxy_2_RSP_1_2a_2b_wid NOT TOUCH EDGE 
(INT [Mxy_2_RSP_1_2a_2b_wid] Mxy_2_RSP_1_2a_2b_wan < 0.001 ABUT==90 INTERSECTING ONLY)) <= 0.27)
Mxy_2_RSP_1_2a_2b_sps_sides_B = (Mxy_2_RSP_1_2a_2b_wid COIN EDGE Mxy_2_RSP_1_2a_2b_sps) NOT COIN EDGE (LENGTH (Mxy_2_RSP_1_2a_2b_wid NOT TOUCH EDGE 
(EXT [Mxy_2_RSP_1_2a_2b_wid] Mxy_2_RSP_1_2a_2b_wan < 0.001 ABUT==90 INTERSECTING ONLY)) <= 0.27)
Mxy_2_RSP_1_2a_2b_sps_sides = Mxy_2_RSP_1_2a_2b_sps_sides_A OR EDGE Mxy_2_RSP_1_2a_2b_sps_sides_B
Mxy_2_RSP_1_2a_2b_sps_sides_PRL = Mxy_2_RSP_1_2a_2b_sps_sides COIN EDGE (PATH LENGTH (Mxy_2_RSP_1_2a_2b_wan OR EDGE Mxy_2_RSP_1_2a_2b_sps_sides) > 0.27)
// 
Mxy_2_RSP_1_2a_2b_S1_side = EXT M2 Mxy_2_RSP_1_2a_2b_sps_sides_PRL < 0.09 OPPOSITE EXCLUDE SHIELDED
Mxy_2_RSP_1_2a_2b_S1_area = EXT M2 Mxy_2_RSP_1_2a_2b_sps_sides_PRL < 0.09 OPPOSITE EXCLUDE SHIELDED REGION
Mxy_2_RSP_1_2a_2b_S1_rlen = Mxy_2_RSP_1_2a_2b_S1_area ENCLOSE RECTANGLE 0.001 0.271 ORTHOGONAL ONLY
Mxy_2_RSP_1_2a_2b_L1_side = M2 COIN EDGE ((DFM COPY Mxy_2_RSP_1_2a_2b_S1_side EDGE) COIN EDGE Mxy_2_RSP_1_2a_2b_S1_rlen)
Mxy_2_RSP_1_2a_2b_L1_side_jog_sum = Mxy_2_RSP_1_2a_2b_wan OR EDGE Mxy_2_RSP_1_2a_2b_L1_side
Mxy_2_RSP_1_2a_2b_L1_side_jog_sum_EXP = EXPAND EDGE Mxy_2_RSP_1_2a_2b_L1_side_jog_sum INSIDE BY 0.001 CORNER FILL
// 
Mxy_2_RSP_1_2a_2b_Q1 = EXPAND EDGE (Mxy_2_RSP_1_2a_2b_L1_side COIN EDGE Mxy_2_RSP_1_2a_2b_L1_side_jog_sum) INSIDE BY 0.001
Mxy_2_RSP_1_2a_2b_Q2 = Mxy_2_RSP_1_2a_2b_L1_side_jog_sum_EXP INTERACT (AREA Mxy_2_RSP_1_2a_2b_Q1 > 0.27 * 0.001)
Mxy_2_RSP_1_2a_2b_Q3 = Mxy_2_RSP_1_2a_2b_L1_side_jog_sum TOUCH EDGE (LENGTH (Mxy_2_RSP_1_2a_2b_Q1 INTERACT Mxy_2_RSP_1_2a_2b_Q2) > 0.001)
// 
Mxy_2_RSP_1_2a_2b_y1 = DFM COPY (EXT M2 Mxy_2_RSP_1_2a_2b_Q3 < 0.09 OPPOSITE EXCLUDE SHIELDED) EDGE
Mxy_2_RSP_1_2a_2b_y2 = DFM COPY (EXT M2 Mxy_2_RSP_1_2a_2b_Q3 < 0.09 OPPOSITE EXCLUDE SHIELDED) REGION
Mxy_2_RSP_1_2a_2b_y3 = Mxy_2_RSP_1_2a_2b_y1 TOUCH EDGE (INT M2 [Mxy_2_RSP_1_2a_2b_y1] <= 0.001 ABUT==90 INTERSECTING ONLY MEASURE ALL)
Mxy_2_RSP_1_2a_2b_y4 = EXT Mxy_2_RSP_1_2a_2b_y3 Mxy_2_RSP_1_2a_2b_y1 < 0.072 OPPOSITE PROJ <= 0.082 REGION
Mxy_2_RSP_1_2a_2b_y5 = EXT Mxy_2_RSP_1_2a_2b_y3 Mxy_2_RSP_1_2a_2b_y1 < 0.072 OPPOSITE PROJ <= 0.082
Mxy_2_RSP_1_2a_2b_y6 = RECTANGLE (DFM PROPERTY Mxy_2_RSP_1_2a_2b_y4 Mxy_2_RSP_1_2a_2b_y5 OVERLAP ABUT ALSO MULTI [-= EC(Mxy_2_RSP_1_2a_2b_y5)] <= 0.082)
// 
Mxy_2_RSP_1_2a_2b_y2_c = OR M2EMPTY9696 Mxy_2_RSP_1_2a_2b_y2
Mxy_2_RSP_1_2a_2b_y6_c = OR M2EMPTY9696 Mxy_2_RSP_1_2a_2b_y6
CONNECT Mxy_2_RSP_1_2a_2b_y2_c Mxy_2_RSP_1_2a_2b_y6_c
// 
Mxy_2_RSP_1_2a_2b_ERR1_CHK = EXT Mxy_2_RSP_1_2a_2b_y1 >= 0.072 < 0.09 OPPOSITE REGION EXCLUDE SHIELDED
Mxy_2_RSP_1_2a_2b_ERR1_TMP = EXT ((Mxy_2_RSP_1_2a_2b_y6_c NOT COIN EDGE M2) COIN EDGE Mxy_2_RSP_1_2a_2b_ERR1_CHK) < 0.298 CONNECTED REGION
Mxy_2_RSP_1_2a_2b_ERR1 = Mxy_2_RSP_1_2a_2b_ERR1_TMP OR (Mxy_2_RSP_1_2a_2b_y6 INTERACT (COPY Mxy_2_RSP_1_2a_2b_y6) >= 3 SINGULAR ALSO)
// 
Mxy_2_RSP_1_2a_2b_CA = EXT Mxy_2_RSP_1_2a_2b_y3 Mxy_2_RSP_1_2a_2b_y1 < 0.041 OPPOSITE REGION
Mxy_2_RSP_1_2a_2b_CA_side = Mxy_2_RSP_1_2a_2b_CA NOT COIN EDGE M2
Mxy_2_RSP_1_2a_2b_CA_area = INT Mxy_2_RSP_1_2a_2b_CA_side Mxy_2_RSP_1_2a_2b_CA <= 0.082 REGION
// 
Mxy_2_RSP_1_2a_2b_ERR2_CHK = Mxy_2_RSP_1_2a_2b_CA_side NOT TOUCH EDGE Mxy_2_RSP_1_2a_2b_CA_area
Mxy_2_RSP_1_2a_2b_ERR2_TMP = (NOT RECTANGLE Mxy_2_RSP_1_2a_2b_y2) OR ((RECTANGLE Mxy_2_RSP_1_2a_2b_y2) ENCLOSE RECTANGLE 0.001 0.269)
Mxy_2_RSP_1_2a_2b_ERR2 = (Mxy_2_RSP_1_2a_2b_CA WITH EDGE Mxy_2_RSP_1_2a_2b_ERR2_CHK) INSIDE Mxy_2_RSP_1_2a_2b_ERR2_TMP
// 
Mxy_2_RSP_1_2a_2b_CB = EXT Mxy_2_RSP_1_2a_2b_y3 Mxy_2_RSP_1_2a_2b_y1 < 0.032 OPPOSITE REGION
Mxy_2_RSP_1_2a_2b_CB_side = Mxy_2_RSP_1_2a_2b_CB NOT COIN EDGE M2
Mxy_2_RSP_1_2a_2b_CB_area = INT Mxy_2_RSP_1_2a_2b_CB_side <= 0.082 REGION
// 
Mxy_2_RSP_1_2a_2b_ERR3_CHK = Mxy_2_RSP_1_2a_2b_CB_side TOUCH EDGE Mxy_2_RSP_1_2a_2b_CB_area
Mxy_2_RSP_1_2a_2b_ERR3_TMP = (NOT RECTANGLE Mxy_2_RSP_1_2a_2b_y2) OR ((RECTANGLE Mxy_2_RSP_1_2a_2b_y2) ENCLOSE RECTANGLE 0.001 0.269)
Mxy_2_RSP_1_2a_2b_ERR3 = (Mxy_2_RSP_1_2a_2b_CB WITH EDGE Mxy_2_RSP_1_2a_2b_ERR3_CHK) INSIDE Mxy_2_RSP_1_2a_2b_ERR3_TMP
 
M2_RSP_1 {
@ Space between metal space segments with S2 < 0.072 and L2 <= 0.082um
@ Metal space segments definition:
@ 1) At least one metal line width > 0.07um (W1) and PRL > 0.27um (L1) in metal space < 0.09um (S1) region
@ 2) Metal space segments within metal space (S1) region and are generated by space cut line which is perpendicular with L1 direction formed by all vertex in metal space region (S1)
@ 3) Metal space segments at least abut one metal with width > 0.07um (W1)
@ 4) L2 is the width of metal space segments which is parallel with L1 direction
@ 5) S2 is the width of metal space segments which is perpendicular with L1 direction. >= 0.298um
 Mxy_2_RSP_1_2a_2b_ERR1 NOT INSIDE SealR_NOT_BULK
}
 
M2_RSP_2a {
@ Width (S2) of metal space segments with L2 > 0.082um (0.063 <= S < 0.072 is forbidden)
@ Metal space segments definition:
@ 1) At least one metal line width > 0.07um (W1) and PRL > 0.27um (L1) in metal space < 0.09um (S1) region
@ 2) Metal space segments within metal space (S1) region and are generated by space cut line which is perpendicular with L1 direction formed by all vertex in metal space region (S1)
@ 3) Metal space segments at least abut one metal with width > 0.07um (W1)
@ 4) L2 is the width of metal space segments which is parallel with L1 direction
@ 5) S2 is the width of metal space segments which is perpendicular with L1 direction. >= 0.041um
 Mxy_2_RSP_1_2a_2b_ERR2 NOT INSIDE SealR_NOT_BULK
 // 
 forbidden_RSP_1_2a_2b_A1 = EXT Mxy_2_RSP_1_2a_2b_Y3 Mxy_2_RSP_1_2a_2b_Y1 >= 0.063 < 0.072 OPPOSITE REGION
 forbidden_RSP_1_2a_2b_A1_edge = forbidden_RSP_1_2a_2b_A1 NOT COIN EDGE M2
 forbidden_RSP_1_2a_2b_A1_area = INT forbidden_RSP_1_2a_2b_A1_edge forbidden_RSP_1_2a_2b_A1 <= 0.082 REGION
 forbidden_RSP_1_2a_2b_A1_1 = forbidden_RSP_1_2a_2b_A1_edge NOT TOUCH EDGE forbidden_RSP_1_2a_2b_A1_area
 forbidden_RSP_1_2a_2b_ERR2 = (NOT RECTANGLE Mxy_2_RSP_1_2a_2b_Y2) OR ((RECTANGLE Mxy_2_RSP_1_2a_2b_Y2) ENCLOSE RECTANGLE 0.001 0.269)
 err2 = (forbidden_RSP_1_2a_2b_A1 WITH EDGE forbidden_RSP_1_2a_2b_A1_1) INSIDE forbidden_RSP_1_2a_2b_ERR2
 err2 NOT INSIDE SealR_NOT_BULK
}
 
M2_RSP_2b {
@ Width (S2) of metal space segments with L2 <= 0.082um
@ Metal space segments definition:
@ 1) At least one metal line width > 0.07um (W1) and PRL > 0.27um (L1) in metal space < 0.090um (S1) region
@ 2) Metal space segments within metal space (S1) region and are generated by space cut line which is perpendicular with L1 direction formed by all vertex in metal space region (S1)
@ 3) Metal space segments at least abut one metal with width > 0.07um (W1)
@ 4) L2 is the width of metal space segments which is parallel with L1 direction
@ 5) S2 is the width of metal space segments which is perpendicular with L1 direction. >= 0.032um
 Mxy_2_RSP_1_2a_2b_ERR3 NOT INSIDE SealR_NOT_BULK
}
 
Mxy_2_RSP_3_4a_4b_met = ENCLOSE RECTANGLE (M2 INTERACT (M2 WITH WIDTH > 0.088)) 0.089 0.271 ORTHOGONAL ONLY
Mxy_2_RSP_3_4a_4b_wid = INT (Mxy_2_RSP_3_4a_4b_met) <= 0.088 OPPOSITE EXCLUDE SHIELDED
Mxy_2_RSP_3_4a_4b_wan = LENGTH (M2_convex_270_90_edges COIN EDGE Mxy_2_RSP_3_4a_4b_met) < 0.108 - 0.032
Mxy_2_RSP_3_4a_4b_sps = Mxy_2_RSP_3_4a_4b_met COIN EDGE (EXT Mxy_2_RSP_3_4a_4b_met M2 < 0.108 OPPOSITE REGION EXCLUDE SHIELDED)
// 
Mxy_2_RSP_3_4a_4b_sps_sides_A = (Mxy_2_RSP_3_4a_4b_wid COIN EDGE Mxy_2_RSP_3_4a_4b_sps) NOT COIN EDGE (LENGTH (Mxy_2_RSP_3_4a_4b_wid NOT TOUCH EDGE 
(INT [Mxy_2_RSP_3_4a_4b_wid] Mxy_2_RSP_3_4a_4b_wan < 0.001 ABUT==90 INTERSECTING ONLY)) <= 0.27)
Mxy_2_RSP_3_4a_4b_sps_sides_B = (Mxy_2_RSP_3_4a_4b_wid COIN EDGE Mxy_2_RSP_3_4a_4b_sps) NOT COIN EDGE (LENGTH (Mxy_2_RSP_3_4a_4b_wid NOT TOUCH EDGE 
(EXT [Mxy_2_RSP_3_4a_4b_wid] Mxy_2_RSP_3_4a_4b_wan < 0.001 ABUT==90 INTERSECTING ONLY)) <= 0.27)
Mxy_2_RSP_3_4a_4b_sps_sides = Mxy_2_RSP_3_4a_4b_sps_sides_A OR EDGE Mxy_2_RSP_3_4a_4b_sps_sides_B
Mxy_2_RSP_3_4a_4b_sps_sides_PRL = Mxy_2_RSP_3_4a_4b_sps_sides COIN EDGE (PATH LENGTH (Mxy_2_RSP_3_4a_4b_wan OR EDGE Mxy_2_RSP_3_4a_4b_sps_sides) > 0.27)
// 
Mxy_2_RSP_3_4a_4b_S1_side = EXT M2 Mxy_2_RSP_3_4a_4b_sps_sides_PRL < 0.108 OPPOSITE EXCLUDE SHIELDED
Mxy_2_RSP_3_4a_4b_S1_area = EXT M2 Mxy_2_RSP_3_4a_4b_sps_sides_PRL < 0.108 OPPOSITE EXCLUDE SHIELDED REGION
Mxy_2_RSP_3_4a_4b_S1_rlen = Mxy_2_RSP_3_4a_4b_S1_area ENCLOSE RECTANGLE 0.001 0.271 ORTHOGONAL ONLY
Mxy_2_RSP_3_4a_4b_L1_side = M2 COIN EDGE ((DFM COPY Mxy_2_RSP_3_4a_4b_S1_side EDGE) COIN EDGE Mxy_2_RSP_3_4a_4b_S1_rlen)
Mxy_2_RSP_3_4a_4b_L1_side_jog_sum = Mxy_2_RSP_3_4a_4b_wan OR EDGE Mxy_2_RSP_3_4a_4b_L1_side
Mxy_2_RSP_3_4a_4b_L1_side_jog_sum_EXP = EXPAND EDGE Mxy_2_RSP_3_4a_4b_L1_side_jog_sum INSIDE BY 0.001 CORNER FILL
// 
Mxy_2_RSP_3_4a_4b_Q1 = EXPAND EDGE (Mxy_2_RSP_3_4a_4b_L1_side COIN EDGE Mxy_2_RSP_3_4a_4b_L1_side_jog_sum) INSIDE BY 0.001
Mxy_2_RSP_3_4a_4b_Q2 = Mxy_2_RSP_3_4a_4b_L1_side_jog_sum_EXP INTERACT (AREA Mxy_2_RSP_3_4a_4b_Q1 > 0.27 * 0.001)
Mxy_2_RSP_3_4a_4b_Q3 = Mxy_2_RSP_3_4a_4b_L1_side_jog_sum TOUCH EDGE (LENGTH (Mxy_2_RSP_3_4a_4b_Q1 INTERACT Mxy_2_RSP_3_4a_4b_Q2) > 0.001)
// 
Mxy_2_RSP_3_4a_4b_y1 = DFM COPY (EXT M2 Mxy_2_RSP_3_4a_4b_Q3 < 0.108 OPPOSITE EXCLUDE SHIELDED) EDGE
Mxy_2_RSP_3_4a_4b_y2 = DFM COPY (EXT M2 Mxy_2_RSP_3_4a_4b_Q3 < 0.108 OPPOSITE EXCLUDE SHIELDED) REGION
Mxy_2_RSP_3_4a_4b_y3 = Mxy_2_RSP_3_4a_4b_y1 TOUCH EDGE (INT M2 [Mxy_2_RSP_3_4a_4b_y1] <= 0.001 ABUT==90 INTERSECTING ONLY MEASURE ALL)
Mxy_2_RSP_3_4a_4b_y4 = EXT Mxy_2_RSP_3_4a_4b_y3 Mxy_2_RSP_3_4a_4b_y1 < 0.081 OPPOSITE PROJ <= 0.082 REGION
Mxy_2_RSP_3_4a_4b_y5 = EXT Mxy_2_RSP_3_4a_4b_y3 Mxy_2_RSP_3_4a_4b_y1 < 0.081 OPPOSITE PROJ <= 0.082
Mxy_2_RSP_3_4a_4b_y6 = RECTANGLE (DFM PROPERTY Mxy_2_RSP_3_4a_4b_y4 Mxy_2_RSP_3_4a_4b_y5 OVERLAP ABUT ALSO MULTI [-= EC(Mxy_2_RSP_3_4a_4b_y5)] <= 0.082)
// 
Mxy_2_RSP_3_4a_4b_y2_c = OR M2EMPTY9696 Mxy_2_RSP_3_4a_4b_y2
Mxy_2_RSP_3_4a_4b_y6_c = OR M2EMPTY9696 Mxy_2_RSP_3_4a_4b_y6
CONNECT Mxy_2_RSP_3_4a_4b_y2_c Mxy_2_RSP_3_4a_4b_y6_c
// 
Mxy_2_RSP_3_4a_4b_ERR1_CHK = EXT Mxy_2_RSP_3_4a_4b_y1 >= 0.081 < 0.108 OPPOSITE REGION EXCLUDE SHIELDED
Mxy_2_RSP_3_4a_4b_ERR1_TMP = EXT ((Mxy_2_RSP_3_4a_4b_y6_c NOT COIN EDGE M2) COIN EDGE Mxy_2_RSP_3_4a_4b_ERR1_CHK) < 0.298 CONNECTED REGION
Mxy_2_RSP_3_4a_4b_ERR1 = Mxy_2_RSP_3_4a_4b_ERR1_TMP OR (Mxy_2_RSP_3_4a_4b_y6 INTERACT (COPY Mxy_2_RSP_3_4a_4b_y6) >= 3 SINGULAR ALSO)
// 
Mxy_2_RSP_3_4a_4b_CA = EXT Mxy_2_RSP_3_4a_4b_y3 Mxy_2_RSP_3_4a_4b_y1 < 0.041 OPPOSITE REGION
Mxy_2_RSP_3_4a_4b_CA_side = Mxy_2_RSP_3_4a_4b_CA NOT COIN EDGE M2
Mxy_2_RSP_3_4a_4b_CA_area = INT Mxy_2_RSP_3_4a_4b_CA_side Mxy_2_RSP_3_4a_4b_CA <= 0.082 REGION
// 
Mxy_2_RSP_3_4a_4b_ERR2_CHK = Mxy_2_RSP_3_4a_4b_CA_side NOT TOUCH EDGE Mxy_2_RSP_3_4a_4b_CA_area
Mxy_2_RSP_3_4a_4b_ERR2_TMP = (NOT RECTANGLE Mxy_2_RSP_3_4a_4b_y2) OR ((RECTANGLE Mxy_2_RSP_3_4a_4b_y2) ENCLOSE RECTANGLE 0.001 0.269)
Mxy_2_RSP_3_4a_4b_ERR2 = (Mxy_2_RSP_3_4a_4b_CA WITH EDGE Mxy_2_RSP_3_4a_4b_ERR2_CHK) INSIDE Mxy_2_RSP_3_4a_4b_ERR2_TMP
// 
Mxy_2_RSP_3_4a_4b_CB = EXT Mxy_2_RSP_3_4a_4b_y3 Mxy_2_RSP_3_4a_4b_y1 < 0.041 OPPOSITE REGION
Mxy_2_RSP_3_4a_4b_CB_side = Mxy_2_RSP_3_4a_4b_CB NOT COIN EDGE M2
Mxy_2_RSP_3_4a_4b_CB_area = INT Mxy_2_RSP_3_4a_4b_CB_side <= 0.082 REGION
// 
Mxy_2_RSP_3_4a_4b_ERR3_CHK = Mxy_2_RSP_3_4a_4b_CB_side TOUCH EDGE Mxy_2_RSP_3_4a_4b_CB_area
Mxy_2_RSP_3_4a_4b_ERR3_TMP = (NOT RECTANGLE Mxy_2_RSP_3_4a_4b_y2) OR ((RECTANGLE Mxy_2_RSP_3_4a_4b_y2) ENCLOSE RECTANGLE 0.001 0.269)
Mxy_2_RSP_3_4a_4b_ERR3 = (Mxy_2_RSP_3_4a_4b_CB WITH EDGE Mxy_2_RSP_3_4a_4b_ERR3_CHK) INSIDE Mxy_2_RSP_3_4a_4b_ERR3_TMP
 
M2_RSP_3 {
@ Space between metal space segments with S2 < 0.081 and L2 <= 0.082um
@ Metal space segments definition:
@ 1) At least one metal line width > 0.088um (W1) and PRL > 0.27um (L1) in metal space < 0.108um (S1) region
@ 2) Metal space segments within metal space (S1) region and are generated by space cut line which is perpendicular with L1 direction formed by all vertex in metal space region (S1)
@ 3) Metal space segments at least abut one metal with width > 0.088um (W1)
@ 4) L2 is the width of metal space segments which is parallel with L1 direction
@ 5) S2 is the width of metal space segments which is perpendicular with L1 direction. >= 0.298um
 Mxy_2_RSP_3_4a_4b_ERR1 NOT INSIDE SealR_NOT_BULK
}
 
M2_RSP_4a {
@ Width (S2) of metal space segments with L2 > 0.082um (0.063um <= S < 0.081um is forbidden)
@ Metal space segments definition:
@ 1) At least one metal line width > 0.088um (W1) and PRL > 0.27um (L1) in metal space < 0.108um (S1) region
@ 2) Metal space segments within metal space (S1) region and are generated by space cut line which is perpendicular with L1 direction formed by all vertex in metal space region (S1)
@ 3) Metal space segments at least abut one metal with width > 0.088um (W1)
@ 4) L2 is the width of metal space segments which is parallel with L1 direction
@ 5) S2 is the width of metal space segments which is perpendicular with L1 direction. >= 0.041um
 Mxy_2_RSP_3_4a_4b_ERR2 NOT INSIDE SealR_NOT_BULK
 // 
 forbidden_RSP_3_4a_4b_A1 = EXT Mxy_2_RSP_3_4a_4b_Y3 Mxy_2_RSP_3_4a_4b_Y1 >= 0.063 < 0.081 OPPOSITE REGION
 forbidden_RSP_3_4a_4b_A1_edge = forbidden_RSP_3_4a_4b_A1 NOT COIN EDGE M2
 forbidden_RSP_3_4a_4b_A1_area = INT forbidden_RSP_3_4a_4b_A1_edge forbidden_RSP_3_4a_4b_A1 <= 0.082 REGION
 forbidden_RSP_3_4a_4b_A1_1 = forbidden_RSP_3_4a_4b_A1_edge NOT TOUCH EDGE forbidden_RSP_3_4a_4b_A1_area
 forbidden_RSP_3_4a_4b_ERR2 = (NOT RECTANGLE Mxy_2_RSP_3_4a_4b_Y2) OR ((RECTANGLE Mxy_2_RSP_3_4a_4b_Y2) ENCLOSE RECTANGLE 0.001 0.269)
 err2 = (forbidden_RSP_3_4a_4b_A1 WITH EDGE forbidden_RSP_3_4a_4b_A1_1) INSIDE forbidden_RSP_3_4a_4b_ERR2
 err2 NOT INSIDE SealR_NOT_BULK
}
 
M2_RSP_4b {
@ Width (S2) of metal space segments with L2 <= 0.082um (0.063um <= S < 0.072um is forbidden)
@ Metal space segments definition:
@ 1) At least one metal line width > 0.088um (W1) and PRL > 0.270um (L1) in metal space < 0.108um (S1) region
@ 2) Metal space segments within metal space (S1) region and are generated by space cut line which is perpendicular with L1 direction formed by all vertex in metal space region (S1)
@ 3) Metal space segments at least abut one metal with width > 0.088um (W1)
@ 4) L2 is the width of metal space segments which is parallel with L1 direction
@ 5) S2 is the width of metal space segments which is perpendicular with L1 direction. >= 0.041um
 Mxy_2_RSP_3_4a_4b_ERR3 NOT INSIDE SealR_NOT_BULK
 // 
 forbidden_RSP_3_4a_4b_A2 = EXT Mxy_2_RSP_3_4a_4b_Y3 Mxy_2_RSP_3_4a_4b_Y1 >= 0.063 < 0.072 OPPOSITE REGION
 forbidden_RSP_3_4a_4b_A2_edge = forbidden_RSP_3_4a_4b_A2 NOT COIN EDGE M2
 forbidden_RSP_3_4a_4b_A2_area = INT forbidden_RSP_3_4a_4b_A2_edge <= 0.082 REGION
 forbidden_RSP_3_4a_4b_A2_2 = forbidden_RSP_3_4a_4b_A2_edge TOUCH EDGE forbidden_RSP_3_4a_4b_A2_area
 forbidden_RSP_3_4a_4b_ERR3 = (NOT RECTANGLE Mxy_2_RSP_3_4a_4b_Y2) OR ((RECTANGLE Mxy_2_RSP_3_4a_4b_Y2) ENCLOSE RECTANGLE 0.001 0.269)
 err2 = (forbidden_RSP_3_4a_4b_A2 WITH EDGE forbidden_RSP_3_4a_4b_A2_2) INSIDE forbidden_RSP_3_4a_4b_ERR3
 err2 NOT INSIDE SealR_NOT_BULK
}
 
Mxy_2_RSP_5_6a_6b_met = ENCLOSE RECTANGLE (M2 INTERACT (M2 WITH WIDTH > 0.112)) 0.113 0.271 ORTHOGONAL ONLY
Mxy_2_RSP_5_6a_6b_wid = INT (Mxy_2_RSP_5_6a_6b_met) <= 0.112 OPPOSITE EXCLUDE SHIELDED
Mxy_2_RSP_5_6a_6b_wan = LENGTH (M2_convex_270_90_edges COIN EDGE Mxy_2_RSP_5_6a_6b_met) < 0.126 - 0.032
Mxy_2_RSP_5_6a_6b_sps = Mxy_2_RSP_5_6a_6b_met COIN EDGE (EXT Mxy_2_RSP_5_6a_6b_met M2 < 0.126 OPPOSITE REGION EXCLUDE SHIELDED)
// 
Mxy_2_RSP_5_6a_6b_sps_sides_A = (Mxy_2_RSP_5_6a_6b_wid COIN EDGE Mxy_2_RSP_5_6a_6b_sps) NOT COIN EDGE (LENGTH (Mxy_2_RSP_5_6a_6b_wid NOT TOUCH EDGE 
(INT [Mxy_2_RSP_5_6a_6b_wid] Mxy_2_RSP_5_6a_6b_wan < 0.001 ABUT==90 INTERSECTING ONLY)) <= 0.27)
Mxy_2_RSP_5_6a_6b_sps_sides_B = (Mxy_2_RSP_5_6a_6b_wid COIN EDGE Mxy_2_RSP_5_6a_6b_sps) NOT COIN EDGE (LENGTH (Mxy_2_RSP_5_6a_6b_wid NOT TOUCH EDGE 
(EXT [Mxy_2_RSP_5_6a_6b_wid] Mxy_2_RSP_5_6a_6b_wan < 0.001 ABUT==90 INTERSECTING ONLY)) <= 0.27)
Mxy_2_RSP_5_6a_6b_sps_sides = Mxy_2_RSP_5_6a_6b_sps_sides_A OR EDGE Mxy_2_RSP_5_6a_6b_sps_sides_B
Mxy_2_RSP_5_6a_6b_sps_sides_PRL = Mxy_2_RSP_5_6a_6b_sps_sides COIN EDGE (PATH LENGTH (Mxy_2_RSP_5_6a_6b_wan OR EDGE Mxy_2_RSP_5_6a_6b_sps_sides) > 0.27)
// 
Mxy_2_RSP_5_6a_6b_S1_side = EXT M2 Mxy_2_RSP_5_6a_6b_sps_sides_PRL < 0.126 OPPOSITE EXCLUDE SHIELDED
Mxy_2_RSP_5_6a_6b_S1_area = EXT M2 Mxy_2_RSP_5_6a_6b_sps_sides_PRL < 0.126 OPPOSITE EXCLUDE SHIELDED REGION
Mxy_2_RSP_5_6a_6b_S1_rlen = Mxy_2_RSP_5_6a_6b_S1_area ENCLOSE RECTANGLE 0.001 0.271 ORTHOGONAL ONLY
Mxy_2_RSP_5_6a_6b_L1_side = M2 COIN EDGE ((DFM COPY Mxy_2_RSP_5_6a_6b_S1_side EDGE) COIN EDGE Mxy_2_RSP_5_6a_6b_S1_rlen)
Mxy_2_RSP_5_6a_6b_L1_side_jog_sum = Mxy_2_RSP_5_6a_6b_wan OR EDGE Mxy_2_RSP_5_6a_6b_L1_side
Mxy_2_RSP_5_6a_6b_L1_side_jog_sum_EXP = EXPAND EDGE Mxy_2_RSP_5_6a_6b_L1_side_jog_sum INSIDE BY 0.001 CORNER FILL
// 
Mxy_2_RSP_5_6a_6b_Q1 = EXPAND EDGE (Mxy_2_RSP_5_6a_6b_L1_side COIN EDGE Mxy_2_RSP_5_6a_6b_L1_side_jog_sum) INSIDE BY 0.001
Mxy_2_RSP_5_6a_6b_Q2 = Mxy_2_RSP_5_6a_6b_L1_side_jog_sum_EXP INTERACT (AREA Mxy_2_RSP_5_6a_6b_Q1 > 0.27 * 0.001)
Mxy_2_RSP_5_6a_6b_Q3 = Mxy_2_RSP_5_6a_6b_L1_side_jog_sum TOUCH EDGE (LENGTH (Mxy_2_RSP_5_6a_6b_Q1 INTERACT Mxy_2_RSP_5_6a_6b_Q2) > 0.001)
// 
Mxy_2_RSP_5_6a_6b_y1 = DFM COPY (EXT M2 Mxy_2_RSP_5_6a_6b_Q3 < 0.126 OPPOSITE EXCLUDE SHIELDED) EDGE
Mxy_2_RSP_5_6a_6b_y2 = DFM COPY (EXT M2 Mxy_2_RSP_5_6a_6b_Q3 < 0.126 OPPOSITE EXCLUDE SHIELDED) REGION
Mxy_2_RSP_5_6a_6b_y3 = Mxy_2_RSP_5_6a_6b_y1 TOUCH EDGE (INT M2 [Mxy_2_RSP_5_6a_6b_y1] <= 0.001 ABUT==90 INTERSECTING ONLY MEASURE ALL)
Mxy_2_RSP_5_6a_6b_y4 = EXT Mxy_2_RSP_5_6a_6b_y3 Mxy_2_RSP_5_6a_6b_y1 < 0.106 OPPOSITE PROJ <= 0.082 REGION
Mxy_2_RSP_5_6a_6b_y5 = EXT Mxy_2_RSP_5_6a_6b_y3 Mxy_2_RSP_5_6a_6b_y1 < 0.106 OPPOSITE PROJ <= 0.082
Mxy_2_RSP_5_6a_6b_y6 = RECTANGLE (DFM PROPERTY Mxy_2_RSP_5_6a_6b_y4 Mxy_2_RSP_5_6a_6b_y5 OVERLAP ABUT ALSO MULTI [-= EC(Mxy_2_RSP_5_6a_6b_y5)] <= 0.082)
// 
Mxy_2_RSP_5_6a_6b_y2_c = OR M2EMPTY9696 Mxy_2_RSP_5_6a_6b_y2
Mxy_2_RSP_5_6a_6b_y6_c = OR M2EMPTY9696 Mxy_2_RSP_5_6a_6b_y6
CONNECT Mxy_2_RSP_5_6a_6b_y2_c Mxy_2_RSP_5_6a_6b_y6_c
// 
Mxy_2_RSP_5_6a_6b_ERR1_CHK = EXT Mxy_2_RSP_5_6a_6b_y1 >= 0.106 < 0.126 OPPOSITE REGION EXCLUDE SHIELDED
Mxy_2_RSP_5_6a_6b_ERR1_TMP = EXT ((Mxy_2_RSP_5_6a_6b_y6_c NOT COIN EDGE M2) COIN EDGE Mxy_2_RSP_5_6a_6b_ERR1_CHK) < 0.298 CONNECTED REGION
Mxy_2_RSP_5_6a_6b_ERR1 = Mxy_2_RSP_5_6a_6b_ERR1_TMP OR (Mxy_2_RSP_5_6a_6b_y6 INTERACT (COPY Mxy_2_RSP_5_6a_6b_y6) >= 3 SINGULAR ALSO)
// 
Mxy_2_RSP_5_6a_6b_CA = EXT Mxy_2_RSP_5_6a_6b_y3 Mxy_2_RSP_5_6a_6b_y1 < 0.041 OPPOSITE REGION
Mxy_2_RSP_5_6a_6b_CA_side = Mxy_2_RSP_5_6a_6b_CA NOT COIN EDGE M2
Mxy_2_RSP_5_6a_6b_CA_area = INT Mxy_2_RSP_5_6a_6b_CA_side Mxy_2_RSP_5_6a_6b_CA <= 0.082 REGION
// 
Mxy_2_RSP_5_6a_6b_ERR2_CHK = Mxy_2_RSP_5_6a_6b_CA_side NOT TOUCH EDGE Mxy_2_RSP_5_6a_6b_CA_area
Mxy_2_RSP_5_6a_6b_ERR2_TMP = (NOT RECTANGLE Mxy_2_RSP_5_6a_6b_y2) OR ((RECTANGLE Mxy_2_RSP_5_6a_6b_y2) ENCLOSE RECTANGLE 0.001 0.269)
Mxy_2_RSP_5_6a_6b_ERR2 = (Mxy_2_RSP_5_6a_6b_CA WITH EDGE Mxy_2_RSP_5_6a_6b_ERR2_CHK) INSIDE Mxy_2_RSP_5_6a_6b_ERR2_TMP
// 
Mxy_2_RSP_5_6a_6b_CB = EXT Mxy_2_RSP_5_6a_6b_y3 Mxy_2_RSP_5_6a_6b_y1 < 0.041 OPPOSITE REGION
Mxy_2_RSP_5_6a_6b_CB_side = Mxy_2_RSP_5_6a_6b_CB NOT COIN EDGE M2
Mxy_2_RSP_5_6a_6b_CB_area = INT Mxy_2_RSP_5_6a_6b_CB_side <= 0.082 REGION
// 
Mxy_2_RSP_5_6a_6b_ERR3_CHK = Mxy_2_RSP_5_6a_6b_CB_side TOUCH EDGE Mxy_2_RSP_5_6a_6b_CB_area
Mxy_2_RSP_5_6a_6b_ERR3_TMP = (NOT RECTANGLE Mxy_2_RSP_5_6a_6b_y2) OR ((RECTANGLE Mxy_2_RSP_5_6a_6b_y2) ENCLOSE RECTANGLE 0.001 0.269)
Mxy_2_RSP_5_6a_6b_ERR3 = (Mxy_2_RSP_5_6a_6b_CB WITH EDGE Mxy_2_RSP_5_6a_6b_ERR3_CHK) INSIDE Mxy_2_RSP_5_6a_6b_ERR3_TMP
 
M2_RSP_5 {
@ Space between metal space segments with S2 < 0.106um and L2 <= 0.082um
@ Metal space segments definition:
@ 1) At least one metal line width > 0.112um (W1) and PRL > 0.270um (L1) in metal space < 0.126um (S1) region
@ 2) Metal space segments within metal space (S1) region and are generated by space cut line which is perpendicular with L1 direction formed by all vertex in metal space region (S1)
@ 3) Metal space segments at least abut one metal with width > 0.112um (W1)
@ 4) L2 is the width of metal space segments which is parallel with L1 direction
@ 5) S2 is the width of metal space segments which is perpendicular with L1 direction. >= 0.298um
 Mxy_2_RSP_5_6a_6b_ERR1 NOT INSIDE SealR_NOT_BULK
}
 
M2_RSP_6a {
@ Width (S2) of metal space segments with L2 > 0.082um (0.063um <= S < 0.106um is forbidden)
@ Metal space segments definition:
@ 1) At least one metal line width > 0.112um (W1) and PRL > 0.27um (L1) in metal space < 0.126um (S1) region
@ 2) Metal space segments within metal space (S1) region and are generated by space cut line which is perpendicular with L1 direction formed by all vertex in metal space region (S1)
@ 3) Metal space segments at least abut one metal with width > 0.112um (W1)
@ 4) L2 is the width of metal space segments which is parallel with L1 direction
@ 5) S2 is the width of metal space segments which is perpendicular with L1 direction. >= 0.041um
 Mxy_2_RSP_5_6a_6b_ERR2 NOT INSIDE SealR_NOT_BULK
 // 
 forbidden_RSP_5_6a_6b_A1 = EXT Mxy_2_RSP_5_6a_6b_Y3 Mxy_2_RSP_5_6a_6b_Y1 >= 0.063 < 0.106 OPPOSITE REGION
 forbidden_RSP_5_6a_6b_A1_edge = forbidden_RSP_5_6a_6b_A1 NOT COIN EDGE M2
 forbidden_RSP_5_6a_6b_A1_area = INT forbidden_RSP_5_6a_6b_A1_edge forbidden_RSP_5_6a_6b_A1 <= 0.082 REGION
 forbidden_RSP_5_6a_6b_A1_1 = forbidden_RSP_5_6a_6b_A1_edge NOT TOUCH EDGE forbidden_RSP_5_6a_6b_A1_area
 forbidden_RSP_5_6a_6b_ERR2 = (NOT RECTANGLE Mxy_2_RSP_5_6a_6b_Y2) OR ((RECTANGLE Mxy_2_RSP_5_6a_6b_Y2) ENCLOSE RECTANGLE 0.001 0.269)
 err2 = (forbidden_RSP_5_6a_6b_A1 WITH EDGE forbidden_RSP_5_6a_6b_A1_1) INSIDE forbidden_RSP_5_6a_6b_ERR2
 err2 NOT INSIDE SealR_NOT_BULK
}
 
M2_RSP_6b {
@ Width (S2) of metal space segments with L2 <= 0.082um (0.063um <= S < 0.081um is forbidden)
@ Metal space segments definition:
@ 1) At least one metal line width > 0.112um (W1) and PRL > 0.27um (L1) in metal space < 0.126um (S1) region
@ 2) Metal space segments within metal space (S1) region and are generated by space cut line which is perpendicular with L1 direction formed by all vertex in metal space region (S1)
@ 3) Metal space segments at least abut one metal with width > 0.112um (W1)
@ 4) L2 is the width of metal space segments which is parallel with L1 direction
@ 5) S2 is the width of metal space segments which is perpendicular with L1 direction. >= 0.041um
 Mxy_2_RSP_5_6a_6b_ERR3 NOT INSIDE SealR_NOT_BULK
 // 
 forbidden_RSP_5_6a_6b_A2 = EXT Mxy_2_RSP_5_6a_6b_Y3 Mxy_2_RSP_5_6a_6b_Y1 >= 0.063 < 0.081 OPPOSITE REGION
 forbidden_RSP_5_6a_6b_A2_edge = forbidden_RSP_5_6a_6b_A2 NOT COIN EDGE M2
 forbidden_RSP_5_6a_6b_A2_area = INT forbidden_RSP_5_6a_6b_A2_edge <= 0.082 REGION
 forbidden_RSP_5_6a_6b_A2_2 = forbidden_RSP_5_6a_6b_A2_edge TOUCH EDGE forbidden_RSP_5_6a_6b_A2_area
 forbidden_RSP_5_6a_6b_ERR3 = (NOT RECTANGLE Mxy_2_RSP_5_6a_6b_Y2) OR ((RECTANGLE Mxy_2_RSP_5_6a_6b_Y2) ENCLOSE RECTANGLE 0.001 0.269)
 err2 = (forbidden_RSP_5_6a_6b_A2 WITH EDGE forbidden_RSP_5_6a_6b_A2_2) INSIDE forbidden_RSP_5_6a_6b_ERR3
 err2 NOT INSIDE SealR_NOT_BULK
}
 
Mxy_2_RSP_7_8a_8b_met = ENCLOSE RECTANGLE (M2 INTERACT (M2 WITH WIDTH > 0.180)) 0.181 0.271 ORTHOGONAL ONLY
Mxy_2_RSP_7_8a_8b_wid = INT (Mxy_2_RSP_7_8a_8b_met) <= 0.180 OPPOSITE EXCLUDE SHIELDED
Mxy_2_RSP_7_8a_8b_wan = LENGTH (M2_convex_270_90_edges COIN EDGE Mxy_2_RSP_7_8a_8b_met) < 0.144 - 0.032
Mxy_2_RSP_7_8a_8b_sps = Mxy_2_RSP_7_8a_8b_met COIN EDGE (EXT Mxy_2_RSP_7_8a_8b_met M2 < 0.144 OPPOSITE REGION EXCLUDE SHIELDED)
// 
Mxy_2_RSP_7_8a_8b_sps_sides_A = (Mxy_2_RSP_7_8a_8b_wid COIN EDGE Mxy_2_RSP_7_8a_8b_sps) NOT COIN EDGE (LENGTH (Mxy_2_RSP_7_8a_8b_wid NOT TOUCH EDGE 
(INT [Mxy_2_RSP_7_8a_8b_wid] Mxy_2_RSP_7_8a_8b_wan < 0.001 ABUT==90 INTERSECTING ONLY)) <= 0.27)
Mxy_2_RSP_7_8a_8b_sps_sides_B = (Mxy_2_RSP_7_8a_8b_wid COIN EDGE Mxy_2_RSP_7_8a_8b_sps) NOT COIN EDGE (LENGTH (Mxy_2_RSP_7_8a_8b_wid NOT TOUCH EDGE 
(EXT [Mxy_2_RSP_7_8a_8b_wid] Mxy_2_RSP_7_8a_8b_wan < 0.001 ABUT==90 INTERSECTING ONLY)) <= 0.27)
Mxy_2_RSP_7_8a_8b_sps_sides = Mxy_2_RSP_7_8a_8b_sps_sides_A OR EDGE Mxy_2_RSP_7_8a_8b_sps_sides_B
Mxy_2_RSP_7_8a_8b_sps_sides_PRL = Mxy_2_RSP_7_8a_8b_sps_sides COIN EDGE (PATH LENGTH (Mxy_2_RSP_7_8a_8b_wan OR EDGE Mxy_2_RSP_7_8a_8b_sps_sides) > 0.27)
// 
Mxy_2_RSP_7_8a_8b_S1_side = EXT M2 Mxy_2_RSP_7_8a_8b_sps_sides_PRL < 0.144 OPPOSITE EXCLUDE SHIELDED
Mxy_2_RSP_7_8a_8b_S1_area = EXT M2 Mxy_2_RSP_7_8a_8b_sps_sides_PRL < 0.144 OPPOSITE EXCLUDE SHIELDED REGION
Mxy_2_RSP_7_8a_8b_S1_rlen = Mxy_2_RSP_7_8a_8b_S1_area ENCLOSE RECTANGLE 0.001 0.271 ORTHOGONAL ONLY
Mxy_2_RSP_7_8a_8b_L1_side = M2 COIN EDGE ((DFM COPY Mxy_2_RSP_7_8a_8b_S1_side EDGE) COIN EDGE Mxy_2_RSP_7_8a_8b_S1_rlen)
Mxy_2_RSP_7_8a_8b_L1_side_jog_sum = Mxy_2_RSP_7_8a_8b_wan OR EDGE Mxy_2_RSP_7_8a_8b_L1_side
Mxy_2_RSP_7_8a_8b_L1_side_jog_sum_EXP = EXPAND EDGE Mxy_2_RSP_7_8a_8b_L1_side_jog_sum INSIDE BY 0.001 CORNER FILL
// 
Mxy_2_RSP_7_8a_8b_Q1 = EXPAND EDGE (Mxy_2_RSP_7_8a_8b_L1_side COIN EDGE Mxy_2_RSP_7_8a_8b_L1_side_jog_sum) INSIDE BY 0.001
Mxy_2_RSP_7_8a_8b_Q2 = Mxy_2_RSP_7_8a_8b_L1_side_jog_sum_EXP INTERACT (AREA Mxy_2_RSP_7_8a_8b_Q1 > 0.27 * 0.001)
Mxy_2_RSP_7_8a_8b_Q3 = Mxy_2_RSP_7_8a_8b_L1_side_jog_sum TOUCH EDGE (LENGTH (Mxy_2_RSP_7_8a_8b_Q1 INTERACT Mxy_2_RSP_7_8a_8b_Q2) > 0.001)
// 
Mxy_2_RSP_7_8a_8b_y1 = DFM COPY (EXT M2 Mxy_2_RSP_7_8a_8b_Q3 < 0.144 OPPOSITE EXCLUDE SHIELDED) EDGE
Mxy_2_RSP_7_8a_8b_y2 = DFM COPY (EXT M2 Mxy_2_RSP_7_8a_8b_Q3 < 0.144 OPPOSITE EXCLUDE SHIELDED) REGION
Mxy_2_RSP_7_8a_8b_y3 = Mxy_2_RSP_7_8a_8b_y1 TOUCH EDGE (INT M2 [Mxy_2_RSP_7_8a_8b_y1] <= 0.001 ABUT==90 INTERSECTING ONLY MEASURE ALL)
Mxy_2_RSP_7_8a_8b_y4 = EXT Mxy_2_RSP_7_8a_8b_y3 Mxy_2_RSP_7_8a_8b_y1 < 0.126 OPPOSITE PROJ <= 0.082 REGION
Mxy_2_RSP_7_8a_8b_y5 = EXT Mxy_2_RSP_7_8a_8b_y3 Mxy_2_RSP_7_8a_8b_y1 < 0.126 OPPOSITE PROJ <= 0.082
Mxy_2_RSP_7_8a_8b_y6 = RECTANGLE (DFM PROPERTY Mxy_2_RSP_7_8a_8b_y4 Mxy_2_RSP_7_8a_8b_y5 OVERLAP ABUT ALSO MULTI [-= EC(Mxy_2_RSP_7_8a_8b_y5)] <= 0.082)
// 
Mxy_2_RSP_7_8a_8b_y2_c = OR M2EMPTY9696 Mxy_2_RSP_7_8a_8b_y2
Mxy_2_RSP_7_8a_8b_y6_c = OR M2EMPTY9696 Mxy_2_RSP_7_8a_8b_y6
CONNECT Mxy_2_RSP_7_8a_8b_y2_c Mxy_2_RSP_7_8a_8b_y6_c
// 
Mxy_2_RSP_7_8a_8b_ERR1_CHK = EXT Mxy_2_RSP_7_8a_8b_y1 >= 0.126 < 0.144 OPPOSITE REGION EXCLUDE SHIELDED
Mxy_2_RSP_7_8a_8b_ERR1_TMP = EXT ((Mxy_2_RSP_7_8a_8b_y6_c NOT COIN EDGE M2) COIN EDGE Mxy_2_RSP_7_8a_8b_ERR1_CHK) < 0.298 CONNECTED REGION
Mxy_2_RSP_7_8a_8b_ERR1 = Mxy_2_RSP_7_8a_8b_ERR1_TMP OR (Mxy_2_RSP_7_8a_8b_y6 INTERACT (COPY Mxy_2_RSP_7_8a_8b_y6) >= 3 SINGULAR ALSO)
// 
Mxy_2_RSP_7_8a_8b_CA = EXT Mxy_2_RSP_7_8a_8b_y3 Mxy_2_RSP_7_8a_8b_y1 < 0.125 OPPOSITE REGION
Mxy_2_RSP_7_8a_8b_CA_side = Mxy_2_RSP_7_8a_8b_CA NOT COIN EDGE M2
Mxy_2_RSP_7_8a_8b_CA_area = INT Mxy_2_RSP_7_8a_8b_CA_side Mxy_2_RSP_7_8a_8b_CA <= 0.082 REGION
// 
Mxy_2_RSP_7_8a_8b_ERR2_CHK = Mxy_2_RSP_7_8a_8b_CA_side NOT TOUCH EDGE Mxy_2_RSP_7_8a_8b_CA_area
Mxy_2_RSP_7_8a_8b_ERR2_TMP = (NOT RECTANGLE Mxy_2_RSP_7_8a_8b_y2) OR ((RECTANGLE Mxy_2_RSP_7_8a_8b_y2) ENCLOSE RECTANGLE 0.001 0.269)
Mxy_2_RSP_7_8a_8b_ERR2 = (Mxy_2_RSP_7_8a_8b_CA WITH EDGE Mxy_2_RSP_7_8a_8b_ERR2_CHK) INSIDE Mxy_2_RSP_7_8a_8b_ERR2_TMP
// 
Mxy_2_RSP_7_8a_8b_CB = EXT Mxy_2_RSP_7_8a_8b_y3 Mxy_2_RSP_7_8a_8b_y1 < 0.107 OPPOSITE REGION
Mxy_2_RSP_7_8a_8b_CB_side = Mxy_2_RSP_7_8a_8b_CB NOT COIN EDGE M2
Mxy_2_RSP_7_8a_8b_CB_area = INT Mxy_2_RSP_7_8a_8b_CB_side <= 0.082 REGION
// 
Mxy_2_RSP_7_8a_8b_ERR3_CHK = Mxy_2_RSP_7_8a_8b_CB_side TOUCH EDGE Mxy_2_RSP_7_8a_8b_CB_area
Mxy_2_RSP_7_8a_8b_ERR3_TMP = (NOT RECTANGLE Mxy_2_RSP_7_8a_8b_y2) OR ((RECTANGLE Mxy_2_RSP_7_8a_8b_y2) ENCLOSE RECTANGLE 0.001 0.269)
Mxy_2_RSP_7_8a_8b_ERR3 = (Mxy_2_RSP_7_8a_8b_CB WITH EDGE Mxy_2_RSP_7_8a_8b_ERR3_CHK) INSIDE Mxy_2_RSP_7_8a_8b_ERR3_TMP
 
M2_RSP_7 {
@ Space between metal space segments with S2 < 0.126um and L2 <= 0.082um
@ Metal space segments definition:
@ 1) At least one metal line width > 0.180um (W1) and PRL > 0.27um (L1) in metal space < 0.144um (S1) region
@ 2) Metal space segments within metal space (S1) region and are generated by space cut line which is perpendicular with L1 direction formed by all vertex in metal space region (S1)
@ 3) Metal space segments at least abut one metal with width > 0.18um (W1)
@ 4) L2 is the width of metal space segments which is parallel with L1 direction
@ 5) S2 is the width of metal space segments which is perpendicular with L1 direction. >= 0.298um
 Mxy_2_RSP_7_8a_8b_ERR1 NOT INSIDE SealR_NOT_BULK
}
 
M2_RSP_8a {
@ Width (S2) of metal space segments with L2 > 0.082um
@ Metal space segments definition:
@ 1) At least one metal line width > 0.18um (W1) and PRL > 0.27um (L1) in metal space < 0.144um (S1) region
@ 2) Metal space segments within metal space (S1) region and are generated by space cut line which is perpendicular with L1 direction formed by all vertex in metal space region (S1)
@ 3) Metal space segments at least abut one metal with width > 0.18um (W1)
@ 4) L2 is the width of metal space segments which is parallel with L1 direction
@ 5) S2 is the width of metal space segments which is perpendicular with L1 direction. >= 0.125um
 Mxy_2_RSP_7_8a_8b_ERR2 NOT INSIDE SealR_NOT_BULK
}
 
M2_RSP_8b {
@ Width (S2) of metal space segments with L2 <= 0.082um
@ Metal space segments definition:
@ 1) At least one metal line width > 0.18um (W1) and PRL > 0.27um (L1) in metal space < 0.144um (S1) region
@ 2) Metal space segments within metal space (S1) region and are generated by space cut line which is perpendicular with L1 direction formed by all vertex in metal space region (S1)
@ 3) Metal space segments at least abut one metal with width > 0.18um (W1)
@ 4) L2 is the width of metal space segments which is parallel with L1 direction
@ 5) S2 is the width of metal space segments which is perpendicular with L1 direction. >= 0.107um
 Mxy_2_RSP_7_8a_8b_ERR3 NOT INSIDE SealR_NOT_BULK
}
 
Mxy_2_RSP_9_10a_10b_met = ENCLOSE RECTANGLE (M2 INTERACT (M2 WITH WIDTH > 0.270)) 0.271 0.271 ORTHOGONAL ONLY
Mxy_2_RSP_9_10a_10b_wid = INT (Mxy_2_RSP_9_10a_10b_met) <= 0.270 OPPOSITE EXCLUDE SHIELDED
Mxy_2_RSP_9_10a_10b_wan = LENGTH (M2_convex_270_90_edges COIN EDGE Mxy_2_RSP_9_10a_10b_met) < 0.261 - 0.032
Mxy_2_RSP_9_10a_10b_sps = Mxy_2_RSP_9_10a_10b_met COIN EDGE (EXT Mxy_2_RSP_9_10a_10b_met M2 < 0.261 OPPOSITE REGION EXCLUDE SHIELDED)
// 
Mxy_2_RSP_9_10a_10b_sps_sides_A = (Mxy_2_RSP_9_10a_10b_wid COIN EDGE Mxy_2_RSP_9_10a_10b_sps) NOT COIN EDGE (LENGTH (Mxy_2_RSP_9_10a_10b_wid NOT TOUCH EDGE 
(INT [Mxy_2_RSP_9_10a_10b_wid] Mxy_2_RSP_9_10a_10b_wan < 0.001 ABUT==90 INTERSECTING ONLY)) <= 0.27)
Mxy_2_RSP_9_10a_10b_sps_sides_B = (Mxy_2_RSP_9_10a_10b_wid COIN EDGE Mxy_2_RSP_9_10a_10b_sps) NOT COIN EDGE (LENGTH (Mxy_2_RSP_9_10a_10b_wid NOT TOUCH EDGE 
(EXT [Mxy_2_RSP_9_10a_10b_wid] Mxy_2_RSP_9_10a_10b_wan < 0.001 ABUT==90 INTERSECTING ONLY)) <= 0.27)
Mxy_2_RSP_9_10a_10b_sps_sides = Mxy_2_RSP_9_10a_10b_sps_sides_A OR EDGE Mxy_2_RSP_9_10a_10b_sps_sides_B
Mxy_2_RSP_9_10a_10b_sps_sides_PRL = Mxy_2_RSP_9_10a_10b_sps_sides COIN EDGE (PATH LENGTH (Mxy_2_RSP_9_10a_10b_wan OR EDGE Mxy_2_RSP_9_10a_10b_sps_sides) > 0.27)
// 
Mxy_2_RSP_9_10a_10b_S1_side = EXT M2 Mxy_2_RSP_9_10a_10b_sps_sides_PRL < 0.261 OPPOSITE EXCLUDE SHIELDED
Mxy_2_RSP_9_10a_10b_S1_area = EXT M2 Mxy_2_RSP_9_10a_10b_sps_sides_PRL < 0.261 OPPOSITE EXCLUDE SHIELDED REGION
Mxy_2_RSP_9_10a_10b_S1_rlen = Mxy_2_RSP_9_10a_10b_S1_area ENCLOSE RECTANGLE 0.001 0.271 ORTHOGONAL ONLY
Mxy_2_RSP_9_10a_10b_L1_side = M2 COIN EDGE ((DFM COPY Mxy_2_RSP_9_10a_10b_S1_side EDGE) COIN EDGE Mxy_2_RSP_9_10a_10b_S1_rlen)
Mxy_2_RSP_9_10a_10b_L1_side_jog_sum = Mxy_2_RSP_9_10a_10b_wan OR EDGE Mxy_2_RSP_9_10a_10b_L1_side
Mxy_2_RSP_9_10a_10b_L1_side_jog_sum_EXP = EXPAND EDGE Mxy_2_RSP_9_10a_10b_L1_side_jog_sum INSIDE BY 0.001 CORNER FILL
// 
Mxy_2_RSP_9_10a_10b_Q1 = EXPAND EDGE (Mxy_2_RSP_9_10a_10b_L1_side COIN EDGE Mxy_2_RSP_9_10a_10b_L1_side_jog_sum) INSIDE BY 0.001
Mxy_2_RSP_9_10a_10b_Q2 = Mxy_2_RSP_9_10a_10b_L1_side_jog_sum_EXP INTERACT (AREA Mxy_2_RSP_9_10a_10b_Q1 > 0.27 * 0.001)
Mxy_2_RSP_9_10a_10b_Q3 = Mxy_2_RSP_9_10a_10b_L1_side_jog_sum TOUCH EDGE (LENGTH (Mxy_2_RSP_9_10a_10b_Q1 INTERACT Mxy_2_RSP_9_10a_10b_Q2) > 0.001)
// 
Mxy_2_RSP_9_10a_10b_y1 = DFM COPY (EXT M2 Mxy_2_RSP_9_10a_10b_Q3 < 0.261 OPPOSITE EXCLUDE SHIELDED) EDGE
Mxy_2_RSP_9_10a_10b_y2 = DFM COPY (EXT M2 Mxy_2_RSP_9_10a_10b_Q3 < 0.261 OPPOSITE EXCLUDE SHIELDED) REGION
Mxy_2_RSP_9_10a_10b_y3 = Mxy_2_RSP_9_10a_10b_y1 TOUCH EDGE (INT M2 [Mxy_2_RSP_9_10a_10b_y1] <= 0.001 ABUT==90 INTERSECTING ONLY MEASURE ALL)
Mxy_2_RSP_9_10a_10b_y4 = EXT Mxy_2_RSP_9_10a_10b_y3 Mxy_2_RSP_9_10a_10b_y1 < 0.144 OPPOSITE PROJ <= 0.082 REGION
Mxy_2_RSP_9_10a_10b_y5 = EXT Mxy_2_RSP_9_10a_10b_y3 Mxy_2_RSP_9_10a_10b_y1 < 0.144 OPPOSITE PROJ <= 0.082
Mxy_2_RSP_9_10a_10b_y6 = RECTANGLE (DFM PROPERTY Mxy_2_RSP_9_10a_10b_y4 Mxy_2_RSP_9_10a_10b_y5 OVERLAP ABUT ALSO MULTI [-= EC(Mxy_2_RSP_9_10a_10b_y5)] <= 0.082)
// 
Mxy_2_RSP_9_10a_10b_y2_c = OR M2EMPTY9696 Mxy_2_RSP_9_10a_10b_y2
Mxy_2_RSP_9_10a_10b_y6_c = OR M2EMPTY9696 Mxy_2_RSP_9_10a_10b_y6
CONNECT Mxy_2_RSP_9_10a_10b_y2_c Mxy_2_RSP_9_10a_10b_y6_c
// 
Mxy_2_RSP_9_10a_10b_ERR1_CHK = EXT Mxy_2_RSP_9_10a_10b_y1 >= 0.144 < 0.261 OPPOSITE REGION EXCLUDE SHIELDED
Mxy_2_RSP_9_10a_10b_ERR1_TMP = EXT ((Mxy_2_RSP_9_10a_10b_y6_c NOT COIN EDGE M2) COIN EDGE Mxy_2_RSP_9_10a_10b_ERR1_CHK) < 0.298 CONNECTED REGION
Mxy_2_RSP_9_10a_10b_ERR1 = Mxy_2_RSP_9_10a_10b_ERR1_TMP OR (Mxy_2_RSP_9_10a_10b_y6 INTERACT (COPY Mxy_2_RSP_9_10a_10b_y6) >= 3 SINGULAR ALSO)
// 
Mxy_2_RSP_9_10a_10b_CA = EXT Mxy_2_RSP_9_10a_10b_y3 Mxy_2_RSP_9_10a_10b_y1 < 0.142 OPPOSITE REGION
Mxy_2_RSP_9_10a_10b_CA_side = Mxy_2_RSP_9_10a_10b_CA NOT COIN EDGE M2
Mxy_2_RSP_9_10a_10b_CA_area = INT Mxy_2_RSP_9_10a_10b_CA_side Mxy_2_RSP_9_10a_10b_CA <= 0.082 REGION
// 
Mxy_2_RSP_9_10a_10b_ERR2_CHK = Mxy_2_RSP_9_10a_10b_CA_side NOT TOUCH EDGE Mxy_2_RSP_9_10a_10b_CA_area
Mxy_2_RSP_9_10a_10b_ERR2_TMP = (NOT RECTANGLE Mxy_2_RSP_9_10a_10b_y2) OR ((RECTANGLE Mxy_2_RSP_9_10a_10b_y2) ENCLOSE RECTANGLE 0.001 0.269)
Mxy_2_RSP_9_10a_10b_ERR2 = (Mxy_2_RSP_9_10a_10b_CA WITH EDGE Mxy_2_RSP_9_10a_10b_ERR2_CHK) INSIDE Mxy_2_RSP_9_10a_10b_ERR2_TMP
// 
Mxy_2_RSP_9_10a_10b_CB = EXT Mxy_2_RSP_9_10a_10b_y3 Mxy_2_RSP_9_10a_10b_y1 < 0.125 OPPOSITE REGION
Mxy_2_RSP_9_10a_10b_CB_side = Mxy_2_RSP_9_10a_10b_CB NOT COIN EDGE M2
Mxy_2_RSP_9_10a_10b_CB_area = INT Mxy_2_RSP_9_10a_10b_CB_side <= 0.082 REGION
// 
Mxy_2_RSP_9_10a_10b_ERR3_CHK = Mxy_2_RSP_9_10a_10b_CB_side TOUCH EDGE Mxy_2_RSP_9_10a_10b_CB_area
Mxy_2_RSP_9_10a_10b_ERR3_TMP = (NOT RECTANGLE Mxy_2_RSP_9_10a_10b_y2) OR ((RECTANGLE Mxy_2_RSP_9_10a_10b_y2) ENCLOSE RECTANGLE 0.001 0.269)
Mxy_2_RSP_9_10a_10b_ERR3 = (Mxy_2_RSP_9_10a_10b_CB WITH EDGE Mxy_2_RSP_9_10a_10b_ERR3_CHK) INSIDE Mxy_2_RSP_9_10a_10b_ERR3_TMP
 
M2_RSP_9 {
@ Space between metal space segments with S2 < 0.144um and L2 <= 0.082um
@ Metal space segments definition:
@ 1) At least one metal line width > 0.27um (W1) and PRL > 0.27um (L1) in metal space < 0.261um (S1) region
@ 2) Metal space segments within metal space (S1) region and are generated by space cut line which is perpendicular with L1 direction formed by all vertex in metal space region (S1)
@ 3) Metal space segments at least abut one metal with width > 0.27um (W1)
@ 4) L2 is the width of metal space segments which is parallel with L1 direction
@ 5) S2 is the width of metal space segments which is perpendicular with L1 direction. >= 0.298um
 Mxy_2_RSP_9_10a_10b_ERR1 NOT INSIDE SealR_NOT_BULK
}
 
M2_RSP_10a {
@ Width (S2) of metal space segments with L2 > 0.082um
@ Metal space segments definition:
@ 1) At least one metal line width > 0.27um (W1) and PRL > 0.27um (L1) in metal space < 0.261um (S1) region
@ 2) Metal space segments within metal space (S1) region and are generated by space cut line which is perpendicular with L1 direction formed by all vertex in metal space region (S1)
@ 3) Metal space segments at least abut one metal with width > 0.27um (W1)
@ 4) L2 is the width of metal space segments which is parallel with L1 direction
@ 5) S2 is the width of metal space segments which is perpendicular with L1 direction. >= 0.142um
 Mxy_2_RSP_9_10a_10b_ERR2 NOT INSIDE SealR_NOT_BULK
}
 
M2_RSP_10b {
@ Width (S2) of metal space segments with L2 <= 0.082um
@ Metal space segments definition:
@ 1) At least one metal line width > 0.27um (W1) and PRL > 0.27um (L1) in metal space < 0.261um (S1) region
@ 2) Metal space segments within metal space (S1) region and are generated by space cut line which is perpendicular with L1 direction formed by all vertex in metal space region (S1)
@ 3) Metal space segments at least abut one metal with width > 0.27um (W1)
@ 4) L2 is the width of metal space segments which is parallel with L1 direction
@ 5) S2 is the width of metal space segments which is perpendicular with L1 direction. >= 0.125um
 Mxy_2_RSP_9_10a_10b_ERR3 NOT INSIDE SealR_NOT_BULK
}

#IFDEF DOUBLE_PATTERNING_RULES_CHECK YES
#IFDEF DOUBLE_PATTERNING_RULES_CHECK_ONLY YES

GROUP GM2DP M2_OR_?
DRC SELECT CHECK GM2DP

#ENDIF
//----------------------------------------------------------------------------------------------------------------------//
//	Mxy.OR.0\[NC\]	Odd ring conflict space definition: 							        //
//	OR Line Space (ORLS): polygons violate any one of the odd ring space rules from Mxy.ORCS.1 and Mxy.ORCS.2       //
//	OR Corner Space (ORCS): polygons violate any one of the odd ring space rule Mxy.ORCS.3			        //
//	OR-AREA definition: 											        //
//	1. Odd ring line area (ORLA): The projection area between two edges with ORLS				        //
//	2. Odd ring corner area (ORCA): The line between two corners with ORCS						//
//	3. ORLA or ORCA region are independent to all other ones, even if they are overlapped or crossed		//
//	Loop:														//
//	1.A loop is formed when polygons of Mxy are connected in a cycle sequence with OR-AREA in between		//
//	2.A loop cannot contain any sub-loops which share one or more polygons with it					//
//	Path:														//
//	A path is formed when polygons of Mxy are connected one by one from one marker to another marker with OR-AREA   //
//       in between													//
//----------------------------------------------------------------------------------------------------------------------//

//;beginning of Mxy.ORCS.1 derivations
M2_ORCS_1 = EXT M2 < 0.063 OPPOSITE EXTENDED 0.015
M2_ORCS_1_AREA = DFM COPY M2_ORCS_1 REGION
//;end of Mxy.ORCS.1 derivations
 
//;beginning of Mxy.ORCS.2 derivations
M2_end_DP = LENGTH M2_convex_90_90_edges < 0.046
M2_ORCS_2 = EXT M2_end_DP M2 < 0.08 OPPOSITE EXTENDED 0.015
M2_ORCS_2_AREA = DFM COPY M2_ORCS_2 REGION
//;end of Mxy.ORCS.2 derivations
 
//;beginning of Mxy.ORCS.3 derivations
M2_ORCS_3_TMP = EXT M2 < 0.058 CORNER TO CORNER
M2_ORCS_3 = DFM PROPERTY M2_ORCS_3_TMP [-= (EWXP(M2_ORCS_3_TMP) >= 0.015 && EWYP(M2_ORCS_3_TMP) >= 0.015) ? 1 : 0] > 0
M2_ORCS_3_AREA = DFM COPY M2_ORCS_3 REGION
M2_ORCS_AREA_temp = OR M2_ORCS_1_AREA M2_ORCS_2_AREA M2_ORCS_3_AREA
//;end of Mxy.ORCS.3 derivations
 
M2_critical_case_edge = LENGTH M2_convex_eq_one_edges <= 0.002
M2_critical_case = EXT M2 M2_critical_case_edge < 0.002 ABUT==90 INTERSECTING ONLY REGION
M2_ORCS_AREA = M2_ORCS_AREA_temp NOT M2_critical_case
// 
M2_conflict_rings = DFM DP RING M2 M2_ORCS_1 M2_ORCS_2 M2_ORCS_3 (OPPOSITE 0)
M2_conflict_anchor = DFM DP ANCHOR_CONFLICT M2 M2_ORCS_1 M2_ORCS_2 M2_ORCS_3 (OPPOSITE 0) M2CA(anchor mask0) M2CB(anchor mask1) UNFILTERED
M2_mask0 = DFM DP MASK0 M2 M2_ORCS_1 M2_ORCS_2 M2_ORCS_3 (OPPOSITE 0)
M2_mask1 = DFM DP MASK1 M2 M2_ORCS_1 M2_ORCS_2 M2_ORCS_3 (OPPOSITE 0)
// SETLAYER M2_conflict_rings = RET NMDPC M2_ORCS_1 M2 M2_ORCS_2 M2_ORCS_3 M2CA M2CB FILE M2dpcfile MAP ring
// SETLAYER M2_warning_rings = RET NMDPC M2_ORCS_1 M2 M2_ORCS_2 M2_ORCS_3 M2CA M2CB FILE M2dpcfile MAP warning
// SETLAYER M2_conflict_anchor = RET NMDPC M2_ORCS_1 M2 M2_ORCS_2 M2_ORCS_3 M2CA M2CB FILE M2dpcfile MAP anchor_path
 

#IFDEF SHOW_DOUBLE_PATTERNING_CONFLICT_SPACE YES

M2_ORCS_1 {
@ Space between Mxy to Mxy when PRL > -0.015um. >= 0.063um
 err1 = COPY M2_ORCS_1_AREA
 err1 NOT INSIDE SealR_NOT_BULK
}
 
M2_ORCS_2 {
@ Space between Mxy line-end (width < 0.046um) and Mxy when PRL > -0.015um. >= 0.08um
 err1 = COPY M2_ORCS_2_AREA
 err1 NOT INSIDE SealR_NOT_BULK
}
 
M2_ORCS_3 {
@ Corner space between Mxy when PRL <= -0.015um. >= 0.058um
 err1 = COPY M2_ORCS_3_AREA
 err1 NOT INSIDE SealR_NOT_BULK
}

#ENDIF

 
M2_ORCS_1_single = EXT M2 < 0.063 OPPOSITE EXTENDED 0.015 NOTCH
M2_ORCS_2_single = EXT (M2 TOUCH EDGE M2_end_DP) M2 < 0.08 OPPOSITE EXTENDED 0.015 NOTCH
M2_ORCS_3_single_TMP = EXT M2 < 0.058 CORNER TO CORNER NOTCH
M2_ORCS_3_single = DFM PROPERTY M2_ORCS_3_single_TMP [-= (EWXP(M2_ORCS_3_single_TMP) >= 0.015 && EWYP(M2_ORCS_3_single_TMP) >= 0.015) ? 1 : 0] > 0
 
M2_OR_1 {
@ OR-AREA formed by single polygon is not allowed
 err1 = DFM COPY M2_ORCS_1_single M2_ORCS_2_single M2_ORCS_3_single REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
M2_OR_3 {
@ M2.OR.3: OR-AREA count of the close loop formed by original polygons and OR-AREA cannot be odd number
@ M2.OR.2: ORCA cannot cross another ORCA or touch ORLA
 err1 = COPY M2_conflict_rings
 err1 NOT INSIDE SealR_NOT_BULK
}
 
M2_OR_4 {
@ MxyDPMK must be drawn identically to Mxy
 err1 = M2DPMK NOT COIN EDGE M2
 err2 = M2DPMK NOT M2
 err1 NOT INSIDE EDGE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}
 
M2_OR_5 {
@ (Mxy INTERACT MxyDPMK) INTERACT ORLS or ORCS is not allowed
 err1 = M2_ORCS_AREA INTERACT (M2 INTERACT M2DPMK) SINGULAR ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
M2_OR_6 {
@ (Mxy INTERACT INST) INTERACT MxyDPMK is not allowed
 err1 = (M2 INTERACT INST) INTERACT M2DPMK SINGULAR ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
M2_OR_7 {
@ Pre-coloring marker MxyCA and MxyCB must be drawn identically to Mxy
 err1 = (M2CA OUTSIDE INST) NOT COIN EDGE M2
 // based M2_OR_9: CA/CB is forbidden in INST region
 err2 = (M2CB OUTSIDE INST) NOT COIN EDGE M2
 err3 = (M2CA OUTSIDE INST) NOT M2
 err4 = (M2CB OUTSIDE INST) NOT M2
 err1 NOT INSIDE EDGE SealR_NOT_BULK
 err2 NOT INSIDE EDGE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
 err4 NOT INSIDE SealR_NOT_BULK
}
 
M2_OR_8 {
@ MxyCA INTERACT MxyCB is not allowed
 err1 = M2CA INTERACT M2CB SINGULAR ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
M2_OR_9 {
@ (Mxy INTERACT INST) INTERACT (MxyCA OR MxyCB) is not allowed
 err1 = (M2CA OR M2CB) INTERACT (M2 INTERACT INST) SINGULAR ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
M2_OR_10 {
@ (MxyCA OR MxyCB) INTERACT MxyDPMK is not allowed
 err1 = (M2CA OR M2CB) INTERACT M2DPMK SINGULAR ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
M2_OR_11_12_13 {
@ OR-AREA count of any path starting from MxyCA and ending at MxyCA must not be an odd number
@ OR-AREA count of any path starting from MxyCB and ending at MxyCB must not be an odd number
@ OR-AREA count of any path starting from MxyCA and ending at MxyCB must not be an even number
 err1 = COPY M2_conflict_anchor
 err1 NOT INSIDE SealR_NOT_BULK
}
 
M2_OR_14 {
@ Maximum pre-coloring ratio of ((MxyCA + MxyCB + MxyDPMK)/Mxy) before decomposition < 16%
 check_pattern = (M2CA OR M2CB) OR M2DPMK
 check_region = COPY M2
 DENSITY check_pattern check_region [AREA(check_pattern)/AREA(check_region)] >= 0.16 PRINT "./SMIC_14SFPLUS_DRC_logFile/pre_coloring_ratio_M2_OR_14.log" RDB "./SMIC_14SFPLUS_DRC_logFile/pre_coloring_ratio_M2_OR_14.rdb"
}

#ENDIF


// =======================================================
// Mxy design rules (double patterning process)
// =======================================================

 //;---------------M${j} design rules --------------- 
GROUP GM3 M3_?
// 
M3_end_0.050 = LENGTH M3_end <= 0.05
M3_end_0.038 = LENGTH M3_end <= 0.038
M3_end_0.064 = LENGTH M3_convex_90_90_edges <= 0.064
met3_38_side = INT [M3] <= 0.038 ABUT<90 OPPOSITE
met3_48_side = INT [M3] <= 0.048 ABUT<90 OPPOSITE
met3_64_side = INT [M3] <= 0.064 ABUT<90 OPPOSITE
met3_wide_eqgt_150 = M3 WITH WIDTH >= 0.15
// 
M3_end_0.052 = LENGTH M3_end < 0.052
M3_end_0.055 = LENGTH M3_end < 0.055
M3_end_0.048 = LENGTH M3_end < 0.048
M3_end_0.046 = LENGTH M3_end < 0.046
M3_end_0.046_0.051 = LENGTH M3_end > 0.046 <= 0.051
M3_end_0.032_0.047 = LENGTH M3_end >= 0.032 <= 0.047
M3_end_0.032_0.051 = LENGTH M3_end >= 0.032 <= 0.051
M3_end_0.048_0.051 = LENGTH M3_end >= 0.048 <= 0.051
// 
M3_WIDTH_eq_024 = M3 WITH WIDTH == 0.024
M3_WIDTH_eq_028 = M3 WITH WIDTH == 0.028
M3_WIDTH_eq_032 = M3 WITH WIDTH == 0.032
M3_WIDTH_gt_024 = M3 WITH WIDTH >= 0.024
M3_WIDTH_gt_028 = M3_WIDTH_gt_024 WITH WIDTH >= 0.028
M3_WIDTH_gt_032 = M3_WIDTH_gt_028 WITH WIDTH >= 0.032
M3_WIDTH_gt_048 = M3_WIDTH_gt_032 WITH WIDTH >= 0.048
M3_WIDTH_lt_032 = M3 WITH WIDTH < 0.032
M3_WIDTH_eq_024_028 = OR M3_WIDTH_eq_024 M3_WIDTH_eq_028
// 
M3_eq_024_end = LENGTH M3_convex_90_90_edges == 0.024
M3_eq_028_end = LENGTH M3_convex_90_90_edges == 0.028
M3_eq_048_end = LENGTH M3_convex_90_90_edges == 0.048
M3_eq_024_028_end = OR EDGE M3_eq_024_end M3_eq_028_end
M3_eq_024_048_end = OR EDGE M3_eq_024_end M3_eq_048_end
// 
M3_lt_050_end = LENGTH M3_convex_90_90_edges < 0.050
M3_lt_052_end = LENGTH M3_convex_90_90_edges < 0.052
M3_lt_072_end = LENGTH M3_convex_90_90_edges <= 0.072
M3_eq_032_lt_048_end = LENGTH M3_convex_90_90_edges >= 0.032 < 0.048
M3_eq_048_lt_052_end = LENGTH M3_convex_90_90_edges >= 0.048 < 0.052
// 
M3_width_lt_037_opp_edges = INT [M3] < 0.037 ABUT<90 OPPOSITE PARA ONLY
M3_width_lt_032_opp_edges = INT [M3] < 0.032 ABUT<90 OPPOSITE PARA ONLY
// 
Mxy3_GROUP_48 = SIZE (SIZE (SIZE M3_WIDTH_eq_024 BY 0.012) BY -0.024) BY 0.012
Mxy3_GROUP_64 = SIZE (SIZE (SIZE M3_WIDTH_eq_032 BY 0.016) BY -0.032) BY 0.016
 

#IFDEF MANUFACTURABILITY_ENHANCEMENT_RULES YES

M3_S_9_ME {
@ Space between Mxy line and line-end (W < 0.046um) when PRL > -0.022um, except INST region >= 0.07um
 err1 = EXT M3 M3_end_0.046 < 0.07 ABUT<90 OPPOSITE EXTENDED 0.022 REGION
 err1 NOT INSIDE INST
}
 
 
M3_R_6_RV2_ME {
@ U-shape Mxy is not allowed, except INST region
@ DRC check condition:
@ 1. With at least one RVy or RVy-1
@ 2. Mxy width W <= 0.038um
@ 3. S <= 0.12um
 ushape_opp = LENGTH M3_convex_270_270_edges <= 0.120
 ushape_wid = INT ushape_opp M3_convex_gt_one_edges <= 0.038 OPPOSITE
 ushape_edg = ushape_opp COIN EDGE (DFM COPY ushape_wid EDGE)
 ushape_met = (M3 WITH EDGE ushape_edg) INTERACT RV2
 ushape_chk = ushape_edg COIN EDGE ushape_met
 ushape_038 = (EXPAND EDGE ushape_chk INSIDE BY 0.038) AND M3
 ushape_via = (SIZE ushape_038 BY 0.12 INSIDE OF M3 STEP 0.01) INTERACT RV2
 ushape_err = DFM PROPERTY ushape_wid ushape_via OVERLAP ABUT ALSO MULTI [s= area(ushape_via)] > 0 [w= min(ew(ushape_wid))] > 0
 // 
 err1 = copy (DFM COPY ushape_err REGION)
 err1 NOT INSIDE INST
}
 
M3_R_6_RV3_ME {
@ U-shape Mxy is not allowed, except INST region
@ DRC check condition:
@ 1. With at least one RVy or RVy-1
@ 2. Mxy width W <= 0.038um
@ 3. S <= 0.12um
 ushape_opp = LENGTH M3_convex_270_270_edges <= 0.120
 ushape_wid = INT ushape_opp M3_convex_gt_one_edges <= 0.038 OPPOSITE
 ushape_edg = ushape_opp COIN EDGE (DFM COPY ushape_wid EDGE)
 ushape_met = (M3 WITH EDGE ushape_edg) INTERACT RV3
 ushape_chk = ushape_edg COIN EDGE ushape_met
 ushape_038 = (EXPAND EDGE ushape_chk INSIDE BY 0.038) AND M3
 ushape_via = (SIZE ushape_038 BY 0.12 INSIDE OF M3 STEP 0.01) INTERACT RV3
 ushape_err = DFM PROPERTY ushape_wid ushape_via OVERLAP ABUT ALSO MULTI [s= area(ushape_via)] > 0 [w= min(ew(ushape_wid))] > 0
 // 
 err1 = copy (DFM COPY ushape_err REGION)
 err1 NOT INSIDE INST
}
 
M3_R_6_RV4_ME {
@ U-shape Mxy is not allowed, except INST region
@ DRC check condition:
@ 1. With at least one RVy or RVy-1
@ 2. Mxy width W <= 0.038um
@ 3. S <= 0.12um
 ushape_opp = LENGTH M3_convex_270_270_edges <= 0.120
 ushape_wid = INT ushape_opp M3_convex_gt_one_edges <= 0.038 OPPOSITE
 ushape_edg = ushape_opp COIN EDGE (DFM COPY ushape_wid EDGE)
 ushape_met = (M3 WITH EDGE ushape_edg) INTERACT RV4
 ushape_chk = ushape_edg COIN EDGE ushape_met
 ushape_038 = (EXPAND EDGE ushape_chk INSIDE BY 0.038) AND M3
 ushape_via = (SIZE ushape_038 BY 0.12 INSIDE OF M3 STEP 0.01) INTERACT RV4
 ushape_err = DFM PROPERTY ushape_wid ushape_via OVERLAP ABUT ALSO MULTI [s= area(ushape_via)] > 0 [w= min(ew(ushape_wid))] > 0
 // 
 err1 = DFM COPY ushape_err REGION
 err1 NOT INSIDE INST
}
 
M3_R_7_V2_ME {
@ It's not allowed to use Hook-shape Mxy, except INST region
@ Hook-shape Mxy definition:
@ (1) Hook-end line width(W1) is <= 0.05um, length(L1) <= 0.15um, ΔL > 0.1um and Hook-end interact one via
@ (2) W2/W3 width <= 0.072um
@ (3) Space between two Mxy arms(S1) <= 0.1um
@ (4) Space between via and another Mxy S2 <= 0.038um when PRL > -0.015um
@ DRC waive if hook-end enclosure via >= 0.05um
 hook_neck = CONVEX EDGE M3 ANGLE1==270 LENGTH1<=0.15 ANGLE2==270 LENGTH2>0 WITH LENGTH <= 0.100
 hook_neck_ege = hook_neck NOT TOUCH EDGE (INT (hook_neck) M3 <= 0.072 ABUT<90 OPPOSITE)
 hook_neck_exd = EXPAND EDGE hook_neck_ege OUTSIDE BY 0.01
 hook_neck_sid = M3 COIN EDGE hook_neck_exd
 // 
 hook_seek = (M3 WITH EDGE hook_neck_ege) WITH EDGE M3_end_0.050
 hook_head_sid = INT [hook_seek] <= 0.05 ABUT<90 OPPOSITE
 hook_head_end = M3_end_0.050 TOUCH EDGE hook_seek
 hook_head_end_r = M3_end_0.050 TOUCH EDGE (OR EDGE (ENC V2 [hook_head_end] < 0.05 ABUT<90 OPPOSITE) (ENC V3 [hook_head_end] < 0.05 ABUT<90 OPPOSITE))
 hook_head_via_b = V2 WITH EDGE (ENC [V2] hook_head_end < 0.05 ABUT<90 OPPOSITE)
 hook_head_via_u = V3 WITH EDGE (ENC [V3] hook_head_end < 0.05 ABUT<90 OPPOSITE)
 hook_head_via_b_sid = ENC [hook_head_via_b] hook_head_sid <= 0.018 ABUT<90 OPPOSITE
 hook_head_via_u_sid = ENC [hook_head_via_u] hook_head_sid <= 0.018 ABUT<90 OPPOSITE
 hook_head_via = hook_head_via_b WITH EDGE (EXT M3 [hook_head_via_b_sid] < 0.038+GLOBAL_TOLERANCE ABUT<90 OPPOSITE EXTENDED 0.015 MEASURE ALL)
 // 
 hook_seek_met = hook_seek ENCLOSE hook_head_via
 hook_neck_cor = EXT [hook_seek_met] < 0.005 ABUT==90 INTERSECTING ONLY
 hook_neck_err = EXT hook_neck_cor <= 0.100 ABUT<90 OPPOSITE
 hook_neck_arm = hook_seek_met TOUCH EDGE hook_neck_cor
 hook_neck_dtl = DFM PROPERTY hook_neck_err hook_neck_arm OVERLAP ABUT ALSO MULTI [dt_l = max(length(hook_neck_arm)) - min(length(hook_neck_arm))]
 // 
 hook_head_a = (INT (M3_convex_gt_one_edges TOUCH EDGE hook_seek_met) <= 0.05 OPPOSITE REGION) WITH EDGE hook_head_end_r
 hook_head_b = NOT ENCLOSE RECTANGLE hook_head_a 0.001 0.150+GLOBAL_TOLERANCE ORTHOGONAL ONLY
 hook_head = hook_head_b NOT OUTSIDE hook_head_via
 hook_tail = INT (hook_neck_sid) M3 <= 0.072 ABUT<90 OPPOSITE
 hook_gain = DFM PROPERTY hook_neck_err hook_tail hook_head hook_neck_dtl OVERLAP ABUT ALSO MULTI 
 [-= (count(hook_head) > 0 && count(hook_tail) == 0) ? 1 : 0] > 0 [dt_l = property(hook_neck_dtl,dt_l)] > 0.10
 err1 = copy (DFM COPY hook_gain REGION)
 err1 NOT INSIDE INST
}
 
M3_R_7_V3_ME {
@ It's not allowed to use Hook-shape Mxy, except INST region
@ Hook-shape Mxy definition:
@ (1) Hook-end line width(W1) is <= 0.05um, length(L1) <= 0.15um, ΔL > 0.1um and Hook-end interact one via
@ (2) W2/W3 width <= 0.072um
@ (3) Space between two Mxy arms(S1) <= 0.1um
@ (4) Space between via and another Mxy S2 <= 0.038um when PRL > -0.015um
@ DRC waive if hook-end enclosure via >= 0.05um
 hook_neck = CONVEX EDGE M3 ANGLE1==270 LENGTH1<=0.15 ANGLE2==270 LENGTH2>0 WITH LENGTH <= 0.100
 hook_neck_ege = hook_neck NOT TOUCH EDGE (INT (hook_neck) M3 <= 0.072 ABUT<90 OPPOSITE)
 hook_neck_exd = EXPAND EDGE hook_neck_ege OUTSIDE BY 0.01
 hook_neck_sid = M3 COIN EDGE hook_neck_exd
 // 
 hook_seek = (M3 WITH EDGE hook_neck_ege) WITH EDGE M3_end_0.050
 hook_head_sid = INT [hook_seek] <= 0.05 ABUT<90 OPPOSITE
 hook_head_end = M3_end_0.050 TOUCH EDGE hook_seek
 hook_head_end_r = M3_end_0.050 TOUCH EDGE (OR EDGE (ENC V2 [hook_head_end] < 0.05 ABUT<90 OPPOSITE) (ENC V3 [hook_head_end] < 0.05 ABUT<90 OPPOSITE))
 hook_head_via_b = V2 WITH EDGE (ENC [V2] hook_head_end < 0.05 ABUT<90 OPPOSITE)
 hook_head_via_u = V3 WITH EDGE (ENC [V3] hook_head_end < 0.05 ABUT<90 OPPOSITE)
 hook_head_via_b_sid = ENC [hook_head_via_b] hook_head_sid <= 0.018 ABUT<90 OPPOSITE
 hook_head_via_u_sid = ENC [hook_head_via_u] hook_head_sid <= 0.018 ABUT<90 OPPOSITE
 hook_head_via = hook_head_via_u WITH EDGE (EXT M3 [hook_head_via_u_sid] < 0.038+GLOBAL_TOLERANCE ABUT<90 OPPOSITE EXTENDED 0.015 MEASURE ALL)
 // 
 hook_seek_met = hook_seek ENCLOSE hook_head_via
 hook_neck_cor = EXT [hook_seek_met] < 0.005 ABUT==90 INTERSECTING ONLY
 hook_neck_err = EXT hook_neck_cor <= 0.100 ABUT<90 OPPOSITE
 hook_neck_arm = hook_seek_met TOUCH EDGE hook_neck_cor
 hook_neck_dtl = DFM PROPERTY hook_neck_err hook_neck_arm OVERLAP ABUT ALSO MULTI [dt_l = max(length(hook_neck_arm)) - min(length(hook_neck_arm))]
 // 
 hook_head_a = (INT (M3_convex_gt_one_edges TOUCH EDGE hook_seek_met) <= 0.05 OPPOSITE REGION) WITH EDGE hook_head_end_r
 hook_head_b = NOT ENCLOSE RECTANGLE hook_head_a 0.001 0.150+GLOBAL_TOLERANCE ORTHOGONAL ONLY
 hook_head = hook_head_b NOT OUTSIDE hook_head_via
 hook_tail = INT (hook_neck_sid) M3 <= 0.072 ABUT<90 OPPOSITE
 hook_gain = DFM PROPERTY hook_neck_err hook_tail hook_head hook_neck_dtl OVERLAP ABUT ALSO MULTI 
 [-= (count(hook_head) > 0 && count(hook_tail) == 0) ? 1 : 0] > 0 [dt_l = property(hook_neck_dtl,dt_l)] > 0.10
 err1 = copy (DFM COPY hook_gain REGION)
 err1 NOT INSIDE INST
}

#ENDIF

 

#IFDEF DFM_RULES_PRIORITY_1 YES

M3_W_1_DFM1 {
@ Recommended Mxy width to reduce the line open possibility, except MOMDMY and EFUSE regions >= 0.046um
 err1 = INT M3 < 0.046 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE (OR MOMDMY EFUSE)
}
 
M3_S_1_DFM1 {
@ Recommend Mxy space to reduce the short possibility, except MOMDMY region >= 0.044um
 err1 = EXT M3 < 0.044 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE MOMDMY
}
 
chk_M3_070 = M3 WITH WIDTH > 0.07
chk_M3_088 = chk_M3_070 WITH WIDTH > 0.088
chk_M3_112 = chk_M3_088 WITH WIDTH > 0.112
chk_M3_180 = chk_M3_112 WITH WIDTH > 0.180
chk_M3_270 = chk_M3_180 WITH WIDTH > 0.270
 
M3_S_2_DFM1 {
@ Recommended Mxy space when either one Mxy width > 0.07um. >= 0.072um
 err1 = EXT chk_M3_070 M3 < 0.072 ABUT<90 REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
M3_S_3_DFM1 {
@ Recommended Mxy space when either one Mxy width > 0.088um. >= 0.081um
 err1 = EXT chk_M3_088 M3 < 0.081 ABUT<90 REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
M3_S_4_DFM1 {
@ Recommended Mxy space when either one Mxy width > 0.112um, except EFUSE region >= 0.106um
 err1 = EXT chk_M3_112 M3 < 0.106 ABUT<90 REGION
 err1 NOT INSIDE EFUSE
}
 
M3_S_5_DFM1 {
@ Recommended Mxy space when either one Mxy width > 0.18um, except EFUSE region >= 0.126um
 err1 = EXT chk_M3_180 M3 < 0.126 ABUT<90 REGION
 err1 NOT INSIDE EFUSE
}
 
M3_S_6_DFM1 {
@ Recommended Mxy space when either one Mxy width > 0.27um. >= 0.144um
 err1 = EXT chk_M3_270 M3 < 0.144 ABUT<90 REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
M3_S_9a_DFM1 {
@ Space between Mxy line and line-end (W < 0.046um, PRL > -0.022um) >= 0.070um
 err1 = EXT M3 M3_end_0.046 < 0.070 ABUT<90 OPPOSITE EXTENDED 0.022 REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
M3_S_9b_DFM1 {
@ Space between Mxy line and line-end (0.046 < W <= 0.051um, PRL > -0.022um) >= 0.063um
 err1 = EXT M3 M3_end_0.046_0.051 < 0.063 ABUT<90 OPPOSITE EXTENDED 0.022 REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
M3_S_10_DFM1 {
@ Recommended space between Mxy line-end (width <= 0.051um) and line-end (width < 0.048um) when PRL > -0.022um. >= 0.081um
 err1 = EXT M3_end_0.052 M3_end_0.048 < 0.081 ABUT<90 OPPOSITE EXTENDED 0.022 REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
M3_A_1_DFM1 {
@ Recommended Mxy area >= 0.01um2
 err1 = AREA M3 < 0.01
 err1 NOT INSIDE SealR_NOT_BULK
}
 
M3_R_6_RV2_DFM1 {
@ It's not recommended to use U-shape Mxy
@ DRC check condition:
@ 1. With at least one RVy or RVy-1
@ 2. Mxy width W <= 0.038um
@ 3. S <= 0.12um
@ Which rule is not applied for INST region
 ushape_opp = LENGTH M3_convex_270_270_edges <= 0.120
 ushape_wid = INT ushape_opp M3_convex_gt_one_edges <= 0.038 OPPOSITE
 ushape_edg = ushape_opp COIN EDGE (DFM COPY ushape_wid EDGE)
 ushape_met = (M3 WITH EDGE ushape_edg) INTERACT RV2
 ushape_chk = ushape_edg COIN EDGE ushape_met
 ushape_038 = (EXPAND EDGE ushape_chk INSIDE BY 0.038) AND M3
 ushape_via = (SIZE ushape_038 BY 0.12 INSIDE OF M3 STEP 0.01) INTERACT RV2
 ushape_err = DFM PROPERTY ushape_wid ushape_via OVERLAP ABUT ALSO MULTI [s= area(ushape_via)] > 0 [w= min(ew(ushape_wid))] > 0
 // 
 err1 = DFM COPY ushape_err REGION
 err1 NOT INSIDE INST
}
 
M3_R_6_RV3_DFM1 {
@ It's not recommended to use U-shape Mxy
@ DRC check condition:
@ 1. With at least one RVy or RVy-1
@ 2. Mxy width W <= 0.038um
@ 3. S <= 0.12um
@ Which rule is not applied for INST region
 ushape_opp = LENGTH M3_convex_270_270_edges <= 0.120
 ushape_wid = INT ushape_opp M3_convex_gt_one_edges <= 0.038 OPPOSITE
 ushape_edg = ushape_opp COIN EDGE (DFM COPY ushape_wid EDGE)
 ushape_met = (M3 WITH EDGE ushape_edg) INTERACT RV3
 ushape_chk = ushape_edg COIN EDGE ushape_met
 ushape_038 = (EXPAND EDGE ushape_chk INSIDE BY 0.038) AND M3
 ushape_via = (SIZE ushape_038 BY 0.12 INSIDE OF M3 STEP 0.01) INTERACT RV3
 ushape_err = DFM PROPERTY ushape_wid ushape_via OVERLAP ABUT ALSO MULTI [s= area(ushape_via)] > 0 [w= min(ew(ushape_wid))] > 0
 // 
 err1 = DFM COPY ushape_err REGION
 err1 NOT INSIDE INST
}
 
M3_R_7_V2_DFM1 {
@ It's not recommended to use Hook-shape Mxy
@ Hook-shape Mxy definition:
@ (1) Hook-end line width(W1) is <= 0.05um, length(L1) <= 0.15um, ΔL > 0.1um and Hook-end interact one via
@ (2) W2/W3 width <= 0.072um
@ (3) Space between two Mxy arms(S1) <= 0.1um
@ (4) Space between via and another Mxy S2 <= 0.038um when PRL > -0.015um
@ DRC waive if hook-end enclosure via >= 0.05um
@ This rule is not applied for INST region
 hook_neck = CONVEX EDGE M3 ANGLE1==270 LENGTH1<=0.15 ANGLE2==270 LENGTH2>0 WITH LENGTH <= 0.100
 hook_neck_ege = hook_neck NOT TOUCH EDGE (INT (hook_neck) M3 <= 0.072 ABUT<90 OPPOSITE)
 hook_neck_exd = EXPAND EDGE hook_neck_ege OUTSIDE BY 0.01
 hook_neck_sid = M3 COIN EDGE hook_neck_exd
 // 
 hook_seek = (M3 WITH EDGE hook_neck_ege) WITH EDGE M3_end_0.050
 hook_head_sid = INT [hook_seek] <= 0.05 ABUT<90 OPPOSITE
 hook_head_end = M3_end_0.050 TOUCH EDGE hook_seek
 hook_head_end_r = M3_end_0.050 TOUCH EDGE (OR EDGE (ENC V2 [hook_head_end] < 0.05 ABUT<90 OPPOSITE) (ENC V3 [hook_head_end] < 0.05 ABUT<90 OPPOSITE))
 hook_head_via_b = V2 WITH EDGE (ENC [V2] hook_head_end < 0.05 ABUT<90 OPPOSITE)
 hook_head_via_u = V3 WITH EDGE (ENC [V3] hook_head_end < 0.05 ABUT<90 OPPOSITE)
 hook_head_via_b_sid = ENC [hook_head_via_b] hook_head_sid <= 0.018 ABUT<90 OPPOSITE
 hook_head_via_u_sid = ENC [hook_head_via_u] hook_head_sid <= 0.018 ABUT<90 OPPOSITE
 hook_head_via = hook_head_via_b WITH EDGE (EXT M3 [hook_head_via_b_sid] < 0.038+GLOBAL_TOLERANCE ABUT<90 OPPOSITE EXTENDED 0.015 MEASURE ALL)
 // 
 hook_seek_met = hook_seek ENCLOSE hook_head_via
 hook_neck_cor = EXT [hook_seek_met] < 0.005 ABUT==90 INTERSECTING ONLY
 hook_neck_err = EXT hook_neck_cor <= 0.100 ABUT<90 OPPOSITE
 hook_neck_arm = hook_seek_met TOUCH EDGE hook_neck_cor
 hook_neck_dtl = DFM PROPERTY hook_neck_err hook_neck_arm OVERLAP ABUT ALSO MULTI [dt_l = max(length(hook_neck_arm)) - min(length(hook_neck_arm))]
 // 
 hook_head_a = (INT (M3_convex_gt_one_edges TOUCH EDGE hook_seek_met) <= 0.05 OPPOSITE REGION) WITH EDGE hook_head_end_r
 hook_head_b = NOT ENCLOSE RECTANGLE hook_head_a 0.001 0.150+GLOBAL_TOLERANCE ORTHOGONAL ONLY
 hook_head = hook_head_b NOT OUTSIDE hook_head_via
 hook_tail = INT (hook_neck_sid) M3 <= 0.072 ABUT<90 OPPOSITE
 hook_gain = DFM PROPERTY hook_neck_err hook_tail hook_head hook_neck_dtl OVERLAP ABUT ALSO MULTI 
 [-= (count(hook_head) > 0 && count(hook_tail) == 0) ? 1 : 0] > 0 [dt_l = property(hook_neck_dtl,dt_l)] > 0.10
 err1 = DFM COPY hook_gain REGION
 err1 NOT INSIDE INST
}
 
M3_R_7_V3_DFM1 {
@ It's not recommended to use Hook-shape Mxy
@ Hook-shape Mxy definition:
@ (1) Hook-end line width(W1) is <= 0.05um, length(L1) <= 0.15um, ΔL > 0.1um and Hook-end interact one via
@ (2) W2/W3 width <= 0.072um
@ (3) Space between two Mxy arms(S1) <= 0.1um
@ (4) Space between via and another Mxy S2 <= 0.038um when PRL > -0.015um
@ DRC waive if hook-end enclosure via >= 0.05um
@ This rule is not applied for INST region
 hook_neck = CONVEX EDGE M3 ANGLE1==270 LENGTH1<=0.15 ANGLE2==270 LENGTH2>0 WITH LENGTH <= 0.100
 hook_neck_ege = hook_neck NOT TOUCH EDGE (INT (hook_neck) M3 <= 0.072 ABUT<90 OPPOSITE)
 hook_neck_exd = EXPAND EDGE hook_neck_ege OUTSIDE BY 0.01
 hook_neck_sid = M3 COIN EDGE hook_neck_exd
 // 
 hook_seek = (M3 WITH EDGE hook_neck_ege) WITH EDGE M3_end_0.050
 hook_head_sid = INT [hook_seek] <= 0.05 ABUT<90 OPPOSITE
 hook_head_end = M3_end_0.050 TOUCH EDGE hook_seek
 hook_head_end_r = M3_end_0.050 TOUCH EDGE (OR EDGE (ENC V2 [hook_head_end] < 0.05 ABUT<90 OPPOSITE) (ENC V3 [hook_head_end] < 0.05 ABUT<90 OPPOSITE))
 hook_head_via_b = V2 WITH EDGE (ENC [V2] hook_head_end < 0.05 ABUT<90 OPPOSITE)
 hook_head_via_u = V3 WITH EDGE (ENC [V3] hook_head_end < 0.05 ABUT<90 OPPOSITE)
 hook_head_via_b_sid = ENC [hook_head_via_b] hook_head_sid <= 0.018 ABUT<90 OPPOSITE
 hook_head_via_u_sid = ENC [hook_head_via_u] hook_head_sid <= 0.018 ABUT<90 OPPOSITE
 hook_head_via = hook_head_via_u WITH EDGE (EXT M3 [hook_head_via_u_sid] < 0.038+GLOBAL_TOLERANCE ABUT<90 OPPOSITE EXTENDED 0.015 MEASURE ALL)
 // 
 hook_seek_met = hook_seek ENCLOSE hook_head_via
 hook_neck_cor = EXT [hook_seek_met] < 0.005 ABUT==90 INTERSECTING ONLY
 hook_neck_err = EXT hook_neck_cor <= 0.100 ABUT<90 OPPOSITE
 hook_neck_arm = hook_seek_met TOUCH EDGE hook_neck_cor
 hook_neck_dtl = DFM PROPERTY hook_neck_err hook_neck_arm OVERLAP ABUT ALSO MULTI [dt_l = max(length(hook_neck_arm)) - min(length(hook_neck_arm))]
 // 
 hook_head_a = (INT (M3_convex_gt_one_edges TOUCH EDGE hook_seek_met) <= 0.05 OPPOSITE REGION) WITH EDGE hook_head_end_r
 hook_head_b = NOT ENCLOSE RECTANGLE hook_head_a 0.001 0.150+GLOBAL_TOLERANCE ORTHOGONAL ONLY
 hook_head = hook_head_b NOT OUTSIDE hook_head_via
 hook_tail = INT (hook_neck_sid) M3 <= 0.072 ABUT<90 OPPOSITE
 hook_gain = DFM PROPERTY hook_neck_err hook_tail hook_head hook_neck_dtl OVERLAP ABUT ALSO MULTI 
 [-= (count(hook_head) > 0 && count(hook_tail) == 0) ? 1 : 0] > 0 [dt_l = property(hook_neck_dtl,dt_l)] > 0.10
 err1 = DFM COPY hook_gain REGION
 err1 NOT INSIDE INST
}
 
M3_R_8_DFM1 {
@ It's not recommended to use dense Mxy line end pattern
@ DRC flage conditions:
@ (1) Middle Mxy line width(W1) <= 0.038um, both two neighbour Mxy lines width <= 0.064um
@ (2) Both the Vy-1 dense region (dense region definition: region formed by Vy-1 horizontal edge extension 0.038um, vertical edge extension 0.05um) horizontal edges neighbour Mxy line-end
@ DRC waive if Mxy enclosure Vy-1 > 0.05um. (Vy-1 is the via underneath Mxy)
@ This rule is not applied for INST region
 via_met = V2_SR NOT OUTSIDE (M3 WITH WIDTH <= 0.038)
 via_end = via_met TOUCH EDGE (ENC [via_met] M3_end_0.038 <= 0.05 ABUT<90 OPPOSITE)
 via_lin = (via_met NOT TOUCH EDGE via_end) TOUCH EDGE (ENC [via_met] met3_38_side <= 0.006 ABUT<90 OPPOSITE)
 via_mid = (via_met WITH EDGE via_end) WITH EDGE via_lin == 2
 via_sid = via_mid TOUCH EDGE via_lin
 // 
 nei_end = LENGTH M3_convex_90_90_edges <= 0.064
 nei_sid = LENGTH (EXPAND EDGE nei_end OUTSIDE BY 0.001) == 0.001
 nei_via = EXT [via_sid] nei_sid < 0.038+GLOBAL_TOLERANCE ABUT<90 OPPOSITE EXTENDED 0.050 MEASURE ALL
 err1 = via_mid WITH EDGE (via_mid TOUCH EDGE nei_via) >= 2
 err1 NOT INSIDE INST
}
 
M3_R_9_V2_DFM1 {
@ It's not recommended to use dense Mxy 3-bar pattern
@ DRC flag conditions:
@ (1) Middle Mxy line width(W1) is <= 0.048um, both two neighbour Mxy line width <= 0.064um and interact square or rectangle Vy or Vy-1
@ (2) Mxy Space to both via (S1/S2) = 0.058~0.063um
@ (3) The via PRL: -0.1 < PRL < 0.1um
@ (4) Both neighbour Mxy enclosure Vy or Vy-1 < 0.05um
@ This rule is not applied for INST region
 via_d_met = V2_SR NOT OUTSIDE (M3 WITH WIDTH <= 0.064)
 via_d_end = via_d_met TOUCH EDGE (ENC [via_d_met] M3_end_0.064 < 0.05 ABUT<90 OPPOSITE)
 via_d_lin = (via_d_met NOT TOUCH EDGE via_d_end) TOUCH EDGE (ENC [via_d_met] met3_64_side <= 0.032 ABUT<90 OPPOSITE)
 via_d_mid = (via_d_met WITH EDGE via_d_end) WITH EDGE via_d_lin >= 2
 via_d_sid = via_d_mid TOUCH EDGE via_d_lin
 via_d_sps = (EXT [met3_48_side] via_d_sid >= 0.058 <= 0.063 OPPOSITE EXTENDED 0.1 MEASURE ALL) TOUCH EDGE (EXT [met3_48_side] via_d_sid >= 0.058 <= 0.063 OPPOSITE MEASURE ALL)
 err1 = INT via_d_sps <= 0.048 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE INST
}
 
M3_R_9_V3_DFM1 {
@ It's not recommended to use dense Mxy 3-bar pattern
@ DRC flag conditions:
@ (1) Middle Mxy line width(W1) is <= 0.048um, both two neighbour Mxy line width <= 0.064um and interact square or rectangle Vy or Vy-1
@ (2) Mxy Space to both via (S1/S2) = 0.058~0.063um
@ (3) The via PRL: -0.1 < PRL < 0.1um
@ (4) Both neighbour Mxy enclosure Vy or Vy-1 < 0.05um
@ This rule is not applied for INST region
 via_u_met = V3_SR NOT OUTSIDE (M3 WITH WIDTH <= 0.064)
 via_u_end = via_u_met TOUCH EDGE (ENC [via_u_met] M3_end_0.064 < 0.05 ABUT<90 OPPOSITE)
 via_u_lin = (via_u_met NOT TOUCH EDGE via_u_end) TOUCH EDGE (ENC [via_u_met] met3_64_side <= 0.032 ABUT<90 OPPOSITE)
 via_u_mid = (via_u_met WITH EDGE via_u_end) WITH EDGE via_u_lin >= 2
 via_u_sid = via_u_mid TOUCH EDGE via_u_lin
 via_u_sps = (EXT [met3_48_side] via_u_sid >= 0.058 <= 0.063 OPPOSITE EXTENDED 0.1 MEASURE ALL) TOUCH EDGE (EXT [met3_48_side] via_u_sid >= 0.058 <= 0.063 OPPOSITE MEASURE ALL)
 err1 = INT via_u_sps <= 0.048 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE INST
}

#ENDIF

 
M3_W_1 {
@ Mxy width >= 0.032um
 err1 = INT M3 < 0.032 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
M3_W_2 {
@ Mxy width, except MARKS, and LOGO regions <= 2.1um
 err1 = (M3 NOT INSIDE MARKS_LOGO) WITH WIDTH > 2.1
 err1 NOT INSIDE MARKS_LOGO
}
 
M3_W_3 {
@ Metal branch width when connected to wide metal with both width and length >= 0.27um. >= 0.065um
 dorian_large = M3 WITH WIDTH >= 0.27
 dorian_whole = M3 INTERACT dorian_large
 dorian_large_exp = SIZE dorian_large BY 0.005 INSIDE OF dorian_whole
 dorian_branch_0 = dorian_whole NOT dorian_large
 dorian_branch_1 = dorian_branch_0 NOT COIN EDGE dorian_large
 dorian_branch_2 = dorian_branch_1 TOUCH EDGE dorian_large_exp
 err1 = INT dorian_branch_2 < 0.065 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
M3_W_4 {
@ Mxy branch width when connected to wide Mxy (width > 2um) which enclosed inner hole ((Mxy OR Mxy-hole) area >= 3050um2)
@ DRC checks the Mxy interact ((((Mxy OR Mxy-hole) sd 1um) su 1um) su 1um) >= 0.037um
 area_including_holes = AREA (M3 OR (HOLES M3 INNER EMPTY)) >= 3050
 met_WIDTH_gt_2 = SIZE area_including_holes BY 1 UNDEROVER
 met_SPACE_lt_2 = SIZE met_WIDTH_gt_2 BY 1
 // 
 err1_TMP = WITH WIDTH (M3 INTERACT met_SPACE_lt_2) < 0.037
 err1 = err1_TMP INTERACT met_SPACE_lt_2
 err1 NOT INSIDE SealR_NOT_BULK
}
 
M3_W_5 {
@ Width of 45-degree bent Mxy >= 0.152um
 err1 = INT M3_45_skew_edges < 0.152 OPPOSITE REGION EXCLUDE SHIELDED
 err1 NOT INSIDE SealR_NOT_BULK
}
 
M3_S_1 {
@ Space between two Mxy, except LOGO region >= 0.032um
 err1 = EXT M3 < 0.032 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE LOGO
}
 
M3_S_2 {
@ Space between Mxy when one or both Mxy width >= 0.071um and the PRL >= 0.14um. = 0.041~0.062, >= 0.072um
 met_wid_all = M3 WITH WIDTH >= 0.071
 met_err_RAW = (EXT [met_wid_all] M3 < 0.041 ABUT<90 OPPOSITE MEASURE ALL) OR EDGE (EXT [met_wid_all] M3 >= 0.063 < 0.072 ABUT<90 OPPOSITE MEASURE ALL)
 met_jog_ALL = (CONVEX EDGE M3 == 1) NOT COIN EDGE met_err_RAW
 met_jog_EXP_a = EXPAND EDGE met_jog_ALL INSIDE BY 0.0005
 met_jog_EXP_b = EXPAND EDGE met_jog_ALL OUTSIDE BY 0.0005
 met_jog_TMP = (met_jog_ALL COIN EDGE (met_jog_EXP_a WITH EDGE met_err_RAW)) COIN EDGE (met_jog_EXP_b WITH EDGE met_err_RAW)
 met_jog_EXP = ((VERTEX (EXPAND EDGE met_jog_TMP OUTSIDE BY 0.001 EXTEND BY 0.001) == 4) OR (EXPAND EDGE met_err_RAW OUTSIDE BY 0.001)) NOT M3
 // 
 met_err_PRL = DFM PROPERTY met_jog_EXP met_err_RAW OVERLAP ABUT ALSO MULTI [-= LENGTH(met_err_RAW)] > 0.140-GLOBAL_TOLERANCE
 met_err_EGE = met_err_RAW TOUCH EDGE met_err_PRL
 err1 = (EXT met_err_EGE M3 < 0.041 ABUT<90 OPPOSITE REGION MEASURE ALL) OR (EXT met_err_EGE M3 >= 0.063 < 0.072 ABUT<90 OPPOSITE REGION MEASURE ALL)
 err1 NOT INSIDE SealR_NOT_BULK
}
 
M3_S_3 {
@ Space between Mxy when one or both width >= 0.09um and PRL >= 0.14um. = 0.041~0.062, >= 0.081um
 met_wid_all = M3 WITH WIDTH >= 0.09
 met_err_RAW = (EXT [met_wid_all] M3 < 0.041 ABUT<90 OPPOSITE MEASURE ALL) OR EDGE (EXT [met_wid_all] M3 >= 0.063 < 0.081 ABUT<90 OPPOSITE MEASURE ALL)
 met_jog_ALL = (CONVEX EDGE M3 == 1) NOT COIN EDGE met_err_RAW
 met_jog_EXP_a = EXPAND EDGE met_jog_ALL INSIDE BY 0.0005
 met_jog_EXP_b = EXPAND EDGE met_jog_ALL OUTSIDE BY 0.0005
 met_jog_TMP = (met_jog_ALL COIN EDGE (met_jog_EXP_a WITH EDGE met_err_RAW)) COIN EDGE (met_jog_EXP_b WITH EDGE met_err_RAW)
 met_jog_EXP = ((VERTEX (EXPAND EDGE met_jog_TMP OUTSIDE BY 0.001 EXTEND BY 0.001) == 4) OR (EXPAND EDGE met_err_RAW OUTSIDE BY 0.001)) NOT M3
 // 
 met_err_PRL = DFM PROPERTY met_jog_EXP met_err_RAW OVERLAP ABUT ALSO MULTI [-= LENGTH(met_err_RAW)] > 0.140-GLOBAL_TOLERANCE
 met_err_EGE = met_err_RAW TOUCH EDGE met_err_PRL
 err1 = (EXT met_err_EGE M3 < 0.041 ABUT<90 OPPOSITE REGION MEASURE ALL) OR (EXT met_err_EGE M3 >= 0.063 < 0.081 ABUT<90 OPPOSITE REGION MEASURE ALL)
 err1 NOT INSIDE SealR_NOT_BULK
}
 
M3_S_4 {
@ Space between Mxy when one or both width >= 0.114um and PRL >= 0.14um, except LOGO region = 0.041~0.062, >= 0.106um
 met_wid_all = M3 WITH WIDTH >= 0.114
 met_err_RAW = (EXT [met_wid_all] M3 < 0.041 ABUT<90 OPPOSITE MEASURE ALL) OR EDGE (EXT [met_wid_all] M3 >= 0.063 < 0.106 ABUT<90 OPPOSITE MEASURE ALL)
 met_jog_ALL = (CONVEX EDGE M3 == 1) NOT COIN EDGE met_err_RAW
 met_jog_EXP_a = EXPAND EDGE met_jog_ALL INSIDE BY 0.0005
 met_jog_EXP_b = EXPAND EDGE met_jog_ALL OUTSIDE BY 0.0005
 met_jog_TMP = (met_jog_ALL COIN EDGE (met_jog_EXP_a WITH EDGE met_err_RAW)) COIN EDGE (met_jog_EXP_b WITH EDGE met_err_RAW)
 met_jog_EXP = ((VERTEX (EXPAND EDGE met_jog_TMP OUTSIDE BY 0.001 EXTEND BY 0.001) == 4) OR (EXPAND EDGE met_err_RAW OUTSIDE BY 0.001)) NOT M3
 // 
 met_err_PRL = DFM PROPERTY met_jog_EXP met_err_RAW OVERLAP ABUT ALSO MULTI [-= LENGTH(met_err_RAW)] > 0.140-GLOBAL_TOLERANCE
 met_err_EGE = met_err_RAW TOUCH EDGE met_err_PRL
 err1 = (EXT met_err_EGE M3 < 0.041 ABUT<90 OPPOSITE REGION MEASURE ALL) OR (EXT met_err_EGE M3 >= 0.063 < 0.106 ABUT<90 OPPOSITE REGION MEASURE ALL)
 err1 NOT INSIDE LOGO
}
 
M3_S_5 {
@ Space between Mxy when one or both width >= 0.181um and PRL >= 0.19um. >= 0.125um
 met_wid_all = M3 WITH WIDTH >= 0.181
 met_err_RAW = EXT M3 met_wid_all < 0.125 OPPOSITE REGION MEASURE ALL
 met_err_CRN = EXT (ANGLE M3 > 44 < 46) met_wid_all < 0.125 OPPOSITE1 REGION MEASURE ALL
 err1 = met_err_RAW ENCLOSE RECTANGLE 0.001 0.19 ORTHOGONAL ONLY
 err2 = met_err_CRN ENCLOSE RECTANGLE 0.032 0.19
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}
 
M3_S_6 {
@ Space between Mxy when one or both width >= 0.272um and PRL >= 0.288um. >= 0.143um
 met_wid_all = M3 WITH WIDTH >= 0.272
 met_err_RAW = EXT M3 met_wid_all < 0.143 OPPOSITE REGION MEASURE ALL
 met_err_CRN = EXT (ANGLE M3 > 44 < 46) met_wid_all < 0.143 OPPOSITE1 REGION MEASURE ALL
 err1 = met_err_RAW ENCLOSE RECTANGLE 0.001 0.288 ORTHOGONAL ONLY
 err2 = met_err_CRN ENCLOSE RECTANGLE 0.032 0.288
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}
 
M3_S_7 {
@ Space between Mxy when one or both width >= 0.542um, except LOGO region >= 0.188um
 chk_Mn = M3 WITH WIDTH >= 0.542
 err1 = EXT M3 chk_Mn < 0.188 ABUT<90 REGION
 err1 NOT INSIDE LOGO
}
 
M3_S_8 {
@ Space between Mxy when one or both width >= 1.352um, except LOGO region >= 0.304um
 chk_Mn = (M3 WITH WIDTH >= 0.542) WITH WIDTH >= 1.352
 err1 = EXT M3 chk_Mn < 0.304 ABUT<90 REGION
 err1 NOT INSIDE LOGO
}
 
M3_S_9 {
@ Space between Mxy line and line-end (W <= 0.051um) when PRL >= -0.021um. >= 0.049um
 err1 = EXT M3_line M3_end_0.052 < 0.049 ABUT<90 OPPOSITE EXTENDED 0.021+GLOBAL_TOLERANCE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
M3_S_10 {
@ Space between Mxy line-end (0.032um <= width <= 0.051um) and line-end (0.032um <= width <= 0.047um) when PRL >= -0.021um. >= 0.058um
 err1 = EXT M3_end_0.032_0.051 M3_end_0.032_0.047 < 0.058 ABUT<90 OPPOSITE EXTENDED 0.021+GLOBAL_TOLERANCE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
M3_S_11 {
@ Space between Mxy line-end (0.032um <= width <= 0.051um) and line-end (0.048um <= width <= 0.051um) when PRL >= -0.021um. >= 0.055um
 err1 = EXT M3_end_0.032_0.051 M3_end_0.048_0.051 < 0.055 ABUT<90 OPPOSITE EXTENDED 0.021+GLOBAL_TOLERANCE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
M3_S_12 {
@ Space between Mxy and dense Mxy line-end (0.032um >= W <= 0.047um), when PRL > -0.022um. Dense Mxy line end definition:
@ (W+S1) < 0.09um, other metal must be in the region R, T and D is the extension from metal line end, T <= 0.021um, D <= 0.051um, S1 should be the space between separate metal
@ (Except small jog with edge length <= 0.031um) >= 0.07um
 end_check_TMP = CONVEX EDGE M3 ANGLE1 == 90 LENGTH1 >= 0.001 ANGLE2 == 90 LENGTH2 >= 0.001 WITH LENGTH < 0.047+GLOBAL_TOLERANCE
 end_space_TMP = EXT end_check_TMP M3 < 0.07 ABUT<90 OPPOSITE EXTENDED 0.021+GLOBAL_TOLERANCE REGION
 end_space_EGE = end_check_TMP TOUCH EDGE end_space_TMP
 end_inner_EXD = EXPAND EDGE end_space_EGE INSIDE BY 0.051+GLOBAL_TOLERANCE OUTSIDE BY 0.021+GLOBAL_TOLERANCE
 end_sides_EGE = (end_inner_EXD TOUCH EDGE M3) NOT COIN EDGE end_check_TMP
 // 
 end_sides_ERR = EXT end_sides_EGE M3 < 0.09-0.024 OPPOSITE
 end_width_ERR = INT end_inner_EXD < 0.047+GLOBAL_TOLERANCE OPPOSITE EXCLUDE SHIELDED
 end_sides_CHK = DFM PROPERTY end_sides_EGE end_sides_ERR end_width_ERR OVERLAP ABUT ALSO MULTI [-= MIN(EW(end_sides_ERR)) + MIN(EW(end_width_ERR))] < 0.09
 end_check_EXD = (end_inner_EXD AND M3) WITH EDGE end_sides_CHK
 end_check = end_space_EGE TOUCH EDGE end_check_EXD
 err1 = EXT end_check M3 < 0.07 ABUT<90 OPPOSITE EXTENDED 0.021+GLOBAL_TOLERANCE REGION
 err2 = err1 NOT WITH EDGE (LENGTH M3_end <= 0.031)
 err2 NOT INSIDE SealR_NOT_BULK
}
 
M3_S_13 {
@ Space between Mxy and dense Mxy line-end (0.048um <= W <= 0.051um), when PRL > -0.022um. Dense Mxy line end definition:
@ (W+S1) < 0.09um, other metal must be in the region R, T and D is the extension from metal line end, T <= 0.021um, D <= 0.051um, S1 should be the space between separate metal
@ (Except small jog with edge length <= 0.031um) >= 0.056um
 end_check_TMP = CONVEX EDGE M3 ANGLE1 == 90 LENGTH1 >= 0.001 ANGLE2 == 90 LENGTH2 >= 0.001 WITH LENGTH >= 0.048 <= 0.051
 end_space_TMP = EXT end_check_TMP M3 < 0.056 ABUT<90 OPPOSITE EXTENDED 0.022 REGION
 end_space_EGE = end_check_TMP TOUCH EDGE end_space_TMP
 end_inner_EXD = EXPAND EDGE end_space_EGE INSIDE BY 0.051+GLOBAL_TOLERANCE OUTSIDE BY 0.021+GLOBAL_TOLERANCE
 end_sides_EGE = (end_inner_EXD TOUCH EDGE M3) NOT COIN EDGE end_check_TMP
 // 
 end_sides_ERR = EXT end_sides_EGE M3 < 0.058 OPPOSITE
 end_width_ERR = INT end_inner_EXD >= 0.048 <= 0.051 OPPOSITE EXCLUDE SHIELDED
 end_sides_CHK = DFM PROPERTY end_sides_EGE end_sides_ERR end_width_ERR OVERLAP ABUT ALSO MULTI [-= MIN(EW(end_sides_ERR)) + MIN(EW(end_width_ERR))] < 0.09
 end_check_EXD = (end_inner_EXD AND M3) WITH EDGE end_sides_CHK
 end_check = end_space_EGE TOUCH EDGE end_check_EXD
 err1 = EXT end_check M3 < 0.056 ABUT<90 OPPOSITE EXTENDED 0.022 REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
M3_line_end_046_054_edges = CONVEX EDGE M3 == 2 WITH LENGTH >= 0.046 <= 0.054
M3_line_end_046_054_prl_gt_L = INT (M3_line_end_046_054_edges) M3 < 0.134 OPPOSITE EXCLUDE SHIELDED
M3_line_end_046_054_prl_gt_L_all = M3_line_end_046_054_edges TOUCH EDGE M3_line_end_046_054_prl_gt_L
 
M3_S_14 {
@ Mxy line-end space in metal array >= 0.072um
@ Metal array definition:
@ 1. Mxy width (W): 0.046um <= W <= 0.054um
@ 2. Mxy length (L) >= 0.134um
@ 3. Searching distance (D) of Mxy line-end edge: 0.048um
@ 4. Mxy space (S1) 0.058um <= S1 <= 0.076um for both long sides
@ 5. Mxy PRL > 0um for short side (L1)
@ 6. Line end space (S2) of both neighboring Mxy: 0.058um <= S2 <= 0.076um with PRL > 0um
@ DRC doesn't flag at least one S1 >= 0.058~ <= 0.063um with PRL > 0.112um. And DRC flags forbidden space that has PRL > 0um with both S2
 distance_D_M = EXPAND EDGE M3_line_end_046_054_prl_gt_L_all INSIDE BY 0.048
 distance_D_W = (distance_D_M AND M3) COIN EDGE M3_line_end_046_054_prl_gt_L_all // W edge
 distance_D_W_edge = EXT [distance_D_W] M3 >= 0.058 <= 0.076 ABUT<90 OPPOSITE
 distance_D_W_058_076 = distance_D_W TOUCH EDGE distance_D_W_edge
 // for 58~76 region
 distance_D_seg_twin = (EXPAND EDGE distance_D_W_058_076 INSIDE BY 0.112+0.048 EXTEND BY 0.054-0.046) AND (INT M3 >= 0.046 <= 0.054 OPPOSITE REGION) // include jogs
 distance_D_seg_twin_l_sides = (distance_D_seg_twin NOT TOUCH EDGE distance_D_W_058_076) NOT INSIDE EDGE M3
 distance_D_seg_twin_l_sides_real = distance_D_seg_twin_l_sides NOT TOUCH EDGE (INT [distance_D_seg_twin_l_sides] distance_D_W_058_076 <= 0.112 + 0.048 ABUT<90 OPPOSITE)
 // 
 distance_D_side_058_076_edges = EXT [distance_D_seg_twin_l_sides_real] >= 0.058 <= 0.076 ABUT<90 OPPOSITE
 distance_D_side_058_076 = INT distance_D_side_058_076_edges >= 0.046 <= 0.054 ABUT<90 OPPOSITE REGION
 // 
 distance_D_seg_midd_part = M3 AND (EXPAND EDGE distance_D_W_058_076 INSIDE BY 0.112 + 0.048 EXTEND BY -0.01)
 distance_D_seg_side_part = distance_D_seg_twin NOT distance_D_seg_midd_part
 distance_D_seg_side_part_c = distance_D_seg_side_part INTERACT distance_D_side_058_076
 distance_D_seg_midd_part_c = distance_D_seg_midd_part INTERACT distance_D_seg_side_part_c >= 2
 distance_D_seg_twin_058_076_c = (distance_D_seg_twin INTERACT distance_D_side_058_076) INTERACT distance_D_seg_midd_part_c
 // 
 distance_D_seg_twin_opp = INT distance_D_seg_twin_058_076_c <= 0.112 + 0.048 ABUT<90 OPPOSITE EXCLUDE SHIELDED
 distance_D_seg_twin_opp_ew = DFM PROPERTY distance_D_seg_twin_opp distance_D_seg_twin_058_076_c OVERLAP ABUT ALSO MULTI [max_ew = ew(distance_D_seg_twin_opp)] >= 0.134 [cal_ew = (property_ref(max_ew) == ew(distance_D_seg_twin_opp)) ? 1 : 0] > 0
 // 
 distance_D_sp1 = distance_D_seg_twin_058_076_c NOT COIN EDGE (DFM COPY distance_D_seg_twin_opp_ew EDGE)
 distance_D_sp2 = (EXPAND EDGE distance_D_sp1 INSIDE BY 0.002 CORNER FILL) INTERACT distance_D_side_058_076
 distance_D_sp3 = distance_D_W_058_076 COIN EDGE (distance_D_seg_twin_058_076_c INTERACT distance_D_sp2 >= 2)
 // 
 distance_D_sp_forbidden = EXT distance_D_sp3 M3 < 0.072 ABUT<90 OPPOSITE REGION
 distance_D_sp_forbidden_ove = EXPAND EDGE (distance_D_W_058_076 TOUCH EDGE distance_D_sp_forbidden) OUTSIDE BY 0.005
 distance_D_sp_forbidden_all = EXTENTS (OR distance_D_sp_forbidden distance_D_sp_forbidden_ove)
 distance_D_sp_forbidden_side = distance_D_sp_forbidden_all NOT TOUCH EDGE M3
 distance_D_sp_forbidden_side_prl = EXT (distance_D_sp_forbidden_side) M3 >= 0.058 <= 0.076 ABUT<90 OPPOSITE
 distance_D_sp_forbidden_side_prl_both = distance_D_sp_forbidden_all WITH EDGE distance_D_sp_forbidden_side_prl >= 2
 err1 = distance_D_sp_forbidden AND distance_D_sp_forbidden_side_prl_both // flag error region has prl with the beside error region
 err1 NOT INSIDE SealR_NOT_BULK
}
 
M3_S_15 {
@ Space between two Mxy when one or both Mxy enclosure of long side edge of RVy-1 is < 0.007um, Mxy is the metal layer directly above RVy-1
@ DRC flag the space between Mxy and the long sides of RVy-1. >= 0.035um
 err1_c = ENC RV2_L [M3] < 0.007 ABUT<90 OPPOSITE
 err1 = EXT err1_c M3 < 0.035 ABUT<90 REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
M3_S_16 {
@ Space between two Mxy when one or both Mxy enclosure of long side edge of RVy-1 are < 0.003um, Mxy is the metal layer directly above RVy-1
@ DRC flag the space between Mxy and the long sides of RVy-1. >= 0.044um
 err1_c = ENC RV2_L [M3] < 0.003 ABUT<90 OPPOSITE
 err1 = EXT err1_c M3 < 0.044 ABUT<90 REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
M3_S_17 {
@ Space between Mxy and 45-degree bent Mxy, DRC check 45-degree direction >= 0.152um
 err1 = EXT M3 M3_45_skew_edges < 0.152 ABUT<90 OPPOSITE2 REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
M3_S_18 {
@ Space between Mxy and INST, space = 0 is allowed >= 0.08um
 err1 = EXT M3 INST < 0.08 ABUT>0<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
M3_L_1 {
@ Mxy edge length with adjacent edge < 0.032um (these two edges formed by three consecutive 270-90-270 degree corner) >= 0.064um
@ DRC doesn't flag if there is Mxy in the region which is formed by 0.125um extension from these two edges and the 90-degree outer vertex
 L1 = CONVEX EDGE M3 ANGLE1 == 90 ANGLE2 == 270 WITH LENGTH < 0.032
 L2 = CONVEX EDGE M3 ANGLE1 == 90 ANGLE2 == 270 WITH LENGTH < 0.064
 L3_corner = INT L1 L2 < 0.005 ABUT==90 INTERSECTING ONLY REGION
 L1_c_edge = L1 TOUCH EDGE L3_corner
 L2_c_edge = L2 TOUCH EDGE L3_corner
 L1_c_s125 = EXPAND EDGE L1_c_edge OUTSIDE BY 0.125
 L2_c_s125 = EXPAND EDGE L2_c_edge OUTSIDE BY 0.125
 // 
 SQ_corner_raw = (EXT L1_c_s125 L2_c_s125 < 0.125 ABUT==90 INTERSECTING ONLY REGION EXTENTS) NOT INSIDE M3
 SQ_corner = (SQ_corner_raw NOT COIN EDGE L1_c_s125) NOT COIN EDGE L2_c_s125
 // 
 RM_step_1 = INT SQ_corner <= 0.586*0.125 ABUT==90 INTERSECTING ONLY REGION
 SQ_step_1 = SQ_corner_raw NOT RM_step_1
 RM_step_2 = INT SQ_step_1 <= 0.215*0.125 ABUT>134.8 <135.2 INTERSECTING ONLY REGION
 SQ_step_2 = SQ_step_1 NOT RM_step_2
 SQ_step_3 = (SQ_step_2 OR L1_c_s125) OR L2_c_s125
 SQ_real = SQ_step_3 NOT INTERACT (SQ_step_3 AND M3)
 err1_TMP = L3_corner TOUCH SQ_real
 err1 = EXPAND EDGE (M3 TOUCH EDGE err1_TMP) INSIDE BY 0.001
 err1 NOT INSIDE SealR_NOT_BULK
}
 
M3_L_2 {
@ Mxy edge length with adjacent edge < 0.032um (these two edges formed by three consecutive 90-270-90 degree corners), except EFUSE region >= 0.064um
 chk_EDG = LENGTH M3_convex_270_90_edges < 0.032
 err_EDG = LENGTH M3_convex_270_90_edges < 0.064
 err1 = EXT chk_EDG err_EDG < 0.005 ABUT==90 INTERSECTING ONLY REGION
 err1 NOT INSIDE EFUSE
}
 
M3_L_3 {
@ Mxy branch length when Mxy branch width <= 0.269um, and connected to wide metal with both width and length >= 0.27um. >= 0.139um
@ DRC waive if the branch region can fill at least one (0.005um*design value) rectangle
 // 0.065 based on Mxy.W.3
 dorian_large = M3 WITH WIDTH >= 0.27
 dorian_whole = M3 INTERACT dorian_large
 dorian_large_ep = SIZE dorian_large BY 0.005 INSIDE OF dorian_whole
 dorian_branch_1 = M3 WITH WIDTH >= 0.065 < 0.269+GLOBAL_TOLERANCE
 dorian_branch_2 = dorian_branch_1 NOT OUTSIDE dorian_large_ep
 dorian_branch_3 = ENCLOSE RECTANGLE dorian_branch_2 0.005 0.139 ORTHOGONAL ONLY
 err1 = dorian_branch_2 NOT dorian_branch_3
 err1 NOT INSIDE SealR_NOT_BULK
}
 
M3_L_4 {
@ Mxy branch length when Mxy branch width <= 0.269um, and connected to wide metal with both width and length >= 0.542um. >= 0.248um
@ DRC waive if the branch region can fill at least one (0.005um*design value) rectangle
 // 0.065 based on Mxy.W.3
 dorian_large = M3 WITH WIDTH >= 0.542
 dorian_whole = M3 INTERACT dorian_large
 dorian_large_ep = SIZE dorian_large BY 0.005 INSIDE OF dorian_whole
 dorian_branch_1 = M3 WITH WIDTH >= 0.065 < 0.269+GLOBAL_TOLERANCE
 dorian_branch_2 = dorian_branch_1 NOT OUTSIDE dorian_large_ep
 dorian_branch_3 = ENCLOSE RECTANGLE dorian_branch_2 0.005 0.248 ORTHOGONAL ONLY
 err1 = dorian_branch_2 NOT dorian_branch_3
 err1 NOT INSIDE SealR_NOT_BULK
}
 
M3_L_5 {
@ Length of Mxy branch when Mxy branch width <= 0.269um, and connected to wide metal e with both width and length >= 1um. >= 0.495um
@ DRC waive if the branch region can fill at least one (0.005um*design value) rectangle
 // 0.065 based on Mxy.W.3
 dorian_large = M3 WITH WIDTH >= 1.00
 dorian_whole = M3 INTERACT dorian_large
 dorian_large_ep = SIZE dorian_large BY 0.005 INSIDE OF dorian_whole
 dorian_branch_1 = M3 WITH WIDTH >= 0.065 < 0.269+GLOBAL_TOLERANCE
 dorian_branch_2 = dorian_branch_1 NOT OUTSIDE dorian_large_ep
 dorian_branch_3 = ENCLOSE RECTANGLE dorian_branch_2 0.005 0.495 ORTHOGONAL ONLY
 err1 = dorian_branch_2 NOT dorian_branch_3
 err1 NOT INSIDE SealR_NOT_BULK
}
 
M3_L_6 {
@ Length of 45-degree bent metal, except MARKS region >= 0.44um
 err1 = LENGTH M3_45_skew_edges < 0.44
 err1 NOT INSIDE EDGE MARKS
}
 
M3_NOT_MARKS = (M3 OR M3DP) NOT MARKS
M3_in_ck_area = M3_NOT_MARKS AND CHIP_NOT_MARKS
M3_all_NOT_MARKS = M3_all NOT MARKS
M3_all_in_ck_area = M3_all_NOT_MARKS AND CHIP_NOT_MARKS
 

#IFDEF IP_LEVEL_DENSITY_CHECK YES
#IFDEF MINIMUM_DENSITY_CHECK YES

M3_D_1_less_than_15 {
@ Mxy density (window 50um*50um, stepping 50um/step_number), except the window (15.8% <= metal density < 26.3%) not interact 3um*3um empty area, except OCOVL region, (NODMF su 1um) >= 26.3%
 check_region = CHIP_NOT_MARKS NOT (or OCOVL NODMF_SIZE_1)
 check_pattern = M3_all AND check_region
 // 
 check_window1 = check_region WITH WIDTH >= 50/4
 err1_TMP1 = DENSITY check_pattern check_window1 check_region [!AREA(check_window1) + !!AREA(check_window1)*AREA(check_pattern)/AREA(check_region)] < 0.158 WINDOW 50 STEP 50/step_number BACKUP INSIDE OF LAYER DRC:1 BY POLYGON
 // 
 check_window2 = WITH WIDTH (check_region AND err1_TMP1) >= 50/4
 err1_TMP2 = DENSITY check_pattern check_window2 check_region [!AREA(check_window2) + !!AREA(check_window2)*AREA(check_pattern)/AREA(check_region)] < 0.158 WINDOW 50 STEP 50/step_number BACKUP INSIDE OF LAYER err1_TMP1 BY POLYGON
 // 
 check_window3 = WITH WIDTH (check_region AND err1_TMP2) >= 50/4
 DENSITY check_pattern check_window3 check_region [!AREA(check_window3) + !!AREA(check_window3)*AREA(check_pattern)/AREA(check_region)] < 0.158 WINDOW 50 STEP 50/step_number BACKUP INSIDE OF LAYER err1_TMP2 BY POLYGON PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_M3_D_1_less_than_15.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_M3_D_1_less_than_15.rdb"
}
 
M3_D_1_between_15_25 {
@ Mxy density (window 50um*50um, stepping 50um/step_number), except the window (15.8% <= metal density < 26.3%) not interact 3um*3um empty area, except OCOVL region, (NODMF su 1um) >= 26.3%
 ck3x3_window = WITH WIDTH (check_region NOT M3_all) >= 3
 check_region = CHIP_NOT_MARKS NOT (or OCOVL NODMF_SIZE_1)
 check_pattern = M3_all AND check_region
 // 
 check_window1 = check_region WITH WIDTH >= 50/4
 err1_TMP1 = DENSITY check_pattern check_window1 check_region ck3x3_window [!AREA(ck3x3_window) + !AREA(check_window1) + !!AREA(ck3x3_window)*!!AREA(check_window1)*AREA(check_pattern)/AREA(check_region)] >= 0.158 < 0.263 WINDOW 50 STEP 50/step_number BACKUP INSIDE OF LAYER DRC:1 BY POLYGON
 // 
 check_window2 = WITH WIDTH (check_region AND err1_TMP1) >= 50/4
 err1_TMP2 = DENSITY check_pattern check_window2 check_region ck3x3_window [!AREA(ck3x3_window) + !AREA(check_window2) + !!AREA(ck3x3_window)*!!AREA(check_window2)*AREA(check_pattern)/AREA(check_region)] >= 0.158 < 0.263 WINDOW 50 STEP 50/step_number BACKUP INSIDE OF LAYER err1_TMP1 BY POLYGON
 // 
 check_window3 = WITH WIDTH (check_region AND err1_TMP2) >= 50/4
 DENSITY check_pattern check_window3 check_region ck3x3_window [!AREA(ck3x3_window) + !AREA(check_window3) + !!AREA(ck3x3_window)*!!AREA(check_window3)*AREA(check_pattern)/AREA(check_region)] >= 0.158 < 0.263 WINDOW 50 STEP 50/step_number BACKUP INSIDE OF LAYER err1_TMP2 BY POLYGON PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_M3_D_1_between_15_25.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_M3_D_1_between_15_25.rdb"
}

#ENDIF

 
M3_D_2 {
@ Mxy maximum density (window 50um*50um, stepping 25um), except dummy metal <= 65%
 check_region = COPY CHIP_NOT_MARKS
 check_pattern = (M3 OR M3DP) AND check_region
 // 
 check_window1 = check_region WITH WIDTH >= 50/4
 err1_TMP1 = DENSITY check_pattern check_window1 check_region [!!AREA(check_window1)*AREA(check_pattern)/AREA(check_region)] > 0.65 WINDOW 50 STEP 25 BACKUP INSIDE OF LAYER DRC:1 BY POLYGON
 // 
 check_window2 = WITH WIDTH (check_region AND err1_TMP1) >= 50/4
 err1_TMP2 = DENSITY check_pattern check_window2 check_region [!!AREA(check_window2)*AREA(check_pattern)/AREA(check_region)] > 0.65 WINDOW 50 STEP 25 BACKUP INSIDE OF LAYER err1_TMP1 BY POLYGON
 // 
 check_window3 = WITH WIDTH (check_region AND err1_TMP2) >= 50/4
 DENSITY check_pattern check_window3 check_region [!!AREA(check_window3)*AREA(check_pattern)/AREA(check_region)] > 0.65 WINDOW 50 STEP 25 BACKUP INSIDE OF LAYER err1_TMP2 BY POLYGON PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_M3_D_2.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_M3_D_2.rdb"
}
 
M3_D_3 {
@ Mxy maximum density (window 50um*50um, stepping 50um/step_number) <= 71.3%
 check_region = COPY CHIP_NOT_MARKS
 check_pattern = M3_all AND check_region
 // 
 check_window1 = check_region WITH WIDTH >= 50/4
 err1_TMP1 = DENSITY check_pattern check_window1 check_region [!!AREA(check_window1)*AREA(check_pattern)/AREA(check_region)] > 0.713 WINDOW 50 STEP 50/step_number BACKUP INSIDE OF LAYER DRC:1 BY POLYGON
 // 
 check_window2 = WITH WIDTH (check_region AND err1_TMP1) >= 50/4
 err1_TMP2 = DENSITY check_pattern check_window2 check_region [!!AREA(check_window2)*AREA(check_pattern)/AREA(check_region)] > 0.713 WINDOW 50 STEP 50/step_number BACKUP INSIDE OF LAYER err1_TMP1 BY POLYGON
 // 
 check_window3 = WITH WIDTH (check_region AND err1_TMP2) >= 50/4
 DENSITY check_pattern check_window3 check_region [!!AREA(check_window3)*AREA(check_pattern)/AREA(check_region)] > 0.713 WINDOW 50 STEP 50/step_number BACKUP INSIDE OF LAYER err1_TMP2 BY POLYGON PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_M3_D_3.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_M3_D_3.rdb"
}
 
M3_D_4 {
@ Mxy density difference between any two neighboring checking windows (window 180um*180um, stepping 180um/step_number) <= 38%
 DENSITY M3_all_NOT_MARKS CHIP_NOT_MARKS [AREA(M3_all_NOT_MARKS)/AREA(CHIP_NOT_MARKS)] >= 0 WINDOW 180 STEP 180/step_number GRADIENT > 0.38 ABSOLUTE BACKUP PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_M3_D_4.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_M3_D_4.rdb"
}
 

#IFDEF MINIMUM_DENSITY_CHECK YES


#ENDIF

 
M3_D_7 {
@ Mxy density ratio of ((Mxy or dummy Mxy) INTERACT ((MxyDPMK OR MxyCA) OR MxyCB)) to (Mxy or dummy Mxy) in window 72um*72um, step size: 72um/step_number, except OCOVL region <= 28.5%
 check_pattern = (M3_all INTERACT (OR M3DPMK M3CA M3CB)) NOT (OR MARKS OCOVL)
 check_region = M3_all NOT (OR MARKS OCOVL)
 DENSITY check_pattern check_region [AREA(check_pattern)/AREA(check_region)] > 0.285 WINDOW 72 STEP 72/step_number BACKUP PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_M3_D_7.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_M3_D_7.rdb"
}

#ENDIF

 

#IFDEF IP_LEVEL_DENSITY_CHECK NO
#IFDEF MINIMUM_DENSITY_CHECK YES

M3_D_1_less_than_15 {
@ Mxy density (window 50um*50um, stepping 25um), except the window (15% <= metal density < 25%) not interact 3um*3um empty area, except OCOVL region, (NODMF su 1um) >= 25%
 check_region = CHIP_NOT_MARKS NOT (or OCOVL NODMF_SIZE_1)
 check_pattern = M3_all AND check_region
 // 
 check_window1 = check_region WITH WIDTH >= 50/4
 err1_TMP1 = DENSITY check_pattern check_window1 check_region [!AREA(check_window1) + !!AREA(check_window1)*AREA(check_pattern)/AREA(check_region)] < 0.15 WINDOW 50 STEP 25 BACKUP INSIDE OF LAYER DRC:1 BY POLYGON
 // 
 check_window2 = WITH WIDTH (check_region AND err1_TMP1) >= 50/4
 err1_TMP2 = DENSITY check_pattern check_window2 check_region [!AREA(check_window2) + !!AREA(check_window2)*AREA(check_pattern)/AREA(check_region)] < 0.15 WINDOW 50 STEP 25 BACKUP INSIDE OF LAYER err1_TMP1 BY POLYGON
 // 
 check_window3 = WITH WIDTH (check_region AND err1_TMP2) >= 50/4
 DENSITY check_pattern check_window3 check_region [!AREA(check_window3) + !!AREA(check_window3)*AREA(check_pattern)/AREA(check_region)] < 0.15 WINDOW 50 STEP 25 BACKUP INSIDE OF LAYER err1_TMP2 BY POLYGON PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_M3_D_1_less_than_15.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_M3_D_1_less_than_15.rdb"
}
 
M3_D_1_between_15_25 {
@ Mxy density (window 50um*50um, stepping 25um), except the window (15% <= metal density < 25%) not interact 3um*3um empty area, except OCOVL, (NODMF su 1um) region >= 25%
 ck3x3_window = WITH WIDTH (check_region NOT M3_all) >= 3
 check_region = CHIP_NOT_MARKS NOT (or OCOVL NODMF_SIZE_1)
 check_pattern = M3_all AND check_region
 // 
 check_window1 = check_region WITH WIDTH >= 50/4
 err1_TMP1 = DENSITY check_pattern check_window1 check_region ck3x3_window [!AREA(ck3x3_window) + !AREA(check_window1) + !!AREA(ck3x3_window)*!!AREA(check_window1)*AREA(check_pattern)/AREA(check_region)] >= 0.15 < 0.25 WINDOW 50 STEP 25 BACKUP INSIDE OF LAYER DRC:1 BY POLYGON
 // 
 check_window2 = WITH WIDTH (check_region AND err1_TMP1) >= 50/4
 err1_TMP2 = DENSITY check_pattern check_window2 check_region ck3x3_window [!AREA(ck3x3_window) + !AREA(check_window2) + !!AREA(ck3x3_window)*!!AREA(check_window2)*AREA(check_pattern)/AREA(check_region)] >= 0.15 < 0.25 WINDOW 50 STEP 25 BACKUP INSIDE OF LAYER err1_TMP1 BY POLYGON
 // 
 check_window3 = WITH WIDTH (check_region AND err1_TMP2) >= 50/4
 DENSITY check_pattern check_window3 check_region ck3x3_window [!AREA(ck3x3_window) + !AREA(check_window3) + !!AREA(ck3x3_window)*!!AREA(check_window3)*AREA(check_pattern)/AREA(check_region)] >= 0.15 < 0.25 WINDOW 50 STEP 25 BACKUP INSIDE OF LAYER err1_TMP2 BY POLYGON PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_M3_D_1_between_15_25.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_M3_D_1_between_15_25.rdb"
}

#ENDIF

 
M3_D_2 {
@ Mxy maximum density (window 50um*50um, stepping 25um), except dummy metal <= 65%
 check_region = COPY CHIP_NOT_MARKS
 check_pattern = (M3 OR M3DP) AND check_region
 // 
 check_window1 = check_region WITH WIDTH >= 50/4
 err1_TMP1 = DENSITY check_pattern check_window1 check_region [!!AREA(check_window1)*AREA(check_pattern)/AREA(check_region)] > 0.65 WINDOW 50 STEP 25 BACKUP INSIDE OF LAYER DRC:1 BY POLYGON
 // 
 check_window2 = WITH WIDTH (check_region AND err1_TMP1) >= 50/4
 err1_TMP2 = DENSITY check_pattern check_window2 check_region [!!AREA(check_window2)*AREA(check_pattern)/AREA(check_region)] > 0.65 WINDOW 50 STEP 25 BACKUP INSIDE OF LAYER err1_TMP1 BY POLYGON
 // 
 check_window3 = WITH WIDTH (check_region AND err1_TMP2) >= 50/4
 DENSITY check_pattern check_window3 check_region [!!AREA(check_window3)*AREA(check_pattern)/AREA(check_region)] > 0.65 WINDOW 50 STEP 25 BACKUP INSIDE OF LAYER err1_TMP2 BY POLYGON PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_M3_D_2.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_M3_D_2.rdb"
}
 
M3_D_3 {
@ Mxy maximum density (window 50um*50um, stepping 25um) <= 75%
 check_region = COPY CHIP_NOT_MARKS
 check_pattern = M3_all AND check_region
 // 
 check_window1 = check_region WITH WIDTH >= 50/4
 err1_TMP1 = DENSITY check_pattern check_window1 check_region [!!AREA(check_window1)*AREA(check_pattern)/AREA(check_region)] > 0.75 WINDOW 50 STEP 25 BACKUP INSIDE OF LAYER DRC:1 BY POLYGON
 // 
 check_window2 = WITH WIDTH (check_region AND err1_TMP1) >= 50/4
 err1_TMP2 = DENSITY check_pattern check_window2 check_region [!!AREA(check_window2)*AREA(check_pattern)/AREA(check_region)] > 0.75 WINDOW 50 STEP 25 BACKUP INSIDE OF LAYER err1_TMP1 BY POLYGON
 // 
 check_window3 = WITH WIDTH (check_region AND err1_TMP2) >= 50/4
 DENSITY check_pattern check_window3 check_region [!!AREA(check_window3)*AREA(check_pattern)/AREA(check_region)] > 0.75 WINDOW 50 STEP 25 BACKUP INSIDE OF LAYER err1_TMP2 BY POLYGON PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_M3_D_3.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_M3_D_3.rdb"
}
 
M3_D_4 {
@ Mxy density difference between any two neighboring checking windows (window 180um*180um, stepping 90um) <= 40%
 DENSITY M3_all_NOT_MARKS CHIP_NOT_MARKS [AREA(M3_all_NOT_MARKS)/AREA(CHIP_NOT_MARKS)] >= 0 WINDOW 180 STEP 90 GRADIENT > 0.4 ABSOLUTE BACKUP PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_M3_D_4.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_M3_D_4.rdb"
}
 

#IFDEF MINIMUM_DENSITY_CHECK YES


#ENDIF

 
M3_D_7 {
@ Mxy density ratio of ((Mxy or dummy Mxy) INTERACT ((MxyDPMK OR MxyCA) OR MxyCB)) to (Mxy or dummy Mxy) in window 72um*72um, step size: 36um, except OCOVL region <= 30%
 check_pattern = (M3_all INTERACT (OR M3DPMK M3CA M3CB)) NOT (OR MARKS OCOVL)
 check_region = M3_all NOT (OR MARKS OCOVL)
 DENSITY check_pattern check_region [AREA(check_pattern)/AREA(check_region)] > 0.3 WINDOW 72 STEP 36 BACKUP PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_M3_D_7.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_M3_D_7.rdb"
}

#ENDIF

 

#IFDEF METAL_DECOMPOSITION_RESULT YES

 
M3_D_8 {
@ Mxy density difference of ABS (((Mxy OR MxyDUM OR MxyDOP) - (MxyDP OR MxyDPDUM OR MxyDPDOP)) / ((Mxy OR MxyDUM OR MxyDOP) + (MxyDP OR MxyDPDUM OR MxyDPDOP)))
@ This rule is applied post Mxy layout decomposition <= 10%
 FM_all = (M3 OR M3DUM) OR M3DOP
 GM_all = (M3DP OR M3DPDUM) OR M3DPDOP
 FM_chk = FM_all NOT MARKS
 GM_chk = GM_all NOT MARKS
 err1 = DENSITY FM_chk GM_chk [AREA(FM_chk) - AREA(GM_chk) - 0.1*(AREA(FM_chk) + AREA(GM_chk))] > 0 PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_M3_D_8_1.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_M3_D_8_1.rdb"
 err2 = DENSITY FM_chk GM_chk [AREA(GM_chk) - AREA(FM_chk) - 0.1*(AREA(FM_chk) + AREA(GM_chk))] > 0 PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_M3_D_8_2.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_M3_D_8_2.rdb"
 err1 OR err2
}

#ENDIF

 
M3_A_2 {
@ M3 area >= 0.0072um2
 err1 = AREA M3 < 0.0072
 err1 NOT INSIDE SealR_NOT_BULK
}
 
M3_A_4 {
@ Mxy area (with all of edge lengths < 0.082um) (Except a pattern filling 0.078um*0.078um rectangular pattern) >= 0.0178um2
 Mn_waive = ENCLOSE RECTANGLE M3 0.078 0.078 ORTHOGONAL ONLY
 Mn_check = AREA M3 < 0.0178
 Mn_edge_all = LENGTH Mn_check >= 0.082
 err1 = (Mn_check NOT WITH EDGE Mn_edge_all) NOT Mn_waive
 err1 NOT INSIDE SealR_NOT_BULK
}
 
M3_A_5 {
@ Mxy enclosed area >= 0.161um2
 err1 = AREA ((HOLES M3 INNER) NOT M3) < 0.161
 err1 NOT INSIDE SealR_NOT_BULK
}
 
M3_R_1 {
@ Mxy forbidden space (Mxy width >= 0.15um and PRL > 0.135um), except Mxy jog width <= 0.135um. = 0.058~0.062um
@ DRC searching range is from 0.106um to 0.729um
@ DRC flags the forbidden space that totally inside the searching range along the space direction, and the PRL between forbidden space and the wide metal is > 0.135um
 SPACE_Forbidden_PRE = EXT M3 >= 0.058 <= 0.062 ABUT<90 OPPOSITE REGION
 SPACE_Forbidden_TMP = SPACE_Forbidden_PRE ENCLOSE RECTANGLE 0.001 0.135+GLOBAL_TOLERANCE ORTHOGONAL ONLY
 SPACE_Forbidden_TMP_in_SearchR = EXT (M3 COIN EDGE SPACE_Forbidden_TMP) met3_wide_eqgt_150 >= 0.106 <= 0.729 ABUT>0<90 OPPOSITE MEASURE ALL
 SPACE_Forbidden_TMP_in_SearchR_EDGE = M3 COIN EDGE (DFM COPY SPACE_Forbidden_TMP_in_SearchR EDGE)
 SPACE_Forbidden_real = EXT SPACE_Forbidden_TMP_in_SearchR_EDGE M3 >= 0.058 <= 0.062 ABUT<90 OPPOSITE REGION
 err1 = ENCLOSE RECTANGLE SPACE_Forbidden_real 0.001 0.135+GLOBAL_TOLERANCE ORTHOGONAL ONLY
 err1 NOT INSIDE SealR_NOT_BULK
}
 
M3_COLORA = M3 INTERACT M3CA
M3_COLORB = M3 INTERACT M3CB

#IFDEF DOUBLE_PATTERNING_RULES_CHECK YES

M3_a = M3 INTERACT M3_mask0
M3_b = M3 INTERACT M3_mask1
M3_a_v_edges = M3_v_edges TOUCH EDGE M3_a
M3_b_v_edges = M3_v_edges TOUCH EDGE M3_b
M3_a_h_edges = M3_h_edges TOUCH EDGE M3_a
M3_b_h_edges = M3_h_edges TOUCH EDGE M3_b
M3_a_width_lt_037_opp_edges = M3_width_lt_037_opp_edges COIN EDGE M3_a
M3_b_width_lt_037_opp_edges = M3_width_lt_037_opp_edges COIN EDGE M3_b
 

#IFDEF DOUBLE_PATTERNING_RULES_CHECK_ONLY YES

DRC SELECT CHECK M3_R_3

#ENDIF

 
M3_R_3 {
@ Mxy forbidden space for single mask when Mxy width < 0.037um, except M2
@ DRC flags edge of ((W1+S1+W2+S2) or (S1+W2+S2+W3)) = 0.141~0.175um
@ DRC waive when:
@ (1) A/B or B/C are same polygons
@ (2) A/C in different masks
@ DRC flags edge of forbidden zone
 M3_NOTCH = EXT [M3] <= 0.08 ABUT<90 OPPOSITE
 M3_NOTCH_A = EXT (M3_v_edges COIN EDGE M3_NOTCH) <= 0.112 ABUT<90 OPPOSITE PARA ONLY NOTCH REGION EXCLUDE SHIELDED
 M3_NOTCH_A_all = M3_v_edges OR EDGE (M3_NOTCH_A COIN EDGE M3_v_edges)
 M3_ERR_P1 = DFM SPACE M3_NOTCH_A_all M3_width_lt_037_opp_edges >= 0.141 <= 0.175 BY ENC MEASURE ALL COUNT == 3 BY LAYER M3_NOTCH_A_all
 M3_ERR_P2 = DFM SPACE M3_width_lt_037_opp_edges M3_NOTCH_A_all >= 0.141 <= 0.175 BY ENC MEASURE ALL COUNT == 3 BY LAYER M3_NOTCH_A_all
 err1 = DFM PROPERTY M3_ERR_P1 M3_COLORA M3_COLORB M3_width_lt_037_opp_edges OVERLAP ABUT ALSO MULTI 
 [+= (count(M3_width_lt_037_opp_edges) > 0) ? 1 : 0] > 0 
 [-= (EC(M3_ERR_P1) > 0 && (count(M3_COLORA) > 1 || count(M3_COLORB) > 1 || count(M3_COLORA) == 0 || count(M3_COLORB) == 0)) ? 1 : 0 ] > 0
 err2 = DFM PROPERTY M3_ERR_P2 M3_COLORA M3_COLORB M3_width_lt_037_opp_edges OVERLAP ABUT ALSO MULTI 
 [+= (count(M3_width_lt_037_opp_edges) > 0) ? 1 : 0] > 0 
 [-= (EC(M3_ERR_P2) > 0 && (count(M3_COLORA) > 1 || count(M3_COLORB) > 1 || count(M3_COLORA) == 0 || count(M3_COLORB) == 0)) ? 1 : 0 ] > 0
 DFM COPY err1 err2
 // 
 M3_NOTCH_B = EXT (M3_h_edges COIN EDGE M3_NOTCH) <= 0.112 ABUT<90 OPPOSITE PARA ONLY NOTCH REGION EXCLUDE SHIELDED
 M3_NOTCH_B_all = M3_h_edges OR EDGE (M3_NOTCH_B COIN EDGE M3_h_edges)
 M3_ERR_P3 = DFM SPACE M3_NOTCH_B_all M3_width_lt_037_opp_edges >= 0.141 <= 0.175 BY ENC MEASURE ALL COUNT == 3 BY LAYER M3_NOTCH_B_all
 M3_ERR_P4 = DFM SPACE M3_width_lt_037_opp_edges M3_NOTCH_B_all >= 0.141 <= 0.175 BY ENC MEASURE ALL COUNT == 3 BY LAYER M3_NOTCH_B_all
 err3 = DFM PROPERTY M3_ERR_P3 M3_COLORA M3_COLORB M3_width_lt_037_opp_edges OVERLAP ABUT ALSO MULTI 
 [+= (count(M3_width_lt_037_opp_edges) > 0) ? 1 : 0] > 0 
 [-= (EC(M3_ERR_P3) > 0 && (count(M3_COLORA) > 1 || count(M3_COLORB) > 1 || count(M3_COLORA) == 0 || count(M3_COLORB) == 0)) ? 1 : 0 ] > 0
 err4 = DFM PROPERTY M3_ERR_P4 M3_COLORA M3_COLORB M3_width_lt_037_opp_edges OVERLAP ABUT ALSO MULTI 
 [+= (count(M3_width_lt_037_opp_edges) > 0) ? 1 : 0] > 0 
 [-= (EC(M3_ERR_P4) > 0 && (count(M3_COLORA) > 1 || count(M3_COLORB) > 1 || count(M3_COLORA) == 0 || count(M3_COLORB) == 0)) ? 1 : 0 ] > 0
 DFM COPY err3 err4
}

#ENDIF

 
M3_R_4 {
@ Mxy overlap of MTFUSE is not allowed
 err1 = M3 AND MTFUSE
 err1 NOT INSIDE SealR_NOT_BULK
}
// Mxy.R.6[NC] Mxy pattern must be drawn on data type 0
 
M3_R_7 {
@ U-shape metal pitch (W+S1) or (W+S2) must be >= 0.072um except M2 in INST region
@ Vy enclosure by Mxy line-end (E) must be >= 0.032um (Mxy is the metal underneath Vy)
@ When:
@ (1) Both PRL1 and PRL2 >= -0.015um
@ (2) Space (S) < 0.070um along length direction
@ (3) W < 0.046um
@ DRC waive if S1 or S2 > 0.04um
 end_enc = M3_end_0.046 NOT TOUCH EDGE (ENC V3 [M3_end_0.046] < 0.032 ABUT<90 OPPOSITE)
 end_sps = end_enc TOUCH EDGE (EXT [end_enc] M3_convex_270_270_edges < 0.07 ABUT<90 OPPOSITE)
 end_epd = EXPAND EDGE end_sps OUTSIDE BY 0.016
 end_sid = LENGTH (end_epd NOT TOUCH EDGE M3) == 0.016
 end_wid = INT end_sid < 0.046 ABUT<90 OPPOSITE
 end_sds = EXT end_sid M3 < 0.04 ABUT<90 OPPOSITE
 err1 = DFM PROPERTY end_epd end_wid end_sds OVERLAP ABUT ALSO MULTI 
 [+= (count(end_wid) > 0 && count(end_sds) > 0) ? 1 : 0] > 0 [-= min(ew(end_wid)) + min(ew(end_sds))] < 0.072
 err1 NOT INSIDE SealR_NOT_BULK
}
 
M3_R_8 {
@ U-shape metal pitch (W+S1) or (W+S2) must be >= 0.072um, except M2 in INST region
@ When:
@ 1) Both PRL1 and PRL2 >= -0.015um
@ 2) Space (S) < 0.070um along length direction
@ 3) W < 0.046um
@ 4) Mxy interact Vy-1 and enclosure E < 0.05um. (Mxy is the metal above Vy-1)
@ DRC waive if S1 or S2 > 0.04um
 end_enc = M3_end_0.046 TOUCH EDGE (ENC V2 [M3_end_0.046] < 0.05 ABUT<90 OPPOSITE)
 end_sps = end_enc TOUCH EDGE (EXT [end_enc] M3_convex_270_270_edges < 0.07 ABUT<90 OPPOSITE)
 end_epd = EXPAND EDGE end_sps OUTSIDE BY 0.016
 end_sid = LENGTH (end_epd NOT TOUCH EDGE M3) == 0.016
 end_wid = INT end_sid < 0.046 ABUT<90 OPPOSITE
 end_sds = EXT end_sid M3 < 0.04 ABUT<90 OPPOSITE
 err1 = DFM PROPERTY end_epd end_wid end_sds OVERLAP ABUT ALSO MULTI 
 [+= (count(end_wid) > 0 && count(end_sds) > 0) ? 1 : 0] > 0 [-= min(ew(end_wid)) + min(ew(end_sds))] < 0.072
 err1 NOT INSIDE SealR_NOT_BULK
}
 
// Mxy_R_8: It is a must to use SMIC utility to insert dummy metal Don't change any dimension and variable in utility
Mxy_3_RSP_1_2a_2b_met = ENCLOSE RECTANGLE (M3 INTERACT (M3 WITH WIDTH > 0.07)) 0.071 0.271 ORTHOGONAL ONLY
Mxy_3_RSP_1_2a_2b_wid = INT (Mxy_3_RSP_1_2a_2b_met) <= 0.07 OPPOSITE EXCLUDE SHIELDED
Mxy_3_RSP_1_2a_2b_wan = LENGTH (M3_convex_270_90_edges COIN EDGE Mxy_3_RSP_1_2a_2b_met) < 0.09 - 0.032
Mxy_3_RSP_1_2a_2b_sps = Mxy_3_RSP_1_2a_2b_met COIN EDGE (EXT Mxy_3_RSP_1_2a_2b_met M3 < 0.09 OPPOSITE REGION EXCLUDE SHIELDED)
// 
Mxy_3_RSP_1_2a_2b_sps_sides_A = (Mxy_3_RSP_1_2a_2b_wid COIN EDGE Mxy_3_RSP_1_2a_2b_sps) NOT COIN EDGE (LENGTH (Mxy_3_RSP_1_2a_2b_wid NOT TOUCH EDGE 
(INT [Mxy_3_RSP_1_2a_2b_wid] Mxy_3_RSP_1_2a_2b_wan < 0.001 ABUT==90 INTERSECTING ONLY)) <= 0.27)
Mxy_3_RSP_1_2a_2b_sps_sides_B = (Mxy_3_RSP_1_2a_2b_wid COIN EDGE Mxy_3_RSP_1_2a_2b_sps) NOT COIN EDGE (LENGTH (Mxy_3_RSP_1_2a_2b_wid NOT TOUCH EDGE 
(EXT [Mxy_3_RSP_1_2a_2b_wid] Mxy_3_RSP_1_2a_2b_wan < 0.001 ABUT==90 INTERSECTING ONLY)) <= 0.27)
Mxy_3_RSP_1_2a_2b_sps_sides = Mxy_3_RSP_1_2a_2b_sps_sides_A OR EDGE Mxy_3_RSP_1_2a_2b_sps_sides_B
Mxy_3_RSP_1_2a_2b_sps_sides_PRL = Mxy_3_RSP_1_2a_2b_sps_sides COIN EDGE (PATH LENGTH (Mxy_3_RSP_1_2a_2b_wan OR EDGE Mxy_3_RSP_1_2a_2b_sps_sides) > 0.27)
// 
Mxy_3_RSP_1_2a_2b_S1_side = EXT M3 Mxy_3_RSP_1_2a_2b_sps_sides_PRL < 0.09 OPPOSITE EXCLUDE SHIELDED
Mxy_3_RSP_1_2a_2b_S1_area = EXT M3 Mxy_3_RSP_1_2a_2b_sps_sides_PRL < 0.09 OPPOSITE EXCLUDE SHIELDED REGION
Mxy_3_RSP_1_2a_2b_S1_rlen = Mxy_3_RSP_1_2a_2b_S1_area ENCLOSE RECTANGLE 0.001 0.271 ORTHOGONAL ONLY
Mxy_3_RSP_1_2a_2b_L1_side = M3 COIN EDGE ((DFM COPY Mxy_3_RSP_1_2a_2b_S1_side EDGE) COIN EDGE Mxy_3_RSP_1_2a_2b_S1_rlen)
Mxy_3_RSP_1_2a_2b_L1_side_jog_sum = Mxy_3_RSP_1_2a_2b_wan OR EDGE Mxy_3_RSP_1_2a_2b_L1_side
Mxy_3_RSP_1_2a_2b_L1_side_jog_sum_EXP = EXPAND EDGE Mxy_3_RSP_1_2a_2b_L1_side_jog_sum INSIDE BY 0.001 CORNER FILL
// 
Mxy_3_RSP_1_2a_2b_Q1 = EXPAND EDGE (Mxy_3_RSP_1_2a_2b_L1_side COIN EDGE Mxy_3_RSP_1_2a_2b_L1_side_jog_sum) INSIDE BY 0.001
Mxy_3_RSP_1_2a_2b_Q2 = Mxy_3_RSP_1_2a_2b_L1_side_jog_sum_EXP INTERACT (AREA Mxy_3_RSP_1_2a_2b_Q1 > 0.27 * 0.001)
Mxy_3_RSP_1_2a_2b_Q3 = Mxy_3_RSP_1_2a_2b_L1_side_jog_sum TOUCH EDGE (LENGTH (Mxy_3_RSP_1_2a_2b_Q1 INTERACT Mxy_3_RSP_1_2a_2b_Q2) > 0.001)
// 
Mxy_3_RSP_1_2a_2b_y1 = DFM COPY (EXT M3 Mxy_3_RSP_1_2a_2b_Q3 < 0.09 OPPOSITE EXCLUDE SHIELDED) EDGE
Mxy_3_RSP_1_2a_2b_y2 = DFM COPY (EXT M3 Mxy_3_RSP_1_2a_2b_Q3 < 0.09 OPPOSITE EXCLUDE SHIELDED) REGION
Mxy_3_RSP_1_2a_2b_y3 = Mxy_3_RSP_1_2a_2b_y1 TOUCH EDGE (INT M3 [Mxy_3_RSP_1_2a_2b_y1] <= 0.001 ABUT==90 INTERSECTING ONLY MEASURE ALL)
Mxy_3_RSP_1_2a_2b_y4 = EXT Mxy_3_RSP_1_2a_2b_y3 Mxy_3_RSP_1_2a_2b_y1 < 0.072 OPPOSITE PROJ <= 0.082 REGION
Mxy_3_RSP_1_2a_2b_y5 = EXT Mxy_3_RSP_1_2a_2b_y3 Mxy_3_RSP_1_2a_2b_y1 < 0.072 OPPOSITE PROJ <= 0.082
Mxy_3_RSP_1_2a_2b_y6 = RECTANGLE (DFM PROPERTY Mxy_3_RSP_1_2a_2b_y4 Mxy_3_RSP_1_2a_2b_y5 OVERLAP ABUT ALSO MULTI [-= EC(Mxy_3_RSP_1_2a_2b_y5)] <= 0.082)
// 
Mxy_3_RSP_1_2a_2b_y2_c = OR M3EMPTY9696 Mxy_3_RSP_1_2a_2b_y2
Mxy_3_RSP_1_2a_2b_y6_c = OR M3EMPTY9696 Mxy_3_RSP_1_2a_2b_y6
CONNECT Mxy_3_RSP_1_2a_2b_y2_c Mxy_3_RSP_1_2a_2b_y6_c
// 
Mxy_3_RSP_1_2a_2b_ERR1_CHK = EXT Mxy_3_RSP_1_2a_2b_y1 >= 0.072 < 0.09 OPPOSITE REGION EXCLUDE SHIELDED
Mxy_3_RSP_1_2a_2b_ERR1_TMP = EXT ((Mxy_3_RSP_1_2a_2b_y6_c NOT COIN EDGE M3) COIN EDGE Mxy_3_RSP_1_2a_2b_ERR1_CHK) < 0.298 CONNECTED REGION
Mxy_3_RSP_1_2a_2b_ERR1 = Mxy_3_RSP_1_2a_2b_ERR1_TMP OR (Mxy_3_RSP_1_2a_2b_y6 INTERACT (COPY Mxy_3_RSP_1_2a_2b_y6) >= 3 SINGULAR ALSO)
// 
Mxy_3_RSP_1_2a_2b_CA = EXT Mxy_3_RSP_1_2a_2b_y3 Mxy_3_RSP_1_2a_2b_y1 < 0.041 OPPOSITE REGION
Mxy_3_RSP_1_2a_2b_CA_side = Mxy_3_RSP_1_2a_2b_CA NOT COIN EDGE M3
Mxy_3_RSP_1_2a_2b_CA_area = INT Mxy_3_RSP_1_2a_2b_CA_side Mxy_3_RSP_1_2a_2b_CA <= 0.082 REGION
// 
Mxy_3_RSP_1_2a_2b_ERR2_CHK = Mxy_3_RSP_1_2a_2b_CA_side NOT TOUCH EDGE Mxy_3_RSP_1_2a_2b_CA_area
Mxy_3_RSP_1_2a_2b_ERR2_TMP = (NOT RECTANGLE Mxy_3_RSP_1_2a_2b_y2) OR ((RECTANGLE Mxy_3_RSP_1_2a_2b_y2) ENCLOSE RECTANGLE 0.001 0.269)
Mxy_3_RSP_1_2a_2b_ERR2 = (Mxy_3_RSP_1_2a_2b_CA WITH EDGE Mxy_3_RSP_1_2a_2b_ERR2_CHK) INSIDE Mxy_3_RSP_1_2a_2b_ERR2_TMP
// 
Mxy_3_RSP_1_2a_2b_CB = EXT Mxy_3_RSP_1_2a_2b_y3 Mxy_3_RSP_1_2a_2b_y1 < 0.032 OPPOSITE REGION
Mxy_3_RSP_1_2a_2b_CB_side = Mxy_3_RSP_1_2a_2b_CB NOT COIN EDGE M3
Mxy_3_RSP_1_2a_2b_CB_area = INT Mxy_3_RSP_1_2a_2b_CB_side <= 0.082 REGION
// 
Mxy_3_RSP_1_2a_2b_ERR3_CHK = Mxy_3_RSP_1_2a_2b_CB_side TOUCH EDGE Mxy_3_RSP_1_2a_2b_CB_area
Mxy_3_RSP_1_2a_2b_ERR3_TMP = (NOT RECTANGLE Mxy_3_RSP_1_2a_2b_y2) OR ((RECTANGLE Mxy_3_RSP_1_2a_2b_y2) ENCLOSE RECTANGLE 0.001 0.269)
Mxy_3_RSP_1_2a_2b_ERR3 = (Mxy_3_RSP_1_2a_2b_CB WITH EDGE Mxy_3_RSP_1_2a_2b_ERR3_CHK) INSIDE Mxy_3_RSP_1_2a_2b_ERR3_TMP
 
M3_RSP_1 {
@ Space between metal space segments with S2 < 0.072 and L2 <= 0.082um
@ Metal space segments definition:
@ 1) At least one metal line width > 0.07um (W1) and PRL > 0.27um (L1) in metal space < 0.09um (S1) region
@ 2) Metal space segments within metal space (S1) region and are generated by space cut line which is perpendicular with L1 direction formed by all vertex in metal space region (S1)
@ 3) Metal space segments at least abut one metal with width > 0.07um (W1)
@ 4) L2 is the width of metal space segments which is parallel with L1 direction
@ 5) S2 is the width of metal space segments which is perpendicular with L1 direction. >= 0.298um
 Mxy_3_RSP_1_2a_2b_ERR1 NOT INSIDE SealR_NOT_BULK
}
 
M3_RSP_2a {
@ Width (S2) of metal space segments with L2 > 0.082um (0.063 <= S < 0.072 is forbidden)
@ Metal space segments definition:
@ 1) At least one metal line width > 0.07um (W1) and PRL > 0.27um (L1) in metal space < 0.09um (S1) region
@ 2) Metal space segments within metal space (S1) region and are generated by space cut line which is perpendicular with L1 direction formed by all vertex in metal space region (S1)
@ 3) Metal space segments at least abut one metal with width > 0.07um (W1)
@ 4) L2 is the width of metal space segments which is parallel with L1 direction
@ 5) S2 is the width of metal space segments which is perpendicular with L1 direction. >= 0.041um
 Mxy_3_RSP_1_2a_2b_ERR2 NOT INSIDE SealR_NOT_BULK
 // 
 forbidden_RSP_1_2a_2b_A1 = EXT Mxy_3_RSP_1_2a_2b_Y3 Mxy_3_RSP_1_2a_2b_Y1 >= 0.063 < 0.072 OPPOSITE REGION
 forbidden_RSP_1_2a_2b_A1_edge = forbidden_RSP_1_2a_2b_A1 NOT COIN EDGE M3
 forbidden_RSP_1_2a_2b_A1_area = INT forbidden_RSP_1_2a_2b_A1_edge forbidden_RSP_1_2a_2b_A1 <= 0.082 REGION
 forbidden_RSP_1_2a_2b_A1_1 = forbidden_RSP_1_2a_2b_A1_edge NOT TOUCH EDGE forbidden_RSP_1_2a_2b_A1_area
 forbidden_RSP_1_2a_2b_ERR2 = (NOT RECTANGLE Mxy_3_RSP_1_2a_2b_Y2) OR ((RECTANGLE Mxy_3_RSP_1_2a_2b_Y2) ENCLOSE RECTANGLE 0.001 0.269)
 err2 = (forbidden_RSP_1_2a_2b_A1 WITH EDGE forbidden_RSP_1_2a_2b_A1_1) INSIDE forbidden_RSP_1_2a_2b_ERR2
 err2 NOT INSIDE SealR_NOT_BULK
}
 
M3_RSP_2b {
@ Width (S2) of metal space segments with L2 <= 0.082um
@ Metal space segments definition:
@ 1) At least one metal line width > 0.07um (W1) and PRL > 0.27um (L1) in metal space < 0.090um (S1) region
@ 2) Metal space segments within metal space (S1) region and are generated by space cut line which is perpendicular with L1 direction formed by all vertex in metal space region (S1)
@ 3) Metal space segments at least abut one metal with width > 0.07um (W1)
@ 4) L2 is the width of metal space segments which is parallel with L1 direction
@ 5) S2 is the width of metal space segments which is perpendicular with L1 direction. >= 0.032um
 Mxy_3_RSP_1_2a_2b_ERR3 NOT INSIDE SealR_NOT_BULK
}
 
Mxy_3_RSP_3_4a_4b_met = ENCLOSE RECTANGLE (M3 INTERACT (M3 WITH WIDTH > 0.088)) 0.089 0.271 ORTHOGONAL ONLY
Mxy_3_RSP_3_4a_4b_wid = INT (Mxy_3_RSP_3_4a_4b_met) <= 0.088 OPPOSITE EXCLUDE SHIELDED
Mxy_3_RSP_3_4a_4b_wan = LENGTH (M3_convex_270_90_edges COIN EDGE Mxy_3_RSP_3_4a_4b_met) < 0.108 - 0.032
Mxy_3_RSP_3_4a_4b_sps = Mxy_3_RSP_3_4a_4b_met COIN EDGE (EXT Mxy_3_RSP_3_4a_4b_met M3 < 0.108 OPPOSITE REGION EXCLUDE SHIELDED)
// 
Mxy_3_RSP_3_4a_4b_sps_sides_A = (Mxy_3_RSP_3_4a_4b_wid COIN EDGE Mxy_3_RSP_3_4a_4b_sps) NOT COIN EDGE (LENGTH (Mxy_3_RSP_3_4a_4b_wid NOT TOUCH EDGE 
(INT [Mxy_3_RSP_3_4a_4b_wid] Mxy_3_RSP_3_4a_4b_wan < 0.001 ABUT==90 INTERSECTING ONLY)) <= 0.27)
Mxy_3_RSP_3_4a_4b_sps_sides_B = (Mxy_3_RSP_3_4a_4b_wid COIN EDGE Mxy_3_RSP_3_4a_4b_sps) NOT COIN EDGE (LENGTH (Mxy_3_RSP_3_4a_4b_wid NOT TOUCH EDGE 
(EXT [Mxy_3_RSP_3_4a_4b_wid] Mxy_3_RSP_3_4a_4b_wan < 0.001 ABUT==90 INTERSECTING ONLY)) <= 0.27)
Mxy_3_RSP_3_4a_4b_sps_sides = Mxy_3_RSP_3_4a_4b_sps_sides_A OR EDGE Mxy_3_RSP_3_4a_4b_sps_sides_B
Mxy_3_RSP_3_4a_4b_sps_sides_PRL = Mxy_3_RSP_3_4a_4b_sps_sides COIN EDGE (PATH LENGTH (Mxy_3_RSP_3_4a_4b_wan OR EDGE Mxy_3_RSP_3_4a_4b_sps_sides) > 0.27)
// 
Mxy_3_RSP_3_4a_4b_S1_side = EXT M3 Mxy_3_RSP_3_4a_4b_sps_sides_PRL < 0.108 OPPOSITE EXCLUDE SHIELDED
Mxy_3_RSP_3_4a_4b_S1_area = EXT M3 Mxy_3_RSP_3_4a_4b_sps_sides_PRL < 0.108 OPPOSITE EXCLUDE SHIELDED REGION
Mxy_3_RSP_3_4a_4b_S1_rlen = Mxy_3_RSP_3_4a_4b_S1_area ENCLOSE RECTANGLE 0.001 0.271 ORTHOGONAL ONLY
Mxy_3_RSP_3_4a_4b_L1_side = M3 COIN EDGE ((DFM COPY Mxy_3_RSP_3_4a_4b_S1_side EDGE) COIN EDGE Mxy_3_RSP_3_4a_4b_S1_rlen)
Mxy_3_RSP_3_4a_4b_L1_side_jog_sum = Mxy_3_RSP_3_4a_4b_wan OR EDGE Mxy_3_RSP_3_4a_4b_L1_side
Mxy_3_RSP_3_4a_4b_L1_side_jog_sum_EXP = EXPAND EDGE Mxy_3_RSP_3_4a_4b_L1_side_jog_sum INSIDE BY 0.001 CORNER FILL
// 
Mxy_3_RSP_3_4a_4b_Q1 = EXPAND EDGE (Mxy_3_RSP_3_4a_4b_L1_side COIN EDGE Mxy_3_RSP_3_4a_4b_L1_side_jog_sum) INSIDE BY 0.001
Mxy_3_RSP_3_4a_4b_Q2 = Mxy_3_RSP_3_4a_4b_L1_side_jog_sum_EXP INTERACT (AREA Mxy_3_RSP_3_4a_4b_Q1 > 0.27 * 0.001)
Mxy_3_RSP_3_4a_4b_Q3 = Mxy_3_RSP_3_4a_4b_L1_side_jog_sum TOUCH EDGE (LENGTH (Mxy_3_RSP_3_4a_4b_Q1 INTERACT Mxy_3_RSP_3_4a_4b_Q2) > 0.001)
// 
Mxy_3_RSP_3_4a_4b_y1 = DFM COPY (EXT M3 Mxy_3_RSP_3_4a_4b_Q3 < 0.108 OPPOSITE EXCLUDE SHIELDED) EDGE
Mxy_3_RSP_3_4a_4b_y2 = DFM COPY (EXT M3 Mxy_3_RSP_3_4a_4b_Q3 < 0.108 OPPOSITE EXCLUDE SHIELDED) REGION
Mxy_3_RSP_3_4a_4b_y3 = Mxy_3_RSP_3_4a_4b_y1 TOUCH EDGE (INT M3 [Mxy_3_RSP_3_4a_4b_y1] <= 0.001 ABUT==90 INTERSECTING ONLY MEASURE ALL)
Mxy_3_RSP_3_4a_4b_y4 = EXT Mxy_3_RSP_3_4a_4b_y3 Mxy_3_RSP_3_4a_4b_y1 < 0.081 OPPOSITE PROJ <= 0.082 REGION
Mxy_3_RSP_3_4a_4b_y5 = EXT Mxy_3_RSP_3_4a_4b_y3 Mxy_3_RSP_3_4a_4b_y1 < 0.081 OPPOSITE PROJ <= 0.082
Mxy_3_RSP_3_4a_4b_y6 = RECTANGLE (DFM PROPERTY Mxy_3_RSP_3_4a_4b_y4 Mxy_3_RSP_3_4a_4b_y5 OVERLAP ABUT ALSO MULTI [-= EC(Mxy_3_RSP_3_4a_4b_y5)] <= 0.082)
// 
Mxy_3_RSP_3_4a_4b_y2_c = OR M3EMPTY9696 Mxy_3_RSP_3_4a_4b_y2
Mxy_3_RSP_3_4a_4b_y6_c = OR M3EMPTY9696 Mxy_3_RSP_3_4a_4b_y6
CONNECT Mxy_3_RSP_3_4a_4b_y2_c Mxy_3_RSP_3_4a_4b_y6_c
// 
Mxy_3_RSP_3_4a_4b_ERR1_CHK = EXT Mxy_3_RSP_3_4a_4b_y1 >= 0.081 < 0.108 OPPOSITE REGION EXCLUDE SHIELDED
Mxy_3_RSP_3_4a_4b_ERR1_TMP = EXT ((Mxy_3_RSP_3_4a_4b_y6_c NOT COIN EDGE M3) COIN EDGE Mxy_3_RSP_3_4a_4b_ERR1_CHK) < 0.298 CONNECTED REGION
Mxy_3_RSP_3_4a_4b_ERR1 = Mxy_3_RSP_3_4a_4b_ERR1_TMP OR (Mxy_3_RSP_3_4a_4b_y6 INTERACT (COPY Mxy_3_RSP_3_4a_4b_y6) >= 3 SINGULAR ALSO)
// 
Mxy_3_RSP_3_4a_4b_CA = EXT Mxy_3_RSP_3_4a_4b_y3 Mxy_3_RSP_3_4a_4b_y1 < 0.041 OPPOSITE REGION
Mxy_3_RSP_3_4a_4b_CA_side = Mxy_3_RSP_3_4a_4b_CA NOT COIN EDGE M3
Mxy_3_RSP_3_4a_4b_CA_area = INT Mxy_3_RSP_3_4a_4b_CA_side Mxy_3_RSP_3_4a_4b_CA <= 0.082 REGION
// 
Mxy_3_RSP_3_4a_4b_ERR2_CHK = Mxy_3_RSP_3_4a_4b_CA_side NOT TOUCH EDGE Mxy_3_RSP_3_4a_4b_CA_area
Mxy_3_RSP_3_4a_4b_ERR2_TMP = (NOT RECTANGLE Mxy_3_RSP_3_4a_4b_y2) OR ((RECTANGLE Mxy_3_RSP_3_4a_4b_y2) ENCLOSE RECTANGLE 0.001 0.269)
Mxy_3_RSP_3_4a_4b_ERR2 = (Mxy_3_RSP_3_4a_4b_CA WITH EDGE Mxy_3_RSP_3_4a_4b_ERR2_CHK) INSIDE Mxy_3_RSP_3_4a_4b_ERR2_TMP
// 
Mxy_3_RSP_3_4a_4b_CB = EXT Mxy_3_RSP_3_4a_4b_y3 Mxy_3_RSP_3_4a_4b_y1 < 0.041 OPPOSITE REGION
Mxy_3_RSP_3_4a_4b_CB_side = Mxy_3_RSP_3_4a_4b_CB NOT COIN EDGE M3
Mxy_3_RSP_3_4a_4b_CB_area = INT Mxy_3_RSP_3_4a_4b_CB_side <= 0.082 REGION
// 
Mxy_3_RSP_3_4a_4b_ERR3_CHK = Mxy_3_RSP_3_4a_4b_CB_side TOUCH EDGE Mxy_3_RSP_3_4a_4b_CB_area
Mxy_3_RSP_3_4a_4b_ERR3_TMP = (NOT RECTANGLE Mxy_3_RSP_3_4a_4b_y2) OR ((RECTANGLE Mxy_3_RSP_3_4a_4b_y2) ENCLOSE RECTANGLE 0.001 0.269)
Mxy_3_RSP_3_4a_4b_ERR3 = (Mxy_3_RSP_3_4a_4b_CB WITH EDGE Mxy_3_RSP_3_4a_4b_ERR3_CHK) INSIDE Mxy_3_RSP_3_4a_4b_ERR3_TMP
 
M3_RSP_3 {
@ Space between metal space segments with S2 < 0.081 and L2 <= 0.082um
@ Metal space segments definition:
@ 1) At least one metal line width > 0.088um (W1) and PRL > 0.27um (L1) in metal space < 0.108um (S1) region
@ 2) Metal space segments within metal space (S1) region and are generated by space cut line which is perpendicular with L1 direction formed by all vertex in metal space region (S1)
@ 3) Metal space segments at least abut one metal with width > 0.088um (W1)
@ 4) L2 is the width of metal space segments which is parallel with L1 direction
@ 5) S2 is the width of metal space segments which is perpendicular with L1 direction. >= 0.298um
 Mxy_3_RSP_3_4a_4b_ERR1 NOT INSIDE SealR_NOT_BULK
}
 
M3_RSP_4a {
@ Width (S2) of metal space segments with L2 > 0.082um (0.063um <= S < 0.081um is forbidden)
@ Metal space segments definition:
@ 1) At least one metal line width > 0.088um (W1) and PRL > 0.27um (L1) in metal space < 0.108um (S1) region
@ 2) Metal space segments within metal space (S1) region and are generated by space cut line which is perpendicular with L1 direction formed by all vertex in metal space region (S1)
@ 3) Metal space segments at least abut one metal with width > 0.088um (W1)
@ 4) L2 is the width of metal space segments which is parallel with L1 direction
@ 5) S2 is the width of metal space segments which is perpendicular with L1 direction. >= 0.041um
 Mxy_3_RSP_3_4a_4b_ERR2 NOT INSIDE SealR_NOT_BULK
 // 
 forbidden_RSP_3_4a_4b_A1 = EXT Mxy_3_RSP_3_4a_4b_Y3 Mxy_3_RSP_3_4a_4b_Y1 >= 0.063 < 0.081 OPPOSITE REGION
 forbidden_RSP_3_4a_4b_A1_edge = forbidden_RSP_3_4a_4b_A1 NOT COIN EDGE M3
 forbidden_RSP_3_4a_4b_A1_area = INT forbidden_RSP_3_4a_4b_A1_edge forbidden_RSP_3_4a_4b_A1 <= 0.082 REGION
 forbidden_RSP_3_4a_4b_A1_1 = forbidden_RSP_3_4a_4b_A1_edge NOT TOUCH EDGE forbidden_RSP_3_4a_4b_A1_area
 forbidden_RSP_3_4a_4b_ERR2 = (NOT RECTANGLE Mxy_3_RSP_3_4a_4b_Y2) OR ((RECTANGLE Mxy_3_RSP_3_4a_4b_Y2) ENCLOSE RECTANGLE 0.001 0.269)
 err2 = (forbidden_RSP_3_4a_4b_A1 WITH EDGE forbidden_RSP_3_4a_4b_A1_1) INSIDE forbidden_RSP_3_4a_4b_ERR2
 err2 NOT INSIDE SealR_NOT_BULK
}
 
M3_RSP_4b {
@ Width (S2) of metal space segments with L2 <= 0.082um (0.063um <= S < 0.072um is forbidden)
@ Metal space segments definition:
@ 1) At least one metal line width > 0.088um (W1) and PRL > 0.270um (L1) in metal space < 0.108um (S1) region
@ 2) Metal space segments within metal space (S1) region and are generated by space cut line which is perpendicular with L1 direction formed by all vertex in metal space region (S1)
@ 3) Metal space segments at least abut one metal with width > 0.088um (W1)
@ 4) L2 is the width of metal space segments which is parallel with L1 direction
@ 5) S2 is the width of metal space segments which is perpendicular with L1 direction. >= 0.041um
 Mxy_3_RSP_3_4a_4b_ERR3 NOT INSIDE SealR_NOT_BULK
 // 
 forbidden_RSP_3_4a_4b_A2 = EXT Mxy_3_RSP_3_4a_4b_Y3 Mxy_3_RSP_3_4a_4b_Y1 >= 0.063 < 0.072 OPPOSITE REGION
 forbidden_RSP_3_4a_4b_A2_edge = forbidden_RSP_3_4a_4b_A2 NOT COIN EDGE M3
 forbidden_RSP_3_4a_4b_A2_area = INT forbidden_RSP_3_4a_4b_A2_edge <= 0.082 REGION
 forbidden_RSP_3_4a_4b_A2_2 = forbidden_RSP_3_4a_4b_A2_edge TOUCH EDGE forbidden_RSP_3_4a_4b_A2_area
 forbidden_RSP_3_4a_4b_ERR3 = (NOT RECTANGLE Mxy_3_RSP_3_4a_4b_Y2) OR ((RECTANGLE Mxy_3_RSP_3_4a_4b_Y2) ENCLOSE RECTANGLE 0.001 0.269)
 err2 = (forbidden_RSP_3_4a_4b_A2 WITH EDGE forbidden_RSP_3_4a_4b_A2_2) INSIDE forbidden_RSP_3_4a_4b_ERR3
 err2 NOT INSIDE SealR_NOT_BULK
}
 
Mxy_3_RSP_5_6a_6b_met = ENCLOSE RECTANGLE (M3 INTERACT (M3 WITH WIDTH > 0.112)) 0.113 0.271 ORTHOGONAL ONLY
Mxy_3_RSP_5_6a_6b_wid = INT (Mxy_3_RSP_5_6a_6b_met) <= 0.112 OPPOSITE EXCLUDE SHIELDED
Mxy_3_RSP_5_6a_6b_wan = LENGTH (M3_convex_270_90_edges COIN EDGE Mxy_3_RSP_5_6a_6b_met) < 0.126 - 0.032
Mxy_3_RSP_5_6a_6b_sps = Mxy_3_RSP_5_6a_6b_met COIN EDGE (EXT Mxy_3_RSP_5_6a_6b_met M3 < 0.126 OPPOSITE REGION EXCLUDE SHIELDED)
// 
Mxy_3_RSP_5_6a_6b_sps_sides_A = (Mxy_3_RSP_5_6a_6b_wid COIN EDGE Mxy_3_RSP_5_6a_6b_sps) NOT COIN EDGE (LENGTH (Mxy_3_RSP_5_6a_6b_wid NOT TOUCH EDGE 
(INT [Mxy_3_RSP_5_6a_6b_wid] Mxy_3_RSP_5_6a_6b_wan < 0.001 ABUT==90 INTERSECTING ONLY)) <= 0.27)
Mxy_3_RSP_5_6a_6b_sps_sides_B = (Mxy_3_RSP_5_6a_6b_wid COIN EDGE Mxy_3_RSP_5_6a_6b_sps) NOT COIN EDGE (LENGTH (Mxy_3_RSP_5_6a_6b_wid NOT TOUCH EDGE 
(EXT [Mxy_3_RSP_5_6a_6b_wid] Mxy_3_RSP_5_6a_6b_wan < 0.001 ABUT==90 INTERSECTING ONLY)) <= 0.27)
Mxy_3_RSP_5_6a_6b_sps_sides = Mxy_3_RSP_5_6a_6b_sps_sides_A OR EDGE Mxy_3_RSP_5_6a_6b_sps_sides_B
Mxy_3_RSP_5_6a_6b_sps_sides_PRL = Mxy_3_RSP_5_6a_6b_sps_sides COIN EDGE (PATH LENGTH (Mxy_3_RSP_5_6a_6b_wan OR EDGE Mxy_3_RSP_5_6a_6b_sps_sides) > 0.27)
// 
Mxy_3_RSP_5_6a_6b_S1_side = EXT M3 Mxy_3_RSP_5_6a_6b_sps_sides_PRL < 0.126 OPPOSITE EXCLUDE SHIELDED
Mxy_3_RSP_5_6a_6b_S1_area = EXT M3 Mxy_3_RSP_5_6a_6b_sps_sides_PRL < 0.126 OPPOSITE EXCLUDE SHIELDED REGION
Mxy_3_RSP_5_6a_6b_S1_rlen = Mxy_3_RSP_5_6a_6b_S1_area ENCLOSE RECTANGLE 0.001 0.271 ORTHOGONAL ONLY
Mxy_3_RSP_5_6a_6b_L1_side = M3 COIN EDGE ((DFM COPY Mxy_3_RSP_5_6a_6b_S1_side EDGE) COIN EDGE Mxy_3_RSP_5_6a_6b_S1_rlen)
Mxy_3_RSP_5_6a_6b_L1_side_jog_sum = Mxy_3_RSP_5_6a_6b_wan OR EDGE Mxy_3_RSP_5_6a_6b_L1_side
Mxy_3_RSP_5_6a_6b_L1_side_jog_sum_EXP = EXPAND EDGE Mxy_3_RSP_5_6a_6b_L1_side_jog_sum INSIDE BY 0.001 CORNER FILL
// 
Mxy_3_RSP_5_6a_6b_Q1 = EXPAND EDGE (Mxy_3_RSP_5_6a_6b_L1_side COIN EDGE Mxy_3_RSP_5_6a_6b_L1_side_jog_sum) INSIDE BY 0.001
Mxy_3_RSP_5_6a_6b_Q2 = Mxy_3_RSP_5_6a_6b_L1_side_jog_sum_EXP INTERACT (AREA Mxy_3_RSP_5_6a_6b_Q1 > 0.27 * 0.001)
Mxy_3_RSP_5_6a_6b_Q3 = Mxy_3_RSP_5_6a_6b_L1_side_jog_sum TOUCH EDGE (LENGTH (Mxy_3_RSP_5_6a_6b_Q1 INTERACT Mxy_3_RSP_5_6a_6b_Q2) > 0.001)
// 
Mxy_3_RSP_5_6a_6b_y1 = DFM COPY (EXT M3 Mxy_3_RSP_5_6a_6b_Q3 < 0.126 OPPOSITE EXCLUDE SHIELDED) EDGE
Mxy_3_RSP_5_6a_6b_y2 = DFM COPY (EXT M3 Mxy_3_RSP_5_6a_6b_Q3 < 0.126 OPPOSITE EXCLUDE SHIELDED) REGION
Mxy_3_RSP_5_6a_6b_y3 = Mxy_3_RSP_5_6a_6b_y1 TOUCH EDGE (INT M3 [Mxy_3_RSP_5_6a_6b_y1] <= 0.001 ABUT==90 INTERSECTING ONLY MEASURE ALL)
Mxy_3_RSP_5_6a_6b_y4 = EXT Mxy_3_RSP_5_6a_6b_y3 Mxy_3_RSP_5_6a_6b_y1 < 0.106 OPPOSITE PROJ <= 0.082 REGION
Mxy_3_RSP_5_6a_6b_y5 = EXT Mxy_3_RSP_5_6a_6b_y3 Mxy_3_RSP_5_6a_6b_y1 < 0.106 OPPOSITE PROJ <= 0.082
Mxy_3_RSP_5_6a_6b_y6 = RECTANGLE (DFM PROPERTY Mxy_3_RSP_5_6a_6b_y4 Mxy_3_RSP_5_6a_6b_y5 OVERLAP ABUT ALSO MULTI [-= EC(Mxy_3_RSP_5_6a_6b_y5)] <= 0.082)
// 
Mxy_3_RSP_5_6a_6b_y2_c = OR M3EMPTY9696 Mxy_3_RSP_5_6a_6b_y2
Mxy_3_RSP_5_6a_6b_y6_c = OR M3EMPTY9696 Mxy_3_RSP_5_6a_6b_y6
CONNECT Mxy_3_RSP_5_6a_6b_y2_c Mxy_3_RSP_5_6a_6b_y6_c
// 
Mxy_3_RSP_5_6a_6b_ERR1_CHK = EXT Mxy_3_RSP_5_6a_6b_y1 >= 0.106 < 0.126 OPPOSITE REGION EXCLUDE SHIELDED
Mxy_3_RSP_5_6a_6b_ERR1_TMP = EXT ((Mxy_3_RSP_5_6a_6b_y6_c NOT COIN EDGE M3) COIN EDGE Mxy_3_RSP_5_6a_6b_ERR1_CHK) < 0.298 CONNECTED REGION
Mxy_3_RSP_5_6a_6b_ERR1 = Mxy_3_RSP_5_6a_6b_ERR1_TMP OR (Mxy_3_RSP_5_6a_6b_y6 INTERACT (COPY Mxy_3_RSP_5_6a_6b_y6) >= 3 SINGULAR ALSO)
// 
Mxy_3_RSP_5_6a_6b_CA = EXT Mxy_3_RSP_5_6a_6b_y3 Mxy_3_RSP_5_6a_6b_y1 < 0.041 OPPOSITE REGION
Mxy_3_RSP_5_6a_6b_CA_side = Mxy_3_RSP_5_6a_6b_CA NOT COIN EDGE M3
Mxy_3_RSP_5_6a_6b_CA_area = INT Mxy_3_RSP_5_6a_6b_CA_side Mxy_3_RSP_5_6a_6b_CA <= 0.082 REGION
// 
Mxy_3_RSP_5_6a_6b_ERR2_CHK = Mxy_3_RSP_5_6a_6b_CA_side NOT TOUCH EDGE Mxy_3_RSP_5_6a_6b_CA_area
Mxy_3_RSP_5_6a_6b_ERR2_TMP = (NOT RECTANGLE Mxy_3_RSP_5_6a_6b_y2) OR ((RECTANGLE Mxy_3_RSP_5_6a_6b_y2) ENCLOSE RECTANGLE 0.001 0.269)
Mxy_3_RSP_5_6a_6b_ERR2 = (Mxy_3_RSP_5_6a_6b_CA WITH EDGE Mxy_3_RSP_5_6a_6b_ERR2_CHK) INSIDE Mxy_3_RSP_5_6a_6b_ERR2_TMP
// 
Mxy_3_RSP_5_6a_6b_CB = EXT Mxy_3_RSP_5_6a_6b_y3 Mxy_3_RSP_5_6a_6b_y1 < 0.041 OPPOSITE REGION
Mxy_3_RSP_5_6a_6b_CB_side = Mxy_3_RSP_5_6a_6b_CB NOT COIN EDGE M3
Mxy_3_RSP_5_6a_6b_CB_area = INT Mxy_3_RSP_5_6a_6b_CB_side <= 0.082 REGION
// 
Mxy_3_RSP_5_6a_6b_ERR3_CHK = Mxy_3_RSP_5_6a_6b_CB_side TOUCH EDGE Mxy_3_RSP_5_6a_6b_CB_area
Mxy_3_RSP_5_6a_6b_ERR3_TMP = (NOT RECTANGLE Mxy_3_RSP_5_6a_6b_y2) OR ((RECTANGLE Mxy_3_RSP_5_6a_6b_y2) ENCLOSE RECTANGLE 0.001 0.269)
Mxy_3_RSP_5_6a_6b_ERR3 = (Mxy_3_RSP_5_6a_6b_CB WITH EDGE Mxy_3_RSP_5_6a_6b_ERR3_CHK) INSIDE Mxy_3_RSP_5_6a_6b_ERR3_TMP
 
M3_RSP_5 {
@ Space between metal space segments with S2 < 0.106um and L2 <= 0.082um
@ Metal space segments definition:
@ 1) At least one metal line width > 0.112um (W1) and PRL > 0.270um (L1) in metal space < 0.126um (S1) region
@ 2) Metal space segments within metal space (S1) region and are generated by space cut line which is perpendicular with L1 direction formed by all vertex in metal space region (S1)
@ 3) Metal space segments at least abut one metal with width > 0.112um (W1)
@ 4) L2 is the width of metal space segments which is parallel with L1 direction
@ 5) S2 is the width of metal space segments which is perpendicular with L1 direction. >= 0.298um
 Mxy_3_RSP_5_6a_6b_ERR1 NOT INSIDE SealR_NOT_BULK
}
 
M3_RSP_6a {
@ Width (S2) of metal space segments with L2 > 0.082um (0.063um <= S < 0.106um is forbidden)
@ Metal space segments definition:
@ 1) At least one metal line width > 0.112um (W1) and PRL > 0.27um (L1) in metal space < 0.126um (S1) region
@ 2) Metal space segments within metal space (S1) region and are generated by space cut line which is perpendicular with L1 direction formed by all vertex in metal space region (S1)
@ 3) Metal space segments at least abut one metal with width > 0.112um (W1)
@ 4) L2 is the width of metal space segments which is parallel with L1 direction
@ 5) S2 is the width of metal space segments which is perpendicular with L1 direction. >= 0.041um
 Mxy_3_RSP_5_6a_6b_ERR2 NOT INSIDE SealR_NOT_BULK
 // 
 forbidden_RSP_5_6a_6b_A1 = EXT Mxy_3_RSP_5_6a_6b_Y3 Mxy_3_RSP_5_6a_6b_Y1 >= 0.063 < 0.106 OPPOSITE REGION
 forbidden_RSP_5_6a_6b_A1_edge = forbidden_RSP_5_6a_6b_A1 NOT COIN EDGE M3
 forbidden_RSP_5_6a_6b_A1_area = INT forbidden_RSP_5_6a_6b_A1_edge forbidden_RSP_5_6a_6b_A1 <= 0.082 REGION
 forbidden_RSP_5_6a_6b_A1_1 = forbidden_RSP_5_6a_6b_A1_edge NOT TOUCH EDGE forbidden_RSP_5_6a_6b_A1_area
 forbidden_RSP_5_6a_6b_ERR2 = (NOT RECTANGLE Mxy_3_RSP_5_6a_6b_Y2) OR ((RECTANGLE Mxy_3_RSP_5_6a_6b_Y2) ENCLOSE RECTANGLE 0.001 0.269)
 err2 = (forbidden_RSP_5_6a_6b_A1 WITH EDGE forbidden_RSP_5_6a_6b_A1_1) INSIDE forbidden_RSP_5_6a_6b_ERR2
 err2 NOT INSIDE SealR_NOT_BULK
}
 
M3_RSP_6b {
@ Width (S2) of metal space segments with L2 <= 0.082um (0.063um <= S < 0.081um is forbidden)
@ Metal space segments definition:
@ 1) At least one metal line width > 0.112um (W1) and PRL > 0.27um (L1) in metal space < 0.126um (S1) region
@ 2) Metal space segments within metal space (S1) region and are generated by space cut line which is perpendicular with L1 direction formed by all vertex in metal space region (S1)
@ 3) Metal space segments at least abut one metal with width > 0.112um (W1)
@ 4) L2 is the width of metal space segments which is parallel with L1 direction
@ 5) S2 is the width of metal space segments which is perpendicular with L1 direction. >= 0.041um
 Mxy_3_RSP_5_6a_6b_ERR3 NOT INSIDE SealR_NOT_BULK
 // 
 forbidden_RSP_5_6a_6b_A2 = EXT Mxy_3_RSP_5_6a_6b_Y3 Mxy_3_RSP_5_6a_6b_Y1 >= 0.063 < 0.081 OPPOSITE REGION
 forbidden_RSP_5_6a_6b_A2_edge = forbidden_RSP_5_6a_6b_A2 NOT COIN EDGE M3
 forbidden_RSP_5_6a_6b_A2_area = INT forbidden_RSP_5_6a_6b_A2_edge <= 0.082 REGION
 forbidden_RSP_5_6a_6b_A2_2 = forbidden_RSP_5_6a_6b_A2_edge TOUCH EDGE forbidden_RSP_5_6a_6b_A2_area
 forbidden_RSP_5_6a_6b_ERR3 = (NOT RECTANGLE Mxy_3_RSP_5_6a_6b_Y2) OR ((RECTANGLE Mxy_3_RSP_5_6a_6b_Y2) ENCLOSE RECTANGLE 0.001 0.269)
 err2 = (forbidden_RSP_5_6a_6b_A2 WITH EDGE forbidden_RSP_5_6a_6b_A2_2) INSIDE forbidden_RSP_5_6a_6b_ERR3
 err2 NOT INSIDE SealR_NOT_BULK
}
 
Mxy_3_RSP_7_8a_8b_met = ENCLOSE RECTANGLE (M3 INTERACT (M3 WITH WIDTH > 0.180)) 0.181 0.271 ORTHOGONAL ONLY
Mxy_3_RSP_7_8a_8b_wid = INT (Mxy_3_RSP_7_8a_8b_met) <= 0.180 OPPOSITE EXCLUDE SHIELDED
Mxy_3_RSP_7_8a_8b_wan = LENGTH (M3_convex_270_90_edges COIN EDGE Mxy_3_RSP_7_8a_8b_met) < 0.144 - 0.032
Mxy_3_RSP_7_8a_8b_sps = Mxy_3_RSP_7_8a_8b_met COIN EDGE (EXT Mxy_3_RSP_7_8a_8b_met M3 < 0.144 OPPOSITE REGION EXCLUDE SHIELDED)
// 
Mxy_3_RSP_7_8a_8b_sps_sides_A = (Mxy_3_RSP_7_8a_8b_wid COIN EDGE Mxy_3_RSP_7_8a_8b_sps) NOT COIN EDGE (LENGTH (Mxy_3_RSP_7_8a_8b_wid NOT TOUCH EDGE 
(INT [Mxy_3_RSP_7_8a_8b_wid] Mxy_3_RSP_7_8a_8b_wan < 0.001 ABUT==90 INTERSECTING ONLY)) <= 0.27)
Mxy_3_RSP_7_8a_8b_sps_sides_B = (Mxy_3_RSP_7_8a_8b_wid COIN EDGE Mxy_3_RSP_7_8a_8b_sps) NOT COIN EDGE (LENGTH (Mxy_3_RSP_7_8a_8b_wid NOT TOUCH EDGE 
(EXT [Mxy_3_RSP_7_8a_8b_wid] Mxy_3_RSP_7_8a_8b_wan < 0.001 ABUT==90 INTERSECTING ONLY)) <= 0.27)
Mxy_3_RSP_7_8a_8b_sps_sides = Mxy_3_RSP_7_8a_8b_sps_sides_A OR EDGE Mxy_3_RSP_7_8a_8b_sps_sides_B
Mxy_3_RSP_7_8a_8b_sps_sides_PRL = Mxy_3_RSP_7_8a_8b_sps_sides COIN EDGE (PATH LENGTH (Mxy_3_RSP_7_8a_8b_wan OR EDGE Mxy_3_RSP_7_8a_8b_sps_sides) > 0.27)
// 
Mxy_3_RSP_7_8a_8b_S1_side = EXT M3 Mxy_3_RSP_7_8a_8b_sps_sides_PRL < 0.144 OPPOSITE EXCLUDE SHIELDED
Mxy_3_RSP_7_8a_8b_S1_area = EXT M3 Mxy_3_RSP_7_8a_8b_sps_sides_PRL < 0.144 OPPOSITE EXCLUDE SHIELDED REGION
Mxy_3_RSP_7_8a_8b_S1_rlen = Mxy_3_RSP_7_8a_8b_S1_area ENCLOSE RECTANGLE 0.001 0.271 ORTHOGONAL ONLY
Mxy_3_RSP_7_8a_8b_L1_side = M3 COIN EDGE ((DFM COPY Mxy_3_RSP_7_8a_8b_S1_side EDGE) COIN EDGE Mxy_3_RSP_7_8a_8b_S1_rlen)
Mxy_3_RSP_7_8a_8b_L1_side_jog_sum = Mxy_3_RSP_7_8a_8b_wan OR EDGE Mxy_3_RSP_7_8a_8b_L1_side
Mxy_3_RSP_7_8a_8b_L1_side_jog_sum_EXP = EXPAND EDGE Mxy_3_RSP_7_8a_8b_L1_side_jog_sum INSIDE BY 0.001 CORNER FILL
// 
Mxy_3_RSP_7_8a_8b_Q1 = EXPAND EDGE (Mxy_3_RSP_7_8a_8b_L1_side COIN EDGE Mxy_3_RSP_7_8a_8b_L1_side_jog_sum) INSIDE BY 0.001
Mxy_3_RSP_7_8a_8b_Q2 = Mxy_3_RSP_7_8a_8b_L1_side_jog_sum_EXP INTERACT (AREA Mxy_3_RSP_7_8a_8b_Q1 > 0.27 * 0.001)
Mxy_3_RSP_7_8a_8b_Q3 = Mxy_3_RSP_7_8a_8b_L1_side_jog_sum TOUCH EDGE (LENGTH (Mxy_3_RSP_7_8a_8b_Q1 INTERACT Mxy_3_RSP_7_8a_8b_Q2) > 0.001)
// 
Mxy_3_RSP_7_8a_8b_y1 = DFM COPY (EXT M3 Mxy_3_RSP_7_8a_8b_Q3 < 0.144 OPPOSITE EXCLUDE SHIELDED) EDGE
Mxy_3_RSP_7_8a_8b_y2 = DFM COPY (EXT M3 Mxy_3_RSP_7_8a_8b_Q3 < 0.144 OPPOSITE EXCLUDE SHIELDED) REGION
Mxy_3_RSP_7_8a_8b_y3 = Mxy_3_RSP_7_8a_8b_y1 TOUCH EDGE (INT M3 [Mxy_3_RSP_7_8a_8b_y1] <= 0.001 ABUT==90 INTERSECTING ONLY MEASURE ALL)
Mxy_3_RSP_7_8a_8b_y4 = EXT Mxy_3_RSP_7_8a_8b_y3 Mxy_3_RSP_7_8a_8b_y1 < 0.126 OPPOSITE PROJ <= 0.082 REGION
Mxy_3_RSP_7_8a_8b_y5 = EXT Mxy_3_RSP_7_8a_8b_y3 Mxy_3_RSP_7_8a_8b_y1 < 0.126 OPPOSITE PROJ <= 0.082
Mxy_3_RSP_7_8a_8b_y6 = RECTANGLE (DFM PROPERTY Mxy_3_RSP_7_8a_8b_y4 Mxy_3_RSP_7_8a_8b_y5 OVERLAP ABUT ALSO MULTI [-= EC(Mxy_3_RSP_7_8a_8b_y5)] <= 0.082)
// 
Mxy_3_RSP_7_8a_8b_y2_c = OR M3EMPTY9696 Mxy_3_RSP_7_8a_8b_y2
Mxy_3_RSP_7_8a_8b_y6_c = OR M3EMPTY9696 Mxy_3_RSP_7_8a_8b_y6
CONNECT Mxy_3_RSP_7_8a_8b_y2_c Mxy_3_RSP_7_8a_8b_y6_c
// 
Mxy_3_RSP_7_8a_8b_ERR1_CHK = EXT Mxy_3_RSP_7_8a_8b_y1 >= 0.126 < 0.144 OPPOSITE REGION EXCLUDE SHIELDED
Mxy_3_RSP_7_8a_8b_ERR1_TMP = EXT ((Mxy_3_RSP_7_8a_8b_y6_c NOT COIN EDGE M3) COIN EDGE Mxy_3_RSP_7_8a_8b_ERR1_CHK) < 0.298 CONNECTED REGION
Mxy_3_RSP_7_8a_8b_ERR1 = Mxy_3_RSP_7_8a_8b_ERR1_TMP OR (Mxy_3_RSP_7_8a_8b_y6 INTERACT (COPY Mxy_3_RSP_7_8a_8b_y6) >= 3 SINGULAR ALSO)
// 
Mxy_3_RSP_7_8a_8b_CA = EXT Mxy_3_RSP_7_8a_8b_y3 Mxy_3_RSP_7_8a_8b_y1 < 0.125 OPPOSITE REGION
Mxy_3_RSP_7_8a_8b_CA_side = Mxy_3_RSP_7_8a_8b_CA NOT COIN EDGE M3
Mxy_3_RSP_7_8a_8b_CA_area = INT Mxy_3_RSP_7_8a_8b_CA_side Mxy_3_RSP_7_8a_8b_CA <= 0.082 REGION
// 
Mxy_3_RSP_7_8a_8b_ERR2_CHK = Mxy_3_RSP_7_8a_8b_CA_side NOT TOUCH EDGE Mxy_3_RSP_7_8a_8b_CA_area
Mxy_3_RSP_7_8a_8b_ERR2_TMP = (NOT RECTANGLE Mxy_3_RSP_7_8a_8b_y2) OR ((RECTANGLE Mxy_3_RSP_7_8a_8b_y2) ENCLOSE RECTANGLE 0.001 0.269)
Mxy_3_RSP_7_8a_8b_ERR2 = (Mxy_3_RSP_7_8a_8b_CA WITH EDGE Mxy_3_RSP_7_8a_8b_ERR2_CHK) INSIDE Mxy_3_RSP_7_8a_8b_ERR2_TMP
// 
Mxy_3_RSP_7_8a_8b_CB = EXT Mxy_3_RSP_7_8a_8b_y3 Mxy_3_RSP_7_8a_8b_y1 < 0.107 OPPOSITE REGION
Mxy_3_RSP_7_8a_8b_CB_side = Mxy_3_RSP_7_8a_8b_CB NOT COIN EDGE M3
Mxy_3_RSP_7_8a_8b_CB_area = INT Mxy_3_RSP_7_8a_8b_CB_side <= 0.082 REGION
// 
Mxy_3_RSP_7_8a_8b_ERR3_CHK = Mxy_3_RSP_7_8a_8b_CB_side TOUCH EDGE Mxy_3_RSP_7_8a_8b_CB_area
Mxy_3_RSP_7_8a_8b_ERR3_TMP = (NOT RECTANGLE Mxy_3_RSP_7_8a_8b_y2) OR ((RECTANGLE Mxy_3_RSP_7_8a_8b_y2) ENCLOSE RECTANGLE 0.001 0.269)
Mxy_3_RSP_7_8a_8b_ERR3 = (Mxy_3_RSP_7_8a_8b_CB WITH EDGE Mxy_3_RSP_7_8a_8b_ERR3_CHK) INSIDE Mxy_3_RSP_7_8a_8b_ERR3_TMP
 
M3_RSP_7 {
@ Space between metal space segments with S2 < 0.126um and L2 <= 0.082um
@ Metal space segments definition:
@ 1) At least one metal line width > 0.180um (W1) and PRL > 0.27um (L1) in metal space < 0.144um (S1) region
@ 2) Metal space segments within metal space (S1) region and are generated by space cut line which is perpendicular with L1 direction formed by all vertex in metal space region (S1)
@ 3) Metal space segments at least abut one metal with width > 0.18um (W1)
@ 4) L2 is the width of metal space segments which is parallel with L1 direction
@ 5) S2 is the width of metal space segments which is perpendicular with L1 direction. >= 0.298um
 Mxy_3_RSP_7_8a_8b_ERR1 NOT INSIDE SealR_NOT_BULK
}
 
M3_RSP_8a {
@ Width (S2) of metal space segments with L2 > 0.082um
@ Metal space segments definition:
@ 1) At least one metal line width > 0.18um (W1) and PRL > 0.27um (L1) in metal space < 0.144um (S1) region
@ 2) Metal space segments within metal space (S1) region and are generated by space cut line which is perpendicular with L1 direction formed by all vertex in metal space region (S1)
@ 3) Metal space segments at least abut one metal with width > 0.18um (W1)
@ 4) L2 is the width of metal space segments which is parallel with L1 direction
@ 5) S2 is the width of metal space segments which is perpendicular with L1 direction. >= 0.125um
 Mxy_3_RSP_7_8a_8b_ERR2 NOT INSIDE SealR_NOT_BULK
}
 
M3_RSP_8b {
@ Width (S2) of metal space segments with L2 <= 0.082um
@ Metal space segments definition:
@ 1) At least one metal line width > 0.18um (W1) and PRL > 0.27um (L1) in metal space < 0.144um (S1) region
@ 2) Metal space segments within metal space (S1) region and are generated by space cut line which is perpendicular with L1 direction formed by all vertex in metal space region (S1)
@ 3) Metal space segments at least abut one metal with width > 0.18um (W1)
@ 4) L2 is the width of metal space segments which is parallel with L1 direction
@ 5) S2 is the width of metal space segments which is perpendicular with L1 direction. >= 0.107um
 Mxy_3_RSP_7_8a_8b_ERR3 NOT INSIDE SealR_NOT_BULK
}
 
Mxy_3_RSP_9_10a_10b_met = ENCLOSE RECTANGLE (M3 INTERACT (M3 WITH WIDTH > 0.270)) 0.271 0.271 ORTHOGONAL ONLY
Mxy_3_RSP_9_10a_10b_wid = INT (Mxy_3_RSP_9_10a_10b_met) <= 0.270 OPPOSITE EXCLUDE SHIELDED
Mxy_3_RSP_9_10a_10b_wan = LENGTH (M3_convex_270_90_edges COIN EDGE Mxy_3_RSP_9_10a_10b_met) < 0.261 - 0.032
Mxy_3_RSP_9_10a_10b_sps = Mxy_3_RSP_9_10a_10b_met COIN EDGE (EXT Mxy_3_RSP_9_10a_10b_met M3 < 0.261 OPPOSITE REGION EXCLUDE SHIELDED)
// 
Mxy_3_RSP_9_10a_10b_sps_sides_A = (Mxy_3_RSP_9_10a_10b_wid COIN EDGE Mxy_3_RSP_9_10a_10b_sps) NOT COIN EDGE (LENGTH (Mxy_3_RSP_9_10a_10b_wid NOT TOUCH EDGE 
(INT [Mxy_3_RSP_9_10a_10b_wid] Mxy_3_RSP_9_10a_10b_wan < 0.001 ABUT==90 INTERSECTING ONLY)) <= 0.27)
Mxy_3_RSP_9_10a_10b_sps_sides_B = (Mxy_3_RSP_9_10a_10b_wid COIN EDGE Mxy_3_RSP_9_10a_10b_sps) NOT COIN EDGE (LENGTH (Mxy_3_RSP_9_10a_10b_wid NOT TOUCH EDGE 
(EXT [Mxy_3_RSP_9_10a_10b_wid] Mxy_3_RSP_9_10a_10b_wan < 0.001 ABUT==90 INTERSECTING ONLY)) <= 0.27)
Mxy_3_RSP_9_10a_10b_sps_sides = Mxy_3_RSP_9_10a_10b_sps_sides_A OR EDGE Mxy_3_RSP_9_10a_10b_sps_sides_B
Mxy_3_RSP_9_10a_10b_sps_sides_PRL = Mxy_3_RSP_9_10a_10b_sps_sides COIN EDGE (PATH LENGTH (Mxy_3_RSP_9_10a_10b_wan OR EDGE Mxy_3_RSP_9_10a_10b_sps_sides) > 0.27)
// 
Mxy_3_RSP_9_10a_10b_S1_side = EXT M3 Mxy_3_RSP_9_10a_10b_sps_sides_PRL < 0.261 OPPOSITE EXCLUDE SHIELDED
Mxy_3_RSP_9_10a_10b_S1_area = EXT M3 Mxy_3_RSP_9_10a_10b_sps_sides_PRL < 0.261 OPPOSITE EXCLUDE SHIELDED REGION
Mxy_3_RSP_9_10a_10b_S1_rlen = Mxy_3_RSP_9_10a_10b_S1_area ENCLOSE RECTANGLE 0.001 0.271 ORTHOGONAL ONLY
Mxy_3_RSP_9_10a_10b_L1_side = M3 COIN EDGE ((DFM COPY Mxy_3_RSP_9_10a_10b_S1_side EDGE) COIN EDGE Mxy_3_RSP_9_10a_10b_S1_rlen)
Mxy_3_RSP_9_10a_10b_L1_side_jog_sum = Mxy_3_RSP_9_10a_10b_wan OR EDGE Mxy_3_RSP_9_10a_10b_L1_side
Mxy_3_RSP_9_10a_10b_L1_side_jog_sum_EXP = EXPAND EDGE Mxy_3_RSP_9_10a_10b_L1_side_jog_sum INSIDE BY 0.001 CORNER FILL
// 
Mxy_3_RSP_9_10a_10b_Q1 = EXPAND EDGE (Mxy_3_RSP_9_10a_10b_L1_side COIN EDGE Mxy_3_RSP_9_10a_10b_L1_side_jog_sum) INSIDE BY 0.001
Mxy_3_RSP_9_10a_10b_Q2 = Mxy_3_RSP_9_10a_10b_L1_side_jog_sum_EXP INTERACT (AREA Mxy_3_RSP_9_10a_10b_Q1 > 0.27 * 0.001)
Mxy_3_RSP_9_10a_10b_Q3 = Mxy_3_RSP_9_10a_10b_L1_side_jog_sum TOUCH EDGE (LENGTH (Mxy_3_RSP_9_10a_10b_Q1 INTERACT Mxy_3_RSP_9_10a_10b_Q2) > 0.001)
// 
Mxy_3_RSP_9_10a_10b_y1 = DFM COPY (EXT M3 Mxy_3_RSP_9_10a_10b_Q3 < 0.261 OPPOSITE EXCLUDE SHIELDED) EDGE
Mxy_3_RSP_9_10a_10b_y2 = DFM COPY (EXT M3 Mxy_3_RSP_9_10a_10b_Q3 < 0.261 OPPOSITE EXCLUDE SHIELDED) REGION
Mxy_3_RSP_9_10a_10b_y3 = Mxy_3_RSP_9_10a_10b_y1 TOUCH EDGE (INT M3 [Mxy_3_RSP_9_10a_10b_y1] <= 0.001 ABUT==90 INTERSECTING ONLY MEASURE ALL)
Mxy_3_RSP_9_10a_10b_y4 = EXT Mxy_3_RSP_9_10a_10b_y3 Mxy_3_RSP_9_10a_10b_y1 < 0.144 OPPOSITE PROJ <= 0.082 REGION
Mxy_3_RSP_9_10a_10b_y5 = EXT Mxy_3_RSP_9_10a_10b_y3 Mxy_3_RSP_9_10a_10b_y1 < 0.144 OPPOSITE PROJ <= 0.082
Mxy_3_RSP_9_10a_10b_y6 = RECTANGLE (DFM PROPERTY Mxy_3_RSP_9_10a_10b_y4 Mxy_3_RSP_9_10a_10b_y5 OVERLAP ABUT ALSO MULTI [-= EC(Mxy_3_RSP_9_10a_10b_y5)] <= 0.082)
// 
Mxy_3_RSP_9_10a_10b_y2_c = OR M3EMPTY9696 Mxy_3_RSP_9_10a_10b_y2
Mxy_3_RSP_9_10a_10b_y6_c = OR M3EMPTY9696 Mxy_3_RSP_9_10a_10b_y6
CONNECT Mxy_3_RSP_9_10a_10b_y2_c Mxy_3_RSP_9_10a_10b_y6_c
// 
Mxy_3_RSP_9_10a_10b_ERR1_CHK = EXT Mxy_3_RSP_9_10a_10b_y1 >= 0.144 < 0.261 OPPOSITE REGION EXCLUDE SHIELDED
Mxy_3_RSP_9_10a_10b_ERR1_TMP = EXT ((Mxy_3_RSP_9_10a_10b_y6_c NOT COIN EDGE M3) COIN EDGE Mxy_3_RSP_9_10a_10b_ERR1_CHK) < 0.298 CONNECTED REGION
Mxy_3_RSP_9_10a_10b_ERR1 = Mxy_3_RSP_9_10a_10b_ERR1_TMP OR (Mxy_3_RSP_9_10a_10b_y6 INTERACT (COPY Mxy_3_RSP_9_10a_10b_y6) >= 3 SINGULAR ALSO)
// 
Mxy_3_RSP_9_10a_10b_CA = EXT Mxy_3_RSP_9_10a_10b_y3 Mxy_3_RSP_9_10a_10b_y1 < 0.142 OPPOSITE REGION
Mxy_3_RSP_9_10a_10b_CA_side = Mxy_3_RSP_9_10a_10b_CA NOT COIN EDGE M3
Mxy_3_RSP_9_10a_10b_CA_area = INT Mxy_3_RSP_9_10a_10b_CA_side Mxy_3_RSP_9_10a_10b_CA <= 0.082 REGION
// 
Mxy_3_RSP_9_10a_10b_ERR2_CHK = Mxy_3_RSP_9_10a_10b_CA_side NOT TOUCH EDGE Mxy_3_RSP_9_10a_10b_CA_area
Mxy_3_RSP_9_10a_10b_ERR2_TMP = (NOT RECTANGLE Mxy_3_RSP_9_10a_10b_y2) OR ((RECTANGLE Mxy_3_RSP_9_10a_10b_y2) ENCLOSE RECTANGLE 0.001 0.269)
Mxy_3_RSP_9_10a_10b_ERR2 = (Mxy_3_RSP_9_10a_10b_CA WITH EDGE Mxy_3_RSP_9_10a_10b_ERR2_CHK) INSIDE Mxy_3_RSP_9_10a_10b_ERR2_TMP
// 
Mxy_3_RSP_9_10a_10b_CB = EXT Mxy_3_RSP_9_10a_10b_y3 Mxy_3_RSP_9_10a_10b_y1 < 0.125 OPPOSITE REGION
Mxy_3_RSP_9_10a_10b_CB_side = Mxy_3_RSP_9_10a_10b_CB NOT COIN EDGE M3
Mxy_3_RSP_9_10a_10b_CB_area = INT Mxy_3_RSP_9_10a_10b_CB_side <= 0.082 REGION
// 
Mxy_3_RSP_9_10a_10b_ERR3_CHK = Mxy_3_RSP_9_10a_10b_CB_side TOUCH EDGE Mxy_3_RSP_9_10a_10b_CB_area
Mxy_3_RSP_9_10a_10b_ERR3_TMP = (NOT RECTANGLE Mxy_3_RSP_9_10a_10b_y2) OR ((RECTANGLE Mxy_3_RSP_9_10a_10b_y2) ENCLOSE RECTANGLE 0.001 0.269)
Mxy_3_RSP_9_10a_10b_ERR3 = (Mxy_3_RSP_9_10a_10b_CB WITH EDGE Mxy_3_RSP_9_10a_10b_ERR3_CHK) INSIDE Mxy_3_RSP_9_10a_10b_ERR3_TMP
 
M3_RSP_9 {
@ Space between metal space segments with S2 < 0.144um and L2 <= 0.082um
@ Metal space segments definition:
@ 1) At least one metal line width > 0.27um (W1) and PRL > 0.27um (L1) in metal space < 0.261um (S1) region
@ 2) Metal space segments within metal space (S1) region and are generated by space cut line which is perpendicular with L1 direction formed by all vertex in metal space region (S1)
@ 3) Metal space segments at least abut one metal with width > 0.27um (W1)
@ 4) L2 is the width of metal space segments which is parallel with L1 direction
@ 5) S2 is the width of metal space segments which is perpendicular with L1 direction. >= 0.298um
 Mxy_3_RSP_9_10a_10b_ERR1 NOT INSIDE SealR_NOT_BULK
}
 
M3_RSP_10a {
@ Width (S2) of metal space segments with L2 > 0.082um
@ Metal space segments definition:
@ 1) At least one metal line width > 0.27um (W1) and PRL > 0.27um (L1) in metal space < 0.261um (S1) region
@ 2) Metal space segments within metal space (S1) region and are generated by space cut line which is perpendicular with L1 direction formed by all vertex in metal space region (S1)
@ 3) Metal space segments at least abut one metal with width > 0.27um (W1)
@ 4) L2 is the width of metal space segments which is parallel with L1 direction
@ 5) S2 is the width of metal space segments which is perpendicular with L1 direction. >= 0.142um
 Mxy_3_RSP_9_10a_10b_ERR2 NOT INSIDE SealR_NOT_BULK
}
 
M3_RSP_10b {
@ Width (S2) of metal space segments with L2 <= 0.082um
@ Metal space segments definition:
@ 1) At least one metal line width > 0.27um (W1) and PRL > 0.27um (L1) in metal space < 0.261um (S1) region
@ 2) Metal space segments within metal space (S1) region and are generated by space cut line which is perpendicular with L1 direction formed by all vertex in metal space region (S1)
@ 3) Metal space segments at least abut one metal with width > 0.27um (W1)
@ 4) L2 is the width of metal space segments which is parallel with L1 direction
@ 5) S2 is the width of metal space segments which is perpendicular with L1 direction. >= 0.125um
 Mxy_3_RSP_9_10a_10b_ERR3 NOT INSIDE SealR_NOT_BULK
}

#IFDEF DOUBLE_PATTERNING_RULES_CHECK YES
#IFDEF DOUBLE_PATTERNING_RULES_CHECK_ONLY YES

GROUP GM3DP M3_OR_?
DRC SELECT CHECK GM3DP

#ENDIF
//----------------------------------------------------------------------------------------------------------------------//
//	Mxy.OR.0\[NC\]	Odd ring conflict space definition: 							        //
//	OR Line Space (ORLS): polygons violate any one of the odd ring space rules from Mxy.ORCS.1 and Mxy.ORCS.2       //
//	OR Corner Space (ORCS): polygons violate any one of the odd ring space rule Mxy.ORCS.3			        //
//	OR-AREA definition: 											        //
//	1. Odd ring line area (ORLA): The projection area between two edges with ORLS				        //
//	2. Odd ring corner area (ORCA): The line between two corners with ORCS						//
//	3. ORLA or ORCA region are independent to all other ones, even if they are overlapped or crossed		//
//	Loop:														//
//	1.A loop is formed when polygons of Mxy are connected in a cycle sequence with OR-AREA in between		//
//	2.A loop cannot contain any sub-loops which share one or more polygons with it					//
//	Path:														//
//	A path is formed when polygons of Mxy are connected one by one from one marker to another marker with OR-AREA   //
//       in between													//
//----------------------------------------------------------------------------------------------------------------------//

//;beginning of Mxy.ORCS.1 derivations
M3_ORCS_1 = EXT M3 < 0.063 OPPOSITE EXTENDED 0.015
M3_ORCS_1_AREA = DFM COPY M3_ORCS_1 REGION
//;end of Mxy.ORCS.1 derivations
 
//;beginning of Mxy.ORCS.2 derivations
M3_end_DP = LENGTH M3_convex_90_90_edges < 0.046
M3_ORCS_2 = EXT M3_end_DP M3 < 0.08 OPPOSITE EXTENDED 0.015
M3_ORCS_2_AREA = DFM COPY M3_ORCS_2 REGION
//;end of Mxy.ORCS.2 derivations
 
//;beginning of Mxy.ORCS.3 derivations
M3_ORCS_3_TMP = EXT M3 < 0.058 CORNER TO CORNER
M3_ORCS_3 = DFM PROPERTY M3_ORCS_3_TMP [-= (EWXP(M3_ORCS_3_TMP) >= 0.015 && EWYP(M3_ORCS_3_TMP) >= 0.015) ? 1 : 0] > 0
M3_ORCS_3_AREA = DFM COPY M3_ORCS_3 REGION
M3_ORCS_AREA_temp = OR M3_ORCS_1_AREA M3_ORCS_2_AREA M3_ORCS_3_AREA
//;end of Mxy.ORCS.3 derivations
 
M3_critical_case_edge = LENGTH M3_convex_eq_one_edges <= 0.002
M3_critical_case = EXT M3 M3_critical_case_edge < 0.002 ABUT==90 INTERSECTING ONLY REGION
M3_ORCS_AREA = M3_ORCS_AREA_temp NOT M3_critical_case
// 
M3_conflict_rings = DFM DP RING M3 M3_ORCS_1 M3_ORCS_2 M3_ORCS_3 (OPPOSITE 0)
M3_conflict_anchor = DFM DP ANCHOR_CONFLICT M3 M3_ORCS_1 M3_ORCS_2 M3_ORCS_3 (OPPOSITE 0) M3CA(anchor mask0) M3CB(anchor mask1) UNFILTERED
M3_mask0 = DFM DP MASK0 M3 M3_ORCS_1 M3_ORCS_2 M3_ORCS_3 (OPPOSITE 0)
M3_mask1 = DFM DP MASK1 M3 M3_ORCS_1 M3_ORCS_2 M3_ORCS_3 (OPPOSITE 0)
// SETLAYER M3_conflict_rings = RET NMDPC M3_ORCS_1 M3 M3_ORCS_2 M3_ORCS_3 M3CA M3CB FILE M3dpcfile MAP ring
// SETLAYER M3_warning_rings = RET NMDPC M3_ORCS_1 M3 M3_ORCS_2 M3_ORCS_3 M3CA M3CB FILE M3dpcfile MAP warning
// SETLAYER M3_conflict_anchor = RET NMDPC M3_ORCS_1 M3 M3_ORCS_2 M3_ORCS_3 M3CA M3CB FILE M3dpcfile MAP anchor_path
 

#IFDEF SHOW_DOUBLE_PATTERNING_CONFLICT_SPACE YES

M3_ORCS_1 {
@ Space between Mxy to Mxy when PRL > -0.015um. >= 0.063um
 err1 = COPY M3_ORCS_1_AREA
 err1 NOT INSIDE SealR_NOT_BULK
}
 
M3_ORCS_2 {
@ Space between Mxy line-end (width < 0.046um) and Mxy when PRL > -0.015um. >= 0.08um
 err1 = COPY M3_ORCS_2_AREA
 err1 NOT INSIDE SealR_NOT_BULK
}
 
M3_ORCS_3 {
@ Corner space between Mxy when PRL <= -0.015um. >= 0.058um
 err1 = COPY M3_ORCS_3_AREA
 err1 NOT INSIDE SealR_NOT_BULK
}

#ENDIF

 
M3_ORCS_1_single = EXT M3 < 0.063 OPPOSITE EXTENDED 0.015 NOTCH
M3_ORCS_2_single = EXT (M3 TOUCH EDGE M3_end_DP) M3 < 0.08 OPPOSITE EXTENDED 0.015 NOTCH
M3_ORCS_3_single_TMP = EXT M3 < 0.058 CORNER TO CORNER NOTCH
M3_ORCS_3_single = DFM PROPERTY M3_ORCS_3_single_TMP [-= (EWXP(M3_ORCS_3_single_TMP) >= 0.015 && EWYP(M3_ORCS_3_single_TMP) >= 0.015) ? 1 : 0] > 0
 
M3_OR_1 {
@ OR-AREA formed by single polygon is not allowed
 err1 = DFM COPY M3_ORCS_1_single M3_ORCS_2_single M3_ORCS_3_single REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
M3_OR_3 {
@ M3.OR.3: OR-AREA count of the close loop formed by original polygons and OR-AREA cannot be odd number
@ M3.OR.2: ORCA cannot cross another ORCA or touch ORLA
 err1 = COPY M3_conflict_rings
 err1 NOT INSIDE SealR_NOT_BULK
}
 
M3_OR_4 {
@ MxyDPMK must be drawn identically to Mxy
 err1 = M3DPMK NOT COIN EDGE M3
 err2 = M3DPMK NOT M3
 err1 NOT INSIDE EDGE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}
 
M3_OR_5 {
@ (Mxy INTERACT MxyDPMK) INTERACT ORLS or ORCS is not allowed
 err1 = M3_ORCS_AREA INTERACT (M3 INTERACT M3DPMK) SINGULAR ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
M3_OR_6 {
@ (Mxy INTERACT INST) INTERACT MxyDPMK is not allowed
 err1 = (M3 INTERACT INST) INTERACT M3DPMK SINGULAR ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
M3_OR_7 {
@ Pre-coloring marker MxyCA and MxyCB must be drawn identically to Mxy
 err1 = (M3CA OUTSIDE INST) NOT COIN EDGE M3
 // based M3_OR_9: CA/CB is forbidden in INST region
 err2 = (M3CB OUTSIDE INST) NOT COIN EDGE M3
 err3 = (M3CA OUTSIDE INST) NOT M3
 err4 = (M3CB OUTSIDE INST) NOT M3
 err1 NOT INSIDE EDGE SealR_NOT_BULK
 err2 NOT INSIDE EDGE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
 err4 NOT INSIDE SealR_NOT_BULK
}
 
M3_OR_8 {
@ MxyCA INTERACT MxyCB is not allowed
 err1 = M3CA INTERACT M3CB SINGULAR ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
M3_OR_9 {
@ (Mxy INTERACT INST) INTERACT (MxyCA OR MxyCB) is not allowed
 err1 = (M3CA OR M3CB) INTERACT (M3 INTERACT INST) SINGULAR ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
M3_OR_10 {
@ (MxyCA OR MxyCB) INTERACT MxyDPMK is not allowed
 err1 = (M3CA OR M3CB) INTERACT M3DPMK SINGULAR ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
M3_OR_11_12_13 {
@ OR-AREA count of any path starting from MxyCA and ending at MxyCA must not be an odd number
@ OR-AREA count of any path starting from MxyCB and ending at MxyCB must not be an odd number
@ OR-AREA count of any path starting from MxyCA and ending at MxyCB must not be an even number
 err1 = COPY M3_conflict_anchor
 err1 NOT INSIDE SealR_NOT_BULK
}
 
M3_OR_14 {
@ Maximum pre-coloring ratio of ((MxyCA + MxyCB + MxyDPMK)/Mxy) before decomposition < 16%
 check_pattern = (M3CA OR M3CB) OR M3DPMK
 check_region = COPY M3
 DENSITY check_pattern check_region [AREA(check_pattern)/AREA(check_region)] >= 0.16 PRINT "./SMIC_14SFPLUS_DRC_logFile/pre_coloring_ratio_M3_OR_14.log" RDB "./SMIC_14SFPLUS_DRC_logFile/pre_coloring_ratio_M3_OR_14.rdb"
}

#ENDIF


// =======================================================
// Square Vy design rules
// =======================================================

GROUP GVy1 Vy1_?

#IFDEF MANUFACTURABILITY_ENHANCEMENT_RULES YES

//;beginning of the Vy.EN.2a derivations
met_Vy_1_2a_ME = M1 WITH WIDTH < 0.050
via_Vy_1_2a_ME = 1XV1N INTERACT met_Vy_1_2a_ME
via_Vy_1_2a_bad_ME = RECTANGLE ENCLOSURE via_Vy_1_2a_ME M1 ABUT<90 SINGULAR OUTSIDE ALSO 
GOOD 0 0.032 OPPOSITE 0 0.032 OPPOSITE
via_Vy_1_2a_good_ME = via_Vy_1_2a_ME NOT via_Vy_1_2a_bad_ME
//;end of the Vy.EN.2a derivations
 
Vy1_EN_2a_ME {
@ Vy enclosure by M1 or Mxy (width < 0.05um) for two opposite sides with the other two side >= 0um (M1/Mxy is the metal underneath Vy), except INST region >= 0.032um
 err1 = via_Vy_1_2a_bad_ME NOT via_Vy_1_2c_good_ME
 err1 NOT INSIDE INST
}
 
//;beginning of the Vy.EN.2c derivations
met_Vy_1_2c_ME = M1 WITH WIDTH >= 0.050
via_Vy_1_2c_ME = 1XV1N INTERACT met_Vy_1_2c_ME
via_Vy_1_2c_bad_ME = RECTANGLE ENCLOSURE via_Vy_1_2c_ME M1 ABUT<90 SINGULAR 
GOOD 0.009 0.025 OPPOSITE 0.009 0.025 OPPOSITE
via_Vy_1_2c_good_ME = via_Vy_1_2c_ME NOT via_Vy_1_2c_bad_ME
//;end of the Vy.EN.2c derivations
 
Vy1_EN_2c_ME {
@ Vy enclosure by M1 or Mxy (width >= 0.05um) for two opposite sides with the other two side >= 0.009um (M1/Mxy is the metal underneath Vy), except INST region >= 0.025um
 err1 = via_Vy_1_2c_bad_ME NOT via_Vy_1_2a_good_ME
 err1 NOT INSIDE INST
}
 
//;beginning of the Vy.EN.16a derivations
met_Vy1_16a_ME = M2 WITH WIDTH == 0.032
via_Vy1_16a_ME = 1XV1N INTERACT met_Vy1_16a_ME
via_Vy1_16a_ME_bad = RECTANGLE ENCLOSURE via_Vy1_16a_ME M2 ABUT<90 SINGULAR 
GOOD 0 0.039 OPPOSITE 0 0.039 OPPOSITE
via_Vy1_16a_ME_good = via_Vy1_16a_ME NOT via_Vy1_16a_ME_bad
//;beginning of the Vy.EN.16a derivations
 
Vy1_EN_16a_ME {
@ Vy enclosure by Mxy+1 (width = 0.032um) for two opposite sides with the other two sides >= 0um, except INST region >= 0.039um
 err1 = COPY via_Vy1_16a_ME_bad
 err1 NOT INSIDE INST
}

#ENDIF

 
Vy1_BAR = (OR V1_BAR_100_all V1_BAR_450_all) INSIDE MARKS_MARKG
 
Vy1_W_1 {
@ Vy width and length (except 0.032*0.08um RVy, MARKS, MARKG, INDMY and LOGO region) = 0.032um
 err1 = (V1 NOT RV1) NOT 1XV1N
 err1 NOT INSIDE MARKS_MARKG_INDMY_LOGO
}
 
Vy1_W_2 {
@ Vy bar width in MARKS and MARKG regions = 0.1, 0.45um
 err1 = (V1 NOT (OR V1_SR V1_BAR_100_all V1_BAR_450_all V1N_Seal_Ring)) INSIDE MARKS_MARKG
 err1 NOT INSIDE SealR_NOT_BULK
}
 
Vy1_S_1 {
@ Space between two (Vy or RVy), except Vy.S.1a >= 0.069um
 err1 = EXT V1_SR < 0.069 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
Vy1_S_2 {
@ Space between two square Vy when PRL > -0.032um, except V1 in INST region, DRC only flag the point-to-point space when PRL <= 0. >= 0.082um
 err1 = EXT V1N < 0.082 ABUT<90 OPPOSITE EXTENDED 0.001 REGION
 err2_RAW = EXT V1N < 0.082 ABUT<90 CORNER TO CORNER
 err2_TMP = DFM PROPERTY err2_RAW [-= (EWXP(err2_RAW) < 0.032 || EWYP(err2_RAW) < 0.032) ? 1 : 0] > 0
 err2 = DFM COPY err2_TMP REGION
 // 
 err1 NOT INSIDE INST
 err2 NOT INSIDE INST
}
 
Vy1_S_3 {
@ Space between square Vy and RVy >= 0.082um
 err1 = EXT V1N RV1 < 0.082 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
Vy1_S_4 {
@ Space between Vy and Vy-1 (including V0) at different net and PRL > 0um. >= 0.038um
@ When:
@ Mxy+1/1.25xMy enclosure of Vy > 0um
 // (include V0)
 chk_via = (V1 AND (V1N INSIDE M2)) NOT COIN EDGE M2
 err1 = EXT chk_via V0 < 0.038 ABUT<90 OPPOSITE REGION NOT CONNECTED
 err1 NOT INSIDE SealR_NOT_BULK
}
 
Vy1_S_5 {
@ Space between Vy and Mxy (including M1) at different net, except V1 in INST region >= 0.037um
@ When:
@ 1. Mxy (including M1) enclosure of Vy < 0.003um
@ 2. Mxy+1/1.25xMy width > 0.038um
 y1 = V1 AND (V1N NOT OUTSIDE (M2 WITH WIDTH > 0.038))
 y2 = EXT [y1] M1 < 0.037 ABUT<90 MEASURE ALL NOT CONNECTED
 y3 = ENC [y2] M1 < 0.003 ABUT<90 OPPOSITE
 err1 = EXT (y1 COIN EDGE y3) M1 < 0.037 ABUT<90 MEASURE ALL NOT CONNECTED REGION
 // 
 err1 NOT INSIDE INST
}
 
Vy1_S_6 {
@ Projection space between Vy and the Mxy+1/1.25xMy concave corner >= 0.029um
@ When:
@ 1. Mxy+1/1.25xMy width < 0.035um, form one edge of concave corner
@ 2. Vy enclosure by Mxy+1/1.25xMy <= 0.002um at opposite side of Mxy+1/1.25xMy concave corner
@ 3. The length of another edge of concave corner > 0.005um
@ Via inside the cross region with vertex enclosure <= 0.001um is not allowed
 // for via not totally inside cross region
 min_enc_met_side = M2 TOUCH EDGE (ENC V1N [M2] <= 0.002 ABUT<90 OPPOSITE)
 min_wid_met_side = M2 TOUCH EDGE (INT min_enc_met_side [M2_convex_lt_two_edges] < 0.035 OPPOSITE)
 min_wid_met_corn = EXT min_wid_met_side (LENGTH M2_convex_lt_two_edges > 0.005) < 0.001 ABUT INTERSECTING ONLY REGION
 min_wid_met_side_c = min_wid_met_side TOUCH EDGE min_wid_met_corn
 min_wid_met_corn_c = M2 TOUCH EDGE min_wid_met_corn
 min_wid_met_side_opp = M2 TOUCH EDGE (INT min_wid_met_side_c [M2] < 0.035 OPPOSITE)
 min_wid_met_area_opp = INT min_wid_met_side_c M2 < 0.035 OPPOSITE REGION
 // 
 min_enc_via_s = ENC [V1N] min_wid_met_side_opp <= 0.002 ABUT<90 OPPOSITE
 min_enc_via_c = V1N WITH EDGE min_enc_via_s
 min_met_corn = min_wid_met_corn_c COIN EDGE (M2 ENCLOSE min_enc_via_c)
 via_err_edge_outer = EXT [min_enc_via_c] min_met_corn < 0.029 ABUT<90 OPPOSITE EXTENDED 0.035-0.032+GLOBAL_TOLERANCE MEASURE ALL
 via_err_edge_inner = EXT [min_enc_via_c] min_wid_met_corn < 0.029 ABUT<90 OPPOSITE EXTENDED 0.035-0.032+GLOBAL_TOLERANCE EXCLUDE SHIELDED
 via_err_edge_all = OR EDGE via_err_edge_outer via_err_edge_inner
 err1 = min_enc_via_c WITH EDGE via_err_edge_all
 err1 NOT INSIDE SealR_NOT_BULK
 // 
 min_wid_met_all = INT M2 M2_convex_lt_two_edges < 0.035 OPPOSITE REGION
 // SETLAYER min_wid_met_rvs = DRC:1 NOT M2
 // SETLAYER err2 = (V1N INTERACT min_wid_met_all SINGULAR ALSO) INTERACT min_wid_met_rvs SINGULAR ONLY // point touch via
 err2 = ENC (V1N INTERACT min_wid_met_all SINGULAR ALSO) M2 < 0.0005 SINGULAR REGION
 err2 NOT INSIDE SealR_NOT_BULK
 // 
 met_corner_corss = (EXT M2_convex_lt_two_edges M2 < 0.001 ABUT==90 INTERSECTING ONLY REGION) COIN EDGE min_wid_met_all
 via_inside_corss = ((V1N NOT WITH EDGE (ENC [V1N] M2 < 0.001 ABUT>0<90 SINGULAR)) NOT WITH EDGE via_err_edge_all) NOT INSIDE min_wid_met_all
 via_inside_corss_enc = EXT [via_inside_corss] met_corner_corss <= 0.001 PROJ==0 PARA ONLY OPPOSITE EXTENDED 0.002
 err3 = via_inside_corss INTERACT (INT via_inside_corss_enc <= 0.032 OPPOSITE REGION) // via inside cross must be enclosed by the short side of metal (width< 0.035) >= 0.001
 err3 NOT INSIDE SealR_NOT_BULK
}
 
Vy1_S_8 {
@ Space between Vy bar (width = 0.1/0.45um) and (Vy or RVy) >= 0.34um
 err1 = EXT (OR V1_BAR_100_all V1_BAR_450_all) V1_SR < 0.34 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
Vy1_S_9 {
@ Space between two Vy bar (width = 0.1/0.45um), DRC only check the space between parallel edge when the Vy bar is inside MARKS >= 0.55um
 // SETLAYER waive_shape = EXT (OR V1_BAR_100_all V1_BAR_450_all) < 0.55 ABUT<90 SINGULAR REGION INTERSECTING ONLY
 err1 = EXT ((OR V1_BAR_100_all V1_BAR_450_all) INTERACT MARKS_MARKG) < 0.55 ANGLED!=1 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 

#IFDEF DFM_RULES_PRIORITY_1 YES

 
Vy1_EN_1_DFM1 {
@ Recommended square Vy enclosure by M1/Mxy is defined by either Vy.EN.2.DFM or Vy.EN.3.DFM or Vy.EN.2b.DFM
 err1 = 1XV1N NOT INSIDE M1
 err1 NOT INSIDE SealR_NOT_BULK
}
 
//;beginning of the Vy.EN.2.DFM derivations
via_Vy_1_2_R_bad = RECTANGLE ENCLOSURE 1XV1N M1 ABUT<90 SINGULAR 
GOOD 0.007 0.050 OPPOSITE 0.007 0.050 OPPOSITE
via_Vy_1_2_R_good = 1XV1N NOT via_Vy_1_2_R_bad
//;end of the Vy.EN.2.DFM derivations
 
Vy1_EN_2_DFM1 {
@ Recommended square Vy enclosure by M1/Mxy for two opposite sides with the other two sides >= 0.007um, except FUSEMK1 region. >= 0.05um
 err1 = (via_Vy_1_2_R_bad NOT via_Vy_1_3_R_good) NOT INSIDE FUSEMK1
 err1 NOT INSIDE SealR_NOT_BULK
}
 
Vy1_EN_2b_DFM1 {
@ Recommended enclosure by M1 or Mxy (width < 0.05um) along width direction must be equal or 1nm difference (M1/Mxy is the metal underneath Vy.)
 chk_Mxy = (INT [M1] < 0.05 ABUT<90 OPPOSITE) TOUCH EDGE (M1 WITH WIDTH < 0.05)
 side_en = ENC V1N chk_Mxy < 0.018 ABUT<90 OPPOSITE
 side_en_EDGE = ENC [V1N] chk_Mxy < 0.018 ABUT<90 OPPOSITE
 err1 = DFM PROPERTY V1N side_en OVERLAP ABUT ALSO MULTI [-= COUNT(side_en)] >= 2 [+= ((MIN(EW(side_en)) == MAX(EW(side_en))) || (MIN(EW(side_en)) == ABS(MAX(EW(side_en)) - 0.001))) ? 1 : 0] == 0
 err1 NOT INSIDE SealR_NOT_BULK
}
 
//;beginning of the Vy.EN.3.DFM derivations
via_Vy_1_3_R_bad = RECTANGLE ENCLOSURE 1XV1N M1 ABUT<90 SINGULAR 
GOOD 0.02 0.02 0.02 0.02 OPPOSITE
via_Vy_1_3_R_good = 1XV1N NOT via_Vy_1_3_R_bad
//;end of the Vy.EN.3.DFM derivations
 
Vy1_EN_3_DFM1 {
@ Recommended square Vy enclosure by M1, Mxy for all sides to avoid high Rc, except FUSEMK1 region >= 0.02um
 err1 = (via_Vy_1_3_R_bad NOT via_Vy_1_2_R_good) NOT INSIDE FUSEMK1
 err2 = ((ENC [1XV1N] M1 < 0.02 ABUT<90 SINGULAR) NOT TOUCH EDGE via_Vy_1_2_R_good) NOT INSIDE EDGE FUSEMK1
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE EDGE SealR_NOT_BULK
}

#ENDIF

 
Vy1_EN_1 {
@ 1X square Vy must be fully enclosed by M1 or Mxy
@ where M1/Mxy is the metal layer directly underneath Vy, Vy enclosure by M1 or Mxy must follow either Vy.EN.2 or Vy.EN.3
 err1 = 1XV1N NOT M1
 err1 NOT INSIDE SealR_NOT_BULK
}
 
//;beginning of the Vy.EN.2 derivations
via_Vy_1_2_bad = RECTANGLE ENCLOSURE 1XV1N M1 ABUT<90 SINGULAR OUTSIDE ALSO 
GOOD 0 0.024 OPPOSITE 0 0.024 OPPOSITE
via_Vy_1_2_good = 1XV1N NOT via_Vy_1_2_bad
//;end of the Vy.EN.2 derivations
 
//;beginning of the Vy.EN.3 derivations
via_Vy_1_3_bad = RECTANGLE ENCLOSURE 1XV1N M1 ABUT<90 SINGULAR OUTSIDE ALSO 
GOOD 0.015 0.015 0.015 0.015 OPPOSITE
via_Vy_1_3_good = 1XV1N NOT via_Vy_1_3_bad
via_Vy_1_2_3_good = OR via_Vy_1_2_good via_Vy_1_3_good
//;end of the Vy.EN.3 derivations
 
Vy1_EN_2_3 {
@ Vy.EN.2: Vy enclosure by M1 or Mxy when enclosure by M1 or Mxy on either perpendicular direction >= 0um, except V1 in INST region >= 0.024um
@ Vy.EN.3: Vy enclosure by M1 or Mxy for all sides, except V1 in INST region >= 0.015
 err1 = via_Vy_1_2_bad NOT via_Vy_1_2_3_good
 // 
 err1 NOT INSIDE INST
}
 
Vy1_EN_4a {
@ Vy enclosure by M1 in adjacent S1 side, where M1 is the metal layer directly underneath Vy >= 0.004um
@ When:
@ 1. M1 width W: 0.036um <= W <= 0.041um
@ 2. Space: 0.058um <= S1 < 0.063um, the PRL >= 0.083um
@ 3. The opposite space S2 >= 0.069um
@ except V1 in INST region
 met_wid_all = M1 WITH WIDTH > 0.036-GLOBAL_TOLERANCE <= 0.041
 met_err_RAW_a = EXT [met_wid_all] M1 >= 0.058 < 0.063 ABUT<90 OPPOSITE MEASURE ALL
 met_err_RAW_b = EXT met_wid_all M1 >= 0.058 < 0.063 ABUT<90 OPPOSITE MEASURE ALL
 met_err_RAW_c = EXT met_wid_all [M1] >= 0.058 < 0.063 ABUT<90 OPPOSITE MEASURE ALL
 met_err_PRL = DFM PROPERTY met_err_RAW_b met_err_RAW_c OVERLAP ABUT ALSO MULTI [-= max(LENGTH(met_err_RAW_c))] >= 0.083
 // 
 met_err_EGE_a = met_err_RAW_a COIN EDGE (DFM COPY met_err_PRL EDGE)
 met_err_EGE_b = ENC V1N [met_err_EGE_a] < 0.004 ABUT<90 OPPOSITE
 met_err_EGE_c = INT met_err_EGE_b [M1] > 0.036-GLOBAL_TOLERANCE <= 0.041 ABUT<90 OPPOSITE MEASURE COIN
 met_err_EGE_d = EXT (met_err_EGE_c) M1 < 0.069 ABUT<90 OPPOSITE
 met_err_EGE_e = met_err_EGE_b COIN EDGE M1
 err1 = INT met_err_EGE_d [met_err_EGE_e] > 0.036-GLOBAL_TOLERANCE <= 0.041 ABUT<90 OPPOSITE
 // 
 err1 NOT INSIDE EDGE INST
}
 
Vy1_EN_4b {
@ Vy enclosure by M1 in adjacent S1 side, where M1 is the metal layer directly underneath Vy >= 0.004um
@ When:
@ 1. M1 width W: 0.042um <= W <= 0.05um
@ 2. Space: 0.058um <= S1 <= 0.067um, the PRL >= 0.136um
@ except V1 in INST region
 met_wid_all = M1 WITH WIDTH > 0.042-GLOBAL_TOLERANCE <= 0.05
 met_err_RAW_TMP = EXT met_wid_all [M1] >= 0.058 < 0.067+GLOBAL_TOLERANCE ABUT<90 OPPOSITE MEASURE ALL
 met_err_RAW = EXT met_err_RAW_TMP [M1] >= 0.058 < 0.067+GLOBAL_TOLERANCE ABUT<90 OPPOSITE
 // 
 met_jog_ALL = M1_convex_eq_one_edges NOT COIN EDGE met_err_RAW
 met_jog_EXP_a = EXPAND EDGE met_jog_ALL INSIDE BY 0.0005
 met_jog_EXP_b = EXPAND EDGE met_jog_ALL OUTSIDE BY 0.0005
 met_jog_TMP = (met_jog_ALL COIN EDGE (met_jog_EXP_a WITH EDGE met_err_RAW)) COIN EDGE (met_jog_EXP_b WITH EDGE met_err_RAW)
 met_jog_EXP = ((VERTEX (EXPAND EDGE met_jog_TMP OUTSIDE BY 0.001 EXTEND BY 0.001) == 4) OR (EXPAND EDGE met_err_RAW OUTSIDE BY 0.001)) NOT M1
 // 
 met_err_PRL = DFM PROPERTY met_jog_EXP met_err_RAW met_wid_all OVERLAP ABUT ALSO MULTI [-= LENGTH(met_err_RAW)] >= 0.136 [+= COUNT(met_wid_all)] > 0
 met_err_EGE = M1 COIN EDGE (met_err_RAW COIN EDGE (met_err_PRL COIN EDGE met_wid_all))
 err1 = ENC [V1N] met_err_EGE < 0.004 ABUT<90 OPPOSITE
 // 
 err1 NOT INSIDE EDGE INST
}
 
Vy1_EN_6 {
@ Vy enclosure by M1 in adjacent S1 side, where M1 is the metal layer directly underneath Vy >= 0.004um
@ When:
@ 1. M1 width W: 0.051um <= W <= 0.112um
@ 2. Space: 0.058um <= S1 <= 0.094um, the PRL >= 0.136um
@ DRC doesn't check Vy:
@ a) Two Vys with space <= 0.1um in M1 and 1.25xMy/Mxy intersection region.
@ b) One Vy and one rectangular Vy with space <= 0.1um in M1 and 1.25xMy/Mxy intersection region
 met_wid_all = M1 WITH WIDTH > 0.051-GLOBAL_TOLERANCE <= 0.112
 met_err_RAW_TMP = EXT met_wid_all [M1] >= 0.058 < 0.094+GLOBAL_TOLERANCE ABUT<90 OPPOSITE MEASURE ALL
 met_err_RAW = EXT met_err_RAW_TMP [M1] >= 0.058 < 0.094+GLOBAL_TOLERANCE ABUT<90 OPPOSITE
 // 
 met_jog_ALL = M1_convex_eq_one_edges NOT COIN EDGE met_err_RAW
 met_jog_EXP_a = EXPAND EDGE met_jog_ALL INSIDE BY 0.0005
 met_jog_EXP_b = EXPAND EDGE met_jog_ALL OUTSIDE BY 0.0005
 met_jog_TMP = (met_jog_ALL COIN EDGE (met_jog_EXP_a WITH EDGE met_err_RAW)) COIN EDGE (met_jog_EXP_b WITH EDGE met_err_RAW)
 met_jog_EXP = ((VERTEX (EXPAND EDGE met_jog_TMP OUTSIDE BY 0.001 EXTEND BY 0.001) == 4) OR (EXPAND EDGE met_err_RAW OUTSIDE BY 0.001)) NOT M1
 // 
 met_err_PRL = DFM PROPERTY met_jog_EXP met_err_RAW met_wid_all OVERLAP ABUT ALSO MULTI [-= LENGTH(met_err_RAW)] >= 0.136 [+= COUNT(met_wid_all)] > 0
 met_err_EGE = M1 COIN EDGE (met_err_RAW COIN EDGE (met_err_PRL COIN EDGE met_wid_all))
 via_group_all = SIZE V1 BY 0.05 INSIDE OF (M1 AND M2) STEP 0.02
 via_group_real = V1 INTERACT (via_group_all INTERACT V1 >= 2)
 err1 = ENC (V1N NOT via_group_real) met_err_EGE < 0.004 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
Vy1_EN_7 {
@ Vy enclosure by M1 in adjacent S1 side, where M1 is the metal layer directly underneath Vy >= 0.008um
@ When:
@ 1. M1 width W: 0.061um <= W <= 0.09um
@ 2. Space: 0.058um <= S1 <= 0.079um, the PRL >= 0.136um
 met_wid_all = M1 WITH WIDTH > 0.061-GLOBAL_TOLERANCE <= 0.09
 met_err_RAW_TMP = EXT met_wid_all [M1] >= 0.058 < 0.079+GLOBAL_TOLERANCE ABUT<90 OPPOSITE MEASURE ALL
 met_err_RAW = EXT met_err_RAW_TMP [M1] >= 0.058 < 0.079+GLOBAL_TOLERANCE ABUT<90 OPPOSITE
 // 
 met_jog_ALL = M1_convex_eq_one_edges NOT COIN EDGE met_err_RAW
 met_jog_EXP_a = EXPAND EDGE met_jog_ALL INSIDE BY 0.0005
 met_jog_EXP_b = EXPAND EDGE met_jog_ALL OUTSIDE BY 0.0005
 met_jog_TMP = (met_jog_ALL COIN EDGE (met_jog_EXP_a WITH EDGE met_err_RAW)) COIN EDGE (met_jog_EXP_b WITH EDGE met_err_RAW)
 met_jog_EXP = ((VERTEX (EXPAND EDGE met_jog_TMP OUTSIDE BY 0.001 EXTEND BY 0.001) == 4) OR (EXPAND EDGE met_err_RAW OUTSIDE BY 0.001)) NOT M1
 // 
 met_err_PRL = DFM PROPERTY met_jog_EXP met_err_RAW met_wid_all OVERLAP ABUT ALSO MULTI [-= LENGTH(met_err_RAW)] >= 0.136 [+= COUNT(met_wid_all)] > 0
 met_err_EGE = M1 COIN EDGE (met_err_RAW COIN EDGE (met_err_PRL COIN EDGE met_wid_all))
 err1 = ENC [V1N] met_err_EGE < 0.008 ABUT<90 OPPOSITE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
Vy1_EN_9 {
@ Vy enclosure by M1/Mxy in adjacent S1 side, where M1/Mxy is the metal layer directly underneath Vy >= 0.004um
@ When:
@ 1. M1/Mxy dimension along enclosure direction: 0.113um <= L <= 0.201um
@ 2. Space: 0.058um <= S1 <= 0.094um, the PRL >= 0.083um
 met_wid_all = INT [M1] > 0.113-GLOBAL_TOLERANCE <= 0.201 ABUT<90 OPPOSITE EXCLUDE SHIELDED
 met_err_RAW = EXT [met_wid_all] M1 >= 0.058 < 0.094+GLOBAL_TOLERANCE ABUT<90 OPPOSITE
 met_jog_ALL = M1_convex_eq_one_edges NOT COIN EDGE met_err_RAW
 met_jog_EXP_a = EXPAND EDGE met_jog_ALL INSIDE BY 0.0005
 met_jog_EXP_b = EXPAND EDGE met_jog_ALL OUTSIDE BY 0.0005
 met_jog_TMP = (met_jog_ALL COIN EDGE (met_jog_EXP_a WITH EDGE met_err_RAW)) COIN EDGE (met_jog_EXP_b WITH EDGE met_err_RAW)
 met_jog_EXP = ((VERTEX (EXPAND EDGE met_jog_TMP OUTSIDE BY 0.001 EXTEND BY 0.001) == 4) OR (EXPAND EDGE met_err_RAW OUTSIDE BY 0.001)) NOT M1
 // 
 met_err_PRL = DFM PROPERTY met_jog_EXP met_err_RAW OVERLAP ABUT ALSO MULTI [-= LENGTH(met_err_RAW)] >= 0.083
 met_err_EGE = M1 COIN EDGE (met_err_RAW COIN EDGE met_err_PRL)
 err1 = ENC V1N met_err_EGE < 0.004 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
Vy1_EN_10 {
@ Vy enclosure by M1/Mxy in adjacent S1 side, where M1/Mxy is the metal layer directly underneath Vy >= 0.014um
@ When:
@ 1. M1/Mxy width W: dimension along enclosure direction L >= 0.202um
@ 2. Space: 0.058um <= S1 <= 0.094um, PRL >= 0.083um
 met_wid_all = INT (M1) <= 0.202-GLOBAL_TOLERANCE ABUT<90 OPPOSITE EXCLUDE SHIELDED
 met_err_RAW = EXT [met_wid_all] M1 >= 0.058 < 0.094+GLOBAL_TOLERANCE ABUT<90 OPPOSITE
 met_jog_ALL = M1_convex_eq_one_edges NOT COIN EDGE met_err_RAW
 met_jog_EXP_a = EXPAND EDGE met_jog_ALL INSIDE BY 0.0005
 met_jog_EXP_b = EXPAND EDGE met_jog_ALL OUTSIDE BY 0.0005
 met_jog_TMP = (met_jog_ALL COIN EDGE (met_jog_EXP_a WITH EDGE met_err_RAW)) COIN EDGE (met_jog_EXP_b WITH EDGE met_err_RAW)
 met_jog_EXP = ((VERTEX (EXPAND EDGE met_jog_TMP OUTSIDE BY 0.001 EXTEND BY 0.001) == 4) OR (EXPAND EDGE met_err_RAW OUTSIDE BY 0.001)) NOT M1
 // 
 met_err_PRL = DFM PROPERTY met_jog_EXP met_err_RAW OVERLAP ABUT ALSO MULTI [-= LENGTH(met_err_RAW)] >= 0.083
 met_err_EGE = M1 COIN EDGE (met_err_RAW COIN EDGE met_err_PRL)
 err1 = ENC V1N met_err_EGE < 0.014 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
Vy1_EN_11 {
@ Vy bar must fully enclosure by Mxy (including M1) where Mxy is the metal layer directly underneath Vy bar >= 0.2um
 err1 = ENC V1_BAR_100_all M1 < 0.2 ABUT<90 SINGULAR REGION OUTSIDE ALSO
 err2 = ENC V1_BAR_450_all M1 < 0.2 ABUT<90 SINGULAR REGION OUTSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}
 

#IFDEF DFM_RULES_PRIORITY_1 YES

 
Vy1_EN_14_DFM1 {
@ Recommended square Vy fully enclosure by Mxy+1/1.25xMy is defined by either Vy.EN.16.DFM, Vy.EN.16a.DFM or Vy.EN.16b.DFM, which Mxy+1/1.25xMy is the metal layer directly above Vy
 err1 = 1XV1N NOT INSIDE M2
 err1 NOT INSIDE SealR_NOT_BULK
}
 
//;beginning of the Vy.EN.16.DFM derivations
via_Vy_1_16_R_bad = RECTANGLE ENCLOSURE 1XV1N M2 ABUT<90 SINGULAR OUTSIDE ALSO 
GOOD 0.020 0.020 0.020 0.020 OPPOSITE
via_Vy_1_16_R_good = 1XV1N NOT via_Vy_1_16_R_bad
//;end of the Vy.EN.16.DFM derivations
 
Vy1_EN_16_DFM1 {
@ Recommended square Vy enclosure by Mxy+1/1.25xMy for all sides >= 0.02um
 err1 = via_Vy_1_16_R_bad NOT (OR via_Vy_1_16a_R_good via_Vy_1_16b_R_good)
 err2 = (ENC [1XV1N] M2 < 0.02 ABUT<90 SINGULAR) NOT TOUCH EDGE (OR via_Vy_1_16a_R_good via_Vy_1_16b_R_good)
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE EDGE SealR_NOT_BULK
}
 
//;beginning of the Vy.EN.16a.DFM derivations
met_Vy1_16a_R = M2 WITH WIDTH < 0.05
via_Vy1_16a_R = 1XV1N NOT OUTSIDE met_Vy1_16a_R
via_Vy_1_16a_R_bad = RECTANGLE ENCLOSURE via_Vy1_16a_R M2 ABUT<90 SINGULAR 
GOOD 0.007 0.050 OPPOSITE 0.007 0.050 OPPOSITE
via_Vy_1_16a_R_good = via_Vy1_16a_R NOT via_Vy_1_16a_R_bad
//;end of the Vy.EN.16a.DFM derivations
 
Vy1_EN_16a_DFM1 {
@ Recommended square Vy enclosure by Mxy+1/1.25xMy (width < 0.05um) for two opposite sides with the other two sides >= 0.007um. >= 0.05um
 err1 = via_Vy_1_16a_R_bad NOT (OR via_Vy_1_16_R_good via_Vy_1_16b_R_good)
 err1 NOT INSIDE SealR_NOT_BULK
}
 
//;beginning of the Vy.EN.16b.DFM derivations
via_Vy1_16b_R = (1XV1N OUTSIDE met_Vy1_16a_R) NOT OUTSIDE M2
via_Vy_1_16b_R_bad = RECTANGLE ENCLOSURE via_Vy1_16b_R M2 ABUT<90 SINGULAR 
GOOD 0.009 0.050 OPPOSITE 0.009 0.050 OPPOSITE
via_Vy_1_16b_R_good = via_Vy1_16b_R NOT via_Vy_1_16b_R_bad
//;end of the Vy.EN.16.DFM derivations
 
Vy1_EN_16b_DFM1 {
@ Recommended square Vy enclosure by Mxy+1/1.25xMy (width >= 0.05um) for two opposite sides with the other two sides >= 0.009um. >= 0.05um
 err1 = via_Vy_1_16b_R_bad NOT (OR via_Vy_1_16_R_good via_Vy_1_16a_R_good)
 err1 NOT INSIDE SealR_NOT_BULK
}

#ENDIF

 
//;beginning of the Vy.EN.13 derivations
via_Vy1_13_bad = RECTANGLE ENCLOSURE 1XV1N M2 ABUT<90 SINGULAR OUTSIDE ALSO 
GOOD 0.015 0.015 0.015 0.015 OPPOSITE
via_Vy_1_13_good = 1XV1N NOT via_Vy1_13_bad
//;beginning of the Vy.EN.13 derivations
 
Vy1_EN_12_13 {
@ 1X square Vy must be fully enclosure by Mxy+1/1.25xMy where Mxy+1/1.25xMy is the metal layer directly above Vy
@ Enclosure by Mxy+1/1.25x My must follow one of Vy.En.15 or Vy.EN.16 or Vy.EN.16a or Vy.EN.16b or Vy.EN.16c or Vy.EN.16d or Vy.EN.16e or Vy.EN.16f or Vy.EN.16g or Vy.EN.17 or Vy.EN.18 or Vy.EN.19 or Vy.EN.20 or Vy.EN.21
@ Vy.EN.13: Vy enclosure by Mxy+1 for all sides >= 0.015um
 err1 = 1XV1N NOT M2
 err1 NOT INSIDE SealR_NOT_BULK
}
 
//;beginning of the Vy.EN.16a derivations
met_Vy1_16a = M2 WITH WIDTH > 0.032 <= 0.046
via_Vy1_16a = (1XV1N INTERACT met_Vy1_16a) NOT via_Vy1_16f_16g_good
via_Vy1_16a_bad = RECTANGLE ENCLOSURE via_Vy1_16a M2 ABUT<90 SINGULAR 
GOOD 0.003 0.032 OPPOSITE 0.003 0.047 OPPOSITE
via_Vy1_16a_good = via_Vy1_16a NOT via_Vy1_16a_bad
//;beginning of the Vy.EN.16a derivations
 
Vy1_EN_16a {
@ Vy enclosure by Mxy+1 (0.032um < short side of Mxy+1 width <= 0.046um) for opposite side >= 0.032um with the two sides >= 0.003um, except V1 in INST region >= 0.047um
 err1 = copy via_Vy1_16a_bad
 err1 NOT INSIDE INST
}
 
//;beginning of the Vy.EN.16b derivations
met_Vy1_16b = M2 WITH WIDTH > 0.046 <= 0.09
via_Vy1_16b_TMP = 1XV1N INTERACT met_Vy1_16b
via_Vy1_16b = via_Vy1_16b_TMP NOT (OR via_Vy_1_13_good via_Vy1_16a_good via_Vy1_16f_16g_good)
via_Vy1_16b_bad = RECTANGLE ENCLOSURE via_Vy1_16b M2 ABUT<90 SINGULAR 
GOOD 0.008 0.024 OPPOSITE 0.008 0.024 OPPOSITE
via_Vy1_16b_good = via_Vy1_16b NOT via_Vy1_16b_bad
//;beginning of the Vy.EN.16b derivations
 
Vy1_EN_16b {
@ Vy enclosure by Mxy+1 for two opposite sides with the other two sides >= 0.008um (0.046um < short side of Mxy+1 width <= 0.09um), except V1 in INST region >= 0.024um
 err1 = copy via_Vy1_16b_bad
 err1 NOT INSIDE INST
}
 
//;beginning of the Vy.EN.16c derivations
met_Vy1_width_096_200 = M2 WITH WIDTH > 0.09 <= 0.2
met_Vy1_16c = copy met_Vy1_width_096_200
via_Vy1_16c_TMP = 1XV1N INTERACT met_Vy1_16c
via_Vy1_16c = via_Vy1_16c_TMP NOT (OR via_Vy_1_13_good via_Vy1_16a_good via_Vy1_16b_good via_Vy1_16f_16g_good)
via_Vy1_16c_bad = RECTANGLE ENCLOSURE via_Vy1_16c M2 ABUT<90 SINGULAR 
GOOD 0.014 0.024 OPPOSITE 0.014 0.024 OPPOSITE
via_Vy1_16c_good = via_Vy1_16c NOT via_Vy1_16c_bad
//;end of the Vy.EN.16c derivations
 
//;beginning of the Vy.EN.16d derivations
met_Vy1_16d = copy met_Vy1_width_096_200
via_Vy1_16d_TMP_1 = 1XV1N INTERACT met_Vy1_16d
via_Vy1_16d_TMP = via_Vy1_16d_TMP_1 NOT (OR via_Vy_1_13_good via_Vy1_16a_good via_Vy1_16b_good via_Vy1_16f_16g_good)
via_Vy1_16d_bad_TMP = RECTANGLE ENCLOSURE via_Vy1_16d_TMP M2 ABUT<90 SINGULAR 
GOOD 0 0.009 OPPOSITE 0 0.024 OPPOSITE
via_Vy1_16d = via_Vy1_16d_TMP NOT via_Vy1_16d_bad_TMP
via_Vy1_16d_bad = RECTANGLE ENCLOSURE via_Vy1_16d M2 ABUT<90 SINGULAR 
GOOD 0.009 OPPOSITE 0.024 OPPOSITE 0.058 OPPOSITE 0.058 OPPOSITE 
GOOD 0.024 OPPOSITE 0.009 OPPOSITE 0.058 OPPOSITE 0.058 OPPOSITE
via_Vy1_16d_good = via_Vy1_16d NOT via_Vy1_16d_bad
//;end of the Vy.EN.16d derivations
via_Vy1_16_abcd_good = OR via_Vy1_16a_good via_Vy1_16b_good via_Vy1_16c_good via_Vy1_16d_good
 
Vy1_EN_16c {
@ Vy enclosure by Mxy+1 for two opposite sides with the other two sides >= 0.014um (0.09um < short side of Mxy+1 width <= 0.2um), except V1 in INST region >= 0.024um
 err1 = via_Vy1_16c_bad NOT via_Vy1_16d_good // exclude Vy.en.16d
 err2 = ENC via_Vy1_16c M2 < 0.009 ABUT<90 SINGULAR REGION
 // 
 err1 NOT INSIDE INST
 err2 NOT INSIDE INST
}
 
Vy1_EN_16d {
@ Vy enclosure by Mxy+1 for at least two adjacent edges with the other two sides >= 0.024um and >= 0.009um (0.09um < short side of Mxy+1 width <= 0.2um), except V1 in INST region >= 0.058um
 err1 = via_Vy1_16d_bad NOT via_Vy1_16c_good // exclude Vy.en.16c
 err2 = ENC via_Vy1_16d M2 < 0.009 ABUT<90 SINGULAR REGION
 // 
 err1 NOT INSIDE INST
 err2 NOT INSIDE INST
}
 
//;beginning of the Vy.EN.16e derivations
met_Vy1_16e = M2 WITH WIDTH > 0.2
via_Vy1_16e_TMP = 1XV1N INTERACT met_Vy1_16e
via_Vy1_16e = via_Vy1_16e_TMP NOT (OR via_Vy_1_13_good via_Vy1_16_abcd_good via_Vy1_16f_16g_good)
via_Vy1_16e_bad = RECTANGLE ENCLOSURE via_Vy1_16e M2 ABUT<90 SINGULAR 
GOOD 0.014 0.024 OPPOSITE 0.014 0.024 OPPOSITE
via_Vy1_16e_good = via_Vy1_16e NOT via_Vy1_16e_bad
//;end of the Vy.EN.16e derivations
 
Vy1_EN_16e {
@ Vy enclosure by Mxy+1 for two opposite sides with the other two sides >= 0.014um (short side of Mxy+1 width > 0.2um) >= 0.024um
 err1 = copy via_Vy1_16e_bad
 err1 NOT INSIDE SealR_NOT_BULK
}
 
//;beginning of the Vy.EN.16f derivations
met_Vy1_16f_16g_t = M2 WITH WIDTH == 0.032
met_Vy1_16f_16g = met_Vy1_16f_16g_t INTERACT 1XV1N
met_Vy1_16f_16g_side = INT [met_Vy1_16f_16g] == 0.032 ABUT<90 OPPOSITE
via_Vy1_16f_16g = 1XV1N INTERACT met_Vy1_16f_16g
via_Vy1_16f_16g_non_iso_end = via_Vy1_16f_16g NOT TOUCH EDGE met_Vy1_16f_16g_side
via_Vy1_16f_16g_non_iso_side = via_Vy1_16f_16g TOUCH EDGE met_Vy1_16f_16g_side
via_Vy1_16f_16g_non_iso_s1 = EXT [via_Vy1_16f_16g_non_iso_end] M2 < 0.130 ABUT<90 OPPOSITE MEASURE ALL
via_Vy1_16f_16g_non_iso_s2 = EXT [via_Vy1_16f_16g_non_iso_side] M2 < 0.090 ABUT<90 OPPOSITE EXTENDED 0.13 MEASURE ALL
via_Vy1_16f_16g_non_iso_via = via_Vy1_16f_16g WITH EDGE (OR EDGE via_Vy1_16f_16g_non_iso_s1 via_Vy1_16f_16g_non_iso_s2)
via_Vy1_16f_16g_iso_via = via_Vy1_16f_16g NOT via_Vy1_16f_16g_non_iso_via
via_Vy1_16f_non_iso_bad_1 = RECTANGLE ENCLOSURE via_Vy1_16f_16g_non_iso_via M2 ABUT<90 SINGULAR 
GOOD 0 0.036 OPPOSITE 0 0.036 OPPOSITE
via_Vy1_16f_non_iso_bad_2 = RECTANGLE ENCLOSURE via_Vy1_16f_16g_non_iso_via M2 ABUT<90 SINGULAR 
GOOD 0 0.036 OPPOSITE 0 0.043 OPPOSITE 
GOOD 0 0.037 OPPOSITE 0 0.042 OPPOSITE 
GOOD 0 0.038 OPPOSITE 0 0.041 OPPOSITE 
GOOD 0 0.039 OPPOSITE 0 0.040 OPPOSITE
via_Vy1_16f_non_iso_good = via_Vy1_16f_16g_non_iso_via NOT (OR via_Vy1_16f_non_iso_bad_1 via_Vy1_16f_non_iso_bad_2)
//;end of the Vy.EN.16f derivations
 
//;beginning of the Vy.EN.16g derivations
via_Vy1_16g_iso_bad_1 = RECTANGLE ENCLOSURE via_Vy1_16f_16g_iso_via M2 ABUT<90 SINGULAR 
GOOD 0 0.030 OPPOSITE 0 0.030 OPPOSITE
via_Vy1_16g_iso_bad_2 = RECTANGLE ENCLOSURE via_Vy1_16f_16g_iso_via M2 ABUT<90 SINGULAR 
GOOD 0 0.030 OPPOSITE 0 0.039 OPPOSITE 
GOOD 0 0.031 OPPOSITE 0 0.038 OPPOSITE 
GOOD 0 0.032 OPPOSITE 0 0.037 OPPOSITE 
GOOD 0 0.033 OPPOSITE 0 0.036 OPPOSITE 
GOOD 0 0.034 OPPOSITE 0 0.035 OPPOSITE
via_Vy1_16g_iso_good = via_Vy1_16f_16g_iso_via NOT (OR via_Vy1_16g_iso_bad_1 via_Vy1_16g_iso_bad_2)
//;end of the Vy.EN.16g derivations
via_Vy1_16f_16g_good = OR via_Vy1_16f_non_iso_good via_Vy1_16g_iso_good
 
Vy1_EN_16f {
@ Total Vy enclosure by Mxy+1 (Mxy+1 width = 0.032um, both two opposite sides(EN1A/EN2A) >= 0.036um)with the other two sides >= 0um. >= 0.079um
 err1 = COPY via_Vy1_16f_non_iso_bad_1
 err2 = COPY via_Vy1_16f_non_iso_bad_2
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}
 
Vy1_EN_16g {
@ Total Vy enclosure by Mxy+1 (Mxy+1 width = 0.032um, both two opposite sides >= 0.03um) with the other two sides(EN1A/EN2A) >= 0um (for iso Vy condition only) >= 0.069um
@ Iso Vy condition definition:
@ S1 > 0.13um and S2 > 0.09um, where S1 is via space to metal in length direction and S2 is via space to metal in width direction
 err1 = COPY via_Vy1_16g_iso_bad_1
 err2 = COPY via_Vy1_16g_iso_bad_2
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}
 
Vy1_EN_25 {
@ Vy bar must fully enclosure by Mxy+1/1.25xMy where Mxy+1/1.25xMy is the metal layer directly above Vy bar >= 0.2um
 err1 = ENC V1_BAR_100_all M2 < 0.2 ABUT<90 SINGULAR REGION OUTSIDE ALSO
 err2 = ENC V1_BAR_450_all M2 < 0.2 ABUT<90 SINGULAR REGION OUTSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

#IFDEF RECOMMENDED_CHECK YES

 
Vy1_D_1_R {
@ (Vy OR RVy) density (window 5um*5um, stepping 2.5um) < 7.7%
 check_region = copy CHIP_NOT_MARKS
 check_pattern = (V1 NOT Vy1_BAR) AND check_region
 // 
 check_window1 = check_region WITH WIDTH >= 5/4
 err1_TMP1 = DENSITY check_pattern check_window1 check_region [!!AREA(check_window1)*AREA(check_pattern)/AREA(check_region)] >= 7.7/100 WINDOW 5 STEP 5/2 BACKUP INSIDE OF LAYER DRC:1 BY POLYGON
 // 
 check_window2 = WITH WIDTH (check_region AND err1_TMP1) >= 5/4
 err1_TMP2 = DENSITY check_pattern check_window2 check_region [!!AREA(check_window2)*AREA(check_pattern)/AREA(check_region)] >= 7.7/100 WINDOW 5 STEP 5/2 BACKUP INSIDE OF LAYER err1_TMP1 BY POLYGON
 // 
 check_window3 = WITH WIDTH (check_region AND err1_TMP2) >= 5/4
 DENSITY check_pattern check_window3 check_region [!!AREA(check_window3)*AREA(check_pattern)/AREA(check_region)] >= 7.7/100 WINDOW 5 STEP 5/2 BACKUP INSIDE OF LAYER err1_TMP2 BY POLYGON PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_Vy1_D_1_R.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_Vy1_D_1_R.rdb"
}

#ENDIF

 
Vy1_R_1 {
@ 45-degree (Vy OR RVy) is not allowed
 err1 = ANGLE (V1 NOT Vy1_BAR) > 44.5 < 45.5
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
Vy1_R_2 {
@ Single Vy is not allowed in H-shape Mxy+1/1.25xMy, when:
@ 1. The Mxy+1/1.25xMy has H-shape interacting with two metal holes: both two metal holes length <= 4.5um and two metal hole area <= 4.05um2
@ 2. The Vy overlaps on the center metal bar of this H-shape Mxy+1/1.25xMy
@ 3. The center metal bar length <= 0.9um and the metal bar width <= 0.12um
@ DRC doesn't check when one or more square 1xVn is also on H-shape Mxy+1/1.25xMy region
 hole_area_meet = AREA (HOLES M2 INNER) <= 4.05
 hole_area_meet_len = (hole_area_meet WITH EDGE (LENGTH hole_area_meet <= 0.9)) NOT WITH EDGE (LENGTH hole_area_meet > 4.5)
 hole_area_real = (hole_area_meet_len NOT ENCLOSE RECTANGLE 0.9+GLOBAL_TOLERANCE 4.5) NOT ENCLOSE RECTANGLE 0.9 4.5+GLOBAL_TOLERANCE
 hole_bars_len = M2 COIN EDGE hole_area_real
 // 
 hole_bars = INT hole_bars_len <= 0.12 ABUT<90 OPPOSITE REGION EXCLUDE SHIELDED
 hole_bars_real = hole_bars WITH EDGE (LENGTH hole_bars_len <= 0.9)
 hole_bars_vias_sq = V1N INTERACT ((hole_bars_real INTERACT hole_area_real == 2) NOT ENCLOSE RV1)
 err1 = hole_bars_real INTERACT hole_bars_vias_sq == 1
 err1 NOT INSIDE SealR_NOT_BULK
}
 
Vy1_R_7 {
@ (Vy OR RVy) overlap MTFUSE is not allowed, except V3
 err1 = V1 AND MTFUSE
 err1 NOT INSIDE SealR_NOT_BULK
}
// Vy.R.8[NC] Vy pattern must be drawn on data type 40
 
Vy1_R_9 {
@ It's not allowed Vy overlap with the metal resistor directly underneath and above the Vy
 err1 = V1 AND (M1RES AND M1)
 err2 = V1 AND (M2RES AND M2)
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

#IFDEF RECOMMENDED_CHECK YES

 
Vy1_R_10_R {
@ Recommend space between a square Vy and another (Vy OR RVy OR DUM_Vy) < 4um to avoid single square Vy
 ALL_VIA_CHECK = OR V1_SR DUM_V1
 STEP_1 = SIZE V1_SR BY 1.4
 // 4/1.414 = 2.828
 STEP_1_GOOD = STEP_1 INTERACT ALL_VIA_CHECK > 1
 STEP_1_FILTER = V1N NOT INTERACT STEP_1_GOOD
 err1 = STEP_1_FILTER NOT WITH EDGE (EXT [STEP_1_FILTER] ALL_VIA_CHECK < 4 PERP ALSO)
 err1 NOT INSIDE SealR_NOT_BULK
}

#ENDIF


// =======================================================
// Square Vy design rules
// =======================================================

GROUP GVy2 Vy2_?

#IFDEF MANUFACTURABILITY_ENHANCEMENT_RULES YES

//;beginning of the Vy.EN.2a derivations
met_Vy_2_2a_ME = M2 WITH WIDTH < 0.050
via_Vy_2_2a_ME = 1XV2N INTERACT met_Vy_2_2a_ME
via_Vy_2_2a_bad_ME = RECTANGLE ENCLOSURE via_Vy_2_2a_ME M2 ABUT<90 SINGULAR OUTSIDE ALSO 
GOOD 0 0.032 OPPOSITE 0 0.032 OPPOSITE
via_Vy_2_2a_good_ME = via_Vy_2_2a_ME NOT via_Vy_2_2a_bad_ME
//;end of the Vy.EN.2a derivations
 
Vy2_EN_2a_ME {
@ Vy enclosure by M1 or Mxy (width < 0.05um) for two opposite sides with the other two side >= 0um (M1/Mxy is the metal underneath Vy), except INST region >= 0.032um
 err1 = via_Vy_2_2a_bad_ME NOT via_Vy_2_2c_good_ME
 err1 NOT INSIDE INST
}
 
//;beginning of the Vy.EN.2c derivations
met_Vy_2_2c_ME = M2 WITH WIDTH >= 0.050
via_Vy_2_2c_ME = 1XV2N INTERACT met_Vy_2_2c_ME
via_Vy_2_2c_bad_ME = RECTANGLE ENCLOSURE via_Vy_2_2c_ME M2 ABUT<90 SINGULAR 
GOOD 0.009 0.025 OPPOSITE 0.009 0.025 OPPOSITE
via_Vy_2_2c_good_ME = via_Vy_2_2c_ME NOT via_Vy_2_2c_bad_ME
//;end of the Vy.EN.2c derivations
 
Vy2_EN_2c_ME {
@ Vy enclosure by M1 or Mxy (width >= 0.05um) for two opposite sides with the other two side >= 0.009um (M1/Mxy is the metal underneath Vy), except INST region >= 0.025um
 err1 = via_Vy_2_2c_bad_ME NOT via_Vy_2_2a_good_ME
 err1 NOT INSIDE INST
}
 
//;beginning of the Vy.EN.16a derivations
met_Vy2_16a_ME = M3 WITH WIDTH == 0.032
via_Vy2_16a_ME = 1XV2N INTERACT met_Vy2_16a_ME
via_Vy2_16a_ME_bad = RECTANGLE ENCLOSURE via_Vy2_16a_ME M3 ABUT<90 SINGULAR 
GOOD 0 0.039 OPPOSITE 0 0.039 OPPOSITE
via_Vy2_16a_ME_good = via_Vy2_16a_ME NOT via_Vy2_16a_ME_bad
//;beginning of the Vy.EN.16a derivations
 
Vy2_EN_16a_ME {
@ Vy enclosure by Mxy+1 (width = 0.032um) for two opposite sides with the other two sides >= 0um, except INST region >= 0.039um
 err1 = COPY via_Vy2_16a_ME_bad
 err1 NOT INSIDE INST
}

#ENDIF

 
Vy2_BAR = (OR V2_BAR_100_all V2_BAR_450_all) INSIDE MARKS_MARKG
 
Vy2_W_1 {
@ Vy width and length (except 0.032*0.08um RVy, MARKS, MARKG, INDMY and LOGO region) = 0.032um
 err1 = (V2 NOT RV2) NOT 1XV2N
 err1 NOT INSIDE MARKS_MARKG_INDMY_LOGO
}
 
Vy2_W_2 {
@ Vy bar width in MARKS and MARKG regions = 0.1, 0.45um
 err1 = (V2 NOT (OR V2_SR V2_BAR_100_all V2_BAR_450_all V2N_Seal_Ring)) INSIDE MARKS_MARKG
 err1 NOT INSIDE SealR_NOT_BULK
}
 
Vy2_S_1 {
@ Space between two (Vy or RVy), except Vy.S.1a >= 0.069um
 err1 = EXT V2_SR < 0.069 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
Vy2_S_2 {
@ Space between two square Vy when PRL > -0.032um, except V1 in INST region, DRC only flag the point-to-point space when PRL <= 0. >= 0.082um
 err1 = EXT V2N < 0.082 ABUT<90 OPPOSITE EXTENDED 0.001 REGION
 err2_RAW = EXT V2N < 0.082 ABUT<90 CORNER TO CORNER
 err2_TMP = DFM PROPERTY err2_RAW [-= (EWXP(err2_RAW) < 0.032 || EWYP(err2_RAW) < 0.032) ? 1 : 0] > 0
 err2 = DFM COPY err2_TMP REGION
 // 
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}
 
Vy2_S_3 {
@ Space between square Vy and RVy >= 0.082um
 err1 = EXT V2N RV2 < 0.082 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
Vy2_S_4 {
@ Space between Vy and Vy-1 (including V0) at different net and PRL > 0um. >= 0.038um
@ When:
@ Mxy+1/1.25xMy enclosure of Vy > 0um
 // (include V0)
 chk_via = (V2 AND (V2N INSIDE M3)) NOT COIN EDGE M3
 err1 = EXT chk_via V1 < 0.038 ABUT<90 OPPOSITE REGION NOT CONNECTED
 err1 NOT INSIDE SealR_NOT_BULK
}
 
Vy2_S_5 {
@ Space between Vy and Mxy (including M1) at different net, except V1 in INST region >= 0.037um
@ When:
@ 1. Mxy (including M1) enclosure of Vy < 0.003um
@ 2. Mxy+1/1.25xMy width > 0.038um
 y1 = V2 AND (V2N NOT OUTSIDE (M3 WITH WIDTH > 0.038))
 y2 = EXT [y1] M2 < 0.037 ABUT<90 MEASURE ALL NOT CONNECTED
 y3 = ENC [y2] M2 < 0.003 ABUT<90 OPPOSITE
 err1 = EXT (y1 COIN EDGE y3) M2 < 0.037 ABUT<90 MEASURE ALL NOT CONNECTED REGION
 // 
 err1 NOT INSIDE SealR_NOT_BULK
}
 
Vy2_S_6 {
@ Projection space between Vy and the Mxy+1/1.25xMy concave corner >= 0.029um
@ When:
@ 1. Mxy+1/1.25xMy width < 0.035um, form one edge of concave corner
@ 2. Vy enclosure by Mxy+1/1.25xMy <= 0.002um at opposite side of Mxy+1/1.25xMy concave corner
@ 3. The length of another edge of concave corner > 0.005um
@ Via inside the cross region with vertex enclosure <= 0.001um is not allowed
 // for via not totally inside cross region
 min_enc_met_side = M3 TOUCH EDGE (ENC V2N [M3] <= 0.002 ABUT<90 OPPOSITE)
 min_wid_met_side = M3 TOUCH EDGE (INT min_enc_met_side [M3_convex_lt_two_edges] < 0.035 OPPOSITE)
 min_wid_met_corn = EXT min_wid_met_side (LENGTH M3_convex_lt_two_edges > 0.005) < 0.001 ABUT INTERSECTING ONLY REGION
 min_wid_met_side_c = min_wid_met_side TOUCH EDGE min_wid_met_corn
 min_wid_met_corn_c = M3 TOUCH EDGE min_wid_met_corn
 min_wid_met_side_opp = M3 TOUCH EDGE (INT min_wid_met_side_c [M3] < 0.035 OPPOSITE)
 min_wid_met_area_opp = INT min_wid_met_side_c M3 < 0.035 OPPOSITE REGION
 // 
 min_enc_via_s = ENC [V2N] min_wid_met_side_opp <= 0.002 ABUT<90 OPPOSITE
 min_enc_via_c = V2N WITH EDGE min_enc_via_s
 min_met_corn = min_wid_met_corn_c COIN EDGE (M3 ENCLOSE min_enc_via_c)
 via_err_edge_outer = EXT [min_enc_via_c] min_met_corn < 0.029 ABUT<90 OPPOSITE EXTENDED 0.035-0.032+GLOBAL_TOLERANCE MEASURE ALL
 via_err_edge_inner = EXT [min_enc_via_c] min_wid_met_corn < 0.029 ABUT<90 OPPOSITE EXTENDED 0.035-0.032+GLOBAL_TOLERANCE EXCLUDE SHIELDED
 via_err_edge_all = OR EDGE via_err_edge_outer via_err_edge_inner
 err1 = min_enc_via_c WITH EDGE via_err_edge_all
 err1 NOT INSIDE SealR_NOT_BULK
 // 
 min_wid_met_all = INT M3 M3_convex_lt_two_edges < 0.035 OPPOSITE REGION
 // SETLAYER min_wid_met_rvs = DRC:1 NOT M3
 // SETLAYER err2 = (V2N INTERACT min_wid_met_all SINGULAR ALSO) INTERACT min_wid_met_rvs SINGULAR ONLY // point touch via
 err2 = ENC (V2N INTERACT min_wid_met_all SINGULAR ALSO) M3 < 0.0005 SINGULAR REGION
 err2 NOT INSIDE SealR_NOT_BULK
 // 
 met_corner_corss = (EXT M3_convex_lt_two_edges M3 < 0.001 ABUT==90 INTERSECTING ONLY REGION) COIN EDGE min_wid_met_all
 via_inside_corss = ((V2N NOT WITH EDGE (ENC [V2N] M3 < 0.001 ABUT>0<90 SINGULAR)) NOT WITH EDGE via_err_edge_all) NOT INSIDE min_wid_met_all
 via_inside_corss_enc = EXT [via_inside_corss] met_corner_corss <= 0.001 PROJ==0 PARA ONLY OPPOSITE EXTENDED 0.002
 err3 = via_inside_corss INTERACT (INT via_inside_corss_enc <= 0.032 OPPOSITE REGION) // via inside cross must be enclosed by the short side of metal (width< 0.035) >= 0.001
 err3 NOT INSIDE SealR_NOT_BULK
}
 
Vy2_S_8 {
@ Space between Vy bar (width = 0.1/0.45um) and (Vy or RVy) >= 0.34um
 err1 = EXT (OR V2_BAR_100_all V2_BAR_450_all) V2_SR < 0.34 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
Vy2_S_9 {
@ Space between two Vy bar (width = 0.1/0.45um), DRC only check the space between parallel edge when the Vy bar is inside MARKS >= 0.55um
 // SETLAYER waive_shape = EXT (OR V2_BAR_100_all V2_BAR_450_all) < 0.55 ABUT<90 SINGULAR REGION INTERSECTING ONLY
 err1 = EXT ((OR V2_BAR_100_all V2_BAR_450_all) INTERACT MARKS_MARKG) < 0.55 ANGLED!=1 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 

#IFDEF DFM_RULES_PRIORITY_1 YES

 
Vy2_EN_1_DFM1 {
@ Recommended square Vy enclosure by M1/Mxy is defined by either Vy.EN.2.DFM or Vy.EN.3.DFM or Vy.EN.2b.DFM
 err1 = 1XV2N NOT INSIDE M2
 err1 NOT INSIDE SealR_NOT_BULK
}
 
//;beginning of the Vy.EN.2.DFM derivations
via_Vy_2_2_R_bad = RECTANGLE ENCLOSURE 1XV2N M2 ABUT<90 SINGULAR 
GOOD 0.007 0.050 OPPOSITE 0.007 0.050 OPPOSITE
via_Vy_2_2_R_good = 1XV2N NOT via_Vy_2_2_R_bad
//;end of the Vy.EN.2.DFM derivations
 
Vy2_EN_2_DFM1 {
@ Recommended square Vy enclosure by M1/Mxy for two opposite sides with the other two sides >= 0.007um, except FUSEMK1 region. >= 0.05um
 err1 = (via_Vy_2_2_R_bad NOT via_Vy_2_3_R_good) NOT INSIDE FUSEMK1
 err1 NOT INSIDE SealR_NOT_BULK
}
 
Vy2_EN_2b_DFM1 {
@ Recommended enclosure by M1 or Mxy (width < 0.05um) along width direction must be equal or 1nm difference (M1/Mxy is the metal underneath Vy.)
 chk_Mxy = (INT [M2] < 0.05 ABUT<90 OPPOSITE) TOUCH EDGE (M2 WITH WIDTH < 0.05)
 side_en = ENC V2N chk_Mxy < 0.018 ABUT<90 OPPOSITE
 side_en_EDGE = ENC [V2N] chk_Mxy < 0.018 ABUT<90 OPPOSITE
 err1 = DFM PROPERTY V2N side_en OVERLAP ABUT ALSO MULTI [-= COUNT(side_en)] >= 2 [+= ((MIN(EW(side_en)) == MAX(EW(side_en))) || (MIN(EW(side_en)) == ABS(MAX(EW(side_en)) - 0.001))) ? 1 : 0] == 0
 err1 NOT INSIDE SealR_NOT_BULK
}
 
//;beginning of the Vy.EN.3.DFM derivations
via_Vy_2_3_R_bad = RECTANGLE ENCLOSURE 1XV2N M2 ABUT<90 SINGULAR 
GOOD 0.02 0.02 0.02 0.02 OPPOSITE
via_Vy_2_3_R_good = 1XV2N NOT via_Vy_2_3_R_bad
//;end of the Vy.EN.3.DFM derivations
 
Vy2_EN_3_DFM1 {
@ Recommended square Vy enclosure by M1, Mxy for all sides to avoid high Rc, except FUSEMK1 region >= 0.02um
 err1 = (via_Vy_2_3_R_bad NOT via_Vy_2_2_R_good) NOT INSIDE FUSEMK1
 err2 = ((ENC [1XV2N] M2 < 0.02 ABUT<90 SINGULAR) NOT TOUCH EDGE via_Vy_2_2_R_good) NOT INSIDE EDGE FUSEMK1
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE EDGE SealR_NOT_BULK
}

#ENDIF

 
Vy2_EN_1 {
@ 1X square Vy must be fully enclosed by M1 or Mxy
@ where M1/Mxy is the metal layer directly underneath Vy, Vy enclosure by M1 or Mxy must follow either Vy.EN.2 or Vy.EN.3
 err1 = 1XV2N NOT M2
 err1 NOT INSIDE SealR_NOT_BULK
}
 
//;beginning of the Vy.EN.2 derivations
via_Vy_2_2_bad = RECTANGLE ENCLOSURE 1XV2N M2 ABUT<90 SINGULAR OUTSIDE ALSO 
GOOD 0 0.024 OPPOSITE 0 0.024 OPPOSITE
via_Vy_2_2_good = 1XV2N NOT via_Vy_2_2_bad
//;end of the Vy.EN.2 derivations
 
//;beginning of the Vy.EN.3 derivations
via_Vy_2_3_bad = RECTANGLE ENCLOSURE 1XV2N M2 ABUT<90 SINGULAR OUTSIDE ALSO 
GOOD 0.015 0.015 0.015 0.015 OPPOSITE
via_Vy_2_3_good = 1XV2N NOT via_Vy_2_3_bad
via_Vy_2_2_3_good = OR via_Vy_2_2_good via_Vy_2_3_good
//;end of the Vy.EN.3 derivations
 
Vy2_EN_2_3 {
@ Vy.EN.2: Vy enclosure by M1 or Mxy when enclosure by M1 or Mxy on either perpendicular direction >= 0um, except V1 in INST region >= 0.024um
@ Vy.EN.3: Vy enclosure by M1 or Mxy for all sides, except V1 in INST region >= 0.015
 err1 = via_Vy_2_2_bad NOT via_Vy_2_2_3_good
 // 
 err1 NOT INSIDE SealR_NOT_BULK
}
 
Vy2_EN_4 {
@ Vy enclosure by Mxy in adjacent S1 side, where Mxy is the metal layer directly underneath Vy >= 0.004um
@ When:
@ 1. Mxy width W: 0.036um <= W <= 0.041um
@ 2. Space: 0.058um <= S1 < 0.063um, the PRL >= 0.083um
@ 3. The opposite space S2 >= 0.069um
 met_wid_all = M2 WITH WIDTH > 0.036-GLOBAL_TOLERANCE <= 0.041
 met_err_RAW_a = EXT [met_wid_all] M2 >= 0.058 < 0.063 ABUT<90 OPPOSITE MEASURE ALL
 met_err_RAW_b = EXT met_wid_all M2 >= 0.058 < 0.063 ABUT<90 OPPOSITE MEASURE ALL
 met_err_RAW_c = EXT met_wid_all [M2] >= 0.058 < 0.063 ABUT<90 OPPOSITE MEASURE ALL
 met_err_PRL = DFM PROPERTY met_err_RAW_b met_err_RAW_c OVERLAP ABUT ALSO MULTI [-= max(LENGTH(met_err_RAW_c))] >= 0.083
 // 
 met_err_EGE_a = met_err_RAW_a COIN EDGE (DFM COPY met_err_PRL EDGE)
 met_err_EGE_b = ENC V2N [met_err_EGE_a] < 0.004 ABUT<90 OPPOSITE
 met_err_EGE_c = INT met_err_EGE_b [M2] > 0.036-GLOBAL_TOLERANCE <= 0.041 ABUT<90 OPPOSITE MEASURE COIN
 met_err_EGE_d = EXT (met_err_EGE_c) M2 < 0.069 ABUT<90 OPPOSITE
 met_err_EGE_e = met_err_EGE_b COIN EDGE M2
 err1 = INT met_err_EGE_d [met_err_EGE_e] > 0.036-GLOBAL_TOLERANCE <= 0.041 ABUT<90 OPPOSITE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
Vy2_EN_5 {
@ Vy enclosure by Mxy in adjacent S1 side, where Mxy is the metal layer directly underneath Vy >= 0.004um
@ When:
@ 1. Mxy width W: 0.042um < W <= 0.05um
@ 2. Space: 0.058um <= S1 <= 0.067um, the PRL >= 0.083um
 met_wid_all = M2 WITH WIDTH > 0.042 <= 0.05
 met_err_RAW_TMP = EXT met_wid_all [M2] >= 0.058 < 0.067+GLOBAL_TOLERANCE ABUT<90 OPPOSITE MEASURE ALL
 met_err_RAW = EXT met_err_RAW_TMP [M2] >= 0.058 < 0.067+GLOBAL_TOLERANCE ABUT<90 OPPOSITE
 // 
 met_jog_ALL = M2_convex_eq_one_edges NOT COIN EDGE met_err_RAW
 met_jog_EXP_a = EXPAND EDGE met_jog_ALL INSIDE BY 0.0005
 met_jog_EXP_b = EXPAND EDGE met_jog_ALL OUTSIDE BY 0.0005
 met_jog_TMP = (met_jog_ALL COIN EDGE (met_jog_EXP_a WITH EDGE met_err_RAW)) COIN EDGE (met_jog_EXP_b WITH EDGE met_err_RAW)
 met_jog_EXP = ((VERTEX (EXPAND EDGE met_jog_TMP OUTSIDE BY 0.001 EXTEND BY 0.001) == 4) OR (EXPAND EDGE met_err_RAW OUTSIDE BY 0.001)) NOT M2
 // 
 met_err_PRL = DFM PROPERTY met_jog_EXP met_err_RAW met_wid_all OVERLAP ABUT ALSO MULTI [-= LENGTH(met_err_RAW)] >= 0.083 [+= COUNT(met_wid_all)] > 0
 met_err_EGE = M2 COIN EDGE (met_err_RAW COIN EDGE (met_err_PRL COIN EDGE met_wid_all))
 err1 = ENC [V2N] met_err_EGE < 0.004 ABUT<90 OPPOSITE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
Vy2_EN_8 {
@ Vy enclosure by Mxy in adjacent S1 side, where Mxy is the metal layer directly underneath Vy >= 0.004um
@ When:
@ 1. Mxy width W: 0.051um <= W <= 0.112um
@ 2. Space: 0.058um <= S1 <= 0.094um, the PRL >= 0.083um
@ DRC doesn't check Vy:
@ a) Two Vys with space <= 0.1um in Mxy and 1.25xMy/Mxy+1 intersection region.
@ b) One Vy and one rectangular Vy with space <= 0.1um in Mxy and 1.25xMy/Mxy+1 intersection region
 met_wid_all = M2 WITH WIDTH > 0.051-GLOBAL_TOLERANCE <= 0.112
 met_err_RAW_TMP = EXT met_wid_all [M2] >= 0.058 < 0.094+GLOBAL_TOLERANCE ABUT<90 OPPOSITE MEASURE ALL
 met_err_RAW = EXT met_err_RAW_TMP [M2] >= 0.058 < 0.094+GLOBAL_TOLERANCE ABUT<90 OPPOSITE
 // 
 met_jog_ALL = M2_convex_eq_one_edges NOT COIN EDGE met_err_RAW
 met_jog_EXP_a = EXPAND EDGE met_jog_ALL INSIDE BY 0.0005
 met_jog_EXP_b = EXPAND EDGE met_jog_ALL OUTSIDE BY 0.0005
 met_jog_TMP = (met_jog_ALL COIN EDGE (met_jog_EXP_a WITH EDGE met_err_RAW)) COIN EDGE (met_jog_EXP_b WITH EDGE met_err_RAW)
 met_jog_EXP = ((VERTEX (EXPAND EDGE met_jog_TMP OUTSIDE BY 0.001 EXTEND BY 0.001) == 4) OR (EXPAND EDGE met_err_RAW OUTSIDE BY 0.001)) NOT M2
 // 
 met_err_PRL = DFM PROPERTY met_jog_EXP met_err_RAW met_wid_all OVERLAP ABUT ALSO MULTI [-= LENGTH(met_err_RAW)] >= 0.083 [+= COUNT(met_wid_all)] > 0
 met_err_EGE = M2 COIN EDGE (met_err_RAW COIN EDGE (met_err_PRL COIN EDGE met_wid_all))
 via_group_all = SIZE V2 BY 0.05 INSIDE OF (M2 AND M3) STEP 0.02
 via_group_real = V2 INTERACT (via_group_all INTERACT V2 >= 2)
 err1 = ENC (V2N NOT via_group_real) met_err_EGE < 0.004 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
Vy2_EN_9 {
@ Vy enclosure by M1/Mxy in adjacent S1 side, where M1/Mxy is the metal layer directly underneath Vy >= 0.004um
@ When:
@ 1. M1/Mxy dimension along enclosure direction: 0.113um <= L <= 0.201um
@ 2. Space: 0.058um <= S1 <= 0.094um, the PRL >= 0.083um
 met_wid_all = INT [M2] > 0.113-GLOBAL_TOLERANCE <= 0.201 ABUT<90 OPPOSITE EXCLUDE SHIELDED
 met_err_RAW = EXT [met_wid_all] M2 >= 0.058 < 0.094+GLOBAL_TOLERANCE ABUT<90 OPPOSITE
 met_jog_ALL = M2_convex_eq_one_edges NOT COIN EDGE met_err_RAW
 met_jog_EXP_a = EXPAND EDGE met_jog_ALL INSIDE BY 0.0005
 met_jog_EXP_b = EXPAND EDGE met_jog_ALL OUTSIDE BY 0.0005
 met_jog_TMP = (met_jog_ALL COIN EDGE (met_jog_EXP_a WITH EDGE met_err_RAW)) COIN EDGE (met_jog_EXP_b WITH EDGE met_err_RAW)
 met_jog_EXP = ((VERTEX (EXPAND EDGE met_jog_TMP OUTSIDE BY 0.001 EXTEND BY 0.001) == 4) OR (EXPAND EDGE met_err_RAW OUTSIDE BY 0.001)) NOT M2
 // 
 met_err_PRL = DFM PROPERTY met_jog_EXP met_err_RAW OVERLAP ABUT ALSO MULTI [-= LENGTH(met_err_RAW)] >= 0.083
 met_err_EGE = M2 COIN EDGE (met_err_RAW COIN EDGE met_err_PRL)
 err1 = ENC V2N met_err_EGE < 0.004 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
Vy2_EN_10 {
@ Vy enclosure by M1/Mxy in adjacent S1 side, where M1/Mxy is the metal layer directly underneath Vy >= 0.014um
@ When:
@ 1. M1/Mxy width W: dimension along enclosure direction L >= 0.202um
@ 2. Space: 0.058um <= S1 <= 0.094um, PRL >= 0.083um
 met_wid_all = INT (M2) <= 0.202-GLOBAL_TOLERANCE ABUT<90 OPPOSITE EXCLUDE SHIELDED
 met_err_RAW = EXT [met_wid_all] M2 >= 0.058 < 0.094+GLOBAL_TOLERANCE ABUT<90 OPPOSITE
 met_jog_ALL = M2_convex_eq_one_edges NOT COIN EDGE met_err_RAW
 met_jog_EXP_a = EXPAND EDGE met_jog_ALL INSIDE BY 0.0005
 met_jog_EXP_b = EXPAND EDGE met_jog_ALL OUTSIDE BY 0.0005
 met_jog_TMP = (met_jog_ALL COIN EDGE (met_jog_EXP_a WITH EDGE met_err_RAW)) COIN EDGE (met_jog_EXP_b WITH EDGE met_err_RAW)
 met_jog_EXP = ((VERTEX (EXPAND EDGE met_jog_TMP OUTSIDE BY 0.001 EXTEND BY 0.001) == 4) OR (EXPAND EDGE met_err_RAW OUTSIDE BY 0.001)) NOT M2
 // 
 met_err_PRL = DFM PROPERTY met_jog_EXP met_err_RAW OVERLAP ABUT ALSO MULTI [-= LENGTH(met_err_RAW)] >= 0.083
 met_err_EGE = M2 COIN EDGE (met_err_RAW COIN EDGE met_err_PRL)
 err1 = ENC V2N met_err_EGE < 0.014 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
Vy2_EN_11 {
@ Vy bar must fully enclosure by Mxy (including M1) where Mxy is the metal layer directly underneath Vy bar >= 0.2um
 err1 = ENC V2_BAR_100_all M2 < 0.2 ABUT<90 SINGULAR REGION OUTSIDE ALSO
 err2 = ENC V2_BAR_450_all M2 < 0.2 ABUT<90 SINGULAR REGION OUTSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}
 

#IFDEF DFM_RULES_PRIORITY_1 YES

 
Vy2_EN_14_DFM1 {
@ Recommended square Vy fully enclosure by Mxy+1/1.25xMy is defined by either Vy.EN.16.DFM, Vy.EN.16a.DFM or Vy.EN.16b.DFM, which Mxy+1/1.25xMy is the metal layer directly above Vy
 err1 = 1XV2N NOT INSIDE M3
 err1 NOT INSIDE SealR_NOT_BULK
}
 
//;beginning of the Vy.EN.16.DFM derivations
via_Vy_2_16_R_bad = RECTANGLE ENCLOSURE 1XV2N M3 ABUT<90 SINGULAR OUTSIDE ALSO 
GOOD 0.020 0.020 0.020 0.020 OPPOSITE
via_Vy_2_16_R_good = 1XV2N NOT via_Vy_2_16_R_bad
//;end of the Vy.EN.16.DFM derivations
 
Vy2_EN_16_DFM1 {
@ Recommended square Vy enclosure by Mxy+1/1.25xMy for all sides >= 0.02um
 err1 = via_Vy_2_16_R_bad NOT (OR via_Vy_2_16a_R_good via_Vy_2_16b_R_good)
 err2 = (ENC [1XV2N] M3 < 0.02 ABUT<90 SINGULAR) NOT TOUCH EDGE (OR via_Vy_2_16a_R_good via_Vy_2_16b_R_good)
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE EDGE SealR_NOT_BULK
}
 
//;beginning of the Vy.EN.16a.DFM derivations
met_Vy2_16a_R = M3 WITH WIDTH < 0.05
via_Vy2_16a_R = 1XV2N NOT OUTSIDE met_Vy2_16a_R
via_Vy_2_16a_R_bad = RECTANGLE ENCLOSURE via_Vy2_16a_R M3 ABUT<90 SINGULAR 
GOOD 0.007 0.050 OPPOSITE 0.007 0.050 OPPOSITE
via_Vy_2_16a_R_good = via_Vy2_16a_R NOT via_Vy_2_16a_R_bad
//;end of the Vy.EN.16a.DFM derivations
 
Vy2_EN_16a_DFM1 {
@ Recommended square Vy enclosure by Mxy+1/1.25xMy (width < 0.05um) for two opposite sides with the other two sides >= 0.007um. >= 0.05um
 err1 = via_Vy_2_16a_R_bad NOT (OR via_Vy_2_16_R_good via_Vy_2_16b_R_good)
 err1 NOT INSIDE SealR_NOT_BULK
}
 
//;beginning of the Vy.EN.16b.DFM derivations
via_Vy2_16b_R = (1XV2N OUTSIDE met_Vy2_16a_R) NOT OUTSIDE M3
via_Vy_2_16b_R_bad = RECTANGLE ENCLOSURE via_Vy2_16b_R M3 ABUT<90 SINGULAR 
GOOD 0.009 0.050 OPPOSITE 0.009 0.050 OPPOSITE
via_Vy_2_16b_R_good = via_Vy2_16b_R NOT via_Vy_2_16b_R_bad
//;end of the Vy.EN.16.DFM derivations
 
Vy2_EN_16b_DFM1 {
@ Recommended square Vy enclosure by Mxy+1/1.25xMy (width >= 0.05um) for two opposite sides with the other two sides >= 0.009um. >= 0.05um
 err1 = via_Vy_2_16b_R_bad NOT (OR via_Vy_2_16_R_good via_Vy_2_16a_R_good)
 err1 NOT INSIDE SealR_NOT_BULK
}

#ENDIF

 
//;beginning of the Vy.EN.13 derivations
via_Vy2_13_bad = RECTANGLE ENCLOSURE 1XV2N M3 ABUT<90 SINGULAR OUTSIDE ALSO 
GOOD 0.015 0.015 0.015 0.015 OPPOSITE
via_Vy_2_13_good = 1XV2N NOT via_Vy2_13_bad
//;beginning of the Vy.EN.13 derivations
 
Vy2_EN_12_13 {
@ 1X square Vy must be fully enclosure by Mxy+1/1.25xMy where Mxy+1/1.25xMy is the metal layer directly above Vy
@ Enclosure by Mxy+1/1.25x My must follow one of Vy.En.15 or Vy.EN.16 or Vy.EN.16a or Vy.EN.16b or Vy.EN.16c or Vy.EN.16d or Vy.EN.16e or Vy.EN.16f or Vy.EN.16g or Vy.EN.17 or Vy.EN.18 or Vy.EN.19 or Vy.EN.20 or Vy.EN.21
@ Vy.EN.13: Vy enclosure by Mxy+1 for all sides >= 0.015um
 err1 = 1XV2N NOT M3
 err1 NOT INSIDE SealR_NOT_BULK
}
 
//;beginning of the Vy.EN.16a derivations
met_Vy2_16a = M3 WITH WIDTH > 0.032 <= 0.046
via_Vy2_16a = (1XV2N INTERACT met_Vy2_16a) NOT via_Vy2_16f_16g_good
via_Vy2_16a_bad = RECTANGLE ENCLOSURE via_Vy2_16a M3 ABUT<90 SINGULAR 
GOOD 0.003 0.032 OPPOSITE 0.003 0.047 OPPOSITE
via_Vy2_16a_good = via_Vy2_16a NOT via_Vy2_16a_bad
//;beginning of the Vy.EN.16a derivations
 
Vy2_EN_16a {
@ Vy enclosure by Mxy+1 (0.032um < short side of Mxy+1 width <= 0.046um) for opposite side >= 0.032um with the two sides >= 0.003um, except V1 in INST region >= 0.047um
 err1 = copy via_Vy2_16a_bad
 err1 NOT INSIDE SealR_NOT_BULK
}
 
//;beginning of the Vy.EN.16b derivations
met_Vy2_16b = M3 WITH WIDTH > 0.046 <= 0.09
via_Vy2_16b_TMP = 1XV2N INTERACT met_Vy2_16b
via_Vy2_16b = via_Vy2_16b_TMP NOT (OR via_Vy_2_13_good via_Vy2_16a_good via_Vy2_16f_16g_good)
via_Vy2_16b_bad = RECTANGLE ENCLOSURE via_Vy2_16b M3 ABUT<90 SINGULAR 
GOOD 0.008 0.024 OPPOSITE 0.008 0.024 OPPOSITE
via_Vy2_16b_good = via_Vy2_16b NOT via_Vy2_16b_bad
//;beginning of the Vy.EN.16b derivations
 
Vy2_EN_16b {
@ Vy enclosure by Mxy+1 for two opposite sides with the other two sides >= 0.008um (0.046um < short side of Mxy+1 width <= 0.09um), except V1 in INST region >= 0.024um
 err1 = copy via_Vy2_16b_bad
 err1 NOT INSIDE SealR_NOT_BULK
}
 
//;beginning of the Vy.EN.16c derivations
met_Vy2_width_096_200 = M3 WITH WIDTH > 0.09 <= 0.2
met_Vy2_16c = copy met_Vy2_width_096_200
via_Vy2_16c_TMP = 1XV2N INTERACT met_Vy2_16c
via_Vy2_16c = via_Vy2_16c_TMP NOT (OR via_Vy_2_13_good via_Vy2_16a_good via_Vy2_16b_good via_Vy2_16f_16g_good)
via_Vy2_16c_bad = RECTANGLE ENCLOSURE via_Vy2_16c M3 ABUT<90 SINGULAR 
GOOD 0.014 0.024 OPPOSITE 0.014 0.024 OPPOSITE
via_Vy2_16c_good = via_Vy2_16c NOT via_Vy2_16c_bad
//;end of the Vy.EN.16c derivations
 
//;beginning of the Vy.EN.16d derivations
met_Vy2_16d = copy met_Vy2_width_096_200
via_Vy2_16d_TMP_1 = 1XV2N INTERACT met_Vy2_16d
via_Vy2_16d_TMP = via_Vy2_16d_TMP_1 NOT (OR via_Vy_2_13_good via_Vy2_16a_good via_Vy2_16b_good via_Vy2_16f_16g_good)
via_Vy2_16d_bad_TMP = RECTANGLE ENCLOSURE via_Vy2_16d_TMP M3 ABUT<90 SINGULAR 
GOOD 0 0.009 OPPOSITE 0 0.024 OPPOSITE
via_Vy2_16d = via_Vy2_16d_TMP NOT via_Vy2_16d_bad_TMP
via_Vy2_16d_bad = RECTANGLE ENCLOSURE via_Vy2_16d M3 ABUT<90 SINGULAR 
GOOD 0.009 OPPOSITE 0.024 OPPOSITE 0.058 OPPOSITE 0.058 OPPOSITE 
GOOD 0.024 OPPOSITE 0.009 OPPOSITE 0.058 OPPOSITE 0.058 OPPOSITE
via_Vy2_16d_good = via_Vy2_16d NOT via_Vy2_16d_bad
//;end of the Vy.EN.16d derivations
via_Vy2_16_abcd_good = OR via_Vy2_16a_good via_Vy2_16b_good via_Vy2_16c_good via_Vy2_16d_good
 
Vy2_EN_16c {
@ Vy enclosure by Mxy+1 for two opposite sides with the other two sides >= 0.014um (0.09um < short side of Mxy+1 width <= 0.2um), except V1 in INST region >= 0.024um
 err1 = via_Vy2_16c_bad NOT via_Vy2_16d_good // exclude Vy.en.16d
 err2 = ENC via_Vy2_16c M3 < 0.009 ABUT<90 SINGULAR REGION
 // 
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}
 
Vy2_EN_16d {
@ Vy enclosure by Mxy+1 for at least two adjacent edges with the other two sides >= 0.024um and >= 0.009um (0.09um < short side of Mxy+1 width <= 0.2um), except V1 in INST region >= 0.058um
 err1 = via_Vy2_16d_bad NOT via_Vy2_16c_good // exclude Vy.en.16c
 err2 = ENC via_Vy2_16d M3 < 0.009 ABUT<90 SINGULAR REGION
 // 
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}
 
//;beginning of the Vy.EN.16e derivations
met_Vy2_16e = M3 WITH WIDTH > 0.2
via_Vy2_16e_TMP = 1XV2N INTERACT met_Vy2_16e
via_Vy2_16e = via_Vy2_16e_TMP NOT (OR via_Vy_2_13_good via_Vy2_16_abcd_good via_Vy2_16f_16g_good)
via_Vy2_16e_bad = RECTANGLE ENCLOSURE via_Vy2_16e M3 ABUT<90 SINGULAR 
GOOD 0.014 0.024 OPPOSITE 0.014 0.024 OPPOSITE
via_Vy2_16e_good = via_Vy2_16e NOT via_Vy2_16e_bad
//;end of the Vy.EN.16e derivations
 
Vy2_EN_16e {
@ Vy enclosure by Mxy+1 for two opposite sides with the other two sides >= 0.014um (short side of Mxy+1 width > 0.2um) >= 0.024um
 err1 = copy via_Vy2_16e_bad
 err1 NOT INSIDE SealR_NOT_BULK
}
 
//;beginning of the Vy.EN.16f derivations
met_Vy2_16f_16g_t = M3 WITH WIDTH == 0.032
met_Vy2_16f_16g = met_Vy2_16f_16g_t INTERACT 1XV2N
met_Vy2_16f_16g_side = INT [met_Vy2_16f_16g] == 0.032 ABUT<90 OPPOSITE
via_Vy2_16f_16g = 1XV2N INTERACT met_Vy2_16f_16g
via_Vy2_16f_16g_non_iso_end = via_Vy2_16f_16g NOT TOUCH EDGE met_Vy2_16f_16g_side
via_Vy2_16f_16g_non_iso_side = via_Vy2_16f_16g TOUCH EDGE met_Vy2_16f_16g_side
via_Vy2_16f_16g_non_iso_s1 = EXT [via_Vy2_16f_16g_non_iso_end] M3 < 0.130 ABUT<90 OPPOSITE MEASURE ALL
via_Vy2_16f_16g_non_iso_s2 = EXT [via_Vy2_16f_16g_non_iso_side] M3 < 0.090 ABUT<90 OPPOSITE EXTENDED 0.13 MEASURE ALL
via_Vy2_16f_16g_non_iso_via = via_Vy2_16f_16g WITH EDGE (OR EDGE via_Vy2_16f_16g_non_iso_s1 via_Vy2_16f_16g_non_iso_s2)
via_Vy2_16f_16g_iso_via = via_Vy2_16f_16g NOT via_Vy2_16f_16g_non_iso_via
via_Vy2_16f_non_iso_bad_1 = RECTANGLE ENCLOSURE via_Vy2_16f_16g_non_iso_via M3 ABUT<90 SINGULAR 
GOOD 0 0.036 OPPOSITE 0 0.036 OPPOSITE
via_Vy2_16f_non_iso_bad_2 = RECTANGLE ENCLOSURE via_Vy2_16f_16g_non_iso_via M3 ABUT<90 SINGULAR 
GOOD 0 0.036 OPPOSITE 0 0.043 OPPOSITE 
GOOD 0 0.037 OPPOSITE 0 0.042 OPPOSITE 
GOOD 0 0.038 OPPOSITE 0 0.041 OPPOSITE 
GOOD 0 0.039 OPPOSITE 0 0.040 OPPOSITE
via_Vy2_16f_non_iso_good = via_Vy2_16f_16g_non_iso_via NOT (OR via_Vy2_16f_non_iso_bad_1 via_Vy2_16f_non_iso_bad_2)
//;end of the Vy.EN.16f derivations
 
//;beginning of the Vy.EN.16g derivations
via_Vy2_16g_iso_bad_1 = RECTANGLE ENCLOSURE via_Vy2_16f_16g_iso_via M3 ABUT<90 SINGULAR 
GOOD 0 0.030 OPPOSITE 0 0.030 OPPOSITE
via_Vy2_16g_iso_bad_2 = RECTANGLE ENCLOSURE via_Vy2_16f_16g_iso_via M3 ABUT<90 SINGULAR 
GOOD 0 0.030 OPPOSITE 0 0.039 OPPOSITE 
GOOD 0 0.031 OPPOSITE 0 0.038 OPPOSITE 
GOOD 0 0.032 OPPOSITE 0 0.037 OPPOSITE 
GOOD 0 0.033 OPPOSITE 0 0.036 OPPOSITE 
GOOD 0 0.034 OPPOSITE 0 0.035 OPPOSITE
via_Vy2_16g_iso_good = via_Vy2_16f_16g_iso_via NOT (OR via_Vy2_16g_iso_bad_1 via_Vy2_16g_iso_bad_2)
//;end of the Vy.EN.16g derivations
via_Vy2_16f_16g_good = OR via_Vy2_16f_non_iso_good via_Vy2_16g_iso_good
 
Vy2_EN_16f {
@ Total Vy enclosure by Mxy+1 (Mxy+1 width = 0.032um, both two opposite sides(EN1A/EN2A) >= 0.036um)with the other two sides >= 0um. >= 0.079um
 err1 = COPY via_Vy2_16f_non_iso_bad_1
 err2 = COPY via_Vy2_16f_non_iso_bad_2
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}
 
Vy2_EN_16g {
@ Total Vy enclosure by Mxy+1 (Mxy+1 width = 0.032um, both two opposite sides >= 0.03um) with the other two sides(EN1A/EN2A) >= 0um (for iso Vy condition only) >= 0.069um
@ Iso Vy condition definition:
@ S1 > 0.13um and S2 > 0.09um, where S1 is via space to metal in length direction and S2 is via space to metal in width direction
 err1 = COPY via_Vy2_16g_iso_bad_1
 err2 = COPY via_Vy2_16g_iso_bad_2
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}
 
Vy2_EN_25 {
@ Vy bar must fully enclosure by Mxy+1/1.25xMy where Mxy+1/1.25xMy is the metal layer directly above Vy bar >= 0.2um
 err1 = ENC V2_BAR_100_all M3 < 0.2 ABUT<90 SINGULAR REGION OUTSIDE ALSO
 err2 = ENC V2_BAR_450_all M3 < 0.2 ABUT<90 SINGULAR REGION OUTSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

#IFDEF RECOMMENDED_CHECK YES

 
Vy2_D_1_R {
@ (Vy OR RVy) density (window 5um*5um, stepping 2.5um) < 7.7%
 check_region = copy CHIP_NOT_MARKS
 check_pattern = (V2 NOT Vy2_BAR) AND check_region
 // 
 check_window1 = check_region WITH WIDTH >= 5/4
 err1_TMP1 = DENSITY check_pattern check_window1 check_region [!!AREA(check_window1)*AREA(check_pattern)/AREA(check_region)] >= 7.7/100 WINDOW 5 STEP 5/2 BACKUP INSIDE OF LAYER DRC:1 BY POLYGON
 // 
 check_window2 = WITH WIDTH (check_region AND err1_TMP1) >= 5/4
 err1_TMP2 = DENSITY check_pattern check_window2 check_region [!!AREA(check_window2)*AREA(check_pattern)/AREA(check_region)] >= 7.7/100 WINDOW 5 STEP 5/2 BACKUP INSIDE OF LAYER err1_TMP1 BY POLYGON
 // 
 check_window3 = WITH WIDTH (check_region AND err1_TMP2) >= 5/4
 DENSITY check_pattern check_window3 check_region [!!AREA(check_window3)*AREA(check_pattern)/AREA(check_region)] >= 7.7/100 WINDOW 5 STEP 5/2 BACKUP INSIDE OF LAYER err1_TMP2 BY POLYGON PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_Vy2_D_1_R.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_Vy2_D_1_R.rdb"
}

#ENDIF

 
Vy2_R_1 {
@ 45-degree (Vy OR RVy) is not allowed
 err1 = ANGLE (V2 NOT Vy2_BAR) > 44.5 < 45.5
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
Vy2_R_2 {
@ Single Vy is not allowed in H-shape Mxy+1/1.25xMy, when:
@ 1. The Mxy+1/1.25xMy has H-shape interacting with two metal holes: both two metal holes length <= 4.5um and two metal hole area <= 4.05um2
@ 2. The Vy overlaps on the center metal bar of this H-shape Mxy+1/1.25xMy
@ 3. The center metal bar length <= 0.9um and the metal bar width <= 0.12um
@ DRC doesn't check when one or more square 1xVn is also on H-shape Mxy+1/1.25xMy region
 hole_area_meet = AREA (HOLES M3 INNER) <= 4.05
 hole_area_meet_len = (hole_area_meet WITH EDGE (LENGTH hole_area_meet <= 0.9)) NOT WITH EDGE (LENGTH hole_area_meet > 4.5)
 hole_area_real = (hole_area_meet_len NOT ENCLOSE RECTANGLE 0.9+GLOBAL_TOLERANCE 4.5) NOT ENCLOSE RECTANGLE 0.9 4.5+GLOBAL_TOLERANCE
 hole_bars_len = M3 COIN EDGE hole_area_real
 // 
 hole_bars = INT hole_bars_len <= 0.12 ABUT<90 OPPOSITE REGION EXCLUDE SHIELDED
 hole_bars_real = hole_bars WITH EDGE (LENGTH hole_bars_len <= 0.9)
 hole_bars_vias_sq = V2N INTERACT ((hole_bars_real INTERACT hole_area_real == 2) NOT ENCLOSE RV2)
 err1 = hole_bars_real INTERACT hole_bars_vias_sq == 1
 err1 NOT INSIDE SealR_NOT_BULK
}
 
Vy2_R_7 {
@ (Vy OR RVy) overlap MTFUSE is not allowed, except V3
 err1 = V2 AND MTFUSE
 err1 NOT INSIDE SealR_NOT_BULK
}
// Vy.R.8[NC] Vy pattern must be drawn on data type 40
 
Vy2_R_9 {
@ It's not allowed Vy overlap with the metal resistor directly underneath and above the Vy
 err1 = V2 AND (M2RES AND M2)
 err2 = V2 AND (M3RES AND M3)
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

#IFDEF RECOMMENDED_CHECK YES

 
Vy2_R_10_R {
@ Recommend space between a square Vy and another (Vy OR RVy OR DUM_Vy) < 4um to avoid single square Vy
 ALL_VIA_CHECK = OR V2_SR DUM_V2
 STEP_1 = SIZE V2_SR BY 1.4
 // 4/1.414 = 2.828
 STEP_1_GOOD = STEP_1 INTERACT ALL_VIA_CHECK > 1
 STEP_1_FILTER = V2N NOT INTERACT STEP_1_GOOD
 err1 = STEP_1_FILTER NOT WITH EDGE (EXT [STEP_1_FILTER] ALL_VIA_CHECK < 4 PERP ALSO)
 err1 NOT INSIDE SealR_NOT_BULK
}

#ENDIF


// =======================================================
// Square Vy design rules
// =======================================================

GROUP GVy3 Vy3_?

#IFDEF MANUFACTURABILITY_ENHANCEMENT_RULES YES

//;beginning of the Vy.EN.2a derivations
met_Vy_3_2a_ME = M3 WITH WIDTH < 0.050
via_Vy_3_2a_ME = 1XV3N INTERACT met_Vy_3_2a_ME
via_Vy_3_2a_bad_ME = RECTANGLE ENCLOSURE via_Vy_3_2a_ME M3 ABUT<90 SINGULAR OUTSIDE ALSO 
GOOD 0 0.032 OPPOSITE 0 0.032 OPPOSITE
via_Vy_3_2a_good_ME = via_Vy_3_2a_ME NOT via_Vy_3_2a_bad_ME
//;end of the Vy.EN.2a derivations
 
Vy3_EN_2a_ME {
@ Vy enclosure by M1 or Mxy (width < 0.05um) for two opposite sides with the other two side >= 0um (M1/Mxy is the metal underneath Vy), except INST region >= 0.032um
 err1 = via_Vy_3_2a_bad_ME NOT via_Vy_3_2c_good_ME
 err1 NOT INSIDE INST
}
 
//;beginning of the Vy.EN.2c derivations
met_Vy_3_2c_ME = M3 WITH WIDTH >= 0.050
via_Vy_3_2c_ME = 1XV3N INTERACT met_Vy_3_2c_ME
via_Vy_3_2c_bad_ME = RECTANGLE ENCLOSURE via_Vy_3_2c_ME M3 ABUT<90 SINGULAR 
GOOD 0.009 0.025 OPPOSITE 0.009 0.025 OPPOSITE
via_Vy_3_2c_good_ME = via_Vy_3_2c_ME NOT via_Vy_3_2c_bad_ME
//;end of the Vy.EN.2c derivations
 
Vy3_EN_2c_ME {
@ Vy enclosure by M1 or Mxy (width >= 0.05um) for two opposite sides with the other two side >= 0.009um (M1/Mxy is the metal underneath Vy), except INST region >= 0.025um
 err1 = via_Vy_3_2c_bad_ME NOT via_Vy_3_2a_good_ME
 err1 NOT INSIDE INST
}
 
//;beginning of the Vy.EN.16a derivations
met_Vy3_16a_ME = M4 WITH WIDTH == 0.032
via_Vy3_16a_ME = 1XV3N INTERACT met_Vy3_16a_ME
via_Vy3_16a_ME_bad = RECTANGLE ENCLOSURE via_Vy3_16a_ME M4 ABUT<90 SINGULAR 
GOOD 0 0.039 OPPOSITE 0 0.039 OPPOSITE
via_Vy3_16a_ME_good = via_Vy3_16a_ME NOT via_Vy3_16a_ME_bad
//;beginning of the Vy.EN.16a derivations
 
Vy3_EN_16a_ME {
@ Vy enclosure by Mxy+1 (width = 0.032um) for two opposite sides with the other two sides >= 0um, except INST region >= 0.039um
 err1 = COPY via_Vy3_16a_ME_bad
 err1 NOT INSIDE INST
}

#ENDIF

 
Vy3_BAR = (OR V3_BAR_100_all V3_BAR_450_all) INSIDE MARKS_MARKG
 
Vy3_W_1 {
@ Vy width and length (except 0.032*0.08um RVy, MARKS, MARKG, INDMY and LOGO region) = 0.032um
 err1 = (V3 NOT RV3) NOT 1XV3N
 err1 NOT INSIDE MARKS_MARKG_INDMY_LOGO
}
 
Vy3_W_2 {
@ Vy bar width in MARKS and MARKG regions = 0.1, 0.45um
 err1 = (V3 NOT (OR V3_SR V3_BAR_100_all V3_BAR_450_all V3N_Seal_Ring)) INSIDE MARKS_MARKG
 err1 NOT INSIDE SealR_NOT_BULK
}
 
Vy3_S_1a {
@ Space between two (Vy or RVy) when under 1.25xMy >= 0.066um
 err1 = EXT V3_SR < 0.066 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
Vy3_S_2 {
@ Space between two square Vy when PRL > -0.032um, except V1 in INST region, DRC only flag the point-to-point space when PRL <= 0. >= 0.082um
 err1 = EXT V3N < 0.082 ABUT<90 OPPOSITE EXTENDED 0.001 REGION
 err2_RAW = EXT V3N < 0.082 ABUT<90 CORNER TO CORNER
 err2_TMP = DFM PROPERTY err2_RAW [-= (EWXP(err2_RAW) < 0.032 || EWYP(err2_RAW) < 0.032) ? 1 : 0] > 0
 err2 = DFM COPY err2_TMP REGION
 // 
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}
 
Vy3_S_3 {
@ Space between square Vy and RVy >= 0.082um
 err1 = EXT V3N RV3 < 0.082 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
Vy3_S_4 {
@ Space between Vy and Vy-1 (including V0) at different net and PRL > 0um. >= 0.038um
@ When:
@ Mxy+1/1.25xMy enclosure of Vy > 0um
 // (include V0)
 chk_via = (V3 AND (V3N INSIDE M4)) NOT COIN EDGE M4
 err1 = EXT chk_via V2 < 0.038 ABUT<90 OPPOSITE REGION NOT CONNECTED
 err1 NOT INSIDE SealR_NOT_BULK
}
 
Vy3_S_5 {
@ Space between Vy and Mxy (including M1) at different net, except V1 in INST region >= 0.037um
@ When:
@ 1. Mxy (including M1) enclosure of Vy < 0.003um
@ 2. Mxy+1/1.25xMy width > 0.038um
 y1 = V3 AND (V3N NOT OUTSIDE (M4 WITH WIDTH > 0.038))
 y2 = EXT [y1] M3 < 0.037 ABUT<90 MEASURE ALL NOT CONNECTED
 y3 = ENC [y2] M3 < 0.003 ABUT<90 OPPOSITE
 err1 = EXT (y1 COIN EDGE y3) M3 < 0.037 ABUT<90 MEASURE ALL NOT CONNECTED REGION
 // 
 err1 NOT INSIDE SealR_NOT_BULK
}
 
Vy3_S_6 {
@ Projection space between Vy and the Mxy+1/1.25xMy concave corner >= 0.029um
@ When:
@ 1. Mxy+1/1.25xMy width < 0.035um, form one edge of concave corner
@ 2. Vy enclosure by Mxy+1/1.25xMy <= 0.002um at opposite side of Mxy+1/1.25xMy concave corner
@ 3. The length of another edge of concave corner > 0.005um
@ Via inside the cross region with vertex enclosure <= 0.001um is not allowed
 // for via not totally inside cross region
 min_enc_met_side = M4 TOUCH EDGE (ENC V3N [M4] <= 0.002 ABUT<90 OPPOSITE)
 min_wid_met_side = M4 TOUCH EDGE (INT min_enc_met_side [M4_convex_lt_two_edges] < 0.035 OPPOSITE)
 min_wid_met_corn = EXT min_wid_met_side (LENGTH M4_convex_lt_two_edges > 0.005) < 0.001 ABUT INTERSECTING ONLY REGION
 min_wid_met_side_c = min_wid_met_side TOUCH EDGE min_wid_met_corn
 min_wid_met_corn_c = M4 TOUCH EDGE min_wid_met_corn
 min_wid_met_side_opp = M4 TOUCH EDGE (INT min_wid_met_side_c [M4] < 0.035 OPPOSITE)
 min_wid_met_area_opp = INT min_wid_met_side_c M4 < 0.035 OPPOSITE REGION
 // 
 min_enc_via_s = ENC [V3N] min_wid_met_side_opp <= 0.002 ABUT<90 OPPOSITE
 min_enc_via_c = V3N WITH EDGE min_enc_via_s
 min_met_corn = min_wid_met_corn_c COIN EDGE (M4 ENCLOSE min_enc_via_c)
 via_err_edge_outer = EXT [min_enc_via_c] min_met_corn < 0.029 ABUT<90 OPPOSITE EXTENDED 0.035-0.032+GLOBAL_TOLERANCE MEASURE ALL
 via_err_edge_inner = EXT [min_enc_via_c] min_wid_met_corn < 0.029 ABUT<90 OPPOSITE EXTENDED 0.035-0.032+GLOBAL_TOLERANCE EXCLUDE SHIELDED
 via_err_edge_all = OR EDGE via_err_edge_outer via_err_edge_inner
 err1 = min_enc_via_c WITH EDGE via_err_edge_all
 err1 NOT INSIDE SealR_NOT_BULK
 // 
 min_wid_met_all = INT M4 M4_convex_lt_two_edges < 0.035 OPPOSITE REGION
 // SETLAYER min_wid_met_rvs = DRC:1 NOT M4
 // SETLAYER err2 = (V3N INTERACT min_wid_met_all SINGULAR ALSO) INTERACT min_wid_met_rvs SINGULAR ONLY // point touch via
 err2 = ENC (V3N INTERACT min_wid_met_all SINGULAR ALSO) M4 < 0.0005 SINGULAR REGION
 err2 NOT INSIDE SealR_NOT_BULK
 // 
 met_corner_corss = (EXT M4_convex_lt_two_edges M4 < 0.001 ABUT==90 INTERSECTING ONLY REGION) COIN EDGE min_wid_met_all
 via_inside_corss = ((V3N NOT WITH EDGE (ENC [V3N] M4 < 0.001 ABUT>0<90 SINGULAR)) NOT WITH EDGE via_err_edge_all) NOT INSIDE min_wid_met_all
 via_inside_corss_enc = EXT [via_inside_corss] met_corner_corss <= 0.001 PROJ==0 PARA ONLY OPPOSITE EXTENDED 0.002
 err3 = via_inside_corss INTERACT (INT via_inside_corss_enc <= 0.032 OPPOSITE REGION) // via inside cross must be enclosed by the short side of metal (width< 0.035) >= 0.001
 err3 NOT INSIDE SealR_NOT_BULK
}
 
Vy3_S_7 {
@ Space between two square Vy with PRL >= -0.089um. >= 0.099um
@ When:
@ 1) Vy enclosure by 1.25xMy <= 0.008um at opposite side
@ 2) Space between Vy and 1.25xMy <= 0.052um with PRL >= -0.047um at opposite side
@ DRC doesn't flag Vy meet 1) and 2) condition on both sides
 ncp_axis = ANGLE (ENC [V3N] M4 <= 0.008 ABUT<90 OPPOSITE) == 0
 // only exist along cp direction
 y1 = ANGLE (V3N TOUCH EDGE ncp_axis) == 0
 y2 = EXT [y1] M4 <= 0.052 ABUT<90 OPPOSITE EXTENDED 0.047+GLOBAL_TOLERANCE MEASURE ALL
 y3 = V3N TOUCH EDGE y2
 y4 = INT [V3N] y3 <= 0.032 ABUT<90 OPPOSITE
 err1 = EXT (y4 NOT TOUCH EDGE y2) V3_SR < 0.099 ABUT<90 OPPOSITE EXTENDED 0.089+GLOBAL_TOLERANCE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
Vy3_S_8 {
@ Space between Vy bar (width = 0.1/0.45um) and (Vy or RVy) >= 0.34um
 err1 = EXT (OR V3_BAR_100_all V3_BAR_450_all) V3_SR < 0.34 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
Vy3_S_9 {
@ Space between two Vy bar (width = 0.1/0.45um), DRC only check the space between parallel edge when the Vy bar is inside MARKS >= 0.55um
 // SETLAYER waive_shape = EXT (OR V3_BAR_100_all V3_BAR_450_all) < 0.55 ABUT<90 SINGULAR REGION INTERSECTING ONLY
 err1 = EXT ((OR V3_BAR_100_all V3_BAR_450_all) INTERACT MARKS_MARKG) < 0.55 ANGLED!=1 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 

#IFDEF DFM_RULES_PRIORITY_1 YES

 
Vy3_EN_1_DFM1 {
@ Recommended square Vy enclosure by M1/Mxy is defined by either Vy.EN.2.DFM or Vy.EN.3.DFM or Vy.EN.2b.DFM
 err1 = 1XV3N NOT INSIDE M3
 err1 NOT INSIDE SealR_NOT_BULK
}
 
//;beginning of the Vy.EN.2.DFM derivations
via_Vy_3_2_R_bad = RECTANGLE ENCLOSURE 1XV3N M3 ABUT<90 SINGULAR 
GOOD 0.007 0.050 OPPOSITE 0.007 0.050 OPPOSITE
via_Vy_3_2_R_good = 1XV3N NOT via_Vy_3_2_R_bad
//;end of the Vy.EN.2.DFM derivations
 
Vy3_EN_2_DFM1 {
@ Recommended square Vy enclosure by M1/Mxy for two opposite sides with the other two sides >= 0.007um, except FUSEMK1 region. >= 0.05um
 err1 = (via_Vy_3_2_R_bad NOT via_Vy_3_3_R_good) NOT INSIDE FUSEMK1
 err1 NOT INSIDE SealR_NOT_BULK
}
 
Vy3_EN_2b_DFM1 {
@ Recommended enclosure by M1 or Mxy (width < 0.05um) along width direction must be equal or 1nm difference (M1/Mxy is the metal underneath Vy.)
 chk_Mxy = (INT [M3] < 0.05 ABUT<90 OPPOSITE) TOUCH EDGE (M3 WITH WIDTH < 0.05)
 side_en = ENC V3N chk_Mxy < 0.018 ABUT<90 OPPOSITE
 side_en_EDGE = ENC [V3N] chk_Mxy < 0.018 ABUT<90 OPPOSITE
 err1 = DFM PROPERTY V3N side_en OVERLAP ABUT ALSO MULTI [-= COUNT(side_en)] >= 2 [+= ((MIN(EW(side_en)) == MAX(EW(side_en))) || (MIN(EW(side_en)) == ABS(MAX(EW(side_en)) - 0.001))) ? 1 : 0] == 0
 err1 NOT INSIDE SealR_NOT_BULK
}
 
//;beginning of the Vy.EN.3.DFM derivations
via_Vy_3_3_R_bad = RECTANGLE ENCLOSURE 1XV3N M3 ABUT<90 SINGULAR 
GOOD 0.02 0.02 0.02 0.02 OPPOSITE
via_Vy_3_3_R_good = 1XV3N NOT via_Vy_3_3_R_bad
//;end of the Vy.EN.3.DFM derivations
 
Vy3_EN_3_DFM1 {
@ Recommended square Vy enclosure by M1, Mxy for all sides to avoid high Rc, except FUSEMK1 region >= 0.02um
 err1 = (via_Vy_3_3_R_bad NOT via_Vy_3_2_R_good) NOT INSIDE FUSEMK1
 err2 = ((ENC [1XV3N] M3 < 0.02 ABUT<90 SINGULAR) NOT TOUCH EDGE via_Vy_3_2_R_good) NOT INSIDE EDGE FUSEMK1
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE EDGE SealR_NOT_BULK
}

#ENDIF

 
Vy3_EN_1 {
@ 1X square Vy must be fully enclosed by M1 or Mxy
@ where M1/Mxy is the metal layer directly underneath Vy, Vy enclosure by M1 or Mxy must follow either Vy.EN.2 or Vy.EN.3
 err1 = 1XV3N NOT M3
 err1 NOT INSIDE SealR_NOT_BULK
}
 
//;beginning of the Vy.EN.2 derivations
via_Vy_3_2_bad = RECTANGLE ENCLOSURE 1XV3N M3 ABUT<90 SINGULAR OUTSIDE ALSO 
GOOD 0 0.024 OPPOSITE 0 0.024 OPPOSITE
via_Vy_3_2_good = 1XV3N NOT via_Vy_3_2_bad
//;end of the Vy.EN.2 derivations
 
//;beginning of the Vy.EN.3 derivations
via_Vy_3_3_bad = RECTANGLE ENCLOSURE 1XV3N M3 ABUT<90 SINGULAR OUTSIDE ALSO 
GOOD 0.015 0.015 0.015 0.015 OPPOSITE
via_Vy_3_3_good = 1XV3N NOT via_Vy_3_3_bad
via_Vy_3_2_3_good = OR via_Vy_3_2_good via_Vy_3_3_good
//;end of the Vy.EN.3 derivations
 
Vy3_EN_2_3 {
@ Vy.EN.2: Vy enclosure by M1 or Mxy when enclosure by M1 or Mxy on either perpendicular direction >= 0um, except V1 in INST region >= 0.024um
@ Vy.EN.3: Vy enclosure by M1 or Mxy for all sides, except V1 in INST region >= 0.015
 err1 = via_Vy_3_2_bad NOT via_Vy_3_2_3_good
 // 
 err1 NOT INSIDE SealR_NOT_BULK
}
 
Vy3_EN_4 {
@ Vy enclosure by Mxy in adjacent S1 side, where Mxy is the metal layer directly underneath Vy >= 0.004um
@ When:
@ 1. Mxy width W: 0.036um <= W <= 0.041um
@ 2. Space: 0.058um <= S1 < 0.063um, the PRL >= 0.083um
@ 3. The opposite space S2 >= 0.069um
 met_wid_all = M3 WITH WIDTH > 0.036-GLOBAL_TOLERANCE <= 0.041
 met_err_RAW_a = EXT [met_wid_all] M3 >= 0.058 < 0.063 ABUT<90 OPPOSITE MEASURE ALL
 met_err_RAW_b = EXT met_wid_all M3 >= 0.058 < 0.063 ABUT<90 OPPOSITE MEASURE ALL
 met_err_RAW_c = EXT met_wid_all [M3] >= 0.058 < 0.063 ABUT<90 OPPOSITE MEASURE ALL
 met_err_PRL = DFM PROPERTY met_err_RAW_b met_err_RAW_c OVERLAP ABUT ALSO MULTI [-= max(LENGTH(met_err_RAW_c))] >= 0.083
 // 
 met_err_EGE_a = met_err_RAW_a COIN EDGE (DFM COPY met_err_PRL EDGE)
 met_err_EGE_b = ENC V3N [met_err_EGE_a] < 0.004 ABUT<90 OPPOSITE
 met_err_EGE_c = INT met_err_EGE_b [M3] > 0.036-GLOBAL_TOLERANCE <= 0.041 ABUT<90 OPPOSITE MEASURE COIN
 met_err_EGE_d = EXT (met_err_EGE_c) M3 < 0.069 ABUT<90 OPPOSITE
 met_err_EGE_e = met_err_EGE_b COIN EDGE M3
 err1 = INT met_err_EGE_d [met_err_EGE_e] > 0.036-GLOBAL_TOLERANCE <= 0.041 ABUT<90 OPPOSITE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
Vy3_EN_5 {
@ Vy enclosure by Mxy in adjacent S1 side, where Mxy is the metal layer directly underneath Vy >= 0.004um
@ When:
@ 1. Mxy width W: 0.042um < W <= 0.05um
@ 2. Space: 0.058um <= S1 <= 0.067um, the PRL >= 0.083um
 met_wid_all = M3 WITH WIDTH > 0.042 <= 0.05
 met_err_RAW_TMP = EXT met_wid_all [M3] >= 0.058 < 0.067+GLOBAL_TOLERANCE ABUT<90 OPPOSITE MEASURE ALL
 met_err_RAW = EXT met_err_RAW_TMP [M3] >= 0.058 < 0.067+GLOBAL_TOLERANCE ABUT<90 OPPOSITE
 // 
 met_jog_ALL = M3_convex_eq_one_edges NOT COIN EDGE met_err_RAW
 met_jog_EXP_a = EXPAND EDGE met_jog_ALL INSIDE BY 0.0005
 met_jog_EXP_b = EXPAND EDGE met_jog_ALL OUTSIDE BY 0.0005
 met_jog_TMP = (met_jog_ALL COIN EDGE (met_jog_EXP_a WITH EDGE met_err_RAW)) COIN EDGE (met_jog_EXP_b WITH EDGE met_err_RAW)
 met_jog_EXP = ((VERTEX (EXPAND EDGE met_jog_TMP OUTSIDE BY 0.001 EXTEND BY 0.001) == 4) OR (EXPAND EDGE met_err_RAW OUTSIDE BY 0.001)) NOT M3
 // 
 met_err_PRL = DFM PROPERTY met_jog_EXP met_err_RAW met_wid_all OVERLAP ABUT ALSO MULTI [-= LENGTH(met_err_RAW)] >= 0.083 [+= COUNT(met_wid_all)] > 0
 met_err_EGE = M3 COIN EDGE (met_err_RAW COIN EDGE (met_err_PRL COIN EDGE met_wid_all))
 err1 = ENC [V3N] met_err_EGE < 0.004 ABUT<90 OPPOSITE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
Vy3_EN_8 {
@ Vy enclosure by Mxy in adjacent S1 side, where Mxy is the metal layer directly underneath Vy >= 0.004um
@ When:
@ 1. Mxy width W: 0.051um <= W <= 0.112um
@ 2. Space: 0.058um <= S1 <= 0.094um, the PRL >= 0.083um
@ DRC doesn't check Vy:
@ a) Two Vys with space <= 0.1um in Mxy and 1.25xMy/Mxy+1 intersection region.
@ b) One Vy and one rectangular Vy with space <= 0.1um in Mxy and 1.25xMy/Mxy+1 intersection region
 met_wid_all = M3 WITH WIDTH > 0.051-GLOBAL_TOLERANCE <= 0.112
 met_err_RAW_TMP = EXT met_wid_all [M3] >= 0.058 < 0.094+GLOBAL_TOLERANCE ABUT<90 OPPOSITE MEASURE ALL
 met_err_RAW = EXT met_err_RAW_TMP [M3] >= 0.058 < 0.094+GLOBAL_TOLERANCE ABUT<90 OPPOSITE
 // 
 met_jog_ALL = M3_convex_eq_one_edges NOT COIN EDGE met_err_RAW
 met_jog_EXP_a = EXPAND EDGE met_jog_ALL INSIDE BY 0.0005
 met_jog_EXP_b = EXPAND EDGE met_jog_ALL OUTSIDE BY 0.0005
 met_jog_TMP = (met_jog_ALL COIN EDGE (met_jog_EXP_a WITH EDGE met_err_RAW)) COIN EDGE (met_jog_EXP_b WITH EDGE met_err_RAW)
 met_jog_EXP = ((VERTEX (EXPAND EDGE met_jog_TMP OUTSIDE BY 0.001 EXTEND BY 0.001) == 4) OR (EXPAND EDGE met_err_RAW OUTSIDE BY 0.001)) NOT M3
 // 
 met_err_PRL = DFM PROPERTY met_jog_EXP met_err_RAW met_wid_all OVERLAP ABUT ALSO MULTI [-= LENGTH(met_err_RAW)] >= 0.083 [+= COUNT(met_wid_all)] > 0
 met_err_EGE = M3 COIN EDGE (met_err_RAW COIN EDGE (met_err_PRL COIN EDGE met_wid_all))
 via_group_all = SIZE V3 BY 0.05 INSIDE OF (M3 AND M4) STEP 0.02
 via_group_real = V3 INTERACT (via_group_all INTERACT V3 >= 2)
 err1 = ENC (V3N NOT via_group_real) met_err_EGE < 0.004 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
Vy3_EN_9 {
@ Vy enclosure by M1/Mxy in adjacent S1 side, where M1/Mxy is the metal layer directly underneath Vy >= 0.004um
@ When:
@ 1. M1/Mxy dimension along enclosure direction: 0.113um <= L <= 0.201um
@ 2. Space: 0.058um <= S1 <= 0.094um, the PRL >= 0.083um
 met_wid_all = INT [M3] > 0.113-GLOBAL_TOLERANCE <= 0.201 ABUT<90 OPPOSITE EXCLUDE SHIELDED
 met_err_RAW = EXT [met_wid_all] M3 >= 0.058 < 0.094+GLOBAL_TOLERANCE ABUT<90 OPPOSITE
 met_jog_ALL = M3_convex_eq_one_edges NOT COIN EDGE met_err_RAW
 met_jog_EXP_a = EXPAND EDGE met_jog_ALL INSIDE BY 0.0005
 met_jog_EXP_b = EXPAND EDGE met_jog_ALL OUTSIDE BY 0.0005
 met_jog_TMP = (met_jog_ALL COIN EDGE (met_jog_EXP_a WITH EDGE met_err_RAW)) COIN EDGE (met_jog_EXP_b WITH EDGE met_err_RAW)
 met_jog_EXP = ((VERTEX (EXPAND EDGE met_jog_TMP OUTSIDE BY 0.001 EXTEND BY 0.001) == 4) OR (EXPAND EDGE met_err_RAW OUTSIDE BY 0.001)) NOT M3
 // 
 met_err_PRL = DFM PROPERTY met_jog_EXP met_err_RAW OVERLAP ABUT ALSO MULTI [-= LENGTH(met_err_RAW)] >= 0.083
 met_err_EGE = M3 COIN EDGE (met_err_RAW COIN EDGE met_err_PRL)
 err1 = ENC V3N met_err_EGE < 0.004 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
Vy3_EN_10 {
@ Vy enclosure by M1/Mxy in adjacent S1 side, where M1/Mxy is the metal layer directly underneath Vy >= 0.014um
@ When:
@ 1. M1/Mxy width W: dimension along enclosure direction L >= 0.202um
@ 2. Space: 0.058um <= S1 <= 0.094um, PRL >= 0.083um
 met_wid_all = INT (M3) <= 0.202-GLOBAL_TOLERANCE ABUT<90 OPPOSITE EXCLUDE SHIELDED
 met_err_RAW = EXT [met_wid_all] M3 >= 0.058 < 0.094+GLOBAL_TOLERANCE ABUT<90 OPPOSITE
 met_jog_ALL = M3_convex_eq_one_edges NOT COIN EDGE met_err_RAW
 met_jog_EXP_a = EXPAND EDGE met_jog_ALL INSIDE BY 0.0005
 met_jog_EXP_b = EXPAND EDGE met_jog_ALL OUTSIDE BY 0.0005
 met_jog_TMP = (met_jog_ALL COIN EDGE (met_jog_EXP_a WITH EDGE met_err_RAW)) COIN EDGE (met_jog_EXP_b WITH EDGE met_err_RAW)
 met_jog_EXP = ((VERTEX (EXPAND EDGE met_jog_TMP OUTSIDE BY 0.001 EXTEND BY 0.001) == 4) OR (EXPAND EDGE met_err_RAW OUTSIDE BY 0.001)) NOT M3
 // 
 met_err_PRL = DFM PROPERTY met_jog_EXP met_err_RAW OVERLAP ABUT ALSO MULTI [-= LENGTH(met_err_RAW)] >= 0.083
 met_err_EGE = M3 COIN EDGE (met_err_RAW COIN EDGE met_err_PRL)
 err1 = ENC V3N met_err_EGE < 0.014 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
Vy3_EN_11 {
@ Vy bar must fully enclosure by Mxy (including M1) where Mxy is the metal layer directly underneath Vy bar >= 0.2um
 err1 = ENC V3_BAR_100_all M3 < 0.2 ABUT<90 SINGULAR REGION OUTSIDE ALSO
 err2 = ENC V3_BAR_450_all M3 < 0.2 ABUT<90 SINGULAR REGION OUTSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}
 

#IFDEF DFM_RULES_PRIORITY_1 YES

 
Vy3_EN_14_DFM1 {
@ Recommended square Vy fully enclosure by Mxy+1/1.25xMy is defined by either Vy.EN.16.DFM, Vy.EN.16a.DFM or Vy.EN.16b.DFM, which Mxy+1/1.25xMy is the metal layer directly above Vy
 err1 = 1XV3N NOT INSIDE M4
 err1 NOT INSIDE SealR_NOT_BULK
}
 
//;beginning of the Vy.EN.16.DFM derivations
via_Vy_3_16_R_bad = RECTANGLE ENCLOSURE 1XV3N M4 ABUT<90 SINGULAR OUTSIDE ALSO 
GOOD 0.020 0.020 0.020 0.020 OPPOSITE
via_Vy_3_16_R_good = 1XV3N NOT via_Vy_3_16_R_bad
//;end of the Vy.EN.16.DFM derivations
 
Vy3_EN_16_DFM1 {
@ Recommended square Vy enclosure by Mxy+1/1.25xMy for all sides >= 0.02um
 err1 = via_Vy_3_16_R_bad NOT (OR via_Vy_3_16a_R_good via_Vy_3_16b_R_good)
 err2 = (ENC [1XV3N] M4 < 0.02 ABUT<90 SINGULAR) NOT TOUCH EDGE (OR via_Vy_3_16a_R_good via_Vy_3_16b_R_good)
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE EDGE SealR_NOT_BULK
}
 
//;beginning of the Vy.EN.16a.DFM derivations
met_Vy3_16a_R = M4 WITH WIDTH < 0.05
via_Vy3_16a_R = 1XV3N NOT OUTSIDE met_Vy3_16a_R
via_Vy_3_16a_R_bad = RECTANGLE ENCLOSURE via_Vy3_16a_R M4 ABUT<90 SINGULAR 
GOOD 0.007 0.050 OPPOSITE 0.007 0.050 OPPOSITE
via_Vy_3_16a_R_good = via_Vy3_16a_R NOT via_Vy_3_16a_R_bad
//;end of the Vy.EN.16a.DFM derivations
 
Vy3_EN_16a_DFM1 {
@ Recommended square Vy enclosure by Mxy+1/1.25xMy (width < 0.05um) for two opposite sides with the other two sides >= 0.007um. >= 0.05um
 err1 = via_Vy_3_16a_R_bad NOT (OR via_Vy_3_16_R_good via_Vy_3_16b_R_good)
 err1 NOT INSIDE SealR_NOT_BULK
}
 
//;beginning of the Vy.EN.16b.DFM derivations
via_Vy3_16b_R = (1XV3N OUTSIDE met_Vy3_16a_R) NOT OUTSIDE M4
via_Vy_3_16b_R_bad = RECTANGLE ENCLOSURE via_Vy3_16b_R M4 ABUT<90 SINGULAR 
GOOD 0.009 0.050 OPPOSITE 0.009 0.050 OPPOSITE
via_Vy_3_16b_R_good = via_Vy3_16b_R NOT via_Vy_3_16b_R_bad
//;end of the Vy.EN.16.DFM derivations
 
Vy3_EN_16b_DFM1 {
@ Recommended square Vy enclosure by Mxy+1/1.25xMy (width >= 0.05um) for two opposite sides with the other two sides >= 0.009um. >= 0.05um
 err1 = via_Vy_3_16b_R_bad NOT (OR via_Vy_3_16_R_good via_Vy_3_16a_R_good)
 err1 NOT INSIDE SealR_NOT_BULK
}

#ENDIF

 
//;beginning of the Vy.EN.13 derivations
via_Vy3_13_bad = RECTANGLE ENCLOSURE 1XV3N M4 ABUT<90 SINGULAR OUTSIDE ALSO 
GOOD 0.015 0.015 0.015 0.015 OPPOSITE
via_Vy_3_13_good = 1XV3N NOT via_Vy3_13_bad
//;beginning of the Vy.EN.13 derivations
 
Vy3_EN_12_13 {
@ 1X square Vy must be fully enclosure by Mxy+1/1.25xMy where Mxy+1/1.25xMy is the metal layer directly above Vy
@ Enclosure by Mxy+1/1.25x My must follow one of Vy.En.15 or Vy.EN.16 or Vy.EN.16a or Vy.EN.16b or Vy.EN.16c or Vy.EN.16d or Vy.EN.16e or Vy.EN.16f or Vy.EN.16g or Vy.EN.17 or Vy.EN.18 or Vy.EN.19 or Vy.EN.20 or Vy.EN.21
@ Vy.EN.13: Vy enclosure by Mxy+1 for all sides >= 0.015um
 err1 = 1XV3N NOT M4
 err1 NOT INSIDE SealR_NOT_BULK
}
 
//;beginning of the Vy.EN.17 derivations
met_Vy3_17 = M4 WITH WIDTH == 0.04
via_Vy3_17 = 1XV3N INTERACT met_Vy3_17
via_Vy3_17_bad = RECTANGLE ENCLOSURE via_Vy3_17 M4 ABUT<90 SINGULAR 
GOOD 0.004 0.034 OPPOSITE 0.004 0.034 OPPOSITE
via_Vy3_17_good = via_Vy3_17 NOT via_Vy3_17_bad
//;end of the Vy.EN.17 derivations
 
//;beginning of the Vy.EN.17a derivations
met_Vy3_17a = M4 WITH WIDTH == 0.042
via_Vy3_17a = 1XV3N INTERACT met_Vy3_17a
via_Vy3_17a_bad = RECTANGLE ENCLOSURE via_Vy3_17a M4 ABUT<90 SINGULAR 
GOOD 0.005 0.034 OPPOSITE 0.005 0.034 OPPOSITE
via_Vy3_17a_good = via_Vy3_17a NOT via_Vy3_17a_bad
//;end of the Vy.EN.17a derivations
via_Vy3_17_17a_good = OR via_Vy3_17_good via_Vy3_17a_good
 
Vy3_EN_17 {
@ Vy enclosure by 1.25xMy (width = 0.04um) for two opposite sides with the other two sides >= 0.004um. >= 0.034um
 err1 = COPY via_Vy3_17_bad
 err1 NOT INSIDE SealR_NOT_BULK
}
 
Vy3_EN_17a {
@ Vy enclosure by 1.25xMy (width = 0.042um) for two opposite sides with the other two sides >= 0.005um. >= 0.034um
 err1 = via_Vy3_17a_bad NOT via_Vy3_17_bad
 err1 NOT INSIDE SealR_NOT_BULK
}
 
//;beginning of the Vy.EN.18 derivations
met_Vy3_18 = M4 WITH WIDTH == 0.044
via_Vy3_18 = 1XV3N INTERACT met_Vy3_18
via_Vy3_18_bad = RECTANGLE ENCLOSURE via_Vy3_18 M4 ABUT<90 SINGULAR 
GOOD 0.006 0.034 OPPOSITE 0.006 0.034 OPPOSITE
via_Vy3_18_good = via_Vy3_18 NOT via_Vy3_18_bad
//;end of the Vy.EN.18 derivations
 
//;beginning of the Vy.EN.18a derivations
met_Vy3_18a = M4 WITH WIDTH == 0.046
via_Vy3_18a = 1XV3N INTERACT met_Vy3_18a
via_Vy3_18a_bad = RECTANGLE ENCLOSURE via_Vy3_18a M4 ABUT<90 SINGULAR 
GOOD 0.007 0.034 OPPOSITE 0.007 0.034 OPPOSITE
via_Vy3_18a_good = via_Vy3_18a NOT via_Vy3_18a_bad
//;end of the Vy.EN.18a derivations
via_Vy3_18_18a_good = OR via_Vy3_18_good via_Vy3_18a_good
 
Vy3_EN_18 {
@ Vy enclosure by 1.25xMy (width = 0.044um) for two opposite sides with the other two sides >= 0.006um. >= 0.034um
 err1 = via_Vy3_18_bad NOT via_Vy3_17_17a_good
 err1 NOT INSIDE SealR_NOT_BULK
}
 
Vy3_EN_18a {
@ Vy enclosure by 1.25xMy (width = 0.046um) for two opposite sides with the other two sides >= 0.007um. >= 0.034um
 err1 = via_Vy3_18a_bad NOT (OR via_Vy3_17_17a_good via_Vy3_18_good)
 err1 NOT INSIDE SealR_NOT_BULK
}
 
//;beginning of the Vy.EN.19 derivations
met_Vy3_19 = M4 WITH WIDTH >= 0.060 < 0.08
via_Vy3_19_TMP = 1XV3N INTERACT met_Vy3_19
via_Vy3_19 = via_Vy3_19_TMP NOT (OR via_Vy3_17_17a_good via_Vy3_18_18a_good)
via_Vy3_19_bad = RECTANGLE ENCLOSURE via_Vy3_19 M4 ABUT<90 SINGULAR 
GOOD 0.014 0.034 OPPOSITE 0.014 0.034 OPPOSITE
via_Vy3_19_good = via_Vy3_19 NOT via_Vy3_19_bad
//;end of the Vy.EN.19 derivations
 
Vy3_EN_19 {
@ Vy enclosure by 1.25xMy (0.06um <= width < 0.08um) for two opposite sides with the other two sides >= 0.014um. >= 0.034um
 err1 = COPY via_Vy3_19_bad
 err1 NOT INSIDE SealR_NOT_BULK
}
 
//;beginning of the Vy.EN.20 derivations
met_Vy3_20 = M4 WITH WIDTH == 0.080
via_Vy3_20_TMP = 1XV3N INTERACT met_Vy3_20
via_Vy3_20 = via_Vy3_20_TMP NOT (OR via_Vy3_17_17a_good via_Vy3_18_18a_good via_Vy3_19_good)
via_Vy3_20_bad = RECTANGLE ENCLOSURE via_Vy3_20 M4 ABUT<90 SINGULAR 
GOOD 0.024 0.024 0.024 0.024 OPPOSITE
via_Vy3_20_good = via_Vy3_20 NOT via_Vy3_20_bad
//;end of the Vy.EN.20 derivations
 
Vy3_EN_20 {
@ Vy enclosure by 1.25xMy (width = 0.08um) for all sides >= 0.024um
 err1 = COPY via_Vy3_20_bad
 err1 NOT INSIDE SealR_NOT_BULK
}
 
//;beginning of the Vy.EN.21 derivations
met_Vy3_21 = M4 WITH WIDTH > 0.080
via_Vy3_21_TMP = 1XV3N INTERACT met_Vy3_21
via_Vy3_21 = via_Vy3_21_TMP NOT (OR via_Vy3_17_17a_good via_Vy3_18_18a_good via_Vy3_19_good via_Vy3_20_good)
via_Vy3_21_bad = RECTANGLE ENCLOSURE via_Vy3_21 M4 ABUT<90 SINGULAR 
GOOD 0.024 0.03 OPPOSITE 0.024 0.03 OPPOSITE
via_Vy3_21_good = via_Vy3_21 NOT via_Vy3_21_bad
//;end of the Vy.EN.21 derivations
 
Vy3_EN_21 {
@ Vy enclosure by 1.25xMy (width > 0.08um) for two opposite sides with the other two sides >= 0.024um. >= 0.03um
 err1 = COPY via_Vy3_21_bad
 err1 NOT INSIDE SealR_NOT_BULK
}
 
Vy3_EN_23 {
@ Vy enclosure by 1.25xMy edge (between two consecutive 90-270 degree corners, length < 0.16um), when PRL > 0. >= 0.029um
 chk_edge = CONVEX EDGE M4 ANGLE1 == 90 ANGLE2 == 270 WITH LENGTH < 0.16
 err1_TMP = chk_edge TOUCH EDGE (EXT chk_edge M4_convex_270_90_edges < 0.005 ABUT==90 INTERSECTING ONLY REGION)
 err1 = ENC V3N err1_TMP < 0.029 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
Vy3_EN_24 {
@ Vy enclosure by 1.25xMy for two opposite sides (PRL > 0) with the other side enclosure < 0.04um (corresponding edge length < 0.16um between two consecutive 90-270 degree corners) >= 0.04um
 correspond_EDG = CONVEX EDGE M4 ANGLE1 == 90 ANGLE2 == 270 WITH LENGTH < 0.16
 correspond_ENC = ENC [V3N] correspond_EDG < 0.04 ABUT<90 OPPOSITE EXTENDED 0.001
 correspond_VIA_ENC_EDGE = V3N TOUCH EDGE correspond_ENC
 correspond_VIA_EDG_CORN = INT [V3N] correspond_VIA_ENC_EDGE < 0.001 ABUT==90 INTERSECTING ONLY
 correspond_VIA_EDG = V3N TOUCH EDGE correspond_VIA_EDG_CORN
 err1_RAW = ENC [correspond_VIA_EDG] M4 < 0.04 ABUT<90 OPPOSITE EXTENDED 0.001
 err1_TMP = INT correspond_VIA_ENC_EDGE (correspond_VIA_EDG TOUCH EDGE err1_RAW) < 0.005 ABUT==90 INTERSECTING ONLY REGION
 err1 = EXPAND EDGE (V3N TOUCH EDGE err1_TMP) INSIDE BY 0.001
 err1 NOT INSIDE SealR_NOT_BULK
}
 
Vy3_EN_25 {
@ Vy bar must fully enclosure by Mxy+1/1.25xMy where Mxy+1/1.25xMy is the metal layer directly above Vy bar >= 0.2um
 err1 = ENC V3_BAR_100_all M4 < 0.2 ABUT<90 SINGULAR REGION OUTSIDE ALSO
 err2 = ENC V3_BAR_450_all M4 < 0.2 ABUT<90 SINGULAR REGION OUTSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

#IFDEF RECOMMENDED_CHECK YES

 
Vy3_D_1_R {
@ (Vy OR RVy) density (window 5um*5um, stepping 2.5um) < 7.7%
 check_region = copy CHIP_NOT_MARKS
 check_pattern = (V3 NOT Vy3_BAR) AND check_region
 // 
 check_window1 = check_region WITH WIDTH >= 5/4
 err1_TMP1 = DENSITY check_pattern check_window1 check_region [!!AREA(check_window1)*AREA(check_pattern)/AREA(check_region)] >= 7.7/100 WINDOW 5 STEP 5/2 BACKUP INSIDE OF LAYER DRC:1 BY POLYGON
 // 
 check_window2 = WITH WIDTH (check_region AND err1_TMP1) >= 5/4
 err1_TMP2 = DENSITY check_pattern check_window2 check_region [!!AREA(check_window2)*AREA(check_pattern)/AREA(check_region)] >= 7.7/100 WINDOW 5 STEP 5/2 BACKUP INSIDE OF LAYER err1_TMP1 BY POLYGON
 // 
 check_window3 = WITH WIDTH (check_region AND err1_TMP2) >= 5/4
 DENSITY check_pattern check_window3 check_region [!!AREA(check_window3)*AREA(check_pattern)/AREA(check_region)] >= 7.7/100 WINDOW 5 STEP 5/2 BACKUP INSIDE OF LAYER err1_TMP2 BY POLYGON PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_Vy3_D_1_R.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_Vy3_D_1_R.rdb"
}

#ENDIF

 
Vy3_R_1 {
@ 45-degree (Vy OR RVy) is not allowed
 err1 = ANGLE (V3 NOT Vy3_BAR) > 44.5 < 45.5
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
Vy3_R_2 {
@ Single Vy is not allowed in H-shape Mxy+1/1.25xMy, when:
@ 1. The Mxy+1/1.25xMy has H-shape interacting with two metal holes: both two metal holes length <= 4.5um and two metal hole area <= 4.05um2
@ 2. The Vy overlaps on the center metal bar of this H-shape Mxy+1/1.25xMy
@ 3. The center metal bar length <= 0.9um and the metal bar width <= 0.12um
@ DRC doesn't check when one or more square 1xVn is also on H-shape Mxy+1/1.25xMy region
 hole_area_meet = AREA (HOLES M4 INNER) <= 4.05
 hole_area_meet_len = (hole_area_meet WITH EDGE (LENGTH hole_area_meet <= 0.9)) NOT WITH EDGE (LENGTH hole_area_meet > 4.5)
 hole_area_real = (hole_area_meet_len NOT ENCLOSE RECTANGLE 0.9+GLOBAL_TOLERANCE 4.5) NOT ENCLOSE RECTANGLE 0.9 4.5+GLOBAL_TOLERANCE
 hole_bars_len = M4 COIN EDGE hole_area_real
 // 
 hole_bars = INT hole_bars_len <= 0.12 ABUT<90 OPPOSITE REGION EXCLUDE SHIELDED
 hole_bars_real = hole_bars WITH EDGE (LENGTH hole_bars_len <= 0.9)
 hole_bars_vias_sq = V3N INTERACT ((hole_bars_real INTERACT hole_area_real == 2) NOT ENCLOSE RV3)
 err1 = hole_bars_real INTERACT hole_bars_vias_sq == 1
 err1 NOT INSIDE SealR_NOT_BULK
}
 
Vy3_R_3 {
@ The numbers of neighboring square Vy to each edge of Vy (space <= 0.077um) when Vy under 1.25xMy < 2
 //;based on Vy.S.1 and Vy.S.2, so only check the space range 0.068~0.077um with PRL <= -0.032
 Y1 = EXT V3N >= 0.068 < 0.077+GLOBAL_TOLERANCE ABUT CORNER TO CORNER
 Y2 = DFM PROPERTY Y1 [-= (EWXP(Y1) > 0.032 && EWYP(Y1) > 0.032) ? 1 : 0] > 0
 Y3 = INT [V3N] < 0.001 ABUT INTERSECTING ONLY
 Y4 = Y3 COIN EDGE (DFM COPY Y2 EDGE)
 Y5 = INT Y4 V3N < 0.001 ABUT==90 INTERSECTING ONLY REGION
 Y6 = (INT (V3N COIN EDGE Y5) <= 0.032 OPPOSITE REGION) OR (INT (V3N COIN EDGE Y5) == 0.064 OPPOSITE REGION)
 err1 = V3N INTERACT Y6
 err1 NOT INSIDE SealR_NOT_BULK
}
 
Vy3_R_4 {
@ The numbers of neighboring square Vy in one group (space <= 0.077um) when Vy under 1.25xMy <= 3
 err1 = WITH NEIGHBOR V3N > 2 SPACE < 0.077+GLOBAL_TOLERANCE
 err1 NOT INSIDE SealR_NOT_BULK
}
// Vy.R.8[NC] Vy pattern must be drawn on data type 40
 
Vy3_R_9 {
@ It's not allowed Vy overlap with the metal resistor directly underneath and above the Vy
 err1 = V3 AND (M3RES AND M3)
 err2 = V3 AND (M4RES AND M4)
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

#IFDEF RECOMMENDED_CHECK YES

 
Vy3_R_10_R {
@ Recommend space between a square Vy and another (Vy OR RVy OR DUM_Vy) < 4um to avoid single square Vy
 ALL_VIA_CHECK = OR V3_SR DUM_V3
 STEP_1 = SIZE V3_SR BY 1.4
 // 4/1.414 = 2.828
 STEP_1_GOOD = STEP_1 INTERACT ALL_VIA_CHECK > 1
 STEP_1_FILTER = V3N NOT INTERACT STEP_1_GOOD
 err1 = STEP_1_FILTER NOT WITH EDGE (EXT [STEP_1_FILTER] ALL_VIA_CHECK < 4 PERP ALSO)
 err1 NOT INSIDE SealR_NOT_BULK
}

#ENDIF


// =======================================================
// Rectangular Vy design rule
// =======================================================

GROUP GRVy1 RVy1_?
 
RVy1_W_1_L_1 {
@ RVy.W.1: Rectangular Vy (RVy) width, except square Vy, MARKS, MARKG, INDMY, LOGO regions = 0.032um
@ RVy.L.1: Length of RVy (width = 0.032um) = 0.080um
 err1 = (V1 NOT 1XV1N) NOT RV1
 err1 NOT INSIDE MARKS_MARKG_INDMY_LOGO
}
 
RVy1_L_2 {
@ Length of Vy bar (width = 0.1/0.45um) >= 0.9um
 CHECK_VIA = V1 NOT OUTSIDE (OR MARKS MARKG)
 CHECK_EDG = (INT [CHECK_VIA] == 0.1 ABUT<90 OPPOSITE EXCLUDE SHIELDED) OR EDGE (INT [CHECK_VIA] == 0.45 ABUT<90 OPPOSITE EXCLUDE SHIELDED)
 err1 = LENGTH CHECK_EDG < 0.90
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
RVy1_S_1 {
@ Space between RVy and (Vy-1 or RVy-1) (including V0 and RV0) at different net and PRL > 0um, when Mxy+1/1.25xMy enclosure of RVy > 0um. >= 0.037um
 chk_via = (V1 INTERACT RV1) NOT COIN EDGE M2
 err1 = EXT chk_via V0 < 0.037 ABUT<90 OPPOSITE REGION NOT CONNECTED
 err1 NOT INSIDE SealR_NOT_BULK
}
 
RVy1_S_1a {
@ Space between RVy >= 0.082um
 err1 = EXT RV1 < 0.082 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
RVy1_S_2 {
@ Space between RVy and Mxy (including M1) at different net >= 0.037um
@ When:
@ 1. Mxy (including M1) enclosure of RVy < 0.003um
@ 2. Mxy+1/1.25xMy width > 0.038um
 y1 = V1 AND (RV1 NOT OUTSIDE (M2 WITH WIDTH > 0.038))
 y2 = EXT [y1] M1 < 0.037 ABUT<90 MEASURE ALL NOT CONNECTED
 y3 = ENC [y2] M1 < 0.003 ABUT<90 OPPOSITE
 err1 = EXT (y1 COIN EDGE y3) M1 < 0.037 ABUT<90 MEASURE ALL NOT CONNECTED REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
RVy1_S_4 {
@ Space between the short side of RVy and Vy when PRL > -0.032um. >= 0.108um
 err1 = EXT RV1_W V1_SR < 0.108 ABUT<90 OPPOSITE EXTENDED 0.032 REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
RVy1_S_5 {
@ Space between the long side of RVy (PRL > 0um, with one Mxy+1/1.25xMy in between) >= 0.115um
 ERRS_AREA = EXT RV1_L < 0.115 ABUT<90 OPPOSITE REGION
 // Also check 072 Line to 080 Line
 ERRS_EDGE = EXT [RV1_L] < 0.115 ABUT<90 OPPOSITE
 ERRS_EDGE_EXP = EXPAND EDGE ERRS_EDGE INSIDE BY 0.001
 ERRS_BULK_MET = (ERRS_AREA OR ERRS_EDGE_EXP) AND M2
 err1_TMP = (ERRS_AREA OR ERRS_EDGE_EXP) INTERACT ERRS_BULK_MET >= 3
 err1 = ERRS_AREA AND err1_TMP
 err1 NOT INSIDE SealR_NOT_BULK
}
 

#IFDEF DFM_RULES_PRIORITY_1 YES

RVy1_EN_1_DFM1 {
@ Recommended RVy enclosure by M1/Mxy is defined by either RVy.EN.2.DFM or RVy.EN.2a.DFM
 err1 = RV1 NOT INSIDE M1
 err1 NOT INSIDE SealR_NOT_BULK
}
 
//;beginning of the RVy.EN.2.DFM derivations
via_RVy_1_2_R_bad = RECTANGLE ENCLOSURE RV1 M1 ABUT<90 SINGULAR OUTSIDE ALSO 
GOOD 0.007 0.025 OPPOSITE 0.007 0.025 OPPOSITE
via_RVy_1_2_R_good = RV1 NOT via_RVy_1_2_R_bad
//;end of the RVy.EN.2.DFM derivations
 
RVy1_EN_2_DFM1 {
@ Recommended RVy enclosure by M1/Mxy for two opposite sides with the other twosides >= 0.007um. >= 0.025um
 err1 = via_RVy_1_2_R_bad NOT via_RVy_1_2a_R_good
 err1 NOT INSIDE SealR_NOT_BULK
}
 
//;beginning of the RVy.EN.2a.DFM derivations
via_RVy_1_2a_R_bad = RECTANGLE ENCLOSURE RV1 M1 ABUT<90 SINGULAR OUTSIDE ALSO 
GOOD 0.020 0.020 0.020 0.020 OPPOSITE
via_RVy_1_2a_R_good = RV1 NOT via_RVy_1_2a_R_bad
//;end of the RVy.EN.2a.DFM derivations
 
RVy1_EN_2a_DFM1 {
@ Recommended RVy enclosure by M1, Mxy for all sides >= 0.02um
 err1 = via_RVy_1_2a_R_bad NOT via_RVy_1_2_R_good
 err2 = (ENC [RV1] M1 < 0.02 ABUT<90 SINGULAR) NOT TOUCH EDGE via_RVy_1_2_R_good
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE EDGE SealR_NOT_BULK
}

#ENDIF

 
RVy1_EN_1 {
@ RVy must be fully enclosed by M1/Mxy where M1/Mxy is the metal layer directly underneath RVy
@ Enclosure by M1/Mxy must follow either RVy.EN.2, RVy.EN.2a or RVy.EN.3
 err1 = RV1 NOT M1
 err1 NOT INSIDE SealR_NOT_BULK
}
 
//;beginning of the RVy.EN.2a derivations
via_RVy_1_2a_bad = RECTANGLE ENCLOSURE RV1 M1 ABUT<90 SINGULAR OUTSIDE ALSO 
GOOD 0.015 0.015 0.015 0.015 OPPOSITE
via_RVy_1_2a_good = RV1 NOT via_RVy_1_2a_bad
//;end of the RVy.EN.2a derivations
 
//;beginning of the RVy.EN.2/3 derivations
via_RVy_1_2_3_bad = RECTANGLE ENCLOSURE RV1 M1 ABUT<90 SINGULAR OUTSIDE ALSO 
GOOD 0 0.024 OPPOSITE 0 0.024 OPPOSITE 
GOOD 0.007 0.019 OPPOSITE 0.007 0.019 OPPOSITE
via_RVy_1_2_3_good = RV1 NOT via_RVy_1_2_3_bad
//;end of the RVy.EN.2/3 derivations
 
RVy1_EN_2a {
@ RVy enclosure by M1 or Mxy for all sides >= 0.015um
 err1 = via_RVy_1_2a_bad NOT via_RVy_1_2_3_good
 err2 = (ENC [RV1] M1 < 0.015 ABUT<90 SINGULAR) NOT TOUCH EDGE via_RVy_1_2_3_good
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE EDGE SealR_NOT_BULK
}
 
RVy1_EN_2_3 {
@ Rvy.EN.2: RVy enclosure by M1 or Mxy when enclosure on either perpendicular direction >= 0um. >= 0.024um
@ RVy.EN.3: RVy enclosure by M1 or Mxy for two opposite sides with the other two sides >= 0.007um. >= 0.019um
 err1 = via_RVy_1_2_3_bad NOT via_RVy_1_2a_good
 err1 NOT INSIDE SealR_NOT_BULK
 // 
 RVy_chk_W_sides = ENC [RV1_W] M1 < 0.007 ABUT<90 OPPOSITE
 RVy_chk_L_sides = ENC (RV1_L) M1 < 0.024 ABUT<90 OPPOSITE
 err2 = ((RV1 INSIDE M1) WITH EDGE RVy_chk_W_sides) WITH EDGE RVy_chk_L_sides == 2
 err2 NOT INSIDE SealR_NOT_BULK
}
 
RVy1_EN_4a {
@ RVy enclosure by M1 in adjacent S1 side, where M1 is the metal layer directly underneath RVy >= 0.004um
@ When:
@ 1) M1 width W: 0.036um <= W <= 0.041um
@ 2) Space: 0.058um <= S1 < 0.063um, the PRL >= 0.083um
@ 3) The opposite space S2 >= 0.069um
 met_wid_all = M1 WITH WIDTH > 0.036-GLOBAL_TOLERANCE <= 0.041
 met_err_RAW_a = EXT [met_wid_all] M1 >= 0.058 < 0.063 ABUT<90 OPPOSITE MEASURE ALL
 met_err_RAW_b = EXT met_wid_all M1 >= 0.058 < 0.063 ABUT<90 OPPOSITE MEASURE ALL
 met_err_RAW_c = EXT met_wid_all [M1] >= 0.058 < 0.063 ABUT<90 OPPOSITE MEASURE ALL
 met_err_PRL = DFM PROPERTY met_err_RAW_b met_err_RAW_c OVERLAP ABUT ALSO MULTI [-= max(LENGTH(met_err_RAW_c))] >= 0.083
 // 
 met_err_EGE_a = met_err_RAW_a COIN EDGE (DFM COPY met_err_PRL EDGE)
 met_err_EGE_b = ENC RV1 [met_err_EGE_a] < 0.004 ABUT<90 OPPOSITE
 met_err_EGE_c = INT met_err_EGE_b [M1] > 0.036-GLOBAL_TOLERANCE <= 0.041 ABUT<90 OPPOSITE MEASURE COIN
 met_err_EGE_d = EXT (met_err_EGE_c) M1 < 0.069 ABUT<90 OPPOSITE
 met_err_EGE_e = met_err_EGE_b COIN EDGE M1
 err1 = INT met_err_EGE_d [met_err_EGE_e] > 0.036-GLOBAL_TOLERANCE <= 0.041 ABUT<90 OPPOSITE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
RVy1_EN_4b {
@ RVy enclosure by M1 in adjacent S1 side, where M1 is the metal layer directly underneath RVy >= 0.004um
@ When:
@ 1) M1 width W: 0.042um <= W <= 0.05um
@ 2) Space: 0.058um <= S1<= 0.067um, the PRL >= 0.136um
 met_wid_all = M1 WITH WIDTH > 0.042-GLOBAL_TOLERANCE <= 0.05
 met_err_RAW_TMP = EXT met_wid_all [M1] >= 0.058 < 0.067+GLOBAL_TOLERANCE ABUT<90 OPPOSITE MEASURE ALL
 met_err_RAW = EXT met_err_RAW_TMP [M1] >= 0.058 < 0.067+GLOBAL_TOLERANCE ABUT<90 OPPOSITE
 // 
 met_jog_ALL = M1_convex_eq_one_edges NOT COIN EDGE met_err_RAW
 met_jog_EXP_a = EXPAND EDGE met_jog_ALL INSIDE BY 0.0005
 met_jog_EXP_b = EXPAND EDGE met_jog_ALL OUTSIDE BY 0.0005
 met_jog_TMP = (met_jog_ALL COIN EDGE (met_jog_EXP_a WITH EDGE met_err_RAW)) COIN EDGE (met_jog_EXP_b WITH EDGE met_err_RAW)
 met_jog_EXP = ((VERTEX (EXPAND EDGE met_jog_TMP OUTSIDE BY 0.001 EXTEND BY 0.001) == 4) OR (EXPAND EDGE met_err_RAW OUTSIDE BY 0.001)) NOT M1
 // 
 met_err_PRL = DFM PROPERTY met_jog_EXP met_err_RAW met_wid_all OVERLAP ABUT ALSO MULTI [-= LENGTH(met_err_RAW)] >= 0.136 [+= COUNT(met_wid_all)] > 0
 met_err_EGE = M1 COIN EDGE (met_err_RAW COIN EDGE (met_err_PRL COIN EDGE met_wid_all))
 err1 = ENC [RV1] met_err_EGE < 0.004 ABUT<90 OPPOSITE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
 
RVy1_EN_6 {
@ RVy enclosure by M1 in adjacent S1 side, where M1 is the metal layer directly underneath RVy >= 0.004um
@ When:
@ 1) M1 width W: 0.051um <= W <= 0.112um
@ 2) Space: 0.058um <= S1 <= 0.094um, the PRL >= 0.136um
@ DRC doesn't check RVy:
@ a) Two RVys with space <= 0.1um in M1 and 1.25xMy/Mxy intersection region
@ b) One Vy and one RVy with space <= 0.1um in M1 and 1.25xMy/Mxy intersection region
 met_wid_all = M1 WITH WIDTH > 0.051-GLOBAL_TOLERANCE <= 0.112
 met_err_RAW_TMP = EXT met_wid_all [M1] >= 0.058 < 0.094+GLOBAL_TOLERANCE ABUT<90 OPPOSITE MEASURE ALL
 met_err_RAW = EXT met_err_RAW_TMP [M1] >= 0.058 < 0.094+GLOBAL_TOLERANCE ABUT<90 OPPOSITE
 // 
 met_jog_ALL = M1_convex_eq_one_edges NOT COIN EDGE met_err_RAW
 met_jog_EXP_a = EXPAND EDGE met_jog_ALL INSIDE BY 0.0005
 met_jog_EXP_b = EXPAND EDGE met_jog_ALL OUTSIDE BY 0.0005
 met_jog_TMP = (met_jog_ALL COIN EDGE (met_jog_EXP_a WITH EDGE met_err_RAW)) COIN EDGE (met_jog_EXP_b WITH EDGE met_err_RAW)
 met_jog_EXP = ((VERTEX (EXPAND EDGE met_jog_TMP OUTSIDE BY 0.001 EXTEND BY 0.001) == 4) OR (EXPAND EDGE met_err_RAW OUTSIDE BY 0.001)) NOT M1
 // 
 met_err_PRL = DFM PROPERTY met_jog_EXP met_err_RAW met_wid_all OVERLAP ABUT ALSO MULTI [-= LENGTH(met_err_RAW)] >= 0.136 [+= COUNT(met_wid_all)] > 0
 met_err_EGE = M1 COIN EDGE (met_err_RAW COIN EDGE (met_err_PRL COIN EDGE met_wid_all))
 via_group_all = SIZE V1 BY 0.05 INSIDE OF (M1 AND M2) STEP 0.02
 via_group_real = V1 INTERACT (via_group_all INTERACT V1 >= 2)
 err1 = ENC (RV1 NOT via_group_real) met_err_EGE < 0.004 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
RVy1_EN_7 {
@ RVy enclosure by Mxy in adjacent S1 side, where Mxy is the metal layer directly underneath RVy >= 0.004um
@ When:
@ 1) Mxy dimension along enclosure direction: 0.113um <= L <= 0.201um
@ 2) Space: 0.058um <= S1 <= 0.094um, the PRL >= 0.083um
 met_wid_all = INT [M1] > 0.113-GLOBAL_TOLERANCE <= 0.201 ABUT<90 OPPOSITE EXCLUDE SHIELDED
 met_err_RAW = EXT [met_wid_all] M1 >= 0.058 < 0.094+GLOBAL_TOLERANCE ABUT<90 OPPOSITE
 met_jog_ALL = M1_convex_eq_one_edges NOT COIN EDGE met_err_RAW
 met_jog_EXP_a = EXPAND EDGE met_jog_ALL INSIDE BY 0.0005
 met_jog_EXP_b = EXPAND EDGE met_jog_ALL OUTSIDE BY 0.0005
 met_jog_TMP = (met_jog_ALL COIN EDGE (met_jog_EXP_a WITH EDGE met_err_RAW)) COIN EDGE (met_jog_EXP_b WITH EDGE met_err_RAW)
 met_jog_EXP = ((VERTEX (EXPAND EDGE met_jog_TMP OUTSIDE BY 0.001 EXTEND BY 0.001) == 4) OR (EXPAND EDGE met_err_RAW OUTSIDE BY 0.001)) NOT M1
 // 
 met_err_PRL = DFM PROPERTY met_jog_EXP met_err_RAW OVERLAP ABUT ALSO MULTI [-= LENGTH(met_err_RAW)] >= 0.083
 met_err_EGE = M1 COIN EDGE (met_err_RAW COIN EDGE met_err_PRL)
 err1 = ENC RV1 met_err_EGE < 0.004 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
RVy1_EN_8 {
@ RVy enclosure by Mxy in adjacent S1 side, where Mxy is the metal layer directly underneath RVy >= 0.014um
@ When:
@ 1) Mxy dimension along enclosure direction: L >= 0.202um
@ 2) Space: 0.058um <= S1 <= 0.094um, PRL >= 0.083um
 met_wid_all = INT (M1) <= 0.202-GLOBAL_TOLERANCE ABUT<90 OPPOSITE EXCLUDE SHIELDED
 met_err_RAW = EXT [met_wid_all] M1 >= 0.058 < 0.094+GLOBAL_TOLERANCE ABUT<90 OPPOSITE
 met_jog_ALL = M1_convex_eq_one_edges NOT COIN EDGE met_err_RAW
 met_jog_EXP_a = EXPAND EDGE met_jog_ALL INSIDE BY 0.0005
 met_jog_EXP_b = EXPAND EDGE met_jog_ALL OUTSIDE BY 0.0005
 met_jog_TMP = (met_jog_ALL COIN EDGE (met_jog_EXP_a WITH EDGE met_err_RAW)) COIN EDGE (met_jog_EXP_b WITH EDGE met_err_RAW)
 met_jog_EXP = ((VERTEX (EXPAND EDGE met_jog_TMP OUTSIDE BY 0.001 EXTEND BY 0.001) == 4) OR (EXPAND EDGE met_err_RAW OUTSIDE BY 0.001)) NOT M1
 // 
 met_err_PRL = DFM PROPERTY met_jog_EXP met_err_RAW OVERLAP ABUT ALSO MULTI [-= LENGTH(met_err_RAW)] >= 0.083
 met_err_EGE = M1 COIN EDGE (met_err_RAW COIN EDGE met_err_PRL)
 err1 = ENC RV1 met_err_EGE < 0.014 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 

#IFDEF DFM_RULES_PRIORITY_1 YES

RVy1_EN_9_DFM1 {
@ Recommended RVy fully enclosure by Mxy+1/1.25xMy is defined by either RVy.EN.9a.DFM or Vy.EN.9b.DFM, which Mxy+1/1.25xMy is the metal layer directly above rectangular RVy.
 err1 = RV1 NOT INSIDE M2
 err1 NOT INSIDE SealR_NOT_BULK
}
 
//;beginning of the RVy.EN.9a.DFM derivations
via_RVy_1_9a_R_bad = RECTANGLE ENCLOSURE RV1 M2 ABUT<90 SINGULAR OUTSIDE ALSO 
GOOD 0.020 0.020 0.020 0.020 OPPOSITE
via_RVy_1_9a_R_good = RV1 NOT via_RVy_1_9a_R_bad
//;end of the RVy.EN.9a.DFM derivations
 
RVy1_EN_9a_DFM1 {
@ Recommended RVy enclosure by Mxy+1/1.25xMy for all sides >= 0.020um
 err1 = via_RVy_1_9a_R_bad NOT via_RVy_1_9b_R_good
 err1 NOT INSIDE SealR_NOT_BULK
}
 
//;beginning of the RVy.EN.9b.DFM derivations
via_RVy_1_9b_R_bad = RECTANGLE ENCLOSURE RV1 M2 ABUT<90 SINGULAR OUTSIDE ALSO 
GOOD 0.007 0.025 OPPOSITE 0.007 0.025 OPPOSITE
via_RVy_1_9b_R_good = RV1 NOT via_RVy_1_9b_R_bad
//;end of the RVy.EN.9b.DFM derivations
 
RVy1_EN_9b_DFM1 {
@ Recommended RVy enclosure by Mxy+1/1.25xMy for two opposite sides with the other twosides >= 0.007um. >= 0.025um
 err1 = via_RVy_1_9b_R_bad NOT via_RVy_1_9a_R_good
 err2 = (ENC [RV1] M2 < 0.02 ABUT<90 SINGULAR) NOT TOUCH EDGE via_RVy_1_9b_R_good
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE EDGE SealR_NOT_BULK
}

#ENDIF

 
//;RVy.EN.9 only for Mxy+1 
//;beginning of the RVy.EN.9 derivations
via_RVy1_bad_9_1 = RECTANGLE ENCLOSURE RV1 M2 ABUT<90 SINGULAR 
GOOD 0.015 0.015 0.015 0.015 OPPOSITE
via_RVy1_good_9_1 = RV1 NOT via_RVy1_bad_9_1
// 
via_RVy1_good_9_2_TMP = ENC [RV1_W] M2 < 0.024 ABUT<90 OPPOSITE
via_RVy1_good_9_2 = via_RVy1_bad_9_1 NOT WITH EDGE via_RVy1_good_9_2_TMP
// 
via_RVy1_bad_9_3 = RECTANGLE ENCLOSURE RV1 M2 ABUT<90 SINGULAR 
GOOD 0.007 0.019 OPPOSITE 0.007 0.019 OPPOSITE
via_RVy1_good_9_3 = RV1 NOT via_RVy1_bad_9_3
 
via_RVy1_9_bad = RV1 NOT (OR via_RVy1_good_9_1 via_RVy1_good_9_2 via_RVy1_good_9_3)
via_RVy1_9_good = RV1 NOT via_RVy1_9_bad
//;end of the RVy.EN.9 derivations
 
RVy1_EN_9 {
@ RVy must be fully enclosed by Mxy+1/1.25xMy where Mxy+1/1.25xMy is the metal layer directly above rectangular Vy
@ Enclosure by Mxy+1/1.25xMy must follow one of RVy.EN.9.1, RVy.EN.9.2, RVy.EN.9.3, RVy.EN.10 RVy.EN.10a1, RVy.EN.10a2, RVy.EN.10b or RVy.EN.11 or RVy.EN.12
 err1 = RV1 NOT M2
 err1 NOT INSIDE SealR_NOT_BULK
}
 
RVy1_EN_9_1_2_3 {
@ RVy.EN.9.1: RVy enclosure by Mxy+1 for all sides >= 0.015um
@ RVy.EN.9.2: Enclosure of short side of RVy by Mxy+1 for two opposite sides with the other two side >= 0um. >= 0.024um
@ RVy.EN.9.3: RVy enclosure by Mxy+1 for two opposite sides with the other two sides >= 0.007um. >= 0.019um
 err1 = copy via_RVy1_9_bad
 err1 NOT INSIDE SealR_NOT_BULK
}
 
RVy1_EN_9_4 {
@ RVy enclosure by Mxy+1 (0.036um <= Mxy+1 width <= 0.041um 0.058um <= space < 0.063um and the opposite space >= 0.069um, PRL >= 0.083um) >= 0.004um
 met_wid_all = M2 WITH WIDTH > 0.036-GLOBAL_TOLERANCE <= 0.041
 met_err_RAW_a = EXT [met_wid_all] M2 >= 0.058 < 0.063 ABUT<90 OPPOSITE MEASURE ALL
 met_err_RAW_b = EXT met_wid_all M2 >= 0.058 < 0.063 ABUT<90 OPPOSITE MEASURE ALL
 met_err_RAW_c = EXT met_wid_all [M2] >= 0.058 < 0.063 ABUT<90 OPPOSITE MEASURE ALL
 met_err_PRL = DFM PROPERTY met_err_RAW_b met_err_RAW_c OVERLAP ABUT ALSO MULTI [-= max(LENGTH(met_err_RAW_c))] >= 0.083
 // 
 met_err_EGE_a = met_err_RAW_a COIN EDGE (DFM COPY met_err_PRL EDGE)
 met_err_EGE_b = ENC RV1 [met_err_EGE_a] < 0.004 ABUT<90 OPPOSITE
 met_err_EGE_c = INT met_err_EGE_b [M2] > 0.036-GLOBAL_TOLERANCE <= 0.041 ABUT<90 OPPOSITE MEASURE COIN
 met_err_EGE_d = EXT (met_err_EGE_c) M2 < 0.069 ABUT<90 OPPOSITE
 met_err_EGE_e = met_err_EGE_b COIN EDGE M2
 err1 = INT met_err_EGE_d [met_err_EGE_e] > 0.036-GLOBAL_TOLERANCE <= 0.041 ABUT<90 OPPOSITE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
//;RVy.EN.10~RVy.EN.14 only for 125xMn+1/125xMy+1 
 
RVy1_R_1 {
@ Single RVy is not allowed in H-shape Mxy+1/1.25xMy, when:
@ 1) The Mxy+1/1.25xMy has H-shape interacting with two metal holes: both two metal holes length <= 4.5um and two metal hole area <= 4.05um2
@ 2) The RVy overlaps on the center metal bar of this H-shape Mxy+1/1.25xMy
@ 3) The center metal bar length <= 0.9um and the metal bar width <= 0.12um
 // @ DRC doesn't check when one or more square 1xVn is also on H-shape Mxy+1/1.25xMy region
 hole_area_meet = AREA (HOLES M2 INNER) <= 4.05
 hole_area_meet_len = (hole_area_meet WITH EDGE (LENGTH hole_area_meet <= 0.9)) NOT WITH EDGE (LENGTH hole_area_meet > 4.5)
 hole_area_real = (hole_area_meet_len NOT ENCLOSE RECTANGLE 0.9+GLOBAL_TOLERANCE 4.5) NOT ENCLOSE RECTANGLE 0.9 4.5+GLOBAL_TOLERANCE
 hole_bars_len = M2 COIN EDGE hole_area_real
 // 
 hole_bars = INT hole_bars_len <= 0.12 ABUT<90 OPPOSITE REGION EXCLUDE SHIELDED
 hole_bars_real = hole_bars WITH EDGE (LENGTH hole_bars_len <= 0.9)
 hole_bars_vias_rect = RV1 INTERACT ((hole_bars_real INTERACT hole_area_real == 2) NOT ENCLOSE V1N >= 2)
 err1 = hole_bars_real INTERACT hole_bars_vias_rect == 1
 err1 NOT INSIDE SealR_NOT_BULK
}
 
RVy1_R_2 {
@ Redundant via requirement must be obeyed by one of following conditions of Vy numbers and space for Mxy and 1.25xMy connection
@ (One of Mxy or 1.25xMy has width and length >= 0.162um) (Except VIA bar)
@ 1) At least one rectangular Vy
@ 2) At least two square Vy with space <= 0.091um
@ 3) At least four square Vy with space <= 0.415um
 X1a = WITH WIDTH M1 > 0.162-GLOBAL_TOLERANCE <= 0.272-GLOBAL_TOLERANCE
 X1b = WITH WIDTH M2 > 0.162-GLOBAL_TOLERANCE <= 0.272-GLOBAL_TOLERANCE
 Y1a = WITH WIDTH M1 > 0.272-GLOBAL_TOLERANCE
 Y1b = WITH WIDTH M2 > 0.272-GLOBAL_TOLERANCE
 WIDE_1 = (X1a AND M2) ENCLOSE V1
 WIDE_2 = (M1 AND X1b) ENCLOSE V1
 WIDE_3 = (Y1a AND M2) ENCLOSE V1
 WIDE_4 = (M1 AND Y1b) ENCLOSE V1
 WIDE_all_raw = (WIDE_1 OR WIDE_2) NOT (WIDE_3 OR WIDE_4)
 WIDE_all = (M1 AND M2) NOT OUTSIDE WIDE_all_raw
 // 
 // condition 1 & 2
 Y1_good = WIDE_all_raw AND RV1
 Y2_good = WIDE_all_raw AND 2XV1N
 // 
 // condition 3
 Y3_wide_all = WIDE_all_raw NOT INTERACT (OR Y1_good Y2_good)
 Y3_wide = (WIDE_all INTERACT Y3_wide_all) INTERACT V1_SR >= 2
 Y3_comb_step = SIZE V1_SR BY 0.091/2 INSIDE OF Y3_wide STEP 0.020
 Y3_good_step = OR (Y3_comb_step INTERACT V1N >= 2) (Y3_comb_step INTERACT (OR RV1 2XV1N))
 Y3_good = WIDE_all_raw AND Y3_good_step
 // 
 // condition 4: 32nm*32nm via can be replaced by 2XVia/RVia
 Y4_wide_all = WIDE_all_raw NOT INTERACT (OR Y1_good Y2_good Y3_good)
 Y4_wide = (WIDE_all INTERACT Y4_wide_all) INTERACT V1_SR >= 2 // rectangle array 0.415/2 =0.207
 Y4_vias_input = V1_SR AND Y4_wide
 Y4_wide_chk_1 = Y4_wide INTERACT Y4_wide_all
 Y4_comb_step1 = SIZE Y4_vias_input BY 0.050 INSIDE OF Y4_wide_chk_1 STEP 0.020
 Y4_good_step1_a = OR (Y4_comb_step1 INTERACT V1N >= 4) ((Y4_comb_step1 INTERACT V1N >= 2) INTERACT (OR RV1 2XV1N)) // step1: 0.050
 Y4_good_step1_b = OR (Y4_comb_step1 INTERACT 2XV1N >= 2) (Y4_comb_step1 INTERACT RV1 >= 2)
 Y4_good_step1 = OR Y4_good_step1_a Y4_good_step1_b
 // 
 Y4_wide_chk_2 = Y4_wide_chk_1 INTERACT (WIDE_all_raw NOT INTERACT Y4_good_step1)
 Y4_comb_step2 = SIZE Y4_comb_step1 BY 0.035 INSIDE OF Y4_wide_chk_2 STEP 0.020
 Y4_good_step2_a = OR (Y4_comb_step2 INTERACT V1N >= 4) ((Y4_comb_step2 INTERACT V1N >= 2) INTERACT (OR RV1 2XV1N)) // step2: 0.035
 Y4_good_step2_b = OR (Y4_comb_step2 INTERACT 2XV1N >= 2) (Y4_comb_step2 INTERACT RV1 >= 2)
 Y4_good_step2 = OR Y4_good_step2_a Y4_good_step2_b
 // 
 Y4_wide_chk_3 = Y4_wide_chk_2 INTERACT (WIDE_all_raw NOT INTERACT Y4_good_step2)
 Y4_comb_step3 = SIZE Y4_comb_step2 BY 0.035 INSIDE OF Y4_wide_chk_3 STEP 0.020
 Y4_good_step3_a = OR (Y4_comb_step3 INTERACT V1N >= 4) ((Y4_comb_step3 INTERACT V1N >= 2) INTERACT (OR RV1 2XV1N)) // step3: 0.035
 Y4_good_step3_b = OR (Y4_comb_step3 INTERACT 2XV1N >= 2) (Y4_comb_step3 INTERACT RV1 >= 2)
 Y4_good_step3 = OR Y4_good_step3_a Y4_good_step3_b
 // 
 Y4_wide_chk_4 = Y4_wide_chk_3 INTERACT (WIDE_all_raw NOT INTERACT Y4_good_step3)
 Y4_comb_step4 = SIZE Y4_comb_step3 BY 0.035 INSIDE OF Y4_wide_chk_4 STEP 0.020
 Y4_good_step4_a = OR (Y4_comb_step4 INTERACT V1N >= 4) ((Y4_comb_step4 INTERACT V1N >= 2) INTERACT (OR RV1 2XV1N)) // step4: 0.035
 Y4_good_step4_b = OR (Y4_comb_step4 INTERACT 2XV1N >= 2) (Y4_comb_step4 INTERACT RV1 >= 2)
 Y4_good_step4 = OR Y4_good_step4_a Y4_good_step4_b
 // 
 Y4_wide_chk_5 = Y4_wide_chk_4 INTERACT (WIDE_all_raw NOT INTERACT Y4_good_step4)
 Y4_comb_step5 = SIZE Y4_comb_step4 BY 0.035 INSIDE OF Y4_wide_chk_5 STEP 0.020
 Y4_good_step5_a = OR (Y4_comb_step5 INTERACT V1N >= 4) ((Y4_comb_step5 INTERACT V1N >= 2) INTERACT (OR RV1 2XV1N)) // step5: 0.035
 Y4_good_step5_b = OR (Y4_comb_step5 INTERACT 2XV1N >= 2) (Y4_comb_step5 INTERACT RV1 >= 2)
 Y4_good_step5 = OR Y4_good_step5_a Y4_good_step5_b
 // 
 Y4_wide_chk_6 = Y4_wide_chk_5 INTERACT (WIDE_all_raw NOT INTERACT Y4_good_step5)
 Y4_comb_step6 = SIZE Y4_comb_step5 BY 0.018 INSIDE OF Y4_wide_chk_6 STEP 0.015
 Y4_good_step6_a = OR (Y4_comb_step6 INTERACT V1N >= 4) ((Y4_comb_step6 INTERACT V1N >= 2) INTERACT (OR RV1 2XV1N)) // step6: 0.207-0.05-0.035*4=0.018
 Y4_good_step6_b = OR (Y4_comb_step6 INTERACT 2XV1N >= 2) (Y4_comb_step6 INTERACT RV1 >= 2)
 Y4_good_step6 = OR Y4_good_step6_a Y4_good_step6_b
 Y4_good = WIDE_all_raw AND (OR Y4_good_step1 Y4_good_step2 Y4_good_step3 Y4_good_step4 Y4_good_step5 Y4_good_step6)
 // 
 err1 = (WIDE_all_raw OUTSIDE (OR Y1_good Y2_good Y3_good Y4_good)) INTERACT V1
 err1 NOT INTERACT Vy1_BAR
}
 
RVy1_R_3 {
@ Redundant via requirement must be obeyed by one of following conditions of Vy numbers and space for Mxy and 1.25xMy connection
@ (One of Mxy or 1.25xMy has width and length >= 0.272um, two square vias are equal to one rectangular via for below conditions) (Except VIA bar, MARKS and OCCD region)
@ 1) At least four square Vy with space <= 0.091um
@ 2) At least nine square Vy with space <= 0.545um
@ 3) At least two rectangular Vy with space <= 0.202um
@ 4) At least five rectangular Vy with space <= 0.545um
 X1a = WITH WIDTH M1 > 0.272-GLOBAL_TOLERANCE
 X1b = WITH WIDTH M2 > 0.272-GLOBAL_TOLERANCE
 WIDE_1 = (X1a AND M2) ENCLOSE V1
 WIDE_2 = (M1 AND X1b) ENCLOSE V1
 WIDE_all_raw = WIDE_1 OR WIDE_2
 WIDE_all = (M1 AND M2) NOT OUTSIDE WIDE_all_raw
 // 
 // condition 3: not replaced by RVia
 Y3_wide = WIDE_all INTERACT V1N >= 4 // rectangle array 0.091/2=0.045
 Y3_vias_input = V1N AND Y3_wide
 Y3_comb_step = SIZE Y3_vias_input BY 0.091/2 INSIDE OF Y3_wide STEP 0.02 // via minimum space = 0.083
 Y3_good_step = Y3_comb_step INTERACT V1N >= 4
 Y3_good = WIDE_all_raw AND Y3_good_step
 // 
 // condition 1 & 2 & 4 & 5: 32nm*32nm via can be replaced by 2XVia/RVia
 Y1_wide_all = WIDE_all_raw NOT INTERACT Y3_good
 Y1_wide = (WIDE_all INTERACT Y1_wide_all) INTERACT V1_SR >= 2 // rectangle array 0.545/2=0.272
 Y1_vias_input = V1_SR AND Y1_wide
 Y1_wide_chk_1 = Y1_wide INTERACT Y1_wide_all
 Y1_comb_step1 = SIZE Y1_vias_input BY 0.061 INSIDE OF Y1_wide_chk_1 STEP 0.02 // step1: 0.061, via minimum space = 0.202/2=0.101
 Y1_good_step1_a = Y1_comb_step1 INTERACT V1N >= 9
 Y1_good_step1_b = Y1_comb_step1 INTERACT RV1 >= 5
 Y1_good_step1_c = Y1_comb_step1 INTERACT 2XV1N >= 3
 Y1_good_step1_d = (Y1_comb_step1 INTERACT 1XV1N >= 7) INTERACT RV1 >= 1
 Y1_good_step1_e = (Y1_comb_step1 INTERACT 1XV1N >= 6) INTERACT 2XV1N >= 1
 Y1_good_step1_f = (Y1_comb_step1 INTERACT 1XV1N >= 5) INTERACT RV1 >= 2
 Y1_good_step1_g = ((Y1_comb_step1 INTERACT 1XV1N >= 4) INTERACT 2XV1N >= 1) INTERACT RV1 >= 1
 Y1_good_step1_h = (Y1_comb_step1 INTERACT 1XV1N >= 3) INTERACT RV1 >= 3
 Y1_good_step1_i = (Y1_comb_step1 INTERACT 1XV1N >= 3) INTERACT 2XV1N >= 2
 Y1_good_step1_j = ((Y1_comb_step1 INTERACT 1XV1N >= 2) INTERACT 2XV1N >= 1) INTERACT RV1 >= 2
 // SETLAYER Y1_good_step1_k = (Y1_comb_step1 INTERACT 1XV1N >= 1) INTERACT RV1 >= 4
 Y1_good_step1_l = ((Y1_comb_step1 INTERACT 1XV1N >= 1) INTERACT 2XV1N >= 2) INTERACT RV1 >= 1
 Y1_good_step1_m = Y1_comb_step1 INTERACT RV1 >= 2 // remove good condition3_val: 0.202
 Y1_good_step1_n = Y1_comb_step1 INTERACT 2XV1N >= 2
 Y1_good_step1_o = (Y1_comb_step1 INTERACT 1XV1N >= 2) INTERACT RV1 >= 1
 Y1_good_step1_p = (Y1_comb_step1 INTERACT 1XV1N >= 1) INTERACT 2XV1N >= 1
 Y1_good_step1_q = (Y1_comb_step1 INTERACT 2XV1N >= 1) INTERACT RV1 >= 1
 Y1_good_step1_r = OR Y1_good_step1_a Y1_good_step1_b Y1_good_step1_c Y1_good_step1_d Y1_good_step1_e Y1_good_step1_f Y1_good_step1_g Y1_good_step1_h
 Y1_good_step1_s = OR Y1_good_step1_i Y1_good_step1_j Y1_good_step1_l Y1_good_step1_m Y1_good_step1_n Y1_good_step1_o Y1_good_step1_p Y1_good_step1_q
 Y1_good_step1 = OR Y1_good_step1_r Y1_good_step1_s
 // 
 Y1_wide_chk_2 = Y1_wide_chk_1 INTERACT (WIDE_all_raw NOT INTERACT Y1_good_step1)
 Y1_comb_step2 = SIZE Y1_comb_step1 BY 0.040 INSIDE OF Y1_wide_chk_2 STEP 0.02 // step2: 0.040
 Y1_good_step2_a = Y1_comb_step2 INTERACT V1N >= 9
 Y1_good_step2_b = Y1_comb_step2 INTERACT RV1 >= 5
 Y1_good_step2_c = Y1_comb_step2 INTERACT 2XV1N >= 3
 Y1_good_step2_d = (Y1_comb_step2 INTERACT 1XV1N >= 7) INTERACT RV1 >= 1
 Y1_good_step2_e = (Y1_comb_step2 INTERACT 1XV1N >= 6) INTERACT 2XV1N >= 1
 Y1_good_step2_f = (Y1_comb_step2 INTERACT 1XV1N >= 5) INTERACT RV1 >= 2
 Y1_good_step2_g = ((Y1_comb_step2 INTERACT 1XV1N >= 4) INTERACT 2XV1N >= 1) INTERACT RV1 >= 1
 Y1_good_step2_h = (Y1_comb_step2 INTERACT 1XV1N >= 3) INTERACT RV1 >= 3
 Y1_good_step2_i = (Y1_comb_step2 INTERACT 1XV1N >= 3) INTERACT 2XV1N >= 2
 Y1_good_step2_j = ((Y1_comb_step2 INTERACT 1XV1N >= 2) INTERACT 2XV1N >= 1) INTERACT RV1 >= 2
 // SETLAYER Y1_good_step2_k = (Y1_comb_step2 INTERACT 1XV1N >= 1) INTERACT RV1 >= 4
 Y1_good_step2_l = ((Y1_comb_step2 INTERACT 1XV1N >= 1) INTERACT 2XV1N >= 2) INTERACT RV1 >= 1
 Y1_good_step2_m = Y1_comb_step2 INTERACT RV1 >= 2
 Y1_good_step2_n = Y1_comb_step2 INTERACT 2XV1N >= 2
 Y1_good_step2_o = (Y1_comb_step2 INTERACT 1XV1N >= 2) INTERACT RV1 >= 1
 Y1_good_step2_p = (Y1_comb_step2 INTERACT 1XV1N >= 1) INTERACT 2XV1N >= 1
 Y1_good_step2_q = (Y1_comb_step2 INTERACT 2XV1N >= 1) INTERACT RV1 >= 1
 Y1_good_step2_r = OR Y1_good_step2_a Y1_good_step2_b Y1_good_step2_c Y1_good_step2_d Y1_good_step2_e Y1_good_step2_f Y1_good_step2_g Y1_good_step2_h
 Y1_good_step2_s = OR Y1_good_step2_i Y1_good_step2_j Y1_good_step2_l Y1_good_step2_m Y1_good_step2_n Y1_good_step2_o Y1_good_step2_p Y1_good_step2_q
 Y1_good_step2 = OR Y1_good_step2_r Y1_good_step2_s
 // 
 // condition 1 & 2 & 4 & 5: 32nm*32nm via can be replaced by 2XVia/RVia
 Y1_wide_chk_3 = Y1_wide_chk_2 INTERACT (WIDE_all_raw NOT INTERACT Y1_good_step2)
 Y1_comb_step3 = SIZE Y1_comb_step2 BY 0.04 INSIDE OF Y1_wide_chk_3 STEP 0.02 // step3: 0.040
 Y1_good_step3_a = Y1_comb_step3 INTERACT V1N >= 9
 Y1_good_step3_b = Y1_comb_step3 INTERACT RV1 >= 5
 Y1_good_step3_c = Y1_comb_step3 INTERACT 2XV1N >= 3
 Y1_good_step3_d = (Y1_comb_step3 INTERACT 1XV1N >= 7) INTERACT RV1 >= 1
 Y1_good_step3_e = (Y1_comb_step3 INTERACT 1XV1N >= 6) INTERACT 2XV1N >= 1
 Y1_good_step3_f = (Y1_comb_step3 INTERACT 1XV1N >= 5) INTERACT RV1 >= 2
 Y1_good_step3_g = ((Y1_comb_step3 INTERACT 1XV1N >= 4) INTERACT 2XV1N >= 1) INTERACT RV1 >= 1
 Y1_good_step3_h = (Y1_comb_step3 INTERACT 1XV1N >= 3) INTERACT RV1 >= 3
 Y1_good_step3_i = (Y1_comb_step3 INTERACT 1XV1N >= 3) INTERACT 2XV1N >= 2
 Y1_good_step3_j = ((Y1_comb_step3 INTERACT 1XV1N >= 2) INTERACT 2XV1N >= 1) INTERACT RV1 >= 2
 // SETLAYER Y1_good_step3_k = (Y1_comb_step3 INTERACT 1XV1N >= 1) INTERACT RV1 >= 4
 Y1_good_step3_l = ((Y1_comb_step3 INTERACT 1XV1N >= 1) INTERACT 2XV1N >= 2) INTERACT RV1 >= 1
 Y1_good_step3_r = OR Y1_good_step3_a Y1_good_step3_b Y1_good_step3_c Y1_good_step3_d Y1_good_step3_e Y1_good_step3_f Y1_good_step3_g Y1_good_step3_h
 Y1_good_step3_s = OR Y1_good_step3_i Y1_good_step3_j Y1_good_step3_l
 Y1_good_step3 = OR Y1_good_step3_r Y1_good_step3_s
 // 
 Y1_wide_chk_4 = Y1_wide_chk_3 INTERACT (WIDE_all_raw NOT INTERACT Y1_good_step3)
 Y1_comb_step4 = SIZE Y1_comb_step3 BY 0.040 INSIDE OF Y1_wide_chk_4 STEP 0.02 // step4: 0.040
 Y1_good_step4_a = Y1_comb_step4 INTERACT V1N >= 9
 Y1_good_step4_b = Y1_comb_step4 INTERACT RV1 >= 5
 Y1_good_step4_c = Y1_comb_step4 INTERACT 2XV1N >= 3
 Y1_good_step4_d = (Y1_comb_step4 INTERACT 1XV1N >= 7) INTERACT RV1 >= 1
 Y1_good_step4_e = (Y1_comb_step4 INTERACT 1XV1N >= 6) INTERACT 2XV1N >= 1
 Y1_good_step4_f = (Y1_comb_step4 INTERACT 1XV1N >= 5) INTERACT RV1 >= 2
 Y1_good_step4_g = ((Y1_comb_step4 INTERACT 1XV1N >= 4) INTERACT 2XV1N >= 1) INTERACT RV1 >= 1
 Y1_good_step4_h = (Y1_comb_step4 INTERACT 1XV1N >= 3) INTERACT RV1 >= 3
 Y1_good_step4_i = (Y1_comb_step4 INTERACT 1XV1N >= 3) INTERACT 2XV1N >= 2
 Y1_good_step4_j = ((Y1_comb_step4 INTERACT 1XV1N >= 2) INTERACT 2XV1N >= 1) INTERACT RV1 >= 2
 // SETLAYER Y1_good_step4_k = (Y1_comb_step4 INTERACT 1XV1N >= 1) INTERACT RV1 >= 4
 Y1_good_step4_l = ((Y1_comb_step4 INTERACT 1XV1N >= 1) INTERACT 2XV1N >= 2) INTERACT RV1 >= 1
 Y1_good_step4_r = OR Y1_good_step4_a Y1_good_step4_b Y1_good_step4_c Y1_good_step4_d Y1_good_step4_e Y1_good_step4_f Y1_good_step4_g Y1_good_step4_h
 Y1_good_step4_s = OR Y1_good_step4_i Y1_good_step4_j Y1_good_step4_l
 Y1_good_step4 = OR Y1_good_step4_r Y1_good_step4_s
 // 
 Y1_wide_chk_5 = Y1_wide_chk_4 INTERACT (WIDE_all_raw NOT INTERACT Y1_good_step4)
 Y1_comb_step5 = SIZE Y1_comb_step4 BY 0.040 INSIDE OF Y1_wide_chk_5 STEP 0.02 // step5: 0.040
 Y1_good_step5_a = Y1_comb_step5 INTERACT V1N >= 9
 Y1_good_step5_b = Y1_comb_step5 INTERACT RV1 >= 5
 Y1_good_step5_c = Y1_comb_step5 INTERACT 2XV1N >= 3
 Y1_good_step5_d = (Y1_comb_step5 INTERACT 1XV1N >= 7) INTERACT RV1 >= 1
 Y1_good_step5_e = (Y1_comb_step5 INTERACT 1XV1N >= 6) INTERACT 2XV1N >= 1
 Y1_good_step5_f = (Y1_comb_step5 INTERACT 1XV1N >= 5) INTERACT RV1 >= 2
 Y1_good_step5_g = ((Y1_comb_step5 INTERACT 1XV1N >= 4) INTERACT 2XV1N >= 1) INTERACT RV1 >= 1
 Y1_good_step5_h = (Y1_comb_step5 INTERACT 1XV1N >= 3) INTERACT RV1 >= 3
 Y1_good_step5_i = (Y1_comb_step5 INTERACT 1XV1N >= 3) INTERACT 2XV1N >= 2
 Y1_good_step5_j = ((Y1_comb_step5 INTERACT 1XV1N >= 2) INTERACT 2XV1N >= 1) INTERACT RV1 >= 2
 // SETLAYER Y1_good_step5_k = (Y1_comb_step5 INTERACT 1XV1N >= 1) INTERACT RV1 >= 4
 Y1_good_step5_l = ((Y1_comb_step5 INTERACT 1XV1N >= 1) INTERACT 2XV1N >= 2) INTERACT RV1 >= 1
 Y1_good_step5_r = OR Y1_good_step5_a Y1_good_step5_b Y1_good_step5_c Y1_good_step5_d Y1_good_step5_e Y1_good_step5_f Y1_good_step5_g Y1_good_step5_h
 Y1_good_step5_s = OR Y1_good_step5_i Y1_good_step5_j Y1_good_step5_l
 Y1_good_step5 = OR Y1_good_step5_r Y1_good_step5_s
 // 
 Y1_wide_chk_6 = Y1_wide_chk_5 INTERACT (WIDE_all_raw NOT INTERACT Y1_good_step5)
 Y1_comb_step6 = SIZE Y1_comb_step5 BY 0.040 INSIDE OF Y1_wide_chk_6 STEP 0.02 // step6: 0.040
 Y1_good_step6_a = Y1_comb_step6 INTERACT V1N >= 9
 Y1_good_step6_b = Y1_comb_step6 INTERACT RV1 >= 5
 Y1_good_step6_c = Y1_comb_step6 INTERACT 2XV1N >= 3
 Y1_good_step6_d = (Y1_comb_step6 INTERACT 1XV1N >= 7) INTERACT RV1 >= 1
 Y1_good_step6_e = (Y1_comb_step6 INTERACT 1XV1N >= 6) INTERACT 2XV1N >= 1
 Y1_good_step6_f = (Y1_comb_step6 INTERACT 1XV1N >= 5) INTERACT RV1 >= 2
 Y1_good_step6_g = ((Y1_comb_step6 INTERACT 1XV1N >= 4) INTERACT 2XV1N >= 1) INTERACT RV1 >= 1
 Y1_good_step6_h = (Y1_comb_step6 INTERACT 1XV1N >= 3) INTERACT RV1 >= 3
 Y1_good_step6_i = (Y1_comb_step6 INTERACT 1XV1N >= 3) INTERACT 2XV1N >= 2
 Y1_good_step6_j = ((Y1_comb_step6 INTERACT 1XV1N >= 2) INTERACT 2XV1N >= 1) INTERACT RV1 >= 2
 // SETLAYER Y1_good_step6_k = (Y1_comb_step6 INTERACT 1XV1N >= 1) INTERACT RV1 >= 4
 Y1_good_step6_l = ((Y1_comb_step6 INTERACT 1XV1N >= 1) INTERACT 2XV1N >= 2) INTERACT RV1 >= 1
 Y1_good_step6_r = OR Y1_good_step6_a Y1_good_step6_b Y1_good_step6_c Y1_good_step6_d Y1_good_step6_e Y1_good_step6_f Y1_good_step6_g Y1_good_step6_h
 Y1_good_step6_s = OR Y1_good_step6_i Y1_good_step6_j Y1_good_step6_l
 Y1_good_step6 = OR Y1_good_step6_r Y1_good_step6_s
 // 
 Y1_wide_chk_7 = Y1_wide_chk_6 INTERACT (WIDE_all_raw NOT INTERACT Y1_good_step6)
 Y1_comb_step7 = SIZE Y1_comb_step6 BY 0.011 INSIDE OF Y1_wide_chk_7 STEP 0.02 // step7: 0.272-0.061-0.04-0.040*4=0.011
 Y1_good_step7_a = Y1_comb_step7 INTERACT V1N >= 9
 Y1_good_step7_b = Y1_comb_step7 INTERACT RV1 >= 5
 Y1_good_step7_c = Y1_comb_step7 INTERACT 2XV1N >= 3
 Y1_good_step7_d = (Y1_comb_step7 INTERACT 1XV1N >= 7) INTERACT RV1 >= 1
 Y1_good_step7_e = (Y1_comb_step7 INTERACT 1XV1N >= 6) INTERACT 2XV1N >= 1
 Y1_good_step7_f = (Y1_comb_step7 INTERACT 1XV1N >= 5) INTERACT RV1 >= 2
 Y1_good_step7_g = ((Y1_comb_step7 INTERACT 1XV1N >= 4) INTERACT 2XV1N >= 1) INTERACT RV1 >= 1
 Y1_good_step7_h = (Y1_comb_step7 INTERACT 1XV1N >= 3) INTERACT RV1 >= 3
 Y1_good_step7_i = (Y1_comb_step7 INTERACT 1XV1N >= 3) INTERACT 2XV1N >= 2
 Y1_good_step7_j = ((Y1_comb_step7 INTERACT 1XV1N >= 2) INTERACT 2XV1N >= 1) INTERACT RV1 >= 2
 // SETLAYER Y1_good_step7_k = (Y1_comb_step7 INTERACT 1XV1N >= 1) INTERACT RV1 >= 4
 Y1_good_step7_l = ((Y1_comb_step7 INTERACT 1XV1N >= 1) INTERACT 2XV1N >= 2) INTERACT RV1 >= 1
 Y1_good_step7_r = OR Y1_good_step7_a Y1_good_step7_b Y1_good_step7_c Y1_good_step7_d Y1_good_step7_e Y1_good_step7_f Y1_good_step7_g Y1_good_step7_h
 Y1_good_step7_s = OR Y1_good_step7_i Y1_good_step7_j Y1_good_step7_l
 Y1_good_step7 = OR Y1_good_step7_r Y1_good_step7_s
 Y1_Y2_Y4_good = WIDE_all_raw AND (OR Y1_good_step1 Y1_good_step2 Y1_good_step3 Y1_good_step4 Y1_good_step5 Y1_good_step6 Y1_good_step7)
 // 
 err1 = (WIDE_all_raw OUTSIDE (OR Y1_Y2_Y4_good Y3_good)) INTERACT V1
 (err1 NOT INTERACT Vy1_BAR) NOT INSIDE OCCD_MARKS
}
 
RVy1_R_4_M1 {
@ There should be at least two square Vy or one rectangular Vy in the intersection area of bottom metal and upper metal, when either wide metal Mxy or 1.25xMy length >= 0.162um and width >= 0.162um, the space between either via and wide metal <= 0.5um (S, S is the shortest running path length from Via to the wide metal). (except via bar)
 // DRC flags each intersecting area ({bottom metal AND upper metal}) with single square Via within the branch check region
 wide_M1 = (WITH WIDTH M1 > 0.162-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 0.162-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 0.162-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M1_real = wide_M1 NOT OUTSIDE ((SIZE wide_M1 BY 0.5+GLOBAL_TOLERANCE) INTERACT V1)
 all_down_and_up = (M1 INTERACT wide_M1) AND M2
 dis_down_arm_wide_all = SIZE wide_M1_real BY 0.5+GLOBAL_TOLERANCE INSIDE OF M1 STEP 0.025
 dis_down_and_up = dis_down_arm_wide_all AND all_down_and_up
 dis_down_and_up_arm = (dis_down_and_up NOT wide_M1) AND M1
 dis_down_arm = (dis_down_arm_wide_all NOT wide_M1) AND M1
 // 
 dis_down_arm_good_a = dis_down_and_up_arm INTERACT 1XV1N >= 2
 dis_down_arm_good_b = dis_down_and_up_arm INTERACT RV1
 dis_down_arm_good_c = dis_down_and_up_arm INTERACT 2XV1N
 dis_down_arm_good = OR dis_down_arm_good_a dis_down_arm_good_b dis_down_arm_good_c
 dis_down_arm_bad = (dis_down_and_up_arm NOT dis_down_arm_good) INTERACT (all_down_and_up INTERACT 1XV1N == 1)
 // 
 dis_down_arm_err_stack = (dis_down_arm_bad AND dis_down_and_up_arm) INTERACT 1XV1N
 dis_down_arm_err = dis_down_arm INTERACT dis_down_arm_err_stack
 err1_met_down = (dis_down_arm_err INTERACT (1XV1N NOT OUTSIDE dis_down_arm_err)) NOT INTERACT (OR RV1 2XV1N)
 // 
 wide_M2 = (WITH WIDTH M2 > 0.162-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 0.162-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 0.162-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M2_real = wide_M2 NOT OUTSIDE ((SIZE wide_M2 BY 0.5+GLOBAL_TOLERANCE) INTERACT V1)
 all_up_and_down = (M2 INTERACT wide_M2) AND M1
 dis_up_arm_wide_all = SIZE wide_M2_real BY 0.5+GLOBAL_TOLERANCE INSIDE OF M2 STEP 0.025
 dis_up_and_down = dis_up_arm_wide_all AND all_up_and_down
 dis_up_and_down_arm = (dis_up_and_down NOT wide_M2) AND M2
 dis_up_arm = (dis_up_arm_wide_all NOT wide_M2) AND M2
 // 
 dis_up_arm_good_a = dis_up_and_down_arm INTERACT 1XV1N >= 2
 dis_up_arm_good_b = dis_up_and_down_arm INTERACT RV1
 dis_up_arm_good_c = dis_up_and_down_arm INTERACT 2XV1N
 dis_up_arm_good = OR dis_up_arm_good_a dis_up_arm_good_b dis_up_arm_good_c
 dis_up_arm_bad = (dis_up_and_down_arm NOT dis_up_arm_good) INTERACT (all_up_and_down INTERACT 1XV1N == 1)
 // 
 dis_up_arm_err_stack = (dis_up_arm_bad AND dis_up_and_down_arm) INTERACT 1XV1N
 dis_up_arm_err = dis_up_arm INTERACT dis_up_arm_err_stack
 err2_met_up = (dis_up_arm_err INTERACT (1XV1N NOT OUTSIDE dis_up_arm_err)) NOT INTERACT (OR RV1 2XV1N)
 err1_met_down NOT INTERACT Vy1_BAR
}
 
RVy1_R_4_M2 {
@ There should be at least two square Vy or one rectangular Vy in the intersection area of bottom metal and upper metal, when either wide metal Mxy or 1.25xMy length >= 0.162um and width >= 0.162um, the space between either via and wide metal <= 0.5um (S, S is the shortest running path length from Via to the wide metal). (except via bar)
 // DRC flags each intersecting area ({bottom metal AND upper metal}) with single square Via within the branch check region
 wide_M1 = (WITH WIDTH M1 > 0.162-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 0.162-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 0.162-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M1_real = wide_M1 NOT OUTSIDE ((SIZE wide_M1 BY 0.5+GLOBAL_TOLERANCE) INTERACT V1)
 all_down_and_up = (M1 INTERACT wide_M1) AND M2
 dis_down_arm_wide_all = SIZE wide_M1_real BY 0.5+GLOBAL_TOLERANCE INSIDE OF M1 STEP 0.025
 dis_down_and_up = dis_down_arm_wide_all AND all_down_and_up
 dis_down_and_up_arm = (dis_down_and_up NOT wide_M1) AND M1
 dis_down_arm = (dis_down_arm_wide_all NOT wide_M1) AND M1
 // 
 dis_down_arm_good_a = dis_down_and_up_arm INTERACT 1XV1N >= 2
 dis_down_arm_good_b = dis_down_and_up_arm INTERACT RV1
 dis_down_arm_good_c = dis_down_and_up_arm INTERACT 2XV1N
 dis_down_arm_good = OR dis_down_arm_good_a dis_down_arm_good_b dis_down_arm_good_c
 dis_down_arm_bad = (dis_down_and_up_arm NOT dis_down_arm_good) INTERACT (all_down_and_up INTERACT 1XV1N == 1)
 // 
 dis_down_arm_err_stack = (dis_down_arm_bad AND dis_down_and_up_arm) INTERACT 1XV1N
 dis_down_arm_err = dis_down_arm INTERACT dis_down_arm_err_stack
 err1_met_down = (dis_down_arm_err INTERACT (1XV1N NOT OUTSIDE dis_down_arm_err)) NOT INTERACT (OR RV1 2XV1N)
 // 
 wide_M2 = (WITH WIDTH M2 > 0.162-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 0.162-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 0.162-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M2_real = wide_M2 NOT OUTSIDE ((SIZE wide_M2 BY 0.5+GLOBAL_TOLERANCE) INTERACT V1)
 all_up_and_down = (M2 INTERACT wide_M2) AND M1
 dis_up_arm_wide_all = SIZE wide_M2_real BY 0.5+GLOBAL_TOLERANCE INSIDE OF M2 STEP 0.025
 dis_up_and_down = dis_up_arm_wide_all AND all_up_and_down
 dis_up_and_down_arm = (dis_up_and_down NOT wide_M2) AND M2
 dis_up_arm = (dis_up_arm_wide_all NOT wide_M2) AND M2
 // 
 dis_up_arm_good_a = dis_up_and_down_arm INTERACT 1XV1N >= 2
 dis_up_arm_good_b = dis_up_and_down_arm INTERACT RV1
 dis_up_arm_good_c = dis_up_and_down_arm INTERACT 2XV1N
 dis_up_arm_good = OR dis_up_arm_good_a dis_up_arm_good_b dis_up_arm_good_c
 dis_up_arm_bad = (dis_up_and_down_arm NOT dis_up_arm_good) INTERACT (all_up_and_down INTERACT 1XV1N == 1)
 // 
 dis_up_arm_err_stack = (dis_up_arm_bad AND dis_up_and_down_arm) INTERACT 1XV1N
 dis_up_arm_err = dis_up_arm INTERACT dis_up_arm_err_stack
 err2_met_up = (dis_up_arm_err INTERACT (1XV1N NOT OUTSIDE dis_up_arm_err)) NOT INTERACT (OR RV1 2XV1N)
 err2_met_up NOT INTERACT Vy1_BAR
}
 
RVy1_R_5_M1 {
@ There should be at least two square Vy or one rectangular Vy in the intersection area of bottom metal and upper metal, when either wide metal Mxy or 1.25xMy length >= 0.272um and width >= 0.272um, the space between either via and wide metal <= 1um (S, S is the shortest running path length from Via to the wide metal). (except via bar)
 // DRC flags each intersecting area ({bottom metal AND upper metal}) with single square Via within the branch check region
 wide_M1 = (WITH WIDTH M1 > 0.272-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 0.272-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 0.272-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M1_real = wide_M1 NOT OUTSIDE ((SIZE wide_M1 BY 1+GLOBAL_TOLERANCE) INTERACT V1)
 all_down_and_up = (M1 INTERACT wide_M1) AND M2
 dis_down_arm_wide_all = SIZE wide_M1_real BY 1+GLOBAL_TOLERANCE INSIDE OF M1 STEP 0.025
 dis_down_and_up = dis_down_arm_wide_all AND all_down_and_up
 dis_down_and_up_arm = (dis_down_and_up NOT wide_M1) AND M1
 dis_down_arm = (dis_down_arm_wide_all NOT wide_M1) AND M1
 // 
 dis_down_arm_good_a = dis_down_and_up_arm INTERACT 1XV1N >= 2
 dis_down_arm_good_b = dis_down_and_up_arm INTERACT RV1
 dis_down_arm_good_c = dis_down_and_up_arm INTERACT 2XV1N
 dis_down_arm_good = OR dis_down_arm_good_a dis_down_arm_good_b dis_down_arm_good_c
 dis_down_arm_bad = (dis_down_and_up_arm NOT dis_down_arm_good) INTERACT (all_down_and_up INTERACT 1XV1N == 1)
 // 
 dis_down_arm_err_stack = (dis_down_arm_bad AND dis_down_and_up_arm) INTERACT 1XV1N
 dis_down_arm_err = dis_down_arm INTERACT dis_down_arm_err_stack
 err1_met_down = (dis_down_arm_err INTERACT (1XV1N NOT OUTSIDE dis_down_arm_err)) NOT INTERACT (OR RV1 2XV1N)
 // 
 wide_M2 = (WITH WIDTH M2 > 0.272-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 0.272-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 0.272-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M2_real = wide_M2 NOT OUTSIDE ((SIZE wide_M2 BY 1+GLOBAL_TOLERANCE) INTERACT V1)
 all_up_and_down = (M2 INTERACT wide_M2) AND M1
 dis_up_arm_wide_all = SIZE wide_M2_real BY 1+GLOBAL_TOLERANCE INSIDE OF M2 STEP 0.025
 dis_up_and_down = dis_up_arm_wide_all AND all_up_and_down
 dis_up_and_down_arm = (dis_up_and_down NOT wide_M2) AND M2
 dis_up_arm = (dis_up_arm_wide_all NOT wide_M2) AND M2
 // 
 dis_up_arm_good_a = dis_up_and_down_arm INTERACT 1XV1N >= 2
 dis_up_arm_good_b = dis_up_and_down_arm INTERACT RV1
 dis_up_arm_good_c = dis_up_and_down_arm INTERACT 2XV1N
 dis_up_arm_good = OR dis_up_arm_good_a dis_up_arm_good_b dis_up_arm_good_c
 dis_up_arm_bad = (dis_up_and_down_arm NOT dis_up_arm_good) INTERACT (all_up_and_down INTERACT 1XV1N == 1)
 // 
 dis_up_arm_err_stack = (dis_up_arm_bad AND dis_up_and_down_arm) INTERACT 1XV1N
 dis_up_arm_err = dis_up_arm INTERACT dis_up_arm_err_stack
 err2_met_up = (dis_up_arm_err INTERACT (1XV1N NOT OUTSIDE dis_up_arm_err)) NOT INTERACT (OR RV1 2XV1N)
 err1_met_down NOT INTERACT Vy1_BAR
}
 
RVy1_R_5_M2 {
@ There should be at least two square Vy or one rectangular Vy in the intersection area of bottom metal and upper metal, when either wide metal Mxy or 1.25xMy length >= 0.272um and width >= 0.272um, the space between either via and wide metal <= 1um (S, S is the shortest running path length from Via to the wide metal). (except via bar)
 // DRC flags each intersecting area ({bottom metal AND upper metal}) with single square Via within the branch check region
 wide_M1 = (WITH WIDTH M1 > 0.272-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 0.272-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 0.272-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M1_real = wide_M1 NOT OUTSIDE ((SIZE wide_M1 BY 1+GLOBAL_TOLERANCE) INTERACT V1)
 all_down_and_up = (M1 INTERACT wide_M1) AND M2
 dis_down_arm_wide_all = SIZE wide_M1_real BY 1+GLOBAL_TOLERANCE INSIDE OF M1 STEP 0.025
 dis_down_and_up = dis_down_arm_wide_all AND all_down_and_up
 dis_down_and_up_arm = (dis_down_and_up NOT wide_M1) AND M1
 dis_down_arm = (dis_down_arm_wide_all NOT wide_M1) AND M1
 // 
 dis_down_arm_good_a = dis_down_and_up_arm INTERACT 1XV1N >= 2
 dis_down_arm_good_b = dis_down_and_up_arm INTERACT RV1
 dis_down_arm_good_c = dis_down_and_up_arm INTERACT 2XV1N
 dis_down_arm_good = OR dis_down_arm_good_a dis_down_arm_good_b dis_down_arm_good_c
 dis_down_arm_bad = (dis_down_and_up_arm NOT dis_down_arm_good) INTERACT (all_down_and_up INTERACT 1XV1N == 1)
 // 
 dis_down_arm_err_stack = (dis_down_arm_bad AND dis_down_and_up_arm) INTERACT 1XV1N
 dis_down_arm_err = dis_down_arm INTERACT dis_down_arm_err_stack
 err1_met_down = (dis_down_arm_err INTERACT (1XV1N NOT OUTSIDE dis_down_arm_err)) NOT INTERACT (OR RV1 2XV1N)
 // 
 wide_M2 = (WITH WIDTH M2 > 0.272-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 0.272-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 0.272-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M2_real = wide_M2 NOT OUTSIDE ((SIZE wide_M2 BY 1+GLOBAL_TOLERANCE) INTERACT V1)
 all_up_and_down = (M2 INTERACT wide_M2) AND M1
 dis_up_arm_wide_all = SIZE wide_M2_real BY 1+GLOBAL_TOLERANCE INSIDE OF M2 STEP 0.025
 dis_up_and_down = dis_up_arm_wide_all AND all_up_and_down
 dis_up_and_down_arm = (dis_up_and_down NOT wide_M2) AND M2
 dis_up_arm = (dis_up_arm_wide_all NOT wide_M2) AND M2
 // 
 dis_up_arm_good_a = dis_up_and_down_arm INTERACT 1XV1N >= 2
 dis_up_arm_good_b = dis_up_and_down_arm INTERACT RV1
 dis_up_arm_good_c = dis_up_and_down_arm INTERACT 2XV1N
 dis_up_arm_good = OR dis_up_arm_good_a dis_up_arm_good_b dis_up_arm_good_c
 dis_up_arm_bad = (dis_up_and_down_arm NOT dis_up_arm_good) INTERACT (all_up_and_down INTERACT 1XV1N == 1)
 // 
 dis_up_arm_err_stack = (dis_up_arm_bad AND dis_up_and_down_arm) INTERACT 1XV1N
 dis_up_arm_err = dis_up_arm INTERACT dis_up_arm_err_stack
 err2_met_up = (dis_up_arm_err INTERACT (1XV1N NOT OUTSIDE dis_up_arm_err)) NOT INTERACT (OR RV1 2XV1N)
 err2_met_up NOT INTERACT Vy1_BAR
}
 
RVy1_R_6_M1 {
@ There should be at least two square Vy or one rectangular Vy in the intersection area of bottom metal and upper metal, when either wide metal Mxy or 1.25xMy width and length >= 0.542um, the space between either via and wide metal <= 3um (S, S is the shortest running path length from Via to the wide metal). (except via bar)
 // DRC flags each intersecting area ({bottom metal AND upper metal}) with single square Via within the branch check region
 wide_M1 = (WITH WIDTH M1 > 0.542-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 0.542-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 0.542-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M1_real = wide_M1 NOT OUTSIDE ((SIZE wide_M1 BY 3+GLOBAL_TOLERANCE) INTERACT V1)
 all_down_and_up = (M1 INTERACT wide_M1) AND M2
 dis_down_arm_wide_all = SIZE wide_M1_real BY 3+GLOBAL_TOLERANCE INSIDE OF M1 STEP 0.025
 dis_down_and_up = dis_down_arm_wide_all AND all_down_and_up
 dis_down_and_up_arm = (dis_down_and_up NOT wide_M1) AND M1
 dis_down_arm = (dis_down_arm_wide_all NOT wide_M1) AND M1
 // 
 dis_down_arm_good_a = dis_down_and_up_arm INTERACT 1XV1N >= 2
 dis_down_arm_good_b = dis_down_and_up_arm INTERACT RV1
 dis_down_arm_good_c = dis_down_and_up_arm INTERACT 2XV1N
 dis_down_arm_good = OR dis_down_arm_good_a dis_down_arm_good_b dis_down_arm_good_c
 dis_down_arm_bad = (dis_down_and_up_arm NOT dis_down_arm_good) INTERACT (all_down_and_up INTERACT 1XV1N == 1)
 // 
 dis_down_arm_err_stack = (dis_down_arm_bad AND dis_down_and_up_arm) INTERACT 1XV1N
 dis_down_arm_err = dis_down_arm INTERACT dis_down_arm_err_stack
 err1_met_down = (dis_down_arm_err INTERACT (1XV1N NOT OUTSIDE dis_down_arm_err)) NOT INTERACT (OR RV1 2XV1N)
 // 
 wide_M2 = (WITH WIDTH M2 > 0.542-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 0.542-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 0.542-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M2_real = wide_M2 NOT OUTSIDE ((SIZE wide_M2 BY 3+GLOBAL_TOLERANCE) INTERACT V1)
 all_up_and_down = (M2 INTERACT wide_M2) AND M1
 dis_up_arm_wide_all = SIZE wide_M2_real BY 3+GLOBAL_TOLERANCE INSIDE OF M2 STEP 0.025
 dis_up_and_down = dis_up_arm_wide_all AND all_up_and_down
 dis_up_and_down_arm = (dis_up_and_down NOT wide_M2) AND M2
 dis_up_arm = (dis_up_arm_wide_all NOT wide_M2) AND M2
 // 
 dis_up_arm_good_a = dis_up_and_down_arm INTERACT 1XV1N >= 2
 dis_up_arm_good_b = dis_up_and_down_arm INTERACT RV1
 dis_up_arm_good_c = dis_up_and_down_arm INTERACT 2XV1N
 dis_up_arm_good = OR dis_up_arm_good_a dis_up_arm_good_b dis_up_arm_good_c
 dis_up_arm_bad = (dis_up_and_down_arm NOT dis_up_arm_good) INTERACT (all_up_and_down INTERACT 1XV1N == 1)
 // 
 dis_up_arm_err_stack = (dis_up_arm_bad AND dis_up_and_down_arm) INTERACT 1XV1N
 dis_up_arm_err = dis_up_arm INTERACT dis_up_arm_err_stack
 err2_met_up = (dis_up_arm_err INTERACT (1XV1N NOT OUTSIDE dis_up_arm_err)) NOT INTERACT (OR RV1 2XV1N)
 err1_met_down NOT INTERACT Vy1_BAR
}
 
RVy1_R_6_M2 {
@ There should be at least two square Vy or one rectangular Vy in the intersection area of bottom metal and upper metal, when either wide metal Mxy or 1.25xMy width and length >= 0.542um, the space between either via and wide metal <= 3um (S, S is the shortest running path length from Via to the wide metal). (except via bar)
 // DRC flags each intersecting area ({bottom metal AND upper metal}) with single square Via within the branch check region
 wide_M1 = (WITH WIDTH M1 > 0.542-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 0.542-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 0.542-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M1_real = wide_M1 NOT OUTSIDE ((SIZE wide_M1 BY 3+GLOBAL_TOLERANCE) INTERACT V1)
 all_down_and_up = (M1 INTERACT wide_M1) AND M2
 dis_down_arm_wide_all = SIZE wide_M1_real BY 3+GLOBAL_TOLERANCE INSIDE OF M1 STEP 0.025
 dis_down_and_up = dis_down_arm_wide_all AND all_down_and_up
 dis_down_and_up_arm = (dis_down_and_up NOT wide_M1) AND M1
 dis_down_arm = (dis_down_arm_wide_all NOT wide_M1) AND M1
 // 
 dis_down_arm_good_a = dis_down_and_up_arm INTERACT 1XV1N >= 2
 dis_down_arm_good_b = dis_down_and_up_arm INTERACT RV1
 dis_down_arm_good_c = dis_down_and_up_arm INTERACT 2XV1N
 dis_down_arm_good = OR dis_down_arm_good_a dis_down_arm_good_b dis_down_arm_good_c
 dis_down_arm_bad = (dis_down_and_up_arm NOT dis_down_arm_good) INTERACT (all_down_and_up INTERACT 1XV1N == 1)
 // 
 dis_down_arm_err_stack = (dis_down_arm_bad AND dis_down_and_up_arm) INTERACT 1XV1N
 dis_down_arm_err = dis_down_arm INTERACT dis_down_arm_err_stack
 err1_met_down = (dis_down_arm_err INTERACT (1XV1N NOT OUTSIDE dis_down_arm_err)) NOT INTERACT (OR RV1 2XV1N)
 // 
 wide_M2 = (WITH WIDTH M2 > 0.542-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 0.542-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 0.542-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M2_real = wide_M2 NOT OUTSIDE ((SIZE wide_M2 BY 3+GLOBAL_TOLERANCE) INTERACT V1)
 all_up_and_down = (M2 INTERACT wide_M2) AND M1
 dis_up_arm_wide_all = SIZE wide_M2_real BY 3+GLOBAL_TOLERANCE INSIDE OF M2 STEP 0.025
 dis_up_and_down = dis_up_arm_wide_all AND all_up_and_down
 dis_up_and_down_arm = (dis_up_and_down NOT wide_M2) AND M2
 dis_up_arm = (dis_up_arm_wide_all NOT wide_M2) AND M2
 // 
 dis_up_arm_good_a = dis_up_and_down_arm INTERACT 1XV1N >= 2
 dis_up_arm_good_b = dis_up_and_down_arm INTERACT RV1
 dis_up_arm_good_c = dis_up_and_down_arm INTERACT 2XV1N
 dis_up_arm_good = OR dis_up_arm_good_a dis_up_arm_good_b dis_up_arm_good_c
 dis_up_arm_bad = (dis_up_and_down_arm NOT dis_up_arm_good) INTERACT (all_up_and_down INTERACT 1XV1N == 1)
 // 
 dis_up_arm_err_stack = (dis_up_arm_bad AND dis_up_and_down_arm) INTERACT 1XV1N
 dis_up_arm_err = dis_up_arm INTERACT dis_up_arm_err_stack
 err2_met_up = (dis_up_arm_err INTERACT (1XV1N NOT OUTSIDE dis_up_arm_err)) NOT INTERACT (OR RV1 2XV1N)
 err2_met_up NOT INTERACT Vy1_BAR
}
 
RVy1_R_7_M1 {
@ There should be at least two square Vy or one rectangular Vy in the intersection area of bottom metal and upper metal, when either wide metal Mxy or 1.25xMy width and length >= 1.01um, the space between either via and wide metal <= 5um (S, S is the shortest running path length from Via to the wide metal). (except via bar)
 // DRC flags each intersecting area ({bottom metal AND upper metal}) with single square Via within the branch check region
 wide_M1 = (WITH WIDTH M1 > 1.01-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 1.01-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 1.01-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M1_real = wide_M1 NOT OUTSIDE ((SIZE wide_M1 BY 5+GLOBAL_TOLERANCE) INTERACT V1)
 all_down_and_up = (M1 INTERACT wide_M1) AND M2
 dis_down_arm_wide_all = SIZE wide_M1_real BY 5+GLOBAL_TOLERANCE INSIDE OF M1 STEP 0.025
 dis_down_and_up = dis_down_arm_wide_all AND all_down_and_up
 dis_down_and_up_arm = (dis_down_and_up NOT wide_M1) AND M1
 dis_down_arm = (dis_down_arm_wide_all NOT wide_M1) AND M1
 // 
 dis_down_arm_good_a = dis_down_and_up_arm INTERACT 1XV1N >= 2
 dis_down_arm_good_b = dis_down_and_up_arm INTERACT RV1
 dis_down_arm_good_c = dis_down_and_up_arm INTERACT 2XV1N
 dis_down_arm_good = OR dis_down_arm_good_a dis_down_arm_good_b dis_down_arm_good_c
 dis_down_arm_bad = (dis_down_and_up_arm NOT dis_down_arm_good) INTERACT (all_down_and_up INTERACT 1XV1N == 1)
 // 
 dis_down_arm_err_stack = (dis_down_arm_bad AND dis_down_and_up_arm) INTERACT 1XV1N
 dis_down_arm_err = dis_down_arm INTERACT dis_down_arm_err_stack
 err1_met_down = (dis_down_arm_err INTERACT (1XV1N NOT OUTSIDE dis_down_arm_err)) NOT INTERACT (OR RV1 2XV1N)
 // 
 wide_M2 = (WITH WIDTH M2 > 1.01-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 1.01-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 1.01-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M2_real = wide_M2 NOT OUTSIDE ((SIZE wide_M2 BY 5+GLOBAL_TOLERANCE) INTERACT V1)
 all_up_and_down = (M2 INTERACT wide_M2) AND M1
 dis_up_arm_wide_all = SIZE wide_M2_real BY 5+GLOBAL_TOLERANCE INSIDE OF M2 STEP 0.025
 dis_up_and_down = dis_up_arm_wide_all AND all_up_and_down
 dis_up_and_down_arm = (dis_up_and_down NOT wide_M2) AND M2
 dis_up_arm = (dis_up_arm_wide_all NOT wide_M2) AND M2
 // 
 dis_up_arm_good_a = dis_up_and_down_arm INTERACT 1XV1N >= 2
 dis_up_arm_good_b = dis_up_and_down_arm INTERACT RV1
 dis_up_arm_good_c = dis_up_and_down_arm INTERACT 2XV1N
 dis_up_arm_good = OR dis_up_arm_good_a dis_up_arm_good_b dis_up_arm_good_c
 dis_up_arm_bad = (dis_up_and_down_arm NOT dis_up_arm_good) INTERACT (all_up_and_down INTERACT 1XV1N == 1)
 // 
 dis_up_arm_err_stack = (dis_up_arm_bad AND dis_up_and_down_arm) INTERACT 1XV1N
 dis_up_arm_err = dis_up_arm INTERACT dis_up_arm_err_stack
 err2_met_up = (dis_up_arm_err INTERACT (1XV1N NOT OUTSIDE dis_up_arm_err)) NOT INTERACT (OR RV1 2XV1N)
 err1_met_down NOT INTERACT Vy1_BAR
}
 
RVy1_R_7_M2 {
@ There should be at least two square Vy or one rectangular Vy in the intersection area of bottom metal and upper metal, when either wide metal Mxy or 1.25xMy width and length >= 1.01um, the space between either via and wide metal <= 5um (S, S is the shortest running path length from Via to the wide metal). (except via bar)
 // DRC flags each intersecting area ({bottom metal AND upper metal}) with single square Via within the branch check region
 wide_M1 = (WITH WIDTH M1 > 1.01-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 1.01-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 1.01-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M1_real = wide_M1 NOT OUTSIDE ((SIZE wide_M1 BY 5+GLOBAL_TOLERANCE) INTERACT V1)
 all_down_and_up = (M1 INTERACT wide_M1) AND M2
 dis_down_arm_wide_all = SIZE wide_M1_real BY 5+GLOBAL_TOLERANCE INSIDE OF M1 STEP 0.025
 dis_down_and_up = dis_down_arm_wide_all AND all_down_and_up
 dis_down_and_up_arm = (dis_down_and_up NOT wide_M1) AND M1
 dis_down_arm = (dis_down_arm_wide_all NOT wide_M1) AND M1
 // 
 dis_down_arm_good_a = dis_down_and_up_arm INTERACT 1XV1N >= 2
 dis_down_arm_good_b = dis_down_and_up_arm INTERACT RV1
 dis_down_arm_good_c = dis_down_and_up_arm INTERACT 2XV1N
 dis_down_arm_good = OR dis_down_arm_good_a dis_down_arm_good_b dis_down_arm_good_c
 dis_down_arm_bad = (dis_down_and_up_arm NOT dis_down_arm_good) INTERACT (all_down_and_up INTERACT 1XV1N == 1)
 // 
 dis_down_arm_err_stack = (dis_down_arm_bad AND dis_down_and_up_arm) INTERACT 1XV1N
 dis_down_arm_err = dis_down_arm INTERACT dis_down_arm_err_stack
 err1_met_down = (dis_down_arm_err INTERACT (1XV1N NOT OUTSIDE dis_down_arm_err)) NOT INTERACT (OR RV1 2XV1N)
 // 
 wide_M2 = (WITH WIDTH M2 > 1.01-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 1.01-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 1.01-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M2_real = wide_M2 NOT OUTSIDE ((SIZE wide_M2 BY 5+GLOBAL_TOLERANCE) INTERACT V1)
 all_up_and_down = (M2 INTERACT wide_M2) AND M1
 dis_up_arm_wide_all = SIZE wide_M2_real BY 5+GLOBAL_TOLERANCE INSIDE OF M2 STEP 0.025
 dis_up_and_down = dis_up_arm_wide_all AND all_up_and_down
 dis_up_and_down_arm = (dis_up_and_down NOT wide_M2) AND M2
 dis_up_arm = (dis_up_arm_wide_all NOT wide_M2) AND M2
 // 
 dis_up_arm_good_a = dis_up_and_down_arm INTERACT 1XV1N >= 2
 dis_up_arm_good_b = dis_up_and_down_arm INTERACT RV1
 dis_up_arm_good_c = dis_up_and_down_arm INTERACT 2XV1N
 dis_up_arm_good = OR dis_up_arm_good_a dis_up_arm_good_b dis_up_arm_good_c
 dis_up_arm_bad = (dis_up_and_down_arm NOT dis_up_arm_good) INTERACT (all_up_and_down INTERACT 1XV1N == 1)
 // 
 dis_up_arm_err_stack = (dis_up_arm_bad AND dis_up_and_down_arm) INTERACT 1XV1N
 dis_up_arm_err = dis_up_arm INTERACT dis_up_arm_err_stack
 err2_met_up = (dis_up_arm_err INTERACT (1XV1N NOT OUTSIDE dis_up_arm_err)) NOT INTERACT (OR RV1 2XV1N)
 err2_met_up NOT INTERACT Vy1_BAR
}

// =======================================================
// Rectangular Vy design rule
// =======================================================

GROUP GRVy2 RVy2_?
 
RVy2_W_1_L_1 {
@ RVy.W.1: Rectangular Vy (RVy) width, except square Vy, MARKS, MARKG, INDMY, LOGO regions = 0.032um
@ RVy.L.1: Length of RVy (width = 0.032um) = 0.080um
 err1 = (V2 NOT 1XV2N) NOT RV2
 err1 NOT INSIDE MARKS_MARKG_INDMY_LOGO
}
 
RVy2_L_2 {
@ Length of Vy bar (width = 0.1/0.45um) >= 0.9um
 CHECK_VIA = V2 NOT OUTSIDE (OR MARKS MARKG)
 CHECK_EDG = (INT [CHECK_VIA] == 0.1 ABUT<90 OPPOSITE EXCLUDE SHIELDED) OR EDGE (INT [CHECK_VIA] == 0.45 ABUT<90 OPPOSITE EXCLUDE SHIELDED)
 err1 = LENGTH CHECK_EDG < 0.90
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
RVy2_S_1 {
@ Space between RVy and (Vy-1 or RVy-1) (including V0 and RV0) at different net and PRL > 0um, when Mxy+1/1.25xMy enclosure of RVy > 0um. >= 0.037um
 chk_via = (V2 INTERACT RV2) NOT COIN EDGE M3
 err1 = EXT chk_via V1 < 0.037 ABUT<90 OPPOSITE REGION NOT CONNECTED
 err1 NOT INSIDE SealR_NOT_BULK
}
 
RVy2_S_1a {
@ Space between RVy >= 0.082um
 err1 = EXT RV2 < 0.082 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
RVy2_S_2 {
@ Space between RVy and Mxy (including M1) at different net >= 0.037um
@ When:
@ 1. Mxy (including M1) enclosure of RVy < 0.003um
@ 2. Mxy+1/1.25xMy width > 0.038um
 y1 = V2 AND (RV2 NOT OUTSIDE (M3 WITH WIDTH > 0.038))
 y2 = EXT [y1] M2 < 0.037 ABUT<90 MEASURE ALL NOT CONNECTED
 y3 = ENC [y2] M2 < 0.003 ABUT<90 OPPOSITE
 err1 = EXT (y1 COIN EDGE y3) M2 < 0.037 ABUT<90 MEASURE ALL NOT CONNECTED REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
RVy2_S_4 {
@ Space between the short side of RVy and Vy when PRL > -0.032um. >= 0.108um
 err1 = EXT RV2_W V2_SR < 0.108 ABUT<90 OPPOSITE EXTENDED 0.032 REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
RVy2_S_5 {
@ Space between the long side of RVy (PRL > 0um, with one Mxy+1/1.25xMy in between) >= 0.115um
 ERRS_AREA = EXT RV2_L < 0.115 ABUT<90 OPPOSITE REGION
 // Also check 072 Line to 080 Line
 ERRS_EDGE = EXT [RV2_L] < 0.115 ABUT<90 OPPOSITE
 ERRS_EDGE_EXP = EXPAND EDGE ERRS_EDGE INSIDE BY 0.001
 ERRS_BULK_MET = (ERRS_AREA OR ERRS_EDGE_EXP) AND M3
 err1_TMP = (ERRS_AREA OR ERRS_EDGE_EXP) INTERACT ERRS_BULK_MET >= 3
 err1 = ERRS_AREA AND err1_TMP
 err1 NOT INSIDE SealR_NOT_BULK
}
 

#IFDEF DFM_RULES_PRIORITY_1 YES

RVy2_EN_1_DFM1 {
@ Recommended RVy enclosure by M1/Mxy is defined by either RVy.EN.2.DFM or RVy.EN.2a.DFM
 err1 = RV2 NOT INSIDE M2
 err1 NOT INSIDE SealR_NOT_BULK
}
 
//;beginning of the RVy.EN.2.DFM derivations
via_RVy_2_2_R_bad = RECTANGLE ENCLOSURE RV2 M2 ABUT<90 SINGULAR OUTSIDE ALSO 
GOOD 0.007 0.025 OPPOSITE 0.007 0.025 OPPOSITE
via_RVy_2_2_R_good = RV2 NOT via_RVy_2_2_R_bad
//;end of the RVy.EN.2.DFM derivations
 
RVy2_EN_2_DFM1 {
@ Recommended RVy enclosure by M1/Mxy for two opposite sides with the other twosides >= 0.007um. >= 0.025um
 err1 = via_RVy_2_2_R_bad NOT via_RVy_2_2a_R_good
 err1 NOT INSIDE SealR_NOT_BULK
}
 
//;beginning of the RVy.EN.2a.DFM derivations
via_RVy_2_2a_R_bad = RECTANGLE ENCLOSURE RV2 M2 ABUT<90 SINGULAR OUTSIDE ALSO 
GOOD 0.020 0.020 0.020 0.020 OPPOSITE
via_RVy_2_2a_R_good = RV2 NOT via_RVy_2_2a_R_bad
//;end of the RVy.EN.2a.DFM derivations
 
RVy2_EN_2a_DFM1 {
@ Recommended RVy enclosure by M1, Mxy for all sides >= 0.02um
 err1 = via_RVy_2_2a_R_bad NOT via_RVy_2_2_R_good
 err2 = (ENC [RV2] M2 < 0.02 ABUT<90 SINGULAR) NOT TOUCH EDGE via_RVy_2_2_R_good
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE EDGE SealR_NOT_BULK
}

#ENDIF

 
RVy2_EN_1 {
@ RVy must be fully enclosed by M1/Mxy where M1/Mxy is the metal layer directly underneath RVy
@ Enclosure by M1/Mxy must follow either RVy.EN.2, RVy.EN.2a or RVy.EN.3
 err1 = RV2 NOT M2
 err1 NOT INSIDE SealR_NOT_BULK
}
 
//;beginning of the RVy.EN.2a derivations
via_RVy_2_2a_bad = RECTANGLE ENCLOSURE RV2 M2 ABUT<90 SINGULAR OUTSIDE ALSO 
GOOD 0.015 0.015 0.015 0.015 OPPOSITE
via_RVy_2_2a_good = RV2 NOT via_RVy_2_2a_bad
//;end of the RVy.EN.2a derivations
 
//;beginning of the RVy.EN.2/3 derivations
via_RVy_2_2_3_bad = RECTANGLE ENCLOSURE RV2 M2 ABUT<90 SINGULAR OUTSIDE ALSO 
GOOD 0 0.024 OPPOSITE 0 0.024 OPPOSITE 
GOOD 0.007 0.019 OPPOSITE 0.007 0.019 OPPOSITE
via_RVy_2_2_3_good = RV2 NOT via_RVy_2_2_3_bad
//;end of the RVy.EN.2/3 derivations
 
RVy2_EN_2a {
@ RVy enclosure by M1 or Mxy for all sides >= 0.015um
 err1 = via_RVy_2_2a_bad NOT via_RVy_2_2_3_good
 err2 = (ENC [RV2] M2 < 0.015 ABUT<90 SINGULAR) NOT TOUCH EDGE via_RVy_2_2_3_good
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE EDGE SealR_NOT_BULK
}
 
RVy2_EN_2_3 {
@ Rvy.EN.2: RVy enclosure by M1 or Mxy when enclosure on either perpendicular direction >= 0um. >= 0.024um
@ RVy.EN.3: RVy enclosure by M1 or Mxy for two opposite sides with the other two sides >= 0.007um. >= 0.019um
 err1 = via_RVy_2_2_3_bad NOT via_RVy_2_2a_good
 err1 NOT INSIDE SealR_NOT_BULK
 // 
 RVy_chk_W_sides = ENC [RV2_W] M2 < 0.007 ABUT<90 OPPOSITE
 RVy_chk_L_sides = ENC (RV2_L) M2 < 0.024 ABUT<90 OPPOSITE
 err2 = ((RV2 INSIDE M2) WITH EDGE RVy_chk_W_sides) WITH EDGE RVy_chk_L_sides == 2
 err2 NOT INSIDE SealR_NOT_BULK
}
 
RVy2_EN_4 {
@ RVy enclosure by Mxy in adjacent S1 side, where Mxy is the metal layer directly underneath RVy >= 0.004um
@ When:
@ 1) Mxy width W: 0.036um <= W <= 0.041um
@ 2) Space: 0.058um <= S1 < 0.063um, the PRL >= 0.083um
@ 3) The opposite space S2 >= 0.069um
 met_wid_all = M2 WITH WIDTH > 0.036-GLOBAL_TOLERANCE <= 0.041
 met_err_RAW_a = EXT [met_wid_all] M2 >= 0.058 < 0.063 ABUT<90 OPPOSITE MEASURE ALL
 met_err_RAW_b = EXT met_wid_all M2 >= 0.058 < 0.063 ABUT<90 OPPOSITE MEASURE ALL
 met_err_RAW_c = EXT met_wid_all [M2] >= 0.058 < 0.063 ABUT<90 OPPOSITE MEASURE ALL
 met_err_PRL = DFM PROPERTY met_err_RAW_b met_err_RAW_c OVERLAP ABUT ALSO MULTI [-= max(LENGTH(met_err_RAW_c))] >= 0.083
 // 
 met_err_EGE_a = met_err_RAW_a COIN EDGE (DFM COPY met_err_PRL EDGE)
 met_err_EGE_b = ENC RV2 [met_err_EGE_a] < 0.004 ABUT<90 OPPOSITE
 met_err_EGE_c = INT met_err_EGE_b [M2] > 0.036-GLOBAL_TOLERANCE <= 0.041 ABUT<90 OPPOSITE MEASURE COIN
 met_err_EGE_d = EXT (met_err_EGE_c) M2 < 0.069 ABUT<90 OPPOSITE
 met_err_EGE_e = met_err_EGE_b COIN EDGE M2
 err1 = INT met_err_EGE_d [met_err_EGE_e] > 0.036-GLOBAL_TOLERANCE <= 0.041 ABUT<90 OPPOSITE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
RVy2_EN_5 {
@ RVy enclosure by Mxy in adjacent S1 side, where Mxy is the metal layer directly underneath RVy >= 0.004um
@ When:
@ 1) Mxy width W: 0.042um <= W <= 0.05um
@ 2) Space: 0.058um <= S1 <= 0.067um, the PRL >= 0.083um
 met_wid_all = M2 WITH WIDTH > 0.042-GLOBAL_TOLERANCE <= 0.05
 met_err_RAW_TMP = EXT met_wid_all [M2] >= 0.058 < 0.067+GLOBAL_TOLERANCE ABUT<90 OPPOSITE MEASURE ALL
 met_err_RAW = EXT met_err_RAW_TMP [M2] >= 0.058 < 0.067+GLOBAL_TOLERANCE ABUT<90 OPPOSITE
 // 
 met_jog_ALL = M2_convex_eq_one_edges NOT COIN EDGE met_err_RAW
 met_jog_EXP_a = EXPAND EDGE met_jog_ALL INSIDE BY 0.0005
 met_jog_EXP_b = EXPAND EDGE met_jog_ALL OUTSIDE BY 0.0005
 met_jog_TMP = (met_jog_ALL COIN EDGE (met_jog_EXP_a WITH EDGE met_err_RAW)) COIN EDGE (met_jog_EXP_b WITH EDGE met_err_RAW)
 met_jog_EXP = ((VERTEX (EXPAND EDGE met_jog_TMP OUTSIDE BY 0.001 EXTEND BY 0.001) == 4) OR (EXPAND EDGE met_err_RAW OUTSIDE BY 0.001)) NOT M2
 // 
 met_err_PRL = DFM PROPERTY met_jog_EXP met_err_RAW met_wid_all OVERLAP ABUT ALSO MULTI [-= LENGTH(met_err_RAW)] >= 0.083 [+= COUNT(met_wid_all)] > 0
 met_err_EGE = M2 COIN EDGE (met_err_RAW COIN EDGE (met_err_PRL COIN EDGE met_wid_all))
 err1 = ENC [RV2] met_err_EGE < 0.004 ABUT<90 OPPOSITE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
RVy2_EN_6a {
@ RVy enclosure by Mxy in adjacent S1 side, where Mxy is the metal layer directly underneath RVy >= 0.004um
@ When:
@ 1) Mxy width W: 0.051um <= W <= 0.112um
@ 2) Space: 0.058um <= S1 <= 0.094um, PRL >= 0.083um
@ DRC doesn't check RVy:
@ a) Two RVys with space <= 0.1um in M1 and 1.25xMy/Mxy intersection region
@ b) One Vy and one RVy with space <= 0.1um in M1 and 1.25xMy/Mxy intersection region
 met_wid_all = M2 WITH WIDTH > 0.051-GLOBAL_TOLERANCE <= 0.112
 met_err_RAW_TMP = EXT met_wid_all [M2] >= 0.058 < 0.094+GLOBAL_TOLERANCE ABUT<90 OPPOSITE MEASURE ALL
 met_err_RAW = EXT met_err_RAW_TMP [M2] >= 0.058 < 0.094+GLOBAL_TOLERANCE ABUT<90 OPPOSITE
 // 
 met_jog_ALL = M2_convex_eq_one_edges NOT COIN EDGE met_err_RAW
 met_jog_EXP_a = EXPAND EDGE met_jog_ALL INSIDE BY 0.0005
 met_jog_EXP_b = EXPAND EDGE met_jog_ALL OUTSIDE BY 0.0005
 met_jog_TMP = (met_jog_ALL COIN EDGE (met_jog_EXP_a WITH EDGE met_err_RAW)) COIN EDGE (met_jog_EXP_b WITH EDGE met_err_RAW)
 met_jog_EXP = ((VERTEX (EXPAND EDGE met_jog_TMP OUTSIDE BY 0.001 EXTEND BY 0.001) == 4) OR (EXPAND EDGE met_err_RAW OUTSIDE BY 0.001)) NOT M2
 // 
 met_err_PRL = DFM PROPERTY met_jog_EXP met_err_RAW met_wid_all OVERLAP ABUT ALSO MULTI [-= LENGTH(met_err_RAW)] >= 0.083 [+= COUNT(met_wid_all)] > 0
 met_err_EGE = M2 COIN EDGE (met_err_RAW COIN EDGE (met_err_PRL COIN EDGE met_wid_all))
 via_group_all = SIZE V2 BY 0.05 INSIDE OF (M2 AND M3) STEP 0.02
 via_group_real = V2 INTERACT (via_group_all INTERACT V2 >= 2)
 err1 = ENC (RV2 NOT via_group_real) met_err_EGE < 0.004 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
RVy2_EN_7 {
@ RVy enclosure by Mxy in adjacent S1 side, where Mxy is the metal layer directly underneath RVy >= 0.004um
@ When:
@ 1) Mxy dimension along enclosure direction: 0.113um <= L <= 0.201um
@ 2) Space: 0.058um <= S1 <= 0.094um, the PRL >= 0.083um
 met_wid_all = INT [M2] > 0.113-GLOBAL_TOLERANCE <= 0.201 ABUT<90 OPPOSITE EXCLUDE SHIELDED
 met_err_RAW = EXT [met_wid_all] M2 >= 0.058 < 0.094+GLOBAL_TOLERANCE ABUT<90 OPPOSITE
 met_jog_ALL = M2_convex_eq_one_edges NOT COIN EDGE met_err_RAW
 met_jog_EXP_a = EXPAND EDGE met_jog_ALL INSIDE BY 0.0005
 met_jog_EXP_b = EXPAND EDGE met_jog_ALL OUTSIDE BY 0.0005
 met_jog_TMP = (met_jog_ALL COIN EDGE (met_jog_EXP_a WITH EDGE met_err_RAW)) COIN EDGE (met_jog_EXP_b WITH EDGE met_err_RAW)
 met_jog_EXP = ((VERTEX (EXPAND EDGE met_jog_TMP OUTSIDE BY 0.001 EXTEND BY 0.001) == 4) OR (EXPAND EDGE met_err_RAW OUTSIDE BY 0.001)) NOT M2
 // 
 met_err_PRL = DFM PROPERTY met_jog_EXP met_err_RAW OVERLAP ABUT ALSO MULTI [-= LENGTH(met_err_RAW)] >= 0.083
 met_err_EGE = M2 COIN EDGE (met_err_RAW COIN EDGE met_err_PRL)
 err1 = ENC RV2 met_err_EGE < 0.004 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
RVy2_EN_8 {
@ RVy enclosure by Mxy in adjacent S1 side, where Mxy is the metal layer directly underneath RVy >= 0.014um
@ When:
@ 1) Mxy dimension along enclosure direction: L >= 0.202um
@ 2) Space: 0.058um <= S1 <= 0.094um, PRL >= 0.083um
 met_wid_all = INT (M2) <= 0.202-GLOBAL_TOLERANCE ABUT<90 OPPOSITE EXCLUDE SHIELDED
 met_err_RAW = EXT [met_wid_all] M2 >= 0.058 < 0.094+GLOBAL_TOLERANCE ABUT<90 OPPOSITE
 met_jog_ALL = M2_convex_eq_one_edges NOT COIN EDGE met_err_RAW
 met_jog_EXP_a = EXPAND EDGE met_jog_ALL INSIDE BY 0.0005
 met_jog_EXP_b = EXPAND EDGE met_jog_ALL OUTSIDE BY 0.0005
 met_jog_TMP = (met_jog_ALL COIN EDGE (met_jog_EXP_a WITH EDGE met_err_RAW)) COIN EDGE (met_jog_EXP_b WITH EDGE met_err_RAW)
 met_jog_EXP = ((VERTEX (EXPAND EDGE met_jog_TMP OUTSIDE BY 0.001 EXTEND BY 0.001) == 4) OR (EXPAND EDGE met_err_RAW OUTSIDE BY 0.001)) NOT M2
 // 
 met_err_PRL = DFM PROPERTY met_jog_EXP met_err_RAW OVERLAP ABUT ALSO MULTI [-= LENGTH(met_err_RAW)] >= 0.083
 met_err_EGE = M2 COIN EDGE (met_err_RAW COIN EDGE met_err_PRL)
 err1 = ENC RV2 met_err_EGE < 0.014 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 

#IFDEF DFM_RULES_PRIORITY_1 YES

RVy2_EN_9_DFM1 {
@ Recommended RVy fully enclosure by Mxy+1/1.25xMy is defined by either RVy.EN.9a.DFM or Vy.EN.9b.DFM, which Mxy+1/1.25xMy is the metal layer directly above rectangular RVy.
 err1 = RV2 NOT INSIDE M3
 err1 NOT INSIDE SealR_NOT_BULK
}
 
//;beginning of the RVy.EN.9a.DFM derivations
via_RVy_2_9a_R_bad = RECTANGLE ENCLOSURE RV2 M3 ABUT<90 SINGULAR OUTSIDE ALSO 
GOOD 0.020 0.020 0.020 0.020 OPPOSITE
via_RVy_2_9a_R_good = RV2 NOT via_RVy_2_9a_R_bad
//;end of the RVy.EN.9a.DFM derivations
 
RVy2_EN_9a_DFM1 {
@ Recommended RVy enclosure by Mxy+1/1.25xMy for all sides >= 0.020um
 err1 = via_RVy_2_9a_R_bad NOT via_RVy_2_9b_R_good
 err1 NOT INSIDE SealR_NOT_BULK
}
 
//;beginning of the RVy.EN.9b.DFM derivations
via_RVy_2_9b_R_bad = RECTANGLE ENCLOSURE RV2 M3 ABUT<90 SINGULAR OUTSIDE ALSO 
GOOD 0.007 0.025 OPPOSITE 0.007 0.025 OPPOSITE
via_RVy_2_9b_R_good = RV2 NOT via_RVy_2_9b_R_bad
//;end of the RVy.EN.9b.DFM derivations
 
RVy2_EN_9b_DFM1 {
@ Recommended RVy enclosure by Mxy+1/1.25xMy for two opposite sides with the other twosides >= 0.007um. >= 0.025um
 err1 = via_RVy_2_9b_R_bad NOT via_RVy_2_9a_R_good
 err2 = (ENC [RV2] M3 < 0.02 ABUT<90 SINGULAR) NOT TOUCH EDGE via_RVy_2_9b_R_good
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE EDGE SealR_NOT_BULK
}

#ENDIF

 
//;RVy.EN.9 only for Mxy+1 
//;beginning of the RVy.EN.9 derivations
via_RVy2_bad_9_1 = RECTANGLE ENCLOSURE RV2 M3 ABUT<90 SINGULAR 
GOOD 0.015 0.015 0.015 0.015 OPPOSITE
via_RVy2_good_9_1 = RV2 NOT via_RVy2_bad_9_1
// 
via_RVy2_good_9_2_TMP = ENC [RV2_W] M3 < 0.024 ABUT<90 OPPOSITE
via_RVy2_good_9_2 = via_RVy2_bad_9_1 NOT WITH EDGE via_RVy2_good_9_2_TMP
// 
via_RVy2_bad_9_3 = RECTANGLE ENCLOSURE RV2 M3 ABUT<90 SINGULAR 
GOOD 0.007 0.019 OPPOSITE 0.007 0.019 OPPOSITE
via_RVy2_good_9_3 = RV2 NOT via_RVy2_bad_9_3
 
via_RVy2_9_bad = RV2 NOT (OR via_RVy2_good_9_1 via_RVy2_good_9_2 via_RVy2_good_9_3)
via_RVy2_9_good = RV2 NOT via_RVy2_9_bad
//;end of the RVy.EN.9 derivations
 
RVy2_EN_9 {
@ RVy must be fully enclosed by Mxy+1/1.25xMy where Mxy+1/1.25xMy is the metal layer directly above rectangular Vy
@ Enclosure by Mxy+1/1.25xMy must follow one of RVy.EN.9.1, RVy.EN.9.2, RVy.EN.9.3, RVy.EN.10 RVy.EN.10a1, RVy.EN.10a2, RVy.EN.10b or RVy.EN.11 or RVy.EN.12
 err1 = RV2 NOT M3
 err1 NOT INSIDE SealR_NOT_BULK
}
 
RVy2_EN_9_1_2_3 {
@ RVy.EN.9.1: RVy enclosure by Mxy+1 for all sides >= 0.015um
@ RVy.EN.9.2: Enclosure of short side of RVy by Mxy+1 for two opposite sides with the other two side >= 0um. >= 0.024um
@ RVy.EN.9.3: RVy enclosure by Mxy+1 for two opposite sides with the other two sides >= 0.007um. >= 0.019um
 err1 = copy via_RVy2_9_bad
 err1 NOT INSIDE SealR_NOT_BULK
}
 
RVy2_EN_9_4 {
@ RVy enclosure by Mxy+1 (0.036um <= Mxy+1 width <= 0.041um 0.058um <= space < 0.063um and the opposite space >= 0.069um, PRL >= 0.083um) >= 0.004um
 met_wid_all = M3 WITH WIDTH > 0.036-GLOBAL_TOLERANCE <= 0.041
 met_err_RAW_a = EXT [met_wid_all] M3 >= 0.058 < 0.063 ABUT<90 OPPOSITE MEASURE ALL
 met_err_RAW_b = EXT met_wid_all M3 >= 0.058 < 0.063 ABUT<90 OPPOSITE MEASURE ALL
 met_err_RAW_c = EXT met_wid_all [M3] >= 0.058 < 0.063 ABUT<90 OPPOSITE MEASURE ALL
 met_err_PRL = DFM PROPERTY met_err_RAW_b met_err_RAW_c OVERLAP ABUT ALSO MULTI [-= max(LENGTH(met_err_RAW_c))] >= 0.083
 // 
 met_err_EGE_a = met_err_RAW_a COIN EDGE (DFM COPY met_err_PRL EDGE)
 met_err_EGE_b = ENC RV2 [met_err_EGE_a] < 0.004 ABUT<90 OPPOSITE
 met_err_EGE_c = INT met_err_EGE_b [M3] > 0.036-GLOBAL_TOLERANCE <= 0.041 ABUT<90 OPPOSITE MEASURE COIN
 met_err_EGE_d = EXT (met_err_EGE_c) M3 < 0.069 ABUT<90 OPPOSITE
 met_err_EGE_e = met_err_EGE_b COIN EDGE M3
 err1 = INT met_err_EGE_d [met_err_EGE_e] > 0.036-GLOBAL_TOLERANCE <= 0.041 ABUT<90 OPPOSITE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
//;RVy.EN.10~RVy.EN.14 only for 125xMn+1/125xMy+1 
 
RVy2_R_1 {
@ Single RVy is not allowed in H-shape Mxy+1/1.25xMy, when:
@ 1) The Mxy+1/1.25xMy has H-shape interacting with two metal holes: both two metal holes length <= 4.5um and two metal hole area <= 4.05um2
@ 2) The RVy overlaps on the center metal bar of this H-shape Mxy+1/1.25xMy
@ 3) The center metal bar length <= 0.9um and the metal bar width <= 0.12um
 // @ DRC doesn't check when one or more square 1xVn is also on H-shape Mxy+1/1.25xMy region
 hole_area_meet = AREA (HOLES M3 INNER) <= 4.05
 hole_area_meet_len = (hole_area_meet WITH EDGE (LENGTH hole_area_meet <= 0.9)) NOT WITH EDGE (LENGTH hole_area_meet > 4.5)
 hole_area_real = (hole_area_meet_len NOT ENCLOSE RECTANGLE 0.9+GLOBAL_TOLERANCE 4.5) NOT ENCLOSE RECTANGLE 0.9 4.5+GLOBAL_TOLERANCE
 hole_bars_len = M3 COIN EDGE hole_area_real
 // 
 hole_bars = INT hole_bars_len <= 0.12 ABUT<90 OPPOSITE REGION EXCLUDE SHIELDED
 hole_bars_real = hole_bars WITH EDGE (LENGTH hole_bars_len <= 0.9)
 hole_bars_vias_rect = RV2 INTERACT ((hole_bars_real INTERACT hole_area_real == 2) NOT ENCLOSE V2N >= 2)
 err1 = hole_bars_real INTERACT hole_bars_vias_rect == 1
 err1 NOT INSIDE SealR_NOT_BULK
}
 
RVy2_R_2 {
@ Redundant via requirement must be obeyed by one of following conditions of Vy numbers and space for Mxy and 1.25xMy connection
@ (One of Mxy or 1.25xMy has width and length >= 0.162um) (Except VIA bar)
@ 1) At least one rectangular Vy
@ 2) At least two square Vy with space <= 0.091um
@ 3) At least four square Vy with space <= 0.415um
 X1a = WITH WIDTH M2 > 0.162-GLOBAL_TOLERANCE <= 0.272-GLOBAL_TOLERANCE
 X1b = WITH WIDTH M3 > 0.162-GLOBAL_TOLERANCE <= 0.272-GLOBAL_TOLERANCE
 Y1a = WITH WIDTH M2 > 0.272-GLOBAL_TOLERANCE
 Y1b = WITH WIDTH M3 > 0.272-GLOBAL_TOLERANCE
 WIDE_1 = (X1a AND M3) ENCLOSE V2
 WIDE_2 = (M2 AND X1b) ENCLOSE V2
 WIDE_3 = (Y1a AND M3) ENCLOSE V2
 WIDE_4 = (M2 AND Y1b) ENCLOSE V2
 WIDE_all_raw = (WIDE_1 OR WIDE_2) NOT (WIDE_3 OR WIDE_4)
 WIDE_all = (M2 AND M3) NOT OUTSIDE WIDE_all_raw
 // 
 // condition 1 & 2
 Y1_good = WIDE_all_raw AND RV2
 Y2_good = WIDE_all_raw AND 2XV2N
 // 
 // condition 3
 Y3_wide_all = WIDE_all_raw NOT INTERACT (OR Y1_good Y2_good)
 Y3_wide = (WIDE_all INTERACT Y3_wide_all) INTERACT V2_SR >= 2
 Y3_comb_step = SIZE V2_SR BY 0.091/2 INSIDE OF Y3_wide STEP 0.020
 Y3_good_step = OR (Y3_comb_step INTERACT V2N >= 2) (Y3_comb_step INTERACT (OR RV2 2XV2N))
 Y3_good = WIDE_all_raw AND Y3_good_step
 // 
 // condition 4: 32nm*32nm via can be replaced by 2XVia/RVia
 Y4_wide_all = WIDE_all_raw NOT INTERACT (OR Y1_good Y2_good Y3_good)
 Y4_wide = (WIDE_all INTERACT Y4_wide_all) INTERACT V2_SR >= 2 // rectangle array 0.415/2 =0.207
 Y4_vias_input = V2_SR AND Y4_wide
 Y4_wide_chk_1 = Y4_wide INTERACT Y4_wide_all
 Y4_comb_step1 = SIZE Y4_vias_input BY 0.050 INSIDE OF Y4_wide_chk_1 STEP 0.020
 Y4_good_step1_a = OR (Y4_comb_step1 INTERACT V2N >= 4) ((Y4_comb_step1 INTERACT V2N >= 2) INTERACT (OR RV2 2XV2N)) // step1: 0.050
 Y4_good_step1_b = OR (Y4_comb_step1 INTERACT 2XV2N >= 2) (Y4_comb_step1 INTERACT RV2 >= 2)
 Y4_good_step1 = OR Y4_good_step1_a Y4_good_step1_b
 // 
 Y4_wide_chk_2 = Y4_wide_chk_1 INTERACT (WIDE_all_raw NOT INTERACT Y4_good_step1)
 Y4_comb_step2 = SIZE Y4_comb_step1 BY 0.035 INSIDE OF Y4_wide_chk_2 STEP 0.020
 Y4_good_step2_a = OR (Y4_comb_step2 INTERACT V2N >= 4) ((Y4_comb_step2 INTERACT V2N >= 2) INTERACT (OR RV2 2XV2N)) // step2: 0.035
 Y4_good_step2_b = OR (Y4_comb_step2 INTERACT 2XV2N >= 2) (Y4_comb_step2 INTERACT RV2 >= 2)
 Y4_good_step2 = OR Y4_good_step2_a Y4_good_step2_b
 // 
 Y4_wide_chk_3 = Y4_wide_chk_2 INTERACT (WIDE_all_raw NOT INTERACT Y4_good_step2)
 Y4_comb_step3 = SIZE Y4_comb_step2 BY 0.035 INSIDE OF Y4_wide_chk_3 STEP 0.020
 Y4_good_step3_a = OR (Y4_comb_step3 INTERACT V2N >= 4) ((Y4_comb_step3 INTERACT V2N >= 2) INTERACT (OR RV2 2XV2N)) // step3: 0.035
 Y4_good_step3_b = OR (Y4_comb_step3 INTERACT 2XV2N >= 2) (Y4_comb_step3 INTERACT RV2 >= 2)
 Y4_good_step3 = OR Y4_good_step3_a Y4_good_step3_b
 // 
 Y4_wide_chk_4 = Y4_wide_chk_3 INTERACT (WIDE_all_raw NOT INTERACT Y4_good_step3)
 Y4_comb_step4 = SIZE Y4_comb_step3 BY 0.035 INSIDE OF Y4_wide_chk_4 STEP 0.020
 Y4_good_step4_a = OR (Y4_comb_step4 INTERACT V2N >= 4) ((Y4_comb_step4 INTERACT V2N >= 2) INTERACT (OR RV2 2XV2N)) // step4: 0.035
 Y4_good_step4_b = OR (Y4_comb_step4 INTERACT 2XV2N >= 2) (Y4_comb_step4 INTERACT RV2 >= 2)
 Y4_good_step4 = OR Y4_good_step4_a Y4_good_step4_b
 // 
 Y4_wide_chk_5 = Y4_wide_chk_4 INTERACT (WIDE_all_raw NOT INTERACT Y4_good_step4)
 Y4_comb_step5 = SIZE Y4_comb_step4 BY 0.035 INSIDE OF Y4_wide_chk_5 STEP 0.020
 Y4_good_step5_a = OR (Y4_comb_step5 INTERACT V2N >= 4) ((Y4_comb_step5 INTERACT V2N >= 2) INTERACT (OR RV2 2XV2N)) // step5: 0.035
 Y4_good_step5_b = OR (Y4_comb_step5 INTERACT 2XV2N >= 2) (Y4_comb_step5 INTERACT RV2 >= 2)
 Y4_good_step5 = OR Y4_good_step5_a Y4_good_step5_b
 // 
 Y4_wide_chk_6 = Y4_wide_chk_5 INTERACT (WIDE_all_raw NOT INTERACT Y4_good_step5)
 Y4_comb_step6 = SIZE Y4_comb_step5 BY 0.018 INSIDE OF Y4_wide_chk_6 STEP 0.015
 Y4_good_step6_a = OR (Y4_comb_step6 INTERACT V2N >= 4) ((Y4_comb_step6 INTERACT V2N >= 2) INTERACT (OR RV2 2XV2N)) // step6: 0.207-0.05-0.035*4=0.018
 Y4_good_step6_b = OR (Y4_comb_step6 INTERACT 2XV2N >= 2) (Y4_comb_step6 INTERACT RV2 >= 2)
 Y4_good_step6 = OR Y4_good_step6_a Y4_good_step6_b
 Y4_good = WIDE_all_raw AND (OR Y4_good_step1 Y4_good_step2 Y4_good_step3 Y4_good_step4 Y4_good_step5 Y4_good_step6)
 // 
 err1 = (WIDE_all_raw OUTSIDE (OR Y1_good Y2_good Y3_good Y4_good)) INTERACT V2
 err1 NOT INTERACT Vy2_BAR
}
 
RVy2_R_3 {
@ Redundant via requirement must be obeyed by one of following conditions of Vy numbers and space for Mxy and 1.25xMy connection
@ (One of Mxy or 1.25xMy has width and length >= 0.272um, two square vias are equal to one rectangular via for below conditions) (Except VIA bar, MARKS and OCCD region)
@ 1) At least four square Vy with space <= 0.091um
@ 2) At least nine square Vy with space <= 0.545um
@ 3) At least two rectangular Vy with space <= 0.202um
@ 4) At least five rectangular Vy with space <= 0.545um
 X1a = WITH WIDTH M2 > 0.272-GLOBAL_TOLERANCE
 X1b = WITH WIDTH M3 > 0.272-GLOBAL_TOLERANCE
 WIDE_1 = (X1a AND M3) ENCLOSE V2
 WIDE_2 = (M2 AND X1b) ENCLOSE V2
 WIDE_all_raw = WIDE_1 OR WIDE_2
 WIDE_all = (M2 AND M3) NOT OUTSIDE WIDE_all_raw
 // 
 // condition 3: not replaced by RVia
 Y3_wide = WIDE_all INTERACT V2N >= 4 // rectangle array 0.091/2=0.045
 Y3_vias_input = V2N AND Y3_wide
 Y3_comb_step = SIZE Y3_vias_input BY 0.091/2 INSIDE OF Y3_wide STEP 0.02 // via minimum space = 0.083
 Y3_good_step = Y3_comb_step INTERACT V2N >= 4
 Y3_good = WIDE_all_raw AND Y3_good_step
 // 
 // condition 1 & 2 & 4 & 5: 32nm*32nm via can be replaced by 2XVia/RVia
 Y1_wide_all = WIDE_all_raw NOT INTERACT Y3_good
 Y1_wide = (WIDE_all INTERACT Y1_wide_all) INTERACT V2_SR >= 2 // rectangle array 0.545/2=0.272
 Y1_vias_input = V2_SR AND Y1_wide
 Y1_wide_chk_1 = Y1_wide INTERACT Y1_wide_all
 Y1_comb_step1 = SIZE Y1_vias_input BY 0.061 INSIDE OF Y1_wide_chk_1 STEP 0.02 // step1: 0.061, via minimum space = 0.202/2=0.101
 Y1_good_step1_a = Y1_comb_step1 INTERACT V2N >= 9
 Y1_good_step1_b = Y1_comb_step1 INTERACT RV2 >= 5
 Y1_good_step1_c = Y1_comb_step1 INTERACT 2XV2N >= 3
 Y1_good_step1_d = (Y1_comb_step1 INTERACT 1XV2N >= 7) INTERACT RV2 >= 1
 Y1_good_step1_e = (Y1_comb_step1 INTERACT 1XV2N >= 6) INTERACT 2XV2N >= 1
 Y1_good_step1_f = (Y1_comb_step1 INTERACT 1XV2N >= 5) INTERACT RV2 >= 2
 Y1_good_step1_g = ((Y1_comb_step1 INTERACT 1XV2N >= 4) INTERACT 2XV2N >= 1) INTERACT RV2 >= 1
 Y1_good_step1_h = (Y1_comb_step1 INTERACT 1XV2N >= 3) INTERACT RV2 >= 3
 Y1_good_step1_i = (Y1_comb_step1 INTERACT 1XV2N >= 3) INTERACT 2XV2N >= 2
 Y1_good_step1_j = ((Y1_comb_step1 INTERACT 1XV2N >= 2) INTERACT 2XV2N >= 1) INTERACT RV2 >= 2
 // SETLAYER Y1_good_step1_k = (Y1_comb_step1 INTERACT 1XV2N >= 1) INTERACT RV2 >= 4
 Y1_good_step1_l = ((Y1_comb_step1 INTERACT 1XV2N >= 1) INTERACT 2XV2N >= 2) INTERACT RV2 >= 1
 Y1_good_step1_m = Y1_comb_step1 INTERACT RV2 >= 2 // remove good condition3_val: 0.202
 Y1_good_step1_n = Y1_comb_step1 INTERACT 2XV2N >= 2
 Y1_good_step1_o = (Y1_comb_step1 INTERACT 1XV2N >= 2) INTERACT RV2 >= 1
 Y1_good_step1_p = (Y1_comb_step1 INTERACT 1XV2N >= 1) INTERACT 2XV2N >= 1
 Y1_good_step1_q = (Y1_comb_step1 INTERACT 2XV2N >= 1) INTERACT RV2 >= 1
 Y1_good_step1_r = OR Y1_good_step1_a Y1_good_step1_b Y1_good_step1_c Y1_good_step1_d Y1_good_step1_e Y1_good_step1_f Y1_good_step1_g Y1_good_step1_h
 Y1_good_step1_s = OR Y1_good_step1_i Y1_good_step1_j Y1_good_step1_l Y1_good_step1_m Y1_good_step1_n Y1_good_step1_o Y1_good_step1_p Y1_good_step1_q
 Y1_good_step1 = OR Y1_good_step1_r Y1_good_step1_s
 // 
 Y1_wide_chk_2 = Y1_wide_chk_1 INTERACT (WIDE_all_raw NOT INTERACT Y1_good_step1)
 Y1_comb_step2 = SIZE Y1_comb_step1 BY 0.040 INSIDE OF Y1_wide_chk_2 STEP 0.02 // step2: 0.040
 Y1_good_step2_a = Y1_comb_step2 INTERACT V2N >= 9
 Y1_good_step2_b = Y1_comb_step2 INTERACT RV2 >= 5
 Y1_good_step2_c = Y1_comb_step2 INTERACT 2XV2N >= 3
 Y1_good_step2_d = (Y1_comb_step2 INTERACT 1XV2N >= 7) INTERACT RV2 >= 1
 Y1_good_step2_e = (Y1_comb_step2 INTERACT 1XV2N >= 6) INTERACT 2XV2N >= 1
 Y1_good_step2_f = (Y1_comb_step2 INTERACT 1XV2N >= 5) INTERACT RV2 >= 2
 Y1_good_step2_g = ((Y1_comb_step2 INTERACT 1XV2N >= 4) INTERACT 2XV2N >= 1) INTERACT RV2 >= 1
 Y1_good_step2_h = (Y1_comb_step2 INTERACT 1XV2N >= 3) INTERACT RV2 >= 3
 Y1_good_step2_i = (Y1_comb_step2 INTERACT 1XV2N >= 3) INTERACT 2XV2N >= 2
 Y1_good_step2_j = ((Y1_comb_step2 INTERACT 1XV2N >= 2) INTERACT 2XV2N >= 1) INTERACT RV2 >= 2
 // SETLAYER Y1_good_step2_k = (Y1_comb_step2 INTERACT 1XV2N >= 1) INTERACT RV2 >= 4
 Y1_good_step2_l = ((Y1_comb_step2 INTERACT 1XV2N >= 1) INTERACT 2XV2N >= 2) INTERACT RV2 >= 1
 Y1_good_step2_m = Y1_comb_step2 INTERACT RV2 >= 2
 Y1_good_step2_n = Y1_comb_step2 INTERACT 2XV2N >= 2
 Y1_good_step2_o = (Y1_comb_step2 INTERACT 1XV2N >= 2) INTERACT RV2 >= 1
 Y1_good_step2_p = (Y1_comb_step2 INTERACT 1XV2N >= 1) INTERACT 2XV2N >= 1
 Y1_good_step2_q = (Y1_comb_step2 INTERACT 2XV2N >= 1) INTERACT RV2 >= 1
 Y1_good_step2_r = OR Y1_good_step2_a Y1_good_step2_b Y1_good_step2_c Y1_good_step2_d Y1_good_step2_e Y1_good_step2_f Y1_good_step2_g Y1_good_step2_h
 Y1_good_step2_s = OR Y1_good_step2_i Y1_good_step2_j Y1_good_step2_l Y1_good_step2_m Y1_good_step2_n Y1_good_step2_o Y1_good_step2_p Y1_good_step2_q
 Y1_good_step2 = OR Y1_good_step2_r Y1_good_step2_s
 // 
 // condition 1 & 2 & 4 & 5: 32nm*32nm via can be replaced by 2XVia/RVia
 Y1_wide_chk_3 = Y1_wide_chk_2 INTERACT (WIDE_all_raw NOT INTERACT Y1_good_step2)
 Y1_comb_step3 = SIZE Y1_comb_step2 BY 0.04 INSIDE OF Y1_wide_chk_3 STEP 0.02 // step3: 0.040
 Y1_good_step3_a = Y1_comb_step3 INTERACT V2N >= 9
 Y1_good_step3_b = Y1_comb_step3 INTERACT RV2 >= 5
 Y1_good_step3_c = Y1_comb_step3 INTERACT 2XV2N >= 3
 Y1_good_step3_d = (Y1_comb_step3 INTERACT 1XV2N >= 7) INTERACT RV2 >= 1
 Y1_good_step3_e = (Y1_comb_step3 INTERACT 1XV2N >= 6) INTERACT 2XV2N >= 1
 Y1_good_step3_f = (Y1_comb_step3 INTERACT 1XV2N >= 5) INTERACT RV2 >= 2
 Y1_good_step3_g = ((Y1_comb_step3 INTERACT 1XV2N >= 4) INTERACT 2XV2N >= 1) INTERACT RV2 >= 1
 Y1_good_step3_h = (Y1_comb_step3 INTERACT 1XV2N >= 3) INTERACT RV2 >= 3
 Y1_good_step3_i = (Y1_comb_step3 INTERACT 1XV2N >= 3) INTERACT 2XV2N >= 2
 Y1_good_step3_j = ((Y1_comb_step3 INTERACT 1XV2N >= 2) INTERACT 2XV2N >= 1) INTERACT RV2 >= 2
 // SETLAYER Y1_good_step3_k = (Y1_comb_step3 INTERACT 1XV2N >= 1) INTERACT RV2 >= 4
 Y1_good_step3_l = ((Y1_comb_step3 INTERACT 1XV2N >= 1) INTERACT 2XV2N >= 2) INTERACT RV2 >= 1
 Y1_good_step3_r = OR Y1_good_step3_a Y1_good_step3_b Y1_good_step3_c Y1_good_step3_d Y1_good_step3_e Y1_good_step3_f Y1_good_step3_g Y1_good_step3_h
 Y1_good_step3_s = OR Y1_good_step3_i Y1_good_step3_j Y1_good_step3_l
 Y1_good_step3 = OR Y1_good_step3_r Y1_good_step3_s
 // 
 Y1_wide_chk_4 = Y1_wide_chk_3 INTERACT (WIDE_all_raw NOT INTERACT Y1_good_step3)
 Y1_comb_step4 = SIZE Y1_comb_step3 BY 0.040 INSIDE OF Y1_wide_chk_4 STEP 0.02 // step4: 0.040
 Y1_good_step4_a = Y1_comb_step4 INTERACT V2N >= 9
 Y1_good_step4_b = Y1_comb_step4 INTERACT RV2 >= 5
 Y1_good_step4_c = Y1_comb_step4 INTERACT 2XV2N >= 3
 Y1_good_step4_d = (Y1_comb_step4 INTERACT 1XV2N >= 7) INTERACT RV2 >= 1
 Y1_good_step4_e = (Y1_comb_step4 INTERACT 1XV2N >= 6) INTERACT 2XV2N >= 1
 Y1_good_step4_f = (Y1_comb_step4 INTERACT 1XV2N >= 5) INTERACT RV2 >= 2
 Y1_good_step4_g = ((Y1_comb_step4 INTERACT 1XV2N >= 4) INTERACT 2XV2N >= 1) INTERACT RV2 >= 1
 Y1_good_step4_h = (Y1_comb_step4 INTERACT 1XV2N >= 3) INTERACT RV2 >= 3
 Y1_good_step4_i = (Y1_comb_step4 INTERACT 1XV2N >= 3) INTERACT 2XV2N >= 2
 Y1_good_step4_j = ((Y1_comb_step4 INTERACT 1XV2N >= 2) INTERACT 2XV2N >= 1) INTERACT RV2 >= 2
 // SETLAYER Y1_good_step4_k = (Y1_comb_step4 INTERACT 1XV2N >= 1) INTERACT RV2 >= 4
 Y1_good_step4_l = ((Y1_comb_step4 INTERACT 1XV2N >= 1) INTERACT 2XV2N >= 2) INTERACT RV2 >= 1
 Y1_good_step4_r = OR Y1_good_step4_a Y1_good_step4_b Y1_good_step4_c Y1_good_step4_d Y1_good_step4_e Y1_good_step4_f Y1_good_step4_g Y1_good_step4_h
 Y1_good_step4_s = OR Y1_good_step4_i Y1_good_step4_j Y1_good_step4_l
 Y1_good_step4 = OR Y1_good_step4_r Y1_good_step4_s
 // 
 Y1_wide_chk_5 = Y1_wide_chk_4 INTERACT (WIDE_all_raw NOT INTERACT Y1_good_step4)
 Y1_comb_step5 = SIZE Y1_comb_step4 BY 0.040 INSIDE OF Y1_wide_chk_5 STEP 0.02 // step5: 0.040
 Y1_good_step5_a = Y1_comb_step5 INTERACT V2N >= 9
 Y1_good_step5_b = Y1_comb_step5 INTERACT RV2 >= 5
 Y1_good_step5_c = Y1_comb_step5 INTERACT 2XV2N >= 3
 Y1_good_step5_d = (Y1_comb_step5 INTERACT 1XV2N >= 7) INTERACT RV2 >= 1
 Y1_good_step5_e = (Y1_comb_step5 INTERACT 1XV2N >= 6) INTERACT 2XV2N >= 1
 Y1_good_step5_f = (Y1_comb_step5 INTERACT 1XV2N >= 5) INTERACT RV2 >= 2
 Y1_good_step5_g = ((Y1_comb_step5 INTERACT 1XV2N >= 4) INTERACT 2XV2N >= 1) INTERACT RV2 >= 1
 Y1_good_step5_h = (Y1_comb_step5 INTERACT 1XV2N >= 3) INTERACT RV2 >= 3
 Y1_good_step5_i = (Y1_comb_step5 INTERACT 1XV2N >= 3) INTERACT 2XV2N >= 2
 Y1_good_step5_j = ((Y1_comb_step5 INTERACT 1XV2N >= 2) INTERACT 2XV2N >= 1) INTERACT RV2 >= 2
 // SETLAYER Y1_good_step5_k = (Y1_comb_step5 INTERACT 1XV2N >= 1) INTERACT RV2 >= 4
 Y1_good_step5_l = ((Y1_comb_step5 INTERACT 1XV2N >= 1) INTERACT 2XV2N >= 2) INTERACT RV2 >= 1
 Y1_good_step5_r = OR Y1_good_step5_a Y1_good_step5_b Y1_good_step5_c Y1_good_step5_d Y1_good_step5_e Y1_good_step5_f Y1_good_step5_g Y1_good_step5_h
 Y1_good_step5_s = OR Y1_good_step5_i Y1_good_step5_j Y1_good_step5_l
 Y1_good_step5 = OR Y1_good_step5_r Y1_good_step5_s
 // 
 Y1_wide_chk_6 = Y1_wide_chk_5 INTERACT (WIDE_all_raw NOT INTERACT Y1_good_step5)
 Y1_comb_step6 = SIZE Y1_comb_step5 BY 0.040 INSIDE OF Y1_wide_chk_6 STEP 0.02 // step6: 0.040
 Y1_good_step6_a = Y1_comb_step6 INTERACT V2N >= 9
 Y1_good_step6_b = Y1_comb_step6 INTERACT RV2 >= 5
 Y1_good_step6_c = Y1_comb_step6 INTERACT 2XV2N >= 3
 Y1_good_step6_d = (Y1_comb_step6 INTERACT 1XV2N >= 7) INTERACT RV2 >= 1
 Y1_good_step6_e = (Y1_comb_step6 INTERACT 1XV2N >= 6) INTERACT 2XV2N >= 1
 Y1_good_step6_f = (Y1_comb_step6 INTERACT 1XV2N >= 5) INTERACT RV2 >= 2
 Y1_good_step6_g = ((Y1_comb_step6 INTERACT 1XV2N >= 4) INTERACT 2XV2N >= 1) INTERACT RV2 >= 1
 Y1_good_step6_h = (Y1_comb_step6 INTERACT 1XV2N >= 3) INTERACT RV2 >= 3
 Y1_good_step6_i = (Y1_comb_step6 INTERACT 1XV2N >= 3) INTERACT 2XV2N >= 2
 Y1_good_step6_j = ((Y1_comb_step6 INTERACT 1XV2N >= 2) INTERACT 2XV2N >= 1) INTERACT RV2 >= 2
 // SETLAYER Y1_good_step6_k = (Y1_comb_step6 INTERACT 1XV2N >= 1) INTERACT RV2 >= 4
 Y1_good_step6_l = ((Y1_comb_step6 INTERACT 1XV2N >= 1) INTERACT 2XV2N >= 2) INTERACT RV2 >= 1
 Y1_good_step6_r = OR Y1_good_step6_a Y1_good_step6_b Y1_good_step6_c Y1_good_step6_d Y1_good_step6_e Y1_good_step6_f Y1_good_step6_g Y1_good_step6_h
 Y1_good_step6_s = OR Y1_good_step6_i Y1_good_step6_j Y1_good_step6_l
 Y1_good_step6 = OR Y1_good_step6_r Y1_good_step6_s
 // 
 Y1_wide_chk_7 = Y1_wide_chk_6 INTERACT (WIDE_all_raw NOT INTERACT Y1_good_step6)
 Y1_comb_step7 = SIZE Y1_comb_step6 BY 0.011 INSIDE OF Y1_wide_chk_7 STEP 0.02 // step7: 0.272-0.061-0.04-0.040*4=0.011
 Y1_good_step7_a = Y1_comb_step7 INTERACT V2N >= 9
 Y1_good_step7_b = Y1_comb_step7 INTERACT RV2 >= 5
 Y1_good_step7_c = Y1_comb_step7 INTERACT 2XV2N >= 3
 Y1_good_step7_d = (Y1_comb_step7 INTERACT 1XV2N >= 7) INTERACT RV2 >= 1
 Y1_good_step7_e = (Y1_comb_step7 INTERACT 1XV2N >= 6) INTERACT 2XV2N >= 1
 Y1_good_step7_f = (Y1_comb_step7 INTERACT 1XV2N >= 5) INTERACT RV2 >= 2
 Y1_good_step7_g = ((Y1_comb_step7 INTERACT 1XV2N >= 4) INTERACT 2XV2N >= 1) INTERACT RV2 >= 1
 Y1_good_step7_h = (Y1_comb_step7 INTERACT 1XV2N >= 3) INTERACT RV2 >= 3
 Y1_good_step7_i = (Y1_comb_step7 INTERACT 1XV2N >= 3) INTERACT 2XV2N >= 2
 Y1_good_step7_j = ((Y1_comb_step7 INTERACT 1XV2N >= 2) INTERACT 2XV2N >= 1) INTERACT RV2 >= 2
 // SETLAYER Y1_good_step7_k = (Y1_comb_step7 INTERACT 1XV2N >= 1) INTERACT RV2 >= 4
 Y1_good_step7_l = ((Y1_comb_step7 INTERACT 1XV2N >= 1) INTERACT 2XV2N >= 2) INTERACT RV2 >= 1
 Y1_good_step7_r = OR Y1_good_step7_a Y1_good_step7_b Y1_good_step7_c Y1_good_step7_d Y1_good_step7_e Y1_good_step7_f Y1_good_step7_g Y1_good_step7_h
 Y1_good_step7_s = OR Y1_good_step7_i Y1_good_step7_j Y1_good_step7_l
 Y1_good_step7 = OR Y1_good_step7_r Y1_good_step7_s
 Y1_Y2_Y4_good = WIDE_all_raw AND (OR Y1_good_step1 Y1_good_step2 Y1_good_step3 Y1_good_step4 Y1_good_step5 Y1_good_step6 Y1_good_step7)
 // 
 err1 = (WIDE_all_raw OUTSIDE (OR Y1_Y2_Y4_good Y3_good)) INTERACT V2
 (err1 NOT INTERACT Vy2_BAR) NOT INSIDE OCCD_MARKS
}
 
RVy2_R_4_M2 {
@ There should be at least two square Vy or one rectangular Vy in the intersection area of bottom metal and upper metal, when either wide metal Mxy or 1.25xMy length >= 0.162um and width >= 0.162um, the space between either via and wide metal <= 0.5um (S, S is the shortest running path length from Via to the wide metal). (except via bar)
 // DRC flags each intersecting area ({bottom metal AND upper metal}) with single square Via within the branch check region
 wide_M2 = (WITH WIDTH M2 > 0.162-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 0.162-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 0.162-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M2_real = wide_M2 NOT OUTSIDE ((SIZE wide_M2 BY 0.5+GLOBAL_TOLERANCE) INTERACT V2)
 all_down_and_up = (M2 INTERACT wide_M2) AND M3
 dis_down_arm_wide_all = SIZE wide_M2_real BY 0.5+GLOBAL_TOLERANCE INSIDE OF M2 STEP 0.025
 dis_down_and_up = dis_down_arm_wide_all AND all_down_and_up
 dis_down_and_up_arm = (dis_down_and_up NOT wide_M2) AND M2
 dis_down_arm = (dis_down_arm_wide_all NOT wide_M2) AND M2
 // 
 dis_down_arm_good_a = dis_down_and_up_arm INTERACT 1XV2N >= 2
 dis_down_arm_good_b = dis_down_and_up_arm INTERACT RV2
 dis_down_arm_good_c = dis_down_and_up_arm INTERACT 2XV2N
 dis_down_arm_good = OR dis_down_arm_good_a dis_down_arm_good_b dis_down_arm_good_c
 dis_down_arm_bad = (dis_down_and_up_arm NOT dis_down_arm_good) INTERACT (all_down_and_up INTERACT 1XV2N == 1)
 // 
 dis_down_arm_err_stack = (dis_down_arm_bad AND dis_down_and_up_arm) INTERACT 1XV2N
 dis_down_arm_err = dis_down_arm INTERACT dis_down_arm_err_stack
 err1_met_down = (dis_down_arm_err INTERACT (1XV2N NOT OUTSIDE dis_down_arm_err)) NOT INTERACT (OR RV2 2XV2N)
 // 
 wide_M3 = (WITH WIDTH M3 > 0.162-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 0.162-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 0.162-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M3_real = wide_M3 NOT OUTSIDE ((SIZE wide_M3 BY 0.5+GLOBAL_TOLERANCE) INTERACT V2)
 all_up_and_down = (M3 INTERACT wide_M3) AND M2
 dis_up_arm_wide_all = SIZE wide_M3_real BY 0.5+GLOBAL_TOLERANCE INSIDE OF M3 STEP 0.025
 dis_up_and_down = dis_up_arm_wide_all AND all_up_and_down
 dis_up_and_down_arm = (dis_up_and_down NOT wide_M3) AND M3
 dis_up_arm = (dis_up_arm_wide_all NOT wide_M3) AND M3
 // 
 dis_up_arm_good_a = dis_up_and_down_arm INTERACT 1XV2N >= 2
 dis_up_arm_good_b = dis_up_and_down_arm INTERACT RV2
 dis_up_arm_good_c = dis_up_and_down_arm INTERACT 2XV2N
 dis_up_arm_good = OR dis_up_arm_good_a dis_up_arm_good_b dis_up_arm_good_c
 dis_up_arm_bad = (dis_up_and_down_arm NOT dis_up_arm_good) INTERACT (all_up_and_down INTERACT 1XV2N == 1)
 // 
 dis_up_arm_err_stack = (dis_up_arm_bad AND dis_up_and_down_arm) INTERACT 1XV2N
 dis_up_arm_err = dis_up_arm INTERACT dis_up_arm_err_stack
 err2_met_up = (dis_up_arm_err INTERACT (1XV2N NOT OUTSIDE dis_up_arm_err)) NOT INTERACT (OR RV2 2XV2N)
 err1_met_down NOT INTERACT Vy2_BAR
}
 
RVy2_R_4_M3 {
@ There should be at least two square Vy or one rectangular Vy in the intersection area of bottom metal and upper metal, when either wide metal Mxy or 1.25xMy length >= 0.162um and width >= 0.162um, the space between either via and wide metal <= 0.5um (S, S is the shortest running path length from Via to the wide metal). (except via bar)
 // DRC flags each intersecting area ({bottom metal AND upper metal}) with single square Via within the branch check region
 wide_M2 = (WITH WIDTH M2 > 0.162-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 0.162-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 0.162-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M2_real = wide_M2 NOT OUTSIDE ((SIZE wide_M2 BY 0.5+GLOBAL_TOLERANCE) INTERACT V2)
 all_down_and_up = (M2 INTERACT wide_M2) AND M3
 dis_down_arm_wide_all = SIZE wide_M2_real BY 0.5+GLOBAL_TOLERANCE INSIDE OF M2 STEP 0.025
 dis_down_and_up = dis_down_arm_wide_all AND all_down_and_up
 dis_down_and_up_arm = (dis_down_and_up NOT wide_M2) AND M2
 dis_down_arm = (dis_down_arm_wide_all NOT wide_M2) AND M2
 // 
 dis_down_arm_good_a = dis_down_and_up_arm INTERACT 1XV2N >= 2
 dis_down_arm_good_b = dis_down_and_up_arm INTERACT RV2
 dis_down_arm_good_c = dis_down_and_up_arm INTERACT 2XV2N
 dis_down_arm_good = OR dis_down_arm_good_a dis_down_arm_good_b dis_down_arm_good_c
 dis_down_arm_bad = (dis_down_and_up_arm NOT dis_down_arm_good) INTERACT (all_down_and_up INTERACT 1XV2N == 1)
 // 
 dis_down_arm_err_stack = (dis_down_arm_bad AND dis_down_and_up_arm) INTERACT 1XV2N
 dis_down_arm_err = dis_down_arm INTERACT dis_down_arm_err_stack
 err1_met_down = (dis_down_arm_err INTERACT (1XV2N NOT OUTSIDE dis_down_arm_err)) NOT INTERACT (OR RV2 2XV2N)
 // 
 wide_M3 = (WITH WIDTH M3 > 0.162-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 0.162-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 0.162-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M3_real = wide_M3 NOT OUTSIDE ((SIZE wide_M3 BY 0.5+GLOBAL_TOLERANCE) INTERACT V2)
 all_up_and_down = (M3 INTERACT wide_M3) AND M2
 dis_up_arm_wide_all = SIZE wide_M3_real BY 0.5+GLOBAL_TOLERANCE INSIDE OF M3 STEP 0.025
 dis_up_and_down = dis_up_arm_wide_all AND all_up_and_down
 dis_up_and_down_arm = (dis_up_and_down NOT wide_M3) AND M3
 dis_up_arm = (dis_up_arm_wide_all NOT wide_M3) AND M3
 // 
 dis_up_arm_good_a = dis_up_and_down_arm INTERACT 1XV2N >= 2
 dis_up_arm_good_b = dis_up_and_down_arm INTERACT RV2
 dis_up_arm_good_c = dis_up_and_down_arm INTERACT 2XV2N
 dis_up_arm_good = OR dis_up_arm_good_a dis_up_arm_good_b dis_up_arm_good_c
 dis_up_arm_bad = (dis_up_and_down_arm NOT dis_up_arm_good) INTERACT (all_up_and_down INTERACT 1XV2N == 1)
 // 
 dis_up_arm_err_stack = (dis_up_arm_bad AND dis_up_and_down_arm) INTERACT 1XV2N
 dis_up_arm_err = dis_up_arm INTERACT dis_up_arm_err_stack
 err2_met_up = (dis_up_arm_err INTERACT (1XV2N NOT OUTSIDE dis_up_arm_err)) NOT INTERACT (OR RV2 2XV2N)
 err2_met_up NOT INTERACT Vy2_BAR
}
 
RVy2_R_5_M2 {
@ There should be at least two square Vy or one rectangular Vy in the intersection area of bottom metal and upper metal, when either wide metal Mxy or 1.25xMy length >= 0.272um and width >= 0.272um, the space between either via and wide metal <= 1um (S, S is the shortest running path length from Via to the wide metal). (except via bar)
 // DRC flags each intersecting area ({bottom metal AND upper metal}) with single square Via within the branch check region
 wide_M2 = (WITH WIDTH M2 > 0.272-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 0.272-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 0.272-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M2_real = wide_M2 NOT OUTSIDE ((SIZE wide_M2 BY 1+GLOBAL_TOLERANCE) INTERACT V2)
 all_down_and_up = (M2 INTERACT wide_M2) AND M3
 dis_down_arm_wide_all = SIZE wide_M2_real BY 1+GLOBAL_TOLERANCE INSIDE OF M2 STEP 0.025
 dis_down_and_up = dis_down_arm_wide_all AND all_down_and_up
 dis_down_and_up_arm = (dis_down_and_up NOT wide_M2) AND M2
 dis_down_arm = (dis_down_arm_wide_all NOT wide_M2) AND M2
 // 
 dis_down_arm_good_a = dis_down_and_up_arm INTERACT 1XV2N >= 2
 dis_down_arm_good_b = dis_down_and_up_arm INTERACT RV2
 dis_down_arm_good_c = dis_down_and_up_arm INTERACT 2XV2N
 dis_down_arm_good = OR dis_down_arm_good_a dis_down_arm_good_b dis_down_arm_good_c
 dis_down_arm_bad = (dis_down_and_up_arm NOT dis_down_arm_good) INTERACT (all_down_and_up INTERACT 1XV2N == 1)
 // 
 dis_down_arm_err_stack = (dis_down_arm_bad AND dis_down_and_up_arm) INTERACT 1XV2N
 dis_down_arm_err = dis_down_arm INTERACT dis_down_arm_err_stack
 err1_met_down = (dis_down_arm_err INTERACT (1XV2N NOT OUTSIDE dis_down_arm_err)) NOT INTERACT (OR RV2 2XV2N)
 // 
 wide_M3 = (WITH WIDTH M3 > 0.272-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 0.272-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 0.272-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M3_real = wide_M3 NOT OUTSIDE ((SIZE wide_M3 BY 1+GLOBAL_TOLERANCE) INTERACT V2)
 all_up_and_down = (M3 INTERACT wide_M3) AND M2
 dis_up_arm_wide_all = SIZE wide_M3_real BY 1+GLOBAL_TOLERANCE INSIDE OF M3 STEP 0.025
 dis_up_and_down = dis_up_arm_wide_all AND all_up_and_down
 dis_up_and_down_arm = (dis_up_and_down NOT wide_M3) AND M3
 dis_up_arm = (dis_up_arm_wide_all NOT wide_M3) AND M3
 // 
 dis_up_arm_good_a = dis_up_and_down_arm INTERACT 1XV2N >= 2
 dis_up_arm_good_b = dis_up_and_down_arm INTERACT RV2
 dis_up_arm_good_c = dis_up_and_down_arm INTERACT 2XV2N
 dis_up_arm_good = OR dis_up_arm_good_a dis_up_arm_good_b dis_up_arm_good_c
 dis_up_arm_bad = (dis_up_and_down_arm NOT dis_up_arm_good) INTERACT (all_up_and_down INTERACT 1XV2N == 1)
 // 
 dis_up_arm_err_stack = (dis_up_arm_bad AND dis_up_and_down_arm) INTERACT 1XV2N
 dis_up_arm_err = dis_up_arm INTERACT dis_up_arm_err_stack
 err2_met_up = (dis_up_arm_err INTERACT (1XV2N NOT OUTSIDE dis_up_arm_err)) NOT INTERACT (OR RV2 2XV2N)
 err1_met_down NOT INTERACT Vy2_BAR
}
 
RVy2_R_5_M3 {
@ There should be at least two square Vy or one rectangular Vy in the intersection area of bottom metal and upper metal, when either wide metal Mxy or 1.25xMy length >= 0.272um and width >= 0.272um, the space between either via and wide metal <= 1um (S, S is the shortest running path length from Via to the wide metal). (except via bar)
 // DRC flags each intersecting area ({bottom metal AND upper metal}) with single square Via within the branch check region
 wide_M2 = (WITH WIDTH M2 > 0.272-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 0.272-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 0.272-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M2_real = wide_M2 NOT OUTSIDE ((SIZE wide_M2 BY 1+GLOBAL_TOLERANCE) INTERACT V2)
 all_down_and_up = (M2 INTERACT wide_M2) AND M3
 dis_down_arm_wide_all = SIZE wide_M2_real BY 1+GLOBAL_TOLERANCE INSIDE OF M2 STEP 0.025
 dis_down_and_up = dis_down_arm_wide_all AND all_down_and_up
 dis_down_and_up_arm = (dis_down_and_up NOT wide_M2) AND M2
 dis_down_arm = (dis_down_arm_wide_all NOT wide_M2) AND M2
 // 
 dis_down_arm_good_a = dis_down_and_up_arm INTERACT 1XV2N >= 2
 dis_down_arm_good_b = dis_down_and_up_arm INTERACT RV2
 dis_down_arm_good_c = dis_down_and_up_arm INTERACT 2XV2N
 dis_down_arm_good = OR dis_down_arm_good_a dis_down_arm_good_b dis_down_arm_good_c
 dis_down_arm_bad = (dis_down_and_up_arm NOT dis_down_arm_good) INTERACT (all_down_and_up INTERACT 1XV2N == 1)
 // 
 dis_down_arm_err_stack = (dis_down_arm_bad AND dis_down_and_up_arm) INTERACT 1XV2N
 dis_down_arm_err = dis_down_arm INTERACT dis_down_arm_err_stack
 err1_met_down = (dis_down_arm_err INTERACT (1XV2N NOT OUTSIDE dis_down_arm_err)) NOT INTERACT (OR RV2 2XV2N)
 // 
 wide_M3 = (WITH WIDTH M3 > 0.272-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 0.272-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 0.272-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M3_real = wide_M3 NOT OUTSIDE ((SIZE wide_M3 BY 1+GLOBAL_TOLERANCE) INTERACT V2)
 all_up_and_down = (M3 INTERACT wide_M3) AND M2
 dis_up_arm_wide_all = SIZE wide_M3_real BY 1+GLOBAL_TOLERANCE INSIDE OF M3 STEP 0.025
 dis_up_and_down = dis_up_arm_wide_all AND all_up_and_down
 dis_up_and_down_arm = (dis_up_and_down NOT wide_M3) AND M3
 dis_up_arm = (dis_up_arm_wide_all NOT wide_M3) AND M3
 // 
 dis_up_arm_good_a = dis_up_and_down_arm INTERACT 1XV2N >= 2
 dis_up_arm_good_b = dis_up_and_down_arm INTERACT RV2
 dis_up_arm_good_c = dis_up_and_down_arm INTERACT 2XV2N
 dis_up_arm_good = OR dis_up_arm_good_a dis_up_arm_good_b dis_up_arm_good_c
 dis_up_arm_bad = (dis_up_and_down_arm NOT dis_up_arm_good) INTERACT (all_up_and_down INTERACT 1XV2N == 1)
 // 
 dis_up_arm_err_stack = (dis_up_arm_bad AND dis_up_and_down_arm) INTERACT 1XV2N
 dis_up_arm_err = dis_up_arm INTERACT dis_up_arm_err_stack
 err2_met_up = (dis_up_arm_err INTERACT (1XV2N NOT OUTSIDE dis_up_arm_err)) NOT INTERACT (OR RV2 2XV2N)
 err2_met_up NOT INTERACT Vy2_BAR
}
 
RVy2_R_6_M2 {
@ There should be at least two square Vy or one rectangular Vy in the intersection area of bottom metal and upper metal, when either wide metal Mxy or 1.25xMy width and length >= 0.542um, the space between either via and wide metal <= 3um (S, S is the shortest running path length from Via to the wide metal). (except via bar)
 // DRC flags each intersecting area ({bottom metal AND upper metal}) with single square Via within the branch check region
 wide_M2 = (WITH WIDTH M2 > 0.542-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 0.542-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 0.542-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M2_real = wide_M2 NOT OUTSIDE ((SIZE wide_M2 BY 3+GLOBAL_TOLERANCE) INTERACT V2)
 all_down_and_up = (M2 INTERACT wide_M2) AND M3
 dis_down_arm_wide_all = SIZE wide_M2_real BY 3+GLOBAL_TOLERANCE INSIDE OF M2 STEP 0.025
 dis_down_and_up = dis_down_arm_wide_all AND all_down_and_up
 dis_down_and_up_arm = (dis_down_and_up NOT wide_M2) AND M2
 dis_down_arm = (dis_down_arm_wide_all NOT wide_M2) AND M2
 // 
 dis_down_arm_good_a = dis_down_and_up_arm INTERACT 1XV2N >= 2
 dis_down_arm_good_b = dis_down_and_up_arm INTERACT RV2
 dis_down_arm_good_c = dis_down_and_up_arm INTERACT 2XV2N
 dis_down_arm_good = OR dis_down_arm_good_a dis_down_arm_good_b dis_down_arm_good_c
 dis_down_arm_bad = (dis_down_and_up_arm NOT dis_down_arm_good) INTERACT (all_down_and_up INTERACT 1XV2N == 1)
 // 
 dis_down_arm_err_stack = (dis_down_arm_bad AND dis_down_and_up_arm) INTERACT 1XV2N
 dis_down_arm_err = dis_down_arm INTERACT dis_down_arm_err_stack
 err1_met_down = (dis_down_arm_err INTERACT (1XV2N NOT OUTSIDE dis_down_arm_err)) NOT INTERACT (OR RV2 2XV2N)
 // 
 wide_M3 = (WITH WIDTH M3 > 0.542-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 0.542-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 0.542-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M3_real = wide_M3 NOT OUTSIDE ((SIZE wide_M3 BY 3+GLOBAL_TOLERANCE) INTERACT V2)
 all_up_and_down = (M3 INTERACT wide_M3) AND M2
 dis_up_arm_wide_all = SIZE wide_M3_real BY 3+GLOBAL_TOLERANCE INSIDE OF M3 STEP 0.025
 dis_up_and_down = dis_up_arm_wide_all AND all_up_and_down
 dis_up_and_down_arm = (dis_up_and_down NOT wide_M3) AND M3
 dis_up_arm = (dis_up_arm_wide_all NOT wide_M3) AND M3
 // 
 dis_up_arm_good_a = dis_up_and_down_arm INTERACT 1XV2N >= 2
 dis_up_arm_good_b = dis_up_and_down_arm INTERACT RV2
 dis_up_arm_good_c = dis_up_and_down_arm INTERACT 2XV2N
 dis_up_arm_good = OR dis_up_arm_good_a dis_up_arm_good_b dis_up_arm_good_c
 dis_up_arm_bad = (dis_up_and_down_arm NOT dis_up_arm_good) INTERACT (all_up_and_down INTERACT 1XV2N == 1)
 // 
 dis_up_arm_err_stack = (dis_up_arm_bad AND dis_up_and_down_arm) INTERACT 1XV2N
 dis_up_arm_err = dis_up_arm INTERACT dis_up_arm_err_stack
 err2_met_up = (dis_up_arm_err INTERACT (1XV2N NOT OUTSIDE dis_up_arm_err)) NOT INTERACT (OR RV2 2XV2N)
 err1_met_down NOT INTERACT Vy2_BAR
}
 
RVy2_R_6_M3 {
@ There should be at least two square Vy or one rectangular Vy in the intersection area of bottom metal and upper metal, when either wide metal Mxy or 1.25xMy width and length >= 0.542um, the space between either via and wide metal <= 3um (S, S is the shortest running path length from Via to the wide metal). (except via bar)
 // DRC flags each intersecting area ({bottom metal AND upper metal}) with single square Via within the branch check region
 wide_M2 = (WITH WIDTH M2 > 0.542-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 0.542-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 0.542-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M2_real = wide_M2 NOT OUTSIDE ((SIZE wide_M2 BY 3+GLOBAL_TOLERANCE) INTERACT V2)
 all_down_and_up = (M2 INTERACT wide_M2) AND M3
 dis_down_arm_wide_all = SIZE wide_M2_real BY 3+GLOBAL_TOLERANCE INSIDE OF M2 STEP 0.025
 dis_down_and_up = dis_down_arm_wide_all AND all_down_and_up
 dis_down_and_up_arm = (dis_down_and_up NOT wide_M2) AND M2
 dis_down_arm = (dis_down_arm_wide_all NOT wide_M2) AND M2
 // 
 dis_down_arm_good_a = dis_down_and_up_arm INTERACT 1XV2N >= 2
 dis_down_arm_good_b = dis_down_and_up_arm INTERACT RV2
 dis_down_arm_good_c = dis_down_and_up_arm INTERACT 2XV2N
 dis_down_arm_good = OR dis_down_arm_good_a dis_down_arm_good_b dis_down_arm_good_c
 dis_down_arm_bad = (dis_down_and_up_arm NOT dis_down_arm_good) INTERACT (all_down_and_up INTERACT 1XV2N == 1)
 // 
 dis_down_arm_err_stack = (dis_down_arm_bad AND dis_down_and_up_arm) INTERACT 1XV2N
 dis_down_arm_err = dis_down_arm INTERACT dis_down_arm_err_stack
 err1_met_down = (dis_down_arm_err INTERACT (1XV2N NOT OUTSIDE dis_down_arm_err)) NOT INTERACT (OR RV2 2XV2N)
 // 
 wide_M3 = (WITH WIDTH M3 > 0.542-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 0.542-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 0.542-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M3_real = wide_M3 NOT OUTSIDE ((SIZE wide_M3 BY 3+GLOBAL_TOLERANCE) INTERACT V2)
 all_up_and_down = (M3 INTERACT wide_M3) AND M2
 dis_up_arm_wide_all = SIZE wide_M3_real BY 3+GLOBAL_TOLERANCE INSIDE OF M3 STEP 0.025
 dis_up_and_down = dis_up_arm_wide_all AND all_up_and_down
 dis_up_and_down_arm = (dis_up_and_down NOT wide_M3) AND M3
 dis_up_arm = (dis_up_arm_wide_all NOT wide_M3) AND M3
 // 
 dis_up_arm_good_a = dis_up_and_down_arm INTERACT 1XV2N >= 2
 dis_up_arm_good_b = dis_up_and_down_arm INTERACT RV2
 dis_up_arm_good_c = dis_up_and_down_arm INTERACT 2XV2N
 dis_up_arm_good = OR dis_up_arm_good_a dis_up_arm_good_b dis_up_arm_good_c
 dis_up_arm_bad = (dis_up_and_down_arm NOT dis_up_arm_good) INTERACT (all_up_and_down INTERACT 1XV2N == 1)
 // 
 dis_up_arm_err_stack = (dis_up_arm_bad AND dis_up_and_down_arm) INTERACT 1XV2N
 dis_up_arm_err = dis_up_arm INTERACT dis_up_arm_err_stack
 err2_met_up = (dis_up_arm_err INTERACT (1XV2N NOT OUTSIDE dis_up_arm_err)) NOT INTERACT (OR RV2 2XV2N)
 err2_met_up NOT INTERACT Vy2_BAR
}
 
RVy2_R_7_M2 {
@ There should be at least two square Vy or one rectangular Vy in the intersection area of bottom metal and upper metal, when either wide metal Mxy or 1.25xMy width and length >= 1.01um, the space between either via and wide metal <= 5um (S, S is the shortest running path length from Via to the wide metal). (except via bar)
 // DRC flags each intersecting area ({bottom metal AND upper metal}) with single square Via within the branch check region
 wide_M2 = (WITH WIDTH M2 > 1.01-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 1.01-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 1.01-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M2_real = wide_M2 NOT OUTSIDE ((SIZE wide_M2 BY 5+GLOBAL_TOLERANCE) INTERACT V2)
 all_down_and_up = (M2 INTERACT wide_M2) AND M3
 dis_down_arm_wide_all = SIZE wide_M2_real BY 5+GLOBAL_TOLERANCE INSIDE OF M2 STEP 0.025
 dis_down_and_up = dis_down_arm_wide_all AND all_down_and_up
 dis_down_and_up_arm = (dis_down_and_up NOT wide_M2) AND M2
 dis_down_arm = (dis_down_arm_wide_all NOT wide_M2) AND M2
 // 
 dis_down_arm_good_a = dis_down_and_up_arm INTERACT 1XV2N >= 2
 dis_down_arm_good_b = dis_down_and_up_arm INTERACT RV2
 dis_down_arm_good_c = dis_down_and_up_arm INTERACT 2XV2N
 dis_down_arm_good = OR dis_down_arm_good_a dis_down_arm_good_b dis_down_arm_good_c
 dis_down_arm_bad = (dis_down_and_up_arm NOT dis_down_arm_good) INTERACT (all_down_and_up INTERACT 1XV2N == 1)
 // 
 dis_down_arm_err_stack = (dis_down_arm_bad AND dis_down_and_up_arm) INTERACT 1XV2N
 dis_down_arm_err = dis_down_arm INTERACT dis_down_arm_err_stack
 err1_met_down = (dis_down_arm_err INTERACT (1XV2N NOT OUTSIDE dis_down_arm_err)) NOT INTERACT (OR RV2 2XV2N)
 // 
 wide_M3 = (WITH WIDTH M3 > 1.01-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 1.01-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 1.01-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M3_real = wide_M3 NOT OUTSIDE ((SIZE wide_M3 BY 5+GLOBAL_TOLERANCE) INTERACT V2)
 all_up_and_down = (M3 INTERACT wide_M3) AND M2
 dis_up_arm_wide_all = SIZE wide_M3_real BY 5+GLOBAL_TOLERANCE INSIDE OF M3 STEP 0.025
 dis_up_and_down = dis_up_arm_wide_all AND all_up_and_down
 dis_up_and_down_arm = (dis_up_and_down NOT wide_M3) AND M3
 dis_up_arm = (dis_up_arm_wide_all NOT wide_M3) AND M3
 // 
 dis_up_arm_good_a = dis_up_and_down_arm INTERACT 1XV2N >= 2
 dis_up_arm_good_b = dis_up_and_down_arm INTERACT RV2
 dis_up_arm_good_c = dis_up_and_down_arm INTERACT 2XV2N
 dis_up_arm_good = OR dis_up_arm_good_a dis_up_arm_good_b dis_up_arm_good_c
 dis_up_arm_bad = (dis_up_and_down_arm NOT dis_up_arm_good) INTERACT (all_up_and_down INTERACT 1XV2N == 1)
 // 
 dis_up_arm_err_stack = (dis_up_arm_bad AND dis_up_and_down_arm) INTERACT 1XV2N
 dis_up_arm_err = dis_up_arm INTERACT dis_up_arm_err_stack
 err2_met_up = (dis_up_arm_err INTERACT (1XV2N NOT OUTSIDE dis_up_arm_err)) NOT INTERACT (OR RV2 2XV2N)
 err1_met_down NOT INTERACT Vy2_BAR
}
 
RVy2_R_7_M3 {
@ There should be at least two square Vy or one rectangular Vy in the intersection area of bottom metal and upper metal, when either wide metal Mxy or 1.25xMy width and length >= 1.01um, the space between either via and wide metal <= 5um (S, S is the shortest running path length from Via to the wide metal). (except via bar)
 // DRC flags each intersecting area ({bottom metal AND upper metal}) with single square Via within the branch check region
 wide_M2 = (WITH WIDTH M2 > 1.01-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 1.01-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 1.01-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M2_real = wide_M2 NOT OUTSIDE ((SIZE wide_M2 BY 5+GLOBAL_TOLERANCE) INTERACT V2)
 all_down_and_up = (M2 INTERACT wide_M2) AND M3
 dis_down_arm_wide_all = SIZE wide_M2_real BY 5+GLOBAL_TOLERANCE INSIDE OF M2 STEP 0.025
 dis_down_and_up = dis_down_arm_wide_all AND all_down_and_up
 dis_down_and_up_arm = (dis_down_and_up NOT wide_M2) AND M2
 dis_down_arm = (dis_down_arm_wide_all NOT wide_M2) AND M2
 // 
 dis_down_arm_good_a = dis_down_and_up_arm INTERACT 1XV2N >= 2
 dis_down_arm_good_b = dis_down_and_up_arm INTERACT RV2
 dis_down_arm_good_c = dis_down_and_up_arm INTERACT 2XV2N
 dis_down_arm_good = OR dis_down_arm_good_a dis_down_arm_good_b dis_down_arm_good_c
 dis_down_arm_bad = (dis_down_and_up_arm NOT dis_down_arm_good) INTERACT (all_down_and_up INTERACT 1XV2N == 1)
 // 
 dis_down_arm_err_stack = (dis_down_arm_bad AND dis_down_and_up_arm) INTERACT 1XV2N
 dis_down_arm_err = dis_down_arm INTERACT dis_down_arm_err_stack
 err1_met_down = (dis_down_arm_err INTERACT (1XV2N NOT OUTSIDE dis_down_arm_err)) NOT INTERACT (OR RV2 2XV2N)
 // 
 wide_M3 = (WITH WIDTH M3 > 1.01-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 1.01-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 1.01-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M3_real = wide_M3 NOT OUTSIDE ((SIZE wide_M3 BY 5+GLOBAL_TOLERANCE) INTERACT V2)
 all_up_and_down = (M3 INTERACT wide_M3) AND M2
 dis_up_arm_wide_all = SIZE wide_M3_real BY 5+GLOBAL_TOLERANCE INSIDE OF M3 STEP 0.025
 dis_up_and_down = dis_up_arm_wide_all AND all_up_and_down
 dis_up_and_down_arm = (dis_up_and_down NOT wide_M3) AND M3
 dis_up_arm = (dis_up_arm_wide_all NOT wide_M3) AND M3
 // 
 dis_up_arm_good_a = dis_up_and_down_arm INTERACT 1XV2N >= 2
 dis_up_arm_good_b = dis_up_and_down_arm INTERACT RV2
 dis_up_arm_good_c = dis_up_and_down_arm INTERACT 2XV2N
 dis_up_arm_good = OR dis_up_arm_good_a dis_up_arm_good_b dis_up_arm_good_c
 dis_up_arm_bad = (dis_up_and_down_arm NOT dis_up_arm_good) INTERACT (all_up_and_down INTERACT 1XV2N == 1)
 // 
 dis_up_arm_err_stack = (dis_up_arm_bad AND dis_up_and_down_arm) INTERACT 1XV2N
 dis_up_arm_err = dis_up_arm INTERACT dis_up_arm_err_stack
 err2_met_up = (dis_up_arm_err INTERACT (1XV2N NOT OUTSIDE dis_up_arm_err)) NOT INTERACT (OR RV2 2XV2N)
 err2_met_up NOT INTERACT Vy2_BAR
}

// =======================================================
// Rectangular Vy design rule
// =======================================================

GROUP GRVy3 RVy3_?
 
RVy3_W_1_L_1 {
@ RVy.W.1: Rectangular Vy (RVy) width, except square Vy, MARKS, MARKG, INDMY, LOGO regions = 0.032um
@ RVy.L.1: Length of RVy (width = 0.032um) = 0.080um
 err1 = (V3 NOT 1XV3N) NOT RV3
 err1 NOT INSIDE MARKS_MARKG_INDMY_LOGO
}
 
RVy3_L_2 {
@ Length of Vy bar (width = 0.1/0.45um) >= 0.9um
 CHECK_VIA = V3 NOT OUTSIDE (OR MARKS MARKG)
 CHECK_EDG = (INT [CHECK_VIA] == 0.1 ABUT<90 OPPOSITE EXCLUDE SHIELDED) OR EDGE (INT [CHECK_VIA] == 0.45 ABUT<90 OPPOSITE EXCLUDE SHIELDED)
 err1 = LENGTH CHECK_EDG < 0.90
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
RVy3_S_1 {
@ Space between RVy and (Vy-1 or RVy-1) (including V0 and RV0) at different net and PRL > 0um, when Mxy+1/1.25xMy enclosure of RVy > 0um. >= 0.037um
 chk_via = (V3 INTERACT RV3) NOT COIN EDGE M4
 err1 = EXT chk_via V2 < 0.037 ABUT<90 OPPOSITE REGION NOT CONNECTED
 err1 NOT INSIDE SealR_NOT_BULK
}
 
RVy3_S_1a {
@ Space between RVy >= 0.082um
 err1 = EXT RV3 < 0.082 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
RVy3_S_2 {
@ Space between RVy and Mxy (including M1) at different net >= 0.037um
@ When:
@ 1. Mxy (including M1) enclosure of RVy < 0.003um
@ 2. Mxy+1/1.25xMy width > 0.038um
 y1 = V3 AND (RV3 NOT OUTSIDE (M4 WITH WIDTH > 0.038))
 y2 = EXT [y1] M3 < 0.037 ABUT<90 MEASURE ALL NOT CONNECTED
 y3 = ENC [y2] M3 < 0.003 ABUT<90 OPPOSITE
 err1 = EXT (y1 COIN EDGE y3) M3 < 0.037 ABUT<90 MEASURE ALL NOT CONNECTED REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
RVy3_S_3 {
 //;GATE poly direction
@ Space between two RVy with PRL > -0.09um. >= 0.099um
@ When:
@ 1. RVy enclosure by 1.25xMy < 0.01um at opposite side
@ 2. Space between RVy and 1.25xMy <= 0.052um with PRL >= -0.046um at opposite side
@ DRC doesn't flag RVy meet 1) and 2) condition on both sides
 ncp_axis = ANGLE (ENC [RV3] M4 < 0.01 ABUT<90 OPPOSITE) == 0
 y1 = ANGLE (RV3 TOUCH EDGE ncp_axis) == 0
 y2 = EXT [y1] M4 <= 0.052 ABUT<90 OPPOSITE EXTENDED 0.046+GLOBAL_TOLERANCE MEASURE ALL
 y3 = RV3 TOUCH EDGE y2
 y4 = INT [RV3] y3 <= 0.032 ABUT<90 OPPOSITE
 err1 = EXT (y4 NOT TOUCH EDGE y2) V3_SR < 0.099 ABUT<90 OPPOSITE EXTENDED 0.09 REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
RVy3_S_4 {
@ Space between the short side of RVy and Vy when PRL > -0.032um. >= 0.108um
 err1 = EXT RV3_W V3_SR < 0.108 ABUT<90 OPPOSITE EXTENDED 0.032 REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
RVy3_S_5 {
@ Space between the long side of RVy (PRL > 0um, with one Mxy+1/1.25xMy in between) >= 0.115um
 ERRS_AREA = EXT RV3_L < 0.115 ABUT<90 OPPOSITE REGION
 // Also check 072 Line to 080 Line
 ERRS_EDGE = EXT [RV3_L] < 0.115 ABUT<90 OPPOSITE
 ERRS_EDGE_EXP = EXPAND EDGE ERRS_EDGE INSIDE BY 0.001
 ERRS_BULK_MET = (ERRS_AREA OR ERRS_EDGE_EXP) AND M4
 err1_TMP = (ERRS_AREA OR ERRS_EDGE_EXP) INTERACT ERRS_BULK_MET >= 3
 err1 = ERRS_AREA AND err1_TMP
 err1 NOT INSIDE SealR_NOT_BULK
}
 

#IFDEF DFM_RULES_PRIORITY_1 YES

RVy3_EN_1_DFM1 {
@ Recommended RVy enclosure by M1/Mxy is defined by either RVy.EN.2.DFM or RVy.EN.2a.DFM
 err1 = RV3 NOT INSIDE M3
 err1 NOT INSIDE SealR_NOT_BULK
}
 
//;beginning of the RVy.EN.2.DFM derivations
via_RVy_3_2_R_bad = RECTANGLE ENCLOSURE RV3 M3 ABUT<90 SINGULAR OUTSIDE ALSO 
GOOD 0.007 0.025 OPPOSITE 0.007 0.025 OPPOSITE
via_RVy_3_2_R_good = RV3 NOT via_RVy_3_2_R_bad
//;end of the RVy.EN.2.DFM derivations
 
RVy3_EN_2_DFM1 {
@ Recommended RVy enclosure by M1/Mxy for two opposite sides with the other twosides >= 0.007um. >= 0.025um
 err1 = via_RVy_3_2_R_bad NOT via_RVy_3_2a_R_good
 err1 NOT INSIDE SealR_NOT_BULK
}
 
//;beginning of the RVy.EN.2a.DFM derivations
via_RVy_3_2a_R_bad = RECTANGLE ENCLOSURE RV3 M3 ABUT<90 SINGULAR OUTSIDE ALSO 
GOOD 0.020 0.020 0.020 0.020 OPPOSITE
via_RVy_3_2a_R_good = RV3 NOT via_RVy_3_2a_R_bad
//;end of the RVy.EN.2a.DFM derivations
 
RVy3_EN_2a_DFM1 {
@ Recommended RVy enclosure by M1, Mxy for all sides >= 0.02um
 err1 = via_RVy_3_2a_R_bad NOT via_RVy_3_2_R_good
 err2 = (ENC [RV3] M3 < 0.02 ABUT<90 SINGULAR) NOT TOUCH EDGE via_RVy_3_2_R_good
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE EDGE SealR_NOT_BULK
}

#ENDIF

 
RVy3_EN_1 {
@ RVy must be fully enclosed by M1/Mxy where M1/Mxy is the metal layer directly underneath RVy
@ Enclosure by M1/Mxy must follow either RVy.EN.2, RVy.EN.2a or RVy.EN.3
 err1 = RV3 NOT M3
 err1 NOT INSIDE SealR_NOT_BULK
}
 
//;beginning of the RVy.EN.2a derivations
via_RVy_3_2a_bad = RECTANGLE ENCLOSURE RV3 M3 ABUT<90 SINGULAR OUTSIDE ALSO 
GOOD 0.015 0.015 0.015 0.015 OPPOSITE
via_RVy_3_2a_good = RV3 NOT via_RVy_3_2a_bad
//;end of the RVy.EN.2a derivations
 
//;beginning of the RVy.EN.2/3 derivations
via_RVy_3_2_3_bad = RECTANGLE ENCLOSURE RV3 M3 ABUT<90 SINGULAR OUTSIDE ALSO 
GOOD 0 0.024 OPPOSITE 0 0.024 OPPOSITE 
GOOD 0.007 0.019 OPPOSITE 0.007 0.019 OPPOSITE
via_RVy_3_2_3_good = RV3 NOT via_RVy_3_2_3_bad
//;end of the RVy.EN.2/3 derivations
 
RVy3_EN_2a {
@ RVy enclosure by M1 or Mxy for all sides >= 0.015um
 err1 = via_RVy_3_2a_bad NOT via_RVy_3_2_3_good
 err2 = (ENC [RV3] M3 < 0.015 ABUT<90 SINGULAR) NOT TOUCH EDGE via_RVy_3_2_3_good
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE EDGE SealR_NOT_BULK
}
 
RVy3_EN_2_3 {
@ Rvy.EN.2: RVy enclosure by M1 or Mxy when enclosure on either perpendicular direction >= 0um. >= 0.024um
@ RVy.EN.3: RVy enclosure by M1 or Mxy for two opposite sides with the other two sides >= 0.007um. >= 0.019um
 err1 = via_RVy_3_2_3_bad NOT via_RVy_3_2a_good
 err1 NOT INSIDE SealR_NOT_BULK
 // 
 RVy_chk_W_sides = ENC [RV3_W] M3 < 0.007 ABUT<90 OPPOSITE
 RVy_chk_L_sides = ENC (RV3_L) M3 < 0.024 ABUT<90 OPPOSITE
 err2 = ((RV3 INSIDE M3) WITH EDGE RVy_chk_W_sides) WITH EDGE RVy_chk_L_sides == 2
 err2 NOT INSIDE SealR_NOT_BULK
}
 
RVy3_EN_4 {
@ RVy enclosure by Mxy in adjacent S1 side, where Mxy is the metal layer directly underneath RVy >= 0.004um
@ When:
@ 1) Mxy width W: 0.036um <= W <= 0.041um
@ 2) Space: 0.058um <= S1 < 0.063um, the PRL >= 0.083um
@ 3) The opposite space S2 >= 0.069um
 met_wid_all = M3 WITH WIDTH > 0.036-GLOBAL_TOLERANCE <= 0.041
 met_err_RAW_a = EXT [met_wid_all] M3 >= 0.058 < 0.063 ABUT<90 OPPOSITE MEASURE ALL
 met_err_RAW_b = EXT met_wid_all M3 >= 0.058 < 0.063 ABUT<90 OPPOSITE MEASURE ALL
 met_err_RAW_c = EXT met_wid_all [M3] >= 0.058 < 0.063 ABUT<90 OPPOSITE MEASURE ALL
 met_err_PRL = DFM PROPERTY met_err_RAW_b met_err_RAW_c OVERLAP ABUT ALSO MULTI [-= max(LENGTH(met_err_RAW_c))] >= 0.083
 // 
 met_err_EGE_a = met_err_RAW_a COIN EDGE (DFM COPY met_err_PRL EDGE)
 met_err_EGE_b = ENC RV3 [met_err_EGE_a] < 0.004 ABUT<90 OPPOSITE
 met_err_EGE_c = INT met_err_EGE_b [M3] > 0.036-GLOBAL_TOLERANCE <= 0.041 ABUT<90 OPPOSITE MEASURE COIN
 met_err_EGE_d = EXT (met_err_EGE_c) M3 < 0.069 ABUT<90 OPPOSITE
 met_err_EGE_e = met_err_EGE_b COIN EDGE M3
 err1 = INT met_err_EGE_d [met_err_EGE_e] > 0.036-GLOBAL_TOLERANCE <= 0.041 ABUT<90 OPPOSITE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
RVy3_EN_5 {
@ RVy enclosure by Mxy in adjacent S1 side, where Mxy is the metal layer directly underneath RVy >= 0.004um
@ When:
@ 1) Mxy width W: 0.042um <= W <= 0.05um
@ 2) Space: 0.058um <= S1 <= 0.067um, the PRL >= 0.083um
 met_wid_all = M3 WITH WIDTH > 0.042-GLOBAL_TOLERANCE <= 0.05
 met_err_RAW_TMP = EXT met_wid_all [M3] >= 0.058 < 0.067+GLOBAL_TOLERANCE ABUT<90 OPPOSITE MEASURE ALL
 met_err_RAW = EXT met_err_RAW_TMP [M3] >= 0.058 < 0.067+GLOBAL_TOLERANCE ABUT<90 OPPOSITE
 // 
 met_jog_ALL = M3_convex_eq_one_edges NOT COIN EDGE met_err_RAW
 met_jog_EXP_a = EXPAND EDGE met_jog_ALL INSIDE BY 0.0005
 met_jog_EXP_b = EXPAND EDGE met_jog_ALL OUTSIDE BY 0.0005
 met_jog_TMP = (met_jog_ALL COIN EDGE (met_jog_EXP_a WITH EDGE met_err_RAW)) COIN EDGE (met_jog_EXP_b WITH EDGE met_err_RAW)
 met_jog_EXP = ((VERTEX (EXPAND EDGE met_jog_TMP OUTSIDE BY 0.001 EXTEND BY 0.001) == 4) OR (EXPAND EDGE met_err_RAW OUTSIDE BY 0.001)) NOT M3
 // 
 met_err_PRL = DFM PROPERTY met_jog_EXP met_err_RAW met_wid_all OVERLAP ABUT ALSO MULTI [-= LENGTH(met_err_RAW)] >= 0.083 [+= COUNT(met_wid_all)] > 0
 met_err_EGE = M3 COIN EDGE (met_err_RAW COIN EDGE (met_err_PRL COIN EDGE met_wid_all))
 err1 = ENC [RV3] met_err_EGE < 0.004 ABUT<90 OPPOSITE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
RVy3_EN_6a {
@ RVy enclosure by Mxy in adjacent S1 side, where Mxy is the metal layer directly underneath RVy >= 0.004um
@ When:
@ 1) Mxy width W: 0.051um <= W <= 0.112um
@ 2) Space: 0.058um <= S1 <= 0.094um, PRL >= 0.083um
@ DRC doesn't check RVy:
@ a) Two RVys with space <= 0.1um in M1 and 1.25xMy/Mxy intersection region
@ b) One Vy and one RVy with space <= 0.1um in M1 and 1.25xMy/Mxy intersection region
 met_wid_all = M3 WITH WIDTH > 0.051-GLOBAL_TOLERANCE <= 0.112
 met_err_RAW_TMP = EXT met_wid_all [M3] >= 0.058 < 0.094+GLOBAL_TOLERANCE ABUT<90 OPPOSITE MEASURE ALL
 met_err_RAW = EXT met_err_RAW_TMP [M3] >= 0.058 < 0.094+GLOBAL_TOLERANCE ABUT<90 OPPOSITE
 // 
 met_jog_ALL = M3_convex_eq_one_edges NOT COIN EDGE met_err_RAW
 met_jog_EXP_a = EXPAND EDGE met_jog_ALL INSIDE BY 0.0005
 met_jog_EXP_b = EXPAND EDGE met_jog_ALL OUTSIDE BY 0.0005
 met_jog_TMP = (met_jog_ALL COIN EDGE (met_jog_EXP_a WITH EDGE met_err_RAW)) COIN EDGE (met_jog_EXP_b WITH EDGE met_err_RAW)
 met_jog_EXP = ((VERTEX (EXPAND EDGE met_jog_TMP OUTSIDE BY 0.001 EXTEND BY 0.001) == 4) OR (EXPAND EDGE met_err_RAW OUTSIDE BY 0.001)) NOT M3
 // 
 met_err_PRL = DFM PROPERTY met_jog_EXP met_err_RAW met_wid_all OVERLAP ABUT ALSO MULTI [-= LENGTH(met_err_RAW)] >= 0.083 [+= COUNT(met_wid_all)] > 0
 met_err_EGE = M3 COIN EDGE (met_err_RAW COIN EDGE (met_err_PRL COIN EDGE met_wid_all))
 via_group_all = SIZE V3 BY 0.05 INSIDE OF (M3 AND M4) STEP 0.02
 via_group_real = V3 INTERACT (via_group_all INTERACT V3 >= 2)
 err1 = ENC (RV3 NOT via_group_real) met_err_EGE < 0.004 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
RVy3_EN_7 {
@ RVy enclosure by Mxy in adjacent S1 side, where Mxy is the metal layer directly underneath RVy >= 0.004um
@ When:
@ 1) Mxy dimension along enclosure direction: 0.113um <= L <= 0.201um
@ 2) Space: 0.058um <= S1 <= 0.094um, the PRL >= 0.083um
 met_wid_all = INT [M3] > 0.113-GLOBAL_TOLERANCE <= 0.201 ABUT<90 OPPOSITE EXCLUDE SHIELDED
 met_err_RAW = EXT [met_wid_all] M3 >= 0.058 < 0.094+GLOBAL_TOLERANCE ABUT<90 OPPOSITE
 met_jog_ALL = M3_convex_eq_one_edges NOT COIN EDGE met_err_RAW
 met_jog_EXP_a = EXPAND EDGE met_jog_ALL INSIDE BY 0.0005
 met_jog_EXP_b = EXPAND EDGE met_jog_ALL OUTSIDE BY 0.0005
 met_jog_TMP = (met_jog_ALL COIN EDGE (met_jog_EXP_a WITH EDGE met_err_RAW)) COIN EDGE (met_jog_EXP_b WITH EDGE met_err_RAW)
 met_jog_EXP = ((VERTEX (EXPAND EDGE met_jog_TMP OUTSIDE BY 0.001 EXTEND BY 0.001) == 4) OR (EXPAND EDGE met_err_RAW OUTSIDE BY 0.001)) NOT M3
 // 
 met_err_PRL = DFM PROPERTY met_jog_EXP met_err_RAW OVERLAP ABUT ALSO MULTI [-= LENGTH(met_err_RAW)] >= 0.083
 met_err_EGE = M3 COIN EDGE (met_err_RAW COIN EDGE met_err_PRL)
 err1 = ENC RV3 met_err_EGE < 0.004 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
RVy3_EN_8 {
@ RVy enclosure by Mxy in adjacent S1 side, where Mxy is the metal layer directly underneath RVy >= 0.014um
@ When:
@ 1) Mxy dimension along enclosure direction: L >= 0.202um
@ 2) Space: 0.058um <= S1 <= 0.094um, PRL >= 0.083um
 met_wid_all = INT (M3) <= 0.202-GLOBAL_TOLERANCE ABUT<90 OPPOSITE EXCLUDE SHIELDED
 met_err_RAW = EXT [met_wid_all] M3 >= 0.058 < 0.094+GLOBAL_TOLERANCE ABUT<90 OPPOSITE
 met_jog_ALL = M3_convex_eq_one_edges NOT COIN EDGE met_err_RAW
 met_jog_EXP_a = EXPAND EDGE met_jog_ALL INSIDE BY 0.0005
 met_jog_EXP_b = EXPAND EDGE met_jog_ALL OUTSIDE BY 0.0005
 met_jog_TMP = (met_jog_ALL COIN EDGE (met_jog_EXP_a WITH EDGE met_err_RAW)) COIN EDGE (met_jog_EXP_b WITH EDGE met_err_RAW)
 met_jog_EXP = ((VERTEX (EXPAND EDGE met_jog_TMP OUTSIDE BY 0.001 EXTEND BY 0.001) == 4) OR (EXPAND EDGE met_err_RAW OUTSIDE BY 0.001)) NOT M3
 // 
 met_err_PRL = DFM PROPERTY met_jog_EXP met_err_RAW OVERLAP ABUT ALSO MULTI [-= LENGTH(met_err_RAW)] >= 0.083
 met_err_EGE = M3 COIN EDGE (met_err_RAW COIN EDGE met_err_PRL)
 err1 = ENC RV3 met_err_EGE < 0.014 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 

#IFDEF DFM_RULES_PRIORITY_1 YES

RVy3_EN_9_DFM1 {
@ Recommended RVy fully enclosure by Mxy+1/1.25xMy is defined by either RVy.EN.9a.DFM or Vy.EN.9b.DFM, which Mxy+1/1.25xMy is the metal layer directly above rectangular RVy.
 err1 = RV3 NOT INSIDE M4
 err1 NOT INSIDE SealR_NOT_BULK
}
 
//;beginning of the RVy.EN.9a.DFM derivations
via_RVy_3_9a_R_bad = RECTANGLE ENCLOSURE RV3 M4 ABUT<90 SINGULAR OUTSIDE ALSO 
GOOD 0.020 0.020 0.020 0.020 OPPOSITE
via_RVy_3_9a_R_good = RV3 NOT via_RVy_3_9a_R_bad
//;end of the RVy.EN.9a.DFM derivations
 
RVy3_EN_9a_DFM1 {
@ Recommended RVy enclosure by Mxy+1/1.25xMy for all sides >= 0.020um
 err1 = via_RVy_3_9a_R_bad NOT via_RVy_3_9b_R_good
 err1 NOT INSIDE SealR_NOT_BULK
}
 
//;beginning of the RVy.EN.9b.DFM derivations
via_RVy_3_9b_R_bad = RECTANGLE ENCLOSURE RV3 M4 ABUT<90 SINGULAR OUTSIDE ALSO 
GOOD 0.007 0.025 OPPOSITE 0.007 0.025 OPPOSITE
via_RVy_3_9b_R_good = RV3 NOT via_RVy_3_9b_R_bad
//;end of the RVy.EN.9b.DFM derivations
 
RVy3_EN_9b_DFM1 {
@ Recommended RVy enclosure by Mxy+1/1.25xMy for two opposite sides with the other twosides >= 0.007um. >= 0.025um
 err1 = via_RVy_3_9b_R_bad NOT via_RVy_3_9a_R_good
 err2 = (ENC [RV3] M4 < 0.02 ABUT<90 SINGULAR) NOT TOUCH EDGE via_RVy_3_9b_R_good
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE EDGE SealR_NOT_BULK
}

#ENDIF

 
//;RVy.EN.9 only for Mxy+1 
//;beginning of the RVy.EN.9 derivations
via_RVy3_bad_9_1 = RECTANGLE ENCLOSURE RV3 M4 ABUT<90 SINGULAR 
GOOD 0.015 0.015 0.015 0.015 OPPOSITE
via_RVy3_good_9_1 = RV3 NOT via_RVy3_bad_9_1
// 
via_RVy3_good_9_2_TMP = ENC [RV3_W] M4 < 0.024 ABUT<90 OPPOSITE
via_RVy3_good_9_2 = via_RVy3_bad_9_1 NOT WITH EDGE via_RVy3_good_9_2_TMP
// 
via_RVy3_bad_9_3 = RECTANGLE ENCLOSURE RV3 M4 ABUT<90 SINGULAR 
GOOD 0.007 0.019 OPPOSITE 0.007 0.019 OPPOSITE
via_RVy3_good_9_3 = RV3 NOT via_RVy3_bad_9_3
 
via_RVy3_9_bad = RV3 NOT (OR via_RVy3_good_9_1 via_RVy3_good_9_2 via_RVy3_good_9_3)
via_RVy3_9_good = RV3 NOT via_RVy3_9_bad
//;end of the RVy.EN.9 derivations
 
RVy3_EN_9 {
@ RVy must be fully enclosed by Mxy+1/1.25xMy where Mxy+1/1.25xMy is the metal layer directly above rectangular Vy
@ Enclosure by Mxy+1/1.25xMy must follow one of RVy.EN.9.1, RVy.EN.9.2, RVy.EN.9.3, RVy.EN.10 RVy.EN.10a1, RVy.EN.10a2, RVy.EN.10b or RVy.EN.11 or RVy.EN.12
 err1 = RV3 NOT M4
 err1 NOT INSIDE SealR_NOT_BULK
}
 
//;RVy.EN.10~RVy.EN.14 only for 125xMn+1/125xMy+1 
//;beginning of the RVy.EN.10 derivations
met_RVy3_10 = M4 WITH WIDTH == 0.04
via_RVy3_10 = RV3 NOT OUTSIDE met_RVy3_10
via_RVy3_10_bad = RECTANGLE ENCLOSURE via_RVy3_10 M4 ABUT<90 SINGULAR 
GOOD 0.004 0.038 OPPOSITE 0.004 0.038 OPPOSITE
via_RVy3_10_good = via_RVy3_10 NOT via_RVy3_10_bad
//;end of the RVy.EN.10 derivations
RVy3_EN_10 {
@ Enclosure of short side of RVy by 1.25xMy (width = 0.04um) with the other two sides >= 0.004um. >= 0.038um
 err1 = copy via_RVy3_10_bad
 err1 NOT INSIDE SealR_NOT_BULK
}
 
//;beginning of the RVy.EN.10a1 derivations
met_RVy3_10a1 = M4 WITH WIDTH == 0.042
via_RVy3_10a1 = RV3 NOT OUTSIDE met_RVy3_10a1
via_RVy3_10a1_bad = RECTANGLE ENCLOSURE via_RVy3_10a1 M4 ABUT<90 SINGULAR 
GOOD 0.005 0.038 OPPOSITE 0.005 0.038 OPPOSITE
via_RVy3_10a1_good = via_RVy3_10a1 NOT via_RVy3_10a1_bad
//;end of the RVy.EN.10a1 derivations
//;beginning of the RVy.EN.10a derivations
met_RVy3_10a = M4 WITH WIDTH == 0.044
via_RVy3_10a = RV3 NOT OUTSIDE met_RVy3_10a
via_RVy3_10a_bad = RECTANGLE ENCLOSURE via_RVy3_10a M4 ABUT<90 SINGULAR 
GOOD 0.006 0.038 OPPOSITE 0.006 0.038 OPPOSITE
via_RVy3_10a_good = via_RVy3_10a NOT via_RVy3_10a_bad
//;end of the RVy.EN.10a derivations
//;beginning of the RVy.EN.10a2 derivations
met_RVy3_10a2 = M4 WITH WIDTH == 0.046
via_RVy3_10a2 = RV3 NOT OUTSIDE met_RVy3_10a2
via_RVy3_10a2_bad = RECTANGLE ENCLOSURE via_RVy3_10a2 M4 ABUT<90 SINGULAR 
GOOD 0.007 0.038 OPPOSITE 0.007 0.038 OPPOSITE
via_RVy3_10a2_good = via_RVy3_10a2 NOT via_RVy3_10a2_bad
//;end of the RVy.EN.10a2 derivations
 
RVy3_EN_10a1 {
@ Enclosure of short side of RVy by 1.25xMy (width = 0.042um) with the other two sides >= 0.005um. >= 0.038um
 err1 = via_RVy3_10a1_bad NOT via_RVy3_10_good
 err1 NOT INSIDE SealR_NOT_BULK
}
 
RVy3_EN_10a {
@ Enclosure of short side of RVy by 1.25xMy (width = 0.044um) with the other two sides >= 0.006um. >= 0.038um
 err1 = via_RVy3_10a_bad NOT (OR via_RVy3_10_good via_RVy3_10a1_good)
 err1 NOT INSIDE SealR_NOT_BULK
}
 
RVy3_EN_10a2 {
@ Enclosure of short side of RVy by 1.25xMy (width = 0.046um) with the other two sides >= 0.007um. >= 0.038um
 err1 = via_RVy3_10a2_bad NOT (OR via_RVy3_10_good via_RVy3_10a1_good via_RVy3_10a_good)
 err1 NOT INSIDE SealR_NOT_BULK
}
 
//;beginning of the RVy.EN.10b derivations
met_RVy3_10b = M4 WITH WIDTH >= 0.060 < 0.08
via_RVy3_10b = RV3 NOT OUTSIDE met_RVy3_10b
via_RVy3_10b_bad = RECTANGLE ENCLOSURE via_RVy3_10b M4 ABUT<90 SINGULAR 
GOOD 0.014 0.038 OPPOSITE 0.014 0.038 OPPOSITE
via_RVy3_10b_good = via_RVy3_10b NOT via_RVy3_10b_bad
//;end of the RVy.EN.10b derivations
 
RVy3_EN_10b {
@ Enclosure of short side of RVy by 1.25xMy (0.06um <= width < 0.08um) with the other two sides >= 0.014um. >= 0.038um
 err1 = via_RVy3_10b_bad NOT (OR via_RVy3_10_good via_RVy3_10a_good via_RVy3_10a1_good via_RVy3_10a2_good)
 err1 NOT INSIDE SealR_NOT_BULK
}
 
//;beginning of the RVy.EN.11 derivations
met_RVy3_11 = M4 WITH WIDTH == 0.080
via_RVy3_11 = RV3 NOT OUTSIDE met_RVy3_11
via_RVy3_11_bad = RECTANGLE ENCLOSURE via_RVy3_11 M4 ABUT<90 SINGULAR 
GOOD 0.019 0.024 OPPOSITE 0.019 0.024 OPPOSITE
via_RVy3_11_good = via_RVy3_11 NOT via_RVy3_11_bad
//;end of the RVy.EN.11 derivations
via_RVy3_10_11_good = OR via_RVy3_10_good via_RVy3_10a_good via_RVy3_10a1_good via_RVy3_10a2_good via_RVy3_10b_good via_RVy3_11_good
 
RVy3_EN_11 {
@ Enclosure of short side of RVy by 1.25xMy (width = 0.08um) with the other two sides >= 0.024um. >= 0.019um
 err1 = via_RVy3_11_bad NOT (OR via_RVy3_10_good via_RVy3_10a_good via_RVy3_10a1_good via_RVy3_10a2_good via_RVy3_10b_good)
 err1 NOT INSIDE SealR_NOT_BULK
}
 
//;beginning of the RVy.EN.12 derivations
met_RVy3_12 = M4 WITH WIDTH > 0.080
via_RVy3_12_TMP = RV3 INTERACT met_RVy3_12
via_RVy3_12 = via_RVy3_12_TMP NOT via_RVy3_10_11_good
via_RVy3_12_bad1 = RECTANGLE ENCLOSURE via_RVy3_12 M4 ABUT<90 SINGULAR 
GOOD 0.019 OPPOSITE 0.030 OPPOSITE 0.019 OPPOSITE 0.030 OPPOSITE 
GOOD 0.024 OPPOSITE 0.029 OPPOSITE 0.024 OPPOSITE 0.029 OPPOSITE
 
via_RVy3_12_R_L = LENGTH via_RVy3_12 >= 0.072 <= 0.080
via_RVy3_12_R_W = LENGTH via_RVy3_12 >= 0.024 <= 0.032
via_RVy3_12_Z1 = ENC [via_RVy3_12_R_W] M4 < 0.029 ABUT<90 OPPOSITE EXTENDED 0.024 // include corner enclosure
via_RVy3_12_Z2 = ENC [via_RVy3_12_R_W] M4 < 0.019 ABUT<90 OPPOSITE EXTENDED 0.030 // include corner enclosure
via_RVy3_12_Z3 = ENC [via_RVy3_12_R_L] M4 < 0.024 ABUT<90 OPPOSITE
via_RVy3_12_Z4 = ENC [via_RVy3_12_R_L] M4 < 0.030 ABUT<90 OPPOSITE
via_RVy3_12_bad2 = (via_RVy3_12 WITH EDGE via_RVy3_12_Z1) WITH EDGE via_RVy3_12_Z4
via_RVy3_12_bad3 = (via_RVy3_12 NOT WITH EDGE via_RVy3_12_Z1) WITH EDGE via_RVy3_12_Z3
via_RVy3_12_good = via_RVy3_12 NOT (OR via_RVy3_12_bad1 via_RVy3_12_bad2 via_RVy3_12_bad3)
//;end of the RVy.EN.12 derivations
 
RVy3_EN_12 {
@ Enclosure of short side of RVy by 1.25xMy (width > 0.08um) with the other two sides >= 0.03/0.024um. >= 0.019/0.029um
 // 1.if W enclosure >= 0.019, then L enclosure >= 0.030
 // 2.if W enclosure >= 0.029, then L enclosure >= 0.024
 via_RVy3_12_bad1 NOT INSIDE SealR_NOT_BULK
 via_RVy3_12_bad2 NOT INSIDE SealR_NOT_BULK
 via_RVy3_12_bad3 NOT INSIDE SealR_NOT_BULK
}
 
RVy3_EN_13 {
@ RVy enclosure by 1.25xMy edge (between two consecutive 90-270 degree corners, length < 0.16um), when PRL > 0. >= 0.029um
 chk_edge = CONVEX EDGE M4 ANGLE1 == 90 ANGLE2 == 270 WITH LENGTH < 0.16
 err1_TMP = chk_edge TOUCH EDGE (EXT chk_edge M4_convex_270_90_edges < 0.005 ABUT==90 INTERSECTING ONLY REGION)
 err1 = ENC RV3 err1_TMP < 0.029 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
RVy3_EN_14 {
@ RVy enclosure by 1.25xMy for two opposite sides (PRL > 0) with the other side enclosure < 0.04um (corresponding edge length < 0.16um between two consecutive 90-270 degree corners) >= 0.04um
 correspond_EDG = CONVEX EDGE M4 ANGLE1 == 90 ANGLE2 == 270 WITH LENGTH < 0.16
 correspond_ENC = ENC [RV3] correspond_EDG < 0.04 ABUT<90 OPPOSITE EXTENDED 0.001
 correspond_VIA_ENC_EDGE = RV3 TOUCH EDGE correspond_ENC
 correspond_VIA_EDG_CORN = INT [RV3] correspond_VIA_ENC_EDGE < 0.001 ABUT==90 INTERSECTING ONLY
 correspond_VIA_EDG = RV3 TOUCH EDGE correspond_VIA_EDG_CORN
 err1_RAW = ENC [correspond_VIA_EDG] M4 < 0.040 ABUT<90 OPPOSITE EXTENDED 0.001
 err1_TMP = INT correspond_VIA_ENC_EDGE (correspond_VIA_EDG TOUCH EDGE err1_RAW) < 0.005 ABUT==90 INTERSECTING ONLY REGION
 err1 = EXPAND EDGE (RV3 TOUCH EDGE err1_TMP) INSIDE BY 0.001
 err1 NOT INSIDE SealR_NOT_BULK
}
 
RVy3_R_1 {
@ Single RVy is not allowed in H-shape Mxy+1/1.25xMy, when:
@ 1) The Mxy+1/1.25xMy has H-shape interacting with two metal holes: both two metal holes length <= 4.5um and two metal hole area <= 4.05um2
@ 2) The RVy overlaps on the center metal bar of this H-shape Mxy+1/1.25xMy
@ 3) The center metal bar length <= 0.9um and the metal bar width <= 0.12um
 // @ DRC doesn't check when one or more square 1xVn is also on H-shape Mxy+1/1.25xMy region
 hole_area_meet = AREA (HOLES M4 INNER) <= 4.05
 hole_area_meet_len = (hole_area_meet WITH EDGE (LENGTH hole_area_meet <= 0.9)) NOT WITH EDGE (LENGTH hole_area_meet > 4.5)
 hole_area_real = (hole_area_meet_len NOT ENCLOSE RECTANGLE 0.9+GLOBAL_TOLERANCE 4.5) NOT ENCLOSE RECTANGLE 0.9 4.5+GLOBAL_TOLERANCE
 hole_bars_len = M4 COIN EDGE hole_area_real
 // 
 hole_bars = INT hole_bars_len <= 0.12 ABUT<90 OPPOSITE REGION EXCLUDE SHIELDED
 hole_bars_real = hole_bars WITH EDGE (LENGTH hole_bars_len <= 0.9)
 hole_bars_vias_rect = RV3 INTERACT ((hole_bars_real INTERACT hole_area_real == 2) NOT ENCLOSE V3N >= 2)
 err1 = hole_bars_real INTERACT hole_bars_vias_rect == 1
 err1 NOT INSIDE SealR_NOT_BULK
}
 
RVy3_R_2 {
@ Redundant via requirement must be obeyed by one of following conditions of Vy numbers and space for Mxy and 1.25xMy connection
@ (One of Mxy or 1.25xMy has width and length >= 0.162um) (Except VIA bar)
@ 1) At least one rectangular Vy
@ 2) At least two square Vy with space <= 0.091um
@ 3) At least four square Vy with space <= 0.415um
 X1a = WITH WIDTH M3 > 0.162-GLOBAL_TOLERANCE <= 0.272-GLOBAL_TOLERANCE
 X1b = WITH WIDTH M4 > 0.162-GLOBAL_TOLERANCE <= 0.272-GLOBAL_TOLERANCE
 Y1a = WITH WIDTH M3 > 0.272-GLOBAL_TOLERANCE
 Y1b = WITH WIDTH M4 > 0.272-GLOBAL_TOLERANCE
 WIDE_1 = (X1a AND M4) ENCLOSE V3
 WIDE_2 = (M3 AND X1b) ENCLOSE V3
 WIDE_3 = (Y1a AND M4) ENCLOSE V3
 WIDE_4 = (M3 AND Y1b) ENCLOSE V3
 WIDE_all_raw = (WIDE_1 OR WIDE_2) NOT (WIDE_3 OR WIDE_4)
 WIDE_all = (M3 AND M4) NOT OUTSIDE WIDE_all_raw
 // 
 // condition 1 & 2
 Y1_good = WIDE_all_raw AND RV3
 Y2_good = WIDE_all_raw AND 2XV3N
 // 
 // condition 3
 Y3_wide_all = WIDE_all_raw NOT INTERACT (OR Y1_good Y2_good)
 Y3_wide = (WIDE_all INTERACT Y3_wide_all) INTERACT V3_SR >= 2
 Y3_comb_step = SIZE V3_SR BY 0.091/2 INSIDE OF Y3_wide STEP 0.020
 Y3_good_step = OR (Y3_comb_step INTERACT V3N >= 2) (Y3_comb_step INTERACT (OR RV3 2XV3N))
 Y3_good = WIDE_all_raw AND Y3_good_step
 // 
 // condition 4: 32nm*32nm via can be replaced by 2XVia/RVia
 Y4_wide_all = WIDE_all_raw NOT INTERACT (OR Y1_good Y2_good Y3_good)
 Y4_wide = (WIDE_all INTERACT Y4_wide_all) INTERACT V3_SR >= 2 // rectangle array 0.415/2 =0.207
 Y4_vias_input = V3_SR AND Y4_wide
 Y4_wide_chk_1 = Y4_wide INTERACT Y4_wide_all
 Y4_comb_step1 = SIZE Y4_vias_input BY 0.050 INSIDE OF Y4_wide_chk_1 STEP 0.020
 Y4_good_step1_a = OR (Y4_comb_step1 INTERACT V3N >= 4) ((Y4_comb_step1 INTERACT V3N >= 2) INTERACT (OR RV3 2XV3N)) // step1: 0.050
 Y4_good_step1_b = OR (Y4_comb_step1 INTERACT 2XV3N >= 2) (Y4_comb_step1 INTERACT RV3 >= 2)
 Y4_good_step1 = OR Y4_good_step1_a Y4_good_step1_b
 // 
 Y4_wide_chk_2 = Y4_wide_chk_1 INTERACT (WIDE_all_raw NOT INTERACT Y4_good_step1)
 Y4_comb_step2 = SIZE Y4_comb_step1 BY 0.035 INSIDE OF Y4_wide_chk_2 STEP 0.020
 Y4_good_step2_a = OR (Y4_comb_step2 INTERACT V3N >= 4) ((Y4_comb_step2 INTERACT V3N >= 2) INTERACT (OR RV3 2XV3N)) // step2: 0.035
 Y4_good_step2_b = OR (Y4_comb_step2 INTERACT 2XV3N >= 2) (Y4_comb_step2 INTERACT RV3 >= 2)
 Y4_good_step2 = OR Y4_good_step2_a Y4_good_step2_b
 // 
 Y4_wide_chk_3 = Y4_wide_chk_2 INTERACT (WIDE_all_raw NOT INTERACT Y4_good_step2)
 Y4_comb_step3 = SIZE Y4_comb_step2 BY 0.035 INSIDE OF Y4_wide_chk_3 STEP 0.020
 Y4_good_step3_a = OR (Y4_comb_step3 INTERACT V3N >= 4) ((Y4_comb_step3 INTERACT V3N >= 2) INTERACT (OR RV3 2XV3N)) // step3: 0.035
 Y4_good_step3_b = OR (Y4_comb_step3 INTERACT 2XV3N >= 2) (Y4_comb_step3 INTERACT RV3 >= 2)
 Y4_good_step3 = OR Y4_good_step3_a Y4_good_step3_b
 // 
 Y4_wide_chk_4 = Y4_wide_chk_3 INTERACT (WIDE_all_raw NOT INTERACT Y4_good_step3)
 Y4_comb_step4 = SIZE Y4_comb_step3 BY 0.035 INSIDE OF Y4_wide_chk_4 STEP 0.020
 Y4_good_step4_a = OR (Y4_comb_step4 INTERACT V3N >= 4) ((Y4_comb_step4 INTERACT V3N >= 2) INTERACT (OR RV3 2XV3N)) // step4: 0.035
 Y4_good_step4_b = OR (Y4_comb_step4 INTERACT 2XV3N >= 2) (Y4_comb_step4 INTERACT RV3 >= 2)
 Y4_good_step4 = OR Y4_good_step4_a Y4_good_step4_b
 // 
 Y4_wide_chk_5 = Y4_wide_chk_4 INTERACT (WIDE_all_raw NOT INTERACT Y4_good_step4)
 Y4_comb_step5 = SIZE Y4_comb_step4 BY 0.035 INSIDE OF Y4_wide_chk_5 STEP 0.020
 Y4_good_step5_a = OR (Y4_comb_step5 INTERACT V3N >= 4) ((Y4_comb_step5 INTERACT V3N >= 2) INTERACT (OR RV3 2XV3N)) // step5: 0.035
 Y4_good_step5_b = OR (Y4_comb_step5 INTERACT 2XV3N >= 2) (Y4_comb_step5 INTERACT RV3 >= 2)
 Y4_good_step5 = OR Y4_good_step5_a Y4_good_step5_b
 // 
 Y4_wide_chk_6 = Y4_wide_chk_5 INTERACT (WIDE_all_raw NOT INTERACT Y4_good_step5)
 Y4_comb_step6 = SIZE Y4_comb_step5 BY 0.018 INSIDE OF Y4_wide_chk_6 STEP 0.015
 Y4_good_step6_a = OR (Y4_comb_step6 INTERACT V3N >= 4) ((Y4_comb_step6 INTERACT V3N >= 2) INTERACT (OR RV3 2XV3N)) // step6: 0.207-0.05-0.035*4=0.018
 Y4_good_step6_b = OR (Y4_comb_step6 INTERACT 2XV3N >= 2) (Y4_comb_step6 INTERACT RV3 >= 2)
 Y4_good_step6 = OR Y4_good_step6_a Y4_good_step6_b
 Y4_good = WIDE_all_raw AND (OR Y4_good_step1 Y4_good_step2 Y4_good_step3 Y4_good_step4 Y4_good_step5 Y4_good_step6)
 // 
 err1 = (WIDE_all_raw OUTSIDE (OR Y1_good Y2_good Y3_good Y4_good)) INTERACT V3
 err1 NOT INTERACT Vy3_BAR
}
 
RVy3_R_3 {
@ Redundant via requirement must be obeyed by one of following conditions of Vy numbers and space for Mxy and 1.25xMy connection
@ (One of Mxy or 1.25xMy has width and length >= 0.272um, two square vias are equal to one rectangular via for below conditions) (Except VIA bar, MARKS and OCCD region)
@ 1) At least four square Vy with space <= 0.091um
@ 2) At least nine square Vy with space <= 0.545um
@ 3) At least two rectangular Vy with space <= 0.202um
@ 4) At least five rectangular Vy with space <= 0.545um
 X1a = WITH WIDTH M3 > 0.272-GLOBAL_TOLERANCE
 X1b = WITH WIDTH M4 > 0.272-GLOBAL_TOLERANCE
 WIDE_1 = (X1a AND M4) ENCLOSE V3
 WIDE_2 = (M3 AND X1b) ENCLOSE V3
 WIDE_all_raw = WIDE_1 OR WIDE_2
 WIDE_all = (M3 AND M4) NOT OUTSIDE WIDE_all_raw
 // 
 // condition 3: not replaced by RVia
 Y3_wide = WIDE_all INTERACT V3N >= 4 // rectangle array 0.091/2=0.045
 Y3_vias_input = V3N AND Y3_wide
 Y3_comb_step = SIZE Y3_vias_input BY 0.091/2 INSIDE OF Y3_wide STEP 0.02 // via minimum space = 0.083
 Y3_good_step = Y3_comb_step INTERACT V3N >= 4
 Y3_good = WIDE_all_raw AND Y3_good_step
 // 
 // condition 1 & 2 & 4 & 5: 32nm*32nm via can be replaced by 2XVia/RVia
 Y1_wide_all = WIDE_all_raw NOT INTERACT Y3_good
 Y1_wide = (WIDE_all INTERACT Y1_wide_all) INTERACT V3_SR >= 2 // rectangle array 0.545/2=0.272
 Y1_vias_input = V3_SR AND Y1_wide
 Y1_wide_chk_1 = Y1_wide INTERACT Y1_wide_all
 Y1_comb_step1 = SIZE Y1_vias_input BY 0.061 INSIDE OF Y1_wide_chk_1 STEP 0.02 // step1: 0.061, via minimum space = 0.202/2=0.101
 Y1_good_step1_a = Y1_comb_step1 INTERACT V3N >= 9
 Y1_good_step1_b = Y1_comb_step1 INTERACT RV3 >= 5
 Y1_good_step1_c = Y1_comb_step1 INTERACT 2XV3N >= 3
 Y1_good_step1_d = (Y1_comb_step1 INTERACT 1XV3N >= 7) INTERACT RV3 >= 1
 Y1_good_step1_e = (Y1_comb_step1 INTERACT 1XV3N >= 6) INTERACT 2XV3N >= 1
 Y1_good_step1_f = (Y1_comb_step1 INTERACT 1XV3N >= 5) INTERACT RV3 >= 2
 Y1_good_step1_g = ((Y1_comb_step1 INTERACT 1XV3N >= 4) INTERACT 2XV3N >= 1) INTERACT RV3 >= 1
 Y1_good_step1_h = (Y1_comb_step1 INTERACT 1XV3N >= 3) INTERACT RV3 >= 3
 Y1_good_step1_i = (Y1_comb_step1 INTERACT 1XV3N >= 3) INTERACT 2XV3N >= 2
 Y1_good_step1_j = ((Y1_comb_step1 INTERACT 1XV3N >= 2) INTERACT 2XV3N >= 1) INTERACT RV3 >= 2
 // SETLAYER Y1_good_step1_k = (Y1_comb_step1 INTERACT 1XV3N >= 1) INTERACT RV3 >= 4
 Y1_good_step1_l = ((Y1_comb_step1 INTERACT 1XV3N >= 1) INTERACT 2XV3N >= 2) INTERACT RV3 >= 1
 Y1_good_step1_m = Y1_comb_step1 INTERACT RV3 >= 2 // remove good condition3_val: 0.202
 Y1_good_step1_n = Y1_comb_step1 INTERACT 2XV3N >= 2
 Y1_good_step1_o = (Y1_comb_step1 INTERACT 1XV3N >= 2) INTERACT RV3 >= 1
 Y1_good_step1_p = (Y1_comb_step1 INTERACT 1XV3N >= 1) INTERACT 2XV3N >= 1
 Y1_good_step1_q = (Y1_comb_step1 INTERACT 2XV3N >= 1) INTERACT RV3 >= 1
 Y1_good_step1_r = OR Y1_good_step1_a Y1_good_step1_b Y1_good_step1_c Y1_good_step1_d Y1_good_step1_e Y1_good_step1_f Y1_good_step1_g Y1_good_step1_h
 Y1_good_step1_s = OR Y1_good_step1_i Y1_good_step1_j Y1_good_step1_l Y1_good_step1_m Y1_good_step1_n Y1_good_step1_o Y1_good_step1_p Y1_good_step1_q
 Y1_good_step1 = OR Y1_good_step1_r Y1_good_step1_s
 // 
 Y1_wide_chk_2 = Y1_wide_chk_1 INTERACT (WIDE_all_raw NOT INTERACT Y1_good_step1)
 Y1_comb_step2 = SIZE Y1_comb_step1 BY 0.040 INSIDE OF Y1_wide_chk_2 STEP 0.02 // step2: 0.040
 Y1_good_step2_a = Y1_comb_step2 INTERACT V3N >= 9
 Y1_good_step2_b = Y1_comb_step2 INTERACT RV3 >= 5
 Y1_good_step2_c = Y1_comb_step2 INTERACT 2XV3N >= 3
 Y1_good_step2_d = (Y1_comb_step2 INTERACT 1XV3N >= 7) INTERACT RV3 >= 1
 Y1_good_step2_e = (Y1_comb_step2 INTERACT 1XV3N >= 6) INTERACT 2XV3N >= 1
 Y1_good_step2_f = (Y1_comb_step2 INTERACT 1XV3N >= 5) INTERACT RV3 >= 2
 Y1_good_step2_g = ((Y1_comb_step2 INTERACT 1XV3N >= 4) INTERACT 2XV3N >= 1) INTERACT RV3 >= 1
 Y1_good_step2_h = (Y1_comb_step2 INTERACT 1XV3N >= 3) INTERACT RV3 >= 3
 Y1_good_step2_i = (Y1_comb_step2 INTERACT 1XV3N >= 3) INTERACT 2XV3N >= 2
 Y1_good_step2_j = ((Y1_comb_step2 INTERACT 1XV3N >= 2) INTERACT 2XV3N >= 1) INTERACT RV3 >= 2
 // SETLAYER Y1_good_step2_k = (Y1_comb_step2 INTERACT 1XV3N >= 1) INTERACT RV3 >= 4
 Y1_good_step2_l = ((Y1_comb_step2 INTERACT 1XV3N >= 1) INTERACT 2XV3N >= 2) INTERACT RV3 >= 1
 Y1_good_step2_m = Y1_comb_step2 INTERACT RV3 >= 2
 Y1_good_step2_n = Y1_comb_step2 INTERACT 2XV3N >= 2
 Y1_good_step2_o = (Y1_comb_step2 INTERACT 1XV3N >= 2) INTERACT RV3 >= 1
 Y1_good_step2_p = (Y1_comb_step2 INTERACT 1XV3N >= 1) INTERACT 2XV3N >= 1
 Y1_good_step2_q = (Y1_comb_step2 INTERACT 2XV3N >= 1) INTERACT RV3 >= 1
 Y1_good_step2_r = OR Y1_good_step2_a Y1_good_step2_b Y1_good_step2_c Y1_good_step2_d Y1_good_step2_e Y1_good_step2_f Y1_good_step2_g Y1_good_step2_h
 Y1_good_step2_s = OR Y1_good_step2_i Y1_good_step2_j Y1_good_step2_l Y1_good_step2_m Y1_good_step2_n Y1_good_step2_o Y1_good_step2_p Y1_good_step2_q
 Y1_good_step2 = OR Y1_good_step2_r Y1_good_step2_s
 // 
 // condition 1 & 2 & 4 & 5: 32nm*32nm via can be replaced by 2XVia/RVia
 Y1_wide_chk_3 = Y1_wide_chk_2 INTERACT (WIDE_all_raw NOT INTERACT Y1_good_step2)
 Y1_comb_step3 = SIZE Y1_comb_step2 BY 0.04 INSIDE OF Y1_wide_chk_3 STEP 0.02 // step3: 0.040
 Y1_good_step3_a = Y1_comb_step3 INTERACT V3N >= 9
 Y1_good_step3_b = Y1_comb_step3 INTERACT RV3 >= 5
 Y1_good_step3_c = Y1_comb_step3 INTERACT 2XV3N >= 3
 Y1_good_step3_d = (Y1_comb_step3 INTERACT 1XV3N >= 7) INTERACT RV3 >= 1
 Y1_good_step3_e = (Y1_comb_step3 INTERACT 1XV3N >= 6) INTERACT 2XV3N >= 1
 Y1_good_step3_f = (Y1_comb_step3 INTERACT 1XV3N >= 5) INTERACT RV3 >= 2
 Y1_good_step3_g = ((Y1_comb_step3 INTERACT 1XV3N >= 4) INTERACT 2XV3N >= 1) INTERACT RV3 >= 1
 Y1_good_step3_h = (Y1_comb_step3 INTERACT 1XV3N >= 3) INTERACT RV3 >= 3
 Y1_good_step3_i = (Y1_comb_step3 INTERACT 1XV3N >= 3) INTERACT 2XV3N >= 2
 Y1_good_step3_j = ((Y1_comb_step3 INTERACT 1XV3N >= 2) INTERACT 2XV3N >= 1) INTERACT RV3 >= 2
 // SETLAYER Y1_good_step3_k = (Y1_comb_step3 INTERACT 1XV3N >= 1) INTERACT RV3 >= 4
 Y1_good_step3_l = ((Y1_comb_step3 INTERACT 1XV3N >= 1) INTERACT 2XV3N >= 2) INTERACT RV3 >= 1
 Y1_good_step3_r = OR Y1_good_step3_a Y1_good_step3_b Y1_good_step3_c Y1_good_step3_d Y1_good_step3_e Y1_good_step3_f Y1_good_step3_g Y1_good_step3_h
 Y1_good_step3_s = OR Y1_good_step3_i Y1_good_step3_j Y1_good_step3_l
 Y1_good_step3 = OR Y1_good_step3_r Y1_good_step3_s
 // 
 Y1_wide_chk_4 = Y1_wide_chk_3 INTERACT (WIDE_all_raw NOT INTERACT Y1_good_step3)
 Y1_comb_step4 = SIZE Y1_comb_step3 BY 0.040 INSIDE OF Y1_wide_chk_4 STEP 0.02 // step4: 0.040
 Y1_good_step4_a = Y1_comb_step4 INTERACT V3N >= 9
 Y1_good_step4_b = Y1_comb_step4 INTERACT RV3 >= 5
 Y1_good_step4_c = Y1_comb_step4 INTERACT 2XV3N >= 3
 Y1_good_step4_d = (Y1_comb_step4 INTERACT 1XV3N >= 7) INTERACT RV3 >= 1
 Y1_good_step4_e = (Y1_comb_step4 INTERACT 1XV3N >= 6) INTERACT 2XV3N >= 1
 Y1_good_step4_f = (Y1_comb_step4 INTERACT 1XV3N >= 5) INTERACT RV3 >= 2
 Y1_good_step4_g = ((Y1_comb_step4 INTERACT 1XV3N >= 4) INTERACT 2XV3N >= 1) INTERACT RV3 >= 1
 Y1_good_step4_h = (Y1_comb_step4 INTERACT 1XV3N >= 3) INTERACT RV3 >= 3
 Y1_good_step4_i = (Y1_comb_step4 INTERACT 1XV3N >= 3) INTERACT 2XV3N >= 2
 Y1_good_step4_j = ((Y1_comb_step4 INTERACT 1XV3N >= 2) INTERACT 2XV3N >= 1) INTERACT RV3 >= 2
 // SETLAYER Y1_good_step4_k = (Y1_comb_step4 INTERACT 1XV3N >= 1) INTERACT RV3 >= 4
 Y1_good_step4_l = ((Y1_comb_step4 INTERACT 1XV3N >= 1) INTERACT 2XV3N >= 2) INTERACT RV3 >= 1
 Y1_good_step4_r = OR Y1_good_step4_a Y1_good_step4_b Y1_good_step4_c Y1_good_step4_d Y1_good_step4_e Y1_good_step4_f Y1_good_step4_g Y1_good_step4_h
 Y1_good_step4_s = OR Y1_good_step4_i Y1_good_step4_j Y1_good_step4_l
 Y1_good_step4 = OR Y1_good_step4_r Y1_good_step4_s
 // 
 Y1_wide_chk_5 = Y1_wide_chk_4 INTERACT (WIDE_all_raw NOT INTERACT Y1_good_step4)
 Y1_comb_step5 = SIZE Y1_comb_step4 BY 0.040 INSIDE OF Y1_wide_chk_5 STEP 0.02 // step5: 0.040
 Y1_good_step5_a = Y1_comb_step5 INTERACT V3N >= 9
 Y1_good_step5_b = Y1_comb_step5 INTERACT RV3 >= 5
 Y1_good_step5_c = Y1_comb_step5 INTERACT 2XV3N >= 3
 Y1_good_step5_d = (Y1_comb_step5 INTERACT 1XV3N >= 7) INTERACT RV3 >= 1
 Y1_good_step5_e = (Y1_comb_step5 INTERACT 1XV3N >= 6) INTERACT 2XV3N >= 1
 Y1_good_step5_f = (Y1_comb_step5 INTERACT 1XV3N >= 5) INTERACT RV3 >= 2
 Y1_good_step5_g = ((Y1_comb_step5 INTERACT 1XV3N >= 4) INTERACT 2XV3N >= 1) INTERACT RV3 >= 1
 Y1_good_step5_h = (Y1_comb_step5 INTERACT 1XV3N >= 3) INTERACT RV3 >= 3
 Y1_good_step5_i = (Y1_comb_step5 INTERACT 1XV3N >= 3) INTERACT 2XV3N >= 2
 Y1_good_step5_j = ((Y1_comb_step5 INTERACT 1XV3N >= 2) INTERACT 2XV3N >= 1) INTERACT RV3 >= 2
 // SETLAYER Y1_good_step5_k = (Y1_comb_step5 INTERACT 1XV3N >= 1) INTERACT RV3 >= 4
 Y1_good_step5_l = ((Y1_comb_step5 INTERACT 1XV3N >= 1) INTERACT 2XV3N >= 2) INTERACT RV3 >= 1
 Y1_good_step5_r = OR Y1_good_step5_a Y1_good_step5_b Y1_good_step5_c Y1_good_step5_d Y1_good_step5_e Y1_good_step5_f Y1_good_step5_g Y1_good_step5_h
 Y1_good_step5_s = OR Y1_good_step5_i Y1_good_step5_j Y1_good_step5_l
 Y1_good_step5 = OR Y1_good_step5_r Y1_good_step5_s
 // 
 Y1_wide_chk_6 = Y1_wide_chk_5 INTERACT (WIDE_all_raw NOT INTERACT Y1_good_step5)
 Y1_comb_step6 = SIZE Y1_comb_step5 BY 0.040 INSIDE OF Y1_wide_chk_6 STEP 0.02 // step6: 0.040
 Y1_good_step6_a = Y1_comb_step6 INTERACT V3N >= 9
 Y1_good_step6_b = Y1_comb_step6 INTERACT RV3 >= 5
 Y1_good_step6_c = Y1_comb_step6 INTERACT 2XV3N >= 3
 Y1_good_step6_d = (Y1_comb_step6 INTERACT 1XV3N >= 7) INTERACT RV3 >= 1
 Y1_good_step6_e = (Y1_comb_step6 INTERACT 1XV3N >= 6) INTERACT 2XV3N >= 1
 Y1_good_step6_f = (Y1_comb_step6 INTERACT 1XV3N >= 5) INTERACT RV3 >= 2
 Y1_good_step6_g = ((Y1_comb_step6 INTERACT 1XV3N >= 4) INTERACT 2XV3N >= 1) INTERACT RV3 >= 1
 Y1_good_step6_h = (Y1_comb_step6 INTERACT 1XV3N >= 3) INTERACT RV3 >= 3
 Y1_good_step6_i = (Y1_comb_step6 INTERACT 1XV3N >= 3) INTERACT 2XV3N >= 2
 Y1_good_step6_j = ((Y1_comb_step6 INTERACT 1XV3N >= 2) INTERACT 2XV3N >= 1) INTERACT RV3 >= 2
 // SETLAYER Y1_good_step6_k = (Y1_comb_step6 INTERACT 1XV3N >= 1) INTERACT RV3 >= 4
 Y1_good_step6_l = ((Y1_comb_step6 INTERACT 1XV3N >= 1) INTERACT 2XV3N >= 2) INTERACT RV3 >= 1
 Y1_good_step6_r = OR Y1_good_step6_a Y1_good_step6_b Y1_good_step6_c Y1_good_step6_d Y1_good_step6_e Y1_good_step6_f Y1_good_step6_g Y1_good_step6_h
 Y1_good_step6_s = OR Y1_good_step6_i Y1_good_step6_j Y1_good_step6_l
 Y1_good_step6 = OR Y1_good_step6_r Y1_good_step6_s
 // 
 Y1_wide_chk_7 = Y1_wide_chk_6 INTERACT (WIDE_all_raw NOT INTERACT Y1_good_step6)
 Y1_comb_step7 = SIZE Y1_comb_step6 BY 0.011 INSIDE OF Y1_wide_chk_7 STEP 0.02 // step7: 0.272-0.061-0.04-0.040*4=0.011
 Y1_good_step7_a = Y1_comb_step7 INTERACT V3N >= 9
 Y1_good_step7_b = Y1_comb_step7 INTERACT RV3 >= 5
 Y1_good_step7_c = Y1_comb_step7 INTERACT 2XV3N >= 3
 Y1_good_step7_d = (Y1_comb_step7 INTERACT 1XV3N >= 7) INTERACT RV3 >= 1
 Y1_good_step7_e = (Y1_comb_step7 INTERACT 1XV3N >= 6) INTERACT 2XV3N >= 1
 Y1_good_step7_f = (Y1_comb_step7 INTERACT 1XV3N >= 5) INTERACT RV3 >= 2
 Y1_good_step7_g = ((Y1_comb_step7 INTERACT 1XV3N >= 4) INTERACT 2XV3N >= 1) INTERACT RV3 >= 1
 Y1_good_step7_h = (Y1_comb_step7 INTERACT 1XV3N >= 3) INTERACT RV3 >= 3
 Y1_good_step7_i = (Y1_comb_step7 INTERACT 1XV3N >= 3) INTERACT 2XV3N >= 2
 Y1_good_step7_j = ((Y1_comb_step7 INTERACT 1XV3N >= 2) INTERACT 2XV3N >= 1) INTERACT RV3 >= 2
 // SETLAYER Y1_good_step7_k = (Y1_comb_step7 INTERACT 1XV3N >= 1) INTERACT RV3 >= 4
 Y1_good_step7_l = ((Y1_comb_step7 INTERACT 1XV3N >= 1) INTERACT 2XV3N >= 2) INTERACT RV3 >= 1
 Y1_good_step7_r = OR Y1_good_step7_a Y1_good_step7_b Y1_good_step7_c Y1_good_step7_d Y1_good_step7_e Y1_good_step7_f Y1_good_step7_g Y1_good_step7_h
 Y1_good_step7_s = OR Y1_good_step7_i Y1_good_step7_j Y1_good_step7_l
 Y1_good_step7 = OR Y1_good_step7_r Y1_good_step7_s
 Y1_Y2_Y4_good = WIDE_all_raw AND (OR Y1_good_step1 Y1_good_step2 Y1_good_step3 Y1_good_step4 Y1_good_step5 Y1_good_step6 Y1_good_step7)
 // 
 err1 = (WIDE_all_raw OUTSIDE (OR Y1_Y2_Y4_good Y3_good)) INTERACT V3
 (err1 NOT INTERACT Vy3_BAR) NOT INSIDE OCCD_MARKS
}
 
RVy3_R_4_M3 {
@ There should be at least two square Vy or one rectangular Vy in the intersection area of bottom metal and upper metal, when either wide metal Mxy or 1.25xMy length >= 0.162um and width >= 0.162um, the space between either via and wide metal <= 0.5um (S, S is the shortest running path length from Via to the wide metal). (except via bar)
 // DRC flags each intersecting area ({bottom metal AND upper metal}) with single square Via within the branch check region
 wide_M3 = (WITH WIDTH M3 > 0.162-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 0.162-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 0.162-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M3_real = wide_M3 NOT OUTSIDE ((SIZE wide_M3 BY 0.5+GLOBAL_TOLERANCE) INTERACT V3)
 all_down_and_up = (M3 INTERACT wide_M3) AND M4
 dis_down_arm_wide_all = SIZE wide_M3_real BY 0.5+GLOBAL_TOLERANCE INSIDE OF M3 STEP 0.025
 dis_down_and_up = dis_down_arm_wide_all AND all_down_and_up
 dis_down_and_up_arm = (dis_down_and_up NOT wide_M3) AND M3
 dis_down_arm = (dis_down_arm_wide_all NOT wide_M3) AND M3
 // 
 dis_down_arm_good_a = dis_down_and_up_arm INTERACT 1XV3N >= 2
 dis_down_arm_good_b = dis_down_and_up_arm INTERACT RV3
 dis_down_arm_good_c = dis_down_and_up_arm INTERACT 2XV3N
 dis_down_arm_good = OR dis_down_arm_good_a dis_down_arm_good_b dis_down_arm_good_c
 dis_down_arm_bad = (dis_down_and_up_arm NOT dis_down_arm_good) INTERACT (all_down_and_up INTERACT 1XV3N == 1)
 // 
 dis_down_arm_err_stack = (dis_down_arm_bad AND dis_down_and_up_arm) INTERACT 1XV3N
 dis_down_arm_err = dis_down_arm INTERACT dis_down_arm_err_stack
 err1_met_down = (dis_down_arm_err INTERACT (1XV3N NOT OUTSIDE dis_down_arm_err)) NOT INTERACT (OR RV3 2XV3N)
 // 
 wide_M4 = (WITH WIDTH M4 > 0.162-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 0.162-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 0.162-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M4_real = wide_M4 NOT OUTSIDE ((SIZE wide_M4 BY 0.5+GLOBAL_TOLERANCE) INTERACT V3)
 all_up_and_down = (M4 INTERACT wide_M4) AND M3
 dis_up_arm_wide_all = SIZE wide_M4_real BY 0.5+GLOBAL_TOLERANCE INSIDE OF M4 STEP 0.025
 dis_up_and_down = dis_up_arm_wide_all AND all_up_and_down
 dis_up_and_down_arm = (dis_up_and_down NOT wide_M4) AND M4
 dis_up_arm = (dis_up_arm_wide_all NOT wide_M4) AND M4
 // 
 dis_up_arm_good_a = dis_up_and_down_arm INTERACT 1XV3N >= 2
 dis_up_arm_good_b = dis_up_and_down_arm INTERACT RV3
 dis_up_arm_good_c = dis_up_and_down_arm INTERACT 2XV3N
 dis_up_arm_good = OR dis_up_arm_good_a dis_up_arm_good_b dis_up_arm_good_c
 dis_up_arm_bad = (dis_up_and_down_arm NOT dis_up_arm_good) INTERACT (all_up_and_down INTERACT 1XV3N == 1)
 // 
 dis_up_arm_err_stack = (dis_up_arm_bad AND dis_up_and_down_arm) INTERACT 1XV3N
 dis_up_arm_err = dis_up_arm INTERACT dis_up_arm_err_stack
 err2_met_up = (dis_up_arm_err INTERACT (1XV3N NOT OUTSIDE dis_up_arm_err)) NOT INTERACT (OR RV3 2XV3N)
 err1_met_down NOT INTERACT Vy3_BAR
}
 
RVy3_R_4_M4 {
@ There should be at least two square Vy or one rectangular Vy in the intersection area of bottom metal and upper metal, when either wide metal Mxy or 1.25xMy length >= 0.162um and width >= 0.162um, the space between either via and wide metal <= 0.5um (S, S is the shortest running path length from Via to the wide metal). (except via bar)
 // DRC flags each intersecting area ({bottom metal AND upper metal}) with single square Via within the branch check region
 wide_M3 = (WITH WIDTH M3 > 0.162-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 0.162-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 0.162-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M3_real = wide_M3 NOT OUTSIDE ((SIZE wide_M3 BY 0.5+GLOBAL_TOLERANCE) INTERACT V3)
 all_down_and_up = (M3 INTERACT wide_M3) AND M4
 dis_down_arm_wide_all = SIZE wide_M3_real BY 0.5+GLOBAL_TOLERANCE INSIDE OF M3 STEP 0.025
 dis_down_and_up = dis_down_arm_wide_all AND all_down_and_up
 dis_down_and_up_arm = (dis_down_and_up NOT wide_M3) AND M3
 dis_down_arm = (dis_down_arm_wide_all NOT wide_M3) AND M3
 // 
 dis_down_arm_good_a = dis_down_and_up_arm INTERACT 1XV3N >= 2
 dis_down_arm_good_b = dis_down_and_up_arm INTERACT RV3
 dis_down_arm_good_c = dis_down_and_up_arm INTERACT 2XV3N
 dis_down_arm_good = OR dis_down_arm_good_a dis_down_arm_good_b dis_down_arm_good_c
 dis_down_arm_bad = (dis_down_and_up_arm NOT dis_down_arm_good) INTERACT (all_down_and_up INTERACT 1XV3N == 1)
 // 
 dis_down_arm_err_stack = (dis_down_arm_bad AND dis_down_and_up_arm) INTERACT 1XV3N
 dis_down_arm_err = dis_down_arm INTERACT dis_down_arm_err_stack
 err1_met_down = (dis_down_arm_err INTERACT (1XV3N NOT OUTSIDE dis_down_arm_err)) NOT INTERACT (OR RV3 2XV3N)
 // 
 wide_M4 = (WITH WIDTH M4 > 0.162-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 0.162-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 0.162-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M4_real = wide_M4 NOT OUTSIDE ((SIZE wide_M4 BY 0.5+GLOBAL_TOLERANCE) INTERACT V3)
 all_up_and_down = (M4 INTERACT wide_M4) AND M3
 dis_up_arm_wide_all = SIZE wide_M4_real BY 0.5+GLOBAL_TOLERANCE INSIDE OF M4 STEP 0.025
 dis_up_and_down = dis_up_arm_wide_all AND all_up_and_down
 dis_up_and_down_arm = (dis_up_and_down NOT wide_M4) AND M4
 dis_up_arm = (dis_up_arm_wide_all NOT wide_M4) AND M4
 // 
 dis_up_arm_good_a = dis_up_and_down_arm INTERACT 1XV3N >= 2
 dis_up_arm_good_b = dis_up_and_down_arm INTERACT RV3
 dis_up_arm_good_c = dis_up_and_down_arm INTERACT 2XV3N
 dis_up_arm_good = OR dis_up_arm_good_a dis_up_arm_good_b dis_up_arm_good_c
 dis_up_arm_bad = (dis_up_and_down_arm NOT dis_up_arm_good) INTERACT (all_up_and_down INTERACT 1XV3N == 1)
 // 
 dis_up_arm_err_stack = (dis_up_arm_bad AND dis_up_and_down_arm) INTERACT 1XV3N
 dis_up_arm_err = dis_up_arm INTERACT dis_up_arm_err_stack
 err2_met_up = (dis_up_arm_err INTERACT (1XV3N NOT OUTSIDE dis_up_arm_err)) NOT INTERACT (OR RV3 2XV3N)
 err2_met_up NOT INTERACT Vy3_BAR
}
 
RVy3_R_5_M3 {
@ There should be at least two square Vy or one rectangular Vy in the intersection area of bottom metal and upper metal, when either wide metal Mxy or 1.25xMy length >= 0.272um and width >= 0.272um, the space between either via and wide metal <= 1um (S, S is the shortest running path length from Via to the wide metal). (except via bar)
 // DRC flags each intersecting area ({bottom metal AND upper metal}) with single square Via within the branch check region
 wide_M3 = (WITH WIDTH M3 > 0.272-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 0.272-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 0.272-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M3_real = wide_M3 NOT OUTSIDE ((SIZE wide_M3 BY 1+GLOBAL_TOLERANCE) INTERACT V3)
 all_down_and_up = (M3 INTERACT wide_M3) AND M4
 dis_down_arm_wide_all = SIZE wide_M3_real BY 1+GLOBAL_TOLERANCE INSIDE OF M3 STEP 0.025
 dis_down_and_up = dis_down_arm_wide_all AND all_down_and_up
 dis_down_and_up_arm = (dis_down_and_up NOT wide_M3) AND M3
 dis_down_arm = (dis_down_arm_wide_all NOT wide_M3) AND M3
 // 
 dis_down_arm_good_a = dis_down_and_up_arm INTERACT 1XV3N >= 2
 dis_down_arm_good_b = dis_down_and_up_arm INTERACT RV3
 dis_down_arm_good_c = dis_down_and_up_arm INTERACT 2XV3N
 dis_down_arm_good = OR dis_down_arm_good_a dis_down_arm_good_b dis_down_arm_good_c
 dis_down_arm_bad = (dis_down_and_up_arm NOT dis_down_arm_good) INTERACT (all_down_and_up INTERACT 1XV3N == 1)
 // 
 dis_down_arm_err_stack = (dis_down_arm_bad AND dis_down_and_up_arm) INTERACT 1XV3N
 dis_down_arm_err = dis_down_arm INTERACT dis_down_arm_err_stack
 err1_met_down = (dis_down_arm_err INTERACT (1XV3N NOT OUTSIDE dis_down_arm_err)) NOT INTERACT (OR RV3 2XV3N)
 // 
 wide_M4 = (WITH WIDTH M4 > 0.272-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 0.272-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 0.272-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M4_real = wide_M4 NOT OUTSIDE ((SIZE wide_M4 BY 1+GLOBAL_TOLERANCE) INTERACT V3)
 all_up_and_down = (M4 INTERACT wide_M4) AND M3
 dis_up_arm_wide_all = SIZE wide_M4_real BY 1+GLOBAL_TOLERANCE INSIDE OF M4 STEP 0.025
 dis_up_and_down = dis_up_arm_wide_all AND all_up_and_down
 dis_up_and_down_arm = (dis_up_and_down NOT wide_M4) AND M4
 dis_up_arm = (dis_up_arm_wide_all NOT wide_M4) AND M4
 // 
 dis_up_arm_good_a = dis_up_and_down_arm INTERACT 1XV3N >= 2
 dis_up_arm_good_b = dis_up_and_down_arm INTERACT RV3
 dis_up_arm_good_c = dis_up_and_down_arm INTERACT 2XV3N
 dis_up_arm_good = OR dis_up_arm_good_a dis_up_arm_good_b dis_up_arm_good_c
 dis_up_arm_bad = (dis_up_and_down_arm NOT dis_up_arm_good) INTERACT (all_up_and_down INTERACT 1XV3N == 1)
 // 
 dis_up_arm_err_stack = (dis_up_arm_bad AND dis_up_and_down_arm) INTERACT 1XV3N
 dis_up_arm_err = dis_up_arm INTERACT dis_up_arm_err_stack
 err2_met_up = (dis_up_arm_err INTERACT (1XV3N NOT OUTSIDE dis_up_arm_err)) NOT INTERACT (OR RV3 2XV3N)
 err1_met_down NOT INTERACT Vy3_BAR
}
 
RVy3_R_5_M4 {
@ There should be at least two square Vy or one rectangular Vy in the intersection area of bottom metal and upper metal, when either wide metal Mxy or 1.25xMy length >= 0.272um and width >= 0.272um, the space between either via and wide metal <= 1um (S, S is the shortest running path length from Via to the wide metal). (except via bar)
 // DRC flags each intersecting area ({bottom metal AND upper metal}) with single square Via within the branch check region
 wide_M3 = (WITH WIDTH M3 > 0.272-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 0.272-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 0.272-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M3_real = wide_M3 NOT OUTSIDE ((SIZE wide_M3 BY 1+GLOBAL_TOLERANCE) INTERACT V3)
 all_down_and_up = (M3 INTERACT wide_M3) AND M4
 dis_down_arm_wide_all = SIZE wide_M3_real BY 1+GLOBAL_TOLERANCE INSIDE OF M3 STEP 0.025
 dis_down_and_up = dis_down_arm_wide_all AND all_down_and_up
 dis_down_and_up_arm = (dis_down_and_up NOT wide_M3) AND M3
 dis_down_arm = (dis_down_arm_wide_all NOT wide_M3) AND M3
 // 
 dis_down_arm_good_a = dis_down_and_up_arm INTERACT 1XV3N >= 2
 dis_down_arm_good_b = dis_down_and_up_arm INTERACT RV3
 dis_down_arm_good_c = dis_down_and_up_arm INTERACT 2XV3N
 dis_down_arm_good = OR dis_down_arm_good_a dis_down_arm_good_b dis_down_arm_good_c
 dis_down_arm_bad = (dis_down_and_up_arm NOT dis_down_arm_good) INTERACT (all_down_and_up INTERACT 1XV3N == 1)
 // 
 dis_down_arm_err_stack = (dis_down_arm_bad AND dis_down_and_up_arm) INTERACT 1XV3N
 dis_down_arm_err = dis_down_arm INTERACT dis_down_arm_err_stack
 err1_met_down = (dis_down_arm_err INTERACT (1XV3N NOT OUTSIDE dis_down_arm_err)) NOT INTERACT (OR RV3 2XV3N)
 // 
 wide_M4 = (WITH WIDTH M4 > 0.272-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 0.272-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 0.272-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M4_real = wide_M4 NOT OUTSIDE ((SIZE wide_M4 BY 1+GLOBAL_TOLERANCE) INTERACT V3)
 all_up_and_down = (M4 INTERACT wide_M4) AND M3
 dis_up_arm_wide_all = SIZE wide_M4_real BY 1+GLOBAL_TOLERANCE INSIDE OF M4 STEP 0.025
 dis_up_and_down = dis_up_arm_wide_all AND all_up_and_down
 dis_up_and_down_arm = (dis_up_and_down NOT wide_M4) AND M4
 dis_up_arm = (dis_up_arm_wide_all NOT wide_M4) AND M4
 // 
 dis_up_arm_good_a = dis_up_and_down_arm INTERACT 1XV3N >= 2
 dis_up_arm_good_b = dis_up_and_down_arm INTERACT RV3
 dis_up_arm_good_c = dis_up_and_down_arm INTERACT 2XV3N
 dis_up_arm_good = OR dis_up_arm_good_a dis_up_arm_good_b dis_up_arm_good_c
 dis_up_arm_bad = (dis_up_and_down_arm NOT dis_up_arm_good) INTERACT (all_up_and_down INTERACT 1XV3N == 1)
 // 
 dis_up_arm_err_stack = (dis_up_arm_bad AND dis_up_and_down_arm) INTERACT 1XV3N
 dis_up_arm_err = dis_up_arm INTERACT dis_up_arm_err_stack
 err2_met_up = (dis_up_arm_err INTERACT (1XV3N NOT OUTSIDE dis_up_arm_err)) NOT INTERACT (OR RV3 2XV3N)
 err2_met_up NOT INTERACT Vy3_BAR
}
 
RVy3_R_6_M3 {
@ There should be at least two square Vy or one rectangular Vy in the intersection area of bottom metal and upper metal, when either wide metal Mxy or 1.25xMy width and length >= 0.542um, the space between either via and wide metal <= 3um (S, S is the shortest running path length from Via to the wide metal). (except via bar)
 // DRC flags each intersecting area ({bottom metal AND upper metal}) with single square Via within the branch check region
 wide_M3 = (WITH WIDTH M3 > 0.542-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 0.542-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 0.542-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M3_real = wide_M3 NOT OUTSIDE ((SIZE wide_M3 BY 3+GLOBAL_TOLERANCE) INTERACT V3)
 all_down_and_up = (M3 INTERACT wide_M3) AND M4
 dis_down_arm_wide_all = SIZE wide_M3_real BY 3+GLOBAL_TOLERANCE INSIDE OF M3 STEP 0.025
 dis_down_and_up = dis_down_arm_wide_all AND all_down_and_up
 dis_down_and_up_arm = (dis_down_and_up NOT wide_M3) AND M3
 dis_down_arm = (dis_down_arm_wide_all NOT wide_M3) AND M3
 // 
 dis_down_arm_good_a = dis_down_and_up_arm INTERACT 1XV3N >= 2
 dis_down_arm_good_b = dis_down_and_up_arm INTERACT RV3
 dis_down_arm_good_c = dis_down_and_up_arm INTERACT 2XV3N
 dis_down_arm_good = OR dis_down_arm_good_a dis_down_arm_good_b dis_down_arm_good_c
 dis_down_arm_bad = (dis_down_and_up_arm NOT dis_down_arm_good) INTERACT (all_down_and_up INTERACT 1XV3N == 1)
 // 
 dis_down_arm_err_stack = (dis_down_arm_bad AND dis_down_and_up_arm) INTERACT 1XV3N
 dis_down_arm_err = dis_down_arm INTERACT dis_down_arm_err_stack
 err1_met_down = (dis_down_arm_err INTERACT (1XV3N NOT OUTSIDE dis_down_arm_err)) NOT INTERACT (OR RV3 2XV3N)
 // 
 wide_M4 = (WITH WIDTH M4 > 0.542-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 0.542-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 0.542-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M4_real = wide_M4 NOT OUTSIDE ((SIZE wide_M4 BY 3+GLOBAL_TOLERANCE) INTERACT V3)
 all_up_and_down = (M4 INTERACT wide_M4) AND M3
 dis_up_arm_wide_all = SIZE wide_M4_real BY 3+GLOBAL_TOLERANCE INSIDE OF M4 STEP 0.025
 dis_up_and_down = dis_up_arm_wide_all AND all_up_and_down
 dis_up_and_down_arm = (dis_up_and_down NOT wide_M4) AND M4
 dis_up_arm = (dis_up_arm_wide_all NOT wide_M4) AND M4
 // 
 dis_up_arm_good_a = dis_up_and_down_arm INTERACT 1XV3N >= 2
 dis_up_arm_good_b = dis_up_and_down_arm INTERACT RV3
 dis_up_arm_good_c = dis_up_and_down_arm INTERACT 2XV3N
 dis_up_arm_good = OR dis_up_arm_good_a dis_up_arm_good_b dis_up_arm_good_c
 dis_up_arm_bad = (dis_up_and_down_arm NOT dis_up_arm_good) INTERACT (all_up_and_down INTERACT 1XV3N == 1)
 // 
 dis_up_arm_err_stack = (dis_up_arm_bad AND dis_up_and_down_arm) INTERACT 1XV3N
 dis_up_arm_err = dis_up_arm INTERACT dis_up_arm_err_stack
 err2_met_up = (dis_up_arm_err INTERACT (1XV3N NOT OUTSIDE dis_up_arm_err)) NOT INTERACT (OR RV3 2XV3N)
 err1_met_down NOT INTERACT Vy3_BAR
}
 
RVy3_R_6_M4 {
@ There should be at least two square Vy or one rectangular Vy in the intersection area of bottom metal and upper metal, when either wide metal Mxy or 1.25xMy width and length >= 0.542um, the space between either via and wide metal <= 3um (S, S is the shortest running path length from Via to the wide metal). (except via bar)
 // DRC flags each intersecting area ({bottom metal AND upper metal}) with single square Via within the branch check region
 wide_M3 = (WITH WIDTH M3 > 0.542-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 0.542-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 0.542-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M3_real = wide_M3 NOT OUTSIDE ((SIZE wide_M3 BY 3+GLOBAL_TOLERANCE) INTERACT V3)
 all_down_and_up = (M3 INTERACT wide_M3) AND M4
 dis_down_arm_wide_all = SIZE wide_M3_real BY 3+GLOBAL_TOLERANCE INSIDE OF M3 STEP 0.025
 dis_down_and_up = dis_down_arm_wide_all AND all_down_and_up
 dis_down_and_up_arm = (dis_down_and_up NOT wide_M3) AND M3
 dis_down_arm = (dis_down_arm_wide_all NOT wide_M3) AND M3
 // 
 dis_down_arm_good_a = dis_down_and_up_arm INTERACT 1XV3N >= 2
 dis_down_arm_good_b = dis_down_and_up_arm INTERACT RV3
 dis_down_arm_good_c = dis_down_and_up_arm INTERACT 2XV3N
 dis_down_arm_good = OR dis_down_arm_good_a dis_down_arm_good_b dis_down_arm_good_c
 dis_down_arm_bad = (dis_down_and_up_arm NOT dis_down_arm_good) INTERACT (all_down_and_up INTERACT 1XV3N == 1)
 // 
 dis_down_arm_err_stack = (dis_down_arm_bad AND dis_down_and_up_arm) INTERACT 1XV3N
 dis_down_arm_err = dis_down_arm INTERACT dis_down_arm_err_stack
 err1_met_down = (dis_down_arm_err INTERACT (1XV3N NOT OUTSIDE dis_down_arm_err)) NOT INTERACT (OR RV3 2XV3N)
 // 
 wide_M4 = (WITH WIDTH M4 > 0.542-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 0.542-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 0.542-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M4_real = wide_M4 NOT OUTSIDE ((SIZE wide_M4 BY 3+GLOBAL_TOLERANCE) INTERACT V3)
 all_up_and_down = (M4 INTERACT wide_M4) AND M3
 dis_up_arm_wide_all = SIZE wide_M4_real BY 3+GLOBAL_TOLERANCE INSIDE OF M4 STEP 0.025
 dis_up_and_down = dis_up_arm_wide_all AND all_up_and_down
 dis_up_and_down_arm = (dis_up_and_down NOT wide_M4) AND M4
 dis_up_arm = (dis_up_arm_wide_all NOT wide_M4) AND M4
 // 
 dis_up_arm_good_a = dis_up_and_down_arm INTERACT 1XV3N >= 2
 dis_up_arm_good_b = dis_up_and_down_arm INTERACT RV3
 dis_up_arm_good_c = dis_up_and_down_arm INTERACT 2XV3N
 dis_up_arm_good = OR dis_up_arm_good_a dis_up_arm_good_b dis_up_arm_good_c
 dis_up_arm_bad = (dis_up_and_down_arm NOT dis_up_arm_good) INTERACT (all_up_and_down INTERACT 1XV3N == 1)
 // 
 dis_up_arm_err_stack = (dis_up_arm_bad AND dis_up_and_down_arm) INTERACT 1XV3N
 dis_up_arm_err = dis_up_arm INTERACT dis_up_arm_err_stack
 err2_met_up = (dis_up_arm_err INTERACT (1XV3N NOT OUTSIDE dis_up_arm_err)) NOT INTERACT (OR RV3 2XV3N)
 err2_met_up NOT INTERACT Vy3_BAR
}
 
RVy3_R_7_M3 {
@ There should be at least two square Vy or one rectangular Vy in the intersection area of bottom metal and upper metal, when either wide metal Mxy or 1.25xMy width and length >= 1.01um, the space between either via and wide metal <= 5um (S, S is the shortest running path length from Via to the wide metal). (except via bar)
 // DRC flags each intersecting area ({bottom metal AND upper metal}) with single square Via within the branch check region
 wide_M3 = (WITH WIDTH M3 > 1.01-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 1.01-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 1.01-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M3_real = wide_M3 NOT OUTSIDE ((SIZE wide_M3 BY 5+GLOBAL_TOLERANCE) INTERACT V3)
 all_down_and_up = (M3 INTERACT wide_M3) AND M4
 dis_down_arm_wide_all = SIZE wide_M3_real BY 5+GLOBAL_TOLERANCE INSIDE OF M3 STEP 0.025
 dis_down_and_up = dis_down_arm_wide_all AND all_down_and_up
 dis_down_and_up_arm = (dis_down_and_up NOT wide_M3) AND M3
 dis_down_arm = (dis_down_arm_wide_all NOT wide_M3) AND M3
 // 
 dis_down_arm_good_a = dis_down_and_up_arm INTERACT 1XV3N >= 2
 dis_down_arm_good_b = dis_down_and_up_arm INTERACT RV3
 dis_down_arm_good_c = dis_down_and_up_arm INTERACT 2XV3N
 dis_down_arm_good = OR dis_down_arm_good_a dis_down_arm_good_b dis_down_arm_good_c
 dis_down_arm_bad = (dis_down_and_up_arm NOT dis_down_arm_good) INTERACT (all_down_and_up INTERACT 1XV3N == 1)
 // 
 dis_down_arm_err_stack = (dis_down_arm_bad AND dis_down_and_up_arm) INTERACT 1XV3N
 dis_down_arm_err = dis_down_arm INTERACT dis_down_arm_err_stack
 err1_met_down = (dis_down_arm_err INTERACT (1XV3N NOT OUTSIDE dis_down_arm_err)) NOT INTERACT (OR RV3 2XV3N)
 // 
 wide_M4 = (WITH WIDTH M4 > 1.01-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 1.01-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 1.01-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M4_real = wide_M4 NOT OUTSIDE ((SIZE wide_M4 BY 5+GLOBAL_TOLERANCE) INTERACT V3)
 all_up_and_down = (M4 INTERACT wide_M4) AND M3
 dis_up_arm_wide_all = SIZE wide_M4_real BY 5+GLOBAL_TOLERANCE INSIDE OF M4 STEP 0.025
 dis_up_and_down = dis_up_arm_wide_all AND all_up_and_down
 dis_up_and_down_arm = (dis_up_and_down NOT wide_M4) AND M4
 dis_up_arm = (dis_up_arm_wide_all NOT wide_M4) AND M4
 // 
 dis_up_arm_good_a = dis_up_and_down_arm INTERACT 1XV3N >= 2
 dis_up_arm_good_b = dis_up_and_down_arm INTERACT RV3
 dis_up_arm_good_c = dis_up_and_down_arm INTERACT 2XV3N
 dis_up_arm_good = OR dis_up_arm_good_a dis_up_arm_good_b dis_up_arm_good_c
 dis_up_arm_bad = (dis_up_and_down_arm NOT dis_up_arm_good) INTERACT (all_up_and_down INTERACT 1XV3N == 1)
 // 
 dis_up_arm_err_stack = (dis_up_arm_bad AND dis_up_and_down_arm) INTERACT 1XV3N
 dis_up_arm_err = dis_up_arm INTERACT dis_up_arm_err_stack
 err2_met_up = (dis_up_arm_err INTERACT (1XV3N NOT OUTSIDE dis_up_arm_err)) NOT INTERACT (OR RV3 2XV3N)
 err1_met_down NOT INTERACT Vy3_BAR
}
 
RVy3_R_7_M4 {
@ There should be at least two square Vy or one rectangular Vy in the intersection area of bottom metal and upper metal, when either wide metal Mxy or 1.25xMy width and length >= 1.01um, the space between either via and wide metal <= 5um (S, S is the shortest running path length from Via to the wide metal). (except via bar)
 // DRC flags each intersecting area ({bottom metal AND upper metal}) with single square Via within the branch check region
 wide_M3 = (WITH WIDTH M3 > 1.01-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 1.01-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 1.01-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M3_real = wide_M3 NOT OUTSIDE ((SIZE wide_M3 BY 5+GLOBAL_TOLERANCE) INTERACT V3)
 all_down_and_up = (M3 INTERACT wide_M3) AND M4
 dis_down_arm_wide_all = SIZE wide_M3_real BY 5+GLOBAL_TOLERANCE INSIDE OF M3 STEP 0.025
 dis_down_and_up = dis_down_arm_wide_all AND all_down_and_up
 dis_down_and_up_arm = (dis_down_and_up NOT wide_M3) AND M3
 dis_down_arm = (dis_down_arm_wide_all NOT wide_M3) AND M3
 // 
 dis_down_arm_good_a = dis_down_and_up_arm INTERACT 1XV3N >= 2
 dis_down_arm_good_b = dis_down_and_up_arm INTERACT RV3
 dis_down_arm_good_c = dis_down_and_up_arm INTERACT 2XV3N
 dis_down_arm_good = OR dis_down_arm_good_a dis_down_arm_good_b dis_down_arm_good_c
 dis_down_arm_bad = (dis_down_and_up_arm NOT dis_down_arm_good) INTERACT (all_down_and_up INTERACT 1XV3N == 1)
 // 
 dis_down_arm_err_stack = (dis_down_arm_bad AND dis_down_and_up_arm) INTERACT 1XV3N
 dis_down_arm_err = dis_down_arm INTERACT dis_down_arm_err_stack
 err1_met_down = (dis_down_arm_err INTERACT (1XV3N NOT OUTSIDE dis_down_arm_err)) NOT INTERACT (OR RV3 2XV3N)
 // 
 wide_M4 = (WITH WIDTH M4 > 1.01-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 1.01-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 1.01-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M4_real = wide_M4 NOT OUTSIDE ((SIZE wide_M4 BY 5+GLOBAL_TOLERANCE) INTERACT V3)
 all_up_and_down = (M4 INTERACT wide_M4) AND M3
 dis_up_arm_wide_all = SIZE wide_M4_real BY 5+GLOBAL_TOLERANCE INSIDE OF M4 STEP 0.025
 dis_up_and_down = dis_up_arm_wide_all AND all_up_and_down
 dis_up_and_down_arm = (dis_up_and_down NOT wide_M4) AND M4
 dis_up_arm = (dis_up_arm_wide_all NOT wide_M4) AND M4
 // 
 dis_up_arm_good_a = dis_up_and_down_arm INTERACT 1XV3N >= 2
 dis_up_arm_good_b = dis_up_and_down_arm INTERACT RV3
 dis_up_arm_good_c = dis_up_and_down_arm INTERACT 2XV3N
 dis_up_arm_good = OR dis_up_arm_good_a dis_up_arm_good_b dis_up_arm_good_c
 dis_up_arm_bad = (dis_up_and_down_arm NOT dis_up_arm_good) INTERACT (all_up_and_down INTERACT 1XV3N == 1)
 // 
 dis_up_arm_err_stack = (dis_up_arm_bad AND dis_up_and_down_arm) INTERACT 1XV3N
 dis_up_arm_err = dis_up_arm INTERACT dis_up_arm_err_stack
 err2_met_up = (dis_up_arm_err INTERACT (1XV3N NOT OUTSIDE dis_up_arm_err)) NOT INTERACT (OR RV3 2XV3N)
 err2_met_up NOT INTERACT Vy3_BAR
}

// =======================================================
// 1.25xMy design rules
// =======================================================

GROUP G125xmy4 125xmy4_?
 
125xmy4_040 = M4 WITH WIDTH == 0.040
125xmy4_042 = M4 WITH WIDTH == 0.042
125xmy4_044 = M4 WITH WIDTH == 0.044
125xmy4_046 = M4 WITH WIDTH == 0.046
125xmy4_060 = M4 WITH WIDTH == 0.060
125xmy4_080 = M4 WITH WIDTH == 0.080
125xmy4_120 = M4 WITH WIDTH == 0.120
125xmy4_160 = M4 WITH WIDTH == 0.160
125xmy4_eqgt_060 = M4 WITH WIDTH >= 0.060
125xmy4_eqgt_120 = 125xmy4_eqgt_060 WITH WIDTH >= 0.120
125xmy4_eqgt_121 = 125xmy4_eqgt_060 WITH WIDTH >= 0.121
125xmy4_eqgt_200 = 125xmy4_eqgt_120 WITH WIDTH >= 0.200
125xmy4_gt_060 = 125xmy4_eqgt_060 WITH WIDTH > 0.060
125xmy4_gt_160 = 125xmy4_eqgt_060 WITH WIDTH > 0.160
125xmy4_gt_080 = 125xmy4_eqgt_060 WITH WIDTH > 0.080
 
125xmy4_044_end = LENGTH M4_convex_90_90_edges <= 0.044
125xmy4_060_end = LENGTH M4_convex_90_90_edges <= 0.060
M4_060_h_edges = INT [M4_h_edges] == 0.06 OPPOSITE
 

#IFDEF DFM_RULES_PRIORITY_1 YES

125xmy4_S_3_DFM1 {
@ Recommended 1.25xMy space when either one 1.25xMy width > 1.35um. >= 0.450um
 chk_mn = M4 WITH WIDTH > 1.35
 err1 = EXT chk_mn M4 < 0.450 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xmy4_A_1_DFM1 {
@ Recommended 1.25xMy area >= 0.02um2
 err1 = AREA M4 < 0.02
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xmy4_R_12_V3_DFM1 {
@ It's not recommended to use dense 1.25xMy 3-bar pattern
@ DRC flag conditions:
@ (1) Middle 1.25xMy line width (W1) <= 0.044um, both two neighbour 1.25xMy line width <= 0.06um and interact square or rectangle Vy-1 or Vy
@ (2) 1.25xMxy Space to both via (S1/S2) < 0.048um
@ (3) The via PRL: -0.1 < PRL < 0.1um
@ (4) Both neighbour 1.25xMxy enclosure Vy < 0.05um, or Both neighbour 1.25xMxy enclosure 1.25xVn < 0.065um
@ This rule is not applied for INST region
 met_44_side = INT [M4] <= 0.044 ABUT<90 OPPOSITE
 met_60_side = INT [M4] <= 0.060 ABUT<90 OPPOSITE
 via_d_met = V3_SR NOT OUTSIDE (M4 WITH WIDTH <= 0.06)
 via_d_end = via_d_met TOUCH EDGE (ENC [via_d_met] 125xmy4_060_end < 0.050 ABUT<90 OPPOSITE)
 via_d_lin = (via_d_met NOT TOUCH EDGE via_d_end) TOUCH EDGE (ENC [via_d_met] met_60_side <= 0.028 ABUT<90 OPPOSITE)
 via_d_mid = (via_d_met WITH EDGE via_d_end) WITH EDGE via_d_lin >= 2
 via_d_sid = via_d_mid TOUCH EDGE via_d_lin
 via_d_sps = (EXT [met_44_side] via_d_sid < 0.048 OPPOSITE EXTENDED 0.1 MEASURE ALL) TOUCH EDGE (EXT [met_44_side] via_d_sid < 0.048 OPPOSITE MEASURE ALL)
 err1 = INT via_d_sps <= 0.044 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE INST
}
 
125xmy4_R_12_V4_DFM1 {
@ It's not recommended to use dense 1.25xMy 3-bar pattern
@ DRC flag conditions:
@ (1) Middle 1.25xMy line width (W1) <= 0.044um, both two neighbour 1.25xMy line width <= 0.06um and interact square or rectangle Vy-1 or Vy
@ (2) 1.25xMxy Space to both via (S1/S2) < 0.048um
@ (3) The via PRL: -0.1 < PRL < 0.1um
@ (4) Both neighbour 1.25xMxy enclosure Vy < 0.05um, or Both neighbour 1.25xMxy enclosure 1.25xVn < 0.065um
@ This rule is not applied for INST region
 met_44_side = INT [M4] <= 0.044 ABUT<90 OPPOSITE
 met_60_side = INT [M4] <= 0.060 ABUT<90 OPPOSITE
 via_u_met = V4_SR NOT OUTSIDE (M4 WITH WIDTH <= 0.06)
 via_u_end = via_u_met TOUCH EDGE (ENC [via_u_met] 125xmy4_060_end < 0.065 ABUT<90 OPPOSITE)
 via_u_lin = (via_u_met NOT TOUCH EDGE via_u_end) TOUCH EDGE (ENC [via_u_met] met_60_side <= 0.028 ABUT<90 OPPOSITE)
 via_u_mid = (via_u_met WITH EDGE via_u_end) WITH EDGE via_u_lin >= 2
 via_u_sid = via_u_mid TOUCH EDGE via_u_lin
 via_u_sps = (EXT [met_44_side] via_u_sid < 0.048 OPPOSITE EXTENDED 0.1 MEASURE ALL) TOUCH EDGE (EXT [met_44_side] via_u_sid < 0.048 OPPOSITE MEASURE ALL)
 err1 = INT via_u_sps <= 0.044 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE INST
}

#ENDIF

125xmy4_W_1 {
@ 1.25xMy width >= 0.04um
 err1 = INT M4 < 0.04 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xmy4_W_1a {
@ 1.25xMy width in CP direction = 0.040~0.046, >= 0.06um
@ The width should be even value when <= 0.046um
@ CP direction definition: Critical-Pitch direction along the minimum pitch (80nm) of 1.25xMy
 err1 = INT M4_h_edges < 0.040 ABUT<90 OPPOSITE REGION
 err2 = INT M4_h_edges > 0.040 < 0.042 ABUT<90 OPPOSITE REGION
 err3 = INT M4_h_edges > 0.042 < 0.044 ABUT<90 OPPOSITE REGION
 err4 = INT M4_h_edges > 0.044 < 0.046 ABUT<90 OPPOSITE REGION
 err5 = INT M4_h_edges > 0.046 < 0.060 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
 err4 NOT INSIDE SealR_NOT_BULK
 err5 NOT INSIDE SealR_NOT_BULK
}
 
125xmy4_W_1b {
@ 1.25xMy width in NCP direction = 0.080, >= 0.12um
@ NCP direction definition: Non-Critical-Pitch direction perpendicular to CP direction
 err1 = INT M4_v_edges < 0.080 ABUT<90 OPPOSITE REGION
 err2 = INT M4_v_edges > 0.080 < 0.120 ABUT<90 OPPOSITE REGION EXCLUDE SHIELDED
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}
 
125xmy4_W_2 {
@ Maximum 1.25xMy width, except MARKS and LOGO regions <= 2.1um
 err1 = (M4 NOT INSIDE MARKS_LOGO) WITH WIDTH > 2.1
 err1 NOT INSIDE MARKS_LOGO
}
 
125xmy4_W_3 {
@ Width of 45-degree bent 1.25xMy >= 0.396um
 err1 = INT M4_45_skew_edges < 0.396 OPPOSITE REGION EXCLUDE SHIELDED
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xmy4_W_4 {
@ 1.25xMy branch width when connected to wide metal with both width and length >= 0.401um. >= 0.080um
 dorian_large = M4 WITH WIDTH >= 0.401
 dorian_whole = M4 INTERACT dorian_large
 dorian_large_exp = SIZE dorian_large BY 0.005 INSIDE OF dorian_whole
 dorian_branch_0 = dorian_whole NOT dorian_large
 dorian_branch_1 = dorian_branch_0 NOT COIN EDGE dorian_large
 dorian_branch_2 = dorian_branch_1 TOUCH EDGE dorian_large_exp
 err1 = INT dorian_branch_2 < 0.08 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xmy4_W_5 {
@ 1.25xMy width when PRL < 0um. >= 0.08um
 err1 = INT M4 < 0.08 ABUT<90 REGION CORNER TO CORNER
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xmy4_S_1 {
@ 1.25xMy space >= 0.040um
 err1 = EXT M4 < 0.04 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xmy4_S_2 {
@ Space between 1.25xMy when one or both 1.25xMy width >= 0.201um when PRL >= -0.139um. >= 0.139um
 chk_Mn = M4 WITH WIDTH >= 0.201
 err1 = EXT M4 chk_Mn < 0.139 ABUT<90 OPPOSITE EXTENDED 0.139+GLOBAL_TOLERANCE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xmy4_S_3 {
@ Space between 1.25xMy when one or both 1.25xMy width >= 0.282um when PRL > 0.16um. >= 0.199um
 mets_RAW = (M4 WITH WIDTH >= 0.201) WITH WIDTH >= 0.282
 mets_sps_ERRS = EXT mets_RAW M4 < 0.199 ABUT<90 OPPOSITE
 mets_sps_AREA = EXT mets_RAW M4 < 0.199 ABUT<90 OPPOSITE REGION
 err1 = DFM PROPERTY mets_sps_AREA mets_sps_ERRS OVERLAP ABUT ALSO MULTI [-= EC(mets_sps_ERRS)] > 0.16
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xmy4_S_4 {
@ Space between 1.25xMy when one or both 1.25xMy width > 0.5um when PRL >= -0.199um. >= 0.199um
 chk_Mn = (M4 WITH WIDTH >= 0.201) WITH WIDTH > 0.5
 err1 = EXT M4 chk_Mn < 0.199 ABUT<90 OPPOSITE EXTENDED 0.199+GLOBAL_TOLERANCE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xmy4_S_5 {
@ Space between 1.25xMy when one or both 1.25xMy width > 1.35um when PRL > 1.35um. >= 0.448um
 met_wid_all = M4 WITH WIDTH >= 1.35+GLOBAL_TOLERANCE
 met_err_RAW = EXT M4 met_wid_all < 0.448 OPPOSITE REGION MEASURE ALL
 met_err_CRN = EXT (ANGLE M4 > 44 < 46) met_wid_all < 0.448 OPPOSITE1 REGION MEASURE ALL
 err1 = met_err_RAW ENCLOSE RECTANGLE 0.001 1.351 ORTHOGONAL ONLY
 err2 = met_err_CRN ENCLOSE RECTANGLE 0.04 1.351
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}
 
125xmy4_S_6 {
@ Space between 1.25xMy in CP direction when one or both 1.25xMy width = 0.04um. = 0.040, >= 0.07um
 err1_TMP = DFM SPACE M4 125xmy4_040 < 0.04 BY EXT VERTICAL
 err2_TMP = DFM SPACE M4 125xmy4_040 > 0.04 < 0.07 BY EXT VERTICAL
 // 
 waive_TMP = ANGLE 125xmy4_060 == 0
 waive_EDG = EXT waive_TMP 125xmy4_040 == 0.07 ABUT<90 OPPOSITE
 err1 = DFM COPY err1_TMP EDGE
 // NOT COIN EDGE (DFM COPY waive_EDG EDGE)
 err2 = DFM COPY err2_TMP EDGE
 // NOT COIN EDGE (DFM COPY waive_EDG EDGE)
 err1 NOT INSIDE EDGE SealR_NOT_BULK
 err2 NOT INSIDE EDGE SealR_NOT_BULK
}
 
125xmy4_S_6a {
@ Space between 1.25xMy in CP direction when one or both 1.25xMy width = 0.042um. = 0.048, >= 0.07um
 err1 = EXT M4_h_edges 125xmy4_042 < 0.048 ABUT<90 OPPOSITE REGION
 err2 = EXT M4_h_edges 125xmy4_042 > 0.048 < 0.07 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}
 
125xmy4_S_7 {
@ Space between 1.25xMy in CP direction when one or both 1.25xMy width = 0.044um. = 0.046, >= 0.07um
 err1 = EXT M4_h_edges 125xmy4_044 < 0.046 ABUT<90 OPPOSITE REGION
 err2 = EXT M4_h_edges 125xmy4_044 > 0.046 < 0.07 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}
 
125xmy4_S_7a {
@ Space between 1.25xMy in CP direction when one or both 1.25xMy width = 0.046um. = 0.046, >= 0.07um
 err1 = EXT M4_h_edges 125xmy4_046 < 0.046 ABUT<90 OPPOSITE REGION
 err2 = EXT M4_h_edges 125xmy4_046 > 0.046 < 0.07 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}
 
125xmy4_S_8 {
@ Space between 1.25xMy in CP direction when one or both 1.25xMy width = 0.06um) = 0.04, 0.046, >= 0.06um
 waive_s_6a_chk = ANGLE 125xmy4_060 == 0
 waive_s_6a = DFM COPY (EXT waive_s_6a_chk 125xmy4_040 == 0.070 ABUT<90 OPPOSITE) EDGE
 bad_1 = DFM SPACE 125xmy4_060 M4 < 0.040 BY EXT VERTICAL
 bad_2 = DFM SPACE 125xmy4_060 M4 > 0.040 < 0.046 BY EXT VERTICAL
 bad_3 = DFM SPACE 125xmy4_060 M4 > 0.046 < 0.060 BY EXT VERTICAL
 err1 = DFM COPY bad_1 EDGE
 // NOT COIN EDGE waive_s_6a
 err2 = DFM COPY bad_2 EDGE
 // NOT COIN EDGE waive_s_6a
 err3 = DFM COPY bad_3 EDGE
 // NOT COIN EDGE waive_s_6a
 err1 NOT INSIDE EDGE SealR_NOT_BULK
 err2 NOT INSIDE EDGE SealR_NOT_BULK
 err3 NOT INSIDE EDGE SealR_NOT_BULK
}
 
125xmy4_S_8a {
@ Space between 1.25xMy in CP direction when one or both 1.25xMy width > 0.06um when PRL > 0.08um. >= 0.06um
 met_wid_all = COPY 125xmy4_gt_060
 met_err_RAW = EXT [met_wid_all] M4_h_edges < 0.06 ABUT<90 OPPOSITE MEASURE ALL
 met_jog_ALL = (CONVEX EDGE M4 == 1) NOT COIN EDGE met_err_RAW
 met_jog_EXP_a = EXPAND EDGE met_jog_ALL INSIDE BY 0.0005
 met_jog_EXP_b = EXPAND EDGE met_jog_ALL OUTSIDE BY 0.0005
 met_jog_TMP = (met_jog_ALL COIN EDGE (met_jog_EXP_a WITH EDGE met_err_RAW)) COIN EDGE (met_jog_EXP_b WITH EDGE met_err_RAW)
 met_jog_EXP = ((VERTEX (EXPAND EDGE met_jog_TMP OUTSIDE BY 0.001 EXTEND BY 0.001) == 4) OR (EXPAND EDGE met_err_RAW OUTSIDE BY 0.001)) NOT M4
 // 
 met_err_PRL = DFM PROPERTY met_jog_EXP met_err_RAW OVERLAP ABUT ALSO MULTI [-= LENGTH(met_err_RAW)] > 0.08
 met_err_EGE = met_err_RAW TOUCH EDGE met_err_PRL
 err1 = EXT met_err_EGE M4 < 0.06 ABUT<90 OPPOSITE REGION MEASURE ALL
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xmy4_S_9 {
@ Space between 1.25xMy in CP direction, when one or both width = 0.06um, and the other side space < 0.06um. >= 0.079um
 mets_sps_060 = EXT [M4_060_h_edges] M4 < 0.06 ABUT<90 OPPOSITE
 mets_sps_080 = EXT [M4_060_h_edges] M4 < 0.079 ABUT<90 OPPOSITE
 err1 = INT mets_sps_060 mets_sps_080 == 0.06 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
M4_convex_90_270_edges_gt_040 = ANGLE (CONVEX EDGE M4 ANGLE1 == 90 ANGLE2 == 270 WITH LENGTH > 0.04) == 90
M4_width_eq_080 = M4 WITH WIDTH == 0.08
 
125xmy4_S_10 {
@ Space between 1.25xMy in CP direction when one or both 1.25xMy width >= 0.08um. >= 0.079um
@ Except Z-shape corner
@ Z-shape corner definition:
@ Edge length > 0.04um between two consecutive 90-270 degree corners, corresponding width = 0.08um in NCP direction between 2 opposite edge length > 0.04um
 zfig_shape_s_side = ANGLE (LENGTH M4_convex_90_90_edges == 0.08) == 0
 zfig_shape = (M4_width_eq_080 INTERACT (INT M4_convex_90_270_edges_gt_040 == 0.08 ABUT<90 OPPOSITE REGION)) NOT WITH EDGE zfig_shape_s_side
 waive_shape = zfig_shape NOT COIN EDGE (INT [M4_h_edges] == 0.08 ABUT<90 OPPOSITE) // vertical width=0.08 need to flag
 // 
 check_edge = INT (M4_h_edges) < 0.08 ABUT<90 OPPOSITE
 check_shape = check_edge NOT COIN EDGE waive_shape
 err1 = EXT check_shape (M4 NOT COIN EDGE waive_shape) < 0.079 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xmy4_S_11 {
@ Space between 1.25xMy in CP direction when one or both width >= 0.121um, PRL > 0.08um. >= 0.099um
 mets_sps_100_ERRS = EXT 125xmy4_eqgt_121 M4_h_edges < 0.099 ABUT<90 OPPOSITE
 mets_sps_100_AREA = EXT 125xmy4_eqgt_121 M4_h_edges < 0.099 ABUT<90 OPPOSITE REGION
 err1 = DFM PROPERTY mets_sps_100_AREA mets_sps_100_ERRS OVERLAP ABUT ALSO MULTI [-= EC(mets_sps_100_ERRS)] > 0.08
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xmy4_S_12 {
@ Space between 1.25xMy (CP direction width > 0.16um and NCP direction width > 0.08um) and 1.25xMy edge (edge length > 0.08um in NCP direction) in CP direction >= 0.119um
 mets_L_sides = (INT (M4_h_edges) <= 0.16 ABUT<90 OPPOSITE EXCLUDE SHIELDED) COIN EDGE 125xmy4_gt_080
 mets_R_sides = LENGTH M4_h_edges > 0.08
 err1 = EXT mets_R_sides (mets_L_sides COIN EDGE mets_R_sides) < 0.119 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xmy4_S_13 {
@ Space between 1.25xMy in CP direction when one or both width >= 0.201um, PRL >= 0.121um. >= 0.144um
 mets_RAW = M4 WITH WIDTH >= 0.201
 mets_sps_ERRS = EXT mets_RAW M4_h_edges < 0.144 ABUT<90 OPPOSITE
 mets_sps_AREA = EXT mets_RAW M4_h_edges < 0.144 ABUT<90 OPPOSITE REGION
 err1 = DFM PROPERTY mets_sps_AREA mets_sps_ERRS OVERLAP ABUT ALSO MULTI [-= EC(mets_sps_ERRS)] >= 0.121
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xmy4_S_14 {
@ Space between 1.25xMy in CP direction when one or both width >= 0.231um, PRL >= 0.121um. >= 0.159um
 mets_RAW = (M4 WITH WIDTH >= 0.201) WITH WIDTH >= 0.231
 mets_sps_ERRS = EXT mets_RAW M4_h_edges < 0.159 ABUT<90 OPPOSITE
 mets_sps_AREA = EXT mets_RAW M4_h_edges < 0.159 ABUT<90 OPPOSITE REGION
 err1 = DFM PROPERTY mets_sps_AREA mets_sps_ERRS OVERLAP ABUT ALSO MULTI [-= EC(mets_sps_ERRS)] >= 0.121
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xmy4_S_15 {
@ Space between 1.25xMy and 1.25xMy line-end (width = 0.08um) in CP direction when PRL > -0.08um. >= 0.099um
 lend_RAW = LENGTH M4_convex_eq_two_edges == 0.08
 lend_CHK = ANGLE lend_RAW == 0
 err1 = EXT lend_CHK M4 < 0.099 ABUT<90 OPPOSITE EXTENDED 0.08 REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xmy4_S_16 {
@ Space between 1.25xMy in NCP direction when one or both width = 0.08, 0.12um. >= 0.080um
 mets_RAW = 125xmy4_080 OR 125xmy4_120
 mets_CHK = ANGLE mets_RAW == 90
 err1 = EXT mets_CHK M4 < 0.08 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xmy4_S_17 {
@ Space between 1.25xMy (0.16um <= NCP direction width < 0.2um and CP direction width > 0.08um) and 1.25xMy edge (edge length > 0.08um in CP direction) in NCP direction >= 0.099um
 mets_L_sides = (INT [M4_v_edges] >= 0.16 < 0.2 ABUT<90 OPPOSITE EXCLUDE SHIELDED) COIN EDGE 125xmy4_gt_080
 mets_R_sides = LENGTH M4_v_edges > 0.08
 err1 = EXT mets_R_sides (mets_L_sides COIN EDGE mets_R_sides) < 0.099 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xmy4_S_18 {
@ Space between 1.25xMy in NCP direction when one or both width > 0.12um, PRL >= 0.121um. >= 0.119um
 err1_TMP = EXT 125xmy4_eqgt_121 M4_v_edges < 0.119 ABUT<90 OPPOSITE REGION
 err1 = err1_TMP ENCLOSE RECTANGLE 0.001 0.121 ORTHOGONAL ONLY
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xmy4_S_19 {
@ Space between 1.25xMy (NCP direction width >= 0.2um and CP direction width > 0.08um) and 1.25xMy edge (edge length > 0.08um in CP direction) in NCP direction >= 0.139um
 mets_L_sides = (INT (M4_v_edges) < 0.2 ABUT<90 OPPOSITE EXCLUDE SHIELDED) COIN EDGE 125xmy4_gt_080
 mets_R_sides = LENGTH M4_v_edges > 0.08
 err1 = EXT mets_R_sides (mets_L_sides COIN EDGE mets_R_sides) < 0.139 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xmy4_S_20 {
@ Space between 1.25xMy in NCP direction when one or both width > 0.16um, PRL > 0.2um. >= 0.159um
 err1_TMP = EXT 125xmy4_gt_160 M4_v_edges < 0.159 ABUT<90 OPPOSITE REGION
 err1 = err1_TMP ENCLOSE RECTANGLE 0.001 0.20+GLOBAL_TOLERANCE ORTHOGONAL ONLY
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xmy4_S_21 {
@ Space between 1.25xMy and 1.25xMy line-end (width = 0.04/0.042um) in NCP direction when PRL > -0.04um. >= 0.089um
 lend_RAW = LENGTH M4_convex_eq_two_edges >= 0.04 <= 0.042
 lend_CHK = ANGLE lend_RAW == 90
 err1 = EXT lend_CHK M4 < 0.089 ABUT<90 OPPOSITE EXTENDED 0.04 REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xmy4_S_21a {
@ Space between 1.25xMy and 1.25xMy line-end (width = 0.044/0.046/0.06um) in NCP direction when PRL > -0.04um. >= 0.080um
 lend_RAW_a = LENGTH M4_convex_eq_two_edges >= 0.044 <= 0.046
 lend_RAW_b = LENGTH M4_convex_eq_two_edges == 0.06
 lend_CHK = ANGLE (lend_RAW_a OR EDGE lend_RAW_b) == 90
 err1 = EXT lend_CHK M4 < 0.08 ABUT<90 OPPOSITE EXTENDED 0.04 REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xmy4_S_22 {
@ Space between 1.25xMy and 1.25xMy line-end (0.06um < width <= 0.08um) in NCP direction when PRL > -0.08um. >= 0.080um
 lend_RAW = LENGTH M4_convex_eq_two_edges > 0.06 <= 0.08
 lend_CHK = ANGLE lend_RAW == 90
 err1 = EXT lend_CHK M4 < 0.08 ABUT<90 OPPOSITE EXTENDED 0.08 REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xmy4_S_23 {
@ Space between 1.25xMy line-end (width < 0.08um) and U-shape inner edge (edge length <= 0.149um between two concave corners) in NCP direction >= 0.149um
 mets_U_sides = LENGTH M4_convex_270_270_edges <= 0.149
 err1 = EXT M4_end_080 mets_U_sides < 0.149 ABUT<90 OPPOSITE EXTENDED 0.04 REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xMy4_GROUP_80 = SIZE (SIZE (SIZE 125xmy4_040 BY 0.02) BY -0.04) BY 0.02
125xMy4_GROUP_90_1 = SIZE (SIZE (SIZE 125xmy4_044 BY 0.023) BY -0.046) BY 0.023
125xMy4_GROUP_90_2 = SIZE (SIZE (SIZE 125xmy4_042 BY 0.024) BY -0.048) BY 0.024
125xMy4_GROUP_90 = OR 125xMy4_GROUP_90_1 125xMy4_GROUP_90_2
 
125xmy4_S_24a {
@ Space between 1.25xMy_Group_80 and 1.25xMy_Group_90 in CP direction when PRL > -0.08um. >= 0.199um
@ 1.25xMy_Group_80 definition: (((1.25xMy (width = 0.040um) su 0.020um) su -0.040um) su 0.020um)
@ 1.25xMy_Group_90 definition: 1) (((1.25xMy (width = 0.044um) su 0.023um) sd -0.046um) su 0.023um). 2) (((1.25xMy (width = 0.042um) su 0.024um) sd -0.048um) su 0.024um)
 line_080 = ANGLE 125xMy4_GROUP_80 == 0
 line_090 = ANGLE 125xMy4_GROUP_90 == 0
 err1 = EXT line_080 line_090 < 0.199 ABUT<90 OPPOSITE EXTENDED 0.08 REGION MEASURE ALL
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xmy4_S_24b {
@ Space between 1.25xMy line-end of 1.25xMy_Group_80 and 1.25xMy line-end of 1.25xMy_Group_90 in NCP direction when PRL > -0.199um. >= 0.149um
 lend_080 = ANGLE (M4_end NOT OUTSIDE EDGE 125xMy4_GROUP_80) == 90
 lend_090 = ANGLE (M4_end NOT OUTSIDE EDGE 125xMy4_GROUP_90) == 90
 err1 = EXT lend_080 lend_090 < 0.149 ABUT<90 OPPOSITE EXTENDED 0.199 REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xmy4_S_25 {
@ Corner projected space between 1.25xMy when -0.08um < PRL <= 0um. >= 0.08um
@ Except line end-to-end (width <= 0.06um), Z-shape (edge length > 0.040um between two consecutive 90-270 degree corners, corresponding width = 0.08um in NCP direction between 2 opposite edge length > 0.040um, not including T-shape)
 line_end = (CONVEX EDGE M4 ANGLE1 == 90 ANGLE2 == 90 WITH LENGTH <= 0.06) COIN EDGE M4_v_edges
 // 
 zfig_shape_s_side = ANGLE (LENGTH M4_convex_90_90_edges == 0.08) == 0
 zfig_shape = (M4_width_eq_080 INTERACT (INT M4_convex_90_270_edges_gt_040 == 0.08 ABUT<90 OPPOSITE REGION)) NOT WITH EDGE zfig_shape_s_side
 waive_shape = COPY zfig_shape
 // 
 corner_space_prl_lt_0 = EXT M4 < 0.08*1.414 CORNER TO CORNER
 corner_space_prl_eq_0 = EXT line_end M4 < 0.08 PROJ == 0
 corner_space_all_TMP = DFM COPY corner_space_prl_lt_0 corner_space_prl_eq_0
 corner_space_all = DFM PROPERTY corner_space_all_TMP line_end waive_shape OVERLAP ABUT ALSO MULTI 
 [-= (count(line_end) > 0 && count(waive_shape) == 0) ? 1 : 0] > 0 
 [-= (EWXP(corner_space_all_TMP) < 0.08 && EWYP(corner_space_all_TMP) < 0.08) ? 1 : 0] > 0
 err1_TMP = DFM PROPERTY corner_space_all line_end OVERLAP ABUT ALSO MULTI [-= (count(line_end) == 0 || count(line_end) < 2) ? 1 : 0] > 0
 err1 = DFM COPY err1_TMP REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xmy4_S_25a {
@ Corner space between 1.25xMy in NCP direction when -0.04um < PRL <= 0um. >= 0.08um
 err1_RAW = EXT M4 < 0.08 ABUT<90 CORNER TO CORNER
 err1_TMP = DFM PROPERTY err1_RAW GLOBALXY [-= EWYP(err1_RAW)] < 0.04
 err1_SPE = EXT M4 M4_v_edges < 0.08 ABUT<90 REGION PROJ == 0
 err1 = (DFM COPY err1_TMP REGION) OR err1_SPE
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xmy4_S_26 {
@ At least one space between 1.25xMy edge (any adjacent edge of concave corner) and 1.25xMy >= 0.119um, except either condition as below
@ 1. Edge length between two concave corners < 0.12um
@ 2. Side edge length of concave corner < 0.042um
 waive_edge_a = LENGTH M4_convex_270_270_edges < 0.120
 waive_edge_b = LENGTH M4_convex_lt_two_edges < 0.042
 check_edge = (LENGTH M4_convex_lt_two_edges >= 0.042) NOT COIN EDGE M4_45_skew_edges
 // 
 Y1 = EXT [M4] check_edge < 0.119 ABUT<90 OPPOSITE EXTENDED 0.119
 Y2 = INT [Y1] < 0.001 ABUT==90 INTERSECTING ONLY
 Y3 = EXT Y2 check_edge < 0.119 ABUT<90 OPPOSITE EXTENDED 0.119
 err1_TMP = EXT (DFM COPY Y3 EDGE) < 0.04 ABUT==90 INTERSECTING ONLY REGION EXTENTS
 err1 = (err1_TMP NOT WITH EDGE waive_edge_a) NOT WITH EDGE waive_edge_b
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xmy4_S_27 {
@ Space between 1.25xMy concave corner (both side edge length > 0.08um) and 1.25xMy line-end (width < 0.08um) >= 0.154um
 mets_CHK = LENGTH M4_convex_lt_two_edges > 0.08
 mets_CRN = EXT [mets_CHK] < 0.0005 ABUT==90 INTERSECTING ONLY // resolution concern
 // 
 err1_RAW = EXT M4_convex_lt_two_edges M4_end_080 < 0.154 ABUT EXCLUDE SHIELDED
 err1_HAS = mets_CRN COIN EDGE M4_convex_lt_two_edges
 err1_TMP = DFM PROPERTY err1_RAW err1_HAS ABUT ALSO OVERLAP MULTI [-= count(err1_HAS)] > 0
 err1 = DFM COPY err1_TMP REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
M4_space_eq_040_h_edges = EXT [M4_h_edges] == 0.04 OPPOSITE
M4_space_eq_040_h_areas = EXT M4_h_edges == 0.04 OPPOSITE REGION
M4_space_eq_040_h_areas_h_edges = ANGLE M4_space_eq_040_h_areas == 0
M4_width_lt_080_h_edges = (INT [M4_h_edges] < 0.08 ABUT<90 OPPOSITE) COIN EDGE (M4 WITH WIDTH < 0.08)
 
125xmy4_S_28 {
@ Fobidden space between 1.25xMy (width = 0.04~0.046um and one side space = 0.04um) and 1.25xMy (width < 0.08um) in CP direction, except both side space of 1.25xMy (width < 0.08um) to 1.25xMy >= 0.1um. = 0.061~0.098, 0.131~0.178um
 Mn_w040_w042 = WITH WIDTH M4 >= 0.04 <= 0.046
 Mn_w040_s040_h_edges = Mn_w040_w042 COIN EDGE M4_space_eq_040_h_edges
 Mn_w040_s040_h_edges_opp = INT Mn_w040_s040_h_edges [Mn_w040_w042] >= 0.04 <= 0.046 ABUT<90 OPPOSITE
 // not check W1 >= 0.08
 // 
 Mn_w080_s99_h_edges = EXT (M4_width_lt_080_h_edges) < 0.10 ABUT<90 OPPOSITE
 Mn_w080_s99_h_edges_both = INT [Mn_w080_s99_h_edges] < 0.08 ABUT<90 OPPOSITE
 Mn_w080_s99_h_edges_none = M4_width_lt_080_h_edges NOT COIN EDGE Mn_w080_s99_h_edges_both
 err1 = EXT Mn_w080_s99_h_edges_none Mn_w040_s040_h_edges_opp >= 0.131 <= 0.178 ABUT<90 OPPOSITE REGION EXCLUDE SHIELDED
 err2 = EXT Mn_w080_s99_h_edges_none Mn_w040_s040_h_edges_opp >= 0.061 <= 0.098 ABUT<90 OPPOSITE REGION EXCLUDE SHIELDED
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}
 
125xmy4_S_29 {
@ Fobidden space between 1.25xMy (width = 0.06~0.07um and one side space = 0.04um) and 1.25xMy (width < 0.08um) in CP direction, except both side space of 1.25xMy (width < 0.08um) to 1.25xMy >= 0.1um. = 0.11~0.158um
 Mn_w060_w070 = WITH WIDTH M4 >= 0.06 <= 0.07
 Mn_w060_s040_h_edges = Mn_w060_w070 COIN EDGE M4_space_eq_040_h_edges
 Mn_w060_s040_h_edges_opp = INT Mn_w060_s040_h_edges [Mn_w060_w070] >= 0.06 <= 0.07 ABUT<90 OPPOSITE
 // not check W1 >= 0.08
 // 
 Mn_w080_s99_h_edges = EXT (M4_width_lt_080_h_edges) < 0.10 ABUT<90 OPPOSITE
 Mn_w080_s99_h_edges_both = INT [Mn_w080_s99_h_edges] < 0.08 ABUT<90 OPPOSITE
 Mn_w080_s99_h_edges_none = M4_width_lt_080_h_edges NOT COIN EDGE Mn_w080_s99_h_edges_both
 err1 = EXT Mn_w080_s99_h_edges_none Mn_w060_s040_h_edges_opp >= 0.110 <= 0.158 ABUT<90 OPPOSITE REGION EXCLUDE SHIELDED
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xmy4_S_30 {
@ Space between 1.25xMy and 45-degree bent 1.25xMy, DRC check 45-degree direction >= 0.396um
 err1 = EXT M4 M4_45_skew_edges < 0.396 ABUT<90 OPPOSITE2 REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
//;125xmy_S_31~125xmy_S_37a: detla voltage rule
 
125xmy4_L_1 {
@ Length of 45-degree bent 1.25xMy, except MARKS >= 0.905um
 err1 = LENGTH M4_45_skew_edges < 0.905
 err1 NOT INSIDE EDGE MARKS
}
 
125xmy4_L_2 {
@ 1.25xMy edge length when the adjacent edge length <= 0.089um, except two 0.08um edges form a convex corner. >= 0.099um
 chk_condition = LENGTH M4 <= 0.089
 err_EdgLength = LENGTH M4 < 0.099
 waive_CASE = INT (LENGTH chk_condition == 0.08) (LENGTH err_EdgLength == 0.08) < 0.005 ABUT INTERSECTING ONLY REGION
 err1_TMP_A = EXT chk_condition err_EdgLength < 0.005 ABUT INTERSECTING ONLY REGION
 err1_TMP_B = (INT chk_condition err_EdgLength < 0.005 ABUT INTERSECTING ONLY REGION) NOT INTERACT waive_CASE
 err1 = OR (EXPAND EDGE (M4 TOUCH EDGE err1_TMP_A) OUTSIDE BY 0.001 EXTEND BY 0.001) (EXPAND EDGE (M4 TOUCH EDGE err1_TMP_B) OUTSIDE BY 0.001 EXTEND BY 0.001)
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xmy4_L_3 {
@ 1.25xMy edge length when the adjacent edge length < 0.04um. >= 0.119um
 chk_condition = LENGTH M4 < 0.04
 err_EdgLength = LENGTH M4 < 0.119
 err1_TMP_A = EXT chk_condition err_EdgLength < 0.005 ABUT INTERSECTING ONLY REGION
 err1_TMP_B = INT chk_condition err_EdgLength < 0.005 ABUT INTERSECTING ONLY REGION
 err1 = OR (EXPAND EDGE (M4 TOUCH EDGE err1_TMP_A) OUTSIDE BY 0.001 EXTEND BY 0.001) (EXPAND EDGE (M4 TOUCH EDGE err1_TMP_B) OUTSIDE BY 0.001 EXTEND BY 0.001)
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xmy4_L_4 {
@ 1.25xMy edge length when the adjacent line-end width < 0.060um. >= 0.159um
 chk_condition = EXPAND EDGE M4_end_060 INSIDE BY 0.001
 err_EdgLength = (M4_convex_eq_one_edges TOUCH EDGE chk_condition) NOT COIN EDGE M4_end_060
 err1 = LENGTH err_EdgLength < 0.159
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
125xmy4_L_5 {
@ 1.25xMy edge length when the adjacent line-end width < 0.08um. >= 0.109um
 chk_condition = EXPAND EDGE M4_end_080 INSIDE BY 0.001
 err_EdgLength = (M4_convex_eq_one_edges TOUCH EDGE chk_condition) NOT COIN EDGE M4_end_080
 err1 = LENGTH err_EdgLength < 0.109
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
125xmy4_L_6 {
@ 1.25xMy edge length between two consecutive 90-270 degree corners >= 0.019um
 // DRC also check the condition with at least one 90-270 degree corners
 mets_ERRS_EDGE = LENGTH M4_convex_270_90_edges < 0.019
 mets_ERRS_a = INT mets_ERRS_EDGE M4_convex_eq_one_edges < 0.005 ABUT==90 INTERSECTING ONLY REGION
 mets_ERRS_b = EXT mets_ERRS_EDGE M4_convex_eq_one_edges < 0.005 ABUT==90 INTERSECTING ONLY REGION
 err1_TMP = (M4_convex_eq_one_edges TOUCH EDGE mets_ERRS_a) OR EDGE (M4_convex_eq_one_edges TOUCH EDGE mets_ERRS_b)
 err1 = EXPAND EDGE err1_TMP INSIDE BY 0.001 CORNER FILL
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xmy4_L_7 {
@ 1.25xMy edge length between two consecutive 90-270 degree corners with one adjacent line end width < 0.08um and the other adjacent edge length > 0.07um. >= 0.238um
 line_CHK_a_RAW = LENGTH M4_convex_270_90_edges > 0.07 < 0.238
 line_CHK_a_TMP = EXPAND EDGE M4_end_080 INSIDE BY 0.001
 line_CHK_a = (line_CHK_a_RAW NOT TOUCH EDGE M4_end_080) TOUCH EDGE line_CHK_a_TMP
 line_CHK_b = LENGTH M4_convex_lt_two_edges > 0.07
 err1 = EXT line_CHK_b line_CHK_a < 0.005 ABUT==90 INTERSECTING REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xmy4_L_8 {
@ 1.25xMy U-shape inner edge length between two consecutive 270-270 degree corners >= 0.08um
 err1 = LENGTH M4_convex_270_270_edges < 0.08
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
125xmy4_L_9_V3 {
@ Length of 1.25xMy metal branch (width <= 0.269um) >= 1um
@ When:
@ 1) Metal branch is connected to wide metal with width and length >= 0.398um
@ 2) One square Vy-1/1.25xVn in metal branch, and space to wide metal <= 1um
@ DRC flags branch that can't enclose a 0.08*1um orthogonal rectangle
@ ("V3_40" is mapped to "V3" in the rule name of this check)
 WIDE_M4 = (WITH WIDTH M4 > 0.398-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 0.398-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 0.398-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 branch_all = ((SIZE WIDE_M4 BY 1+GLOBAL_TOLERANCE INSIDE OF M4 STEP 0.025) NOT WIDE_M4) AND M4
 branch_size = INT (M4 INTERACT branch_all) < 0.269+GLOBAL_TOLERANCE ABUT<90 OPPOSITE REGION EXCLUDE SHIELDED
 branch_real = branch_size INTERACT WIDE_M4
 branch_down = (branch_real AND M3) INTERACT DVK_V3_SQ == 1
 branch_down_real = ((M4 INTERACT branch_down) AND M3) INTERACT DVK_V3_SQ == 1
 branch_down_err1 = branch_real NOT OUTSIDE branch_down_real
 err1_down = branch_down_err1 NOT ENCLOSE RECTANGLE 0.08 1 ORTHOGONAL ONLY
 // 
 branch_up = (branch_real AND M5) INTERACT (RECTANGLE V4 ASPECT == 1) == 1
 branch_up_real = ((M4 INTERACT branch_up) AND M5) INTERACT (RECTANGLE V4 ASPECT == 1) == 1
 branch_up_err2 = branch_real NOT OUTSIDE branch_up_real
 err2_up = branch_up_err2 NOT ENCLOSE RECTANGLE 0.08 1 ORTHOGONAL ONLY
 err1_down NOT INSIDE SealR_NOT_BULK
}
 
125xmy4_L_9_V4 {
@ Length of 1.25xMy metal branch (width <= 0.269um) >= 1um
@ When:
@ 1) Metal branch is connected to wide metal with width and length >= 0.398um
@ 2) One square Vy-1/1.25xVn in metal branch, and space to wide metal <= 1um
@ DRC flags branch that can't enclose a 0.08*1um orthogonal rectangle
@ ("V4_50" is mapped to "V4" in the rule name of this check)
 WIDE_M4 = (WITH WIDTH M4 > 0.398-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 0.398-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 0.398-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 branch_all = ((SIZE WIDE_M4 BY 1+GLOBAL_TOLERANCE INSIDE OF M4 STEP 0.025) NOT WIDE_M4) AND M4
 branch_size = INT (M4 INTERACT branch_all) < 0.269+GLOBAL_TOLERANCE ABUT<90 OPPOSITE REGION EXCLUDE SHIELDED
 branch_real = branch_size INTERACT WIDE_M4
 branch_down = (branch_real AND M3) INTERACT DVK_V3_SQ == 1
 branch_down_real = ((M4 INTERACT branch_down) AND M3) INTERACT DVK_V3_SQ == 1
 branch_down_err1 = branch_real NOT OUTSIDE branch_down_real
 err1_down = branch_down_err1 NOT ENCLOSE RECTANGLE 0.08 1 ORTHOGONAL ONLY
 // 
 branch_up = (branch_real AND M5) INTERACT (RECTANGLE V4 ASPECT == 1) == 1
 branch_up_real = ((M4 INTERACT branch_up) AND M5) INTERACT (RECTANGLE V4 ASPECT == 1) == 1
 branch_up_err2 = branch_real NOT OUTSIDE branch_up_real
 err2_up = branch_up_err2 NOT ENCLOSE RECTANGLE 0.08 1 ORTHOGONAL ONLY
 err2_up NOT INSIDE SealR_NOT_BULK
}
 
125xmy4_L_10_V3 {
@ Length of 1.25xMy metal branch (width <= 0.269um) >= 3um
@ When:
@ 1) Metal branch is connected to wide metal with width and length >= 0.542um
@ 2) One square Vy-1/1.25xVn in metal branch, and space to wide metal <= 3um
@ DRC flags branch that can't enclose a 0.08*3um orthogonal rectangle
@ ("V3_40" is mapped to "V3" in the rule name of this check)
 WIDE_M4 = (WITH WIDTH M4 > 0.542-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 0.542-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 0.542-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 branch_all = ((SIZE WIDE_M4 BY 3+GLOBAL_TOLERANCE INSIDE OF M4 STEP 0.025) NOT WIDE_M4) AND M4
 branch_size = INT (M4 INTERACT branch_all) < 0.269+GLOBAL_TOLERANCE ABUT<90 OPPOSITE REGION EXCLUDE SHIELDED
 branch_real = branch_size INTERACT WIDE_M4
 branch_down = (branch_real AND M3) INTERACT DVK_V3_SQ == 1
 branch_down_real = ((M4 INTERACT branch_down) AND M3) INTERACT DVK_V3_SQ == 1
 branch_down_err1 = branch_real NOT OUTSIDE branch_down_real
 err1_down = branch_down_err1 NOT ENCLOSE RECTANGLE 0.08 3 ORTHOGONAL ONLY
 // 
 branch_up = (branch_real AND M5) INTERACT (RECTANGLE V4 ASPECT == 1) == 1
 branch_up_real = ((M4 INTERACT branch_up) AND M5) INTERACT (RECTANGLE V4 ASPECT == 1) == 1
 branch_up_err2 = branch_real NOT OUTSIDE branch_up_real
 err2_up = branch_up_err2 NOT ENCLOSE RECTANGLE 0.08 3 ORTHOGONAL ONLY
 err1_down NOT INSIDE SealR_NOT_BULK
}
 
125xmy4_L_10_V4 {
@ Length of 1.25xMy metal branch (width <= 0.269um) >= 3um
@ When:
@ 1) Metal branch is connected to wide metal with width and length >= 0.542um
@ 2) One square Vy-1/1.25xVn in metal branch, and space to wide metal <= 3um
@ DRC flags branch that can't enclose a 0.08*3um orthogonal rectangle
@ ("V4_50" is mapped to "V4" in the rule name of this check)
 WIDE_M4 = (WITH WIDTH M4 > 0.542-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 0.542-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 0.542-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 branch_all = ((SIZE WIDE_M4 BY 3+GLOBAL_TOLERANCE INSIDE OF M4 STEP 0.025) NOT WIDE_M4) AND M4
 branch_size = INT (M4 INTERACT branch_all) < 0.269+GLOBAL_TOLERANCE ABUT<90 OPPOSITE REGION EXCLUDE SHIELDED
 branch_real = branch_size INTERACT WIDE_M4
 branch_down = (branch_real AND M3) INTERACT DVK_V3_SQ == 1
 branch_down_real = ((M4 INTERACT branch_down) AND M3) INTERACT DVK_V3_SQ == 1
 branch_down_err1 = branch_real NOT OUTSIDE branch_down_real
 err1_down = branch_down_err1 NOT ENCLOSE RECTANGLE 0.08 3 ORTHOGONAL ONLY
 // 
 branch_up = (branch_real AND M5) INTERACT (RECTANGLE V4 ASPECT == 1) == 1
 branch_up_real = ((M4 INTERACT branch_up) AND M5) INTERACT (RECTANGLE V4 ASPECT == 1) == 1
 branch_up_err2 = branch_real NOT OUTSIDE branch_up_real
 err2_up = branch_up_err2 NOT ENCLOSE RECTANGLE 0.08 3 ORTHOGONAL ONLY
 err2_up NOT INSIDE SealR_NOT_BULK
}
 
125xmy4_L_11_V3 {
@ Length of 1.25xMy metal branch (width <= 0.269um) >= 5um
@ When:
@ 1) Metal branch is connected to wide metal with width and length > 1um
@ 2) One square Vy-1/1.25xVn in metal branch, and space to wide metal <= 5um
@ DRC flags branch that can't enclose a 0.08*5um orthogonal rectangle
@ ("V3_40" is mapped to "V3" in the rule name of this check)
 WIDE_M4 = (WITH WIDTH M4 > 1.0) ENCLOSE RECTANGLE 1.0+GLOBAL_TOLERANCE 1.0+GLOBAL_TOLERANCE
 branch_all = ((SIZE WIDE_M4 BY 5+GLOBAL_TOLERANCE INSIDE OF M4 STEP 0.025) NOT WIDE_M4) AND M4
 branch_size = INT (M4 INTERACT branch_all) < 0.269+GLOBAL_TOLERANCE ABUT<90 OPPOSITE REGION EXCLUDE SHIELDED
 branch_real = branch_size INTERACT WIDE_M4
 branch_down = (branch_real AND M3) INTERACT DVK_V3_SQ == 1
 branch_down_real = ((M4 INTERACT branch_down) AND M3) INTERACT DVK_V3_SQ == 1
 branch_down_err1 = branch_real NOT OUTSIDE branch_down_real
 err1_down = branch_down_err1 NOT ENCLOSE RECTANGLE 0.08 5 ORTHOGONAL ONLY
 // 
 branch_up = (branch_real AND M5) INTERACT (RECTANGLE V4 ASPECT == 1) == 1
 branch_up_real = ((M4 INTERACT branch_up) AND M5) INTERACT (RECTANGLE V4 ASPECT == 1) == 1
 branch_up_err2 = branch_real NOT OUTSIDE branch_up_real
 err2_up = branch_up_err2 NOT ENCLOSE RECTANGLE 0.08 5 ORTHOGONAL ONLY
 err1_down NOT INSIDE SealR_NOT_BULK
}
 
125xmy4_L_11_V4 {
@ Length of 1.25xMy metal branch (width <= 0.269um) >= 5um
@ When:
@ 1) Metal branch is connected to wide metal with width and length > 1um
@ 2) One square Vy-1/1.25xVn in metal branch, and space to wide metal <= 5um
@ DRC flags branch that can't enclose a 0.08*5um orthogonal rectangle
@ ("V4_50" is mapped to "V4" in the rule name of this check)
 WIDE_M4 = (WITH WIDTH M4 > 1.0) ENCLOSE RECTANGLE 1.0+GLOBAL_TOLERANCE 1.0+GLOBAL_TOLERANCE
 branch_all = ((SIZE WIDE_M4 BY 5+GLOBAL_TOLERANCE INSIDE OF M4 STEP 0.025) NOT WIDE_M4) AND M4
 branch_size = INT (M4 INTERACT branch_all) < 0.269+GLOBAL_TOLERANCE ABUT<90 OPPOSITE REGION EXCLUDE SHIELDED
 branch_real = branch_size INTERACT WIDE_M4
 branch_down = (branch_real AND M3) INTERACT DVK_V3_SQ == 1
 branch_down_real = ((M4 INTERACT branch_down) AND M3) INTERACT DVK_V3_SQ == 1
 branch_down_err1 = branch_real NOT OUTSIDE branch_down_real
 err1_down = branch_down_err1 NOT ENCLOSE RECTANGLE 0.08 5 ORTHOGONAL ONLY
 // 
 branch_up = (branch_real AND M5) INTERACT (RECTANGLE V4 ASPECT == 1) == 1
 branch_up_real = ((M4 INTERACT branch_up) AND M5) INTERACT (RECTANGLE V4 ASPECT == 1) == 1
 branch_up_err2 = branch_real NOT OUTSIDE branch_up_real
 err2_up = branch_up_err2 NOT ENCLOSE RECTANGLE 0.08 5 ORTHOGONAL ONLY
 err2_up NOT INSIDE SealR_NOT_BULK
}
 
125xmy4_A_1 {
@ 1.25xMy area >= 0.0148um2
 err1 = AREA M4 < 0.0148
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xmy4_A_2 {
@ 1.25xMy area when all of edge length <= 0.115um, except can fill 0.05*0.13um rectangle >= 0.039um2
 M4_waive = ENCLOSE RECTANGLE M4 0.050 0.130 ORTHOGONAL ONLY
 M4_check = AREA M4 < 0.039
 M4_edge_all = LENGTH M4_check > 0.115
 err1 = (M4_check NOT WITH EDGE M4_edge_all) NOT M4_waive
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xmy4_A_3 {
@ 1.25xMy enclosed area >= 0.181um2
 err1 = AREA ((HOLES M4 INNER) NOT M4) < 0.181
 err1 NOT INSIDE SealR_NOT_BULK
}
 

#IFDEF IP_LEVEL_DENSITY_CHECK YES
#IFDEF MINIMUM_DENSITY_CHECK YES

125xmy4_DN_1 {
@ 1.25xMy Density (window 50um*50um, stepping 50um/step_number), except LOGO, MARKS, (OCOVL AND MnDUB), (NODMF su 1um) regions >= 10%
 except_area = OR LOGO MARKS (OCOVL AND M4DUB) NODMF_SIZE_1
 check_region = DRC:1 NOT except_area
 check_pattern = M4_all AND check_region
 // 
 check_window1 = check_region WITH WIDTH >= 50/4
 err1_TMP1 = DENSITY check_pattern check_window1 check_region [!AREA(check_window1) + !!AREA(check_window1)*AREA(check_pattern)/AREA(check_region)] < 0.105 WINDOW 50 STEP 50/step_number BACKUP INSIDE OF LAYER DRC:1 BY POLYGON
 // 
 check_window2 = WITH WIDTH (check_region AND err1_TMP1) >= 50/4
 err1_TMP2 = DENSITY check_pattern check_window2 check_region [!AREA(check_window2) + !!AREA(check_window2)*AREA(check_pattern)/AREA(check_region)] < 0.105 WINDOW 50 STEP 50/step_number BACKUP INSIDE OF LAYER err1_TMP1 BY POLYGON
 // 
 check_window3 = WITH WIDTH (check_region AND err1_TMP2) >= 50/4
 DENSITY check_pattern check_window3 check_region [!AREA(check_window3) + !!AREA(check_window3)*AREA(check_pattern)/AREA(check_region)] < 0.105 WINDOW 50 STEP 50/step_number BACKUP INSIDE OF LAYER err1_TMP2 BY POLYGON PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_125xmy4_DN_1.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_125xmy4_DN_1.rdb"
}
 
125xmy4_DN_1a {
@ 1.25xMy Density (window 50um*50um, stepping 50um/step_number), except the window not interact 3um*3um empty area, LOGO, MARKS, (OCOVL AND MnDUB), (NODMF su 1um) regions >= 26.3%
 except_area = OR LOGO MARKS (OCOVL AND M4DUB) NODMF_SIZE_1
 check_region = DRC:1 NOT except_area
 ck3x3_window = WITH WIDTH (check_region NOT M4_all) >= 3
 check_pattern = M4_all AND check_region
 // 
 check_window1 = check_region WITH WIDTH >= 50/4
 err1_TMP1 = DENSITY check_pattern check_window1 check_region ck3x3_window [!AREA(ck3x3_window) + !AREA(check_window1) + !!AREA(ck3x3_window)*!!AREA(check_window1)*AREA(check_pattern)/AREA(check_region)] < 0.263 WINDOW 50 STEP 50/step_number BACKUP INSIDE OF LAYER DRC:1 BY POLYGON
 // 
 check_window2 = WITH WIDTH (check_region AND err1_TMP1) >= 50/4
 err1_TMP2 = DENSITY check_pattern check_window2 check_region ck3x3_window [!AREA(ck3x3_window) + !AREA(check_window2) + !!AREA(ck3x3_window)*!!AREA(check_window2)*AREA(check_pattern)/AREA(check_region)] < 0.263 WINDOW 50 STEP 50/step_number BACKUP INSIDE OF LAYER err1_TMP1 BY POLYGON
 // 
 check_window3 = WITH WIDTH (check_region AND err1_TMP2) >= 50/4
 DENSITY check_pattern check_window3 check_region ck3x3_window [!AREA(ck3x3_window) + !AREA(check_window3) + !!AREA(ck3x3_window)*!!AREA(check_window3)*AREA(check_pattern)/AREA(check_region)] < 0.263 WINDOW 50 STEP 50/step_number BACKUP INSIDE OF LAYER err1_TMP2 BY POLYGON PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_125xmy4_DN_1a.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_125xmy4_DN_1a.rdb"
}

#ENDIF


#IFDEF RECOMMENDED_CHECK YES

 
125xmy4_DN_2_R {
@ 1.25xMy maximum density (window 50um*50um, stepping 25um), except dummy metal <= 65%
 check_region = COPY CHIP_NOT_MARKS
 check_pattern = M4 AND check_region
 // 
 check_window1 = check_region WITH WIDTH >= 50/4
 err1_TMP1 = DENSITY check_pattern check_window1 check_region [!!AREA(check_window1)*AREA(check_pattern)/AREA(check_region)] > 0.65 WINDOW 50 STEP 25 BACKUP INSIDE OF LAYER DRC:1 BY POLYGON
 // 
 check_window2 = WITH WIDTH (check_region AND err1_TMP1) >= 50/4
 err1_TMP2 = DENSITY check_pattern check_window2 check_region [!!AREA(check_window2)*AREA(check_pattern)/AREA(check_region)] > 0.65 WINDOW 50 STEP 25 BACKUP INSIDE OF LAYER err1_TMP1 BY POLYGON
 // 
 check_window3 = WITH WIDTH (check_region AND err1_TMP2) >= 50/4
 DENSITY check_pattern check_window3 check_region [!!AREA(check_window3)*AREA(check_pattern)/AREA(check_region)] > 0.65 WINDOW 50 STEP 25 BACKUP INSIDE OF LAYER err1_TMP2 BY POLYGON PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_125xmy4_DN_2_R.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_125xmy4_DN_2_R.rdb"
}

#ENDIF

 
125xmy4_DN_3 {
@ 1.25xMy maximum density (window 50um*50um, stepping 50um/step_number) <= 71.3%
 check_region = COPY CHIP_NOT_MARKS
 check_pattern = M4_all AND check_region
 // 
 check_window1 = check_region WITH WIDTH >= 50/4
 err1_TMP1 = DENSITY check_pattern check_window1 check_region [!!AREA(check_window1)*AREA(check_pattern)/AREA(check_region)] > 0.713 WINDOW 50 STEP 50/step_number BACKUP INSIDE OF LAYER DRC:1 BY POLYGON
 // 
 check_window2 = WITH WIDTH (check_region AND err1_TMP1) >= 50/4
 err1_TMP2 = DENSITY check_pattern check_window2 check_region [!!AREA(check_window2)*AREA(check_pattern)/AREA(check_region)] > 0.713 WINDOW 50 STEP 50/step_number BACKUP INSIDE OF LAYER err1_TMP1 BY POLYGON
 // 
 check_window3 = WITH WIDTH (check_region AND err1_TMP2) >= 50/4
 DENSITY check_pattern check_window3 check_region [!!AREA(check_window3)*AREA(check_pattern)/AREA(check_region)] > 0.713 WINDOW 50 STEP 50/step_number BACKUP INSIDE OF LAYER err1_TMP2 BY POLYGON PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_125xmy4_DN_3.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_125xmy4_DN_3.rdb"
}
 
125xmy4_DN_4 {
@ 1.25xMy density difference between two neighboring checking windows (window 180um*180um, stepping 360um/step_number), except (NODMF su 0.4um) region <= 47.5%
 except_area = OR MARKS NODMF_SIZE_0.4
 check_pattern = M4_all NOT except_area
 check_region = DRC:1 NOT except_area
 DENSITY check_pattern check_region [AREA(check_pattern)/AREA(check_region)] >= 0 WINDOW 180 STEP 360/step_number GRADIENT > 0.475 ABSOLUTE BACKUP PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_125xmy4_DN_4.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_125xmy4_DN_4.rdb"
}
 

#IFDEF MINIMUM_DENSITY_CHECK YES


#ENDIF
#ENDIF

 

#IFDEF IP_LEVEL_DENSITY_CHECK NO
#IFDEF MINIMUM_DENSITY_CHECK YES

125xmy4_DN_1 {
@ 1.25xMy Density (window 50um*50um, stepping 25um), except LOGO, MARKS, (OCOVL AND MnDUB), (NODMF su 1um) regions >= 10%
 except_area = OR LOGO MARKS (OCOVL AND M4DUB) NODMF_SIZE_1
 check_region = DRC:1 NOT except_area
 check_pattern = M4_all AND check_region
 // 
 check_window1 = check_region WITH WIDTH >= 50/4
 err1_TMP1 = DENSITY check_pattern check_window1 check_region [!AREA(check_window1) + !!AREA(check_window1)*AREA(check_pattern)/AREA(check_region)] < 0.1 WINDOW 50 STEP 25 BACKUP INSIDE OF LAYER DRC:1 BY POLYGON
 // 
 check_window2 = WITH WIDTH (check_region AND err1_TMP1) >= 50/4
 err1_TMP2 = DENSITY check_pattern check_window2 check_region [!AREA(check_window2) + !!AREA(check_window2)*AREA(check_pattern)/AREA(check_region)] < 0.1 WINDOW 50 STEP 25 BACKUP INSIDE OF LAYER err1_TMP1 BY POLYGON
 // 
 check_window3 = WITH WIDTH (check_region AND err1_TMP2) >= 50/4
 DENSITY check_pattern check_window3 check_region [!AREA(check_window3) + !!AREA(check_window3)*AREA(check_pattern)/AREA(check_region)] < 0.1 WINDOW 50 STEP 25 BACKUP INSIDE OF LAYER err1_TMP2 BY POLYGON PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_125xmy4_DN_1.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_125xmy4_DN_1.rdb"
}
 
125xmy4_DN_1a {
@ 1.25xMy Density (window 50um*50um, stepping 25um), except the window not interact 3um*3um empty area, LOGO, MARKS, (OCOVL AND MnDUB), (NODMF su 1um) regions >= 25%
 except_area = OR LOGO MARKS (OCOVL AND M4DUB) NODMF_SIZE_1
 check_region = DRC:1 NOT except_area
 ck3x3_window = WITH WIDTH (check_region NOT M4_all) >= 3
 check_pattern = M4_all AND check_region
 // 
 check_window1 = check_region WITH WIDTH >= 50/4
 err1_TMP1 = DENSITY check_pattern check_window1 check_region ck3x3_window [!AREA(ck3x3_window) + !AREA(check_window1) + !!AREA(ck3x3_window)*!!AREA(check_window1)*AREA(check_pattern)/AREA(check_region)] < 0.25 WINDOW 50 STEP 25 BACKUP INSIDE OF LAYER DRC:1 BY POLYGON
 // 
 check_window2 = WITH WIDTH (check_region AND err1_TMP1) >= 50/4
 err1_TMP2 = DENSITY check_pattern check_window2 check_region ck3x3_window [!AREA(ck3x3_window) + !AREA(check_window2) + !!AREA(ck3x3_window)*!!AREA(check_window2)*AREA(check_pattern)/AREA(check_region)] < 0.25 WINDOW 50 STEP 25 BACKUP INSIDE OF LAYER err1_TMP1 BY POLYGON
 // 
 check_window3 = WITH WIDTH (check_region AND err1_TMP2) >= 50/4
 DENSITY check_pattern check_window3 check_region ck3x3_window [!AREA(ck3x3_window) + !AREA(check_window3) + !!AREA(ck3x3_window)*!!AREA(check_window3)*AREA(check_pattern)/AREA(check_region)] < 0.25 WINDOW 50 STEP 25 BACKUP INSIDE OF LAYER err1_TMP2 BY POLYGON PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_125xmy4_DN_1a.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_125xmy4_DN_1a.rdb"
}

#ENDIF


#IFDEF RECOMMENDED_CHECK YES

 
125xmy4_DN_2_R {
@ 1.25xMy maximum density (window 50um*50um, stepping 25um), except dummy metal <= 65%
 check_region = COPY CHIP_NOT_MARKS
 check_pattern = M4 AND check_region
 // 
 check_window1 = check_region WITH WIDTH >= 50/4
 err1_TMP1 = DENSITY check_pattern check_window1 check_region [!!AREA(check_window1)*AREA(check_pattern)/AREA(check_region)] > 0.65 WINDOW 50 STEP 25 BACKUP INSIDE OF LAYER DRC:1 BY POLYGON
 // 
 check_window2 = WITH WIDTH (check_region AND err1_TMP1) >= 50/4
 err1_TMP2 = DENSITY check_pattern check_window2 check_region [!!AREA(check_window2)*AREA(check_pattern)/AREA(check_region)] > 0.65 WINDOW 50 STEP 25 BACKUP INSIDE OF LAYER err1_TMP1 BY POLYGON
 // 
 check_window3 = WITH WIDTH (check_region AND err1_TMP2) >= 50/4
 DENSITY check_pattern check_window3 check_region [!!AREA(check_window3)*AREA(check_pattern)/AREA(check_region)] > 0.65 WINDOW 50 STEP 25 BACKUP INSIDE OF LAYER err1_TMP2 BY POLYGON PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_125xmy4_DN_2_R.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_125xmy4_DN_2_R.rdb"
}

#ENDIF

 
125xmy4_DN_3 {
@ 1.25xMy maximum density (window 50um*50um, stepping 25um) <= 75%
 check_region = COPY CHIP_NOT_MARKS
 check_pattern = M4_all AND check_region
 // 
 check_window1 = check_region WITH WIDTH >= 50/4
 err1_TMP1 = DENSITY check_pattern check_window1 check_region [!!AREA(check_window1)*AREA(check_pattern)/AREA(check_region)] > 0.75 WINDOW 50 STEP 25 BACKUP INSIDE OF LAYER DRC:1 BY POLYGON
 // 
 check_window2 = WITH WIDTH (check_region AND err1_TMP1) >= 50/4
 err1_TMP2 = DENSITY check_pattern check_window2 check_region [!!AREA(check_window2)*AREA(check_pattern)/AREA(check_region)] > 0.75 WINDOW 50 STEP 25 BACKUP INSIDE OF LAYER err1_TMP1 BY POLYGON
 // 
 check_window3 = WITH WIDTH (check_region AND err1_TMP2) >= 50/4
 DENSITY check_pattern check_window3 check_region [!!AREA(check_window3)*AREA(check_pattern)/AREA(check_region)] > 0.75 WINDOW 50 STEP 25 BACKUP INSIDE OF LAYER err1_TMP2 BY POLYGON PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_125xmy4_DN_3.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_125xmy4_DN_3.rdb"
}
 
125xmy4_DN_4 {
@ 1.25xMy density difference between two neighboring checking windows (window 180um*180um, stepping 180um), except (NODMF su 0.4um) region <= 50%
 except_area = OR MARKS NODMF_SIZE_0.4
 check_pattern = M4_all NOT except_area
 check_region = DRC:1 NOT except_area
 DENSITY check_pattern check_region [AREA(check_pattern)/AREA(check_region)] >= 0 WINDOW 180 STEP 180 GRADIENT > 0.5 ABSOLUTE BACKUP PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_125xmy4_DN_4.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_125xmy4_DN_4.rdb"
}
 

#IFDEF MINIMUM_DENSITY_CHECK YES


#ENDIF
#ENDIF

// 1.25xMy.R.1[NC] 1.25xMy pattern must be drawn on data type 40

// =======================================================
// 1.25xMn design rules
// =======================================================

GROUP G125xm6 125xm6_?
 
125xm6_040 = M6 WITH WIDTH == 0.040
125xm6_042 = M6 WITH WIDTH == 0.042
125xm6_044 = M6 WITH WIDTH == 0.044
125xm6_046 = M6 WITH WIDTH == 0.046
125xm6_060 = M6 WITH WIDTH == 0.060
125xm6_080 = M6 WITH WIDTH == 0.080
125xm6_120 = M6 WITH WIDTH == 0.120
125xm6_160 = M6 WITH WIDTH == 0.160
125xm6_eqgt_060 = M6 WITH WIDTH >= 0.060
125xm6_eqgt_120 = 125xm6_eqgt_060 WITH WIDTH >= 0.120
125xm6_eqgt_121 = 125xm6_eqgt_060 WITH WIDTH >= 0.121
125xm6_eqgt_200 = 125xm6_eqgt_120 WITH WIDTH >= 0.200
125xm6_gt_060 = 125xm6_eqgt_060 WITH WIDTH > 0.060
125xm6_gt_160 = 125xm6_eqgt_060 WITH WIDTH > 0.160
125xm6_gt_080 = 125xm6_eqgt_060 WITH WIDTH > 0.080
 
125xm6_044_end = LENGTH M6_convex_90_90_edges <= 0.044
125xm6_060_end = LENGTH M6_convex_90_90_edges <= 0.060
M6_060_h_edges = INT [M6_h_edges] == 0.06 OPPOSITE
 

#IFDEF DFM_RULES_PRIORITY_1 YES

125xm6_S_3_DFM1 {
@ Recommended 1.25xMn space when either one 1.25xMn width > 1.35um. >= 0.450um
 chk_mn = M6 WITH WIDTH > 1.35
 err1 = EXT chk_mn M6 < 0.450 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xm6_A_1_DFM1 {
@ Recommended 1.25xMn area >= 0.02um2
 err1 = AREA M6 < 0.02
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xm6_R_9_V5_DFM1 {
@ 1.25xMn.R.9.DFM:
@ It's not recommended to use dense 1.25xMn 3-bar pattern
@ DRC flag conditions:
@ (1) Middle line width(W1) is <= 0.044um, both two neighbour 1.25xMn line width <= 0.06um and interact square or rectangle Vy or 1.25xVn
@ (2) 1.25xMn Space to both via (S1/S2)< 0.048um
@ (3) The via PRL: -0.1 < PRL < 0.1um
@ (4) Both neighbor 1.25xMn enclosure 1.25xVn or 1.25xVn-1 < 0.065um
@ This rule is not applied for INST region
 met_44_side = INT [M6] <= 0.044 ABUT<90 OPPOSITE
 met_60_side = INT [M6] <= 0.060 ABUT<90 OPPOSITE
 via_d_met = V5_SR NOT OUTSIDE (M6 WITH WIDTH <= 0.06)
 via_d_end = via_d_met TOUCH EDGE (ENC [via_d_met] 125xm6_060_end < 0.065 ABUT<90 OPPOSITE)
 via_d_lin = (via_d_met NOT TOUCH EDGE via_d_end) TOUCH EDGE (ENC [via_d_met] met_60_side <= 0.028 ABUT<90 OPPOSITE)
 via_d_mid = (via_d_met WITH EDGE via_d_end) WITH EDGE via_d_lin >= 2
 via_d_sid = via_d_mid TOUCH EDGE via_d_lin
 via_d_sps = (EXT [met_44_side] via_d_sid < 0.048 OPPOSITE EXTENDED 0.1 MEASURE ALL) TOUCH EDGE (EXT [met_44_side] via_d_sid < 0.048 OPPOSITE MEASURE ALL)
 err1 = INT via_d_sps <= 0.044 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE INST
}
 
125xm6_R_9_V6_DFM1 {
@ 1.25xMn.R.9.DFM:
@ It's not recommended to use dense 1.25xMn 3-bar pattern
@ DRC flag conditions:
@ (1) Middle line width(W1) is <= 0.044um, both two neighbour 1.25xMn line width <= 0.06um and interact square or rectangle Vy or 1.25xVn
@ (2) 1.25xMn Space to both via (S1/S2)< 0.048um
@ (3) The via PRL: -0.1 < PRL < 0.1um
@ (4) Both neighbor 1.25xMn enclosure 1.25xVn or 1.25xVn-1 < 0.065um
@ This rule is not applied for INST region
 met_44_side = INT [M6] <= 0.044 ABUT<90 OPPOSITE
 met_60_side = INT [M6] <= 0.060 ABUT<90 OPPOSITE
 via_u_met = V6_SR NOT OUTSIDE (M6 WITH WIDTH <= 0.06)
 via_u_end = via_u_met TOUCH EDGE (ENC [via_u_met] 125xm6_060_end < 0.065 ABUT<90 OPPOSITE)
 via_u_lin = (via_u_met NOT TOUCH EDGE via_u_end) TOUCH EDGE (ENC [via_u_met] met_60_side <= 0.028 ABUT<90 OPPOSITE)
 via_u_mid = (via_u_met WITH EDGE via_u_end) WITH EDGE via_u_lin >= 2
 via_u_sid = via_u_mid TOUCH EDGE via_u_lin
 via_u_sps = (EXT [met_44_side] via_u_sid < 0.048 OPPOSITE EXTENDED 0.1 MEASURE ALL) TOUCH EDGE (EXT [met_44_side] via_u_sid < 0.048 OPPOSITE MEASURE ALL)
 err1 = INT via_u_sps <= 0.044 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE INST
}

#ENDIF

125xm6_W_1 {
@ 1.25xMn width >= 0.04um
 err1 = INT M6 < 0.04 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xm6_W_1a {
@ 1.25xMn width in CP direction
@ The width should be even value when <= 0.046um
@ CP direction definition: Critical-Pitch direction along the minimum pitch (80nm) of 1.25xMn = 0.04~0.046, >= 0.060
 err1 = INT M6_h_edges < 0.040 ABUT<90 OPPOSITE REGION
 err2 = INT M6_h_edges > 0.040 < 0.042 ABUT<90 OPPOSITE REGION
 err3 = INT M6_h_edges > 0.042 < 0.044 ABUT<90 OPPOSITE REGION
 err4 = INT M6_h_edges > 0.044 < 0.046 ABUT<90 OPPOSITE REGION
 err5 = INT M6_h_edges > 0.046 < 0.060 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
 err4 NOT INSIDE SealR_NOT_BULK
 err5 NOT INSIDE SealR_NOT_BULK
}
 
125xm6_W_1b {
@ 1.25xMn width in NCP direction
@ NCP direction definition: Non-Critical-Pitch direction which is perpendicular to CP direction = 0.08, >= 0.120um
 err1 = INT M6_v_edges < 0.080 ABUT<90 OPPOSITE REGION
 err2 = INT M6_v_edges > 0.080 < 0.120 ABUT<90 OPPOSITE REGION EXCLUDE SHIELDED
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}
 
125xm6_W_2 {
@ 1.25xMn width, except MARKS and LOGO regions <= 2.1um
@ DRC doesn't flag (1.25xMn AND DUPMK1) region when the 1.25xMn layer is used as TM-1
 err1 = (M6 NOT INSIDE MARKS_LOGO) WITH WIDTH > 2.1
 err1 NOT INSIDE MARKS_LOGO
}
 
125xm6_W_3 {
@ 1.25xMn width of 45-degree bent metal >= 0.396um
 err1 = INT M6_45_skew_edges < 0.396 OPPOSITE REGION EXCLUDE SHIELDED
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xm6_W_4 {
@ 1.25xMn width of metal branch connected to wide metal width and length >= 0.401um. >= 0.08um
 dorian_large = M6 WITH WIDTH >= 0.401
 dorian_whole = M6 INTERACT dorian_large
 dorian_large_exp = SIZE dorian_large BY 0.005 INSIDE OF dorian_whole
 dorian_branch_0 = dorian_whole NOT dorian_large
 dorian_branch_1 = dorian_branch_0 NOT COIN EDGE dorian_large
 dorian_branch_2 = dorian_branch_1 TOUCH EDGE dorian_large_exp
 err1 = INT dorian_branch_2 < 0.08 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xm6_W_5 {
@ 1.25xMn width when PRL < 0um. >= 0.08um
 err1 = INT M6 < 0.08 ABUT<90 REGION CORNER TO CORNER
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xm6_S_1 {
@ 1.25xMn space >= 0.04um
 err1 = EXT M6 < 0.04 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xm6_S_2 {
@ Space between 1.25xMn when one or both width >= 0.201um when PRL >= -0.139um. >= 0.139um
 chk_Mn = M6 WITH WIDTH >= 0.201
 err1 = EXT M6 chk_Mn < 0.139 ABUT<90 OPPOSITE EXTENDED 0.139+GLOBAL_TOLERANCE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xm6_S_3 {
@ Space between 1.25xMn when one or both width >= 0.282um when PRL > 0.16um. >= 0.199um
 mets_RAW = (M6 WITH WIDTH >= 0.201) WITH WIDTH >= 0.282
 mets_sps_ERRS = EXT mets_RAW M6 < 0.199 ABUT<90 OPPOSITE
 mets_sps_AREA = EXT mets_RAW M6 < 0.199 ABUT<90 OPPOSITE REGION
 err1 = DFM PROPERTY mets_sps_AREA mets_sps_ERRS OVERLAP ABUT ALSO MULTI [-= EC(mets_sps_ERRS)] > 0.16
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xm6_S_4 {
@ Space between 1.25xMn when one or both width > 0.5um when PRL >= -0.199um. >= 0.199um
 chk_Mn = (M6 WITH WIDTH >= 0.201) WITH WIDTH > 0.5
 err1 = EXT M6 chk_Mn < 0.199 ABUT<90 OPPOSITE EXTENDED 0.199+GLOBAL_TOLERANCE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xm6_S_5 {
@ Space between 1.25xMn when one or both width > 1.35um when PRL > 1.35um. >= 0.448um
 met_wid_all = M6 WITH WIDTH >= 1.35+GLOBAL_TOLERANCE
 met_err_RAW = EXT M6 met_wid_all < 0.448 OPPOSITE REGION MEASURE ALL
 met_err_CRN = EXT (ANGLE M6 > 44 < 46) met_wid_all < 0.448 OPPOSITE1 REGION MEASURE ALL
 err1 = met_err_RAW ENCLOSE RECTANGLE 0.001 1.351 ORTHOGONAL ONLY
 err2 = met_err_CRN ENCLOSE RECTANGLE 0.04 1.351
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}
 
125xm6_S_6 {
@ Space between 1.25xMn in CP direction when one or both width = 0.04um. = 0.04, >= 0.07um
 err1_TMP = DFM SPACE M6 125xm6_040 < 0.04 BY EXT VERTICAL
 err2_TMP = DFM SPACE M6 125xm6_040 > 0.04 < 0.07 BY EXT VERTICAL
 // 
 waive_TMP = ANGLE 125xm6_060 == 0
 waive_EDG = EXT waive_TMP 125xm6_040 == 0.07 ABUT<90 OPPOSITE
 err1 = DFM COPY err1_TMP EDGE
 // NOT COIN EDGE (DFM COPY waive_EDG EDGE)
 err2 = DFM COPY err2_TMP EDGE
 // NOT COIN EDGE (DFM COPY waive_EDG EDGE)
 err1 NOT INSIDE EDGE SealR_NOT_BULK
 err2 NOT INSIDE EDGE SealR_NOT_BULK
}
 
125xm6_S_6a {
@ Space between 1.25xMn in CP direction when one or both width = 0.042um. = 0.048, >= 0.07um
 err1 = EXT M6_h_edges 125xm6_042 < 0.048 ABUT<90 OPPOSITE REGION
 err2 = EXT M6_h_edges 125xm6_042 > 0.048 < 0.07 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}
 
125xm6_S_7 {
@ Space between 1.25xMn in CP direction when one or both width = 0.044um. = 0.046, >= 0.07um
 err1 = EXT M6_h_edges 125xm6_044 < 0.046 ABUT<90 OPPOSITE REGION
 err2 = EXT M6_h_edges 125xm6_044 > 0.046 < 0.07 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}
 
125xm6_S_7a {
@ Space between 1.25xMn in CP direction when one or both width = 0.046um. = 0.046um, >= 0.07um
 err1 = EXT M6_h_edges 125xm6_046 < 0.046 ABUT<90 OPPOSITE REGION
 err2 = EXT M6_h_edges 125xm6_046 > 0.046 < 0.07 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}
 
125xm6_S_8 {
@ Space between 1.25xMn in CP direction when one or both width = 0.06um. = 0.04, 0.046, >= 0.06um
 waive_s_6a_chk = ANGLE 125xm6_060 == 0
 waive_s_6a = DFM COPY (EXT waive_s_6a_chk 125xm6_040 == 0.070 ABUT<90 OPPOSITE) EDGE
 bad_1 = DFM SPACE 125xm6_060 M6 < 0.040 BY EXT VERTICAL
 bad_2 = DFM SPACE 125xm6_060 M6 > 0.040 < 0.046 BY EXT VERTICAL
 bad_3 = DFM SPACE 125xm6_060 M6 > 0.046 < 0.060 BY EXT VERTICAL
 err1 = DFM COPY bad_1 EDGE
 // NOT COIN EDGE waive_s_6a
 err2 = DFM COPY bad_2 EDGE
 // NOT COIN EDGE waive_s_6a
 err3 = DFM COPY bad_3 EDGE
 // NOT COIN EDGE waive_s_6a
 err1 NOT INSIDE EDGE SealR_NOT_BULK
 err2 NOT INSIDE EDGE SealR_NOT_BULK
 err3 NOT INSIDE EDGE SealR_NOT_BULK
}
 
125xm6_S_8a {
@ Space between 1.25xMn in CP direction when one or both width > 0.06um when PRL > 0.08um. >= 0.06um
 met_wid_all = COPY 125xm6_gt_060
 met_err_RAW = EXT [met_wid_all] M6_h_edges < 0.06 ABUT<90 OPPOSITE MEASURE ALL
 met_jog_ALL = (CONVEX EDGE M6 == 1) NOT COIN EDGE met_err_RAW
 met_jog_EXP_a = EXPAND EDGE met_jog_ALL INSIDE BY 0.0005
 met_jog_EXP_b = EXPAND EDGE met_jog_ALL OUTSIDE BY 0.0005
 met_jog_TMP = (met_jog_ALL COIN EDGE (met_jog_EXP_a WITH EDGE met_err_RAW)) COIN EDGE (met_jog_EXP_b WITH EDGE met_err_RAW)
 met_jog_EXP = ((VERTEX (EXPAND EDGE met_jog_TMP OUTSIDE BY 0.001 EXTEND BY 0.001) == 4) OR (EXPAND EDGE met_err_RAW OUTSIDE BY 0.001)) NOT M6
 // 
 met_err_PRL = DFM PROPERTY met_jog_EXP met_err_RAW OVERLAP ABUT ALSO MULTI [-= LENGTH(met_err_RAW)] > 0.08
 met_err_EGE = met_err_RAW TOUCH EDGE met_err_PRL
 err1 = EXT met_err_EGE M6 < 0.06 ABUT<90 OPPOSITE REGION MEASURE ALL
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xm6_S_9 {
@ Space between 1.25xMn in CP direction, when one or both width = 0.06um, and the other side space < 0.06um. >= 0.079um
 mets_sps_060 = EXT [M6_060_h_edges] M6 < 0.06 ABUT<90 OPPOSITE
 mets_sps_080 = EXT [M6_060_h_edges] M6 < 0.079 ABUT<90 OPPOSITE
 err1 = INT mets_sps_060 mets_sps_080 == 0.06 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
M6_convex_90_270_edges_gt_040 = ANGLE (CONVEX EDGE M6 ANGLE1 == 90 ANGLE2 == 270 WITH LENGTH > 0.04) == 90
M6_width_eq_080 = M6 WITH WIDTH == 0.08
 
125xm6_S_10 {
@ Space between 1.25xMn in CP direction when one or both width >= 0.08um. >= 0.079um
@ Except Z shape and flag shape:
@ (1) Z-shape definition: edge length > 0.040um between two consecutive 90-270 degree corners, corresponding width = 0.08um in NCP direction between two opposite edge length > 0.04um, not including T-shape
@ (2) Flag-shape definition: edge length > 0.04um between two consecutive 90-270 degree corners, the opposite edge length > 0.08um between two consecutive 90-90 degree corners, corresponding width = 0.08um in NCP direction between these two opposite edge, and the other corresponding width > 0.04um in CP direction
 flag_shape_l_side = LENGTH M6_convex_90_90_edges > 0.08
 flag_shape_s_side = ANGLE (LENGTH M6_convex_90_90_edges == 0.08) == 0
 flag_shape = (M6_width_eq_080 INTERACT (INT M6_convex_90_270_edges_gt_040 flag_shape_l_side == 0.08 ABUT<90 OPPOSITE REGION)) WITH EDGE flag_shape_s_side
 zfig_shape = (M6_width_eq_080 INTERACT (INT M6_convex_90_270_edges_gt_040 == 0.08 ABUT<90 OPPOSITE REGION)) NOT WITH EDGE flag_shape_s_side
 waive_shape = (OR zfig_shape flag_shape) NOT COIN EDGE (INT [M6_h_edges] == 0.08 ABUT<90 OPPOSITE) // vertical width=0.08 need to flag
 // 
 check_edge = INT (M6_h_edges) < 0.08 ABUT<90 OPPOSITE
 check_shape = check_edge NOT COIN EDGE waive_shape
 err1 = EXT check_shape (M6 NOT COIN EDGE waive_shape) < 0.079 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xm6_S_11 {
@ Space between 1.25xMn in CP direction when one or both width >= 0.121um, PRL > 0.08um. >= 0.099um
 mets_sps_100_ERRS = EXT 125xm6_eqgt_121 M6_h_edges < 0.099 ABUT<90 OPPOSITE
 mets_sps_100_AREA = EXT 125xm6_eqgt_121 M6_h_edges < 0.099 ABUT<90 OPPOSITE REGION
 err1 = DFM PROPERTY mets_sps_100_AREA mets_sps_100_ERRS OVERLAP ABUT ALSO MULTI [-= EC(mets_sps_100_ERRS)] > 0.08
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xm6_S_12 {
@ Space between 1.25xMn (CP direction width > 0.16um and NCP direction width > 0.08um) and 1.25xMn edge (edge length > 0.08um in NCP direction) in CP direction >= 0.119um
 mets_L_sides = (INT (M6_h_edges) <= 0.16 ABUT<90 OPPOSITE EXCLUDE SHIELDED) COIN EDGE 125xm6_gt_080
 mets_R_sides = LENGTH M6_h_edges > 0.08
 err1 = EXT mets_R_sides (mets_L_sides COIN EDGE mets_R_sides) < 0.119 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xm6_S_13 {
@ Space between 1.25xMn in CP direction when one or both width >= 0.201um, PRL >= 0.121um. >= 0.144um
 mets_RAW = M6 WITH WIDTH >= 0.201
 mets_sps_ERRS = EXT mets_RAW M6_h_edges < 0.144 ABUT<90 OPPOSITE
 mets_sps_AREA = EXT mets_RAW M6_h_edges < 0.144 ABUT<90 OPPOSITE REGION
 err1 = DFM PROPERTY mets_sps_AREA mets_sps_ERRS OVERLAP ABUT ALSO MULTI [-= EC(mets_sps_ERRS)] >= 0.121
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xm6_S_14 {
@ Space between 1.25xMn in CP direction when one or both width >= 0.231um, PRL >= 0.121um. >= 0.159um
 mets_RAW = (M6 WITH WIDTH >= 0.201) WITH WIDTH >= 0.231
 mets_sps_ERRS = EXT mets_RAW M6_h_edges < 0.159 ABUT<90 OPPOSITE
 mets_sps_AREA = EXT mets_RAW M6_h_edges < 0.159 ABUT<90 OPPOSITE REGION
 err1 = DFM PROPERTY mets_sps_AREA mets_sps_ERRS OVERLAP ABUT ALSO MULTI [-= EC(mets_sps_ERRS)] >= 0.121
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xm6_S_15 {
@ Space between 1.25xMn and 1.25xMn line-end (width = 0.08um and both adiacent edge length > 0.09um) in CP direction when PRL > -0.08um. >= 0.099um
 lend_RAW = CONVEX EDGE M6 ANGLE1 == 90 LENGTH1 > 0.09 ANGLE2 == 90 LENGTH2 > 0.09 WITH LENGTH == 0.08
 lend_CHK = ANGLE lend_RAW == 0
 err1 = EXT lend_CHK M6 < 0.099 ABUT<90 OPPOSITE EXTENDED 0.08 REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xm6_S_16 {
@ Space between 1.25xMn in NCP direction when one or both width = 0.08um, 0.12um. >= 0.08um
 mets_RAW = 125xm6_080 OR 125xm6_120
 mets_CHK = ANGLE mets_RAW == 90
 err1 = EXT mets_CHK M6 < 0.08 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xm6_S_17 {
@ Space between 1.25xMn (0.16um <= NCP direction width < 0.2um and CP direction width > 0.08um) and 1.25xMn edge (edge length > 0.08um in CP direction) in NCP direction >= 0.099um
 mets_L_sides = (INT [M6_v_edges] >= 0.16 < 0.2 ABUT<90 OPPOSITE EXCLUDE SHIELDED) COIN EDGE 125xm6_gt_080
 mets_R_sides = LENGTH M6_v_edges > 0.08
 err1 = EXT mets_R_sides (mets_L_sides COIN EDGE mets_R_sides) < 0.099 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xm6_S_18 {
@ Space between 1.25xMn in NCP direction when one or both width > 0.12um, PRL >= 0.121um. >= 0.119um
 err1_TMP = EXT 125xm6_eqgt_121 M6_v_edges < 0.119 ABUT<90 OPPOSITE REGION
 err1 = err1_TMP ENCLOSE RECTANGLE 0.001 0.121 ORTHOGONAL ONLY
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xm6_S_19 {
@ Space between 1.25xMn (NCP direction width >= 0.2um and CP direction width > 0.08um) and 1.25xMn edge (edge length > 0.08um in CP direction) in NCP direction >= 0.139um
 mets_L_sides = (INT (M6_v_edges) < 0.2 ABUT<90 OPPOSITE EXCLUDE SHIELDED) COIN EDGE 125xm6_gt_080
 mets_R_sides = LENGTH M6_v_edges > 0.08
 err1 = EXT mets_R_sides (mets_L_sides COIN EDGE mets_R_sides) < 0.139 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xm6_S_20 {
@ Space between 1.25xMn in NCP direction when one or both width > 0.16um when PRL > 0.2um. >= 0.159um
 err1_TMP = EXT 125xm6_gt_160 M6_v_edges < 0.159 ABUT<90 OPPOSITE REGION
 err1 = err1_TMP ENCLOSE RECTANGLE 0.001 0.20+GLOBAL_TOLERANCE ORTHOGONAL ONLY
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xm6_S_21 {
@ Space between 1.25xMn and 1.25xMn line-end (width = 0.04/0.042um) in NCP direction when PRL > -0.04um. >= 0.099um
 lend_RAW = LENGTH M6_convex_eq_two_edges >= 0.04 <= 0.042
 lend_CHK = ANGLE lend_RAW == 90
 err1 = EXT lend_CHK M6 < 0.099 ABUT<90 OPPOSITE EXTENDED 0.04 REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xm6_S_21a {
@ Space between 1.25xMn and 1.25xMn line-end (width = 0.044/0.046/0.06um) in NCP direction when PRL > -0.04um. >= 0.080um
 lend_RAW_a = LENGTH M6_convex_eq_two_edges >= 0.044 <= 0.046
 lend_RAW_b = LENGTH M6_convex_eq_two_edges == 0.06
 lend_CHK = ANGLE (lend_RAW_a OR EDGE lend_RAW_b) == 90
 err1 = EXT lend_CHK M6 < 0.08 ABUT<90 OPPOSITE EXTENDED 0.04 REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xm6_S_22 {
@ Space between 1.25xMn and 1.25xMn line-end (0.06um < width <= 0.08um) in NCP direction when PRL > -0.08um. >= 0.08um
 lend_RAW = LENGTH M6_convex_eq_two_edges > 0.06 <= 0.08
 lend_CHK = ANGLE lend_RAW == 90
 err1 = EXT lend_CHK M6 < 0.08 ABUT<90 OPPOSITE EXTENDED 0.08 REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xm6_S_23 {
@ Space between 1.25xMn line-end (width < 0.08um) and U-shape inner edge (edge length <= 0.149um between two concave corners) in NCP direction >= 0.149um
 mets_U_sides = LENGTH M6_convex_270_270_edges <= 0.149
 err1 = EXT M6_end_080 mets_U_sides < 0.149 ABUT<90 OPPOSITE EXTENDED 0.04 REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xM6_GROUP_80 = SIZE (SIZE (SIZE 125xm6_040 BY 0.02) BY -0.04) BY 0.02
125xM6_GROUP_90_1 = SIZE (SIZE (SIZE 125xm6_044 BY 0.023) BY -0.046) BY 0.023
125xM6_GROUP_90_2 = SIZE (SIZE (SIZE 125xm6_042 BY 0.024) BY -0.048) BY 0.024
125xM6_GROUP_90 = OR 125xM6_GROUP_90_1 125xM6_GROUP_90_2
 
125xm6_S_24a {
@ Space between 1.25xMn_Group_80 and 1.25xMn_Group_90 in CP direction when PRL > -0.08um. >= 0.199um
@ 1.25xMn_Group_80 definition: (((1.25xMn (width = 0.040um) SIZING 0.020um) SIZING -0.040um) SIZING 0.020um)
@ 1.25xMn_Group_90 definition: 1) (((1.25xMn (width = 0.044um) su 0.023um) sd -0.046um) su 0.023um). 2) (((1.25xMn (width = 0.042um) su 0.024um) sd -0.048um) su 0.024um)
 line_080 = ANGLE 125xM6_GROUP_80 == 0
 line_090 = ANGLE 125xM6_GROUP_90 == 0
 err1 = EXT line_080 line_090 < 0.199 ABUT<90 OPPOSITE EXTENDED 0.08 REGION MEASURE ALL
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xm6_S_24b {
@ Space between 1.25xMn line-end inside 1.25xMn_Group_80 and 1.25xMy line-end of 1.25xMn_Group_90 in NCP direction when PRL > -0.199um. >= 0.149um
 lend_080 = ANGLE (M6_end NOT OUTSIDE EDGE 125xM6_GROUP_80) == 90
 lend_090 = ANGLE (M6_end NOT OUTSIDE EDGE 125xM6_GROUP_90) == 90
 err1 = EXT lend_080 lend_090 < 0.149 ABUT<90 OPPOSITE EXTENDED 0.199 REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xm6_S_25 {
@ Corner projected space between 1.25xMn when -0.08um < PRL <= 0um. >= 0.08um
@ Except line end-to-end (width <= 0.06um), Z-shape, and flag-shape:
@ Definition of Z-shape /flag-shape:
@ 1) Z-shape: edge length > 0.040um between two consecutive 90-270 degree corners, corresponding width = 0.08um in NCP direction between 2 opposite edge length > 0.040um, not including T-shape
@ 2) flag-shape: edge length > 0.04um between two consecutive 90-270 degree corners, the opposite edge length > 0.08um between two consecutive 90-90 degree corners, corresponding width = 0.08um in NCP direction between these 2 opposite edge, and the other corresponding width > 0.04um in CP direction
 line_end = (CONVEX EDGE M6 ANGLE1 == 90 ANGLE2 == 90 WITH LENGTH <= 0.06) COIN EDGE M6_v_edges
 // 
 flag_shape_l_side = LENGTH M6_convex_90_90_edges > 0.08
 flag_shape_s_side = ANGLE (LENGTH M6_convex_90_90_edges == 0.08) == 0
 flag_shape = (M6_width_eq_080 INTERACT (INT M6_convex_90_270_edges_gt_040 flag_shape_l_side == 0.08 ABUT<90 OPPOSITE REGION)) WITH EDGE flag_shape_s_side
 zfig_shape = (M6_width_eq_080 INTERACT (INT M6_convex_90_270_edges_gt_040 == 0.08 ABUT<90 OPPOSITE REGION)) NOT WITH EDGE flag_shape_s_side
 waive_shape = OR zfig_shape flag_shape
 // 
 corner_space_prl_lt_0 = EXT M6 < 0.08*1.414 CORNER TO CORNER
 corner_space_prl_eq_0 = EXT line_end M6 < 0.08 PROJ == 0
 corner_space_all_TMP = DFM COPY corner_space_prl_lt_0 corner_space_prl_eq_0
 corner_space_all = DFM PROPERTY corner_space_all_TMP line_end waive_shape OVERLAP ABUT ALSO MULTI 
 [-= (count(line_end) > 0 && count(waive_shape) == 0) ? 1 : 0] > 0 
 [-= (EWXP(corner_space_all_TMP) < 0.08 && EWYP(corner_space_all_TMP) < 0.08) ? 1 : 0] > 0
 err1_TMP = DFM PROPERTY corner_space_all line_end OVERLAP ABUT ALSO MULTI [-= (count(line_end) == 0 || count(line_end) < 2) ? 1 : 0] > 0
 err1 = DFM COPY err1_TMP REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xm6_S_25a {
@ Corner space between two 1.25xMn in NCP direction when -0.04um < PRL <= 0um. >= 0.08um
 err1_RAW = EXT M6 < 0.08 ABUT<90 CORNER TO CORNER
 err1_TMP = DFM PROPERTY err1_RAW GLOBALXY [-= EWYP(err1_RAW)] < 0.04
 err1_SPE = EXT M6 M6_v_edges < 0.08 ABUT<90 REGION PROJ == 0
 err1 = (DFM COPY err1_TMP REGION) OR err1_SPE
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xm6_S_26 {
@ At least one space between 1.25xMn edge (any adjacent edge of concave corner) and 1.25xMn >= 0.119um, except either condition as below
@ 1. Edge length between two concave corners < 0.12um
@ 2. Side edge length of concave corner < 0.042um
 waive_edge_a = LENGTH M6_convex_270_270_edges < 0.120
 waive_edge_b = LENGTH M6_convex_lt_two_edges < 0.042
 check_edge = (LENGTH M6_convex_lt_two_edges >= 0.042) NOT COIN EDGE M6_45_skew_edges
 // 
 Y1 = EXT [M6] check_edge < 0.119 ABUT<90 OPPOSITE EXTENDED 0.119
 Y2 = INT [Y1] < 0.001 ABUT==90 INTERSECTING ONLY
 Y3 = EXT Y2 check_edge < 0.119 ABUT<90 OPPOSITE EXTENDED 0.119
 err1_TMP = EXT (DFM COPY Y3 EDGE) < 0.04 ABUT==90 INTERSECTING ONLY REGION EXTENTS
 err1 = (err1_TMP NOT WITH EDGE waive_edge_a) NOT WITH EDGE waive_edge_b
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xm6_S_27 {
@ Space between 1.25xMy concave corner (both side edge length > 0.08um) and 1.25xMy line-end (width < 0.08um) >= 0.154um
 mets_CHK = LENGTH M6_convex_lt_two_edges > 0.08
 mets_CRN = EXT [mets_CHK] < 0.0005 ABUT==90 INTERSECTING ONLY // resolution concern
 // 
 err1_RAW = EXT M6_convex_lt_two_edges M6_end_080 < 0.154 ABUT EXCLUDE SHIELDED
 err1_HAS = mets_CRN COIN EDGE M6_convex_lt_two_edges
 err1_TMP = DFM PROPERTY err1_RAW err1_HAS ABUT ALSO OVERLAP MULTI [-= count(err1_HAS)] > 0
 err1 = DFM COPY err1_TMP REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
M6_space_eq_040_h_edges = EXT [M6_h_edges] == 0.04 OPPOSITE
M6_space_eq_040_h_areas = EXT M6_h_edges == 0.04 OPPOSITE REGION
M6_space_eq_040_h_areas_h_edges = ANGLE M6_space_eq_040_h_areas == 0
M6_width_lt_080_h_edges = (INT [M6_h_edges] < 0.08 ABUT<90 OPPOSITE) COIN EDGE (M6 WITH WIDTH < 0.08)
 
125xm6_S_28 {
@ Forbidden the space between 1.25xMn (width = 0.04~0.046um and one side space = 0.04um) and 1.25xMn (width < 0.08um (W1)) in CP direction, except both side space of 1.25xMy (width < 0.08um) to 1.25xMy >= 0.1um. = 0.061~0.098, 0.131~0.178um
 Mn_w040_w042 = WITH WIDTH M6 >= 0.04 <= 0.046
 Mn_w040_s040_h_edges = Mn_w040_w042 COIN EDGE M6_space_eq_040_h_edges
 Mn_w040_s040_h_edges_opp = INT Mn_w040_s040_h_edges [Mn_w040_w042] >= 0.04 <= 0.046 ABUT<90 OPPOSITE
 // not check W1 >= 0.08
 // 
 Mn_w080_s99_h_edges = EXT (M6_width_lt_080_h_edges) < 0.10 ABUT<90 OPPOSITE
 Mn_w080_s99_h_edges_both = INT [Mn_w080_s99_h_edges] < 0.08 ABUT<90 OPPOSITE
 Mn_w080_s99_h_edges_none = M6_width_lt_080_h_edges NOT COIN EDGE Mn_w080_s99_h_edges_both
 err1 = EXT Mn_w080_s99_h_edges_none Mn_w040_s040_h_edges_opp >= 0.131 <= 0.178 ABUT<90 OPPOSITE REGION EXCLUDE SHIELDED
 err2 = EXT Mn_w080_s99_h_edges_none Mn_w040_s040_h_edges_opp >= 0.061 <= 0.098 ABUT<90 OPPOSITE REGION EXCLUDE SHIELDED
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}
 
125xm6_S_29 {
@ Fobidden space between 1.25xMy (width = 0.06~0.07um and one side space = 0.04um) and 1.25xMy (width < 0.08um) in CP direction, except both side space of 1.25xMy (width < 0.08um) to 1.25xMy >= 0.1um. = 0.11~0.158um
 Mn_w060_w070 = WITH WIDTH M6 >= 0.06 <= 0.07
 Mn_w060_s040_h_edges = Mn_w060_w070 COIN EDGE M6_space_eq_040_h_edges
 Mn_w060_s040_h_edges_opp = INT Mn_w060_s040_h_edges [Mn_w060_w070] >= 0.06 <= 0.07 ABUT<90 OPPOSITE
 // not check W1 >= 0.08
 // 
 Mn_w080_s99_h_edges = EXT (M6_width_lt_080_h_edges) < 0.10 ABUT<90 OPPOSITE
 Mn_w080_s99_h_edges_both = INT [Mn_w080_s99_h_edges] < 0.08 ABUT<90 OPPOSITE
 Mn_w080_s99_h_edges_none = M6_width_lt_080_h_edges NOT COIN EDGE Mn_w080_s99_h_edges_both
 err1 = EXT Mn_w080_s99_h_edges_none Mn_w060_s040_h_edges_opp >= 0.110 <= 0.158 ABUT<90 OPPOSITE REGION EXCLUDE SHIELDED
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xm6_S_30 {
@ Space between 1.25xMn and 45-degree bent 1.25xMn, DRC check 45-degree direction >= 0.396um
 err1 = EXT M6 M6_45_skew_edges < 0.396 ABUT<90 OPPOSITE2 REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
//; 125xmn.S.31~125xmn.S.37a: delta voltage rule
 
125xm6_L_1 {
@ Length of 45-degree bent 1.25xMn, except MARKS >= 0.905um
 err1 = LENGTH M6_45_skew_edges < 0.905
 err1 NOT INSIDE EDGE MARKS
}
 
125xm6_L_2 {
@ 1.25xMn edge length when the adjacent edge length <= 0.089um, except two 0.08um edges form a convex corner. >= 0.099um
 chk_condition = LENGTH M6 <= 0.089
 err_EdgLength = LENGTH M6 < 0.099
 waive_CASE = INT (LENGTH chk_condition == 0.08) (LENGTH err_EdgLength == 0.08) < 0.005 ABUT INTERSECTING ONLY REGION
 err1_TMP_A = EXT chk_condition err_EdgLength < 0.005 ABUT INTERSECTING ONLY REGION
 err1_TMP_B = (INT chk_condition err_EdgLength < 0.005 ABUT INTERSECTING ONLY REGION) NOT INTERACT waive_CASE
 err1 = OR (EXPAND EDGE (M6 TOUCH EDGE err1_TMP_A) OUTSIDE BY 0.001 EXTEND BY 0.001) (EXPAND EDGE (M6 TOUCH EDGE err1_TMP_B) OUTSIDE BY 0.001 EXTEND BY 0.001)
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xm6_L_3 {
@ 1.25xMn edge length when the adjacent edge length < 0.04um. >= 0.119um
 chk_condition = LENGTH M6 < 0.04
 err_EdgLength = LENGTH M6 < 0.119
 err1_TMP_A = EXT chk_condition err_EdgLength < 0.005 ABUT INTERSECTING ONLY REGION
 err1_TMP_B = INT chk_condition err_EdgLength < 0.005 ABUT INTERSECTING ONLY REGION
 err1 = OR (EXPAND EDGE (M6 TOUCH EDGE err1_TMP_A) OUTSIDE BY 0.001 EXTEND BY 0.001) (EXPAND EDGE (M6 TOUCH EDGE err1_TMP_B) OUTSIDE BY 0.001 EXTEND BY 0.001)
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xm6_L_4 {
@ 1.25xMn edge length when the adjacent line-end width < 0.06um. >= 0.159um
 chk_condition = EXPAND EDGE M6_end_060 INSIDE BY 0.001
 err_EdgLength = (M6_convex_eq_one_edges TOUCH EDGE chk_condition) NOT COIN EDGE M6_end_060
 err1 = LENGTH err_EdgLength < 0.159
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
125xm6_L_5 {
@ 1.25xMn edge length when the adjacent line-end width < 0.08um. >= 0.109um
 chk_condition = EXPAND EDGE M6_end_080 INSIDE BY 0.001
 err_EdgLength = (M6_convex_eq_one_edges TOUCH EDGE chk_condition) NOT COIN EDGE M6_end_080
 err1 = LENGTH err_EdgLength < 0.109
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
125xm6_L_6 {
@ 1.25xMn edge length between two consecutive 90-270 degree corners >= 0.019um
 // DRC also check the condition with at least one 90-270 degree corners
 mets_ERRS_EDGE = LENGTH M6_convex_270_90_edges < 0.019
 mets_ERRS_a = INT mets_ERRS_EDGE M6_convex_eq_one_edges < 0.005 ABUT==90 INTERSECTING ONLY REGION
 mets_ERRS_b = EXT mets_ERRS_EDGE M6_convex_eq_one_edges < 0.005 ABUT==90 INTERSECTING ONLY REGION
 err1_TMP = (M6_convex_eq_one_edges TOUCH EDGE mets_ERRS_a) OR EDGE (M6_convex_eq_one_edges TOUCH EDGE mets_ERRS_b)
 err1 = EXPAND EDGE err1_TMP INSIDE BY 0.001 CORNER FILL
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xm6_L_7 {
@ 1.25xMn edge length between two consecutive 90-270 degree corners with adjacent line end edge width < 0.08um and another adjacent edge > 0.070um. >= 0.238um
 line_CHK_a_RAW = LENGTH M6_convex_270_90_edges > 0.07 < 0.238
 line_CHK_a_TMP = EXPAND EDGE M6_end_080 INSIDE BY 0.001
 line_CHK_a = (line_CHK_a_RAW NOT TOUCH EDGE M6_end_080) TOUCH EDGE line_CHK_a_TMP
 line_CHK_b = LENGTH M6_convex_lt_two_edges > 0.07
 err1 = EXT line_CHK_b line_CHK_a < 0.005 ABUT==90 INTERSECTING REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xm6_L_8 {
@ 1.25xMn U-shape inner edge length between two consecutive 270-270 degree corners >= 0.08um
 err1 = LENGTH M6_convex_270_270_edges < 0.08
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
125xm6_L_9_V5 {
@ Length of 1.25xMn metal branch (width <= 0.269um) >= 1.5um
@ When:
@ 1. Metal branch is connected to wide metal with width and length >= 0.398um
@ 2. One square 1.25xVn-1/1.25xVn in metal branch, and space to wide metal <= 1.5um
@ DRC flags branch that can't enclose a 0.08um*1.5um orthogonal rectangle
@ ("V5_50" is mapped to "V5" in the rule name of this check)
 WIDE_M6 = (WITH WIDTH M6 > 0.398-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 0.398-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 0.398-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 branch_all = ((SIZE WIDE_M6 BY 1.5+GLOBAL_TOLERANCE INSIDE OF M6 STEP 0.025) NOT WIDE_M6) AND M6
 branch_size = INT (M6 INTERACT branch_all) < 0.269+GLOBAL_TOLERANCE ABUT<90 OPPOSITE REGION EXCLUDE SHIELDED
 branch_real = branch_size INTERACT WIDE_M6
 branch_down = (branch_real AND M5) INTERACT DVK_V5_SQ == 1
 branch_down_real = ((M6 INTERACT branch_down) AND M5) INTERACT DVK_V5_SQ == 1
 branch_down_err1 = branch_real NOT OUTSIDE branch_down_real
 err1_down = branch_down_err1 NOT ENCLOSE RECTANGLE 0.08 1.5 ORTHOGONAL ONLY
 // 
 branch_up = (branch_real AND M7) INTERACT (RECTANGLE V6 ASPECT == 1) == 1
 branch_up_real = ((M6 INTERACT branch_up) AND M7) INTERACT (RECTANGLE V6 ASPECT == 1) == 1
 branch_up_err2 = branch_real NOT OUTSIDE branch_up_real
 err2_up = branch_up_err2 NOT ENCLOSE RECTANGLE 0.08 1.5 ORTHOGONAL ONLY
 err1_down NOT INSIDE SealR_NOT_BULK
}
 
125xm6_L_9_V6 {
@ Length of 1.25xMn metal branch (width <= 0.269um) >= 1.5um
@ When:
@ 1. Metal branch is connected to wide metal with width and length >= 0.398um
@ 2. One square 1.25xVn-1/1.25xVn in metal branch, and space to wide metal <= 1.5um
@ DRC flags branch that can't enclose a 0.08um*1.5um orthogonal rectangle
@ ("V6_50" is mapped to "V6" in the rule name of this check)
 WIDE_M6 = (WITH WIDTH M6 > 0.398-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 0.398-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 0.398-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 branch_all = ((SIZE WIDE_M6 BY 1.5+GLOBAL_TOLERANCE INSIDE OF M6 STEP 0.025) NOT WIDE_M6) AND M6
 branch_size = INT (M6 INTERACT branch_all) < 0.269+GLOBAL_TOLERANCE ABUT<90 OPPOSITE REGION EXCLUDE SHIELDED
 branch_real = branch_size INTERACT WIDE_M6
 branch_down = (branch_real AND M5) INTERACT DVK_V5_SQ == 1
 branch_down_real = ((M6 INTERACT branch_down) AND M5) INTERACT DVK_V5_SQ == 1
 branch_down_err1 = branch_real NOT OUTSIDE branch_down_real
 err1_down = branch_down_err1 NOT ENCLOSE RECTANGLE 0.08 1.5 ORTHOGONAL ONLY
 // 
 branch_up = (branch_real AND M7) INTERACT (RECTANGLE V6 ASPECT == 1) == 1
 branch_up_real = ((M6 INTERACT branch_up) AND M7) INTERACT (RECTANGLE V6 ASPECT == 1) == 1
 branch_up_err2 = branch_real NOT OUTSIDE branch_up_real
 err2_up = branch_up_err2 NOT ENCLOSE RECTANGLE 0.08 1.5 ORTHOGONAL ONLY
 err2_up NOT INSIDE SealR_NOT_BULK
}
 
125xm6_L_10_V5 {
@ Length of 1.25xMn metal branch (width <= 0.269um) >= 3.6um
@ When:
@ 1. Metal branch is connected to wide metal with width and length > 0.9um
@ 2. One square 1.25xVn-1/1.25xVn in metal branch, and space to wide metal <= 3.6um
@ DRC flags branch that can't enclose a 0.08um*3.6um orthogonal rectangle
@ ("V5_50" is mapped to "V5" in the rule name of this check)
 WIDE_M6 = (WITH WIDTH M6 > 0.9) ENCLOSE RECTANGLE 0.9+GLOBAL_TOLERANCE 0.9+GLOBAL_TOLERANCE
 branch_all = ((SIZE WIDE_M6 BY 3.6+GLOBAL_TOLERANCE INSIDE OF M6 STEP 0.025) NOT WIDE_M6) AND M6
 branch_size = INT (M6 INTERACT branch_all) < 0.269+GLOBAL_TOLERANCE ABUT<90 OPPOSITE REGION EXCLUDE SHIELDED
 branch_real = branch_size INTERACT WIDE_M6
 branch_down = (branch_real AND M5) INTERACT DVK_V5_SQ == 1
 branch_down_real = ((M6 INTERACT branch_down) AND M5) INTERACT DVK_V5_SQ == 1
 branch_down_err1 = branch_real NOT OUTSIDE branch_down_real
 err1_down = branch_down_err1 NOT ENCLOSE RECTANGLE 0.08 3.6 ORTHOGONAL ONLY
 // 
 branch_up = (branch_real AND M7) INTERACT (RECTANGLE V6 ASPECT == 1) == 1
 branch_up_real = ((M6 INTERACT branch_up) AND M7) INTERACT (RECTANGLE V6 ASPECT == 1) == 1
 branch_up_err2 = branch_real NOT OUTSIDE branch_up_real
 err2_up = branch_up_err2 NOT ENCLOSE RECTANGLE 0.08 3.6 ORTHOGONAL ONLY
 err1_down NOT INSIDE SealR_NOT_BULK
}
 
125xm6_L_10_V6 {
@ Length of 1.25xMn metal branch (width <= 0.269um) >= 3.6um
@ When:
@ 1. Metal branch is connected to wide metal with width and length > 0.9um
@ 2. One square 1.25xVn-1/1.25xVn in metal branch, and space to wide metal <= 3.6um
@ DRC flags branch that can't enclose a 0.08um*3.6um orthogonal rectangle
@ ("V6_50" is mapped to "V6" in the rule name of this check)
 WIDE_M6 = (WITH WIDTH M6 > 0.9) ENCLOSE RECTANGLE 0.9+GLOBAL_TOLERANCE 0.9+GLOBAL_TOLERANCE
 branch_all = ((SIZE WIDE_M6 BY 3.6+GLOBAL_TOLERANCE INSIDE OF M6 STEP 0.025) NOT WIDE_M6) AND M6
 branch_size = INT (M6 INTERACT branch_all) < 0.269+GLOBAL_TOLERANCE ABUT<90 OPPOSITE REGION EXCLUDE SHIELDED
 branch_real = branch_size INTERACT WIDE_M6
 branch_down = (branch_real AND M5) INTERACT DVK_V5_SQ == 1
 branch_down_real = ((M6 INTERACT branch_down) AND M5) INTERACT DVK_V5_SQ == 1
 branch_down_err1 = branch_real NOT OUTSIDE branch_down_real
 err1_down = branch_down_err1 NOT ENCLOSE RECTANGLE 0.08 3.6 ORTHOGONAL ONLY
 // 
 branch_up = (branch_real AND M7) INTERACT (RECTANGLE V6 ASPECT == 1) == 1
 branch_up_real = ((M6 INTERACT branch_up) AND M7) INTERACT (RECTANGLE V6 ASPECT == 1) == 1
 branch_up_err2 = branch_real NOT OUTSIDE branch_up_real
 err2_up = branch_up_err2 NOT ENCLOSE RECTANGLE 0.08 3.6 ORTHOGONAL ONLY
 err2_up NOT INSIDE SealR_NOT_BULK
}
 
125xm6_L_11_V5 {
@ Length of 1.25xMn metal branch (width <= 0.269um) >= 9um
@ When:
@ 1. Metal branch is connected to wide metal with width and length > 1.35um
@ 2. One square 1.25xVn-1/1.25xVn in metal branch, and space to wide metal <= 9um
@ DRC flags branch that can't enclose a 0.08um*9um orthogonal rectangle
@ ("V5_50" is mapped to "V5" in the rule name of this check)
 WIDE_M6 = (WITH WIDTH M6 > 1.35) ENCLOSE RECTANGLE 1.35+GLOBAL_TOLERANCE 1.35+GLOBAL_TOLERANCE
 branch_all = ((SIZE WIDE_M6 BY 9+GLOBAL_TOLERANCE INSIDE OF M6 STEP 0.025) NOT WIDE_M6) AND M6
 branch_size = INT (M6 INTERACT branch_all) < 0.269+GLOBAL_TOLERANCE ABUT<90 OPPOSITE REGION EXCLUDE SHIELDED
 branch_real = branch_size INTERACT WIDE_M6
 branch_down = (branch_real AND M5) INTERACT DVK_V5_SQ == 1
 branch_down_real = ((M6 INTERACT branch_down) AND M5) INTERACT DVK_V5_SQ == 1
 branch_down_err1 = branch_real NOT OUTSIDE branch_down_real
 err1_down = branch_down_err1 NOT ENCLOSE RECTANGLE 0.08 9 ORTHOGONAL ONLY
 // 
 branch_up = (branch_real AND M7) INTERACT (RECTANGLE V6 ASPECT == 1) == 1
 branch_up_real = ((M6 INTERACT branch_up) AND M7) INTERACT (RECTANGLE V6 ASPECT == 1) == 1
 branch_up_err2 = branch_real NOT OUTSIDE branch_up_real
 err2_up = branch_up_err2 NOT ENCLOSE RECTANGLE 0.08 9 ORTHOGONAL ONLY
 err1_down NOT INSIDE SealR_NOT_BULK
}
 
125xm6_L_11_V6 {
@ Length of 1.25xMn metal branch (width <= 0.269um) >= 9um
@ When:
@ 1. Metal branch is connected to wide metal with width and length > 1.35um
@ 2. One square 1.25xVn-1/1.25xVn in metal branch, and space to wide metal <= 9um
@ DRC flags branch that can't enclose a 0.08um*9um orthogonal rectangle
@ ("V6_50" is mapped to "V6" in the rule name of this check)
 WIDE_M6 = (WITH WIDTH M6 > 1.35) ENCLOSE RECTANGLE 1.35+GLOBAL_TOLERANCE 1.35+GLOBAL_TOLERANCE
 branch_all = ((SIZE WIDE_M6 BY 9+GLOBAL_TOLERANCE INSIDE OF M6 STEP 0.025) NOT WIDE_M6) AND M6
 branch_size = INT (M6 INTERACT branch_all) < 0.269+GLOBAL_TOLERANCE ABUT<90 OPPOSITE REGION EXCLUDE SHIELDED
 branch_real = branch_size INTERACT WIDE_M6
 branch_down = (branch_real AND M5) INTERACT DVK_V5_SQ == 1
 branch_down_real = ((M6 INTERACT branch_down) AND M5) INTERACT DVK_V5_SQ == 1
 branch_down_err1 = branch_real NOT OUTSIDE branch_down_real
 err1_down = branch_down_err1 NOT ENCLOSE RECTANGLE 0.08 9 ORTHOGONAL ONLY
 // 
 branch_up = (branch_real AND M7) INTERACT (RECTANGLE V6 ASPECT == 1) == 1
 branch_up_real = ((M6 INTERACT branch_up) AND M7) INTERACT (RECTANGLE V6 ASPECT == 1) == 1
 branch_up_err2 = branch_real NOT OUTSIDE branch_up_real
 err2_up = branch_up_err2 NOT ENCLOSE RECTANGLE 0.08 9 ORTHOGONAL ONLY
 err2_up NOT INSIDE SealR_NOT_BULK
}
 
125xm6_A_1 {
@ 1.25xMn area >= 0.0148um2
 err1 = AREA M6 < 0.0148
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xm6_A_2 {
@ 1.25xMn area when all of edge lengths < 0.115um, except can fill a 0.05um*0.13um rectangle >= 0.039um2
 M6_waive = ENCLOSE RECTANGLE M6 0.050 0.130 ORTHOGONAL ONLY
 M6_check = AREA M6 < 0.039
 M6_edge_all = LENGTH M6_check >= 0.115
 err1 = (M6_check NOT WITH EDGE M6_edge_all) NOT M6_waive
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xm6_A_3 {
@ 1.25xMn enclosed area >= 0.181um2
 err1 = AREA ((HOLES M6 INNER) NOT M6) < 0.181
 err1 NOT INSIDE SealR_NOT_BULK
}
 

#IFDEF IP_LEVEL_DENSITY_CHECK YES
#IFDEF MINIMUM_DENSITY_CHECK YES

125xm6_DN_1 {
@ 1.25xMn Density (window 50um*50um, stepping 50um/step_number), except LOGO, MARKS, (OCOVL AND MnDUB), (NODMF su 1um) regions >= 10.5%
 except_area = OR LOGO MARKS (OCOVL AND M6DUB) NODMF_SIZE_1
 check_region = DRC:1 NOT except_area
 check_pattern = M6_all AND check_region
 // 
 check_window1 = check_region WITH WIDTH >= 50/4
 err1_TMP1 = DENSITY check_pattern check_window1 check_region [!AREA(check_window1) + !!AREA(check_window1)*AREA(check_pattern)/AREA(check_region)] < 0.105 WINDOW 50 STEP 50/step_number BACKUP INSIDE OF LAYER DRC:1 BY POLYGON
 // 
 check_window2 = WITH WIDTH (check_region AND err1_TMP1) >= 50/4
 err1_TMP2 = DENSITY check_pattern check_window2 check_region [!AREA(check_window2) + !!AREA(check_window2)*AREA(check_pattern)/AREA(check_region)] < 0.105 WINDOW 50 STEP 50/step_number BACKUP INSIDE OF LAYER err1_TMP1 BY POLYGON
 // 
 check_window3 = WITH WIDTH (check_region AND err1_TMP2) >= 50/4
 DENSITY check_pattern check_window3 check_region [!AREA(check_window3) + !!AREA(check_window3)*AREA(check_pattern)/AREA(check_region)] < 0.105 WINDOW 50 STEP 50/step_number BACKUP INSIDE OF LAYER err1_TMP2 BY POLYGON PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_125xm6_DN_1.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_125xm6_DN_1.rdb"
}
 
125xm6_DN_1a {
@ 1.25xMn Density (window 50um*50um, stepping 50um/step_number), except the window not interact 3um*3um empty area, LOGO, MARKS, (OCOVL AND MnDUB), (NODMF su 1um) regions >= 26.3%
 except_area = OR LOGO MARKS (OCOVL AND M6DUB) NODMF_SIZE_1
 check_region = DRC:1 NOT except_area
 ck3x3_window = WITH WIDTH (check_region NOT M6_all) >= 3
 check_pattern = M6_all AND check_region
 // 
 check_window1 = check_region WITH WIDTH >= 50/4
 err1_TMP1 = DENSITY check_pattern check_window1 check_region ck3x3_window [!AREA(ck3x3_window) + !AREA(check_window1) + !!AREA(ck3x3_window)*!!AREA(check_window1)*AREA(check_pattern)/AREA(check_region)] < 0.263 WINDOW 50 STEP 50/step_number BACKUP INSIDE OF LAYER DRC:1 BY POLYGON
 // 
 check_window2 = WITH WIDTH (check_region AND err1_TMP1) >= 50/4
 err1_TMP2 = DENSITY check_pattern check_window2 check_region ck3x3_window [!AREA(ck3x3_window) + !AREA(check_window2) + !!AREA(ck3x3_window)*!!AREA(check_window2)*AREA(check_pattern)/AREA(check_region)] < 0.263 WINDOW 50 STEP 50/step_number BACKUP INSIDE OF LAYER err1_TMP1 BY POLYGON
 // 
 check_window3 = WITH WIDTH (check_region AND err1_TMP2) >= 50/4
 DENSITY check_pattern check_window3 check_region ck3x3_window [!AREA(ck3x3_window) + !AREA(check_window3) + !!AREA(ck3x3_window)*!!AREA(check_window3)*AREA(check_pattern)/AREA(check_region)] < 0.263 WINDOW 50 STEP 50/step_number BACKUP INSIDE OF LAYER err1_TMP2 BY POLYGON PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_125xm6_DN_1a.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_125xm6_DN_1a.rdb"
}

#ENDIF


#IFDEF RECOMMENDED_CHECK YES

 
125xm6_DN_2_R {
@ 1.25xMn maximum density (window 50um*50um, stepping 25um), except dummy metal. DRC doesn't check (1.25xMn AND DUPMK1) region when the 1.25xMn layer is used as TM-1 <= 65%
 check_region = COPY CHIP_NOT_MARKS
 check_pattern = M6 AND check_region
 // 
 check_window1 = check_region WITH WIDTH >= 50/4
 err1_TMP1 = DENSITY check_pattern check_window1 check_region [!!AREA(check_window1)*AREA(check_pattern)/AREA(check_region)] > 0.65 WINDOW 50 STEP 25 BACKUP INSIDE OF LAYER DRC:1 BY POLYGON
 // 
 check_window2 = WITH WIDTH (check_region AND err1_TMP1) >= 50/4
 err1_TMP2 = DENSITY check_pattern check_window2 check_region [!!AREA(check_window2)*AREA(check_pattern)/AREA(check_region)] > 0.65 WINDOW 50 STEP 25 BACKUP INSIDE OF LAYER err1_TMP1 BY POLYGON
 // 
 check_window3 = WITH WIDTH (check_region AND err1_TMP2) >= 50/4
 DENSITY check_pattern check_window3 check_region [!!AREA(check_window3)*AREA(check_pattern)/AREA(check_region)] > 0.65 WINDOW 50 STEP 25 BACKUP INSIDE OF LAYER err1_TMP2 BY POLYGON PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_125xm6_DN_2_R.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_125xm6_DN_2_R.rdb"
}

#ENDIF

 
125xm6_DN_3 {
@ Maximum 1.25xMn density (window 50um*50um, stepping 50um/step_number). DRC doesn't check (1.25xMn AND DUPMK1) region when the 1.25xMn layer is used as TM-1 <= 71.3%
 check_region = COPY CHIP_NOT_MARKS
 check_pattern = M6_all AND check_region
 // 
 check_window1 = check_region WITH WIDTH >= 50/4
 err1_TMP1 = DENSITY check_pattern check_window1 check_region [!!AREA(check_window1)*AREA(check_pattern)/AREA(check_region)] > 0.713 WINDOW 50 STEP 50/step_number BACKUP INSIDE OF LAYER DRC:1 BY POLYGON
 // 
 check_window2 = WITH WIDTH (check_region AND err1_TMP1) >= 50/4
 err1_TMP2 = DENSITY check_pattern check_window2 check_region [!!AREA(check_window2)*AREA(check_pattern)/AREA(check_region)] > 0.713 WINDOW 50 STEP 50/step_number BACKUP INSIDE OF LAYER err1_TMP1 BY POLYGON
 // 
 check_window3 = WITH WIDTH (check_region AND err1_TMP2) >= 50/4
 DENSITY check_pattern check_window3 check_region [!!AREA(check_window3)*AREA(check_pattern)/AREA(check_region)] > 0.713 WINDOW 50 STEP 50/step_number BACKUP INSIDE OF LAYER err1_TMP2 BY POLYGON PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_125xm6_DN_3.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_125xm6_DN_3.rdb"
}
 
125xm6_DN_4 {
@ 1.25xMn density difference between two neighboring checking windows (window 180um*180um, stepping 360um/step_number), except (NODMF) su 0.4um region <= 47.5%
 except_area = OR MARKS NODMF_SIZE_0.4
 check_pattern = M6_all NOT except_area
 check_region = DRC:1 NOT except_area
 DENSITY check_pattern check_region [AREA(check_pattern)/AREA(check_region)] >= 0 WINDOW 180 STEP 360/step_number GRADIENT > 0.475 ABSOLUTE BACKUP PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_125xm6_DN_4.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_125xm6_DN_4.rdb"
}
 

#IFDEF MINIMUM_DENSITY_CHECK YES


#ENDIF
#ENDIF

 

#IFDEF IP_LEVEL_DENSITY_CHECK NO
#IFDEF MINIMUM_DENSITY_CHECK YES

125xm6_DN_1 {
@ 1.25xMn Density (window 50um*50um, stepping 25um), except LOGO, MARKS, (OCOVL AND MnDUB), (NODMF su 1um) regions >= 10%
 except_area = OR LOGO MARKS (OCOVL AND M6DUB) NODMF_SIZE_1
 check_region = DRC:1 NOT except_area
 check_pattern = M6_all AND check_region
 // 
 check_window1 = check_region WITH WIDTH >= 50/4
 err1_TMP1 = DENSITY check_pattern check_window1 check_region [!AREA(check_window1) + !!AREA(check_window1)*AREA(check_pattern)/AREA(check_region)] < 0.1 WINDOW 50 STEP 25 BACKUP INSIDE OF LAYER DRC:1 BY POLYGON
 // 
 check_window2 = WITH WIDTH (check_region AND err1_TMP1) >= 50/4
 err1_TMP2 = DENSITY check_pattern check_window2 check_region [!AREA(check_window2) + !!AREA(check_window2)*AREA(check_pattern)/AREA(check_region)] < 0.1 WINDOW 50 STEP 25 BACKUP INSIDE OF LAYER err1_TMP1 BY POLYGON
 // 
 check_window3 = WITH WIDTH (check_region AND err1_TMP2) >= 50/4
 DENSITY check_pattern check_window3 check_region [!AREA(check_window3) + !!AREA(check_window3)*AREA(check_pattern)/AREA(check_region)] < 0.1 WINDOW 50 STEP 25 BACKUP INSIDE OF LAYER err1_TMP2 BY POLYGON PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_125xm6_DN_1.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_125xm6_DN_1.rdb"
}
 
125xm6_DN_1a {
@ 1.25xMn Density (window 50um*50um, stepping 25um), except the window not interact 3um*3um empty area, LOGO, MARKS, (OCOVL AND MnDUB), (NODMF su 1um) regions >= 25%
 except_area = OR LOGO MARKS (OCOVL AND M6DUB) NODMF_SIZE_1
 check_region = DRC:1 NOT except_area
 ck3x3_window = WITH WIDTH (check_region NOT M6_all) >= 3
 check_pattern = M6_all AND check_region
 // 
 check_window1 = check_region WITH WIDTH >= 50/4
 err1_TMP1 = DENSITY check_pattern check_window1 check_region ck3x3_window [!AREA(ck3x3_window) + !AREA(check_window1) + !!AREA(ck3x3_window)*!!AREA(check_window1)*AREA(check_pattern)/AREA(check_region)] < 0.25 WINDOW 50 STEP 25 BACKUP INSIDE OF LAYER DRC:1 BY POLYGON
 // 
 check_window2 = WITH WIDTH (check_region AND err1_TMP1) >= 50/4
 err1_TMP2 = DENSITY check_pattern check_window2 check_region ck3x3_window [!AREA(ck3x3_window) + !AREA(check_window2) + !!AREA(ck3x3_window)*!!AREA(check_window2)*AREA(check_pattern)/AREA(check_region)] < 0.25 WINDOW 50 STEP 25 BACKUP INSIDE OF LAYER err1_TMP1 BY POLYGON
 // 
 check_window3 = WITH WIDTH (check_region AND err1_TMP2) >= 50/4
 DENSITY check_pattern check_window3 check_region ck3x3_window [!AREA(ck3x3_window) + !AREA(check_window3) + !!AREA(ck3x3_window)*!!AREA(check_window3)*AREA(check_pattern)/AREA(check_region)] < 0.25 WINDOW 50 STEP 25 BACKUP INSIDE OF LAYER err1_TMP2 BY POLYGON PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_125xm6_DN_1a.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_125xm6_DN_1a.rdb"
}

#ENDIF


#IFDEF RECOMMENDED_CHECK YES

 
125xm6_DN_2_R {
@ 1.25xMn maximum density (window 50um*50um, stepping 25um), except dummy metal. DRC doesn't check (1.25xMn AND DUPMK1) region when the 1.25xMn layer is used as TM-1 <= 65%
 check_region = COPY CHIP_NOT_MARKS
 check_pattern = M6 AND check_region
 // 
 check_window1 = check_region WITH WIDTH >= 50/4
 err1_TMP1 = DENSITY check_pattern check_window1 check_region [!!AREA(check_window1)*AREA(check_pattern)/AREA(check_region)] > 0.65 WINDOW 50 STEP 25 BACKUP INSIDE OF LAYER DRC:1 BY POLYGON
 // 
 check_window2 = WITH WIDTH (check_region AND err1_TMP1) >= 50/4
 err1_TMP2 = DENSITY check_pattern check_window2 check_region [!!AREA(check_window2)*AREA(check_pattern)/AREA(check_region)] > 0.65 WINDOW 50 STEP 25 BACKUP INSIDE OF LAYER err1_TMP1 BY POLYGON
 // 
 check_window3 = WITH WIDTH (check_region AND err1_TMP2) >= 50/4
 DENSITY check_pattern check_window3 check_region [!!AREA(check_window3)*AREA(check_pattern)/AREA(check_region)] > 0.65 WINDOW 50 STEP 25 BACKUP INSIDE OF LAYER err1_TMP2 BY POLYGON PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_125xm6_DN_2_R.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_125xm6_DN_2_R.rdb"
}

#ENDIF

 
125xm6_DN_3 {
@ Maximum 1.25xMn density (window 50um*50um, stepping 25um). DRC doesn't check (1.25xMn AND DUPMK1) region when the 1.25xMn layer is used as TM-1 <= 75%
 check_region = COPY CHIP_NOT_MARKS
 check_pattern = M6_all AND check_region
 // 
 check_window1 = check_region WITH WIDTH >= 50/4
 err1_TMP1 = DENSITY check_pattern check_window1 check_region [!!AREA(check_window1)*AREA(check_pattern)/AREA(check_region)] > 0.75 WINDOW 50 STEP 25 BACKUP INSIDE OF LAYER DRC:1 BY POLYGON
 // 
 check_window2 = WITH WIDTH (check_region AND err1_TMP1) >= 50/4
 err1_TMP2 = DENSITY check_pattern check_window2 check_region [!!AREA(check_window2)*AREA(check_pattern)/AREA(check_region)] > 0.75 WINDOW 50 STEP 25 BACKUP INSIDE OF LAYER err1_TMP1 BY POLYGON
 // 
 check_window3 = WITH WIDTH (check_region AND err1_TMP2) >= 50/4
 DENSITY check_pattern check_window3 check_region [!!AREA(check_window3)*AREA(check_pattern)/AREA(check_region)] > 0.75 WINDOW 50 STEP 25 BACKUP INSIDE OF LAYER err1_TMP2 BY POLYGON PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_125xm6_DN_3.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_125xm6_DN_3.rdb"
}
 
125xm6_DN_4 {
@ 1.25xMn density difference between two neighboring checking windows (window 180um*180um, stepping 180um), except (NODMF) su 0.4um region <= 50%
 except_area = OR MARKS NODMF_SIZE_0.4
 check_pattern = M6_all NOT except_area
 check_region = DRC:1 NOT except_area
 DENSITY check_pattern check_region [AREA(check_pattern)/AREA(check_region)] >= 0 WINDOW 180 STEP 180 GRADIENT > 0.5 ABSOLUTE BACKUP PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_125xm6_DN_4.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_125xm6_DN_4.rdb"
}
 

#IFDEF MINIMUM_DENSITY_CHECK YES


#ENDIF
#ENDIF


//1.25xMn.R.1[NC] 1.25xMn pattern must drawn on data type 50 or 55
//1.25xMn.R.2[NC] It is not allowed for data type 50 and 55 exist on the same metal layer at the same time
//1.25xMn.R.3[NC] M5/M7 must be drawn on data type 55, M6/M8 must be drawn on data type 50, 1.25xMn and 1.25xMn-1 using same data type is not allowed


// =======================================================
// 1.25xMn design rules
// =======================================================

GROUP G125xm5 125xm5_?
 
125xm5_040 = M5 WITH WIDTH == 0.040
125xm5_042 = M5 WITH WIDTH == 0.042
125xm5_044 = M5 WITH WIDTH == 0.044
125xm5_046 = M5 WITH WIDTH == 0.046
125xm5_060 = M5 WITH WIDTH == 0.060
125xm5_080 = M5 WITH WIDTH == 0.080
125xm5_120 = M5 WITH WIDTH == 0.120
125xm5_160 = M5 WITH WIDTH == 0.160
125xm5_eqgt_060 = M5 WITH WIDTH >= 0.060
125xm5_eqgt_120 = 125xm5_eqgt_060 WITH WIDTH >= 0.120
125xm5_eqgt_121 = 125xm5_eqgt_060 WITH WIDTH >= 0.121
125xm5_eqgt_200 = 125xm5_eqgt_120 WITH WIDTH >= 0.200
125xm5_gt_060 = 125xm5_eqgt_060 WITH WIDTH > 0.060
125xm5_gt_160 = 125xm5_eqgt_060 WITH WIDTH > 0.160
125xm5_gt_080 = 125xm5_eqgt_060 WITH WIDTH > 0.080
 
125xm5_044_end = LENGTH M5_convex_90_90_edges <= 0.044
125xm5_060_end = LENGTH M5_convex_90_90_edges <= 0.060
M5_060_v_edges = INT [M5_v_edges] == 0.06 OPPOSITE
 

#IFDEF DFM_RULES_PRIORITY_1 YES

125xm5_S_3_DFM1 {
@ Recommended 1.25xMn space when either one 1.25xMn width > 1.35um. >= 0.450um
 chk_mn = M5 WITH WIDTH > 1.35
 err1 = EXT chk_mn M5 < 0.450 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xm5_A_1_DFM1 {
@ Recommended 1.25xMn area >= 0.02um2
 err1 = AREA M5 < 0.02
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xm5_R_9_V4_DFM1 {
@ 1.25xMn.R.9.DFM:
@ It's not recommended to use dense 1.25xMn 3-bar pattern
@ DRC flag conditions:
@ (1) Middle line width(W1) is <= 0.044um, both two neighbour 1.25xMn line width <= 0.06um and interact square or rectangle Vy or 1.25xVn
@ (2) 1.25xMn Space to both via (S1/S2)< 0.048um
@ (3) The via PRL: -0.1 < PRL < 0.1um
@ (4) Both neighbor 1.25xMn enclosure 1.25xVn or 1.25xVn-1 < 0.065um
@ This rule is not applied for INST region
 met_44_side = INT [M5] <= 0.044 ABUT<90 OPPOSITE
 met_60_side = INT [M5] <= 0.060 ABUT<90 OPPOSITE
 via_d_met = V4_SR NOT OUTSIDE (M5 WITH WIDTH <= 0.06)
 via_d_end = via_d_met TOUCH EDGE (ENC [via_d_met] 125xm5_060_end < 0.065 ABUT<90 OPPOSITE)
 via_d_lin = (via_d_met NOT TOUCH EDGE via_d_end) TOUCH EDGE (ENC [via_d_met] met_60_side <= 0.028 ABUT<90 OPPOSITE)
 via_d_mid = (via_d_met WITH EDGE via_d_end) WITH EDGE via_d_lin >= 2
 via_d_sid = via_d_mid TOUCH EDGE via_d_lin
 via_d_sps = (EXT [met_44_side] via_d_sid < 0.048 OPPOSITE EXTENDED 0.1 MEASURE ALL) TOUCH EDGE (EXT [met_44_side] via_d_sid < 0.048 OPPOSITE MEASURE ALL)
 err1 = INT via_d_sps <= 0.044 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE INST
}
 
125xm5_R_9_V5_DFM1 {
@ 1.25xMn.R.9.DFM:
@ It's not recommended to use dense 1.25xMn 3-bar pattern
@ DRC flag conditions:
@ (1) Middle line width(W1) is <= 0.044um, both two neighbour 1.25xMn line width <= 0.06um and interact square or rectangle Vy or 1.25xVn
@ (2) 1.25xMn Space to both via (S1/S2)< 0.048um
@ (3) The via PRL: -0.1 < PRL < 0.1um
@ (4) Both neighbor 1.25xMn enclosure 1.25xVn or 1.25xVn-1 < 0.065um
@ This rule is not applied for INST region
 met_44_side = INT [M5] <= 0.044 ABUT<90 OPPOSITE
 met_60_side = INT [M5] <= 0.060 ABUT<90 OPPOSITE
 via_u_met = V5_SR NOT OUTSIDE (M5 WITH WIDTH <= 0.06)
 via_u_end = via_u_met TOUCH EDGE (ENC [via_u_met] 125xm5_060_end < 0.065 ABUT<90 OPPOSITE)
 via_u_lin = (via_u_met NOT TOUCH EDGE via_u_end) TOUCH EDGE (ENC [via_u_met] met_60_side <= 0.028 ABUT<90 OPPOSITE)
 via_u_mid = (via_u_met WITH EDGE via_u_end) WITH EDGE via_u_lin >= 2
 via_u_sid = via_u_mid TOUCH EDGE via_u_lin
 via_u_sps = (EXT [met_44_side] via_u_sid < 0.048 OPPOSITE EXTENDED 0.1 MEASURE ALL) TOUCH EDGE (EXT [met_44_side] via_u_sid < 0.048 OPPOSITE MEASURE ALL)
 err1 = INT via_u_sps <= 0.044 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE INST
}

#ENDIF

125xm5_W_1 {
@ 1.25xMn width >= 0.04um
 err1 = INT M5 < 0.04 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xm5_W_1a {
@ 1.25xMn width in CP direction
@ The width should be even value when <= 0.046um
@ CP direction definition: Critical-Pitch direction along the minimum pitch (80nm) of 1.25xMn = 0.04~0.046, >= 0.060
 err1 = INT M5_v_edges < 0.040 ABUT<90 OPPOSITE REGION
 err2 = INT M5_v_edges > 0.040 < 0.042 ABUT<90 OPPOSITE REGION
 err3 = INT M5_v_edges > 0.042 < 0.044 ABUT<90 OPPOSITE REGION
 err4 = INT M5_v_edges > 0.044 < 0.046 ABUT<90 OPPOSITE REGION
 err5 = INT M5_v_edges > 0.046 < 0.060 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
 err4 NOT INSIDE SealR_NOT_BULK
 err5 NOT INSIDE SealR_NOT_BULK
}
 
125xm5_W_1b {
@ 1.25xMn width in NCP direction
@ NCP direction definition: Non-Critical-Pitch direction which is perpendicular to CP direction = 0.08, >= 0.120um
 err1 = INT M5_h_edges < 0.080 ABUT<90 OPPOSITE REGION
 err2 = INT M5_h_edges > 0.080 < 0.120 ABUT<90 OPPOSITE REGION EXCLUDE SHIELDED
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}
 
125xm5_W_2 {
@ 1.25xMn width, except MARKS, and LOGO regions. DRC doesn't flag (1.25xMn AND DUPMK1) region when the 1.25xMn layer is used as TM-1 <= 2.1um
 err1 = (M5 NOT INSIDE MARKS_LOGO) WITH WIDTH > 2.1
 err1 NOT INSIDE MARKS_LOGO
}
 
125xm5_W_3 {
@ 1.25xMn width of 45-degree bent metal >= 0.396um
 err1 = INT M5_45_skew_edges < 0.396 OPPOSITE REGION EXCLUDE SHIELDED
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xm5_W_4 {
@ 1.25xMn width of metal branch connected to wide metal width and length >= 0.401um. >= 0.08um
 dorian_large = M5 WITH WIDTH >= 0.401
 dorian_whole = M5 INTERACT dorian_large
 dorian_large_exp = SIZE dorian_large BY 0.005 INSIDE OF dorian_whole
 dorian_branch_0 = dorian_whole NOT dorian_large
 dorian_branch_1 = dorian_branch_0 NOT COIN EDGE dorian_large
 dorian_branch_2 = dorian_branch_1 TOUCH EDGE dorian_large_exp
 err1 = INT dorian_branch_2 < 0.08 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xm5_W_5 {
@ 1.25xMn width when PRL < 0um. >= 0.08um
 err1 = INT M5 < 0.08 ABUT<90 REGION CORNER TO CORNER
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xm5_S_1 {
@ 1.25xMn space >= 0.04um
 err1 = EXT M5 < 0.04 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xm5_S_2 {
@ Space between 1.25xMn when one or both width >= 0.201um when PRL >= -0.139um. >= 0.139um
 chk_Mn = M5 WITH WIDTH >= 0.201
 err1 = EXT M5 chk_Mn < 0.139 ABUT<90 OPPOSITE EXTENDED 0.139+GLOBAL_TOLERANCE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xm5_S_3 {
@ Space between 1.25xMn when one or both width >= 0.282um when PRL > 0.16um. >= 0.199um
 mets_RAW = (M5 WITH WIDTH >= 0.201) WITH WIDTH >= 0.282
 mets_sps_ERRS = EXT mets_RAW M5 < 0.199 ABUT<90 OPPOSITE
 mets_sps_AREA = EXT mets_RAW M5 < 0.199 ABUT<90 OPPOSITE REGION
 err1 = DFM PROPERTY mets_sps_AREA mets_sps_ERRS OVERLAP ABUT ALSO MULTI [-= EC(mets_sps_ERRS)] > 0.16
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xm5_S_4 {
@ Space between 1.25xMn when one or both width > 0.5um when PRL >= -0.199um. >= 0.199um
 chk_Mn = (M5 WITH WIDTH >= 0.201) WITH WIDTH > 0.5
 err1 = EXT M5 chk_Mn < 0.199 ABUT<90 OPPOSITE EXTENDED 0.199+GLOBAL_TOLERANCE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xm5_S_5 {
@ Space between 1.25xMn when one or both width > 1.35um when PRL > 1.35um. >= 0.448um
 met_wid_all = M5 WITH WIDTH >= 1.35+GLOBAL_TOLERANCE
 met_err_RAW = EXT M5 met_wid_all < 0.448 OPPOSITE REGION MEASURE ALL
 met_err_CRN = EXT (ANGLE M5 > 44 < 46) met_wid_all < 0.448 OPPOSITE1 REGION MEASURE ALL
 err1 = met_err_RAW ENCLOSE RECTANGLE 0.001 1.351 ORTHOGONAL ONLY
 err2 = met_err_CRN ENCLOSE RECTANGLE 0.04 1.351
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}
 
125xm5_S_6 {
@ Space between 1.25xMn in CP direction when one or both width = 0.04um. = 0.04, >= 0.07um
 err1_TMP = DFM SPACE M5 125xm5_040 < 0.04 BY EXT HORIZONTAL
 err2_TMP = DFM SPACE M5 125xm5_040 > 0.04 < 0.07 BY EXT HORIZONTAL
 // 
 waive_TMP = ANGLE 125xm5_060 == 90
 waive_EDG = EXT waive_TMP 125xm5_040 == 0.07 ABUT<90 OPPOSITE
 err1 = DFM COPY err1_TMP EDGE
 // NOT COIN EDGE (DFM COPY waive_EDG EDGE)
 err2 = DFM COPY err2_TMP EDGE
 // NOT COIN EDGE (DFM COPY waive_EDG EDGE)
 err1 NOT INSIDE EDGE SealR_NOT_BULK
 err2 NOT INSIDE EDGE SealR_NOT_BULK
}
 
125xm5_S_6a {
@ Space between 1.25xMn in CP direction when one or both width = 0.042um. = 0.048, >= 0.07um
 err1 = EXT M5_v_edges 125xm5_042 < 0.048 ABUT<90 OPPOSITE REGION
 err2 = EXT M5_v_edges 125xm5_042 > 0.048 < 0.07 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}
 
125xm5_S_7 {
@ Space between 1.25xMn in CP direction when one or both width = 0.044um. = 0.046, >= 0.07um
 err1 = EXT M5_v_edges 125xm5_044 < 0.046 ABUT<90 OPPOSITE REGION
 err2 = EXT M5_v_edges 125xm5_044 > 0.046 < 0.07 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}
 
125xm5_S_7a {
@ Space between 1.25xMn in CP direction when one or both width = 0.046um. = 0.046um, >= 0.07um
 err1 = EXT M5_v_edges 125xm5_046 < 0.046 ABUT<90 OPPOSITE REGION
 err2 = EXT M5_v_edges 125xm5_046 > 0.046 < 0.07 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}
 
125xm5_S_8 {
@ Space between 1.25xMn in CP direction when one or both width = 0.06um. = 0.04, 0.046, >= 0.06um
 waive_s_6a_chk = ANGLE 125xm5_060 == 90
 waive_s_6a = DFM COPY (EXT waive_s_6a_chk 125xm5_040 == 0.070 ABUT<90 OPPOSITE) EDGE
 bad_1 = DFM SPACE 125xm5_060 M5 < 0.040 BY EXT HORIZONTAL
 bad_2 = DFM SPACE 125xm5_060 M5 > 0.040 < 0.046 BY EXT HORIZONTAL
 bad_3 = DFM SPACE 125xm5_060 M5 > 0.046 < 0.060 BY EXT HORIZONTAL
 err1 = DFM COPY bad_1 EDGE
 // NOT COIN EDGE waive_s_6a
 err2 = DFM COPY bad_2 EDGE
 // NOT COIN EDGE waive_s_6a
 err3 = DFM COPY bad_3 EDGE
 // NOT COIN EDGE waive_s_6a
 err1 NOT INSIDE EDGE SealR_NOT_BULK
 err2 NOT INSIDE EDGE SealR_NOT_BULK
 err3 NOT INSIDE EDGE SealR_NOT_BULK
}
 
125xm5_S_8a {
@ Space between 1.25xMn in CP direction when one or both width > 0.06um when PRL > 0.08um. >= 0.06um
 met_wid_all = COPY 125xm5_gt_060
 met_err_RAW = EXT [met_wid_all] M5_v_edges < 0.06 ABUT<90 OPPOSITE MEASURE ALL
 met_jog_ALL = (CONVEX EDGE M5 == 1) NOT COIN EDGE met_err_RAW
 met_jog_EXP_a = EXPAND EDGE met_jog_ALL INSIDE BY 0.0005
 met_jog_EXP_b = EXPAND EDGE met_jog_ALL OUTSIDE BY 0.0005
 met_jog_TMP = (met_jog_ALL COIN EDGE (met_jog_EXP_a WITH EDGE met_err_RAW)) COIN EDGE (met_jog_EXP_b WITH EDGE met_err_RAW)
 met_jog_EXP = ((VERTEX (EXPAND EDGE met_jog_TMP OUTSIDE BY 0.001 EXTEND BY 0.001) == 4) OR (EXPAND EDGE met_err_RAW OUTSIDE BY 0.001)) NOT M5
 // 
 met_err_PRL = DFM PROPERTY met_jog_EXP met_err_RAW OVERLAP ABUT ALSO MULTI [-= LENGTH(met_err_RAW)] > 0.08
 met_err_EGE = met_err_RAW TOUCH EDGE met_err_PRL
 err1 = EXT met_err_EGE M5 < 0.06 ABUT<90 OPPOSITE REGION MEASURE ALL
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xm5_S_9 {
@ Space between 1.25xMn in CP direction, when one or both width = 0.06um, and the other side space < 0.06um. >= 0.079um
 mets_sps_060 = EXT [M5_060_v_edges] M5 < 0.06 ABUT<90 OPPOSITE
 mets_sps_080 = EXT [M5_060_v_edges] M5 < 0.079 ABUT<90 OPPOSITE
 err1 = INT mets_sps_060 mets_sps_080 == 0.06 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
M5_convex_90_270_edges_gt_040 = ANGLE (CONVEX EDGE M5 ANGLE1 == 90 ANGLE2 == 270 WITH LENGTH > 0.04) == 0
M5_width_eq_080 = M5 WITH WIDTH == 0.08
 
125xm5_S_10 {
@ Space between 1.25xMn in CP direction when one or both width >= 0.08um. >= 0.079um
@ Except Z shape and flag shape:
@ (1) Z-shape definition: edge length > 0.040um between two consecutive 90-270 degree corners, corresponding width = 0.08um in NCP direction between two opposite edge length > 0.04um, not including T-shape
@ (2) Flag-shape definition: edge length > 0.04um between two consecutive 90-270 degree corners, the opposite edge length > 0.08um between two consecutive 90-90 degree corners, corresponding width = 0.08um in NCP direction between these two opposite edge, and the other corresponding width > 0.04um in CP direction
 flag_shape_l_side = LENGTH M5_convex_90_90_edges > 0.08
 flag_shape_s_side = ANGLE (LENGTH M5_convex_90_90_edges == 0.08) == 90
 flag_shape = (M5_width_eq_080 INTERACT (INT M5_convex_90_270_edges_gt_040 flag_shape_l_side == 0.08 ABUT<90 OPPOSITE REGION)) WITH EDGE flag_shape_s_side
 zfig_shape = (M5_width_eq_080 INTERACT (INT M5_convex_90_270_edges_gt_040 == 0.08 ABUT<90 OPPOSITE REGION)) NOT WITH EDGE flag_shape_s_side
 waive_shape = (OR zfig_shape flag_shape) NOT COIN EDGE (INT [M5_v_edges] == 0.08 ABUT<90 OPPOSITE) // horizontal width=0.08 need to flag
 // 
 check_edge = INT (M5_v_edges) < 0.08 ABUT<90 OPPOSITE
 check_shape = check_edge NOT COIN EDGE waive_shape
 err1 = EXT check_shape (M5 NOT COIN EDGE waive_shape) < 0.079 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xm5_S_11 {
@ Space between 1.25xMn in CP direction when one or both width >= 0.121um, PRL > 0.08um. >= 0.099um
 mets_sps_100_ERRS = EXT 125xm5_eqgt_121 M5_v_edges < 0.099 ABUT<90 OPPOSITE
 mets_sps_100_AREA = EXT 125xm5_eqgt_121 M5_v_edges < 0.099 ABUT<90 OPPOSITE REGION
 err1 = DFM PROPERTY mets_sps_100_AREA mets_sps_100_ERRS OVERLAP ABUT ALSO MULTI [-= EC(mets_sps_100_ERRS)] > 0.08
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xm5_S_12 {
@ Space between 1.25xMn (CP direction width > 0.16um and NCP direction width > 0.08um) and 1.25xMn edge (edge length > 0.08um in NCP direction) in CP direction >= 0.119um
 mets_L_sides = (INT (M5_v_edges) <= 0.16 ABUT<90 OPPOSITE EXCLUDE SHIELDED) COIN EDGE 125xm5_gt_080
 mets_R_sides = LENGTH M5_v_edges > 0.08
 err1 = EXT mets_R_sides (mets_L_sides COIN EDGE mets_R_sides) < 0.119 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xm5_S_13 {
@ Space between 1.25xMn in CP direction when one or both width >= 0.201um, PRL >= 0.121um. >= 0.144um
 mets_RAW = M5 WITH WIDTH >= 0.201
 mets_sps_ERRS = EXT mets_RAW M5_v_edges < 0.144 ABUT<90 OPPOSITE
 mets_sps_AREA = EXT mets_RAW M5_v_edges < 0.144 ABUT<90 OPPOSITE REGION
 err1 = DFM PROPERTY mets_sps_AREA mets_sps_ERRS OVERLAP ABUT ALSO MULTI [-= EC(mets_sps_ERRS)] >= 0.121
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xm5_S_14 {
@ Space between 1.25xMn in CP direction when one or both width >= 0.231um, PRL >= 0.121um. >= 0.159um
 mets_RAW = (M5 WITH WIDTH >= 0.201) WITH WIDTH >= 0.231
 mets_sps_ERRS = EXT mets_RAW M5_v_edges < 0.159 ABUT<90 OPPOSITE
 mets_sps_AREA = EXT mets_RAW M5_v_edges < 0.159 ABUT<90 OPPOSITE REGION
 err1 = DFM PROPERTY mets_sps_AREA mets_sps_ERRS OVERLAP ABUT ALSO MULTI [-= EC(mets_sps_ERRS)] >= 0.121
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xm5_S_15 {
@ Space between 1.25xMn and 1.25xMn line-end (width = 0.08um and both adiacent edge length > 0.09um) in CP direction when PRL > -0.08um. >= 0.099um
 lend_RAW = CONVEX EDGE M5 ANGLE1 == 90 LENGTH1 > 0.09 ANGLE2 == 90 LENGTH2 > 0.09 WITH LENGTH == 0.08
 lend_CHK = ANGLE lend_RAW == 90
 err1 = EXT lend_CHK M5 < 0.099 ABUT<90 OPPOSITE EXTENDED 0.08 REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xm5_S_16 {
@ Space between 1.25xMn in NCP direction when one or both width = 0.08um, 0.12um. >= 0.08um
 mets_RAW = 125xm5_080 OR 125xm5_120
 mets_CHK = ANGLE mets_RAW == 0
 err1 = EXT mets_CHK M5 < 0.08 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xm5_S_17 {
@ Space between 1.25xMn (0.16um <= NCP direction width < 0.2um and CP direction width > 0.08um) and 1.25xMn edge (edge length > 0.08um in CP direction) in NCP direction >= 0.099um
 mets_L_sides = (INT [M5_h_edges] >= 0.16 < 0.2 ABUT<90 OPPOSITE EXCLUDE SHIELDED) COIN EDGE 125xm5_gt_080
 mets_R_sides = LENGTH M5_h_edges > 0.08
 err1 = EXT mets_R_sides (mets_L_sides COIN EDGE mets_R_sides) < 0.099 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xm5_S_18 {
@ Space between 1.25xMn in NCP direction when one or both width > 0.12um, PRL >= 0.121um. >= 0.119um
 err1_TMP = EXT 125xm5_eqgt_121 M5_h_edges < 0.119 ABUT<90 OPPOSITE REGION
 err1 = err1_TMP ENCLOSE RECTANGLE 0.001 0.121 ORTHOGONAL ONLY
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xm5_S_19 {
@ Space between 1.25xMn (NCP direction width >= 0.2um and CP direction width > 0.08um) and 1.25xMn edge (edge length > 0.08um in CP direction) in NCP direction >= 0.139um
 mets_L_sides = (INT (M5_h_edges) < 0.2 ABUT<90 OPPOSITE EXCLUDE SHIELDED) COIN EDGE 125xm5_gt_080
 mets_R_sides = LENGTH M5_h_edges > 0.08
 err1 = EXT mets_R_sides (mets_L_sides COIN EDGE mets_R_sides) < 0.139 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xm5_S_20 {
@ Space between 1.25xMn in NCP direction when one or both width > 0.16um when PRL > 0.2um. >= 0.159um
 err1_TMP = EXT 125xm5_gt_160 M5_h_edges < 0.159 ABUT<90 OPPOSITE REGION
 err1 = err1_TMP ENCLOSE RECTANGLE 0.001 0.20+GLOBAL_TOLERANCE ORTHOGONAL ONLY
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xm5_S_21 {
@ Space between 1.25xMn and 1.25xMn line-end (width = 0.04/0.042um) in NCP direction when PRL > -0.04um. >= 0.099um
 lend_RAW = LENGTH M5_convex_eq_two_edges >= 0.04 <= 0.042
 lend_CHK = ANGLE lend_RAW == 0
 err1 = EXT lend_CHK M5 < 0.099 ABUT<90 OPPOSITE EXTENDED 0.04 REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xm5_S_21a {
@ Space between 1.25xMn and 1.25xMn line-end (width = 0.044/0.046/0.06um) in NCP direction when PRL > -0.04um. >= 0.080um
 lend_RAW_a = LENGTH M5_convex_eq_two_edges >= 0.044 <= 0.046
 lend_RAW_b = LENGTH M5_convex_eq_two_edges == 0.06
 lend_CHK = ANGLE (lend_RAW_a OR EDGE lend_RAW_b) == 0
 err1 = EXT lend_CHK M5 < 0.08 ABUT<90 OPPOSITE EXTENDED 0.04 REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xm5_S_22 {
@ Space between 1.25xMn and 1.25xMn line-end (0.06um < width <= 0.08um) in NCP direction when PRL > -0.08um. >= 0.08um
 lend_RAW = LENGTH M5_convex_eq_two_edges > 0.06 <= 0.08
 lend_CHK = ANGLE lend_RAW == 0
 err1 = EXT lend_CHK M5 < 0.08 ABUT<90 OPPOSITE EXTENDED 0.08 REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xm5_S_23 {
@ Space between 1.25xMn line-end (width < 0.08um) and U-shape inner edge (edge length <= 0.149um between two concave corners) in NCP direction >= 0.149um
 mets_U_sides = LENGTH M5_convex_270_270_edges <= 0.149
 err1 = EXT M5_end_080 mets_U_sides < 0.149 ABUT<90 OPPOSITE EXTENDED 0.04 REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xM5_GROUP_80 = SIZE (SIZE (SIZE 125xm5_040 BY 0.02) BY -0.04) BY 0.02
125xM5_GROUP_90_1 = SIZE (SIZE (SIZE 125xm5_044 BY 0.023) BY -0.046) BY 0.023
125xM5_GROUP_90_2 = SIZE (SIZE (SIZE 125xm5_042 BY 0.024) BY -0.048) BY 0.024
125xM5_GROUP_90 = OR 125xM5_GROUP_90_1 125xM5_GROUP_90_2
 
125xm5_S_24a {
@ Space between 1.25xMn_Group_80 and 1.25xMn_Group_90 in CP direction when PRL > -0.08um. >= 0.199um
@ 1.25xMn_Group_80 definition: (((1.25xMn (width = 0.040um) SIZING 0.020um) SIZING -0.040um) SIZING 0.020um)
@ 1.25xMn_Group_90 definition: 1) (((1.25xMn (width = 0.044um) su 0.023um) sd -0.046um) su 0.023um). 2) (((1.25xMn (width = 0.042um) su 0.024um) sd -0.048um) su 0.024um)
 line_080 = ANGLE 125xM5_GROUP_80 == 90
 line_090 = ANGLE 125xM5_GROUP_90 == 90
 err1 = EXT line_080 line_090 < 0.199 ABUT<90 OPPOSITE EXTENDED 0.08 REGION MEASURE ALL
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xm5_S_24b {
@ Space between 1.25xMn line-end inside 1.25xMn_Group_80 and 1.25xMy line-end of 1.25xMn_Group_90 in NCP direction when PRL > -0.199um. >= 0.149um
 lend_080 = ANGLE (M5_end NOT OUTSIDE EDGE 125xM5_GROUP_80) == 0
 lend_090 = ANGLE (M5_end NOT OUTSIDE EDGE 125xM5_GROUP_90) == 0
 err1 = EXT lend_080 lend_090 < 0.149 ABUT<90 OPPOSITE EXTENDED 0.199 REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xm5_S_25 {
@ Corner projected space between 1.25xMn when -0.08um < PRL <= 0um. >= 0.08um
@ Except line end-to-end (width <= 0.06um), Z-shape, and flag-shape:
@ Definition of Z-shape /flag-shape:
@ 1) Z-shape: edge length > 0.040um between two consecutive 90-270 degree corners, corresponding width = 0.08um in NCP direction between two opposite edge length > 0.040um, not including T-shape
@ 2) flag-shape: edge length > 0.04um between two consecutive 90-270 degree corners, the opposite edge length > 0.08um between two consecutive 90-90 degree corners, corresponding width = 0.08um in NCP direction between these 2 opposite edge, and the other corresponding width > 0.04um in CP direction
 line_end = (CONVEX EDGE M5 ANGLE1 == 90 ANGLE2 == 90 WITH LENGTH <= 0.06) COIN EDGE M5_h_edges
 // 
 flag_shape_l_side = LENGTH M5_convex_90_90_edges > 0.08
 flag_shape_s_side = ANGLE (LENGTH M5_convex_90_90_edges == 0.08) == 90
 flag_shape = (M5_width_eq_080 INTERACT (INT M5_convex_90_270_edges_gt_040 flag_shape_l_side == 0.08 ABUT<90 OPPOSITE REGION)) WITH EDGE flag_shape_s_side
 zfig_shape = (M5_width_eq_080 INTERACT (INT M5_convex_90_270_edges_gt_040 == 0.08 ABUT<90 OPPOSITE REGION)) NOT WITH EDGE flag_shape_s_side
 waive_shape = OR zfig_shape flag_shape
 // 
 corner_space_prl_lt_0 = EXT M5 < 0.08*1.414 CORNER TO CORNER
 corner_space_prl_eq_0 = EXT line_end M5 < 0.08 PROJ == 0
 corner_space_all_TMP = DFM COPY corner_space_prl_lt_0 corner_space_prl_eq_0
 corner_space_all = DFM PROPERTY corner_space_all_TMP line_end waive_shape OVERLAP ABUT ALSO MULTI 
 [-= (count(line_end) > 0 && count(waive_shape) == 0) ? 1 : 0] > 0 
 [-= (EWXP(corner_space_all_TMP) < 0.08 && EWYP(corner_space_all_TMP) < 0.08) ? 1 : 0] > 0
 err1_TMP = DFM PROPERTY corner_space_all line_end OVERLAP ABUT ALSO MULTI [-= (count(line_end) == 0 || count(line_end) < 2) ? 1 : 0] > 0
 err1 = DFM COPY err1_TMP REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xm5_S_25a {
@ Corner space between two 1.25xMn in NCP direction when -0.04um < PRL <= 0um. >= 0.08um
 err1_RAW = EXT M5 < 0.08 ABUT<90 CORNER TO CORNER
 err1_TMP = DFM PROPERTY err1_RAW GLOBALXY [-= EWXP(err1_RAW)] < 0.04
 err1_SPE = EXT M5 M5_h_edges < 0.08 ABUT<90 REGION PROJ == 0
 err1 = (DFM COPY err1_TMP REGION) OR err1_SPE
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xm5_S_26 {
@ At least one space between 1.25xMn edge (any adjacent edge of concave corner) and 1.25xMn >= 0.119um, except either condition as below:
@ 1. Edge length between two concave corners < 0.12um
@ 2. Side edge length of concave corner < 0.042um
 waive_edge_a = LENGTH M5_convex_270_270_edges < 0.120
 waive_edge_b = LENGTH M5_convex_lt_two_edges < 0.042
 check_edge = (LENGTH M5_convex_lt_two_edges >= 0.042) NOT COIN EDGE M5_45_skew_edges
 // 
 Y1 = EXT [M5] check_edge < 0.119 ABUT<90 OPPOSITE EXTENDED 0.119
 Y2 = INT [Y1] < 0.001 ABUT==90 INTERSECTING ONLY
 Y3 = EXT Y2 check_edge < 0.119 ABUT<90 OPPOSITE EXTENDED 0.119
 err1_TMP = EXT (DFM COPY Y3 EDGE) < 0.04 ABUT==90 INTERSECTING ONLY REGION EXTENTS
 err1 = (err1_TMP NOT WITH EDGE waive_edge_a) NOT WITH EDGE waive_edge_b
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xm5_S_27 {
@ Space between 1.25xMy concave corner (both side edge length > 0.08um) and 1.25xMy line-end (width < 0.08um) >= 0.154um
 mets_CHK = LENGTH M5_convex_lt_two_edges > 0.08
 mets_CRN = EXT [mets_CHK] < 0.0005 ABUT==90 INTERSECTING ONLY // resolution concern
 // 
 err1_RAW = EXT M5_convex_lt_two_edges M5_end_080 < 0.154 ABUT EXCLUDE SHIELDED
 err1_HAS = mets_CRN COIN EDGE M5_convex_lt_two_edges
 err1_TMP = DFM PROPERTY err1_RAW err1_HAS ABUT ALSO OVERLAP MULTI [-= count(err1_HAS)] > 0
 err1 = DFM COPY err1_TMP REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
M5_space_eq_040_v_edges = EXT [M5_v_edges] == 0.04 OPPOSITE
M5_space_eq_040_v_areas = EXT M5_v_edges == 0.04 OPPOSITE REGION
M5_space_eq_040_v_areas_v_edges = ANGLE M5_space_eq_040_v_areas == 90
M5_width_lt_080_v_edges = (INT [M5_v_edges] < 0.08 ABUT<90 OPPOSITE) COIN EDGE (M5 WITH WIDTH < 0.08)
 
125xm5_S_28 {
@ Forbidden the space between 1.25xMn (width = 0.04~0.046um and one side space = 0.04um) and 1.25xMn (width < 0.08um (W1)) in CP direction, except both side space of 1.25xMy (width < 0.08um) to 1.25xMy >= 0.1um. = 0.061~0.098, 0.131~0.178um
 Mn_w040_w042 = WITH WIDTH M5 >= 0.04 <= 0.046
 Mn_w040_s040_v_edges = Mn_w040_w042 COIN EDGE M5_space_eq_040_v_edges
 Mn_w040_s040_v_edges_opp = INT Mn_w040_s040_v_edges [Mn_w040_w042] >= 0.04 <= 0.046 ABUT<90 OPPOSITE
 // not check W1 >= 0.08
 // 
 Mn_w080_s99_v_edges = EXT (M5_width_lt_080_v_edges) < 0.10 ABUT<90 OPPOSITE
 Mn_w080_s99_v_edges_both = INT [Mn_w080_s99_v_edges] < 0.08 ABUT<90 OPPOSITE
 Mn_w080_s99_v_edges_none = M5_width_lt_080_v_edges NOT COIN EDGE Mn_w080_s99_v_edges_both
 err1 = EXT Mn_w080_s99_v_edges_none Mn_w040_s040_v_edges_opp >= 0.131 <= 0.178 ABUT<90 OPPOSITE REGION EXCLUDE SHIELDED
 err2 = EXT Mn_w080_s99_v_edges_none Mn_w040_s040_v_edges_opp >= 0.061 <= 0.098 ABUT<90 OPPOSITE REGION EXCLUDE SHIELDED
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}
 
125xm5_S_29 {
@ Fobidden space between 1.25xMy (width = 0.06~0.07um and one side space = 0.04um) and 1.25xMy (width < 0.08um) in CP direction, except both side space of 1.25xMy (width < 0.08um) to 1.25xMy >= 0.1um. = 0.11~0.158um
 Mn_w060_w070 = WITH WIDTH M5 >= 0.06 <= 0.07
 Mn_w060_s040_v_edges = Mn_w060_w070 COIN EDGE M5_space_eq_040_v_edges
 Mn_w060_s040_v_edges_opp = INT Mn_w060_s040_v_edges [Mn_w060_w070] >= 0.06 <= 0.07 ABUT<90 OPPOSITE
 // not check W1 >= 0.08
 // 
 Mn_w080_s99_v_edges = EXT (M5_width_lt_080_v_edges) < 0.10 ABUT<90 OPPOSITE
 Mn_w080_s99_v_edges_both = INT [Mn_w080_s99_v_edges] < 0.08 ABUT<90 OPPOSITE
 Mn_w080_s99_v_edges_none = M5_width_lt_080_v_edges NOT COIN EDGE Mn_w080_s99_v_edges_both
 err1 = EXT Mn_w080_s99_v_edges_none Mn_w060_s040_v_edges_opp >= 0.110 <= 0.158 ABUT<90 OPPOSITE REGION EXCLUDE SHIELDED
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xm5_S_30 {
@ Space between 1.25xMn and 45-degree bent 1.25xMn, DRC check 45-degree direction >= 0.396um
 err1 = EXT M5 M5_45_skew_edges < 0.396 ABUT<90 OPPOSITE2 REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
//;125xmn_S_31~125xmn_S_37a: delta voltage rule
 
125xm5_L_1 {
@ Length of 45-degree bent 1.25xMn, except MARKS >= 0.905um
 err1 = LENGTH M5_45_skew_edges < 0.905
 err1 NOT INSIDE EDGE MARKS
}
 
125xm5_L_2 {
@ 1.25xMn edge length when the adjacent edge length <= 0.089um, except two 0.08um edges form a convex corner. >= 0.099um
 chk_condition = LENGTH M5 <= 0.089
 err_EdgLength = LENGTH M5 < 0.099
 waive_CASE = INT (LENGTH chk_condition == 0.08) (LENGTH err_EdgLength == 0.08) < 0.005 ABUT INTERSECTING ONLY REGION
 err1_TMP_A = EXT chk_condition err_EdgLength < 0.005 ABUT INTERSECTING ONLY REGION
 err1_TMP_B = (INT chk_condition err_EdgLength < 0.005 ABUT INTERSECTING ONLY REGION) NOT INTERACT waive_CASE
 err1 = OR (EXPAND EDGE (M5 TOUCH EDGE err1_TMP_A) OUTSIDE BY 0.001 EXTEND BY 0.001) (EXPAND EDGE (M5 TOUCH EDGE err1_TMP_B) OUTSIDE BY 0.001 EXTEND BY 0.001)
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xm5_L_3 {
@ 1.25xMn edge length when the adjacent edge length < 0.04um. >= 0.119um
 chk_condition = LENGTH M5 < 0.04
 err_EdgLength = LENGTH M5 < 0.119
 err1_TMP_A = EXT chk_condition err_EdgLength < 0.005 ABUT INTERSECTING ONLY REGION
 err1_TMP_B = INT chk_condition err_EdgLength < 0.005 ABUT INTERSECTING ONLY REGION
 err1 = OR (EXPAND EDGE (M5 TOUCH EDGE err1_TMP_A) OUTSIDE BY 0.001 EXTEND BY 0.001) (EXPAND EDGE (M5 TOUCH EDGE err1_TMP_B) OUTSIDE BY 0.001 EXTEND BY 0.001)
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xm5_L_4 {
@ 1.25xMn edge length when the adjacent line-end width < 0.06um. >= 0.159um
 chk_condition = EXPAND EDGE M5_end_060 INSIDE BY 0.001
 err_EdgLength = (M5_convex_eq_one_edges TOUCH EDGE chk_condition) NOT COIN EDGE M5_end_060
 err1 = LENGTH err_EdgLength < 0.159
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
125xm5_L_5 {
@ 1.25xMn edge length when the adjacent line-end width < 0.08um. >= 0.109um
 chk_condition = EXPAND EDGE M5_end_080 INSIDE BY 0.001
 err_EdgLength = (M5_convex_eq_one_edges TOUCH EDGE chk_condition) NOT COIN EDGE M5_end_080
 err1 = LENGTH err_EdgLength < 0.109
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
125xm5_L_6 {
@ 1.25xMn edge length between two consecutive 90-270 degree corners >= 0.019um
 // DRC also check the condition with at least one 90-270 degree corners
 mets_ERRS_EDGE = LENGTH M5_convex_270_90_edges < 0.019
 mets_ERRS_a = INT mets_ERRS_EDGE M5_convex_eq_one_edges < 0.005 ABUT==90 INTERSECTING ONLY REGION
 mets_ERRS_b = EXT mets_ERRS_EDGE M5_convex_eq_one_edges < 0.005 ABUT==90 INTERSECTING ONLY REGION
 err1_TMP = (M5_convex_eq_one_edges TOUCH EDGE mets_ERRS_a) OR EDGE (M5_convex_eq_one_edges TOUCH EDGE mets_ERRS_b)
 err1 = EXPAND EDGE err1_TMP INSIDE BY 0.001 CORNER FILL
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xm5_L_7 {
@ 1.25xMn edge length between two consecutive 90-270 degree corners with one adjacent line end edge width < 0.08um and the other adjacent edge > 0.070um. >= 0.238um
 line_CHK_a_RAW = LENGTH M5_convex_270_90_edges > 0.07 < 0.238
 line_CHK_a_TMP = EXPAND EDGE M5_end_080 INSIDE BY 0.001
 line_CHK_a = (line_CHK_a_RAW NOT TOUCH EDGE M5_end_080) TOUCH EDGE line_CHK_a_TMP
 line_CHK_b = LENGTH M5_convex_lt_two_edges > 0.07
 err1 = EXT line_CHK_b line_CHK_a < 0.005 ABUT==90 INTERSECTING REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xm5_L_8 {
@ 1.25xMn U-shape inner edge length between two consecutive 270-270 degree corners >= 0.08um
 err1 = LENGTH M5_convex_270_270_edges < 0.08
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
125xm5_L_9_V4 {
@ Length of 1.25xMn metal branch (width <= 0.269um) >= 1.5um
@ When:
@ 1. Metal branch is connected to wide metal with width and length >= 0.398um
@ 2. One square 1.25xVn-1/1.25xVn in metal branch, and space to wide metal <= 1.5um
@ DRC flags branch that can't enclose a 0.08um*1.5um orthogonal rectangle
@ ("V4_50" is mapped to "V4" in the rule name of this check)
 WIDE_M5 = (WITH WIDTH M5 > 0.398-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 0.398-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 0.398-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 branch_all = ((SIZE WIDE_M5 BY 1.5+GLOBAL_TOLERANCE INSIDE OF M5 STEP 0.025) NOT WIDE_M5) AND M5
 branch_size = INT (M5 INTERACT branch_all) < 0.269+GLOBAL_TOLERANCE ABUT<90 OPPOSITE REGION EXCLUDE SHIELDED
 branch_real = branch_size INTERACT WIDE_M5
 branch_down = (branch_real AND M4) INTERACT DVK_V4_SQ == 1
 branch_down_real = ((M5 INTERACT branch_down) AND M4) INTERACT DVK_V4_SQ == 1
 branch_down_err1 = branch_real NOT OUTSIDE branch_down_real
 err1_down = branch_down_err1 NOT ENCLOSE RECTANGLE 0.08 1.5 ORTHOGONAL ONLY
 // 
 branch_up = (branch_real AND M6) INTERACT (RECTANGLE V5 ASPECT == 1) == 1
 branch_up_real = ((M5 INTERACT branch_up) AND M6) INTERACT (RECTANGLE V5 ASPECT == 1) == 1
 branch_up_err2 = branch_real NOT OUTSIDE branch_up_real
 err2_up = branch_up_err2 NOT ENCLOSE RECTANGLE 0.08 1.5 ORTHOGONAL ONLY
 err1_down NOT INSIDE SealR_NOT_BULK
}
 
125xm5_L_9_V5 {
@ Length of 1.25xMn metal branch (width <= 0.269um) >= 1.5um
@ When:
@ 1. Metal branch is connected to wide metal with width and length >= 0.398um
@ 2. One square 1.25xVn-1/1.25xVn in metal branch, and space to wide metal <= 1.5um
@ DRC flags branch that can't enclose a 0.08um*1.5um orthogonal rectangle
@ ("V5_50" is mapped to "V5" in the rule name of this check)
 WIDE_M5 = (WITH WIDTH M5 > 0.398-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 0.398-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 0.398-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 branch_all = ((SIZE WIDE_M5 BY 1.5+GLOBAL_TOLERANCE INSIDE OF M5 STEP 0.025) NOT WIDE_M5) AND M5
 branch_size = INT (M5 INTERACT branch_all) < 0.269+GLOBAL_TOLERANCE ABUT<90 OPPOSITE REGION EXCLUDE SHIELDED
 branch_real = branch_size INTERACT WIDE_M5
 branch_down = (branch_real AND M4) INTERACT DVK_V4_SQ == 1
 branch_down_real = ((M5 INTERACT branch_down) AND M4) INTERACT DVK_V4_SQ == 1
 branch_down_err1 = branch_real NOT OUTSIDE branch_down_real
 err1_down = branch_down_err1 NOT ENCLOSE RECTANGLE 0.08 1.5 ORTHOGONAL ONLY
 // 
 branch_up = (branch_real AND M6) INTERACT (RECTANGLE V5 ASPECT == 1) == 1
 branch_up_real = ((M5 INTERACT branch_up) AND M6) INTERACT (RECTANGLE V5 ASPECT == 1) == 1
 branch_up_err2 = branch_real NOT OUTSIDE branch_up_real
 err2_up = branch_up_err2 NOT ENCLOSE RECTANGLE 0.08 1.5 ORTHOGONAL ONLY
 err2_up NOT INSIDE SealR_NOT_BULK
}
 
125xm5_L_10_V4 {
@ Length of 1.25xMn metal branch (width <= 0.269um) >= 3.6um
@ When:
@ 1. Metal branch is connected to wide metal with width and length > 0.9um
@ 2. One square 1.25xVn-1/1.25xVn in metal branch, and space to wide metal <= 3.6um
@ DRC flags branch that can't enclose a 0.08um*3.6um orthogonal rectangle
@ ("V4_50" is mapped to "V4" in the rule name of this check)
 WIDE_M5 = (WITH WIDTH M5 > 0.9) ENCLOSE RECTANGLE 0.9+GLOBAL_TOLERANCE 0.9+GLOBAL_TOLERANCE
 branch_all = ((SIZE WIDE_M5 BY 3.6+GLOBAL_TOLERANCE INSIDE OF M5 STEP 0.025) NOT WIDE_M5) AND M5
 branch_size = INT (M5 INTERACT branch_all) < 0.269+GLOBAL_TOLERANCE ABUT<90 OPPOSITE REGION EXCLUDE SHIELDED
 branch_real = branch_size INTERACT WIDE_M5
 branch_down = (branch_real AND M4) INTERACT DVK_V4_SQ == 1
 branch_down_real = ((M5 INTERACT branch_down) AND M4) INTERACT DVK_V4_SQ == 1
 branch_down_err1 = branch_real NOT OUTSIDE branch_down_real
 err1_down = branch_down_err1 NOT ENCLOSE RECTANGLE 0.08 3.6 ORTHOGONAL ONLY
 // 
 branch_up = (branch_real AND M6) INTERACT (RECTANGLE V5 ASPECT == 1) == 1
 branch_up_real = ((M5 INTERACT branch_up) AND M6) INTERACT (RECTANGLE V5 ASPECT == 1) == 1
 branch_up_err2 = branch_real NOT OUTSIDE branch_up_real
 err2_up = branch_up_err2 NOT ENCLOSE RECTANGLE 0.08 3.6 ORTHOGONAL ONLY
 err1_down NOT INSIDE SealR_NOT_BULK
}
 
125xm5_L_10_V5 {
@ Length of 1.25xMn metal branch (width <= 0.269um) >= 3.6um
@ When:
@ 1. Metal branch is connected to wide metal with width and length > 0.9um
@ 2. One square 1.25xVn-1/1.25xVn in metal branch, and space to wide metal <= 3.6um
@ DRC flags branch that can't enclose a 0.08um*3.6um orthogonal rectangle
@ ("V5_50" is mapped to "V5" in the rule name of this check)
 WIDE_M5 = (WITH WIDTH M5 > 0.9) ENCLOSE RECTANGLE 0.9+GLOBAL_TOLERANCE 0.9+GLOBAL_TOLERANCE
 branch_all = ((SIZE WIDE_M5 BY 3.6+GLOBAL_TOLERANCE INSIDE OF M5 STEP 0.025) NOT WIDE_M5) AND M5
 branch_size = INT (M5 INTERACT branch_all) < 0.269+GLOBAL_TOLERANCE ABUT<90 OPPOSITE REGION EXCLUDE SHIELDED
 branch_real = branch_size INTERACT WIDE_M5
 branch_down = (branch_real AND M4) INTERACT DVK_V4_SQ == 1
 branch_down_real = ((M5 INTERACT branch_down) AND M4) INTERACT DVK_V4_SQ == 1
 branch_down_err1 = branch_real NOT OUTSIDE branch_down_real
 err1_down = branch_down_err1 NOT ENCLOSE RECTANGLE 0.08 3.6 ORTHOGONAL ONLY
 // 
 branch_up = (branch_real AND M6) INTERACT (RECTANGLE V5 ASPECT == 1) == 1
 branch_up_real = ((M5 INTERACT branch_up) AND M6) INTERACT (RECTANGLE V5 ASPECT == 1) == 1
 branch_up_err2 = branch_real NOT OUTSIDE branch_up_real
 err2_up = branch_up_err2 NOT ENCLOSE RECTANGLE 0.08 3.6 ORTHOGONAL ONLY
 err2_up NOT INSIDE SealR_NOT_BULK
}
 
125xm5_L_11_V4 {
@ Length of 1.25xMn metal branch (width <= 0.269um) >= 9um
@ When:
@ 1. Metal branch is connected to wide metal with width and length > 1.35um
@ 2. One square 1.25xVn-1/1.25xVn in metal branch, and space to wide metal <= 9um
@ DRC flags branch that can't enclose a 0.08um*9um orthogonal rectangle
@ ("V4_50" is mapped to "V4" in the rule name of this check)
 WIDE_M5 = (WITH WIDTH M5 > 1.35) ENCLOSE RECTANGLE 1.35+GLOBAL_TOLERANCE 1.35+GLOBAL_TOLERANCE
 branch_all = ((SIZE WIDE_M5 BY 9+GLOBAL_TOLERANCE INSIDE OF M5 STEP 0.025) NOT WIDE_M5) AND M5
 branch_size = INT (M5 INTERACT branch_all) < 0.269+GLOBAL_TOLERANCE ABUT<90 OPPOSITE REGION EXCLUDE SHIELDED
 branch_real = branch_size INTERACT WIDE_M5
 branch_down = (branch_real AND M4) INTERACT DVK_V4_SQ == 1
 branch_down_real = ((M5 INTERACT branch_down) AND M4) INTERACT DVK_V4_SQ == 1
 branch_down_err1 = branch_real NOT OUTSIDE branch_down_real
 err1_down = branch_down_err1 NOT ENCLOSE RECTANGLE 0.08 9 ORTHOGONAL ONLY
 // 
 branch_up = (branch_real AND M6) INTERACT (RECTANGLE V5 ASPECT == 1) == 1
 branch_up_real = ((M5 INTERACT branch_up) AND M6) INTERACT (RECTANGLE V5 ASPECT == 1) == 1
 branch_up_err2 = branch_real NOT OUTSIDE branch_up_real
 err2_up = branch_up_err2 NOT ENCLOSE RECTANGLE 0.08 9 ORTHOGONAL ONLY
 err1_down NOT INSIDE SealR_NOT_BULK
}
 
125xm5_L_11_V5 {
@ Length of 1.25xMn metal branch (width <= 0.269um) >= 9um
@ When:
@ 1. Metal branch is connected to wide metal with width and length > 1.35um
@ 2. One square 1.25xVn-1/1.25xVn in metal branch, and space to wide metal <= 9um
@ DRC flags branch that can't enclose a 0.08um*9um orthogonal rectangle
@ ("V5_50" is mapped to "V5" in the rule name of this check)
 WIDE_M5 = (WITH WIDTH M5 > 1.35) ENCLOSE RECTANGLE 1.35+GLOBAL_TOLERANCE 1.35+GLOBAL_TOLERANCE
 branch_all = ((SIZE WIDE_M5 BY 9+GLOBAL_TOLERANCE INSIDE OF M5 STEP 0.025) NOT WIDE_M5) AND M5
 branch_size = INT (M5 INTERACT branch_all) < 0.269+GLOBAL_TOLERANCE ABUT<90 OPPOSITE REGION EXCLUDE SHIELDED
 branch_real = branch_size INTERACT WIDE_M5
 branch_down = (branch_real AND M4) INTERACT DVK_V4_SQ == 1
 branch_down_real = ((M5 INTERACT branch_down) AND M4) INTERACT DVK_V4_SQ == 1
 branch_down_err1 = branch_real NOT OUTSIDE branch_down_real
 err1_down = branch_down_err1 NOT ENCLOSE RECTANGLE 0.08 9 ORTHOGONAL ONLY
 // 
 branch_up = (branch_real AND M6) INTERACT (RECTANGLE V5 ASPECT == 1) == 1
 branch_up_real = ((M5 INTERACT branch_up) AND M6) INTERACT (RECTANGLE V5 ASPECT == 1) == 1
 branch_up_err2 = branch_real NOT OUTSIDE branch_up_real
 err2_up = branch_up_err2 NOT ENCLOSE RECTANGLE 0.08 9 ORTHOGONAL ONLY
 err2_up NOT INSIDE SealR_NOT_BULK
}
 
125xm5_A_1 {
@ 1.25xMn area >= 0.0148um2
 err1 = AREA M5 < 0.0148
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xm5_A_2 {
@ 1.25xMn area when all of edge lengths < 0.115um, except can fill a 0.05um*0.13um rectangle >= 0.039um2
 M5_waive = ENCLOSE RECTANGLE M5 0.050 0.130 ORTHOGONAL ONLY
 M5_check = AREA M5 < 0.039
 M5_edge_all = LENGTH M5_check >= 0.115
 err1 = (M5_check NOT WITH EDGE M5_edge_all) NOT M5_waive
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xm5_A_3 {
@ 1.25xMn enclosed area >= 0.181um2
 err1 = AREA ((HOLES M5 INNER) NOT M5) < 0.181
 err1 NOT INSIDE SealR_NOT_BULK
}
 

#IFDEF IP_LEVEL_DENSITY_CHECK YES
#IFDEF MINIMUM_DENSITY_CHECK YES

125xm5_DN_1 {
@ 1.25xMn Density (window 50um*50um, stepping 50um/step_number), except LOGO, MARKS, (OCOVL AND MnDUB), (NODMF su 1um) regions >= 10.5%
 except_area = OR LOGO MARKS (OCOVL AND M5DUB) NODMF_SIZE_1
 check_region = DRC:1 NOT except_area
 check_pattern = M5_all AND check_region
 // 
 check_window1 = check_region WITH WIDTH >= 50/4
 err1_TMP1 = DENSITY check_pattern check_window1 check_region [!AREA(check_window1) + !!AREA(check_window1)*AREA(check_pattern)/AREA(check_region)] < 0.105 WINDOW 50 STEP 50/step_number BACKUP INSIDE OF LAYER DRC:1 BY POLYGON
 // 
 check_window2 = WITH WIDTH (check_region AND err1_TMP1) >= 50/4
 err1_TMP2 = DENSITY check_pattern check_window2 check_region [!AREA(check_window2) + !!AREA(check_window2)*AREA(check_pattern)/AREA(check_region)] < 0.105 WINDOW 50 STEP 50/step_number BACKUP INSIDE OF LAYER err1_TMP1 BY POLYGON
 // 
 check_window3 = WITH WIDTH (check_region AND err1_TMP2) >= 50/4
 DENSITY check_pattern check_window3 check_region [!AREA(check_window3) + !!AREA(check_window3)*AREA(check_pattern)/AREA(check_region)] < 0.105 WINDOW 50 STEP 50/step_number BACKUP INSIDE OF LAYER err1_TMP2 BY POLYGON PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_125xm5_DN_1.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_125xm5_DN_1.rdb"
}
 
125xm5_DN_1a {
@ 1.25xMn Density (window 50um*50um, stepping 50um/step_number), except the window not interact 3um*3um empty area, LOGO, MARKS, (OCOVL AND MnDUB), (NODMF su 1um) regions >= 26.3%
 except_area = OR LOGO MARKS (OCOVL AND M5DUB) NODMF_SIZE_1
 check_region = DRC:1 NOT except_area
 ck3x3_window = WITH WIDTH (check_region NOT M5_all) >= 3
 check_pattern = M5_all AND check_region
 // 
 check_window1 = check_region WITH WIDTH >= 50/4
 err1_TMP1 = DENSITY check_pattern check_window1 check_region ck3x3_window [!AREA(ck3x3_window) + !AREA(check_window1) + !!AREA(ck3x3_window)*!!AREA(check_window1)*AREA(check_pattern)/AREA(check_region)] < 0.263 WINDOW 50 STEP 50/step_number BACKUP INSIDE OF LAYER DRC:1 BY POLYGON
 // 
 check_window2 = WITH WIDTH (check_region AND err1_TMP1) >= 50/4
 err1_TMP2 = DENSITY check_pattern check_window2 check_region ck3x3_window [!AREA(ck3x3_window) + !AREA(check_window2) + !!AREA(ck3x3_window)*!!AREA(check_window2)*AREA(check_pattern)/AREA(check_region)] < 0.263 WINDOW 50 STEP 50/step_number BACKUP INSIDE OF LAYER err1_TMP1 BY POLYGON
 // 
 check_window3 = WITH WIDTH (check_region AND err1_TMP2) >= 50/4
 DENSITY check_pattern check_window3 check_region ck3x3_window [!AREA(ck3x3_window) + !AREA(check_window3) + !!AREA(ck3x3_window)*!!AREA(check_window3)*AREA(check_pattern)/AREA(check_region)] < 0.263 WINDOW 50 STEP 50/step_number BACKUP INSIDE OF LAYER err1_TMP2 BY POLYGON PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_125xm5_DN_1a.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_125xm5_DN_1a.rdb"
}

#ENDIF


#IFDEF RECOMMENDED_CHECK YES

 
125xm5_DN_2_R {
@ 1.25xMn maximum density (window 50um*50um, stepping 25um), except dummy metal. DRC doesn't check (1.25xMn AND DUPMK1) region when the 1.25xMn layer is used as TM-1 <= 65%
 check_region = COPY CHIP_NOT_MARKS
 check_pattern = M5 AND check_region
 // 
 check_window1 = check_region WITH WIDTH >= 50/4
 err1_TMP1 = DENSITY check_pattern check_window1 check_region [!!AREA(check_window1)*AREA(check_pattern)/AREA(check_region)] > 0.65 WINDOW 50 STEP 25 BACKUP INSIDE OF LAYER DRC:1 BY POLYGON
 // 
 check_window2 = WITH WIDTH (check_region AND err1_TMP1) >= 50/4
 err1_TMP2 = DENSITY check_pattern check_window2 check_region [!!AREA(check_window2)*AREA(check_pattern)/AREA(check_region)] > 0.65 WINDOW 50 STEP 25 BACKUP INSIDE OF LAYER err1_TMP1 BY POLYGON
 // 
 check_window3 = WITH WIDTH (check_region AND err1_TMP2) >= 50/4
 DENSITY check_pattern check_window3 check_region [!!AREA(check_window3)*AREA(check_pattern)/AREA(check_region)] > 0.65 WINDOW 50 STEP 25 BACKUP INSIDE OF LAYER err1_TMP2 BY POLYGON PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_125xm5_DN_2_R.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_125xm5_DN_2_R.rdb"
}

#ENDIF

 
125xm5_DN_3 {
@ Maximum 1.25xMn density (window 50um*50um, stepping 50um/step_number). DRC doesn't check (1.25xMn AND DUPMK1) region when the 1.25xMn layer is used as TM-1 <= 71.3%
 check_region = COPY CHIP_NOT_MARKS
 check_pattern = M5_all AND check_region
 // 
 check_window1 = check_region WITH WIDTH >= 50/4
 err1_TMP1 = DENSITY check_pattern check_window1 check_region [!!AREA(check_window1)*AREA(check_pattern)/AREA(check_region)] > 0.713 WINDOW 50 STEP 50/step_number BACKUP INSIDE OF LAYER DRC:1 BY POLYGON
 // 
 check_window2 = WITH WIDTH (check_region AND err1_TMP1) >= 50/4
 err1_TMP2 = DENSITY check_pattern check_window2 check_region [!!AREA(check_window2)*AREA(check_pattern)/AREA(check_region)] > 0.713 WINDOW 50 STEP 50/step_number BACKUP INSIDE OF LAYER err1_TMP1 BY POLYGON
 // 
 check_window3 = WITH WIDTH (check_region AND err1_TMP2) >= 50/4
 DENSITY check_pattern check_window3 check_region [!!AREA(check_window3)*AREA(check_pattern)/AREA(check_region)] > 0.713 WINDOW 50 STEP 50/step_number BACKUP INSIDE OF LAYER err1_TMP2 BY POLYGON PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_125xm5_DN_3.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_125xm5_DN_3.rdb"
}
 
125xm5_DN_4 {
@ 1.25xMn density difference between two neighboring checking windows (window 180um*180um, stepping 360um/step_number), except (NODMF) su 0.4um region <= 47.5%
 except_area = OR MARKS NODMF_SIZE_0.4
 check_pattern = M5_all NOT except_area
 check_region = DRC:1 NOT except_area
 DENSITY check_pattern check_region [AREA(check_pattern)/AREA(check_region)] >= 0 WINDOW 180 STEP 360/step_number GRADIENT > 0.475 ABSOLUTE BACKUP PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_125xm5_DN_4.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_125xm5_DN_4.rdb"
}
 

#IFDEF MINIMUM_DENSITY_CHECK YES


#ENDIF
#ENDIF

 

#IFDEF IP_LEVEL_DENSITY_CHECK NO
#IFDEF MINIMUM_DENSITY_CHECK YES

125xm5_DN_1 {
@ 1.25xMn Density (window 50um*50um, stepping 25um), except LOGO, MARKS, (OCOVL AND MnDUB), (NODMF su 1um) regions >= 10%
 except_area = OR LOGO MARKS (OCOVL AND M5DUB) NODMF_SIZE_1
 check_region = DRC:1 NOT except_area
 check_pattern = M5_all AND check_region
 // 
 check_window1 = check_region WITH WIDTH >= 50/4
 err1_TMP1 = DENSITY check_pattern check_window1 check_region [!AREA(check_window1) + !!AREA(check_window1)*AREA(check_pattern)/AREA(check_region)] < 0.1 WINDOW 50 STEP 25 BACKUP INSIDE OF LAYER DRC:1 BY POLYGON
 // 
 check_window2 = WITH WIDTH (check_region AND err1_TMP1) >= 50/4
 err1_TMP2 = DENSITY check_pattern check_window2 check_region [!AREA(check_window2) + !!AREA(check_window2)*AREA(check_pattern)/AREA(check_region)] < 0.1 WINDOW 50 STEP 25 BACKUP INSIDE OF LAYER err1_TMP1 BY POLYGON
 // 
 check_window3 = WITH WIDTH (check_region AND err1_TMP2) >= 50/4
 DENSITY check_pattern check_window3 check_region [!AREA(check_window3) + !!AREA(check_window3)*AREA(check_pattern)/AREA(check_region)] < 0.1 WINDOW 50 STEP 25 BACKUP INSIDE OF LAYER err1_TMP2 BY POLYGON PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_125xm5_DN_1.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_125xm5_DN_1.rdb"
}
 
125xm5_DN_1a {
@ 1.25xMn Density (window 50um*50um, stepping 25um), except the window not interact 3um*3um empty area, LOGO, MARKS, (OCOVL AND MnDUB), (NODMF su 1um) regions >= 25%
 except_area = OR LOGO MARKS (OCOVL AND M5DUB) NODMF_SIZE_1
 check_region = DRC:1 NOT except_area
 ck3x3_window = WITH WIDTH (check_region NOT M5_all) >= 3
 check_pattern = M5_all AND check_region
 // 
 check_window1 = check_region WITH WIDTH >= 50/4
 err1_TMP1 = DENSITY check_pattern check_window1 check_region ck3x3_window [!AREA(ck3x3_window) + !AREA(check_window1) + !!AREA(ck3x3_window)*!!AREA(check_window1)*AREA(check_pattern)/AREA(check_region)] < 0.25 WINDOW 50 STEP 25 BACKUP INSIDE OF LAYER DRC:1 BY POLYGON
 // 
 check_window2 = WITH WIDTH (check_region AND err1_TMP1) >= 50/4
 err1_TMP2 = DENSITY check_pattern check_window2 check_region ck3x3_window [!AREA(ck3x3_window) + !AREA(check_window2) + !!AREA(ck3x3_window)*!!AREA(check_window2)*AREA(check_pattern)/AREA(check_region)] < 0.25 WINDOW 50 STEP 25 BACKUP INSIDE OF LAYER err1_TMP1 BY POLYGON
 // 
 check_window3 = WITH WIDTH (check_region AND err1_TMP2) >= 50/4
 DENSITY check_pattern check_window3 check_region ck3x3_window [!AREA(ck3x3_window) + !AREA(check_window3) + !!AREA(ck3x3_window)*!!AREA(check_window3)*AREA(check_pattern)/AREA(check_region)] < 0.25 WINDOW 50 STEP 25 BACKUP INSIDE OF LAYER err1_TMP2 BY POLYGON PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_125xm5_DN_1a.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_125xm5_DN_1a.rdb"
}

#ENDIF


#IFDEF RECOMMENDED_CHECK YES

 
125xm5_DN_2_R {
@ 1.25xMn maximum density (window 50um*50um, stepping 25um), except dummy metal. DRC doesn't check (1.25xMn AND DUPMK1) region when the 1.25xMn layer is used as TM-1 <= 65%
 check_region = COPY CHIP_NOT_MARKS
 check_pattern = M5 AND check_region
 // 
 check_window1 = check_region WITH WIDTH >= 50/4
 err1_TMP1 = DENSITY check_pattern check_window1 check_region [!!AREA(check_window1)*AREA(check_pattern)/AREA(check_region)] > 0.65 WINDOW 50 STEP 25 BACKUP INSIDE OF LAYER DRC:1 BY POLYGON
 // 
 check_window2 = WITH WIDTH (check_region AND err1_TMP1) >= 50/4
 err1_TMP2 = DENSITY check_pattern check_window2 check_region [!!AREA(check_window2)*AREA(check_pattern)/AREA(check_region)] > 0.65 WINDOW 50 STEP 25 BACKUP INSIDE OF LAYER err1_TMP1 BY POLYGON
 // 
 check_window3 = WITH WIDTH (check_region AND err1_TMP2) >= 50/4
 DENSITY check_pattern check_window3 check_region [!!AREA(check_window3)*AREA(check_pattern)/AREA(check_region)] > 0.65 WINDOW 50 STEP 25 BACKUP INSIDE OF LAYER err1_TMP2 BY POLYGON PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_125xm5_DN_2_R.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_125xm5_DN_2_R.rdb"
}

#ENDIF

 
125xm5_DN_3 {
@ Maximum 1.25xMn density (window 50um*50um, stepping 25um). DRC doesn't check (1.25xMn AND DUPMK1) region when the 1.25xMn layer is used as TM-1 <= 75%
 check_region = COPY CHIP_NOT_MARKS
 check_pattern = M5_all AND check_region
 // 
 check_window1 = check_region WITH WIDTH >= 50/4
 err1_TMP1 = DENSITY check_pattern check_window1 check_region [!!AREA(check_window1)*AREA(check_pattern)/AREA(check_region)] > 0.75 WINDOW 50 STEP 25 BACKUP INSIDE OF LAYER DRC:1 BY POLYGON
 // 
 check_window2 = WITH WIDTH (check_region AND err1_TMP1) >= 50/4
 err1_TMP2 = DENSITY check_pattern check_window2 check_region [!!AREA(check_window2)*AREA(check_pattern)/AREA(check_region)] > 0.75 WINDOW 50 STEP 25 BACKUP INSIDE OF LAYER err1_TMP1 BY POLYGON
 // 
 check_window3 = WITH WIDTH (check_region AND err1_TMP2) >= 50/4
 DENSITY check_pattern check_window3 check_region [!!AREA(check_window3)*AREA(check_pattern)/AREA(check_region)] > 0.75 WINDOW 50 STEP 25 BACKUP INSIDE OF LAYER err1_TMP2 BY POLYGON PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_125xm5_DN_3.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_125xm5_DN_3.rdb"
}
 
125xm5_DN_4 {
@ 1.25xMn density difference between two neighboring checking windows (window 180um*180um, stepping 180um), except (NODMF) su 0.4um region <= 50%
 except_area = OR MARKS NODMF_SIZE_0.4
 check_pattern = M5_all NOT except_area
 check_region = DRC:1 NOT except_area
 DENSITY check_pattern check_region [AREA(check_pattern)/AREA(check_region)] >= 0 WINDOW 180 STEP 180 GRADIENT > 0.5 ABSOLUTE BACKUP PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_125xm5_DN_4.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_125xm5_DN_4.rdb"
}
 

#IFDEF MINIMUM_DENSITY_CHECK YES


#ENDIF
#ENDIF


//1.25xMn.R.1[NC] 1.25xMn pattern must drawn on data type 50 or 55.
//1.25xMn.R.2[NC] It is not allowed for data type 50 and 55 exist on the same metal layer at the same time.
//1.25xMn.R.3[NC] M5/M7 must be drawn on data type 55, M6/M8 must be drawn on data type 50, 1.25xMn and 1.25xMn-1 using same data type is not allowed


// =======================================================
// 1.25xMn design rules
// =======================================================

GROUP G125xm7 125xm7_?
 
125xm7_040 = M7 WITH WIDTH == 0.040
125xm7_042 = M7 WITH WIDTH == 0.042
125xm7_044 = M7 WITH WIDTH == 0.044
125xm7_046 = M7 WITH WIDTH == 0.046
125xm7_060 = M7 WITH WIDTH == 0.060
125xm7_080 = M7 WITH WIDTH == 0.080
125xm7_120 = M7 WITH WIDTH == 0.120
125xm7_160 = M7 WITH WIDTH == 0.160
125xm7_eqgt_060 = M7 WITH WIDTH >= 0.060
125xm7_eqgt_120 = 125xm7_eqgt_060 WITH WIDTH >= 0.120
125xm7_eqgt_121 = 125xm7_eqgt_060 WITH WIDTH >= 0.121
125xm7_eqgt_200 = 125xm7_eqgt_120 WITH WIDTH >= 0.200
125xm7_gt_060 = 125xm7_eqgt_060 WITH WIDTH > 0.060
125xm7_gt_160 = 125xm7_eqgt_060 WITH WIDTH > 0.160
125xm7_gt_080 = 125xm7_eqgt_060 WITH WIDTH > 0.080
 
125xm7_044_end = LENGTH M7_convex_90_90_edges <= 0.044
125xm7_060_end = LENGTH M7_convex_90_90_edges <= 0.060
M7_060_v_edges = INT [M7_v_edges] == 0.06 OPPOSITE
 

#IFDEF DFM_RULES_PRIORITY_1 YES

125xm7_S_3_DFM1 {
@ Recommended 1.25xMn space when either one 1.25xMn width > 1.35um. >= 0.450um
 chk_mn = M7 WITH WIDTH > 1.35
 err1 = EXT chk_mn M7 < 0.450 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xm7_A_1_DFM1 {
@ Recommended 1.25xMn area >= 0.02um2
 err1 = AREA M7 < 0.02
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xm7_R_9_V6_DFM1 {
@ 1.25xMn.R.9.DFM:
@ It's not recommended to use dense 1.25xMn 3-bar pattern
@ DRC flag conditions:
@ (1) Middle line width(W1) is <= 0.044um, both two neighbour 1.25xMn line width <= 0.06um and interact square or rectangle Vy or 1.25xVn
@ (2) 1.25xMn Space to both via (S1/S2)< 0.048um
@ (3) The via PRL: -0.1 < PRL < 0.1um
@ (4) Both neighbor 1.25xMn enclosure 1.25xVn or 1.25xVn-1 < 0.065um
@ This rule is not applied for INST region
 met_44_side = INT [M7] <= 0.044 ABUT<90 OPPOSITE
 met_60_side = INT [M7] <= 0.060 ABUT<90 OPPOSITE
 via_d_met = V6_SR NOT OUTSIDE (M7 WITH WIDTH <= 0.06)
 via_d_end = via_d_met TOUCH EDGE (ENC [via_d_met] 125xm7_060_end < 0.065 ABUT<90 OPPOSITE)
 via_d_lin = (via_d_met NOT TOUCH EDGE via_d_end) TOUCH EDGE (ENC [via_d_met] met_60_side <= 0.028 ABUT<90 OPPOSITE)
 via_d_mid = (via_d_met WITH EDGE via_d_end) WITH EDGE via_d_lin >= 2
 via_d_sid = via_d_mid TOUCH EDGE via_d_lin
 via_d_sps = (EXT [met_44_side] via_d_sid < 0.048 OPPOSITE EXTENDED 0.1 MEASURE ALL) TOUCH EDGE (EXT [met_44_side] via_d_sid < 0.048 OPPOSITE MEASURE ALL)
 err1 = INT via_d_sps <= 0.044 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE INST
}

#ENDIF

125xm7_W_1 {
@ 1.25xMn width >= 0.04um
 err1 = INT M7 < 0.04 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xm7_W_1a {
@ 1.25xMn width in CP direction
@ The width should be even value when <= 0.046um
@ CP direction definition: Critical-Pitch direction along the minimum pitch (80nm) of 1.25xMn = 0.04~0.046, >= 0.060
 err1 = INT M7_v_edges < 0.040 ABUT<90 OPPOSITE REGION
 err2 = INT M7_v_edges > 0.040 < 0.042 ABUT<90 OPPOSITE REGION
 err3 = INT M7_v_edges > 0.042 < 0.044 ABUT<90 OPPOSITE REGION
 err4 = INT M7_v_edges > 0.044 < 0.046 ABUT<90 OPPOSITE REGION
 err5 = INT M7_v_edges > 0.046 < 0.060 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
 err4 NOT INSIDE SealR_NOT_BULK
 err5 NOT INSIDE SealR_NOT_BULK
}
 
125xm7_W_1b {
@ 1.25xMn width in NCP direction
@ NCP direction definition: Non-Critical-Pitch direction which is perpendicular to CP direction = 0.08, >= 0.120um
 err1 = INT M7_h_edges < 0.080 ABUT<90 OPPOSITE REGION
 err2 = INT M7_h_edges > 0.080 < 0.120 ABUT<90 OPPOSITE REGION EXCLUDE SHIELDED
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}
 
125xm7_W_2 {
@ 1.25xMn width, except MARKS, and LOGO regions. DRC doesn't flag (1.25xMn AND DUPMK1) region when the 1.25xMn layer is used as TM-1 <= 2.1um
 err1 = (M7 NOT INSIDE (OR MARKS_LOGO DUPMK1)) WITH WIDTH > 2.1
 err1 NOT INSIDE MARKS_LOGO
}
 
125xm7_W_3 {
@ 1.25xMn width of 45-degree bent metal >= 0.396um
 err1 = INT M7_45_skew_edges < 0.396 OPPOSITE REGION EXCLUDE SHIELDED
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xm7_W_4 {
@ 1.25xMn width of metal branch connected to wide metal width and length >= 0.401um. >= 0.08um
 dorian_large = M7 WITH WIDTH >= 0.401
 dorian_whole = M7 INTERACT dorian_large
 dorian_large_exp = SIZE dorian_large BY 0.005 INSIDE OF dorian_whole
 dorian_branch_0 = dorian_whole NOT dorian_large
 dorian_branch_1 = dorian_branch_0 NOT COIN EDGE dorian_large
 dorian_branch_2 = dorian_branch_1 TOUCH EDGE dorian_large_exp
 err1 = INT dorian_branch_2 < 0.08 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xm7_W_5 {
@ 1.25xMn width when PRL < 0um. >= 0.08um
 err1 = INT M7 < 0.08 ABUT<90 REGION CORNER TO CORNER
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xm7_S_1 {
@ 1.25xMn space >= 0.04um
 err1 = EXT M7 < 0.04 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xm7_S_2 {
@ Space between 1.25xMn when one or both width >= 0.201um when PRL >= -0.139um. >= 0.139um
 chk_Mn = M7 WITH WIDTH >= 0.201
 err1 = EXT M7 chk_Mn < 0.139 ABUT<90 OPPOSITE EXTENDED 0.139+GLOBAL_TOLERANCE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xm7_S_3 {
@ Space between 1.25xMn when one or both width >= 0.282um when PRL > 0.16um. >= 0.199um
 mets_RAW = (M7 WITH WIDTH >= 0.201) WITH WIDTH >= 0.282
 mets_sps_ERRS = EXT mets_RAW M7 < 0.199 ABUT<90 OPPOSITE
 mets_sps_AREA = EXT mets_RAW M7 < 0.199 ABUT<90 OPPOSITE REGION
 err1 = DFM PROPERTY mets_sps_AREA mets_sps_ERRS OVERLAP ABUT ALSO MULTI [-= EC(mets_sps_ERRS)] > 0.16
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xm7_S_4 {
@ Space between 1.25xMn when one or both width > 0.5um when PRL >= -0.199um. >= 0.199um
 chk_Mn = (M7 WITH WIDTH >= 0.201) WITH WIDTH > 0.5
 err1 = EXT M7 chk_Mn < 0.199 ABUT<90 OPPOSITE EXTENDED 0.199+GLOBAL_TOLERANCE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xm7_S_5 {
@ Space between 1.25xMn when one or both width > 1.35um when PRL > 1.35um. >= 0.448um
 met_wid_all = M7 WITH WIDTH >= 1.35+GLOBAL_TOLERANCE
 met_err_RAW = EXT M7 met_wid_all < 0.448 OPPOSITE REGION MEASURE ALL
 met_err_CRN = EXT (ANGLE M7 > 44 < 46) met_wid_all < 0.448 OPPOSITE1 REGION MEASURE ALL
 err1 = met_err_RAW ENCLOSE RECTANGLE 0.001 1.351 ORTHOGONAL ONLY
 err2 = met_err_CRN ENCLOSE RECTANGLE 0.04 1.351
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}
 
125xm7_S_6 {
@ Space between 1.25xMn in CP direction when one or both width = 0.04um. = 0.04, >= 0.07um
 err1_TMP = DFM SPACE M7 125xm7_040 < 0.04 BY EXT HORIZONTAL
 err2_TMP = DFM SPACE M7 125xm7_040 > 0.04 < 0.07 BY EXT HORIZONTAL
 // 
 waive_TMP = ANGLE 125xm7_060 == 90
 waive_EDG = EXT waive_TMP 125xm7_040 == 0.07 ABUT<90 OPPOSITE
 err1 = DFM COPY err1_TMP EDGE
 // NOT COIN EDGE (DFM COPY waive_EDG EDGE)
 err2 = DFM COPY err2_TMP EDGE
 // NOT COIN EDGE (DFM COPY waive_EDG EDGE)
 err1 NOT INSIDE EDGE SealR_NOT_BULK
 err2 NOT INSIDE EDGE SealR_NOT_BULK
}
 
125xm7_S_6a {
@ Space between 1.25xMn in CP direction when one or both width = 0.042um. = 0.048, >= 0.07um
 err1 = EXT M7_v_edges 125xm7_042 < 0.048 ABUT<90 OPPOSITE REGION
 err2 = EXT M7_v_edges 125xm7_042 > 0.048 < 0.07 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}
 
125xm7_S_7 {
@ Space between 1.25xMn in CP direction when one or both width = 0.044um. = 0.046, >= 0.07um
 err1 = EXT M7_v_edges 125xm7_044 < 0.046 ABUT<90 OPPOSITE REGION
 err2 = EXT M7_v_edges 125xm7_044 > 0.046 < 0.07 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}
 
125xm7_S_7a {
@ Space between 1.25xMn in CP direction when one or both width = 0.046um. = 0.046um, >= 0.07um
 err1 = EXT M7_v_edges 125xm7_046 < 0.046 ABUT<90 OPPOSITE REGION
 err2 = EXT M7_v_edges 125xm7_046 > 0.046 < 0.07 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}
 
125xm7_S_8 {
@ Space between 1.25xMn in CP direction when one or both width = 0.06um. = 0.04, 0.046, >= 0.06um
 waive_s_6a_chk = ANGLE 125xm7_060 == 90
 waive_s_6a = DFM COPY (EXT waive_s_6a_chk 125xm7_040 == 0.070 ABUT<90 OPPOSITE) EDGE
 bad_1 = DFM SPACE 125xm7_060 M7 < 0.040 BY EXT HORIZONTAL
 bad_2 = DFM SPACE 125xm7_060 M7 > 0.040 < 0.046 BY EXT HORIZONTAL
 bad_3 = DFM SPACE 125xm7_060 M7 > 0.046 < 0.060 BY EXT HORIZONTAL
 err1 = DFM COPY bad_1 EDGE
 // NOT COIN EDGE waive_s_6a
 err2 = DFM COPY bad_2 EDGE
 // NOT COIN EDGE waive_s_6a
 err3 = DFM COPY bad_3 EDGE
 // NOT COIN EDGE waive_s_6a
 err1 NOT INSIDE EDGE SealR_NOT_BULK
 err2 NOT INSIDE EDGE SealR_NOT_BULK
 err3 NOT INSIDE EDGE SealR_NOT_BULK
}
 
125xm7_S_8a {
@ Space between 1.25xMn in CP direction when one or both width > 0.06um when PRL > 0.08um. >= 0.06um
 met_wid_all = COPY 125xm7_gt_060
 met_err_RAW = EXT [met_wid_all] M7_v_edges < 0.06 ABUT<90 OPPOSITE MEASURE ALL
 met_jog_ALL = (CONVEX EDGE M7 == 1) NOT COIN EDGE met_err_RAW
 met_jog_EXP_a = EXPAND EDGE met_jog_ALL INSIDE BY 0.0005
 met_jog_EXP_b = EXPAND EDGE met_jog_ALL OUTSIDE BY 0.0005
 met_jog_TMP = (met_jog_ALL COIN EDGE (met_jog_EXP_a WITH EDGE met_err_RAW)) COIN EDGE (met_jog_EXP_b WITH EDGE met_err_RAW)
 met_jog_EXP = ((VERTEX (EXPAND EDGE met_jog_TMP OUTSIDE BY 0.001 EXTEND BY 0.001) == 4) OR (EXPAND EDGE met_err_RAW OUTSIDE BY 0.001)) NOT M7
 // 
 met_err_PRL = DFM PROPERTY met_jog_EXP met_err_RAW OVERLAP ABUT ALSO MULTI [-= LENGTH(met_err_RAW)] > 0.08
 met_err_EGE = met_err_RAW TOUCH EDGE met_err_PRL
 err1 = EXT met_err_EGE M7 < 0.06 ABUT<90 OPPOSITE REGION MEASURE ALL
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xm7_S_9 {
@ Space between 1.25xMn in CP direction, when one or both width = 0.06um, and the other side space < 0.06um. >= 0.079um
 mets_sps_060 = EXT [M7_060_v_edges] M7 < 0.06 ABUT<90 OPPOSITE
 mets_sps_080 = EXT [M7_060_v_edges] M7 < 0.079 ABUT<90 OPPOSITE
 err1 = INT mets_sps_060 mets_sps_080 == 0.06 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
M7_convex_90_270_edges_gt_040 = ANGLE (CONVEX EDGE M7 ANGLE1 == 90 ANGLE2 == 270 WITH LENGTH > 0.04) == 0
M7_width_eq_080 = M7 WITH WIDTH == 0.08
 
125xm7_S_10 {
@ Space between 1.25xMn in CP direction when one or both width >= 0.08um. >= 0.079um
@ Except Z shape and flag shape:
@ (1) Z-shape definition: edge length > 0.040um between two consecutive 90-270 degree corners, corresponding width = 0.08um in NCP direction between two opposite edge length > 0.04um, not including T-shape
@ (2) Flag-shape definition: edge length > 0.04um between two consecutive 90-270 degree corners, the opposite edge length > 0.08um between two consecutive 90-90 degree corners, corresponding width = 0.08um in NCP direction between these two opposite edge, and the other corresponding width > 0.04um in CP direction
 flag_shape_l_side = LENGTH M7_convex_90_90_edges > 0.08
 flag_shape_s_side = ANGLE (LENGTH M7_convex_90_90_edges == 0.08) == 90
 flag_shape = (M7_width_eq_080 INTERACT (INT M7_convex_90_270_edges_gt_040 flag_shape_l_side == 0.08 ABUT<90 OPPOSITE REGION)) WITH EDGE flag_shape_s_side
 zfig_shape = (M7_width_eq_080 INTERACT (INT M7_convex_90_270_edges_gt_040 == 0.08 ABUT<90 OPPOSITE REGION)) NOT WITH EDGE flag_shape_s_side
 waive_shape = (OR zfig_shape flag_shape) NOT COIN EDGE (INT [M7_v_edges] == 0.08 ABUT<90 OPPOSITE) // horizontal width=0.08 need to flag
 // 
 check_edge = INT (M7_v_edges) < 0.08 ABUT<90 OPPOSITE
 check_shape = check_edge NOT COIN EDGE waive_shape
 err1 = EXT check_shape (M7 NOT COIN EDGE waive_shape) < 0.079 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xm7_S_11 {
@ Space between 1.25xMn in CP direction when one or both width >= 0.121um, PRL > 0.08um. >= 0.099um
 mets_sps_100_ERRS = EXT 125xm7_eqgt_121 M7_v_edges < 0.099 ABUT<90 OPPOSITE
 mets_sps_100_AREA = EXT 125xm7_eqgt_121 M7_v_edges < 0.099 ABUT<90 OPPOSITE REGION
 err1 = DFM PROPERTY mets_sps_100_AREA mets_sps_100_ERRS OVERLAP ABUT ALSO MULTI [-= EC(mets_sps_100_ERRS)] > 0.08
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xm7_S_12 {
@ Space between 1.25xMn (CP direction width > 0.16um and NCP direction width > 0.08um) and 1.25xMn edge (edge length > 0.08um in NCP direction) in CP direction >= 0.119um
 mets_L_sides = (INT (M7_v_edges) <= 0.16 ABUT<90 OPPOSITE EXCLUDE SHIELDED) COIN EDGE 125xm7_gt_080
 mets_R_sides = LENGTH M7_v_edges > 0.08
 err1 = EXT mets_R_sides (mets_L_sides COIN EDGE mets_R_sides) < 0.119 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xm7_S_13 {
@ Space between 1.25xMn in CP direction when one or both width >= 0.201um, PRL >= 0.121um. >= 0.144um
 mets_RAW = M7 WITH WIDTH >= 0.201
 mets_sps_ERRS = EXT mets_RAW M7_v_edges < 0.144 ABUT<90 OPPOSITE
 mets_sps_AREA = EXT mets_RAW M7_v_edges < 0.144 ABUT<90 OPPOSITE REGION
 err1 = DFM PROPERTY mets_sps_AREA mets_sps_ERRS OVERLAP ABUT ALSO MULTI [-= EC(mets_sps_ERRS)] >= 0.121
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xm7_S_14 {
@ Space between 1.25xMn in CP direction when one or both width >= 0.231um, PRL >= 0.121um. >= 0.159um
 mets_RAW = (M7 WITH WIDTH >= 0.201) WITH WIDTH >= 0.231
 mets_sps_ERRS = EXT mets_RAW M7_v_edges < 0.159 ABUT<90 OPPOSITE
 mets_sps_AREA = EXT mets_RAW M7_v_edges < 0.159 ABUT<90 OPPOSITE REGION
 err1 = DFM PROPERTY mets_sps_AREA mets_sps_ERRS OVERLAP ABUT ALSO MULTI [-= EC(mets_sps_ERRS)] >= 0.121
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xm7_S_15 {
@ Space between 1.25xMn and 1.25xMn line-end (width = 0.08um and both adiacent edge length > 0.09um) in CP direction when PRL > -0.08um. >= 0.099um
 lend_RAW = CONVEX EDGE M7 ANGLE1 == 90 LENGTH1 > 0.09 ANGLE2 == 90 LENGTH2 > 0.09 WITH LENGTH == 0.08
 lend_CHK = ANGLE lend_RAW == 90
 err1 = EXT lend_CHK M7 < 0.099 ABUT<90 OPPOSITE EXTENDED 0.08 REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xm7_S_16 {
@ Space between 1.25xMn in NCP direction when one or both width = 0.08um, 0.12um. >= 0.08um
 mets_RAW = 125xm7_080 OR 125xm7_120
 mets_CHK = ANGLE mets_RAW == 0
 err1 = EXT mets_CHK M7 < 0.08 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xm7_S_17 {
@ Space between 1.25xMn (0.16um <= NCP direction width < 0.2um and CP direction width > 0.08um) and 1.25xMn edge (edge length > 0.08um in CP direction) in NCP direction >= 0.099um
 mets_L_sides = (INT [M7_h_edges] >= 0.16 < 0.2 ABUT<90 OPPOSITE EXCLUDE SHIELDED) COIN EDGE 125xm7_gt_080
 mets_R_sides = LENGTH M7_h_edges > 0.08
 err1 = EXT mets_R_sides (mets_L_sides COIN EDGE mets_R_sides) < 0.099 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xm7_S_18 {
@ Space between 1.25xMn in NCP direction when one or both width > 0.12um, PRL >= 0.121um. >= 0.119um
 err1_TMP = EXT 125xm7_eqgt_121 M7_h_edges < 0.119 ABUT<90 OPPOSITE REGION
 err1 = err1_TMP ENCLOSE RECTANGLE 0.001 0.121 ORTHOGONAL ONLY
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xm7_S_19 {
@ Space between 1.25xMn (NCP direction width >= 0.2um and CP direction width > 0.08um) and 1.25xMn edge (edge length > 0.08um in CP direction) in NCP direction >= 0.139um
 mets_L_sides = (INT (M7_h_edges) < 0.2 ABUT<90 OPPOSITE EXCLUDE SHIELDED) COIN EDGE 125xm7_gt_080
 mets_R_sides = LENGTH M7_h_edges > 0.08
 err1 = EXT mets_R_sides (mets_L_sides COIN EDGE mets_R_sides) < 0.139 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xm7_S_20 {
@ Space between 1.25xMn in NCP direction when one or both width > 0.16um when PRL > 0.2um. >= 0.159um
 err1_TMP = EXT 125xm7_gt_160 M7_h_edges < 0.159 ABUT<90 OPPOSITE REGION
 err1 = err1_TMP ENCLOSE RECTANGLE 0.001 0.20+GLOBAL_TOLERANCE ORTHOGONAL ONLY
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xm7_S_21 {
@ Space between 1.25xMn and 1.25xMn line-end (width = 0.04/0.042um) in NCP direction when PRL > -0.04um. >= 0.099um
 lend_RAW = LENGTH M7_convex_eq_two_edges >= 0.04 <= 0.042
 lend_CHK = ANGLE lend_RAW == 0
 err1 = EXT lend_CHK M7 < 0.099 ABUT<90 OPPOSITE EXTENDED 0.04 REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xm7_S_21a {
@ Space between 1.25xMn and 1.25xMn line-end (width = 0.044/0.046/0.06um) in NCP direction when PRL > -0.04um. >= 0.080um
 lend_RAW_a = LENGTH M7_convex_eq_two_edges >= 0.044 <= 0.046
 lend_RAW_b = LENGTH M7_convex_eq_two_edges == 0.06
 lend_CHK = ANGLE (lend_RAW_a OR EDGE lend_RAW_b) == 0
 err1 = EXT lend_CHK M7 < 0.08 ABUT<90 OPPOSITE EXTENDED 0.04 REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xm7_S_22 {
@ Space between 1.25xMn and 1.25xMn line-end (0.06um < width <= 0.08um) in NCP direction when PRL > -0.08um. >= 0.08um
 lend_RAW = LENGTH M7_convex_eq_two_edges > 0.06 <= 0.08
 lend_CHK = ANGLE lend_RAW == 0
 err1 = EXT lend_CHK M7 < 0.08 ABUT<90 OPPOSITE EXTENDED 0.08 REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xm7_S_23 {
@ Space between 1.25xMn line-end (width < 0.08um) and U-shape inner edge (edge length <= 0.149um between two concave corners) in NCP direction >= 0.149um
 mets_U_sides = LENGTH M7_convex_270_270_edges <= 0.149
 err1 = EXT M7_end_080 mets_U_sides < 0.149 ABUT<90 OPPOSITE EXTENDED 0.04 REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xM7_GROUP_80 = SIZE (SIZE (SIZE 125xm7_040 BY 0.02) BY -0.04) BY 0.02
125xM7_GROUP_90_1 = SIZE (SIZE (SIZE 125xm7_044 BY 0.023) BY -0.046) BY 0.023
125xM7_GROUP_90_2 = SIZE (SIZE (SIZE 125xm7_042 BY 0.024) BY -0.048) BY 0.024
125xM7_GROUP_90 = OR 125xM7_GROUP_90_1 125xM7_GROUP_90_2
 
125xm7_S_24a {
@ Space between 1.25xMn_Group_80 and 1.25xMn_Group_90 in CP direction when PRL > -0.08um. >= 0.199um
@ 1.25xMn_Group_80 definition: (((1.25xMn (width = 0.040um) SIZING 0.020um) SIZING -0.040um) SIZING 0.020um)
@ 1.25xMn_Group_90 definition: 1) (((1.25xMn (width = 0.044um) su 0.023um) sd -0.046um) su 0.023um). 2) (((1.25xMn (width = 0.042um) su 0.024um) sd -0.048um) su 0.024um)
 line_080 = ANGLE 125xM7_GROUP_80 == 90
 line_090 = ANGLE 125xM7_GROUP_90 == 90
 err1 = EXT line_080 line_090 < 0.199 ABUT<90 OPPOSITE EXTENDED 0.08 REGION MEASURE ALL
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xm7_S_24b {
@ Space between 1.25xMn line-end inside 1.25xMn_Group_80 and 1.25xMy line-end of 1.25xMn_Group_90 in NCP direction when PRL > -0.199um. >= 0.149um
 lend_080 = ANGLE (M7_end NOT OUTSIDE EDGE 125xM7_GROUP_80) == 0
 lend_090 = ANGLE (M7_end NOT OUTSIDE EDGE 125xM7_GROUP_90) == 0
 err1 = EXT lend_080 lend_090 < 0.149 ABUT<90 OPPOSITE EXTENDED 0.199 REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xm7_S_25 {
@ Corner projected space between 1.25xMn when -0.08um < PRL <= 0um. >= 0.08um
@ Except line end-to-end (width <= 0.06um), Z-shape, and flag-shape:
@ Definition of Z-shape /flag-shape:
@ 1) Z-shape: edge length > 0.040um between two consecutive 90-270 degree corners, corresponding width = 0.08um in NCP direction between two opposite edge length > 0.040um, not including T-shape
@ 2) flag-shape: edge length > 0.04um between two consecutive 90-270 degree corners, the opposite edge length > 0.08um between two consecutive 90-90 degree corners, corresponding width = 0.08um in NCP direction between these 2 opposite edge, and the other corresponding width > 0.04um in CP direction
 line_end = (CONVEX EDGE M7 ANGLE1 == 90 ANGLE2 == 90 WITH LENGTH <= 0.06) COIN EDGE M7_h_edges
 // 
 flag_shape_l_side = LENGTH M7_convex_90_90_edges > 0.08
 flag_shape_s_side = ANGLE (LENGTH M7_convex_90_90_edges == 0.08) == 90
 flag_shape = (M7_width_eq_080 INTERACT (INT M7_convex_90_270_edges_gt_040 flag_shape_l_side == 0.08 ABUT<90 OPPOSITE REGION)) WITH EDGE flag_shape_s_side
 zfig_shape = (M7_width_eq_080 INTERACT (INT M7_convex_90_270_edges_gt_040 == 0.08 ABUT<90 OPPOSITE REGION)) NOT WITH EDGE flag_shape_s_side
 waive_shape = OR zfig_shape flag_shape
 // 
 corner_space_prl_lt_0 = EXT M7 < 0.08*1.414 CORNER TO CORNER
 corner_space_prl_eq_0 = EXT line_end M7 < 0.08 PROJ == 0
 corner_space_all_TMP = DFM COPY corner_space_prl_lt_0 corner_space_prl_eq_0
 corner_space_all = DFM PROPERTY corner_space_all_TMP line_end waive_shape OVERLAP ABUT ALSO MULTI 
 [-= (count(line_end) > 0 && count(waive_shape) == 0) ? 1 : 0] > 0 
 [-= (EWXP(corner_space_all_TMP) < 0.08 && EWYP(corner_space_all_TMP) < 0.08) ? 1 : 0] > 0
 err1_TMP = DFM PROPERTY corner_space_all line_end OVERLAP ABUT ALSO MULTI [-= (count(line_end) == 0 || count(line_end) < 2) ? 1 : 0] > 0
 err1 = DFM COPY err1_TMP REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xm7_S_25a {
@ Corner space between two 1.25xMn in NCP direction when -0.04um < PRL <= 0um. >= 0.08um
 err1_RAW = EXT M7 < 0.08 ABUT<90 CORNER TO CORNER
 err1_TMP = DFM PROPERTY err1_RAW GLOBALXY [-= EWXP(err1_RAW)] < 0.04
 err1_SPE = EXT M7 M7_h_edges < 0.08 ABUT<90 REGION PROJ == 0
 err1 = (DFM COPY err1_TMP REGION) OR err1_SPE
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xm7_S_26 {
@ At least one space between 1.25xMn edge (any adjacent edge of concave corner) and 1.25xMn >= 0.119um, except either condition as below:
@ 1. Edge length between two concave corners < 0.12um
@ 2. Side edge length of concave corner < 0.042um
 waive_edge_a = LENGTH M7_convex_270_270_edges < 0.120
 waive_edge_b = LENGTH M7_convex_lt_two_edges < 0.042
 check_edge = (LENGTH M7_convex_lt_two_edges >= 0.042) NOT COIN EDGE M7_45_skew_edges
 // 
 Y1 = EXT [M7] check_edge < 0.119 ABUT<90 OPPOSITE EXTENDED 0.119
 Y2 = INT [Y1] < 0.001 ABUT==90 INTERSECTING ONLY
 Y3 = EXT Y2 check_edge < 0.119 ABUT<90 OPPOSITE EXTENDED 0.119
 err1_TMP = EXT (DFM COPY Y3 EDGE) < 0.04 ABUT==90 INTERSECTING ONLY REGION EXTENTS
 err1 = (err1_TMP NOT WITH EDGE waive_edge_a) NOT WITH EDGE waive_edge_b
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xm7_S_27 {
@ Space between 1.25xMy concave corner (both side edge length > 0.08um) and 1.25xMy line-end (width < 0.08um) >= 0.154um
 mets_CHK = LENGTH M7_convex_lt_two_edges > 0.08
 mets_CRN = EXT [mets_CHK] < 0.0005 ABUT==90 INTERSECTING ONLY // resolution concern
 // 
 err1_RAW = EXT M7_convex_lt_two_edges M7_end_080 < 0.154 ABUT EXCLUDE SHIELDED
 err1_HAS = mets_CRN COIN EDGE M7_convex_lt_two_edges
 err1_TMP = DFM PROPERTY err1_RAW err1_HAS ABUT ALSO OVERLAP MULTI [-= count(err1_HAS)] > 0
 err1 = DFM COPY err1_TMP REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
M7_space_eq_040_v_edges = EXT [M7_v_edges] == 0.04 OPPOSITE
M7_space_eq_040_v_areas = EXT M7_v_edges == 0.04 OPPOSITE REGION
M7_space_eq_040_v_areas_v_edges = ANGLE M7_space_eq_040_v_areas == 90
M7_width_lt_080_v_edges = (INT [M7_v_edges] < 0.08 ABUT<90 OPPOSITE) COIN EDGE (M7 WITH WIDTH < 0.08)
 
125xm7_S_28 {
@ Forbidden the space between 1.25xMn (width = 0.04~0.046um and one side space = 0.04um) and 1.25xMn (width < 0.08um (W1)) in CP direction, except both side space of 1.25xMy (width < 0.08um) to 1.25xMy >= 0.1um. = 0.061~0.098, 0.131~0.178um
 Mn_w040_w042 = WITH WIDTH M7 >= 0.04 <= 0.046
 Mn_w040_s040_v_edges = Mn_w040_w042 COIN EDGE M7_space_eq_040_v_edges
 Mn_w040_s040_v_edges_opp = INT Mn_w040_s040_v_edges [Mn_w040_w042] >= 0.04 <= 0.046 ABUT<90 OPPOSITE
 // not check W1 >= 0.08
 // 
 Mn_w080_s99_v_edges = EXT (M7_width_lt_080_v_edges) < 0.10 ABUT<90 OPPOSITE
 Mn_w080_s99_v_edges_both = INT [Mn_w080_s99_v_edges] < 0.08 ABUT<90 OPPOSITE
 Mn_w080_s99_v_edges_none = M7_width_lt_080_v_edges NOT COIN EDGE Mn_w080_s99_v_edges_both
 err1 = EXT Mn_w080_s99_v_edges_none Mn_w040_s040_v_edges_opp >= 0.131 <= 0.178 ABUT<90 OPPOSITE REGION EXCLUDE SHIELDED
 err2 = EXT Mn_w080_s99_v_edges_none Mn_w040_s040_v_edges_opp >= 0.061 <= 0.098 ABUT<90 OPPOSITE REGION EXCLUDE SHIELDED
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}
 
125xm7_S_29 {
@ Fobidden space between 1.25xMy (width = 0.06~0.07um and one side space = 0.04um) and 1.25xMy (width < 0.08um) in CP direction, except both side space of 1.25xMy (width < 0.08um) to 1.25xMy >= 0.1um. = 0.11~0.158um
 Mn_w060_w070 = WITH WIDTH M7 >= 0.06 <= 0.07
 Mn_w060_s040_v_edges = Mn_w060_w070 COIN EDGE M7_space_eq_040_v_edges
 Mn_w060_s040_v_edges_opp = INT Mn_w060_s040_v_edges [Mn_w060_w070] >= 0.06 <= 0.07 ABUT<90 OPPOSITE
 // not check W1 >= 0.08
 // 
 Mn_w080_s99_v_edges = EXT (M7_width_lt_080_v_edges) < 0.10 ABUT<90 OPPOSITE
 Mn_w080_s99_v_edges_both = INT [Mn_w080_s99_v_edges] < 0.08 ABUT<90 OPPOSITE
 Mn_w080_s99_v_edges_none = M7_width_lt_080_v_edges NOT COIN EDGE Mn_w080_s99_v_edges_both
 err1 = EXT Mn_w080_s99_v_edges_none Mn_w060_s040_v_edges_opp >= 0.110 <= 0.158 ABUT<90 OPPOSITE REGION EXCLUDE SHIELDED
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xm7_S_30 {
@ Space between 1.25xMn and 45-degree bent 1.25xMn, DRC check 45-degree direction >= 0.396um
 err1 = EXT M7 M7_45_skew_edges < 0.396 ABUT<90 OPPOSITE2 REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
//;125xmn_S_31~125xmn_S_37a: delta voltage rule
 
125xm7_L_1 {
@ Length of 45-degree bent 1.25xMn, except MARKS >= 0.905um
 err1 = LENGTH M7_45_skew_edges < 0.905
 err1 NOT INSIDE EDGE MARKS
}
 
125xm7_L_2 {
@ 1.25xMn edge length when the adjacent edge length <= 0.089um, except two 0.08um edges form a convex corner. >= 0.099um
 chk_condition = LENGTH M7 <= 0.089
 err_EdgLength = LENGTH M7 < 0.099
 waive_CASE = INT (LENGTH chk_condition == 0.08) (LENGTH err_EdgLength == 0.08) < 0.005 ABUT INTERSECTING ONLY REGION
 err1_TMP_A = EXT chk_condition err_EdgLength < 0.005 ABUT INTERSECTING ONLY REGION
 err1_TMP_B = (INT chk_condition err_EdgLength < 0.005 ABUT INTERSECTING ONLY REGION) NOT INTERACT waive_CASE
 err1 = OR (EXPAND EDGE (M7 TOUCH EDGE err1_TMP_A) OUTSIDE BY 0.001 EXTEND BY 0.001) (EXPAND EDGE (M7 TOUCH EDGE err1_TMP_B) OUTSIDE BY 0.001 EXTEND BY 0.001)
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xm7_L_3 {
@ 1.25xMn edge length when the adjacent edge length < 0.04um. >= 0.119um
 chk_condition = LENGTH M7 < 0.04
 err_EdgLength = LENGTH M7 < 0.119
 err1_TMP_A = EXT chk_condition err_EdgLength < 0.005 ABUT INTERSECTING ONLY REGION
 err1_TMP_B = INT chk_condition err_EdgLength < 0.005 ABUT INTERSECTING ONLY REGION
 err1 = OR (EXPAND EDGE (M7 TOUCH EDGE err1_TMP_A) OUTSIDE BY 0.001 EXTEND BY 0.001) (EXPAND EDGE (M7 TOUCH EDGE err1_TMP_B) OUTSIDE BY 0.001 EXTEND BY 0.001)
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xm7_L_4 {
@ 1.25xMn edge length when the adjacent line-end width < 0.06um. >= 0.159um
 chk_condition = EXPAND EDGE M7_end_060 INSIDE BY 0.001
 err_EdgLength = (M7_convex_eq_one_edges TOUCH EDGE chk_condition) NOT COIN EDGE M7_end_060
 err1 = LENGTH err_EdgLength < 0.159
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
125xm7_L_5 {
@ 1.25xMn edge length when the adjacent line-end width < 0.08um. >= 0.109um
 chk_condition = EXPAND EDGE M7_end_080 INSIDE BY 0.001
 err_EdgLength = (M7_convex_eq_one_edges TOUCH EDGE chk_condition) NOT COIN EDGE M7_end_080
 err1 = LENGTH err_EdgLength < 0.109
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
125xm7_L_6 {
@ 1.25xMn edge length between two consecutive 90-270 degree corners >= 0.019um
 // DRC also check the condition with at least one 90-270 degree corners
 mets_ERRS_EDGE = LENGTH M7_convex_270_90_edges < 0.019
 mets_ERRS_a = INT mets_ERRS_EDGE M7_convex_eq_one_edges < 0.005 ABUT==90 INTERSECTING ONLY REGION
 mets_ERRS_b = EXT mets_ERRS_EDGE M7_convex_eq_one_edges < 0.005 ABUT==90 INTERSECTING ONLY REGION
 err1_TMP = (M7_convex_eq_one_edges TOUCH EDGE mets_ERRS_a) OR EDGE (M7_convex_eq_one_edges TOUCH EDGE mets_ERRS_b)
 err1 = EXPAND EDGE err1_TMP INSIDE BY 0.001 CORNER FILL
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xm7_L_7 {
@ 1.25xMn edge length between two consecutive 90-270 degree corners with one adjacent line end edge width < 0.08um and the other adjacent edge > 0.070um. >= 0.238um
 line_CHK_a_RAW = LENGTH M7_convex_270_90_edges > 0.07 < 0.238
 line_CHK_a_TMP = EXPAND EDGE M7_end_080 INSIDE BY 0.001
 line_CHK_a = (line_CHK_a_RAW NOT TOUCH EDGE M7_end_080) TOUCH EDGE line_CHK_a_TMP
 line_CHK_b = LENGTH M7_convex_lt_two_edges > 0.07
 err1 = EXT line_CHK_b line_CHK_a < 0.005 ABUT==90 INTERSECTING REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xm7_L_8 {
@ 1.25xMn U-shape inner edge length between two consecutive 270-270 degree corners >= 0.08um
 err1 = LENGTH M7_convex_270_270_edges < 0.08
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
125xm7_L_9_V6 {
@ Length of 1.25xMn metal branch (width <= 0.269um) >= 1.5um
@ When:
@ 1. Metal branch is connected to wide metal with width and length >= 0.398um
@ 2. One square 1.25xVn-1/1.25xVn in metal branch, and space to wide metal <= 1.5um
@ DRC flags branch that can't enclose a 0.08um*1.5um orthogonal rectangle
@ ("V6_50" is mapped to "V6" in the rule name of this check)
 WIDE_M7 = (WITH WIDTH M7 > 0.398-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 0.398-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 0.398-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 branch_all = ((SIZE WIDE_M7 BY 1.5+GLOBAL_TOLERANCE INSIDE OF M7 STEP 0.025) NOT WIDE_M7) AND M7
 branch_size = INT (M7 INTERACT branch_all) < 0.269+GLOBAL_TOLERANCE ABUT<90 OPPOSITE REGION EXCLUDE SHIELDED
 branch_real = branch_size INTERACT WIDE_M7
 branch_down = (branch_real AND M6) INTERACT DVK_V6_SQ == 1
 branch_down_real = ((M7 INTERACT branch_down) AND M6) INTERACT DVK_V6_SQ == 1
 branch_down_err1 = branch_real NOT OUTSIDE branch_down_real
 err1_down = branch_down_err1 NOT ENCLOSE RECTANGLE 0.08 1.5 ORTHOGONAL ONLY
 // 
 branch_up = (branch_real AND M8) INTERACT (RECTANGLE V7 ASPECT == 1) == 1
 branch_up_real = ((M7 INTERACT branch_up) AND M8) INTERACT (RECTANGLE V7 ASPECT == 1) == 1
 branch_up_err2 = branch_real NOT OUTSIDE branch_up_real
 err2_up = branch_up_err2 NOT ENCLOSE RECTANGLE 0.08 1.5 ORTHOGONAL ONLY
 err1_down NOT INSIDE SealR_NOT_BULK
}
 
125xm7_L_9_V7 {
@ Length of 1.25xMn metal branch (width <= 0.269um) >= 1.5um
@ When:
@ 1. Metal branch is connected to wide metal with width and length >= 0.398um
@ 2. One square 1.25xVn-1/1.25xVn in metal branch, and space to wide metal <= 1.5um
@ DRC flags branch that can't enclose a 0.08um*1.5um orthogonal rectangle
@ ("TV2" is mapped to "V7" in the rule name of this check)
 WIDE_M7 = (WITH WIDTH M7 > 0.398-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 0.398-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 0.398-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 branch_all = ((SIZE WIDE_M7 BY 1.5+GLOBAL_TOLERANCE INSIDE OF M7 STEP 0.025) NOT WIDE_M7) AND M7
 branch_size = INT (M7 INTERACT branch_all) < 0.269+GLOBAL_TOLERANCE ABUT<90 OPPOSITE REGION EXCLUDE SHIELDED
 branch_real = branch_size INTERACT WIDE_M7
 branch_down = (branch_real AND M6) INTERACT DVK_V6_SQ == 1
 branch_down_real = ((M7 INTERACT branch_down) AND M6) INTERACT DVK_V6_SQ == 1
 branch_down_err1 = branch_real NOT OUTSIDE branch_down_real
 err1_down = branch_down_err1 NOT ENCLOSE RECTANGLE 0.08 1.5 ORTHOGONAL ONLY
 // 
 branch_up = (branch_real AND M8) INTERACT (RECTANGLE V7 ASPECT == 1) == 1
 branch_up_real = ((M7 INTERACT branch_up) AND M8) INTERACT (RECTANGLE V7 ASPECT == 1) == 1
 branch_up_err2 = branch_real NOT OUTSIDE branch_up_real
 err2_up = branch_up_err2 NOT ENCLOSE RECTANGLE 0.08 1.5 ORTHOGONAL ONLY
 err2_up NOT INSIDE SealR_NOT_BULK
}
 
125xm7_L_10_V6 {
@ Length of 1.25xMn metal branch (width <= 0.269um) >= 3.6um
@ When:
@ 1. Metal branch is connected to wide metal with width and length > 0.9um
@ 2. One square 1.25xVn-1/1.25xVn in metal branch, and space to wide metal <= 3.6um
@ DRC flags branch that can't enclose a 0.08um*3.6um orthogonal rectangle
@ ("V6_50" is mapped to "V6" in the rule name of this check)
 WIDE_M7 = (WITH WIDTH M7 > 0.9) ENCLOSE RECTANGLE 0.9+GLOBAL_TOLERANCE 0.9+GLOBAL_TOLERANCE
 branch_all = ((SIZE WIDE_M7 BY 3.6+GLOBAL_TOLERANCE INSIDE OF M7 STEP 0.025) NOT WIDE_M7) AND M7
 branch_size = INT (M7 INTERACT branch_all) < 0.269+GLOBAL_TOLERANCE ABUT<90 OPPOSITE REGION EXCLUDE SHIELDED
 branch_real = branch_size INTERACT WIDE_M7
 branch_down = (branch_real AND M6) INTERACT DVK_V6_SQ == 1
 branch_down_real = ((M7 INTERACT branch_down) AND M6) INTERACT DVK_V6_SQ == 1
 branch_down_err1 = branch_real NOT OUTSIDE branch_down_real
 err1_down = branch_down_err1 NOT ENCLOSE RECTANGLE 0.08 3.6 ORTHOGONAL ONLY
 // 
 branch_up = (branch_real AND M8) INTERACT (RECTANGLE V7 ASPECT == 1) == 1
 branch_up_real = ((M7 INTERACT branch_up) AND M8) INTERACT (RECTANGLE V7 ASPECT == 1) == 1
 branch_up_err2 = branch_real NOT OUTSIDE branch_up_real
 err2_up = branch_up_err2 NOT ENCLOSE RECTANGLE 0.08 3.6 ORTHOGONAL ONLY
 err1_down NOT INSIDE SealR_NOT_BULK
}
 
125xm7_L_10_V7 {
@ Length of 1.25xMn metal branch (width <= 0.269um) >= 3.6um
@ When:
@ 1. Metal branch is connected to wide metal with width and length > 0.9um
@ 2. One square 1.25xVn-1/1.25xVn in metal branch, and space to wide metal <= 3.6um
@ DRC flags branch that can't enclose a 0.08um*3.6um orthogonal rectangle
@ ("TV2" is mapped to "V7" in the rule name of this check)
 WIDE_M7 = (WITH WIDTH M7 > 0.9) ENCLOSE RECTANGLE 0.9+GLOBAL_TOLERANCE 0.9+GLOBAL_TOLERANCE
 branch_all = ((SIZE WIDE_M7 BY 3.6+GLOBAL_TOLERANCE INSIDE OF M7 STEP 0.025) NOT WIDE_M7) AND M7
 branch_size = INT (M7 INTERACT branch_all) < 0.269+GLOBAL_TOLERANCE ABUT<90 OPPOSITE REGION EXCLUDE SHIELDED
 branch_real = branch_size INTERACT WIDE_M7
 branch_down = (branch_real AND M6) INTERACT DVK_V6_SQ == 1
 branch_down_real = ((M7 INTERACT branch_down) AND M6) INTERACT DVK_V6_SQ == 1
 branch_down_err1 = branch_real NOT OUTSIDE branch_down_real
 err1_down = branch_down_err1 NOT ENCLOSE RECTANGLE 0.08 3.6 ORTHOGONAL ONLY
 // 
 branch_up = (branch_real AND M8) INTERACT (RECTANGLE V7 ASPECT == 1) == 1
 branch_up_real = ((M7 INTERACT branch_up) AND M8) INTERACT (RECTANGLE V7 ASPECT == 1) == 1
 branch_up_err2 = branch_real NOT OUTSIDE branch_up_real
 err2_up = branch_up_err2 NOT ENCLOSE RECTANGLE 0.08 3.6 ORTHOGONAL ONLY
 err2_up NOT INSIDE SealR_NOT_BULK
}
 
125xm7_L_11_V6 {
@ Length of 1.25xMn metal branch (width <= 0.269um) >= 9um
@ When:
@ 1. Metal branch is connected to wide metal with width and length > 1.35um
@ 2. One square 1.25xVn-1/1.25xVn in metal branch, and space to wide metal <= 9um
@ DRC flags branch that can't enclose a 0.08um*9um orthogonal rectangle
@ ("V6_50" is mapped to "V6" in the rule name of this check)
 WIDE_M7 = (WITH WIDTH M7 > 1.35) ENCLOSE RECTANGLE 1.35+GLOBAL_TOLERANCE 1.35+GLOBAL_TOLERANCE
 branch_all = ((SIZE WIDE_M7 BY 9+GLOBAL_TOLERANCE INSIDE OF M7 STEP 0.025) NOT WIDE_M7) AND M7
 branch_size = INT (M7 INTERACT branch_all) < 0.269+GLOBAL_TOLERANCE ABUT<90 OPPOSITE REGION EXCLUDE SHIELDED
 branch_real = branch_size INTERACT WIDE_M7
 branch_down = (branch_real AND M6) INTERACT DVK_V6_SQ == 1
 branch_down_real = ((M7 INTERACT branch_down) AND M6) INTERACT DVK_V6_SQ == 1
 branch_down_err1 = branch_real NOT OUTSIDE branch_down_real
 err1_down = branch_down_err1 NOT ENCLOSE RECTANGLE 0.08 9 ORTHOGONAL ONLY
 // 
 branch_up = (branch_real AND M8) INTERACT (RECTANGLE V7 ASPECT == 1) == 1
 branch_up_real = ((M7 INTERACT branch_up) AND M8) INTERACT (RECTANGLE V7 ASPECT == 1) == 1
 branch_up_err2 = branch_real NOT OUTSIDE branch_up_real
 err2_up = branch_up_err2 NOT ENCLOSE RECTANGLE 0.08 9 ORTHOGONAL ONLY
 err1_down NOT INSIDE SealR_NOT_BULK
}
 
125xm7_L_11_V7 {
@ Length of 1.25xMn metal branch (width <= 0.269um) >= 9um
@ When:
@ 1. Metal branch is connected to wide metal with width and length > 1.35um
@ 2. One square 1.25xVn-1/1.25xVn in metal branch, and space to wide metal <= 9um
@ DRC flags branch that can't enclose a 0.08um*9um orthogonal rectangle
@ ("TV2" is mapped to "V7" in the rule name of this check)
 WIDE_M7 = (WITH WIDTH M7 > 1.35) ENCLOSE RECTANGLE 1.35+GLOBAL_TOLERANCE 1.35+GLOBAL_TOLERANCE
 branch_all = ((SIZE WIDE_M7 BY 9+GLOBAL_TOLERANCE INSIDE OF M7 STEP 0.025) NOT WIDE_M7) AND M7
 branch_size = INT (M7 INTERACT branch_all) < 0.269+GLOBAL_TOLERANCE ABUT<90 OPPOSITE REGION EXCLUDE SHIELDED
 branch_real = branch_size INTERACT WIDE_M7
 branch_down = (branch_real AND M6) INTERACT DVK_V6_SQ == 1
 branch_down_real = ((M7 INTERACT branch_down) AND M6) INTERACT DVK_V6_SQ == 1
 branch_down_err1 = branch_real NOT OUTSIDE branch_down_real
 err1_down = branch_down_err1 NOT ENCLOSE RECTANGLE 0.08 9 ORTHOGONAL ONLY
 // 
 branch_up = (branch_real AND M8) INTERACT (RECTANGLE V7 ASPECT == 1) == 1
 branch_up_real = ((M7 INTERACT branch_up) AND M8) INTERACT (RECTANGLE V7 ASPECT == 1) == 1
 branch_up_err2 = branch_real NOT OUTSIDE branch_up_real
 err2_up = branch_up_err2 NOT ENCLOSE RECTANGLE 0.08 9 ORTHOGONAL ONLY
 err2_up NOT INSIDE SealR_NOT_BULK
}
 
125xm7_A_1 {
@ 1.25xMn area >= 0.0148um2
 err1 = AREA M7 < 0.0148
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xm7_A_2 {
@ 1.25xMn area when all of edge lengths < 0.115um, except can fill a 0.05um*0.13um rectangle >= 0.039um2
 M7_waive = ENCLOSE RECTANGLE M7 0.050 0.130 ORTHOGONAL ONLY
 M7_check = AREA M7 < 0.039
 M7_edge_all = LENGTH M7_check >= 0.115
 err1 = (M7_check NOT WITH EDGE M7_edge_all) NOT M7_waive
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xm7_A_3 {
@ 1.25xMn enclosed area >= 0.181um2
 err1 = AREA ((HOLES M7 INNER) NOT M7) < 0.181
 err1 NOT INSIDE SealR_NOT_BULK
}
 

#IFDEF IP_LEVEL_DENSITY_CHECK YES
#IFDEF MINIMUM_DENSITY_CHECK YES

125xm7_DN_1 {
@ 1.25xMn Density (window 50um*50um, stepping 50um/step_number), except LOGO, MARKS, (OCOVL AND MnDUB), (NODMF su 1um) regions >= 10.5%
 except_area = OR LOGO MARKS (OCOVL AND M7DUB) NODMF_SIZE_1
 check_region = DRC:1 NOT except_area
 check_pattern = M7_all AND check_region
 // 
 check_window1 = check_region WITH WIDTH >= 50/4
 err1_TMP1 = DENSITY check_pattern check_window1 check_region [!AREA(check_window1) + !!AREA(check_window1)*AREA(check_pattern)/AREA(check_region)] < 0.105 WINDOW 50 STEP 50/step_number BACKUP INSIDE OF LAYER DRC:1 BY POLYGON
 // 
 check_window2 = WITH WIDTH (check_region AND err1_TMP1) >= 50/4
 err1_TMP2 = DENSITY check_pattern check_window2 check_region [!AREA(check_window2) + !!AREA(check_window2)*AREA(check_pattern)/AREA(check_region)] < 0.105 WINDOW 50 STEP 50/step_number BACKUP INSIDE OF LAYER err1_TMP1 BY POLYGON
 // 
 check_window3 = WITH WIDTH (check_region AND err1_TMP2) >= 50/4
 DENSITY check_pattern check_window3 check_region [!AREA(check_window3) + !!AREA(check_window3)*AREA(check_pattern)/AREA(check_region)] < 0.105 WINDOW 50 STEP 50/step_number BACKUP INSIDE OF LAYER err1_TMP2 BY POLYGON PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_125xm7_DN_1.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_125xm7_DN_1.rdb"
}
 
125xm7_DN_1a {
@ 1.25xMn Density (window 50um*50um, stepping 50um/step_number), except the window not interact 3um*3um empty area, LOGO, MARKS, (OCOVL AND MnDUB), (NODMF su 1um) regions >= 26.3%
 except_area = OR LOGO MARKS (OCOVL AND M7DUB) NODMF_SIZE_1
 check_region = DRC:1 NOT except_area
 ck3x3_window = WITH WIDTH (check_region NOT M7_all) >= 3
 check_pattern = M7_all AND check_region
 // 
 check_window1 = check_region WITH WIDTH >= 50/4
 err1_TMP1 = DENSITY check_pattern check_window1 check_region ck3x3_window [!AREA(ck3x3_window) + !AREA(check_window1) + !!AREA(ck3x3_window)*!!AREA(check_window1)*AREA(check_pattern)/AREA(check_region)] < 0.263 WINDOW 50 STEP 50/step_number BACKUP INSIDE OF LAYER DRC:1 BY POLYGON
 // 
 check_window2 = WITH WIDTH (check_region AND err1_TMP1) >= 50/4
 err1_TMP2 = DENSITY check_pattern check_window2 check_region ck3x3_window [!AREA(ck3x3_window) + !AREA(check_window2) + !!AREA(ck3x3_window)*!!AREA(check_window2)*AREA(check_pattern)/AREA(check_region)] < 0.263 WINDOW 50 STEP 50/step_number BACKUP INSIDE OF LAYER err1_TMP1 BY POLYGON
 // 
 check_window3 = WITH WIDTH (check_region AND err1_TMP2) >= 50/4
 DENSITY check_pattern check_window3 check_region ck3x3_window [!AREA(ck3x3_window) + !AREA(check_window3) + !!AREA(ck3x3_window)*!!AREA(check_window3)*AREA(check_pattern)/AREA(check_region)] < 0.263 WINDOW 50 STEP 50/step_number BACKUP INSIDE OF LAYER err1_TMP2 BY POLYGON PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_125xm7_DN_1a.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_125xm7_DN_1a.rdb"
}

#ENDIF


#IFDEF RECOMMENDED_CHECK YES

 
125xm7_DN_2_R {
@ 1.25xMn maximum density (window 50um*50um, stepping 25um), except dummy metal. DRC doesn't check (1.25xMn AND DUPMK1) region when the 1.25xMn layer is used as TM-1 <= 65%
 check_region = CHIP_NOT_MARKS NOT DUPMK1
 check_pattern = M7 AND check_region
 // 
 check_window1 = check_region WITH WIDTH >= 50/4
 err1_TMP1 = DENSITY check_pattern check_window1 check_region [!!AREA(check_window1)*AREA(check_pattern)/AREA(check_region)] > 0.65 WINDOW 50 STEP 25 BACKUP INSIDE OF LAYER DRC:1 BY POLYGON
 // 
 check_window2 = WITH WIDTH (check_region AND err1_TMP1) >= 50/4
 err1_TMP2 = DENSITY check_pattern check_window2 check_region [!!AREA(check_window2)*AREA(check_pattern)/AREA(check_region)] > 0.65 WINDOW 50 STEP 25 BACKUP INSIDE OF LAYER err1_TMP1 BY POLYGON
 // 
 check_window3 = WITH WIDTH (check_region AND err1_TMP2) >= 50/4
 DENSITY check_pattern check_window3 check_region [!!AREA(check_window3)*AREA(check_pattern)/AREA(check_region)] > 0.65 WINDOW 50 STEP 25 BACKUP INSIDE OF LAYER err1_TMP2 BY POLYGON PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_125xm7_DN_2_R.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_125xm7_DN_2_R.rdb"
}

#ENDIF

 
125xm7_DN_3 {
@ Maximum 1.25xMn density (window 50um*50um, stepping 50um/step_number). DRC doesn't check (1.25xMn AND DUPMK1) region when the 1.25xMn layer is used as TM-1 <= 71.3%
 check_region = CHIP_NOT_MARKS NOT DUPMK1
 check_pattern = M7_all AND check_region
 // 
 check_window1 = check_region WITH WIDTH >= 50/4
 err1_TMP1 = DENSITY check_pattern check_window1 check_region [!!AREA(check_window1)*AREA(check_pattern)/AREA(check_region)] > 0.713 WINDOW 50 STEP 50/step_number BACKUP INSIDE OF LAYER DRC:1 BY POLYGON
 // 
 check_window2 = WITH WIDTH (check_region AND err1_TMP1) >= 50/4
 err1_TMP2 = DENSITY check_pattern check_window2 check_region [!!AREA(check_window2)*AREA(check_pattern)/AREA(check_region)] > 0.713 WINDOW 50 STEP 50/step_number BACKUP INSIDE OF LAYER err1_TMP1 BY POLYGON
 // 
 check_window3 = WITH WIDTH (check_region AND err1_TMP2) >= 50/4
 DENSITY check_pattern check_window3 check_region [!!AREA(check_window3)*AREA(check_pattern)/AREA(check_region)] > 0.713 WINDOW 50 STEP 50/step_number BACKUP INSIDE OF LAYER err1_TMP2 BY POLYGON PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_125xm7_DN_3.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_125xm7_DN_3.rdb"
}
 
125xm7_DN_4 {
@ 1.25xMn density difference between two neighboring checking windows (window 180um*180um, stepping 360um/step_number), except (NODMF) su 0.4um region <= 47.5%
 except_area = OR MARKS NODMF_SIZE_0.4
 check_pattern = M7_all NOT except_area
 check_region = DRC:1 NOT except_area
 DENSITY check_pattern check_region [AREA(check_pattern)/AREA(check_region)] >= 0 WINDOW 180 STEP 360/step_number GRADIENT > 0.475 ABSOLUTE BACKUP PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_125xm7_DN_4.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_125xm7_DN_4.rdb"
}
 

#IFDEF MINIMUM_DENSITY_CHECK YES


#ENDIF
#ENDIF

 

#IFDEF IP_LEVEL_DENSITY_CHECK NO
#IFDEF MINIMUM_DENSITY_CHECK YES

125xm7_DN_1 {
@ 1.25xMn Density (window 50um*50um, stepping 25um), except LOGO, MARKS, (OCOVL AND MnDUB), (NODMF su 1um) regions >= 10%
 except_area = OR LOGO MARKS (OCOVL AND M7DUB) NODMF_SIZE_1
 check_region = DRC:1 NOT except_area
 check_pattern = M7_all AND check_region
 // 
 check_window1 = check_region WITH WIDTH >= 50/4
 err1_TMP1 = DENSITY check_pattern check_window1 check_region [!AREA(check_window1) + !!AREA(check_window1)*AREA(check_pattern)/AREA(check_region)] < 0.1 WINDOW 50 STEP 25 BACKUP INSIDE OF LAYER DRC:1 BY POLYGON
 // 
 check_window2 = WITH WIDTH (check_region AND err1_TMP1) >= 50/4
 err1_TMP2 = DENSITY check_pattern check_window2 check_region [!AREA(check_window2) + !!AREA(check_window2)*AREA(check_pattern)/AREA(check_region)] < 0.1 WINDOW 50 STEP 25 BACKUP INSIDE OF LAYER err1_TMP1 BY POLYGON
 // 
 check_window3 = WITH WIDTH (check_region AND err1_TMP2) >= 50/4
 DENSITY check_pattern check_window3 check_region [!AREA(check_window3) + !!AREA(check_window3)*AREA(check_pattern)/AREA(check_region)] < 0.1 WINDOW 50 STEP 25 BACKUP INSIDE OF LAYER err1_TMP2 BY POLYGON PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_125xm7_DN_1.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_125xm7_DN_1.rdb"
}
 
125xm7_DN_1a {
@ 1.25xMn Density (window 50um*50um, stepping 25um), except the window not interact 3um*3um empty area, LOGO, MARKS, (OCOVL AND MnDUB), (NODMF su 1um) regions >= 25%
 except_area = OR LOGO MARKS (OCOVL AND M7DUB) NODMF_SIZE_1
 check_region = DRC:1 NOT except_area
 ck3x3_window = WITH WIDTH (check_region NOT M7_all) >= 3
 check_pattern = M7_all AND check_region
 // 
 check_window1 = check_region WITH WIDTH >= 50/4
 err1_TMP1 = DENSITY check_pattern check_window1 check_region ck3x3_window [!AREA(ck3x3_window) + !AREA(check_window1) + !!AREA(ck3x3_window)*!!AREA(check_window1)*AREA(check_pattern)/AREA(check_region)] < 0.25 WINDOW 50 STEP 25 BACKUP INSIDE OF LAYER DRC:1 BY POLYGON
 // 
 check_window2 = WITH WIDTH (check_region AND err1_TMP1) >= 50/4
 err1_TMP2 = DENSITY check_pattern check_window2 check_region ck3x3_window [!AREA(ck3x3_window) + !AREA(check_window2) + !!AREA(ck3x3_window)*!!AREA(check_window2)*AREA(check_pattern)/AREA(check_region)] < 0.25 WINDOW 50 STEP 25 BACKUP INSIDE OF LAYER err1_TMP1 BY POLYGON
 // 
 check_window3 = WITH WIDTH (check_region AND err1_TMP2) >= 50/4
 DENSITY check_pattern check_window3 check_region ck3x3_window [!AREA(ck3x3_window) + !AREA(check_window3) + !!AREA(ck3x3_window)*!!AREA(check_window3)*AREA(check_pattern)/AREA(check_region)] < 0.25 WINDOW 50 STEP 25 BACKUP INSIDE OF LAYER err1_TMP2 BY POLYGON PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_125xm7_DN_1a.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_125xm7_DN_1a.rdb"
}

#ENDIF


#IFDEF RECOMMENDED_CHECK YES

 
125xm7_DN_2_R {
@ 1.25xMn maximum density (window 50um*50um, stepping 25um), except dummy metal. DRC doesn't check (1.25xMn AND DUPMK1) region when the 1.25xMn layer is used as TM-1 <= 65%
 check_region = CHIP_NOT_MARKS NOT DUPMK1
 check_pattern = M7 AND check_region
 // 
 check_window1 = check_region WITH WIDTH >= 50/4
 err1_TMP1 = DENSITY check_pattern check_window1 check_region [!!AREA(check_window1)*AREA(check_pattern)/AREA(check_region)] > 0.65 WINDOW 50 STEP 25 BACKUP INSIDE OF LAYER DRC:1 BY POLYGON
 // 
 check_window2 = WITH WIDTH (check_region AND err1_TMP1) >= 50/4
 err1_TMP2 = DENSITY check_pattern check_window2 check_region [!!AREA(check_window2)*AREA(check_pattern)/AREA(check_region)] > 0.65 WINDOW 50 STEP 25 BACKUP INSIDE OF LAYER err1_TMP1 BY POLYGON
 // 
 check_window3 = WITH WIDTH (check_region AND err1_TMP2) >= 50/4
 DENSITY check_pattern check_window3 check_region [!!AREA(check_window3)*AREA(check_pattern)/AREA(check_region)] > 0.65 WINDOW 50 STEP 25 BACKUP INSIDE OF LAYER err1_TMP2 BY POLYGON PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_125xm7_DN_2_R.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_125xm7_DN_2_R.rdb"
}

#ENDIF

 
125xm7_DN_3 {
@ Maximum 1.25xMn density (window 50um*50um, stepping 25um). DRC doesn't check (1.25xMn AND DUPMK1) region when the 1.25xMn layer is used as TM-1 <= 75%
 check_region = CHIP_NOT_MARKS NOT DUPMK1
 check_pattern = M7_all AND check_region
 // 
 check_window1 = check_region WITH WIDTH >= 50/4
 err1_TMP1 = DENSITY check_pattern check_window1 check_region [!!AREA(check_window1)*AREA(check_pattern)/AREA(check_region)] > 0.75 WINDOW 50 STEP 25 BACKUP INSIDE OF LAYER DRC:1 BY POLYGON
 // 
 check_window2 = WITH WIDTH (check_region AND err1_TMP1) >= 50/4
 err1_TMP2 = DENSITY check_pattern check_window2 check_region [!!AREA(check_window2)*AREA(check_pattern)/AREA(check_region)] > 0.75 WINDOW 50 STEP 25 BACKUP INSIDE OF LAYER err1_TMP1 BY POLYGON
 // 
 check_window3 = WITH WIDTH (check_region AND err1_TMP2) >= 50/4
 DENSITY check_pattern check_window3 check_region [!!AREA(check_window3)*AREA(check_pattern)/AREA(check_region)] > 0.75 WINDOW 50 STEP 25 BACKUP INSIDE OF LAYER err1_TMP2 BY POLYGON PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_125xm7_DN_3.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_125xm7_DN_3.rdb"
}
 
125xm7_DN_4 {
@ 1.25xMn density difference between two neighboring checking windows (window 180um*180um, stepping 180um), except (NODMF) su 0.4um region <= 50%
 except_area = OR MARKS NODMF_SIZE_0.4
 check_pattern = M7_all NOT except_area
 check_region = DRC:1 NOT except_area
 DENSITY check_pattern check_region [AREA(check_pattern)/AREA(check_region)] >= 0 WINDOW 180 STEP 180 GRADIENT > 0.5 ABSOLUTE BACKUP PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_125xm7_DN_4.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_125xm7_DN_4.rdb"
}
 

#IFDEF MINIMUM_DENSITY_CHECK YES


#ENDIF
#ENDIF


//1.25xMn.R.1[NC] 1.25xMn pattern must drawn on data type 50 or 55.
//1.25xMn.R.2[NC] It is not allowed for data type 50 and 55 exist on the same metal layer at the same time.
//1.25xMn.R.3[NC] M5/M7 must be drawn on data type 55, M6/M8 must be drawn on data type 50, 1.25xMn and 1.25xMn-1 using same data type is not allowed


// =======================================================
// 1.25xVn design rules
// =======================================================

GROUP G125xv4 125xv4_?
 
125xv4_BAR = (OR V4_BAR_100_all V4_BAR_450_all) INSIDE MARKS_MARKG
 
125xv4_W_1_L_1 {
@ 1.25xVn width and length, except 0.04*0.1um 1.25xVn, MARKS, MARKG and LOGO regions = 0.04um
 err1 = (V4 NOT RV4) NOT V4N
 err1 NOT INSIDE MARKS_MARKG_LOGO
}
 
125xv4_W_2 {
@ 1.25xVn bar width in MARKG/MARKS regions = 0.1, 0.45um
 err1 = (V4 NOT (OR V4_SR V4_BAR_100_all V4_BAR_450_all V4N_Seal_Ring)) INSIDE MARKS_MARKG
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xv4_S_1 {
@ Space between two 1.25xVn >= 0.056um
 err1 = EXT V4_SR < 0.056 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xv4_S_2 {
@ Space between two 1.25xVn when PRL > -0.04um. >= 0.074um
 err1 = EXT V4_SR < 0.074 ABUT<90 OPPOSITE EXTENDED 0.040 REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xv4_S_3 {
@ Space between 1.25xVn (1.25xVn enclosure by upper metal > 0um) and Vy/1.25xVn-1 at different net and PRL > 0um. >= 0.055um
 chk_via = (V4 INTERACT (V4N INSIDE M5)) NOT COIN EDGE M5
 err1 = EXT chk_via V3 < 0.055 ABUT<90 OPPOSITE REGION NOT CONNECTED
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xv4_S_4_M4 {
@ Space between two square 1.25xVn with PRL > -0.119um. >= 0.119um
@ When:
@ 1) 1.25xVn enclosure by 1.25xMy/1.25xMn/1.25xMn+1 < 0.01um at opposite side
@ 2) Space between 1.25xVn and 1.25xMy/1.25xMn/1.25xMn+1 <= 0.052um with PRL >= -0.046um at opposite side
@ DRC doesn't flag space between 1.25xVn and 1.25xMy/1.25xMn/1.25xMn+1 <= 0.052um with PRL >= -0.046um on both sides
 ncp_axis = ANGLE (ENC [V4N] M4 < 0.01 ABUT<90 OPPOSITE) == 0
 y1 = ANGLE (V4N TOUCH EDGE ncp_axis) == 0
 y2 = EXT [y1] M4 <= 0.052 ABUT<90 OPPOSITE EXTENDED 0.046+GLOBAL_TOLERANCE MEASURE ALL
 y3 = V4N TOUCH EDGE y2
 y4 = INT [V4N] y3 == 0.040 ABUT<90 OPPOSITE
 err1 = EXT (y4 NOT TOUCH EDGE y2) V4_SR < 0.119 ABUT<90 OPPOSITE EXTENDED 0.119 REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xv4_S_4_M5 {
@ Space between two square 1.25xVn with PRL > -0.119um. >= 0.119um
@ When:
@ 1) 1.25xVn enclosure by 1.25xMy/1.25xMn/1.25xMn+1 < 0.01um at opposite side
@ 2) Space between 1.25xVn and 1.25xMy/1.25xMn/1.25xMn+1 <= 0.052um with PRL >= -0.046um at opposite side
@ DRC doesn't flag space between 1.25xVn and 1.25xMy/1.25xMn/1.25xMn+1 <= 0.052um with PRL >= -0.046um on both sides
 ncp_axis = ANGLE (ENC [V4N] M5 < 0.01 ABUT<90 OPPOSITE) == 90
 y1 = ANGLE (V4N TOUCH EDGE ncp_axis) == 90
 y2 = EXT [y1] M5 <= 0.052 ABUT<90 OPPOSITE EXTENDED 0.046+GLOBAL_TOLERANCE MEASURE ALL
 y3 = V4N TOUCH EDGE y2
 y4 = INT [V4N] y3 == 0.040 ABUT<90 OPPOSITE
 err1 = EXT (y4 NOT TOUCH EDGE y2) V4_SR < 0.119 ABUT<90 OPPOSITE EXTENDED 0.119 REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xv4_S_5 {
@ Space between 1.25xVn bar (width = 0.1/0.45um) and (1.25xVn or 1.25xRVn) >= 0.34um
 err1 = EXT (OR V4_BAR_100_all V4_BAR_450_all) V4_SR < 0.34 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xv4_S_6 {
@ Space between 1.25xVn bar (width = 0.1/0.45um), DRC only check the space between parallel edge when the 1.25xVn bar is inside MARKS >= 0.55um
 err1 = EXT ((OR V4_BAR_100_all V4_BAR_450_all) INTERACT MARKS_MARKG) < 0.55 SINGULAR ANGLED!=1 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xv4_EN_1 {
@ 1.25xVn must be fully enclosed by 1.25xMy or 1.25xMn where 1.25xMy or 1.25xMn is the metal layer direct underneath 1.25xVn
@ Enclosure by 1.25xMy or 1.25xMn must follow one of 1.25xVn.EN.2 or 1.25xVn.EN.3 or 1.25xVn.EN.4 or 1.25xVn.EN.5 or 1.25xVn.EN.6 or 1.25xVn.EN.7
 err1 = V4N NOT M4
 err1 NOT INSIDE SealR_NOT_BULK
}
 
//;beginning of the 125xVn.EN.2 derivations
met_125xv4_2 = M4 WITH WIDTH == 0.040
via_125xv4_2 = V4N NOT OUTSIDE met_125xv4_2
via_125xv4_2_bad = RECTANGLE ENCLOSURE via_125xv4_2 M4 ABUT<90 SINGULAR 
GOOD 0 0.049 OPPOSITE 0 0.049 OPPOSITE
via_125xv4_2_good = via_125xv4_2 NOT via_125xv4_2_bad
//;end of the 125xVn.EN.2 derivations
 
125xv4_EN_2 {
@ 1.25xVn enclosure by 1.25xMy or 1.25xMn (width = 0.04um) for two opposite sides with the other two sides >= 0um. >= 0.049um
 err1 = COPY via_125xv4_2_bad
 err1 NOT INSIDE SealR_NOT_BULK
}
 
//;beginning of the 125xVn.EN.2a derivations
met_125xv4_2a = M4 WITH WIDTH == 0.042
via_125xv4_2a = V4N NOT OUTSIDE met_125xv4_2a
via_125xv4_2a_bad = RECTANGLE ENCLOSURE via_125xv4_2a M4 ABUT<90 SINGULAR 
GOOD 0.001 0.049 OPPOSITE 0.001 0.049 OPPOSITE
via_125xv4_2a_good = via_125xv4_2a NOT via_125xv4_2a_bad
//;end of the 125xVn.EN.2a derivations
 
125xv4_EN_2a {
@ 1.25xVn enclosure by 1.25xMy or 1.25xMn (width = 0.042um) for two opposite sides with the other two sides >= 0.001um. >= 0.049um
 err1 = via_125xv4_2a_bad NOT via_125xv4_2_good
 err1 NOT INSIDE SealR_NOT_BULK
}
 
//;beginning of the 125xVn.EN.3 derivations
met_125xv4_3 = M4 WITH WIDTH == 0.044
via_125xv4_3 = V4N NOT OUTSIDE met_125xv4_3
via_125xv4_3_bad = RECTANGLE ENCLOSURE via_125xv4_3 M4 ABUT<90 SINGULAR 
GOOD 0.002 0.049 OPPOSITE 0.002 0.049 OPPOSITE
via_125xv4_3_good = via_125xv4_3 NOT via_125xv4_3_bad
//;end of the 125xVn.EN.3 derivations
 
125xv4_EN_3 {
@ 1.25xVn enclosure by 1.25xMy or 1.25xMn (width = 0.044um) for two opposite sides with the other two sides >= 0.002um. >= 0.049um
 err1 = via_125xv4_3_bad NOT (OR via_125xv4_2_good via_125xv4_2a_good)
 err1 NOT INSIDE SealR_NOT_BULK
}
 
//;beginning of the 125xVn.EN.3a derivations
met_125xv4_4 = M4 WITH WIDTH == 0.046
via_125xv4_4 = V4N NOT OUTSIDE met_125xv4_4
via_125xv4_4_bad = RECTANGLE ENCLOSURE via_125xv4_4 M4 ABUT<90 SINGULAR 
GOOD 0.003 0.049 OPPOSITE 0.003 0.049 OPPOSITE
via_125xv4_4_good = via_125xv4_4 NOT via_125xv4_4_bad
//;end of the 125xVn.EN.3a derivations
 
125xv4_EN_4 {
@ 1.25xVn enclosure by 1.25xMy or 1.25xMn (width = 0.046um) for two opposite sides with the other two sides >= 0.003um. >= 0.049um
 err1 = via_125xv4_4_bad NOT (OR via_125xv4_2_good via_125xv4_2a_good via_125xv4_3_good)
 err1 NOT INSIDE SealR_NOT_BULK
}
 
//;beginning of the 125xVn.EN.5 derivations
met_125xv4_5 = M4 WITH WIDTH >= 0.060 < 0.08
via_125xv4_5 = V4N NOT OUTSIDE met_125xv4_5
via_125xv4_5_bad = RECTANGLE ENCLOSURE via_125xv4_5 M4 ABUT<90 SINGULAR 
GOOD 0.01 0.049 OPPOSITE 0.01 0.049 OPPOSITE
via_125xv4_5_good = via_125xv4_5 NOT via_125xv4_5_bad
//;end of the 125xVn.EN.5 derivations
 
125xv4_EN_5 {
@ 1.25xVn enclosure by 1.25xMy or 1.25xMn (0.06 <= width < 0.08um) for two opposite sides with the other two sides >= 0.01um. >= 0.049um
 err1 = via_125xv4_5_bad NOT (OR via_125xv4_2_good via_125xv4_2a_good via_125xv4_3_good via_125xv4_4_good)
 err1 NOT INSIDE SealR_NOT_BULK
}
 
// 125xVn.EN.5: purposely blank
 
//;beginning of the 125xVn.EN.6 derivations
met_125xv4_6 = M4 WITH WIDTH == 0.080
via_125xv4_6 = V4N NOT OUTSIDE met_125xv4_6
via_125xv4_6_bad = RECTANGLE ENCLOSURE via_125xv4_6 M4 ABUT<90 SINGULAR 
GOOD 0.02 0.02 0.02 0.02 OPPOSITE
via_125xv4_6_good = via_125xv4_6 NOT via_125xv4_6_bad
//;end of the 125xVn.EN.6 derivations
via_125xv4_2_3_4_good = OR via_125xv4_2_good via_125xv4_2a_good via_125xv4_3_good via_125xv4_4_good via_125xv4_5_good
via_125xv4_2_3_4_6_good = OR via_125xv4_2_3_4_good via_125xv4_6_good
 
125xv4_EN_6 {
@ 1.25xVn enclosure by 1.25xMy or 1.25xMn (width = 0.08um) for all sides >= 0.02um
 err1 = via_125xv4_6_bad NOT via_125xv4_2_3_4_good
 err1 NOT INSIDE SealR_NOT_BULK
 err2 = ENC via_125xv4_6 M4 < 0.02 ABUT<90 SINGULAR REGION //for via corner enclosure check
 err2 NOT INSIDE SealR_NOT_BULK
}
 
//;beginning of the 125xVn.EN.7 derivations
met_125xv4_7 = M4 WITH WIDTH > 0.080
via_125xv4_7 = V4N NOT OUTSIDE met_125xv4_7
via_125xv4_7_bad = RECTANGLE ENCLOSURE via_125xv4_7 M4 ABUT<90 SINGULAR 
GOOD 0.02 0.029 OPPOSITE 0.02 0.029 OPPOSITE
via_125xv4_7_good = via_125xv4_7 NOT via_125xv4_7_bad
//;end of the 125xVn.EN.7 derivations
 
125xv4_EN_7 {
@ 1.25xVn enclosure by 1.25xMy or 1.25xMn (width > 0.08um) for two opposite sides with the other two sides >= 0.02um. >= 0.029um
 err1 = via_125xv4_7_bad NOT via_125xv4_2_3_4_6_good
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xv4_EN_8 {
@ 1.25xVn bar enclosure by 1.25xMy or 1.25xMn >= 0.098um
 err1 = (V4_BAR_100_all OR V4_BAR_450_all) NOT M4
 err2 = ENC V4_BAR_100_all M4 < 0.098 ABUT<90 SINGULAR REGION
 err3 = ENC V4_BAR_450_all M4 < 0.098 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
}
 
125xv4_EN_9 {
@ 1.25xVn must be fully enclosed by 1.25xMn+1 where 1.25xMn+1 is the metal layer directly above 1.25xVn
@ Enclosure by 1.25xMn+1 must follow one of 1.25xVn.EN.10 or 1.25xVn.EN.11 or 1.25xVn.EN.12 or 1.25xVn.EN.13 or 1.25xVn.EN.14
 err1 = V4N NOT M5
 err1 NOT INSIDE SealR_NOT_BULK
}
 
//;beginning of the 125xVn.EN.10 derivations
met_125xv4_10 = M5 WITH WIDTH == 0.040
via_125xv4_10 = V4N NOT OUTSIDE met_125xv4_10
via_125xv4_10_bad = RECTANGLE ENCLOSURE via_125xv4_10 M5 ABUT<90 SINGULAR 
GOOD 0 0.049 OPPOSITE 0 0.049 OPPOSITE
via_125xv4_10_good = via_125xv4_10 NOT via_125xv4_10_bad
//;end of the 125xVn.EN.10 derivations
 
125xv4_EN_10 {
@ 1.25xVn enclosure by 1.25xMn+1 (width = 0.04um) for two opposite sides with the other two sides >= 0um. >= 0.049um
 err1 = copy via_125xv4_10_bad
 err1 NOT INSIDE SealR_NOT_BULK
}
 
//;beginning of the 125xVn.EN.10a derivations
met_125xv4_10a = M5 WITH WIDTH == 0.042
via_125xv4_10a = V4N NOT OUTSIDE met_125xv4_10a
via_125xv4_10a_bad = RECTANGLE ENCLOSURE via_125xv4_10a M5 ABUT<90 SINGULAR 
GOOD 0.001 0.049 OPPOSITE 0.001 0.049 OPPOSITE
via_125xv4_10a_good = via_125xv4_10a NOT via_125xv4_10a_bad
//;end of the 125xVn.EN.10a derivations
 
125xv4_EN_10a {
@ 1.25xVn enclosure by 1.25xMn+1 (width = 0.042um) for two opposite sides with the other two sides >= 0.001um. >= 0.049um
 err1 = via_125xv4_10a_bad NOT via_125xv4_10_good
 err1 NOT INSIDE SealR_NOT_BULK
}
 
//;beginning of the 125xVn.EN.11 derivations
met_125xv4_11 = M5 WITH WIDTH == 0.044
via_125xv4_11_TMP = V4N NOT OUTSIDE met_125xv4_11
via_125xv4_11 = via_125xv4_11_TMP NOT via_125xv4_10_good
via_125xv4_11_bad = RECTANGLE ENCLOSURE via_125xv4_11 M5 ABUT<90 SINGULAR 
GOOD 0.002 0.049 OPPOSITE 0.002 0.049 OPPOSITE
via_125xv4_11_good = via_125xv4_11 NOT via_125xv4_11_bad
//;end of the 125xVn.EN.11 derivations
 
125xv4_EN_11 {
@ 1.25xVn enclosure by 1.25xMn+1 (width = 0.044um) for two opposite sides with the other two sides >= 0.002um. >= 0.049um
 err1 = via_125xv4_11_bad NOT (OR via_125xv4_10_good via_125xv4_10a_good)
 err1 NOT INSIDE SealR_NOT_BULK
}
 
//;beginning of the 125xVn.EN.11 derivations
met_125xv4_11a = M5 WITH WIDTH == 0.046
via_125xv4_11a = V4N NOT OUTSIDE met_125xv4_11a
via_125xv4_11a_bad = RECTANGLE ENCLOSURE via_125xv4_11a M5 ABUT<90 SINGULAR 
GOOD 0.003 0.049 OPPOSITE 0.003 0.049 OPPOSITE
via_125xv4_11a_good = via_125xv4_11a NOT via_125xv4_11a_bad
//;end of the 125xVn.EN.11 derivations
 
125xv4_EN_11a {
@ 1.25xVn enclosure by 1.25xMn+1 (width = 0.046um) for two opposite sides with the other two sides >= 0.003um. >= 0.049um
 err1 = via_125xv4_11a_bad NOT (OR via_125xv4_10_good via_125xv4_10a_good via_125xv4_11_good)
 err1 NOT INSIDE SealR_NOT_BULK
}
 
//;beginning of the 125xVn.EN.12 derivations
met_125xv4_12 = M5 WITH WIDTH >= 0.060 < 0.08
via_125xv4_12 = V4N NOT OUTSIDE met_125xv4_12
via_125xv4_12_bad = RECTANGLE ENCLOSURE via_125xv4_12 M5 ABUT<90 SINGULAR 
GOOD 0.01 0.049 OPPOSITE 0.01 0.049 OPPOSITE
via_125xv4_12_good = via_125xv4_12 NOT via_125xv4_12_bad
//;end of the 125xVn.EN.12 derivations
via_125xv4_10_11_good = OR via_125xv4_10_good via_125xv4_10a_good via_125xv4_11_good via_125xv4_11a_good
via_125xv4_10_11_12_good = OR via_125xv4_10_11_good via_125xv4_12_good
 
125xv4_EN_12 {
@ 1.25xVn enclosure by 1.25xMn+1 (0.06 <= width < 0.08um) for two opposite sides with the other two sides >= 0.01um. >= 0.049um
 err1 = via_125xv4_12_bad NOT via_125xv4_10_11_good
 err1 NOT INSIDE SealR_NOT_BULK
}
 
//;beginning of the 125xVn.EN.13 derivations
met_125xv4_13 = M5 WITH WIDTH == 0.080
via_125xv4_13 = V4N NOT OUTSIDE met_125xv4_13
via_125xv4_13_bad = RECTANGLE ENCLOSURE via_125xv4_13 M5 ABUT<90 SINGULAR 
GOOD 0.02 0.02 0.02 0.02 OPPOSITE
via_125xv4_13_good = via_125xv4_13 NOT via_125xv4_13_bad
//;end of the 125xVn.EN.13 derivations
 
125xv4_EN_13 {
@ 1.25xVn enclosure by 1.25xMn+1 (width = 0.08um) for all sides >= 0.02um
 err1 = via_125xv4_13_bad NOT via_125xv4_10_11_12_good
 err1 NOT INSIDE SealR_NOT_BULK
 err2 = ENC via_125xv4_13 M5 < 0.02 ABUT<90 SINGULAR REGION //for via corner enclosure check
 err2 NOT INSIDE SealR_NOT_BULK
}
 
//;beginning of the 125xVn.EN.14 derivations
met_125xv4_14 = M5 WITH WIDTH > 0.080
via_125xv4_14 = V4N NOT OUTSIDE met_125xv4_14
via_125xv4_14_bad = RECTANGLE ENCLOSURE via_125xv4_14 M5 ABUT<90 SINGULAR 
GOOD 0.02 0.029 OPPOSITE 0.02 0.029 OPPOSITE
via_125xv4_14_good = via_125xv4_14 NOT via_125xv4_14_bad
//;end of the 125xVn.EN.14 derivations
 
125xv4_EN_14 {
@ 1.25xVn enclosure by 1.25xMn+1 (width > 0.08um) for two opposite sides with the other two sides >= 0.02um. >= 0.029um
 err1 = via_125xv4_14_bad NOT (OR via_125xv4_10_11_12_good via_125xv4_13_good)
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xv4_EN_15 {
@ 1.25xVn enclosure by 1.25xMn+1 edge (between two consecutive 90-270 degree corners, length < 0.16um), when PRL > 0um. >= 0.029um
 chk_edge = CONVEX EDGE M5 ANGLE1 == 90 ANGLE2 == 270 WITH LENGTH < 0.16
 err1_TMP = chk_edge TOUCH EDGE (EXT chk_edge M5_convex_270_90_edges < 0.005 ABUT==90 INTERSECTING ONLY REGION)
 err1 = ENC V4N err1_TMP < 0.029 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xv4_EN_16 {
@ 1.25xVn enclosure by 1.25xMn+1 for two opposite sides (PRL > 0) with the other side enclosure < 0.04um (corresponding edge length < 0.16um between two consecutive 90-270 degree corners) >= 0.04um
 correspond_EDG = CONVEX EDGE M5 ANGLE1 == 90 ANGLE2 == 270 WITH LENGTH < 0.16
 correspond_ENC = ENC [V4N] correspond_EDG < 0.04 ABUT<90 OPPOSITE EXTENDED 0.001
 correspond_VIA_ENC_EDGE = V4N TOUCH EDGE correspond_ENC
 correspond_VIA_EDG_CORN = INT [V4N] correspond_VIA_ENC_EDGE < 0.001 ABUT==90 INTERSECTING ONLY
 correspond_VIA_EDG = V4N TOUCH EDGE correspond_VIA_EDG_CORN
 err1_RAW = ENC [correspond_VIA_EDG] M5 < 0.040 ABUT<90 OPPOSITE EXTENDED 0.001
 err1_TMP = INT correspond_VIA_ENC_EDGE (correspond_VIA_EDG TOUCH EDGE err1_RAW) < 0.005 ABUT==90 INTERSECTING ONLY REGION
 err1 = EXPAND EDGE (V4N TOUCH EDGE err1_TMP) INSIDE BY 0.001
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xv4_EN_17 {
@ 1.25xVn bar fully enclosure by 1.25xMn+1 >= 0.2um
 err1 = (V4_BAR_100_all OR V4_BAR_450_all) NOT M5
 err2 = ENC V4_BAR_100_all M5 < 0.2 ABUT<90 SINGULAR REGION
 err3 = ENC V4_BAR_450_all M5 < 0.2 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
}

#IFDEF RECOMMENDED_CHECK YES

 
125xv4_D_1_R {
@ (1.25xVn OR 1.25xRVn) density (window 5um*5um, stepping 2.5um) < 12%
 check_region = copy CHIP_NOT_MARKS
 check_pattern = (V4 NOT 125xv4_BAR) AND check_region
 // 
 check_window1 = check_region WITH WIDTH >= 5/4
 err1_TMP1 = DENSITY check_pattern check_window1 check_region [!!AREA(check_window1)*AREA(check_pattern)/AREA(check_region)] >= 12/100 WINDOW 5 STEP 5/2 BACKUP INSIDE OF LAYER DRC:1 BY POLYGON
 // 
 check_window2 = WITH WIDTH (check_region AND err1_TMP1) >= 5/4
 err1_TMP2 = DENSITY check_pattern check_window2 check_region [!!AREA(check_window2)*AREA(check_pattern)/AREA(check_region)] >= 12/100 WINDOW 5 STEP 5/2 BACKUP INSIDE OF LAYER err1_TMP1 BY POLYGON
 // 
 check_window3 = WITH WIDTH (check_region AND err1_TMP2) >= 5/4
 DENSITY check_pattern check_window3 check_region [!!AREA(check_window3)*AREA(check_pattern)/AREA(check_region)] >= 12/100 WINDOW 5 STEP 5/2 BACKUP INSIDE OF LAYER err1_TMP2 BY POLYGON PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_125xv4_D_1_R.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_125xv4_D_1_R.rdb"
}

#ENDIF

 
125xv4_R_1 {
@ 45-degree 1.25xVn is not allowed
 err1 = ANGLE (V4 NOT 125xv4_BAR) > 44.5 < 45.5
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
125xv4_R_2 {
@ It is not allowed to have single 1.25xVn in "H-shape" 1.25xMn+1 when all of the following conditions come into existence:
@ 1) The 1.25xMn+1 has "H-shape" interact two metal holes: both two metal hole length <= 4.5um and two metal hole area <= 4.05um2
@ 2) The 1.25xVn overlaps on the center metal bar of this "H-shape" 1.25xMn+1
@ 3) The center metal bar length <= 0.9um and the metal bar width <= 0.162um
 hole_area_meet = AREA (HOLES M5 INNER) <= 4.05
 hole_area_meet_len = (hole_area_meet WITH EDGE (LENGTH hole_area_meet <= 0.9)) NOT WITH EDGE (LENGTH hole_area_meet > 4.5)
 hole_area_real = (hole_area_meet_len NOT ENCLOSE RECTANGLE 0.9+GLOBAL_TOLERANCE 4.5) NOT ENCLOSE RECTANGLE 0.9 4.5+GLOBAL_TOLERANCE
 hole_bars_len = M5 COIN EDGE hole_area_real
 // 
 hole_bars = INT hole_bars_len <= 0.162 ABUT<90 OPPOSITE REGION EXCLUDE SHIELDED
 hole_bars_real = hole_bars WITH EDGE (LENGTH hole_bars_len <= 0.9)
 hole_bars_vias_sq = V4N INTERACT ((hole_bars_real INTERACT hole_area_real == 2) NOT ENCLOSE RV4)
 err1 = hole_bars_real INTERACT hole_bars_vias_sq == 1
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xv4_R_3 {
@ The numbers of neighboring square 1.25xVn to each edge of 1.25xVn <= 0.065um is not allowed < 2
 // based on 125xVn.S.6 and 125xVn.S.1, so only check the space range 0.056~0.065um with PRL <= 0.04
 Y1 = EXT V4N >= 0.056 <= 0.065 ABUT CORNER TO CORNER
 Y2 = DFM PROPERTY Y1 [-= (EWXP(Y1) > 0.040 && EWYP(Y1) > 0.040) ? 1 : 0] > 0
 Y3 = INT [V4N] < 0.001 ABUT INTERSECTING ONLY
 Y4 = Y3 COIN EDGE (DFM COPY Y2 EDGE)
 Y5 = INT Y4 V4N < 0.001 ABUT==90 INTERSECTING ONLY REGION
 Y6 = INT (V4N COIN EDGE Y5) == 0.040 OPPOSITE REGION
 err1 = V4N INTERACT Y6
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xv4_R_4 {
@ The numbers of neighboring square 1.25xVn in one group (space <= 0.065um) <= 3
 err1 = WITH NEIGHBOR V4N > 2 SPACE <= 0.065
 err1 NOT INSIDE SealR_NOT_BULK
}
 

#IFDEF Delta_Voltage_Rules_Check YES

125xv4_R_5 {
@ Maximum delta V >= 5.6V is not allowed, when space between 1.25xVn is < 0.410um
 chk_VIA = V4 INTERACT DVK_V4_SQ
 err1 = DFM DV chk_VIA V4 < 0.410 DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" >= 5.6 ANNOTATE NOT CONNECTED SINGULAR
 DFM COPY err1
}

#ENDIF

// 1.25xVn.R.8[NC] 1.25xVn pattern must be drawn on data type 50
 
125xv4_R_9 {
@ It's not allowed 1.25xVn overlap with the metal resistor directly underneath and above the 1.25xVn
 err1 = V4 AND (M4RES AND M4)
 err2 = V4 AND (M5RES AND M5)
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

#IFDEF RECOMMENDED_CHECK YES

 
125xv4_R_10_R {
@ Recommend space between a square 1.25xVn and another (1.25xVn OR 1.25xRVn OR DUM_1.25xVn) < 4um to avoid single square 1.25xVn
 ALL_VIA_CHECK = OR V4_SR V4DUM_all V4DOP_all
 STEP_1 = SIZE V4_SR BY 1.4
 // 4/1.414 = 2.828
 STEP_1_GOOD = STEP_1 INTERACT ALL_VIA_CHECK > 1
 STEP_1_FILTER = V4N NOT INTERACT STEP_1_GOOD
 err1 = STEP_1_FILTER NOT WITH EDGE (EXT [STEP_1_FILTER] ALL_VIA_CHECK < 4 PERP ALSO)
 err1 NOT INSIDE SealR_NOT_BULK
}

#ENDIF


// =======================================================
// 1.25xVn design rules: Rectangular 1.25xVn
// =======================================================

GROUP G125xRv4 125xRv4_?
 
125xRv4_W_1_L_1 {
@ 1.25xRVn.W.1: 1.25xRVn width, except MARKS, MARKG and LOGO regions = 0.04um
@ 1.25xRVn.L.1: Length of 1.25xRVn (width = 0.04um) = 0.1um
 err1 = (V4 NOT V4N) NOT RV4
 err1 NOT INSIDE MARKS_MARKG_LOGO
}
 
125xRv4_S_1a {
@ Space between (1.25xVn or 1.25xRVn) and 1.25xRVn >= 0.074um
 err1 = EXT RV4 V4_SR < 0.074 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xRv4_S_1b {
@ Space between (1.25xVn or 1.25xRVn) and 1.25xRVn when PRL > -0.04um. >= 0.079um
 err1 = EXT RV4 V4_SR < 0.079 ABUT<90 OPPOSITE EXTENDED 0.04 REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xRv4_S_1c {
@ Space between the short side of 1.25xRVn and (1.25xVn or 1.25xRVn) when PRL > -0.04um. >= 0.089um
 err1 = EXT RV4_W V4_SR < 0.089 ABUT<90 OPPOSITE EXTENDED 0.04 REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xRv4_S_2 {
@ Space between 1.25xRVn and (Vy or RVy) at different net and PRL > 0um, when 1.25xMn+1 enclosure of 1.25xRVn > 0um. >= 0.055um
 chk_via = (V4 INTERACT RV4) NOT COIN EDGE M5
 err1 = EXT chk_via V3 < 0.055 ABUT<90 OPPOSITE REGION NOT CONNECTED
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xRv4_S_4_M4 {
@ Space between 1.25xRVn when PRL >= -0.119um. >= 0.119um
@ When:
@ 1) 1.25xRVn enclosure by 1.25xMy/1.25xMn/1.25xMn+1 < 0.01um at opposite side
@ 2) Space between 1.25xRVn and 1.25xMy/1.25xMn/1.25xMn+1 <= 0.052um with PRL >= -0.046um at opposite side
@ DRC doesn't flag space between 1.25xRVn and 1.25xMy/1.25xMn/1.25xMn+1 <= 0.052um with PRL >= -0.046um on both sides
 ncp_axis = ANGLE (ENC [RV4] M4 < 0.01 ABUT<90 OPPOSITE) == 0
 y1 = ANGLE (RV4 TOUCH EDGE ncp_axis) == 0
 y2 = EXT [y1] M4 <= 0.052 ABUT<90 OPPOSITE EXTENDED 0.046+GLOBAL_TOLERANCE MEASURE ALL
 y3 = RV4 TOUCH EDGE y2
 y4 = INT [RV4] y3 == 0.040 ABUT<90 OPPOSITE
 err1 = EXT (y4 NOT TOUCH EDGE y2) V4_SR < 0.119 ABUT<90 OPPOSITE EXTENDED 0.119+GLOBAL_TOLERANCE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xRv4_S_4_M5 {
@ Space between 1.25xRVn when PRL >= -0.119um. >= 0.119um
@ When:
@ 1) 1.25xRVn enclosure by 1.25xMy/1.25xMn/1.25xMn+1 < 0.01um at opposite side
@ 2) Space between 1.25xRVn and 1.25xMy/1.25xMn/1.25xMn+1 <= 0.052um with PRL >= -0.046um at opposite side
@ DRC doesn't flag space between 1.25xRVn and 1.25xMy/1.25xMn/1.25xMn+1 <= 0.052um with PRL >= -0.046um on both sides
 ncp_axis = ANGLE (ENC [RV4] M5 < 0.01 ABUT<90 OPPOSITE) == 90
 y1 = ANGLE (RV4 TOUCH EDGE ncp_axis) == 90
 y2 = EXT [y1] M5 <= 0.052 ABUT<90 OPPOSITE EXTENDED 0.046+GLOBAL_TOLERANCE MEASURE ALL
 y3 = RV4 TOUCH EDGE y2
 y4 = INT [RV4] y3 == 0.040 ABUT<90 OPPOSITE
 err1 = EXT (y4 NOT TOUCH EDGE y2) V4_SR < 0.119 ABUT<90 OPPOSITE EXTENDED 0.119+GLOBAL_TOLERANCE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xRv4_EN_1 {
@ 1.25xRVn must be fully enclosed by 1.25xMy or 1.25xMn where 1.25xMy or 1.25xMn is the metal layer directly underneath 1.25xRVn. Enclosure by 1.25xMy or 1.25xMn must follow one of 1.25xRVn.EN.2 or 1.25xRVn.EN.3 or 1.25xRVn.EN.4 or 1.25xRVn.EN.5 or 1.25xRVn.EN.6 or 1.25xRVn.EN.7 or 1.25xRVn.EN.8
 err1 = RV4 NOT M4
 err1 NOT INSIDE SealR_NOT_BULK
}
 
//;beginning of the 125xRVn.EN.2 derivations
met_125xRv4_2 = M4 WITH WIDTH == 0.040
via_125xRv4_2 = RV4 NOT OUTSIDE met_125xRv4_2
via_125xRv4_2_bad = RECTANGLE ENCLOSURE via_125xRv4_2 M4 ABUT<90 SINGULAR 
GOOD 0 0.049 OPPOSITE 0 0.049 OPPOSITE
via_125xRv4_2_good = via_125xRv4_2 NOT via_125xRv4_2_bad
//;end of the 125xRVn.EN.2 derivations
 
125xRv4_EN_2 {
@ 1.25xRVn enclosure by 1.25xMy or 1.25xMn (width = 0.04um) for two opposite sides with the other two sides >= 0um. >= 0.049um
 err1 = copy via_125xRv4_2_bad
 err1 NOT INSIDE SealR_NOT_BULK
}
 
//;beginning of the 125xRVn.EN.2a derivations
met_125xRv4_2a = M4 WITH WIDTH == 0.042
via_125xRv4_2a = RV4 NOT OUTSIDE met_125xRv4_2a
via_125xRv4_2a_bad = RECTANGLE ENCLOSURE via_125xRv4_2a M4 ABUT<90 SINGULAR 
GOOD 0.001 0.049 OPPOSITE 0.001 0.049 OPPOSITE
via_125xRv4_2a_good = via_125xRv4_2a NOT via_125xRv4_2a_bad
//;end of the 125xRVn.EN.2a derivations
 
125xRv4_EN_2a {
@ 1.25xRVn enclosure by 1.25xMy or 1.25xMn (width = 0.042um) for two opposite sides with the other two sides >= 0.001um. >= 0.049um
 err1 = via_125xRv4_2a_bad NOT via_125xRv4_2_good
 err1 NOT INSIDE SealR_NOT_BULK
}
 
//;beginning of the 125xRVn.EN.3 derivations
met_125xRv4_3 = M4 WITH WIDTH == 0.044
via_125xRv4_3 = RV4 NOT OUTSIDE met_125xRv4_3
via_125xRv4_3_bad = RECTANGLE ENCLOSURE via_125xRv4_3 M4 ABUT<90 SINGULAR 
GOOD 0.002 0.049 OPPOSITE 0.002 0.049 OPPOSITE
via_125xRv4_3_good = via_125xRv4_3 NOT via_125xRv4_3_bad
//;end of the 125xRVn.EN.3 derivations
 
125xRv4_EN_3 {
@ 1.25xRVn enclosure by 1.25xMy or 1.25xMn (width = 0.044um) for two opposite sides with the other two sides >= 0.002um. >= 0.049um
 err1 = via_125xRv4_3_bad NOT (OR via_125xRv4_2_good via_125xRv4_2a_good)
 err1 NOT INSIDE SealR_NOT_BULK
}
 
//;beginning of the 125xRVn.EN.3a derivations
met_125xRv4_3a = M4 WITH WIDTH == 0.046
via_125xRv4_3a = RV4 NOT OUTSIDE met_125xRv4_3a
via_125xRv4_3a_bad = RECTANGLE ENCLOSURE via_125xRv4_3a M4 ABUT<90 SINGULAR 
GOOD 0.003 0.049 OPPOSITE 0.003 0.049 OPPOSITE
via_125xRv4_3a_good = via_125xRv4_3a NOT via_125xRv4_3a_bad
//;end of the 125xRVn.EN.3a derivations
 
125xRv4_EN_3a {
@ 1.25xRVn enclosure by 1.25xMy or 1.25xMn (width = 0.046um) for two opposite sides with the other two sides >= 0.003um. >= 0.049um
 err1 = via_125xRv4_3a_bad NOT (OR via_125xRv4_2_good via_125xRv4_2a_good via_125xRv4_3_good)
 err1 NOT INSIDE SealR_NOT_BULK
}
 
//;beginning of the 125xRVn.EN.4 derivations
met_125xRv4_4 = M4 WITH WIDTH >= 0.060 < 0.08
via_125xRv4_4 = RV4 NOT OUTSIDE met_125xRv4_4
via_125xRv4_4_bad = RECTANGLE ENCLOSURE via_125xRv4_4 M4 ABUT<90 SINGULAR 
GOOD 0.01 0.049 OPPOSITE 0.010 0.049 OPPOSITE
via_125xRv4_4_good = via_125xRv4_4 NOT via_125xRv4_4_bad
//;end of the 125xRVn.EN.4 derivations
via_125xRv4_2_3_good = OR via_125xRv4_2_good via_125xRv4_2a_good via_125xRv4_3_good via_125xRv4_3a_good
via_125xRv4_2_3_4_good = OR via_125xRv4_2_3_good via_125xRv4_4_good
 
125xRv4_EN_4 {
@ 1.25xRVn enclosure by 1.25xMy or 1.25xMn (0.06um <= width < 0.08um) for two opposite sides with the other two sides >= 0.01um. >= 0.049um
 err1 = via_125xRv4_4_bad NOT via_125xRv4_2_3_good
 err1 NOT INSIDE SealR_NOT_BULK
}
 
//;beginning of the 125xRVn.EN.5 derivations
met_125xRv4_5 = M4 WITH WIDTH == 0.080
via_125xRv4_5 = RV4 NOT OUTSIDE met_125xRv4_5
via_125xRv4_5_bad = RECTANGLE ENCLOSURE via_125xRv4_5 M4 ABUT<90 SINGULAR 
GOOD 0.02 0.02 0.02 0.02 OPPOSITE
via_125xRv4_5_good = via_125xRv4_5 NOT via_125xRv4_5_bad
//;end of the 125xRVn.EN.5 derivations
 
125xRv4_EN_5 {
@ 1.25xRVn enclosure by 1.25xMy or 1.25xMn (width = 0.08um) for all sides >= 0.02um
 err1 = via_125xRv4_5_bad NOT via_125xRv4_2_3_4_good
 err1 NOT INSIDE SealR_NOT_BULK
 err2 = ENC via_125xRv4_5 M4 < 0.02 ABUT<90 SINGULAR REGION
 err2 NOT INSIDE SealR_NOT_BULK
}
 
 //--------------Definition of 1.25xRVn array----------------- 
125xRv_14 = EXT [RV4_L] == 0.08 ABUT<90 OPPOSITE
125xRv_24 = LENGTH 125xRv_14 == 0.1
125xRv_04 = (EXT RV4_L == 0.08 ABUT<90 OPPOSITE REGION) WITH EDGE 125xRv_24
125xRv_34 = RV4 WITH EDGE 125xRv_14
125xRv_array4 = (125xRv_34 OR 125xRv_04) INTERACT 125xRv_34 > 1
 
//;beginning of the 125xRVn.EN.6 derivations
met_125xRv4_6 = M4 WITH WIDTH > 0.080
via_125xRv4_6 = (RV4 INTERACT met_125xRv4_6) NOT INTERACT 125xRv_array4
via_125xRv4_6_bad = RECTANGLE ENCLOSURE via_125xRv4_6 M4 ABUT<90 SINGULAR 
GOOD 0.02 0.029 OPPOSITE 0.02 0.029 OPPOSITE
via_125xRv4_6_good = via_125xRv4_6 NOT via_125xRv4_6_bad
//;end of the 125xRVn.EN.6 derivations
 
125xRv4_EN_6 {
@ 1.25xRVn enclosure by 1.25xMy or 1.25xMn (width > 0.08um) for two opposite sides with the other two sides >= 0.02um (except rectangular 1.25xRVn array) >= 0.029um
 err1 = via_125xRv4_6_bad NOT (OR via_125xRv4_2_3_4_good via_125xRv4_5_good via_125xRv4_7_good) //125xRv.EN.6~7: the width conditions are covered by each other
 err1 NOT INSIDE SealR_NOT_BULK
}
 
//;beginning of the 125xRVn.EN.7 derivations
met_125xRv4_7 = M4 WITH WIDTH > 0.080
via_125xRv4_7 = (RV4 INTERACT met_125xRv4_7) NOT INTERACT 125xRv_array4
via_125xRv4_7_L_edges = LENGTH via_125xRv4_7 == 0.10
via_125xRv4_7_W_edges = LENGTH via_125xRv4_7 == 0.04
via_125xRv4_7_x = ENC [via_125xRv4_7_L_edges] M4 < 0.039 ABUT<90 OPPOSITE
via_125xRv4_7_y = ENC [via_125xRv4_7_W_edges] M4 < 0.01 ABUT<90 OPPOSITE
via_125xRv4_7_bad = via_125xRv4_7 WITH EDGE (OR EDGE via_125xRv4_7_x via_125xRv4_7_y)
via_125xRv4_7_good = via_125xRv4_7 NOT via_125xRv4_7_bad
//;end of the 125xRVn.EN.7 derivations
 
125xRv4_EN_7 {
@ 1.25xRVn enclosure by short side of 1.25xMy or 1.25xMn (width > 0.08um) with long side enclosure >= 0.039um (except rectangular 1.25xRVn array) >= 0.01um
 err1 = via_125xRv4_7_bad NOT (OR via_125xRv4_2_3_4_good via_125xRv4_5_good via_125xRv4_6_good)
 err1 NOT INSIDE SealR_NOT_BULK
}
 
//;beginning of the 125xRVn.EN.8 derivations
met_125xRv4_8 = COPY M4
via_125xRv4_8 = (RV4 INTERACT met_125xRv4_8) INTERACT 125xRv_array4
via_125xRv4_8_bad = RECTANGLE ENCLOSURE via_125xRv4_8 M4 ABUT<90 SINGULAR 
GOOD 0.01 0.02 OPPOSITE 0.01 0.02 OPPOSITE
via_125xRv4_8_good = via_125xRv4_8 NOT via_125xRv4_8_bad
//;end of the 125xRVn.EN.8 derivations
 
125xRv4_EN_8 {
@ 1.25xRVn array enclosed by 1.25xMn/1.25xMy for two opposite sides with the other two sides (rectangular 1.25xVn array edge length = 0.1um) >= 0.02um
@ Definition of 1.25xRVn array:
@ 1.25xVn long side space = 0.08um (PRL = 0.1um) >= 0.01um
 err1 = via_125xRv4_8_bad NOT (OR via_125xRv4_2_3_4_good via_125xRv4_5_good via_125xRv4_6_good via_125xRv4_7_good)
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xRv4_EN_9 {
@ 1.25xRVn must be fully enclosed by 1.25xMn+1 where 1.25xMn+1 is the metal layer directly above 1.25xRVn. Enclosures by 1.25xMn+1 must follow one of 1.25xRVn.EN.10 or 1.25xRVn.EN.11 or 1.25xRVn.EN.12 or 1.25xRVn.EN.13 or 1.25xRVn.EN.14.
 err1 = RV4 NOT M5
 err1 NOT INSIDE SealR_NOT_BULK
}
 
//;beginning of the 125xRVn.EN.10 derivations
met_125xRv4_10 = M5 WITH WIDTH == 0.040
via_125xRv4_10 = RV4 NOT OUTSIDE met_125xRv4_10
via_125xRv4_10_bad = RECTANGLE ENCLOSURE via_125xRv4_10 M5 ABUT<90 SINGULAR 
GOOD 0 0.039 OPPOSITE 0 0.039 OPPOSITE
via_125xRv4_10_good = via_125xRv4_10 NOT via_125xRv4_10_bad
//;end of the 125xRVn.EN.10 derivations
 
125xRv4_EN_10 {
@ 1.25xRVn enclosure by 1.25xMn+1 (width = 0.04um) for two opposite sides with the other two sides >= 0um. >= 0.039um
 err1 = copy via_125xRv4_10_bad
 err1 NOT INSIDE SealR_NOT_BULK
}
 
//;beginning of the 125xRVn.EN.10a derivations
met_125xRv4_10a = M5 WITH WIDTH == 0.042
via_125xRv4_10a = RV4 NOT OUTSIDE met_125xRv4_10a
via_125xRv4_10a_bad = RECTANGLE ENCLOSURE via_125xRv4_10a M5 ABUT<90 SINGULAR 
GOOD 0.001 0.039 OPPOSITE 0.001 0.039 OPPOSITE
via_125xRv4_10a_good = via_125xRv4_10a NOT via_125xRv4_10a_bad
//;end of the 125xRVn.EN.10a derivations
 
125xRv4_EN_10a {
@ 1.25xRVn enclosure by 1.25xMn+1 (width = 0.042um) for two opposite sides with the other two sides >= 0.001um. >= 0.039um
 err1 = via_125xRv4_10a_bad NOT via_125xRv4_10_good
 err1 NOT INSIDE SealR_NOT_BULK
}
 
//;beginning of the 125xRVn.EN.10b derivations
met_125xRv4_10b = M5 WITH WIDTH == 0.044
via_125xRv4_10b = RV4 NOT OUTSIDE met_125xRv4_10b
via_125xRv4_10b_bad = RECTANGLE ENCLOSURE via_125xRv4_10b M5 ABUT<90 SINGULAR 
GOOD 0.002 0.039 OPPOSITE 0.002 0.039 OPPOSITE
via_125xRv4_10b_good = via_125xRv4_10b NOT via_125xRv4_10b_bad
//;end of the 125xRVn.EN.10b derivations
 
125xRv4_EN_10b {
@ 1.25xRVn enclosure by 1.25xMn+1 (width = 0.044um) for two opposite sides with the other two sides >= 0.002um. >= 0.039um
 err1 = via_125xRv4_10b_bad NOT (OR via_125xRv4_10_good via_125xRv4_10a_good)
 err1 NOT INSIDE SealR_NOT_BULK
}
 
//;beginning of the 125xRVn.EN.10c derivations
met_125xRv4_10c = M5 WITH WIDTH == 0.046
via_125xRv4_10c = RV4 NOT OUTSIDE met_125xRv4_10c
via_125xRv4_10c_bad = RECTANGLE ENCLOSURE via_125xRv4_10c M5 ABUT<90 SINGULAR 
GOOD 0.003 0.039 OPPOSITE 0.003 0.039 OPPOSITE
via_125xRv4_10c_good = via_125xRv4_10c NOT via_125xRv4_10c_bad
//;end of the 125xRVn.EN.10c derivations
 
125xRv4_EN_10c {
@ 1.25xRVn enclosure by 1.25xMn+1 (width = 0.046um) for two opposite sides with the other two sides >= 0.003um. >= 0.039um
 err1 = via_125xRv4_10c_bad NOT (OR via_125xRv4_10_good via_125xRv4_10a_good via_125xRv4_10b_good)
 err1 NOT INSIDE SealR_NOT_BULK
}
 
//;beginning of the 125xRVn.EN.10d derivations
met_125xRv4_10d = M5 WITH WIDTH >= 0.060 < 0.08
via_125xRv4_10d = RV4 NOT OUTSIDE met_125xRv4_10d
via_125xRv4_10d_bad = RECTANGLE ENCLOSURE via_125xRv4_10d M5 ABUT<90 SINGULAR 
GOOD 0.01 0.039 OPPOSITE 0.01 0.039 OPPOSITE
via_125xRv4_10d_good = via_125xRv4_10d NOT via_125xRv4_10d_bad
//;end of the 125xRVn.EN.10d derivations
 
125xRv4_EN_10d {
@ 1.25xRVn enclosure by 1.25xMn+1 (width >= 0.06 < 0.08um) for two opposite sides with the other two sides >= 0.01um. >= 0.039um
 err1 = via_125xRv4_10d_bad NOT (OR via_125xRv4_10_good via_125xRv4_10a_good via_125xRv4_10b_good via_125xRv4_10c_good)
 err1 NOT INSIDE SealR_NOT_BULK
}
 
//;beginning of the 125xRVn.EN.11 derivations
met_125xRv4_11 = M5 WITH WIDTH == 0.080
via_125xRv4_11 = RV4 NOT OUTSIDE met_125xRv4_11
via_125xRv4_11_bad = RECTANGLE ENCLOSURE via_125xRv4_11 M5 ABUT<90 SINGULAR 
GOOD 0.02 0.02 0.02 0.02 OPPOSITE
via_125xRv4_11_good = via_125xRv4_11 NOT via_125xRv4_11_bad
//;end of the 125xRVn.EN.11 derivations
via_125xRv4_10_10abcd_good = OR via_125xRv4_10_good via_125xRv4_10a_good via_125xRv4_10b_good via_125xRv4_10c_good via_125xRv4_10d_good
via_125xRv4_10_10a_10b_10c_10d_11_good = OR via_125xRv4_10_10abcd_good via_125xRv4_11_good
 
125xRv4_EN_11 {
@ 1.25xRVn enclosure by 1.25xMn+1 (width = 0.08um) for all sides >= 0.02um
 err1 = via_125xRv4_11_bad NOT via_125xRv4_10_10abcd_good
 err1 NOT INSIDE SealR_NOT_BULK
 err2 = ENC via_125xRv4_11 M5 < 0.02 ABUT<90 SINGULAR REGION
 err2 NOT INSIDE SealR_NOT_BULK
}
 
//;beginning of the 125xRVn.EN.12 derivations
met_125xRv4_12 = M5 WITH WIDTH > 0.08
via_125xRv4_12 = (RV4 INTERACT met_125xRv4_12) NOT INTERACT 125xRv_array4
via_125xRv4_12_bad = RECTANGLE ENCLOSURE via_125xRv4_12 M5 ABUT<90 SINGULAR 
GOOD 0.02 0.029 OPPOSITE 0.02 0.029 OPPOSITE
via_125xRv4_12_good = via_125xRv4_12 NOT via_125xRv4_12_bad
//;end of the 125xRVn.EN.12 derivations
 
125xRv4_EN_12 {
@ 1.25xRVn enclosure by 1.25xMn+1 (width > 0.080um) for two opposite sides with the other two sides >= 0.02um (except rectangular 1.25xVn array) >= 0.029um
 err1 = via_125xRv4_12_bad NOT (OR via_125xRv4_10_10a_10b_10c_10d_11_good via_125xRv4_13_13a_good) //125xRv.EN.12~13: the width conditions are covered by each other
 err1 NOT INSIDE SealR_NOT_BULK
}
 
//;beginning of the 125xRVn.EN.13a derivations
met_125xRv4_13a = (M5 WITH WIDTH > 0.08) WITH WIDTH >= 0.12
via_125xRv4_13a = (RV4 INTERACT met_125xRv4_13a) NOT INTERACT 125xRv_array4
via_125xRv4_13a_bad = RECTANGLE ENCLOSURE via_125xRv4_13a M5 ABUT<90 SINGULAR 
GOOD 0.02 0.029 OPPOSITE 0.02 0.029 OPPOSITE
via_125xRv4_13a_good = via_125xRv4_13a NOT via_125xRv4_13a_bad
//;end of the 125xRVn.EN.13a derivations
 
//;beginning of the 125xRVn.EN.13 derivations
met_125xRv4_13 = (M5 WITH WIDTH > 0.08) WITH WIDTH >= 0.12
via_125xRv4_13_TMP = (RV4 INTERACT met_125xRv4_13) NOT INTERACT 125xRv_array4
via_125xRv4_13 = via_125xRv4_13_TMP NOT (OR via_125xRv4_10_10a_10b_10c_10d_11_good via_125xRv4_12_good)
via_125xRv4_13_L_edges = LENGTH via_125xRv4_13 == 0.10
via_125xRv4_13_W_edges = LENGTH via_125xRv4_13 == 0.04
via_125xRv4_13_x = ENC [via_125xRv4_13_L_edges] M5 < 0.039 ABUT<90 OPPOSITE
via_125xRv4_13_y = ENC [via_125xRv4_13_W_edges] M5 < 0.01 ABUT<90 OPPOSITE
via_125xRv4_13_bad = via_125xRv4_13 WITH EDGE (OR EDGE via_125xRv4_13_x via_125xRv4_13_y)
via_125xRv4_13_good = via_125xRv4_13 NOT via_125xRv4_13_bad
via_125xRv4_13_13a_good = OR via_125xRv4_13_good via_125xRv4_13a_good
//;end of the 125xRVn.EN.13 derivations
 
125xRv4_EN_13a {
@ 1.25xRVn enclosure by 1.25xMn+1 (width >= 0.12um) for two opposite sides with the other two sides >= 0.02um (except rectangle 1.25xVn array) >= 0.029um
 err1 = via_125xRv4_13a_bad NOT (OR via_125xRv4_10_10a_10b_10c_10d_11_good via_125xRv4_12_good via_125xRv4_13_good) //125xRv.EN.13 already covered by 125xRv.EN.12
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xRv4_EN_13 {
@ 1.25xRVn short side enclosed by 1.25xMn+1, 1.25xMn+1 (width >= 0.12um) with long sides enclosure >= 0.039um (except rectangular 1.25xVn array) >= 0.01um
 err1 = via_125xRv4_13_bad NOT (OR via_125xRv4_10_10a_10b_10c_10d_11_good via_125xRv4_12_good via_125xRv4_13a_good) //125xRv.EN.12~13: the width conditions are covered by each other
 err1 NOT INSIDE SealR_NOT_BULK
}
 
//;beginning of the 125xRVn.EN.14a derivations
met_125xRv4_14 = COPY M5
via_125xRv4_14_TMP = (RV4 INTERACT met_125xRv4_14) INTERACT 125xRv_array4
via_125xRv4_14 = via_125xRv4_14_TMP NOT (OR via_125xRv4_10_10a_10b_10c_10d_11_good via_125xRv4_12_good via_125xRv4_13_13a_good)
via_125xRv4_14_bad = RECTANGLE ENCLOSURE via_125xRv4_14 M5 ABUT<90 SINGULAR 
GOOD 0.01 0.02 OPPOSITE 0.01 0.02 OPPOSITE
via_125xRv4_14_good = via_125xRv4_14 NOT via_125xRv4_14_bad
//;end of the 125xRVn.EN.14 derivations
 
125xRv4_EN_14 {
@ 1.25xRVn array enclosed by 1.25xMn+1 for two opposite sides with the other two sides (rectangular 1.25xVn array edge length = 0.1um) >= 0.02um
@ Definition of rectangular 1.25xVn array:
@ 1.25xVn long side space = 0.08um (PRL = 0.10um) >= 0.01um
 err1 = copy via_125xRv4_14_bad
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xRv4_EN_15 {
@ 1.25xRVn enclosure by 1.25xMn+1 edge (between two consecutive 90-270 degree corners, length < 0.16um), when PRL > 0. >= 0.029um
 chk_edge = CONVEX EDGE M5 ANGLE1 == 90 ANGLE2 == 270 WITH LENGTH < 0.16
 err1_TMP = chk_edge TOUCH EDGE (EXT chk_edge M5_convex_270_90_edges < 0.005 ABUT==90 INTERSECTING ONLY REGION)
 err1 = ENC RV4 err1_TMP < 0.029 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xRv4_EN_16 {
@ 1.25xRVn enclosure by 1.25xMn+1 for two opposite sides (PRL > 0) with the other side enclosure < 0.04um (corresponding edge length < 0.16um between two consecutive 90-270 degree corners) >= 0.04um
 correspond_EDG = CONVEX EDGE M5 ANGLE1 == 90 ANGLE2 == 270 WITH LENGTH < 0.16
 correspond_ENC = ENC [RV4] correspond_EDG < 0.04 ABUT<90 OPPOSITE EXTENDED 0.001
 correspond_VIA_ENC_EDGE = RV4 TOUCH EDGE correspond_ENC
 correspond_VIA_EDG_CORN = INT [RV4] correspond_VIA_ENC_EDGE < 0.001 ABUT==90 INTERSECTING ONLY
 correspond_VIA_EDG = RV4 TOUCH EDGE correspond_VIA_EDG_CORN
 err1_RAW = ENC [correspond_VIA_EDG] M5 < 0.040 ABUT<90 OPPOSITE EXTENDED 0.001
 err1_TMP = INT correspond_VIA_ENC_EDGE (correspond_VIA_EDG TOUCH EDGE err1_RAW) < 0.005 ABUT==90 INTERSECTING ONLY REGION
 err1 = EXPAND EDGE (RV4 TOUCH EDGE err1_TMP) INSIDE BY 0.001
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xRv4_R_1 {
@ Single 1.25xRVn is not allowed in "H-shape" 1.25xMn+1, when:
@ 1. The 1.25xMn+1 has "H-shape" interacting with two metal holes: both two metal holes length <= 4.5um and two metal hole area <= 4.05um2
@ 2. The 1.25xRVn overlaps on the center metal bar of this "H-shape" 1.25xMn+1
@ 3. The center metal bar length <= 0.9um and the metal bar width <= 0.162um
@ DRC doesn't check when one or more square 1.25xRVn is also on H-shape 1.25xMn+1 region
 hole_area_meet = AREA (HOLES M5 INNER) <= 4.05
 hole_area_meet_len = (hole_area_meet WITH EDGE (LENGTH hole_area_meet <= 0.9)) NOT WITH EDGE (LENGTH hole_area_meet > 4.5)
 hole_area_real = (hole_area_meet_len NOT ENCLOSE RECTANGLE 0.9+GLOBAL_TOLERANCE 4.5) NOT ENCLOSE RECTANGLE 0.9 4.5+GLOBAL_TOLERANCE
 hole_bars_len = M5 COIN EDGE hole_area_real
 // 
 hole_bars = INT hole_bars_len <= 0.162 ABUT<90 OPPOSITE REGION EXCLUDE SHIELDED
 hole_bars_real = hole_bars WITH EDGE (LENGTH hole_bars_len <= 0.9)
 hole_bars_vias_rect = RV4 INTERACT ((hole_bars_real INTERACT hole_area_real == 2) NOT ENCLOSE V4N >= 2)
 err1 = hole_bars_real INTERACT hole_bars_vias_rect == 1
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xRv4_R_2 {
@ Redundant via requirement must be obeyed by one of following conditions of via numbers and space for 1.25xMy/1.25xMn, 1.25xMn+1 connection (one of 1.25xMy/1.25xMn or 1.25xMn+1 have width and length >= 0.164um, two square vias are equal to one rectangular via for below conditions) (Except VIA bar)
@ 1) At least one rectangular 1.25xVn
@ 2) At least two square 1.25xVn with space <= 0.091um
@ 3) At least four square 1.25xVn with space <= 0.59um
 X1a = WITH WIDTH M4 > 0.164-GLOBAL_TOLERANCE <= 0.398-GLOBAL_TOLERANCE
 X1b = WITH WIDTH M5 > 0.164-GLOBAL_TOLERANCE <= 0.398-GLOBAL_TOLERANCE
 Y1a = WITH WIDTH M4 > 0.398-GLOBAL_TOLERANCE
 Y1b = WITH WIDTH M5 > 0.398-GLOBAL_TOLERANCE
 WIDE_1 = (X1a AND M5) ENCLOSE V4
 WIDE_2 = (M4 AND X1b) ENCLOSE V4
 WIDE_3 = (Y1a AND M5) ENCLOSE V4
 WIDE_4 = (M4 AND Y1b) ENCLOSE V4
 WIDE_all_raw = (WIDE_1 OR WIDE_2) NOT (WIDE_3 OR WIDE_4)
 WIDE_all = (M4 AND M5) NOT OUTSIDE WIDE_all_raw
 // 
 // condition 1
 Y1_good = WIDE_all_raw AND RV4
 // condition 2
 Y2_wide_all = WIDE_all_raw NOT INTERACT Y1_good
 Y2_wide = (WIDE_all INTERACT Y2_wide_all) INTERACT V4_SR >= 2
 Y2_comb_step = SIZE V4_SR BY 0.091/2 INSIDE OF Y2_wide STEP 0.030
 Y2_good_step = OR (Y2_comb_step INTERACT V4N >= 2) (Y2_comb_step INTERACT RV4)
 Y2_good = WIDE_all_raw AND Y2_good_step
 // 
 // condition 3
 Y3_wide_all = WIDE_all_raw NOT INTERACT (OR Y1_good Y2_good)
 Y3_wide = (WIDE_all INTERACT Y3_wide_all) INTERACT V4_SR >= 2 // rectangle array 0.59/2=0.295
 Y3_vias_input = V4_SR AND Y3_wide
 Y3_wide_chk_1 = Y3_wide INTERACT Y3_wide_all
 Y3_comb_step1 = SIZE Y3_vias_input BY 0.04 INSIDE OF Y3_wide_chk_1 STEP 0.04 // via minimum space = 0.075
 Y3_good_step1 = OR (Y3_comb_step1 INTERACT V4N >= 4) (Y3_comb_step1 INTERACT RV4) // step1: 0.050
 // 
 Y3_wide_chk_2 = Y3_wide_chk_1 INTERACT (WIDE_all_raw NOT INTERACT Y3_good_step1)
 Y3_comb_step2 = SIZE Y3_comb_step1 BY 0.04 INSIDE OF Y3_wide_chk_2 STEP 0.04
 Y3_good_step2 = OR (Y3_comb_step2 INTERACT V4N >= 4) (Y3_comb_step2 INTERACT RV4) // step2: 0.04
 // 
 Y3_wide_chk_3 = Y3_wide_chk_2 INTERACT (WIDE_all_raw NOT INTERACT Y3_good_step2)
 Y3_comb_step3 = SIZE Y3_comb_step2 BY 0.04 INSIDE OF Y3_wide_chk_3 STEP 0.04
 Y3_good_step3 = OR (Y3_comb_step3 INTERACT V4N >= 4) (Y3_comb_step3 INTERACT RV4) // step3: 0.04
 // 
 Y3_wide_chk_4 = Y3_wide_chk_3 INTERACT (WIDE_all_raw NOT INTERACT Y3_good_step3)
 Y3_comb_step4 = SIZE Y3_comb_step3 BY 0.04 INSIDE OF Y3_wide_chk_4 STEP 0.04
 Y3_good_step4 = OR (Y3_comb_step4 INTERACT V4N >= 4) (Y3_comb_step4 INTERACT RV4) // step4: 0.04
 // 
 Y3_wide_chk_5 = Y3_wide_chk_4 INTERACT (WIDE_all_raw NOT INTERACT Y3_good_step4)
 Y3_comb_step5 = SIZE Y3_comb_step4 BY 0.04 INSIDE OF Y3_wide_chk_5 STEP 0.04
 Y3_good_step5 = OR (Y3_comb_step5 INTERACT V4N >= 4) (Y3_comb_step5 INTERACT RV4) // step5: 0.04
 // 
 Y3_wide_chk_6 = Y3_wide_chk_5 INTERACT (WIDE_all_raw NOT INTERACT Y3_good_step5)
 Y3_comb_step6 = SIZE Y3_comb_step5 BY 0.04 INSIDE OF Y3_wide_chk_6 STEP 0.04
 Y3_good_step6 = OR (Y3_comb_step6 INTERACT V4N >= 4) (Y3_comb_step6 INTERACT RV4) // step6: 0.04
 // 
 Y3_wide_chk_7 = Y3_wide_chk_6 INTERACT (WIDE_all_raw NOT INTERACT Y3_good_step6)
 Y3_comb_step7 = SIZE Y3_comb_step6 BY 0.04 INSIDE OF Y3_wide_chk_7 STEP 0.04
 Y3_good_step7 = OR (Y3_comb_step7 INTERACT V4N >= 4) (Y3_comb_step7 INTERACT RV4) // step7: 0.04
 // 
 Y3_wide_chk_8 = Y3_wide_chk_7 INTERACT (WIDE_all_raw NOT INTERACT Y3_good_step7)
 Y3_comb_step8 = SIZE Y3_comb_step7 BY 0.015 INSIDE OF Y3_wide_chk_8 STEP 0.015
 Y3_good_step8 = OR (Y3_comb_step8 INTERACT V4N >= 4) (Y3_comb_step8 INTERACT RV4) // step8: 0.295-0.04*7=0.015
 Y3_good = WIDE_all_raw AND (OR Y3_good_step1 Y3_good_step2 Y3_good_step3 Y3_good_step4 Y3_good_step5 Y3_good_step6 Y3_good_step7 Y3_good_step8)
 // 
 err1 = (WIDE_all_raw OUTSIDE (OR Y1_good Y2_good Y3_good)) INTERACT V4
 err1 NOT INTERACT 125xv4_BAR
}
 
125xRv4_R_3 {
@ Redundant via requirement must be obeyed by one of following conditions of 1.25xVn numbers and space for 1.25xMy/1.25xMn and 1.25xMn+1 connection (one of 1.25xMy/1.25xMn or 1.25xMn+1 have width and length >= 0.398um, two square vias are equal to one rectangular via for below conditions), except VIA bar, OCCD region
@ 1) At least 4 square 1.25xVn with space <= 0.091um
@ 2) At least 2 square 1.25xVn and 1 rectangular 1.25xVn with space <= 0.118um
@ 3) At least 9 square 1.25xVn with space <= 0.77um
@ For condition 2) and 3) 2 square 1.25xVn can be replaced by 1 rectangular 1.25xVn
 X1a = WITH WIDTH M4 > 0.398-GLOBAL_TOLERANCE
 X1b = WITH WIDTH M5 > 0.398-GLOBAL_TOLERANCE
 WIDE_1 = (X1a AND M5) ENCLOSE V4
 WIDE_2 = (M4 AND X1b) ENCLOSE V4
 WIDE_all_raw = WIDE_1 OR WIDE_2
 WIDE_all = (M4 AND M5) NOT OUTSIDE WIDE_all_raw
 // 
 // condition 1
 Y2_wide = WIDE_all INTERACT V4N >= 4
 Y2_vias_input = V4N AND Y2_wide
 Y2_wide_chk_1 = COPY Y2_wide // rectangle array 0.09/2=0.0455
 Y2_comb_step1 = SIZE Y2_vias_input BY 0.030 INSIDE OF Y2_wide_chk_1 STEP 0.030 // step1: 0.030, via minimum space = 0.056
 Y2_good_step1 = Y2_comb_step1 INTERACT V4N >= 4
 // 
 Y2_wide_chk_2 = Y2_wide_chk_1 INTERACT (WIDE_all_raw NOT INTERACT Y2_good_step1)
 Y2_comb_step2 = SIZE Y2_comb_step1 BY 0.0155 INSIDE OF Y2_wide_chk_2 STEP 0.015 // step2: 0.0155
 Y2_good_step2 = Y2_comb_step2 INTERACT V4N >= 4
 Y2_good = WIDE_all_raw AND (OR Y2_good_step1 Y2_good_step2)
 // 
 // condition 2
 Y1_wide_all = WIDE_all_raw NOT INTERACT Y2_good // rectangle array 0.118/2=0.059
 Y1_wide = (WIDE_all INTERACT Y1_wide_all) INTERACT V4 >= 2
 Y1_vias_input = V4 AND Y1_wide
 Y1_wide_chk_1 = Y1_wide INTERACT Y1_wide_all
 Y1_comb_step1 = SIZE Y1_vias_input BY 0.030 INSIDE OF Y1_wide_chk_1 STEP 0.030 // step1: 0.030, via minimum space = 0.100
 Y1_good_step1_a = Y1_comb_step1 INTERACT RV4 >= 2
 Y1_good_step1_b = (Y1_comb_step1 INTERACT V4N >= 2) INTERACT RV4 >= 1
 Y1_good_step1 = OR Y1_good_step1_a Y1_good_step1_b
 // 
 Y1_wide_chk_2 = Y1_wide_chk_1 INTERACT (WIDE_all_raw NOT INTERACT Y1_good_step1)
 Y1_comb_step2 = SIZE Y1_comb_step1 BY 0.029 INSIDE OF Y1_wide_chk_2 STEP 0.025 // step2: 0.059-0.030=0.029
 Y1_good_step2_a = Y1_comb_step2 INTERACT RV4 >= 2
 Y1_good_step2_b = (Y1_comb_step2 INTERACT V4N >= 2) INTERACT RV4 >= 1
 Y1_good_step2 = OR Y1_good_step2_a Y1_good_step2_b
 Y1_good = WIDE_all_raw AND (OR Y1_good_step1 Y1_good_step2)
 // 
 // condition 3
 Y3_wide_all = WIDE_all_raw NOT INTERACT (OR Y2_good Y1_good)
 Y3_wide = (WIDE_all INTERACT Y3_wide_all) INTERACT V4 >= 5
 Y3_vias_input = V4N AND Y3_wide
 Y3_wide_chk_1 = Y3_wide INTERACT Y3_wide_all // rectangle array 0.77/2=0.385
 Y3_comb_step1 = SIZE Y3_vias_input BY 0.070 INSIDE OF Y3_wide_chk_1 STEP 0.035 // step1: 0.070, via minimum space = 0.056
 Y3_good_step1_a = Y3_comb_step1 INTERACT V4N >= 9
 Y3_good_step1_b = (Y3_comb_step1 INTERACT V4N >= 7) INTERACT RV4 >= 1
 Y3_good_step1_c = (Y3_comb_step1 INTERACT V4N >= 5) INTERACT RV4 >= 2
 Y3_good_step1_d = (Y3_comb_step1 INTERACT V4N >= 3) INTERACT RV4 >= 3
 Y3_good_step1_e = (Y3_comb_step1 INTERACT V4N >= 1) INTERACT RV4 >= 4
 Y3_good_step1_f = Y3_comb_step1 INTERACT RV4 >= 5
 Y3_good_step1 = OR Y3_good_step1_a Y3_good_step1_b Y3_good_step1_c Y3_good_step1_d Y3_good_step1_e Y3_good_step1_f
 // 
 Y3_wide_chk_2 = Y3_wide_chk_1 INTERACT (WIDE_all_raw NOT INTERACT Y3_good_step1)
 Y3_comb_step2 = SIZE Y3_comb_step1 BY 0.035 INSIDE OF Y3_wide_chk_2 STEP 0.035 // step2: 0.035
 Y3_good_step2_a = Y3_comb_step2 INTERACT V4N >= 9
 Y3_good_step2_b = (Y3_comb_step2 INTERACT V4N >= 7) INTERACT RV4 >= 1
 Y3_good_step2_c = (Y3_comb_step2 INTERACT V4N >= 5) INTERACT RV4 >= 2
 Y3_good_step2_d = (Y3_comb_step2 INTERACT V4N >= 3) INTERACT RV4 >= 3
 Y3_good_step2_e = (Y3_comb_step2 INTERACT V4N >= 1) INTERACT RV4 >= 4
 Y3_good_step2_f = Y3_comb_step2 INTERACT RV4 >= 5
 Y3_good_step2 = OR Y3_good_step2_a Y3_good_step2_b Y3_good_step2_c Y3_good_step2_d Y3_good_step2_e Y3_good_step2_f
 // 
 Y3_wide_chk_3 = Y3_wide_chk_2 INTERACT (WIDE_all_raw NOT INTERACT Y3_good_step2)
 Y3_comb_step3 = SIZE Y3_comb_step2 BY 0.035 INSIDE OF Y3_wide_chk_3 STEP 0.035 // step3: 0.035
 Y3_good_step3_a = Y3_comb_step3 INTERACT V4N >= 9
 Y3_good_step3_b = (Y3_comb_step3 INTERACT V4N >= 7) INTERACT RV4 >= 1
 Y3_good_step3_c = (Y3_comb_step3 INTERACT V4N >= 5) INTERACT RV4 >= 2
 Y3_good_step3_d = (Y3_comb_step3 INTERACT V4N >= 3) INTERACT RV4 >= 3
 Y3_good_step3_e = (Y3_comb_step3 INTERACT V4N >= 1) INTERACT RV4 >= 4
 Y3_good_step3_f = Y3_comb_step3 INTERACT RV4 >= 5
 Y3_good_step3 = OR Y3_good_step3_a Y3_good_step3_b Y3_good_step3_c Y3_good_step3_d Y3_good_step3_e Y3_good_step3_f
 // 
 Y3_wide_chk_4 = Y3_wide_chk_3 INTERACT (WIDE_all_raw NOT INTERACT Y3_good_step3)
 Y3_comb_step4 = SIZE Y3_comb_step3 BY 0.035 INSIDE OF Y3_wide_chk_4 STEP 0.035 // step4: 0.035
 Y3_good_step4_a = Y3_comb_step4 INTERACT V4N >= 9
 Y3_good_step4_b = (Y3_comb_step4 INTERACT V4N >= 7) INTERACT RV4 >= 1
 Y3_good_step4_c = (Y3_comb_step4 INTERACT V4N >= 5) INTERACT RV4 >= 2
 Y3_good_step4_d = (Y3_comb_step4 INTERACT V4N >= 3) INTERACT RV4 >= 3
 Y3_good_step4_e = (Y3_comb_step4 INTERACT V4N >= 1) INTERACT RV4 >= 4
 Y3_good_step4_f = Y3_comb_step4 INTERACT RV4 >= 5
 Y3_good_step4 = OR Y3_good_step4_a Y3_good_step4_b Y3_good_step4_c Y3_good_step4_d Y3_good_step4_e Y3_good_step4_f
 // 
 Y3_wide_chk_5 = Y3_wide_chk_4 INTERACT (WIDE_all_raw NOT INTERACT Y3_good_step4)
 Y3_comb_step5 = SIZE Y3_comb_step4 BY 0.035 INSIDE OF Y3_wide_chk_5 STEP 0.035 // step5: 0.035
 Y3_good_step5_a = Y3_comb_step5 INTERACT V4N >= 9
 Y3_good_step5_b = (Y3_comb_step5 INTERACT V4N >= 7) INTERACT RV4 >= 1
 Y3_good_step5_c = (Y3_comb_step5 INTERACT V4N >= 5) INTERACT RV4 >= 2
 Y3_good_step5_d = (Y3_comb_step5 INTERACT V4N >= 3) INTERACT RV4 >= 3
 Y3_good_step5_e = (Y3_comb_step5 INTERACT V4N >= 1) INTERACT RV4 >= 4
 Y3_good_step5_f = Y3_comb_step5 INTERACT RV4 >= 5
 Y3_good_step5 = OR Y3_good_step5_a Y3_good_step5_b Y3_good_step5_c Y3_good_step5_d Y3_good_step5_e Y3_good_step5_f
 // 
 Y3_wide_chk_6 = Y3_wide_chk_5 INTERACT (WIDE_all_raw NOT INTERACT Y3_good_step5)
 Y3_comb_step6 = SIZE Y3_comb_step5 BY 0.035 INSIDE OF Y3_wide_chk_6 STEP 0.035 // step6: 0.035
 Y3_good_step6_a = Y3_comb_step6 INTERACT V4N >= 9
 Y3_good_step6_b = (Y3_comb_step6 INTERACT V4N >= 7) INTERACT RV4 >= 1
 Y3_good_step6_c = (Y3_comb_step6 INTERACT V4N >= 5) INTERACT RV4 >= 2
 Y3_good_step6_d = (Y3_comb_step6 INTERACT V4N >= 3) INTERACT RV4 >= 3
 Y3_good_step6_e = (Y3_comb_step6 INTERACT V4N >= 1) INTERACT RV4 >= 4
 Y3_good_step6_f = Y3_comb_step6 INTERACT RV4 >= 5
 Y3_good_step6 = OR Y3_good_step6_a Y3_good_step6_b Y3_good_step6_c Y3_good_step6_d Y3_good_step6_e Y3_good_step6_f
 // 
 Y3_wide_chk_7 = Y3_wide_chk_6 INTERACT (WIDE_all_raw NOT INTERACT Y3_good_step6)
 Y3_comb_step7 = SIZE Y3_comb_step6 BY 0.035 INSIDE OF Y3_wide_chk_7 STEP 0.035 // step7: 0.035
 Y3_good_step7_a = Y3_comb_step7 INTERACT V4N >= 9
 Y3_good_step7_b = (Y3_comb_step7 INTERACT V4N >= 7) INTERACT RV4 >= 1
 Y3_good_step7_c = (Y3_comb_step7 INTERACT V4N >= 5) INTERACT RV4 >= 2
 Y3_good_step7_d = (Y3_comb_step7 INTERACT V4N >= 3) INTERACT RV4 >= 3
 Y3_good_step7_e = (Y3_comb_step7 INTERACT V4N >= 1) INTERACT RV4 >= 4
 Y3_good_step7_f = Y3_comb_step7 INTERACT RV4 >= 5
 Y3_good_step7 = OR Y3_good_step7_a Y3_good_step7_b Y3_good_step7_c Y3_good_step7_d Y3_good_step7_e Y3_good_step7_f
 // 
 Y3_wide_chk_8 = Y3_wide_chk_7 INTERACT (WIDE_all_raw NOT INTERACT Y3_good_step7)
 Y3_comb_step8 = SIZE Y3_comb_step7 BY 0.035 INSIDE OF Y3_wide_chk_8 STEP 0.035 // step8: 0.035
 Y3_good_step8_a = Y3_comb_step8 INTERACT V4N >= 9
 Y3_good_step8_b = (Y3_comb_step8 INTERACT V4N >= 7) INTERACT RV4 >= 1
 Y3_good_step8_c = (Y3_comb_step8 INTERACT V4N >= 5) INTERACT RV4 >= 2
 Y3_good_step8_d = (Y3_comb_step8 INTERACT V4N >= 3) INTERACT RV4 >= 3
 Y3_good_step8_e = (Y3_comb_step8 INTERACT V4N >= 1) INTERACT RV4 >= 4
 Y3_good_step8_f = Y3_comb_step8 INTERACT RV4 >= 5
 Y3_good_step8 = OR Y3_good_step8_a Y3_good_step8_b Y3_good_step8_c Y3_good_step8_d Y3_good_step8_e Y3_good_step8_f
 // 
 Y3_wide_chk_9 = Y3_wide_chk_8 INTERACT (WIDE_all_raw NOT INTERACT Y3_good_step8)
 Y3_comb_step9 = SIZE Y3_comb_step8 BY 0.07 INSIDE OF Y3_wide_chk_9 STEP 0.035 // step9: 0.385-0.07-0.035*7=0.07
 Y3_good_step9_a = Y3_comb_step9 INTERACT V4N >= 9
 Y3_good_step9_b = (Y3_comb_step9 INTERACT V4N >= 7) INTERACT RV4 >= 1
 Y3_good_step9_c = (Y3_comb_step9 INTERACT V4N >= 5) INTERACT RV4 >= 2
 Y3_good_step9_d = (Y3_comb_step9 INTERACT V4N >= 3) INTERACT RV4 >= 3
 Y3_good_step9_e = (Y3_comb_step9 INTERACT V4N >= 1) INTERACT RV4 >= 4
 Y3_good_step9_f = Y3_comb_step9 INTERACT RV4 >= 5
 Y3_good_step9 = OR Y3_good_step9_a Y3_good_step9_b Y3_good_step9_c Y3_good_step9_d Y3_good_step9_e Y3_good_step9_f
 Y3_good = WIDE_all_raw AND (OR Y3_good_step1 Y3_good_step2 Y3_good_step3 Y3_good_step4 Y3_good_step5 Y3_good_step6 Y3_good_step7 Y3_good_step8 Y3_good_step9)
 // 
 err1 = (WIDE_all_raw OUTSIDE (OR Y1_good Y2_good Y3_good)) INTERACT V4
 (err1 NOT INTERACT 125xv4_BAR) NOT INSIDE OCCD
}
 
125xRv4_R_4_M4 {
@ There should be at least two square 1.25xVn or one rectangular 1.25xVn in the intersection area of bottom metal and upper metal, when either wide metal 1.25xMy/1.25xMn or 1.25xMn+1 length >= 0.162um and width >= 0.162um, the space between either via and wide metal <= 1.48um (S, S is the shortest running path length from Via to the wide metal). (except via bar)
@ DRC flags each intersecting area ({bottom metal AND upper metal}) with single square Via within the branch check region
 wide_M4 = (WITH WIDTH M4 > 0.162-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 0.162-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 0.162-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M4_real = wide_M4 NOT OUTSIDE ((SIZE wide_M4 BY 1.48+GLOBAL_TOLERANCE) INTERACT V4)
 all_down_and_up = (M4 INTERACT wide_M4) AND M5
 dis_down_arm_wide_all = SIZE wide_M4_real BY 1.48+GLOBAL_TOLERANCE INSIDE OF M4 STEP 0.025
 dis_down_and_up = dis_down_arm_wide_all AND all_down_and_up
 dis_down_and_up_arm = (dis_down_and_up NOT wide_M4) AND M4
 dis_down_arm = (dis_down_arm_wide_all NOT wide_M4) AND M4
 // 
 dis_down_arm_good_a = dis_down_and_up_arm INTERACT V4N >= 2
 dis_down_arm_good_b = dis_down_and_up_arm INTERACT RV4
 dis_down_arm_good = OR dis_down_arm_good_a dis_down_arm_good_b
 dis_down_arm_bad = (dis_down_and_up_arm NOT dis_down_arm_good) INTERACT (all_down_and_up INTERACT V4N == 1)
 // 
 dis_down_arm_err_stack = (dis_down_arm_bad AND dis_down_and_up_arm) INTERACT V4N
 dis_down_arm_err = dis_down_arm INTERACT dis_down_arm_err_stack
 err1_met_down = (dis_down_arm_err INTERACT (V4N NOT OUTSIDE dis_down_arm_err)) NOT INTERACT RV4
 // 
 wide_M5 = (WITH WIDTH M5 > 0.162-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 0.162-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 0.162-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M5_real = wide_M5 NOT OUTSIDE ((SIZE wide_M5 BY 1.48+GLOBAL_TOLERANCE) INTERACT V4)
 all_up_and_down = (M5 INTERACT wide_M5) AND M4
 dis_up_arm_wide_all = SIZE wide_M5_real BY 1.48+GLOBAL_TOLERANCE INSIDE OF M5 STEP 0.025
 dis_up_and_down = dis_up_arm_wide_all AND all_up_and_down
 dis_up_and_down_arm = (dis_up_and_down NOT wide_M5) AND M5
 dis_up_arm = (dis_up_arm_wide_all NOT wide_M5) AND M5
 // 
 dis_up_arm_good_a = dis_up_and_down_arm INTERACT V4N >= 2
 dis_up_arm_good_b = dis_up_and_down_arm INTERACT RV4
 dis_up_arm_good = OR dis_up_arm_good_a dis_up_arm_good_b
 dis_up_arm_bad = (dis_up_and_down_arm NOT dis_up_arm_good) INTERACT (all_up_and_down INTERACT V4N == 1)
 // 
 dis_up_arm_err_stack = (dis_up_arm_bad AND dis_up_and_down_arm) INTERACT V4N
 dis_up_arm_err = dis_up_arm INTERACT dis_up_arm_err_stack
 err2_met_up = (dis_up_arm_err INTERACT (V4N NOT OUTSIDE dis_up_arm_err)) NOT INTERACT RV4
 err1_met_down NOT INTERACT 125xv4_BAR
}
 
125xRv4_R_4_M5 {
@ There should be at least two square 1.25xVn or one rectangular 1.25xVn in the intersection area of bottom metal and upper metal, when either wide metal 1.25xMy/1.25xMn or 1.25xMn+1 length >= 0.162um and width >= 0.162um, the space between either via and wide metal <= 1.48um (S, S is the shortest running path length from Via to the wide metal). (except via bar)
@ DRC flags each intersecting area ({bottom metal AND upper metal}) with single square Via within the branch check region
 wide_M4 = (WITH WIDTH M4 > 0.162-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 0.162-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 0.162-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M4_real = wide_M4 NOT OUTSIDE ((SIZE wide_M4 BY 1.48+GLOBAL_TOLERANCE) INTERACT V4)
 all_down_and_up = (M4 INTERACT wide_M4) AND M5
 dis_down_arm_wide_all = SIZE wide_M4_real BY 1.48+GLOBAL_TOLERANCE INSIDE OF M4 STEP 0.025
 dis_down_and_up = dis_down_arm_wide_all AND all_down_and_up
 dis_down_and_up_arm = (dis_down_and_up NOT wide_M4) AND M4
 dis_down_arm = (dis_down_arm_wide_all NOT wide_M4) AND M4
 // 
 dis_down_arm_good_a = dis_down_and_up_arm INTERACT V4N >= 2
 dis_down_arm_good_b = dis_down_and_up_arm INTERACT RV4
 dis_down_arm_good = OR dis_down_arm_good_a dis_down_arm_good_b
 dis_down_arm_bad = (dis_down_and_up_arm NOT dis_down_arm_good) INTERACT (all_down_and_up INTERACT V4N == 1)
 // 
 dis_down_arm_err_stack = (dis_down_arm_bad AND dis_down_and_up_arm) INTERACT V4N
 dis_down_arm_err = dis_down_arm INTERACT dis_down_arm_err_stack
 err1_met_down = (dis_down_arm_err INTERACT (V4N NOT OUTSIDE dis_down_arm_err)) NOT INTERACT RV4
 // 
 wide_M5 = (WITH WIDTH M5 > 0.162-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 0.162-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 0.162-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M5_real = wide_M5 NOT OUTSIDE ((SIZE wide_M5 BY 1.48+GLOBAL_TOLERANCE) INTERACT V4)
 all_up_and_down = (M5 INTERACT wide_M5) AND M4
 dis_up_arm_wide_all = SIZE wide_M5_real BY 1.48+GLOBAL_TOLERANCE INSIDE OF M5 STEP 0.025
 dis_up_and_down = dis_up_arm_wide_all AND all_up_and_down
 dis_up_and_down_arm = (dis_up_and_down NOT wide_M5) AND M5
 dis_up_arm = (dis_up_arm_wide_all NOT wide_M5) AND M5
 // 
 dis_up_arm_good_a = dis_up_and_down_arm INTERACT V4N >= 2
 dis_up_arm_good_b = dis_up_and_down_arm INTERACT RV4
 dis_up_arm_good = OR dis_up_arm_good_a dis_up_arm_good_b
 dis_up_arm_bad = (dis_up_and_down_arm NOT dis_up_arm_good) INTERACT (all_up_and_down INTERACT V4N == 1)
 // 
 dis_up_arm_err_stack = (dis_up_arm_bad AND dis_up_and_down_arm) INTERACT V4N
 dis_up_arm_err = dis_up_arm INTERACT dis_up_arm_err_stack
 err2_met_up = (dis_up_arm_err INTERACT (V4N NOT OUTSIDE dis_up_arm_err)) NOT INTERACT RV4
 err2_met_up NOT INTERACT 125xv4_BAR
}
 
125xRv4_R_5_M4 {
@ There should be at least two square 1.25xVn or one rectangular 1.25xVn in the intersection area of bottom metal and upper metal, when either wide metal 1.25xMy/1.25xMn or 1.25xMn+1 length >= 0.91um and width >= 0.91um, the space between either via and wide metal <= 3.59um (S, S is the shortest running path length from Via to the wide metal). (except via bar)
@ DRC flags each intersecting area ({bottom metal AND upper metal}) with single square Via within the branch check region
 wide_M4 = (WITH WIDTH M4 > 0.91-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 0.91-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 0.91-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M4_real = wide_M4 NOT OUTSIDE ((SIZE wide_M4 BY 3.59+GLOBAL_TOLERANCE) INTERACT V4)
 all_down_and_up = (M4 INTERACT wide_M4) AND M5
 dis_down_arm_wide_all = SIZE wide_M4_real BY 3.59+GLOBAL_TOLERANCE INSIDE OF M4 STEP 0.025
 dis_down_and_up = dis_down_arm_wide_all AND all_down_and_up
 dis_down_and_up_arm = (dis_down_and_up NOT wide_M4) AND M4
 dis_down_arm = (dis_down_arm_wide_all NOT wide_M4) AND M4
 // 
 dis_down_arm_good_a = dis_down_and_up_arm INTERACT V4N >= 2
 dis_down_arm_good_b = dis_down_and_up_arm INTERACT RV4
 dis_down_arm_good = OR dis_down_arm_good_a dis_down_arm_good_b
 dis_down_arm_bad = (dis_down_and_up_arm NOT dis_down_arm_good) INTERACT (all_down_and_up INTERACT V4N == 1)
 // 
 dis_down_arm_err_stack = (dis_down_arm_bad AND dis_down_and_up_arm) INTERACT V4N
 dis_down_arm_err = dis_down_arm INTERACT dis_down_arm_err_stack
 err1_met_down = (dis_down_arm_err INTERACT (V4N NOT OUTSIDE dis_down_arm_err)) NOT INTERACT RV4
 // 
 wide_M5 = (WITH WIDTH M5 > 0.91-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 0.91-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 0.91-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M5_real = wide_M5 NOT OUTSIDE ((SIZE wide_M5 BY 3.59+GLOBAL_TOLERANCE) INTERACT V4)
 all_up_and_down = (M5 INTERACT wide_M5) AND M4
 dis_up_arm_wide_all = SIZE wide_M5_real BY 3.59+GLOBAL_TOLERANCE INSIDE OF M5 STEP 0.025
 dis_up_and_down = dis_up_arm_wide_all AND all_up_and_down
 dis_up_and_down_arm = (dis_up_and_down NOT wide_M5) AND M5
 dis_up_arm = (dis_up_arm_wide_all NOT wide_M5) AND M5
 // 
 dis_up_arm_good_a = dis_up_and_down_arm INTERACT V4N >= 2
 dis_up_arm_good_b = dis_up_and_down_arm INTERACT RV4
 dis_up_arm_good = OR dis_up_arm_good_a dis_up_arm_good_b
 dis_up_arm_bad = (dis_up_and_down_arm NOT dis_up_arm_good) INTERACT (all_up_and_down INTERACT V4N == 1)
 // 
 dis_up_arm_err_stack = (dis_up_arm_bad AND dis_up_and_down_arm) INTERACT V4N
 dis_up_arm_err = dis_up_arm INTERACT dis_up_arm_err_stack
 err2_met_up = (dis_up_arm_err INTERACT (V4N NOT OUTSIDE dis_up_arm_err)) NOT INTERACT RV4
 err1_met_down NOT INTERACT 125xv4_BAR
}
 
125xRv4_R_5_M5 {
@ There should be at least two square 1.25xVn or one rectangular 1.25xVn in the intersection area of bottom metal and upper metal, when either wide metal 1.25xMy/1.25xMn or 1.25xMn+1 length >= 0.91um and width >= 0.91um, the space between either via and wide metal <= 3.59um (S, S is the shortest running path length from Via to the wide metal). (except via bar)
@ DRC flags each intersecting area ({bottom metal AND upper metal}) with single square Via within the branch check region
 wide_M4 = (WITH WIDTH M4 > 0.91-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 0.91-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 0.91-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M4_real = wide_M4 NOT OUTSIDE ((SIZE wide_M4 BY 3.59+GLOBAL_TOLERANCE) INTERACT V4)
 all_down_and_up = (M4 INTERACT wide_M4) AND M5
 dis_down_arm_wide_all = SIZE wide_M4_real BY 3.59+GLOBAL_TOLERANCE INSIDE OF M4 STEP 0.025
 dis_down_and_up = dis_down_arm_wide_all AND all_down_and_up
 dis_down_and_up_arm = (dis_down_and_up NOT wide_M4) AND M4
 dis_down_arm = (dis_down_arm_wide_all NOT wide_M4) AND M4
 // 
 dis_down_arm_good_a = dis_down_and_up_arm INTERACT V4N >= 2
 dis_down_arm_good_b = dis_down_and_up_arm INTERACT RV4
 dis_down_arm_good = OR dis_down_arm_good_a dis_down_arm_good_b
 dis_down_arm_bad = (dis_down_and_up_arm NOT dis_down_arm_good) INTERACT (all_down_and_up INTERACT V4N == 1)
 // 
 dis_down_arm_err_stack = (dis_down_arm_bad AND dis_down_and_up_arm) INTERACT V4N
 dis_down_arm_err = dis_down_arm INTERACT dis_down_arm_err_stack
 err1_met_down = (dis_down_arm_err INTERACT (V4N NOT OUTSIDE dis_down_arm_err)) NOT INTERACT RV4
 // 
 wide_M5 = (WITH WIDTH M5 > 0.91-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 0.91-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 0.91-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M5_real = wide_M5 NOT OUTSIDE ((SIZE wide_M5 BY 3.59+GLOBAL_TOLERANCE) INTERACT V4)
 all_up_and_down = (M5 INTERACT wide_M5) AND M4
 dis_up_arm_wide_all = SIZE wide_M5_real BY 3.59+GLOBAL_TOLERANCE INSIDE OF M5 STEP 0.025
 dis_up_and_down = dis_up_arm_wide_all AND all_up_and_down
 dis_up_and_down_arm = (dis_up_and_down NOT wide_M5) AND M5
 dis_up_arm = (dis_up_arm_wide_all NOT wide_M5) AND M5
 // 
 dis_up_arm_good_a = dis_up_and_down_arm INTERACT V4N >= 2
 dis_up_arm_good_b = dis_up_and_down_arm INTERACT RV4
 dis_up_arm_good = OR dis_up_arm_good_a dis_up_arm_good_b
 dis_up_arm_bad = (dis_up_and_down_arm NOT dis_up_arm_good) INTERACT (all_up_and_down INTERACT V4N == 1)
 // 
 dis_up_arm_err_stack = (dis_up_arm_bad AND dis_up_and_down_arm) INTERACT V4N
 dis_up_arm_err = dis_up_arm INTERACT dis_up_arm_err_stack
 err2_met_up = (dis_up_arm_err INTERACT (V4N NOT OUTSIDE dis_up_arm_err)) NOT INTERACT RV4
 err2_met_up NOT INTERACT 125xv4_BAR
}
 
125xRv4_R_6_M4 {
@ There should be at least two square 1.25xVn or one rectangular 1.25xVn in the intersection area of bottom metal and upper metal, when either wide metal 1.25xMy/1.25xMn or 1.25xMn+1 length >= 1.36um and width >= 1.36um, the space between either via and wide metal <= 9um (S, S is the shortest running path length from Via to the wide metal). (except via bar)
@ DRC flags each intersecting area ({bottom metal AND upper metal}) with single square Via within the branch check region
 wide_M4 = (WITH WIDTH M4 > 1.36-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 1.36-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 1.36-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M4_real = wide_M4 NOT OUTSIDE ((SIZE wide_M4 BY 9+GLOBAL_TOLERANCE) INTERACT V4)
 all_down_and_up = (M4 INTERACT wide_M4) AND M5
 dis_down_arm_wide_all = SIZE wide_M4_real BY 9+GLOBAL_TOLERANCE INSIDE OF M4 STEP 0.025
 dis_down_and_up = dis_down_arm_wide_all AND all_down_and_up
 dis_down_and_up_arm = (dis_down_and_up NOT wide_M4) AND M4
 dis_down_arm = (dis_down_arm_wide_all NOT wide_M4) AND M4
 // 
 dis_down_arm_good_a = dis_down_and_up_arm INTERACT V4N >= 2
 dis_down_arm_good_b = dis_down_and_up_arm INTERACT RV4
 dis_down_arm_good = OR dis_down_arm_good_a dis_down_arm_good_b
 dis_down_arm_bad = (dis_down_and_up_arm NOT dis_down_arm_good) INTERACT (all_down_and_up INTERACT V4N == 1)
 // 
 dis_down_arm_err_stack = (dis_down_arm_bad AND dis_down_and_up_arm) INTERACT V4N
 dis_down_arm_err = dis_down_arm INTERACT dis_down_arm_err_stack
 err1_met_down = (dis_down_arm_err INTERACT (V4N NOT OUTSIDE dis_down_arm_err)) NOT INTERACT RV4
 // 
 wide_M5 = (WITH WIDTH M5 > 1.36-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 1.36-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 1.36-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M5_real = wide_M5 NOT OUTSIDE ((SIZE wide_M5 BY 9+GLOBAL_TOLERANCE) INTERACT V4)
 all_up_and_down = (M5 INTERACT wide_M5) AND M4
 dis_up_arm_wide_all = SIZE wide_M5_real BY 9+GLOBAL_TOLERANCE INSIDE OF M5 STEP 0.025
 dis_up_and_down = dis_up_arm_wide_all AND all_up_and_down
 dis_up_and_down_arm = (dis_up_and_down NOT wide_M5) AND M5
 dis_up_arm = (dis_up_arm_wide_all NOT wide_M5) AND M5
 // 
 dis_up_arm_good_a = dis_up_and_down_arm INTERACT V4N >= 2
 dis_up_arm_good_b = dis_up_and_down_arm INTERACT RV4
 dis_up_arm_good = OR dis_up_arm_good_a dis_up_arm_good_b
 dis_up_arm_bad = (dis_up_and_down_arm NOT dis_up_arm_good) INTERACT (all_up_and_down INTERACT V4N == 1)
 // 
 dis_up_arm_err_stack = (dis_up_arm_bad AND dis_up_and_down_arm) INTERACT V4N
 dis_up_arm_err = dis_up_arm INTERACT dis_up_arm_err_stack
 err2_met_up = (dis_up_arm_err INTERACT (V4N NOT OUTSIDE dis_up_arm_err)) NOT INTERACT RV4
 err1_met_down NOT INTERACT 125xv4_BAR
}
 
125xRv4_R_6_M5 {
@ There should be at least two square 1.25xVn or one rectangular 1.25xVn in the intersection area of bottom metal and upper metal, when either wide metal 1.25xMy/1.25xMn or 1.25xMn+1 length >= 1.36um and width >= 1.36um, the space between either via and wide metal <= 9um (S, S is the shortest running path length from Via to the wide metal). (except via bar)
@ DRC flags each intersecting area ({bottom metal AND upper metal}) with single square Via within the branch check region
 wide_M4 = (WITH WIDTH M4 > 1.36-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 1.36-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 1.36-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M4_real = wide_M4 NOT OUTSIDE ((SIZE wide_M4 BY 9+GLOBAL_TOLERANCE) INTERACT V4)
 all_down_and_up = (M4 INTERACT wide_M4) AND M5
 dis_down_arm_wide_all = SIZE wide_M4_real BY 9+GLOBAL_TOLERANCE INSIDE OF M4 STEP 0.025
 dis_down_and_up = dis_down_arm_wide_all AND all_down_and_up
 dis_down_and_up_arm = (dis_down_and_up NOT wide_M4) AND M4
 dis_down_arm = (dis_down_arm_wide_all NOT wide_M4) AND M4
 // 
 dis_down_arm_good_a = dis_down_and_up_arm INTERACT V4N >= 2
 dis_down_arm_good_b = dis_down_and_up_arm INTERACT RV4
 dis_down_arm_good = OR dis_down_arm_good_a dis_down_arm_good_b
 dis_down_arm_bad = (dis_down_and_up_arm NOT dis_down_arm_good) INTERACT (all_down_and_up INTERACT V4N == 1)
 // 
 dis_down_arm_err_stack = (dis_down_arm_bad AND dis_down_and_up_arm) INTERACT V4N
 dis_down_arm_err = dis_down_arm INTERACT dis_down_arm_err_stack
 err1_met_down = (dis_down_arm_err INTERACT (V4N NOT OUTSIDE dis_down_arm_err)) NOT INTERACT RV4
 // 
 wide_M5 = (WITH WIDTH M5 > 1.36-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 1.36-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 1.36-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M5_real = wide_M5 NOT OUTSIDE ((SIZE wide_M5 BY 9+GLOBAL_TOLERANCE) INTERACT V4)
 all_up_and_down = (M5 INTERACT wide_M5) AND M4
 dis_up_arm_wide_all = SIZE wide_M5_real BY 9+GLOBAL_TOLERANCE INSIDE OF M5 STEP 0.025
 dis_up_and_down = dis_up_arm_wide_all AND all_up_and_down
 dis_up_and_down_arm = (dis_up_and_down NOT wide_M5) AND M5
 dis_up_arm = (dis_up_arm_wide_all NOT wide_M5) AND M5
 // 
 dis_up_arm_good_a = dis_up_and_down_arm INTERACT V4N >= 2
 dis_up_arm_good_b = dis_up_and_down_arm INTERACT RV4
 dis_up_arm_good = OR dis_up_arm_good_a dis_up_arm_good_b
 dis_up_arm_bad = (dis_up_and_down_arm NOT dis_up_arm_good) INTERACT (all_up_and_down INTERACT V4N == 1)
 // 
 dis_up_arm_err_stack = (dis_up_arm_bad AND dis_up_and_down_arm) INTERACT V4N
 dis_up_arm_err = dis_up_arm INTERACT dis_up_arm_err_stack
 err2_met_up = (dis_up_arm_err INTERACT (V4N NOT OUTSIDE dis_up_arm_err)) NOT INTERACT RV4
 err2_met_up NOT INTERACT 125xv4_BAR
}
 
125xRv4_R_7 {
@ 45-degree 1.25xRVn is not allowed
 err1 = ANGLE (V4 NOT 125xv4_BAR) > 44.5 < 45.5
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 

#IFDEF Delta_Voltage_Rules_Check YES

125xRv4_R_8 {
@ Maximum delta V >= 5.6V is not allowed, when space between 1.25xRVn is < 0.410um
 chk_VIA = V4 INTERACT DVK_V4_RE
 err1 = DFM DV chk_VIA V4 < 0.410 DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" >= 5.6 ANNOTATE NOT CONNECTED SINGULAR
 DFM COPY err1
}

#ENDIF


// =======================================================
// 1.25xVn design rules
// =======================================================

GROUP G125xv5 125xv5_?
 
125xv5_BAR = (OR V5_BAR_100_all V5_BAR_450_all) INSIDE MARKS_MARKG
 
125xv5_W_1_L_1 {
@ 1.25xVn width and length, except 0.04*0.1um 1.25xVn, MARKS, MARKG and LOGO regions = 0.04um
 err1 = (V5 NOT RV5) NOT V5N
 err1 NOT INSIDE MARKS_MARKG_LOGO
}
 
125xv5_W_2 {
@ 1.25xVn bar width in MARKG/MARKS regions = 0.1, 0.45um
 err1 = (V5 NOT (OR V5_SR V5_BAR_100_all V5_BAR_450_all V5N_Seal_Ring)) INSIDE MARKS_MARKG
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xv5_S_1 {
@ Space between two 1.25xVn >= 0.056um
 err1 = EXT V5_SR < 0.056 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xv5_S_2 {
@ Space between two 1.25xVn when PRL > -0.04um. >= 0.074um
 err1 = EXT V5_SR < 0.074 ABUT<90 OPPOSITE EXTENDED 0.040 REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xv5_S_3 {
@ Space between 1.25xVn (1.25xVn enclosure by upper metal > 0um) and Vy/1.25xVn-1 at different net and PRL > 0um. >= 0.055um
 chk_via = (V5 INTERACT (V5N INSIDE M6)) NOT COIN EDGE M6
 err1 = EXT chk_via V4 < 0.055 ABUT<90 OPPOSITE REGION NOT CONNECTED
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xv5_S_4_M5 {
@ Space between two square 1.25xVn with PRL > -0.119um. >= 0.119um
@ When:
@ 1) 1.25xVn enclosure by 1.25xMy/1.25xMn/1.25xMn+1 < 0.01um at opposite side
@ 2) Space between 1.25xVn and 1.25xMy/1.25xMn/1.25xMn+1 <= 0.052um with PRL >= -0.046um at opposite side
@ DRC doesn't flag space between 1.25xVn and 1.25xMy/1.25xMn/1.25xMn+1 <= 0.052um with PRL >= -0.046um on both sides
 ncp_axis = ANGLE (ENC [V5N] M5 < 0.01 ABUT<90 OPPOSITE) == 90
 y1 = ANGLE (V5N TOUCH EDGE ncp_axis) == 90
 y2 = EXT [y1] M5 <= 0.052 ABUT<90 OPPOSITE EXTENDED 0.046+GLOBAL_TOLERANCE MEASURE ALL
 y3 = V5N TOUCH EDGE y2
 y4 = INT [V5N] y3 == 0.040 ABUT<90 OPPOSITE
 err1 = EXT (y4 NOT TOUCH EDGE y2) V5_SR < 0.119 ABUT<90 OPPOSITE EXTENDED 0.119 REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xv5_S_4_M6 {
@ Space between two square 1.25xVn with PRL > -0.119um. >= 0.119um
@ When:
@ 1) 1.25xVn enclosure by 1.25xMy/1.25xMn/1.25xMn+1 < 0.01um at opposite side
@ 2) Space between 1.25xVn and 1.25xMy/1.25xMn/1.25xMn+1 <= 0.052um with PRL >= -0.046um at opposite side
@ DRC doesn't flag space between 1.25xVn and 1.25xMy/1.25xMn/1.25xMn+1 <= 0.052um with PRL >= -0.046um on both sides
 ncp_axis = ANGLE (ENC [V5N] M6 < 0.01 ABUT<90 OPPOSITE) == 0
 y1 = ANGLE (V5N TOUCH EDGE ncp_axis) == 0
 y2 = EXT [y1] M6 <= 0.052 ABUT<90 OPPOSITE EXTENDED 0.046+GLOBAL_TOLERANCE MEASURE ALL
 y3 = V5N TOUCH EDGE y2
 y4 = INT [V5N] y3 == 0.040 ABUT<90 OPPOSITE
 err1 = EXT (y4 NOT TOUCH EDGE y2) V5_SR < 0.119 ABUT<90 OPPOSITE EXTENDED 0.119 REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xv5_S_5 {
@ Space between 1.25xVn bar (width = 0.1/0.45um) and (1.25xVn or 1.25xRVn) >= 0.34um
 err1 = EXT (OR V5_BAR_100_all V5_BAR_450_all) V5_SR < 0.34 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xv5_S_6 {
@ Space between 1.25xVn bar (width = 0.1/0.45um), DRC only check the space between parallel edge when the 1.25xVn bar is inside MARKS >= 0.55um
 err1 = EXT ((OR V5_BAR_100_all V5_BAR_450_all) INTERACT MARKS_MARKG) < 0.55 SINGULAR ANGLED!=1 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xv5_EN_1 {
@ 1.25xVn must be fully enclosed by 1.25xMy or 1.25xMn where 1.25xMy or 1.25xMn is the metal layer direct underneath 1.25xVn
@ Enclosure by 1.25xMy or 1.25xMn must follow one of 1.25xVn.EN.2 or 1.25xVn.EN.3 or 1.25xVn.EN.4 or 1.25xVn.EN.5 or 1.25xVn.EN.6 or 1.25xVn.EN.7
 err1 = V5N NOT M5
 err1 NOT INSIDE SealR_NOT_BULK
}
 
//;beginning of the 125xVn.EN.2 derivations
met_125xv5_2 = M5 WITH WIDTH == 0.040
via_125xv5_2 = V5N NOT OUTSIDE met_125xv5_2
via_125xv5_2_bad = RECTANGLE ENCLOSURE via_125xv5_2 M5 ABUT<90 SINGULAR 
GOOD 0 0.049 OPPOSITE 0 0.049 OPPOSITE
via_125xv5_2_good = via_125xv5_2 NOT via_125xv5_2_bad
//;end of the 125xVn.EN.2 derivations
 
125xv5_EN_2 {
@ 1.25xVn enclosure by 1.25xMy or 1.25xMn (width = 0.04um) for two opposite sides with the other two sides >= 0um. >= 0.049um
 err1 = COPY via_125xv5_2_bad
 err1 NOT INSIDE SealR_NOT_BULK
}
 
//;beginning of the 125xVn.EN.2a derivations
met_125xv5_2a = M5 WITH WIDTH == 0.042
via_125xv5_2a = V5N NOT OUTSIDE met_125xv5_2a
via_125xv5_2a_bad = RECTANGLE ENCLOSURE via_125xv5_2a M5 ABUT<90 SINGULAR 
GOOD 0.001 0.049 OPPOSITE 0.001 0.049 OPPOSITE
via_125xv5_2a_good = via_125xv5_2a NOT via_125xv5_2a_bad
//;end of the 125xVn.EN.2a derivations
 
125xv5_EN_2a {
@ 1.25xVn enclosure by 1.25xMy or 1.25xMn (width = 0.042um) for two opposite sides with the other two sides >= 0.001um. >= 0.049um
 err1 = via_125xv5_2a_bad NOT via_125xv5_2_good
 err1 NOT INSIDE SealR_NOT_BULK
}
 
//;beginning of the 125xVn.EN.3 derivations
met_125xv5_3 = M5 WITH WIDTH == 0.044
via_125xv5_3 = V5N NOT OUTSIDE met_125xv5_3
via_125xv5_3_bad = RECTANGLE ENCLOSURE via_125xv5_3 M5 ABUT<90 SINGULAR 
GOOD 0.002 0.049 OPPOSITE 0.002 0.049 OPPOSITE
via_125xv5_3_good = via_125xv5_3 NOT via_125xv5_3_bad
//;end of the 125xVn.EN.3 derivations
 
125xv5_EN_3 {
@ 1.25xVn enclosure by 1.25xMy or 1.25xMn (width = 0.044um) for two opposite sides with the other two sides >= 0.002um. >= 0.049um
 err1 = via_125xv5_3_bad NOT (OR via_125xv5_2_good via_125xv5_2a_good)
 err1 NOT INSIDE SealR_NOT_BULK
}
 
//;beginning of the 125xVn.EN.3a derivations
met_125xv5_4 = M5 WITH WIDTH == 0.046
via_125xv5_4 = V5N NOT OUTSIDE met_125xv5_4
via_125xv5_4_bad = RECTANGLE ENCLOSURE via_125xv5_4 M5 ABUT<90 SINGULAR 
GOOD 0.003 0.049 OPPOSITE 0.003 0.049 OPPOSITE
via_125xv5_4_good = via_125xv5_4 NOT via_125xv5_4_bad
//;end of the 125xVn.EN.3a derivations
 
125xv5_EN_4 {
@ 1.25xVn enclosure by 1.25xMy or 1.25xMn (width = 0.046um) for two opposite sides with the other two sides >= 0.003um. >= 0.049um
 err1 = via_125xv5_4_bad NOT (OR via_125xv5_2_good via_125xv5_2a_good via_125xv5_3_good)
 err1 NOT INSIDE SealR_NOT_BULK
}
 
//;beginning of the 125xVn.EN.5 derivations
met_125xv5_5 = M5 WITH WIDTH >= 0.060 < 0.08
via_125xv5_5 = V5N NOT OUTSIDE met_125xv5_5
via_125xv5_5_bad = RECTANGLE ENCLOSURE via_125xv5_5 M5 ABUT<90 SINGULAR 
GOOD 0.01 0.049 OPPOSITE 0.01 0.049 OPPOSITE
via_125xv5_5_good = via_125xv5_5 NOT via_125xv5_5_bad
//;end of the 125xVn.EN.5 derivations
 
125xv5_EN_5 {
@ 1.25xVn enclosure by 1.25xMy or 1.25xMn (0.06 <= width < 0.08um) for two opposite sides with the other two sides >= 0.01um. >= 0.049um
 err1 = via_125xv5_5_bad NOT (OR via_125xv5_2_good via_125xv5_2a_good via_125xv5_3_good via_125xv5_4_good)
 err1 NOT INSIDE SealR_NOT_BULK
}
 
// 125xVn.EN.5: purposely blank
 
//;beginning of the 125xVn.EN.6 derivations
met_125xv5_6 = M5 WITH WIDTH == 0.080
via_125xv5_6 = V5N NOT OUTSIDE met_125xv5_6
via_125xv5_6_bad = RECTANGLE ENCLOSURE via_125xv5_6 M5 ABUT<90 SINGULAR 
GOOD 0.02 0.02 0.02 0.02 OPPOSITE
via_125xv5_6_good = via_125xv5_6 NOT via_125xv5_6_bad
//;end of the 125xVn.EN.6 derivations
via_125xv5_2_3_4_good = OR via_125xv5_2_good via_125xv5_2a_good via_125xv5_3_good via_125xv5_4_good via_125xv5_5_good
via_125xv5_2_3_4_6_good = OR via_125xv5_2_3_4_good via_125xv5_6_good
 
125xv5_EN_6 {
@ 1.25xVn enclosure by 1.25xMy or 1.25xMn (width = 0.08um) for all sides >= 0.02um
 err1 = via_125xv5_6_bad NOT via_125xv5_2_3_4_good
 err1 NOT INSIDE SealR_NOT_BULK
 err2 = ENC via_125xv5_6 M5 < 0.02 ABUT<90 SINGULAR REGION //for via corner enclosure check
 err2 NOT INSIDE SealR_NOT_BULK
}
 
//;beginning of the 125xVn.EN.7 derivations
met_125xv5_7 = M5 WITH WIDTH > 0.080
via_125xv5_7 = V5N NOT OUTSIDE met_125xv5_7
via_125xv5_7_bad = RECTANGLE ENCLOSURE via_125xv5_7 M5 ABUT<90 SINGULAR 
GOOD 0.02 0.029 OPPOSITE 0.02 0.029 OPPOSITE
via_125xv5_7_good = via_125xv5_7 NOT via_125xv5_7_bad
//;end of the 125xVn.EN.7 derivations
 
125xv5_EN_7 {
@ 1.25xVn enclosure by 1.25xMy or 1.25xMn (width > 0.08um) for two opposite sides with the other two sides >= 0.02um. >= 0.029um
 err1 = via_125xv5_7_bad NOT via_125xv5_2_3_4_6_good
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xv5_EN_8 {
@ 1.25xVn bar enclosure by 1.25xMy or 1.25xMn >= 0.098um
 err1 = (V5_BAR_100_all OR V5_BAR_450_all) NOT M5
 err2 = ENC V5_BAR_100_all M5 < 0.098 ABUT<90 SINGULAR REGION
 err3 = ENC V5_BAR_450_all M5 < 0.098 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
}
 
125xv5_EN_9 {
@ 1.25xVn must be fully enclosed by 1.25xMn+1 where 1.25xMn+1 is the metal layer directly above 1.25xVn
@ Enclosure by 1.25xMn+1 must follow one of 1.25xVn.EN.10 or 1.25xVn.EN.11 or 1.25xVn.EN.12 or 1.25xVn.EN.13 or 1.25xVn.EN.14
 err1 = V5N NOT M6
 err1 NOT INSIDE SealR_NOT_BULK
}
 
//;beginning of the 125xVn.EN.10 derivations
met_125xv5_10 = M6 WITH WIDTH == 0.040
via_125xv5_10 = V5N NOT OUTSIDE met_125xv5_10
via_125xv5_10_bad = RECTANGLE ENCLOSURE via_125xv5_10 M6 ABUT<90 SINGULAR 
GOOD 0 0.049 OPPOSITE 0 0.049 OPPOSITE
via_125xv5_10_good = via_125xv5_10 NOT via_125xv5_10_bad
//;end of the 125xVn.EN.10 derivations
 
125xv5_EN_10 {
@ 1.25xVn enclosure by 1.25xMn+1 (width = 0.04um) for two opposite sides with the other two sides >= 0um. >= 0.049um
 err1 = copy via_125xv5_10_bad
 err1 NOT INSIDE SealR_NOT_BULK
}
 
//;beginning of the 125xVn.EN.10a derivations
met_125xv5_10a = M6 WITH WIDTH == 0.042
via_125xv5_10a = V5N NOT OUTSIDE met_125xv5_10a
via_125xv5_10a_bad = RECTANGLE ENCLOSURE via_125xv5_10a M6 ABUT<90 SINGULAR 
GOOD 0.001 0.049 OPPOSITE 0.001 0.049 OPPOSITE
via_125xv5_10a_good = via_125xv5_10a NOT via_125xv5_10a_bad
//;end of the 125xVn.EN.10a derivations
 
125xv5_EN_10a {
@ 1.25xVn enclosure by 1.25xMn+1 (width = 0.042um) for two opposite sides with the other two sides >= 0.001um. >= 0.049um
 err1 = via_125xv5_10a_bad NOT via_125xv5_10_good
 err1 NOT INSIDE SealR_NOT_BULK
}
 
//;beginning of the 125xVn.EN.11 derivations
met_125xv5_11 = M6 WITH WIDTH == 0.044
via_125xv5_11_TMP = V5N NOT OUTSIDE met_125xv5_11
via_125xv5_11 = via_125xv5_11_TMP NOT via_125xv5_10_good
via_125xv5_11_bad = RECTANGLE ENCLOSURE via_125xv5_11 M6 ABUT<90 SINGULAR 
GOOD 0.002 0.049 OPPOSITE 0.002 0.049 OPPOSITE
via_125xv5_11_good = via_125xv5_11 NOT via_125xv5_11_bad
//;end of the 125xVn.EN.11 derivations
 
125xv5_EN_11 {
@ 1.25xVn enclosure by 1.25xMn+1 (width = 0.044um) for two opposite sides with the other two sides >= 0.002um. >= 0.049um
 err1 = via_125xv5_11_bad NOT (OR via_125xv5_10_good via_125xv5_10a_good)
 err1 NOT INSIDE SealR_NOT_BULK
}
 
//;beginning of the 125xVn.EN.11 derivations
met_125xv5_11a = M6 WITH WIDTH == 0.046
via_125xv5_11a = V5N NOT OUTSIDE met_125xv5_11a
via_125xv5_11a_bad = RECTANGLE ENCLOSURE via_125xv5_11a M6 ABUT<90 SINGULAR 
GOOD 0.003 0.049 OPPOSITE 0.003 0.049 OPPOSITE
via_125xv5_11a_good = via_125xv5_11a NOT via_125xv5_11a_bad
//;end of the 125xVn.EN.11 derivations
 
125xv5_EN_11a {
@ 1.25xVn enclosure by 1.25xMn+1 (width = 0.046um) for two opposite sides with the other two sides >= 0.003um. >= 0.049um
 err1 = via_125xv5_11a_bad NOT (OR via_125xv5_10_good via_125xv5_10a_good via_125xv5_11_good)
 err1 NOT INSIDE SealR_NOT_BULK
}
 
//;beginning of the 125xVn.EN.12 derivations
met_125xv5_12 = M6 WITH WIDTH >= 0.060 < 0.08
via_125xv5_12 = V5N NOT OUTSIDE met_125xv5_12
via_125xv5_12_bad = RECTANGLE ENCLOSURE via_125xv5_12 M6 ABUT<90 SINGULAR 
GOOD 0.01 0.049 OPPOSITE 0.01 0.049 OPPOSITE
via_125xv5_12_good = via_125xv5_12 NOT via_125xv5_12_bad
//;end of the 125xVn.EN.12 derivations
via_125xv5_10_11_good = OR via_125xv5_10_good via_125xv5_10a_good via_125xv5_11_good via_125xv5_11a_good
via_125xv5_10_11_12_good = OR via_125xv5_10_11_good via_125xv5_12_good
 
125xv5_EN_12 {
@ 1.25xVn enclosure by 1.25xMn+1 (0.06 <= width < 0.08um) for two opposite sides with the other two sides >= 0.01um. >= 0.049um
 err1 = via_125xv5_12_bad NOT via_125xv5_10_11_good
 err1 NOT INSIDE SealR_NOT_BULK
}
 
//;beginning of the 125xVn.EN.13 derivations
met_125xv5_13 = M6 WITH WIDTH == 0.080
via_125xv5_13 = V5N NOT OUTSIDE met_125xv5_13
via_125xv5_13_bad = RECTANGLE ENCLOSURE via_125xv5_13 M6 ABUT<90 SINGULAR 
GOOD 0.02 0.02 0.02 0.02 OPPOSITE
via_125xv5_13_good = via_125xv5_13 NOT via_125xv5_13_bad
//;end of the 125xVn.EN.13 derivations
 
125xv5_EN_13 {
@ 1.25xVn enclosure by 1.25xMn+1 (width = 0.08um) for all sides >= 0.02um
 err1 = via_125xv5_13_bad NOT via_125xv5_10_11_12_good
 err1 NOT INSIDE SealR_NOT_BULK
 err2 = ENC via_125xv5_13 M6 < 0.02 ABUT<90 SINGULAR REGION //for via corner enclosure check
 err2 NOT INSIDE SealR_NOT_BULK
}
 
//;beginning of the 125xVn.EN.14 derivations
met_125xv5_14 = M6 WITH WIDTH > 0.080
via_125xv5_14 = V5N NOT OUTSIDE met_125xv5_14
via_125xv5_14_bad = RECTANGLE ENCLOSURE via_125xv5_14 M6 ABUT<90 SINGULAR 
GOOD 0.02 0.029 OPPOSITE 0.02 0.029 OPPOSITE
via_125xv5_14_good = via_125xv5_14 NOT via_125xv5_14_bad
//;end of the 125xVn.EN.14 derivations
 
125xv5_EN_14 {
@ 1.25xVn enclosure by 1.25xMn+1 (width > 0.08um) for two opposite sides with the other two sides >= 0.02um. >= 0.029um
 err1 = via_125xv5_14_bad NOT (OR via_125xv5_10_11_12_good via_125xv5_13_good)
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xv5_EN_15 {
@ 1.25xVn enclosure by 1.25xMn+1 edge (between two consecutive 90-270 degree corners, length < 0.16um), when PRL > 0um. >= 0.029um
 chk_edge = CONVEX EDGE M6 ANGLE1 == 90 ANGLE2 == 270 WITH LENGTH < 0.16
 err1_TMP = chk_edge TOUCH EDGE (EXT chk_edge M6_convex_270_90_edges < 0.005 ABUT==90 INTERSECTING ONLY REGION)
 err1 = ENC V5N err1_TMP < 0.029 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xv5_EN_16 {
@ 1.25xVn enclosure by 1.25xMn+1 for two opposite sides (PRL > 0) with the other side enclosure < 0.04um (corresponding edge length < 0.16um between two consecutive 90-270 degree corners) >= 0.04um
 correspond_EDG = CONVEX EDGE M6 ANGLE1 == 90 ANGLE2 == 270 WITH LENGTH < 0.16
 correspond_ENC = ENC [V5N] correspond_EDG < 0.04 ABUT<90 OPPOSITE EXTENDED 0.001
 correspond_VIA_ENC_EDGE = V5N TOUCH EDGE correspond_ENC
 correspond_VIA_EDG_CORN = INT [V5N] correspond_VIA_ENC_EDGE < 0.001 ABUT==90 INTERSECTING ONLY
 correspond_VIA_EDG = V5N TOUCH EDGE correspond_VIA_EDG_CORN
 err1_RAW = ENC [correspond_VIA_EDG] M6 < 0.040 ABUT<90 OPPOSITE EXTENDED 0.001
 err1_TMP = INT correspond_VIA_ENC_EDGE (correspond_VIA_EDG TOUCH EDGE err1_RAW) < 0.005 ABUT==90 INTERSECTING ONLY REGION
 err1 = EXPAND EDGE (V5N TOUCH EDGE err1_TMP) INSIDE BY 0.001
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xv5_EN_17 {
@ 1.25xVn bar fully enclosure by 1.25xMn+1 >= 0.2um
 err1 = (V5_BAR_100_all OR V5_BAR_450_all) NOT M6
 err2 = ENC V5_BAR_100_all M6 < 0.2 ABUT<90 SINGULAR REGION
 err3 = ENC V5_BAR_450_all M6 < 0.2 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
}

#IFDEF RECOMMENDED_CHECK YES

 
125xv5_D_1_R {
@ (1.25xVn OR 1.25xRVn) density (window 5um*5um, stepping 2.5um) < 12%
 check_region = copy CHIP_NOT_MARKS
 check_pattern = (V5 NOT 125xv5_BAR) AND check_region
 // 
 check_window1 = check_region WITH WIDTH >= 5/4
 err1_TMP1 = DENSITY check_pattern check_window1 check_region [!!AREA(check_window1)*AREA(check_pattern)/AREA(check_region)] >= 12/100 WINDOW 5 STEP 5/2 BACKUP INSIDE OF LAYER DRC:1 BY POLYGON
 // 
 check_window2 = WITH WIDTH (check_region AND err1_TMP1) >= 5/4
 err1_TMP2 = DENSITY check_pattern check_window2 check_region [!!AREA(check_window2)*AREA(check_pattern)/AREA(check_region)] >= 12/100 WINDOW 5 STEP 5/2 BACKUP INSIDE OF LAYER err1_TMP1 BY POLYGON
 // 
 check_window3 = WITH WIDTH (check_region AND err1_TMP2) >= 5/4
 DENSITY check_pattern check_window3 check_region [!!AREA(check_window3)*AREA(check_pattern)/AREA(check_region)] >= 12/100 WINDOW 5 STEP 5/2 BACKUP INSIDE OF LAYER err1_TMP2 BY POLYGON PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_125xv5_D_1_R.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_125xv5_D_1_R.rdb"
}

#ENDIF

 
125xv5_R_1 {
@ 45-degree 1.25xVn is not allowed
 err1 = ANGLE (V5 NOT 125xv5_BAR) > 44.5 < 45.5
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
125xv5_R_2 {
@ It is not allowed to have single 1.25xVn in "H-shape" 1.25xMn+1 when all of the following conditions come into existence:
@ 1) The 1.25xMn+1 has "H-shape" interact two metal holes: both two metal hole length <= 4.5um and two metal hole area <= 4.05um2
@ 2) The 1.25xVn overlaps on the center metal bar of this "H-shape" 1.25xMn+1
@ 3) The center metal bar length <= 0.9um and the metal bar width <= 0.162um
 hole_area_meet = AREA (HOLES M6 INNER) <= 4.05
 hole_area_meet_len = (hole_area_meet WITH EDGE (LENGTH hole_area_meet <= 0.9)) NOT WITH EDGE (LENGTH hole_area_meet > 4.5)
 hole_area_real = (hole_area_meet_len NOT ENCLOSE RECTANGLE 0.9+GLOBAL_TOLERANCE 4.5) NOT ENCLOSE RECTANGLE 0.9 4.5+GLOBAL_TOLERANCE
 hole_bars_len = M6 COIN EDGE hole_area_real
 // 
 hole_bars = INT hole_bars_len <= 0.162 ABUT<90 OPPOSITE REGION EXCLUDE SHIELDED
 hole_bars_real = hole_bars WITH EDGE (LENGTH hole_bars_len <= 0.9)
 hole_bars_vias_sq = V5N INTERACT ((hole_bars_real INTERACT hole_area_real == 2) NOT ENCLOSE RV5)
 err1 = hole_bars_real INTERACT hole_bars_vias_sq == 1
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xv5_R_3 {
@ The numbers of neighboring square 1.25xVn to each edge of 1.25xVn <= 0.065um is not allowed < 2
 // based on 125xVn.S.6 and 125xVn.S.1, so only check the space range 0.056~0.065um with PRL <= 0.04
 Y1 = EXT V5N >= 0.056 <= 0.065 ABUT CORNER TO CORNER
 Y2 = DFM PROPERTY Y1 [-= (EWXP(Y1) > 0.040 && EWYP(Y1) > 0.040) ? 1 : 0] > 0
 Y3 = INT [V5N] < 0.001 ABUT INTERSECTING ONLY
 Y4 = Y3 COIN EDGE (DFM COPY Y2 EDGE)
 Y5 = INT Y4 V5N < 0.001 ABUT==90 INTERSECTING ONLY REGION
 Y6 = INT (V5N COIN EDGE Y5) == 0.040 OPPOSITE REGION
 err1 = V5N INTERACT Y6
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xv5_R_4 {
@ The numbers of neighboring square 1.25xVn in one group (space <= 0.065um) <= 3
 err1 = WITH NEIGHBOR V5N > 2 SPACE <= 0.065
 err1 NOT INSIDE SealR_NOT_BULK
}
 

#IFDEF Delta_Voltage_Rules_Check YES

125xv5_R_5 {
@ Maximum delta V >= 5.6V is not allowed, when space between 1.25xVn is < 0.410um
 chk_VIA = V5 INTERACT DVK_V5_SQ
 err1 = DFM DV chk_VIA V5 < 0.410 DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" >= 5.6 ANNOTATE NOT CONNECTED SINGULAR
 DFM COPY err1
}

#ENDIF

// 1.25xVn.R.8[NC] 1.25xVn pattern must be drawn on data type 50
 
125xv5_R_9 {
@ It's not allowed 1.25xVn overlap with the metal resistor directly underneath and above the 1.25xVn
 err1 = V5 AND (M5RES AND M5)
 err2 = V5 AND (M6RES AND M6)
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

#IFDEF RECOMMENDED_CHECK YES

 
125xv5_R_10_R {
@ Recommend space between a square 1.25xVn and another (1.25xVn OR 1.25xRVn OR DUM_1.25xVn) < 4um to avoid single square 1.25xVn
 ALL_VIA_CHECK = OR V5_SR V5DUM_all V5DOP_all
 STEP_1 = SIZE V5_SR BY 1.4
 // 4/1.414 = 2.828
 STEP_1_GOOD = STEP_1 INTERACT ALL_VIA_CHECK > 1
 STEP_1_FILTER = V5N NOT INTERACT STEP_1_GOOD
 err1 = STEP_1_FILTER NOT WITH EDGE (EXT [STEP_1_FILTER] ALL_VIA_CHECK < 4 PERP ALSO)
 err1 NOT INSIDE SealR_NOT_BULK
}

#ENDIF


// =======================================================
// 1.25xVn design rules: Rectangular 1.25xVn
// =======================================================

GROUP G125xRv5 125xRv5_?
 
125xRv5_W_1_L_1 {
@ 1.25xRVn.W.1: 1.25xRVn width, except MARKS, MARKG and LOGO regions = 0.04um
@ 1.25xRVn.L.1: Length of 1.25xRVn (width = 0.04um) = 0.1um
 err1 = (V5 NOT V5N) NOT RV5
 err1 NOT INSIDE MARKS_MARKG_LOGO
}
 
125xRv5_S_1a {
@ Space between (1.25xVn or 1.25xRVn) and 1.25xRVn >= 0.074um
 err1 = EXT RV5 V5_SR < 0.074 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xRv5_S_1b {
@ Space between (1.25xVn or 1.25xRVn) and 1.25xRVn when PRL > -0.04um. >= 0.079um
 err1 = EXT RV5 V5_SR < 0.079 ABUT<90 OPPOSITE EXTENDED 0.04 REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xRv5_S_1c {
@ Space between the short side of 1.25xRVn and (1.25xVn or 1.25xRVn) when PRL > -0.04um. >= 0.089um
 err1 = EXT RV5_W V5_SR < 0.089 ABUT<90 OPPOSITE EXTENDED 0.04 REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xRv5_S_3 {
@ Space between 1.25xRVn and (1.25xRVn-1 or 1.25xVn-1) at different net and PRL > 0um, when 1.25xMn+1 enclosure of 1.25xRVn > 0um. >= 0.055um
 chk_via = (V5 INTERACT RV5) NOT COIN EDGE M6
 err1 = EXT chk_via V4 < 0.055 ABUT<90 OPPOSITE REGION NOT CONNECTED
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xRv5_S_4_M5 {
@ Space between 1.25xRVn when PRL >= -0.119um. >= 0.119um
@ When:
@ 1) 1.25xRVn enclosure by 1.25xMy/1.25xMn/1.25xMn+1 < 0.01um at opposite side
@ 2) Space between 1.25xRVn and 1.25xMy/1.25xMn/1.25xMn+1 <= 0.052um with PRL >= -0.046um at opposite side
@ DRC doesn't flag space between 1.25xRVn and 1.25xMy/1.25xMn/1.25xMn+1 <= 0.052um with PRL >= -0.046um on both sides
 ncp_axis = ANGLE (ENC [RV5] M5 < 0.01 ABUT<90 OPPOSITE) == 90
 y1 = ANGLE (RV5 TOUCH EDGE ncp_axis) == 90
 y2 = EXT [y1] M5 <= 0.052 ABUT<90 OPPOSITE EXTENDED 0.046+GLOBAL_TOLERANCE MEASURE ALL
 y3 = RV5 TOUCH EDGE y2
 y4 = INT [RV5] y3 == 0.040 ABUT<90 OPPOSITE
 err1 = EXT (y4 NOT TOUCH EDGE y2) V5_SR < 0.119 ABUT<90 OPPOSITE EXTENDED 0.119+GLOBAL_TOLERANCE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xRv5_S_4_M6 {
@ Space between 1.25xRVn when PRL >= -0.119um. >= 0.119um
@ When:
@ 1) 1.25xRVn enclosure by 1.25xMy/1.25xMn/1.25xMn+1 < 0.01um at opposite side
@ 2) Space between 1.25xRVn and 1.25xMy/1.25xMn/1.25xMn+1 <= 0.052um with PRL >= -0.046um at opposite side
@ DRC doesn't flag space between 1.25xRVn and 1.25xMy/1.25xMn/1.25xMn+1 <= 0.052um with PRL >= -0.046um on both sides
 ncp_axis = ANGLE (ENC [RV5] M6 < 0.01 ABUT<90 OPPOSITE) == 0
 y1 = ANGLE (RV5 TOUCH EDGE ncp_axis) == 0
 y2 = EXT [y1] M6 <= 0.052 ABUT<90 OPPOSITE EXTENDED 0.046+GLOBAL_TOLERANCE MEASURE ALL
 y3 = RV5 TOUCH EDGE y2
 y4 = INT [RV5] y3 == 0.040 ABUT<90 OPPOSITE
 err1 = EXT (y4 NOT TOUCH EDGE y2) V5_SR < 0.119 ABUT<90 OPPOSITE EXTENDED 0.119+GLOBAL_TOLERANCE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xRv5_EN_1 {
@ 1.25xRVn must be fully enclosed by 1.25xMy or 1.25xMn where 1.25xMy or 1.25xMn is the metal layer directly underneath 1.25xRVn. Enclosure by 1.25xMy or 1.25xMn must follow one of 1.25xRVn.EN.2 or 1.25xRVn.EN.3 or 1.25xRVn.EN.4 or 1.25xRVn.EN.5 or 1.25xRVn.EN.6 or 1.25xRVn.EN.7 or 1.25xRVn.EN.8
 err1 = RV5 NOT M5
 err1 NOT INSIDE SealR_NOT_BULK
}
 
//;beginning of the 125xRVn.EN.2 derivations
met_125xRv5_2 = M5 WITH WIDTH == 0.040
via_125xRv5_2 = RV5 NOT OUTSIDE met_125xRv5_2
via_125xRv5_2_bad = RECTANGLE ENCLOSURE via_125xRv5_2 M5 ABUT<90 SINGULAR 
GOOD 0 0.049 OPPOSITE 0 0.049 OPPOSITE
via_125xRv5_2_good = via_125xRv5_2 NOT via_125xRv5_2_bad
//;end of the 125xRVn.EN.2 derivations
 
125xRv5_EN_2 {
@ 1.25xRVn enclosure by 1.25xMy or 1.25xMn (width = 0.04um) for two opposite sides with the other two sides >= 0um. >= 0.049um
 err1 = copy via_125xRv5_2_bad
 err1 NOT INSIDE SealR_NOT_BULK
}
 
//;beginning of the 125xRVn.EN.2a derivations
met_125xRv5_2a = M5 WITH WIDTH == 0.042
via_125xRv5_2a = RV5 NOT OUTSIDE met_125xRv5_2a
via_125xRv5_2a_bad = RECTANGLE ENCLOSURE via_125xRv5_2a M5 ABUT<90 SINGULAR 
GOOD 0.001 0.049 OPPOSITE 0.001 0.049 OPPOSITE
via_125xRv5_2a_good = via_125xRv5_2a NOT via_125xRv5_2a_bad
//;end of the 125xRVn.EN.2a derivations
 
125xRv5_EN_2a {
@ 1.25xRVn enclosure by 1.25xMy or 1.25xMn (width = 0.042um) for two opposite sides with the other two sides >= 0.001um. >= 0.049um
 err1 = via_125xRv5_2a_bad NOT via_125xRv5_2_good
 err1 NOT INSIDE SealR_NOT_BULK
}
 
//;beginning of the 125xRVn.EN.3 derivations
met_125xRv5_3 = M5 WITH WIDTH == 0.044
via_125xRv5_3 = RV5 NOT OUTSIDE met_125xRv5_3
via_125xRv5_3_bad = RECTANGLE ENCLOSURE via_125xRv5_3 M5 ABUT<90 SINGULAR 
GOOD 0.002 0.049 OPPOSITE 0.002 0.049 OPPOSITE
via_125xRv5_3_good = via_125xRv5_3 NOT via_125xRv5_3_bad
//;end of the 125xRVn.EN.3 derivations
 
125xRv5_EN_3 {
@ 1.25xRVn enclosure by 1.25xMy or 1.25xMn (width = 0.044um) for two opposite sides with the other two sides >= 0.002um. >= 0.049um
 err1 = via_125xRv5_3_bad NOT (OR via_125xRv5_2_good via_125xRv5_2a_good)
 err1 NOT INSIDE SealR_NOT_BULK
}
 
//;beginning of the 125xRVn.EN.3a derivations
met_125xRv5_3a = M5 WITH WIDTH == 0.046
via_125xRv5_3a = RV5 NOT OUTSIDE met_125xRv5_3a
via_125xRv5_3a_bad = RECTANGLE ENCLOSURE via_125xRv5_3a M5 ABUT<90 SINGULAR 
GOOD 0.003 0.049 OPPOSITE 0.003 0.049 OPPOSITE
via_125xRv5_3a_good = via_125xRv5_3a NOT via_125xRv5_3a_bad
//;end of the 125xRVn.EN.3a derivations
 
125xRv5_EN_3a {
@ 1.25xRVn enclosure by 1.25xMy or 1.25xMn (width = 0.046um) for two opposite sides with the other two sides >= 0.003um. >= 0.049um
 err1 = via_125xRv5_3a_bad NOT (OR via_125xRv5_2_good via_125xRv5_2a_good via_125xRv5_3_good)
 err1 NOT INSIDE SealR_NOT_BULK
}
 
//;beginning of the 125xRVn.EN.4 derivations
met_125xRv5_4 = M5 WITH WIDTH >= 0.060 < 0.08
via_125xRv5_4 = RV5 NOT OUTSIDE met_125xRv5_4
via_125xRv5_4_bad = RECTANGLE ENCLOSURE via_125xRv5_4 M5 ABUT<90 SINGULAR 
GOOD 0.01 0.049 OPPOSITE 0.010 0.049 OPPOSITE
via_125xRv5_4_good = via_125xRv5_4 NOT via_125xRv5_4_bad
//;end of the 125xRVn.EN.4 derivations
via_125xRv5_2_3_good = OR via_125xRv5_2_good via_125xRv5_2a_good via_125xRv5_3_good via_125xRv5_3a_good
via_125xRv5_2_3_4_good = OR via_125xRv5_2_3_good via_125xRv5_4_good
 
125xRv5_EN_4 {
@ 1.25xRVn enclosure by 1.25xMy or 1.25xMn (0.06um <= width < 0.08um) for two opposite sides with the other two sides >= 0.01um. >= 0.049um
 err1 = via_125xRv5_4_bad NOT via_125xRv5_2_3_good
 err1 NOT INSIDE SealR_NOT_BULK
}
 
//;beginning of the 125xRVn.EN.5 derivations
met_125xRv5_5 = M5 WITH WIDTH == 0.080
via_125xRv5_5 = RV5 NOT OUTSIDE met_125xRv5_5
via_125xRv5_5_bad = RECTANGLE ENCLOSURE via_125xRv5_5 M5 ABUT<90 SINGULAR 
GOOD 0.02 0.02 0.02 0.02 OPPOSITE
via_125xRv5_5_good = via_125xRv5_5 NOT via_125xRv5_5_bad
//;end of the 125xRVn.EN.5 derivations
 
125xRv5_EN_5 {
@ 1.25xRVn enclosure by 1.25xMy or 1.25xMn (width = 0.08um) for all sides >= 0.02um
 err1 = via_125xRv5_5_bad NOT via_125xRv5_2_3_4_good
 err1 NOT INSIDE SealR_NOT_BULK
 err2 = ENC via_125xRv5_5 M5 < 0.02 ABUT<90 SINGULAR REGION
 err2 NOT INSIDE SealR_NOT_BULK
}
 
 //--------------Definition of 1.25xRVn array----------------- 
125xRv_15 = EXT [RV5_L] == 0.08 ABUT<90 OPPOSITE
125xRv_25 = LENGTH 125xRv_15 == 0.1
125xRv_05 = (EXT RV5_L == 0.08 ABUT<90 OPPOSITE REGION) WITH EDGE 125xRv_25
125xRv_35 = RV5 WITH EDGE 125xRv_15
125xRv_array5 = (125xRv_35 OR 125xRv_05) INTERACT 125xRv_35 > 1
 
//;beginning of the 125xRVn.EN.6 derivations
met_125xRv5_6 = M5 WITH WIDTH > 0.080
via_125xRv5_6 = (RV5 INTERACT met_125xRv5_6) NOT INTERACT 125xRv_array5
via_125xRv5_6_bad = RECTANGLE ENCLOSURE via_125xRv5_6 M5 ABUT<90 SINGULAR 
GOOD 0.02 0.029 OPPOSITE 0.02 0.029 OPPOSITE
via_125xRv5_6_good = via_125xRv5_6 NOT via_125xRv5_6_bad
//;end of the 125xRVn.EN.6 derivations
 
125xRv5_EN_6 {
@ 1.25xRVn enclosure by 1.25xMy or 1.25xMn (width > 0.08um) for two opposite sides with the other two sides >= 0.02um (except rectangular 1.25xRVn array) >= 0.029um
 err1 = via_125xRv5_6_bad NOT (OR via_125xRv5_2_3_4_good via_125xRv5_5_good via_125xRv5_7_good) //125xRv.EN.6~7: the width conditions are covered by each other
 err1 NOT INSIDE SealR_NOT_BULK
}
 
//;beginning of the 125xRVn.EN.7 derivations
met_125xRv5_7 = M5 WITH WIDTH > 0.080
via_125xRv5_7 = (RV5 INTERACT met_125xRv5_7) NOT INTERACT 125xRv_array5
via_125xRv5_7_L_edges = LENGTH via_125xRv5_7 == 0.10
via_125xRv5_7_W_edges = LENGTH via_125xRv5_7 == 0.04
via_125xRv5_7_x = ENC [via_125xRv5_7_L_edges] M5 < 0.039 ABUT<90 OPPOSITE
via_125xRv5_7_y = ENC [via_125xRv5_7_W_edges] M5 < 0.01 ABUT<90 OPPOSITE
via_125xRv5_7_bad = via_125xRv5_7 WITH EDGE (OR EDGE via_125xRv5_7_x via_125xRv5_7_y)
via_125xRv5_7_good = via_125xRv5_7 NOT via_125xRv5_7_bad
//;end of the 125xRVn.EN.7 derivations
 
125xRv5_EN_7 {
@ 1.25xRVn enclosure by short side of 1.25xMy or 1.25xMn (width > 0.08um) with long side enclosure >= 0.039um (except rectangular 1.25xRVn array) >= 0.01um
 err1 = via_125xRv5_7_bad NOT (OR via_125xRv5_2_3_4_good via_125xRv5_5_good via_125xRv5_6_good)
 err1 NOT INSIDE SealR_NOT_BULK
}
 
//;beginning of the 125xRVn.EN.8 derivations
met_125xRv5_8 = COPY M5
via_125xRv5_8 = (RV5 INTERACT met_125xRv5_8) INTERACT 125xRv_array5
via_125xRv5_8_bad = RECTANGLE ENCLOSURE via_125xRv5_8 M5 ABUT<90 SINGULAR 
GOOD 0.01 0.02 OPPOSITE 0.01 0.02 OPPOSITE
via_125xRv5_8_good = via_125xRv5_8 NOT via_125xRv5_8_bad
//;end of the 125xRVn.EN.8 derivations
 
125xRv5_EN_8 {
@ 1.25xRVn array enclosed by 1.25xMn/1.25xMy for two opposite sides with the other two sides (rectangular 1.25xVn array edge length = 0.1um) >= 0.02um
@ Definition of 1.25xRVn array:
@ 1.25xVn long side space = 0.08um (PRL = 0.1um) >= 0.01um
 err1 = via_125xRv5_8_bad NOT (OR via_125xRv5_2_3_4_good via_125xRv5_5_good via_125xRv5_6_good via_125xRv5_7_good)
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xRv5_EN_9 {
@ 1.25xRVn must be fully enclosed by 1.25xMn+1 where 1.25xMn+1 is the metal layer directly above 1.25xRVn. Enclosures by 1.25xMn+1 must follow one of 1.25xRVn.EN.10 or 1.25xRVn.EN.11 or 1.25xRVn.EN.12 or 1.25xRVn.EN.13 or 1.25xRVn.EN.14.
 err1 = RV5 NOT M6
 err1 NOT INSIDE SealR_NOT_BULK
}
 
//;beginning of the 125xRVn.EN.10 derivations
met_125xRv5_10 = M6 WITH WIDTH == 0.040
via_125xRv5_10 = RV5 NOT OUTSIDE met_125xRv5_10
via_125xRv5_10_bad = RECTANGLE ENCLOSURE via_125xRv5_10 M6 ABUT<90 SINGULAR 
GOOD 0 0.039 OPPOSITE 0 0.039 OPPOSITE
via_125xRv5_10_good = via_125xRv5_10 NOT via_125xRv5_10_bad
//;end of the 125xRVn.EN.10 derivations
 
125xRv5_EN_10 {
@ 1.25xRVn enclosure by 1.25xMn+1 (width = 0.04um) for two opposite sides with the other two sides >= 0um. >= 0.039um
 err1 = copy via_125xRv5_10_bad
 err1 NOT INSIDE SealR_NOT_BULK
}
 
//;beginning of the 125xRVn.EN.10a derivations
met_125xRv5_10a = M6 WITH WIDTH == 0.042
via_125xRv5_10a = RV5 NOT OUTSIDE met_125xRv5_10a
via_125xRv5_10a_bad = RECTANGLE ENCLOSURE via_125xRv5_10a M6 ABUT<90 SINGULAR 
GOOD 0.001 0.039 OPPOSITE 0.001 0.039 OPPOSITE
via_125xRv5_10a_good = via_125xRv5_10a NOT via_125xRv5_10a_bad
//;end of the 125xRVn.EN.10a derivations
 
125xRv5_EN_10a {
@ 1.25xRVn enclosure by 1.25xMn+1 (width = 0.042um) for two opposite sides with the other two sides >= 0.001um. >= 0.039um
 err1 = via_125xRv5_10a_bad NOT via_125xRv5_10_good
 err1 NOT INSIDE SealR_NOT_BULK
}
 
//;beginning of the 125xRVn.EN.10b derivations
met_125xRv5_10b = M6 WITH WIDTH == 0.044
via_125xRv5_10b = RV5 NOT OUTSIDE met_125xRv5_10b
via_125xRv5_10b_bad = RECTANGLE ENCLOSURE via_125xRv5_10b M6 ABUT<90 SINGULAR 
GOOD 0.002 0.039 OPPOSITE 0.002 0.039 OPPOSITE
via_125xRv5_10b_good = via_125xRv5_10b NOT via_125xRv5_10b_bad
//;end of the 125xRVn.EN.10b derivations
 
125xRv5_EN_10b {
@ 1.25xRVn enclosure by 1.25xMn+1 (width = 0.044um) for two opposite sides with the other two sides >= 0.002um. >= 0.039um
 err1 = via_125xRv5_10b_bad NOT (OR via_125xRv5_10_good via_125xRv5_10a_good)
 err1 NOT INSIDE SealR_NOT_BULK
}
 
//;beginning of the 125xRVn.EN.10c derivations
met_125xRv5_10c = M6 WITH WIDTH == 0.046
via_125xRv5_10c = RV5 NOT OUTSIDE met_125xRv5_10c
via_125xRv5_10c_bad = RECTANGLE ENCLOSURE via_125xRv5_10c M6 ABUT<90 SINGULAR 
GOOD 0.003 0.039 OPPOSITE 0.003 0.039 OPPOSITE
via_125xRv5_10c_good = via_125xRv5_10c NOT via_125xRv5_10c_bad
//;end of the 125xRVn.EN.10c derivations
 
125xRv5_EN_10c {
@ 1.25xRVn enclosure by 1.25xMn+1 (width = 0.046um) for two opposite sides with the other two sides >= 0.003um. >= 0.039um
 err1 = via_125xRv5_10c_bad NOT (OR via_125xRv5_10_good via_125xRv5_10a_good via_125xRv5_10b_good)
 err1 NOT INSIDE SealR_NOT_BULK
}
 
//;beginning of the 125xRVn.EN.10d derivations
met_125xRv5_10d = M6 WITH WIDTH >= 0.060 < 0.08
via_125xRv5_10d = RV5 NOT OUTSIDE met_125xRv5_10d
via_125xRv5_10d_bad = RECTANGLE ENCLOSURE via_125xRv5_10d M6 ABUT<90 SINGULAR 
GOOD 0.01 0.039 OPPOSITE 0.01 0.039 OPPOSITE
via_125xRv5_10d_good = via_125xRv5_10d NOT via_125xRv5_10d_bad
//;end of the 125xRVn.EN.10d derivations
 
125xRv5_EN_10d {
@ 1.25xRVn enclosure by 1.25xMn+1 (width >= 0.06 < 0.08um) for two opposite sides with the other two sides >= 0.01um. >= 0.039um
 err1 = via_125xRv5_10d_bad NOT (OR via_125xRv5_10_good via_125xRv5_10a_good via_125xRv5_10b_good via_125xRv5_10c_good)
 err1 NOT INSIDE SealR_NOT_BULK
}
 
//;beginning of the 125xRVn.EN.11 derivations
met_125xRv5_11 = M6 WITH WIDTH == 0.080
via_125xRv5_11 = RV5 NOT OUTSIDE met_125xRv5_11
via_125xRv5_11_bad = RECTANGLE ENCLOSURE via_125xRv5_11 M6 ABUT<90 SINGULAR 
GOOD 0.02 0.02 0.02 0.02 OPPOSITE
via_125xRv5_11_good = via_125xRv5_11 NOT via_125xRv5_11_bad
//;end of the 125xRVn.EN.11 derivations
via_125xRv5_10_10abcd_good = OR via_125xRv5_10_good via_125xRv5_10a_good via_125xRv5_10b_good via_125xRv5_10c_good via_125xRv5_10d_good
via_125xRv5_10_10a_10b_10c_10d_11_good = OR via_125xRv5_10_10abcd_good via_125xRv5_11_good
 
125xRv5_EN_11 {
@ 1.25xRVn enclosure by 1.25xMn+1 (width = 0.08um) for all sides >= 0.02um
 err1 = via_125xRv5_11_bad NOT via_125xRv5_10_10abcd_good
 err1 NOT INSIDE SealR_NOT_BULK
 err2 = ENC via_125xRv5_11 M6 < 0.02 ABUT<90 SINGULAR REGION
 err2 NOT INSIDE SealR_NOT_BULK
}
 
//;beginning of the 125xRVn.EN.12 derivations
met_125xRv5_12 = M6 WITH WIDTH > 0.08
via_125xRv5_12 = (RV5 INTERACT met_125xRv5_12) NOT INTERACT 125xRv_array5
via_125xRv5_12_bad = RECTANGLE ENCLOSURE via_125xRv5_12 M6 ABUT<90 SINGULAR 
GOOD 0.02 0.029 OPPOSITE 0.02 0.029 OPPOSITE
via_125xRv5_12_good = via_125xRv5_12 NOT via_125xRv5_12_bad
//;end of the 125xRVn.EN.12 derivations
 
125xRv5_EN_12 {
@ 1.25xRVn enclosure by 1.25xMn+1 (width > 0.080um) for two opposite sides with the other two sides >= 0.02um (except rectangular 1.25xVn array) >= 0.029um
 err1 = via_125xRv5_12_bad NOT (OR via_125xRv5_10_10a_10b_10c_10d_11_good via_125xRv5_13_13a_good) //125xRv.EN.12~13: the width conditions are covered by each other
 err1 NOT INSIDE SealR_NOT_BULK
}
 
//;beginning of the 125xRVn.EN.13a derivations
met_125xRv5_13a = (M6 WITH WIDTH > 0.08) WITH WIDTH >= 0.12
via_125xRv5_13a = (RV5 INTERACT met_125xRv5_13a) NOT INTERACT 125xRv_array5
via_125xRv5_13a_bad = RECTANGLE ENCLOSURE via_125xRv5_13a M6 ABUT<90 SINGULAR 
GOOD 0.02 0.029 OPPOSITE 0.02 0.029 OPPOSITE
via_125xRv5_13a_good = via_125xRv5_13a NOT via_125xRv5_13a_bad
//;end of the 125xRVn.EN.13a derivations
 
//;beginning of the 125xRVn.EN.13 derivations
met_125xRv5_13 = (M6 WITH WIDTH > 0.08) WITH WIDTH >= 0.12
via_125xRv5_13_TMP = (RV5 INTERACT met_125xRv5_13) NOT INTERACT 125xRv_array5
via_125xRv5_13 = via_125xRv5_13_TMP NOT (OR via_125xRv5_10_10a_10b_10c_10d_11_good via_125xRv5_12_good)
via_125xRv5_13_L_edges = LENGTH via_125xRv5_13 == 0.10
via_125xRv5_13_W_edges = LENGTH via_125xRv5_13 == 0.04
via_125xRv5_13_x = ENC [via_125xRv5_13_L_edges] M6 < 0.039 ABUT<90 OPPOSITE
via_125xRv5_13_y = ENC [via_125xRv5_13_W_edges] M6 < 0.01 ABUT<90 OPPOSITE
via_125xRv5_13_bad = via_125xRv5_13 WITH EDGE (OR EDGE via_125xRv5_13_x via_125xRv5_13_y)
via_125xRv5_13_good = via_125xRv5_13 NOT via_125xRv5_13_bad
via_125xRv5_13_13a_good = OR via_125xRv5_13_good via_125xRv5_13a_good
//;end of the 125xRVn.EN.13 derivations
 
125xRv5_EN_13a {
@ 1.25xRVn enclosure by 1.25xMn+1 (width >= 0.12um) for two opposite sides with the other two sides >= 0.02um (except rectangle 1.25xVn array) >= 0.029um
 err1 = via_125xRv5_13a_bad NOT (OR via_125xRv5_10_10a_10b_10c_10d_11_good via_125xRv5_12_good via_125xRv5_13_good) //125xRv.EN.13 already covered by 125xRv.EN.12
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xRv5_EN_13 {
@ 1.25xRVn short side enclosed by 1.25xMn+1, 1.25xMn+1 (width >= 0.12um) with long sides enclosure >= 0.039um (except rectangular 1.25xVn array) >= 0.01um
 err1 = via_125xRv5_13_bad NOT (OR via_125xRv5_10_10a_10b_10c_10d_11_good via_125xRv5_12_good via_125xRv5_13a_good) //125xRv.EN.12~13: the width conditions are covered by each other
 err1 NOT INSIDE SealR_NOT_BULK
}
 
//;beginning of the 125xRVn.EN.14a derivations
met_125xRv5_14 = COPY M6
via_125xRv5_14_TMP = (RV5 INTERACT met_125xRv5_14) INTERACT 125xRv_array5
via_125xRv5_14 = via_125xRv5_14_TMP NOT (OR via_125xRv5_10_10a_10b_10c_10d_11_good via_125xRv5_12_good via_125xRv5_13_13a_good)
via_125xRv5_14_bad = RECTANGLE ENCLOSURE via_125xRv5_14 M6 ABUT<90 SINGULAR 
GOOD 0.01 0.02 OPPOSITE 0.01 0.02 OPPOSITE
via_125xRv5_14_good = via_125xRv5_14 NOT via_125xRv5_14_bad
//;end of the 125xRVn.EN.14 derivations
 
125xRv5_EN_14 {
@ 1.25xRVn array enclosed by 1.25xMn+1 for two opposite sides with the other two sides (rectangular 1.25xVn array edge length = 0.1um) >= 0.02um
@ Definition of rectangular 1.25xVn array:
@ 1.25xVn long side space = 0.08um (PRL = 0.10um) >= 0.01um
 err1 = copy via_125xRv5_14_bad
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xRv5_EN_15 {
@ 1.25xRVn enclosure by 1.25xMn+1 edge (between two consecutive 90-270 degree corners, length < 0.16um), when PRL > 0. >= 0.029um
 chk_edge = CONVEX EDGE M6 ANGLE1 == 90 ANGLE2 == 270 WITH LENGTH < 0.16
 err1_TMP = chk_edge TOUCH EDGE (EXT chk_edge M6_convex_270_90_edges < 0.005 ABUT==90 INTERSECTING ONLY REGION)
 err1 = ENC RV5 err1_TMP < 0.029 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xRv5_EN_16 {
@ 1.25xRVn enclosure by 1.25xMn+1 for two opposite sides (PRL > 0) with the other side enclosure < 0.04um (corresponding edge length < 0.16um between two consecutive 90-270 degree corners) >= 0.04um
 correspond_EDG = CONVEX EDGE M6 ANGLE1 == 90 ANGLE2 == 270 WITH LENGTH < 0.16
 correspond_ENC = ENC [RV5] correspond_EDG < 0.04 ABUT<90 OPPOSITE EXTENDED 0.001
 correspond_VIA_ENC_EDGE = RV5 TOUCH EDGE correspond_ENC
 correspond_VIA_EDG_CORN = INT [RV5] correspond_VIA_ENC_EDGE < 0.001 ABUT==90 INTERSECTING ONLY
 correspond_VIA_EDG = RV5 TOUCH EDGE correspond_VIA_EDG_CORN
 err1_RAW = ENC [correspond_VIA_EDG] M6 < 0.040 ABUT<90 OPPOSITE EXTENDED 0.001
 err1_TMP = INT correspond_VIA_ENC_EDGE (correspond_VIA_EDG TOUCH EDGE err1_RAW) < 0.005 ABUT==90 INTERSECTING ONLY REGION
 err1 = EXPAND EDGE (RV5 TOUCH EDGE err1_TMP) INSIDE BY 0.001
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xRv5_R_1 {
@ Single 1.25xRVn is not allowed in "H-shape" 1.25xMn+1, when:
@ 1. The 1.25xMn+1 has "H-shape" interacting with two metal holes: both two metal holes length <= 4.5um and two metal hole area <= 4.05um2
@ 2. The 1.25xRVn overlaps on the center metal bar of this "H-shape" 1.25xMn+1
@ 3. The center metal bar length <= 0.9um and the metal bar width <= 0.162um
@ DRC doesn't check when one or more square 1.25xRVn is also on H-shape 1.25xMn+1 region
 hole_area_meet = AREA (HOLES M6 INNER) <= 4.05
 hole_area_meet_len = (hole_area_meet WITH EDGE (LENGTH hole_area_meet <= 0.9)) NOT WITH EDGE (LENGTH hole_area_meet > 4.5)
 hole_area_real = (hole_area_meet_len NOT ENCLOSE RECTANGLE 0.9+GLOBAL_TOLERANCE 4.5) NOT ENCLOSE RECTANGLE 0.9 4.5+GLOBAL_TOLERANCE
 hole_bars_len = M6 COIN EDGE hole_area_real
 // 
 hole_bars = INT hole_bars_len <= 0.162 ABUT<90 OPPOSITE REGION EXCLUDE SHIELDED
 hole_bars_real = hole_bars WITH EDGE (LENGTH hole_bars_len <= 0.9)
 hole_bars_vias_rect = RV5 INTERACT ((hole_bars_real INTERACT hole_area_real == 2) NOT ENCLOSE V5N >= 2)
 err1 = hole_bars_real INTERACT hole_bars_vias_rect == 1
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xRv5_R_2 {
@ Redundant via requirement must be obeyed by one of following conditions of via numbers and space for 1.25xMy/1.25xMn, 1.25xMn+1 connection (one of 1.25xMy/1.25xMn or 1.25xMn+1 have width and length >= 0.164um, two square vias are equal to one rectangular via for below conditions) (Except VIA bar)
@ 1) At least one rectangular 1.25xVn
@ 2) At least two square 1.25xVn with space <= 0.091um
@ 3) At least four square 1.25xVn with space <= 0.59um
 X1a = WITH WIDTH M5 > 0.164-GLOBAL_TOLERANCE <= 0.398-GLOBAL_TOLERANCE
 X1b = WITH WIDTH M6 > 0.164-GLOBAL_TOLERANCE <= 0.398-GLOBAL_TOLERANCE
 Y1a = WITH WIDTH M5 > 0.398-GLOBAL_TOLERANCE
 Y1b = WITH WIDTH M6 > 0.398-GLOBAL_TOLERANCE
 WIDE_1 = (X1a AND M6) ENCLOSE V5
 WIDE_2 = (M5 AND X1b) ENCLOSE V5
 WIDE_3 = (Y1a AND M6) ENCLOSE V5
 WIDE_4 = (M5 AND Y1b) ENCLOSE V5
 WIDE_all_raw = (WIDE_1 OR WIDE_2) NOT (WIDE_3 OR WIDE_4)
 WIDE_all = (M5 AND M6) NOT OUTSIDE WIDE_all_raw
 // 
 // condition 1
 Y1_good = WIDE_all_raw AND RV5
 // condition 2
 Y2_wide_all = WIDE_all_raw NOT INTERACT Y1_good
 Y2_wide = (WIDE_all INTERACT Y2_wide_all) INTERACT V5_SR >= 2
 Y2_comb_step = SIZE V5_SR BY 0.091/2 INSIDE OF Y2_wide STEP 0.030
 Y2_good_step = OR (Y2_comb_step INTERACT V5N >= 2) (Y2_comb_step INTERACT RV5)
 Y2_good = WIDE_all_raw AND Y2_good_step
 // 
 // condition 3
 Y3_wide_all = WIDE_all_raw NOT INTERACT (OR Y1_good Y2_good)
 Y3_wide = (WIDE_all INTERACT Y3_wide_all) INTERACT V5_SR >= 2 // rectangle array 0.59/2=0.295
 Y3_vias_input = V5_SR AND Y3_wide
 Y3_wide_chk_1 = Y3_wide INTERACT Y3_wide_all
 Y3_comb_step1 = SIZE Y3_vias_input BY 0.04 INSIDE OF Y3_wide_chk_1 STEP 0.04 // via minimum space = 0.075
 Y3_good_step1 = OR (Y3_comb_step1 INTERACT V5N >= 4) (Y3_comb_step1 INTERACT RV5) // step1: 0.050
 // 
 Y3_wide_chk_2 = Y3_wide_chk_1 INTERACT (WIDE_all_raw NOT INTERACT Y3_good_step1)
 Y3_comb_step2 = SIZE Y3_comb_step1 BY 0.04 INSIDE OF Y3_wide_chk_2 STEP 0.04
 Y3_good_step2 = OR (Y3_comb_step2 INTERACT V5N >= 4) (Y3_comb_step2 INTERACT RV5) // step2: 0.04
 // 
 Y3_wide_chk_3 = Y3_wide_chk_2 INTERACT (WIDE_all_raw NOT INTERACT Y3_good_step2)
 Y3_comb_step3 = SIZE Y3_comb_step2 BY 0.04 INSIDE OF Y3_wide_chk_3 STEP 0.04
 Y3_good_step3 = OR (Y3_comb_step3 INTERACT V5N >= 4) (Y3_comb_step3 INTERACT RV5) // step3: 0.04
 // 
 Y3_wide_chk_4 = Y3_wide_chk_3 INTERACT (WIDE_all_raw NOT INTERACT Y3_good_step3)
 Y3_comb_step4 = SIZE Y3_comb_step3 BY 0.04 INSIDE OF Y3_wide_chk_4 STEP 0.04
 Y3_good_step4 = OR (Y3_comb_step4 INTERACT V5N >= 4) (Y3_comb_step4 INTERACT RV5) // step4: 0.04
 // 
 Y3_wide_chk_5 = Y3_wide_chk_4 INTERACT (WIDE_all_raw NOT INTERACT Y3_good_step4)
 Y3_comb_step5 = SIZE Y3_comb_step4 BY 0.04 INSIDE OF Y3_wide_chk_5 STEP 0.04
 Y3_good_step5 = OR (Y3_comb_step5 INTERACT V5N >= 4) (Y3_comb_step5 INTERACT RV5) // step5: 0.04
 // 
 Y3_wide_chk_6 = Y3_wide_chk_5 INTERACT (WIDE_all_raw NOT INTERACT Y3_good_step5)
 Y3_comb_step6 = SIZE Y3_comb_step5 BY 0.04 INSIDE OF Y3_wide_chk_6 STEP 0.04
 Y3_good_step6 = OR (Y3_comb_step6 INTERACT V5N >= 4) (Y3_comb_step6 INTERACT RV5) // step6: 0.04
 // 
 Y3_wide_chk_7 = Y3_wide_chk_6 INTERACT (WIDE_all_raw NOT INTERACT Y3_good_step6)
 Y3_comb_step7 = SIZE Y3_comb_step6 BY 0.04 INSIDE OF Y3_wide_chk_7 STEP 0.04
 Y3_good_step7 = OR (Y3_comb_step7 INTERACT V5N >= 4) (Y3_comb_step7 INTERACT RV5) // step7: 0.04
 // 
 Y3_wide_chk_8 = Y3_wide_chk_7 INTERACT (WIDE_all_raw NOT INTERACT Y3_good_step7)
 Y3_comb_step8 = SIZE Y3_comb_step7 BY 0.015 INSIDE OF Y3_wide_chk_8 STEP 0.015
 Y3_good_step8 = OR (Y3_comb_step8 INTERACT V5N >= 4) (Y3_comb_step8 INTERACT RV5) // step8: 0.295-0.04*7=0.015
 Y3_good = WIDE_all_raw AND (OR Y3_good_step1 Y3_good_step2 Y3_good_step3 Y3_good_step4 Y3_good_step5 Y3_good_step6 Y3_good_step7 Y3_good_step8)
 // 
 err1 = (WIDE_all_raw OUTSIDE (OR Y1_good Y2_good Y3_good)) INTERACT V5
 err1 NOT INTERACT 125xv5_BAR
}
 
125xRv5_R_3 {
@ Redundant via requirement must be obeyed by one of following conditions of 1.25xVn numbers and space for 1.25xMy/1.25xMn and 1.25xMn+1 connection (one of 1.25xMy/1.25xMn or 1.25xMn+1 have width and length >= 0.398um, two square vias are equal to one rectangular via for below conditions), except VIA bar, OCCD region
@ 1) At least 4 square 1.25xVn with space <= 0.091um
@ 2) At least 2 square 1.25xVn and 1 rectangular 1.25xVn with space <= 0.118um
@ 3) At least 9 square 1.25xVn with space <= 0.77um
@ For condition 2) and 3) 2 square 1.25xVn can be replaced by 1 rectangular 1.25xVn
 X1a = WITH WIDTH M5 > 0.398-GLOBAL_TOLERANCE
 X1b = WITH WIDTH M6 > 0.398-GLOBAL_TOLERANCE
 WIDE_1 = (X1a AND M6) ENCLOSE V5
 WIDE_2 = (M5 AND X1b) ENCLOSE V5
 WIDE_all_raw = WIDE_1 OR WIDE_2
 WIDE_all = (M5 AND M6) NOT OUTSIDE WIDE_all_raw
 // 
 // condition 1
 Y2_wide = WIDE_all INTERACT V5N >= 4
 Y2_vias_input = V5N AND Y2_wide
 Y2_wide_chk_1 = COPY Y2_wide // rectangle array 0.09/2=0.0455
 Y2_comb_step1 = SIZE Y2_vias_input BY 0.030 INSIDE OF Y2_wide_chk_1 STEP 0.030 // step1: 0.030, via minimum space = 0.056
 Y2_good_step1 = Y2_comb_step1 INTERACT V5N >= 4
 // 
 Y2_wide_chk_2 = Y2_wide_chk_1 INTERACT (WIDE_all_raw NOT INTERACT Y2_good_step1)
 Y2_comb_step2 = SIZE Y2_comb_step1 BY 0.0155 INSIDE OF Y2_wide_chk_2 STEP 0.015 // step2: 0.0155
 Y2_good_step2 = Y2_comb_step2 INTERACT V5N >= 4
 Y2_good = WIDE_all_raw AND (OR Y2_good_step1 Y2_good_step2)
 // 
 // condition 2
 Y1_wide_all = WIDE_all_raw NOT INTERACT Y2_good // rectangle array 0.118/2=0.059
 Y1_wide = (WIDE_all INTERACT Y1_wide_all) INTERACT V5 >= 2
 Y1_vias_input = V5 AND Y1_wide
 Y1_wide_chk_1 = Y1_wide INTERACT Y1_wide_all
 Y1_comb_step1 = SIZE Y1_vias_input BY 0.030 INSIDE OF Y1_wide_chk_1 STEP 0.030 // step1: 0.030, via minimum space = 0.100
 Y1_good_step1_a = Y1_comb_step1 INTERACT RV5 >= 2
 Y1_good_step1_b = (Y1_comb_step1 INTERACT V5N >= 2) INTERACT RV5 >= 1
 Y1_good_step1 = OR Y1_good_step1_a Y1_good_step1_b
 // 
 Y1_wide_chk_2 = Y1_wide_chk_1 INTERACT (WIDE_all_raw NOT INTERACT Y1_good_step1)
 Y1_comb_step2 = SIZE Y1_comb_step1 BY 0.029 INSIDE OF Y1_wide_chk_2 STEP 0.025 // step2: 0.059-0.030=0.029
 Y1_good_step2_a = Y1_comb_step2 INTERACT RV5 >= 2
 Y1_good_step2_b = (Y1_comb_step2 INTERACT V5N >= 2) INTERACT RV5 >= 1
 Y1_good_step2 = OR Y1_good_step2_a Y1_good_step2_b
 Y1_good = WIDE_all_raw AND (OR Y1_good_step1 Y1_good_step2)
 // 
 // condition 3
 Y3_wide_all = WIDE_all_raw NOT INTERACT (OR Y2_good Y1_good)
 Y3_wide = (WIDE_all INTERACT Y3_wide_all) INTERACT V5 >= 5
 Y3_vias_input = V5N AND Y3_wide
 Y3_wide_chk_1 = Y3_wide INTERACT Y3_wide_all // rectangle array 0.77/2=0.385
 Y3_comb_step1 = SIZE Y3_vias_input BY 0.070 INSIDE OF Y3_wide_chk_1 STEP 0.035 // step1: 0.070, via minimum space = 0.056
 Y3_good_step1_a = Y3_comb_step1 INTERACT V5N >= 9
 Y3_good_step1_b = (Y3_comb_step1 INTERACT V5N >= 7) INTERACT RV5 >= 1
 Y3_good_step1_c = (Y3_comb_step1 INTERACT V5N >= 5) INTERACT RV5 >= 2
 Y3_good_step1_d = (Y3_comb_step1 INTERACT V5N >= 3) INTERACT RV5 >= 3
 Y3_good_step1_e = (Y3_comb_step1 INTERACT V5N >= 1) INTERACT RV5 >= 4
 Y3_good_step1_f = Y3_comb_step1 INTERACT RV5 >= 5
 Y3_good_step1 = OR Y3_good_step1_a Y3_good_step1_b Y3_good_step1_c Y3_good_step1_d Y3_good_step1_e Y3_good_step1_f
 // 
 Y3_wide_chk_2 = Y3_wide_chk_1 INTERACT (WIDE_all_raw NOT INTERACT Y3_good_step1)
 Y3_comb_step2 = SIZE Y3_comb_step1 BY 0.035 INSIDE OF Y3_wide_chk_2 STEP 0.035 // step2: 0.035
 Y3_good_step2_a = Y3_comb_step2 INTERACT V5N >= 9
 Y3_good_step2_b = (Y3_comb_step2 INTERACT V5N >= 7) INTERACT RV5 >= 1
 Y3_good_step2_c = (Y3_comb_step2 INTERACT V5N >= 5) INTERACT RV5 >= 2
 Y3_good_step2_d = (Y3_comb_step2 INTERACT V5N >= 3) INTERACT RV5 >= 3
 Y3_good_step2_e = (Y3_comb_step2 INTERACT V5N >= 1) INTERACT RV5 >= 4
 Y3_good_step2_f = Y3_comb_step2 INTERACT RV5 >= 5
 Y3_good_step2 = OR Y3_good_step2_a Y3_good_step2_b Y3_good_step2_c Y3_good_step2_d Y3_good_step2_e Y3_good_step2_f
 // 
 Y3_wide_chk_3 = Y3_wide_chk_2 INTERACT (WIDE_all_raw NOT INTERACT Y3_good_step2)
 Y3_comb_step3 = SIZE Y3_comb_step2 BY 0.035 INSIDE OF Y3_wide_chk_3 STEP 0.035 // step3: 0.035
 Y3_good_step3_a = Y3_comb_step3 INTERACT V5N >= 9
 Y3_good_step3_b = (Y3_comb_step3 INTERACT V5N >= 7) INTERACT RV5 >= 1
 Y3_good_step3_c = (Y3_comb_step3 INTERACT V5N >= 5) INTERACT RV5 >= 2
 Y3_good_step3_d = (Y3_comb_step3 INTERACT V5N >= 3) INTERACT RV5 >= 3
 Y3_good_step3_e = (Y3_comb_step3 INTERACT V5N >= 1) INTERACT RV5 >= 4
 Y3_good_step3_f = Y3_comb_step3 INTERACT RV5 >= 5
 Y3_good_step3 = OR Y3_good_step3_a Y3_good_step3_b Y3_good_step3_c Y3_good_step3_d Y3_good_step3_e Y3_good_step3_f
 // 
 Y3_wide_chk_4 = Y3_wide_chk_3 INTERACT (WIDE_all_raw NOT INTERACT Y3_good_step3)
 Y3_comb_step4 = SIZE Y3_comb_step3 BY 0.035 INSIDE OF Y3_wide_chk_4 STEP 0.035 // step4: 0.035
 Y3_good_step4_a = Y3_comb_step4 INTERACT V5N >= 9
 Y3_good_step4_b = (Y3_comb_step4 INTERACT V5N >= 7) INTERACT RV5 >= 1
 Y3_good_step4_c = (Y3_comb_step4 INTERACT V5N >= 5) INTERACT RV5 >= 2
 Y3_good_step4_d = (Y3_comb_step4 INTERACT V5N >= 3) INTERACT RV5 >= 3
 Y3_good_step4_e = (Y3_comb_step4 INTERACT V5N >= 1) INTERACT RV5 >= 4
 Y3_good_step4_f = Y3_comb_step4 INTERACT RV5 >= 5
 Y3_good_step4 = OR Y3_good_step4_a Y3_good_step4_b Y3_good_step4_c Y3_good_step4_d Y3_good_step4_e Y3_good_step4_f
 // 
 Y3_wide_chk_5 = Y3_wide_chk_4 INTERACT (WIDE_all_raw NOT INTERACT Y3_good_step4)
 Y3_comb_step5 = SIZE Y3_comb_step4 BY 0.035 INSIDE OF Y3_wide_chk_5 STEP 0.035 // step5: 0.035
 Y3_good_step5_a = Y3_comb_step5 INTERACT V5N >= 9
 Y3_good_step5_b = (Y3_comb_step5 INTERACT V5N >= 7) INTERACT RV5 >= 1
 Y3_good_step5_c = (Y3_comb_step5 INTERACT V5N >= 5) INTERACT RV5 >= 2
 Y3_good_step5_d = (Y3_comb_step5 INTERACT V5N >= 3) INTERACT RV5 >= 3
 Y3_good_step5_e = (Y3_comb_step5 INTERACT V5N >= 1) INTERACT RV5 >= 4
 Y3_good_step5_f = Y3_comb_step5 INTERACT RV5 >= 5
 Y3_good_step5 = OR Y3_good_step5_a Y3_good_step5_b Y3_good_step5_c Y3_good_step5_d Y3_good_step5_e Y3_good_step5_f
 // 
 Y3_wide_chk_6 = Y3_wide_chk_5 INTERACT (WIDE_all_raw NOT INTERACT Y3_good_step5)
 Y3_comb_step6 = SIZE Y3_comb_step5 BY 0.035 INSIDE OF Y3_wide_chk_6 STEP 0.035 // step6: 0.035
 Y3_good_step6_a = Y3_comb_step6 INTERACT V5N >= 9
 Y3_good_step6_b = (Y3_comb_step6 INTERACT V5N >= 7) INTERACT RV5 >= 1
 Y3_good_step6_c = (Y3_comb_step6 INTERACT V5N >= 5) INTERACT RV5 >= 2
 Y3_good_step6_d = (Y3_comb_step6 INTERACT V5N >= 3) INTERACT RV5 >= 3
 Y3_good_step6_e = (Y3_comb_step6 INTERACT V5N >= 1) INTERACT RV5 >= 4
 Y3_good_step6_f = Y3_comb_step6 INTERACT RV5 >= 5
 Y3_good_step6 = OR Y3_good_step6_a Y3_good_step6_b Y3_good_step6_c Y3_good_step6_d Y3_good_step6_e Y3_good_step6_f
 // 
 Y3_wide_chk_7 = Y3_wide_chk_6 INTERACT (WIDE_all_raw NOT INTERACT Y3_good_step6)
 Y3_comb_step7 = SIZE Y3_comb_step6 BY 0.035 INSIDE OF Y3_wide_chk_7 STEP 0.035 // step7: 0.035
 Y3_good_step7_a = Y3_comb_step7 INTERACT V5N >= 9
 Y3_good_step7_b = (Y3_comb_step7 INTERACT V5N >= 7) INTERACT RV5 >= 1
 Y3_good_step7_c = (Y3_comb_step7 INTERACT V5N >= 5) INTERACT RV5 >= 2
 Y3_good_step7_d = (Y3_comb_step7 INTERACT V5N >= 3) INTERACT RV5 >= 3
 Y3_good_step7_e = (Y3_comb_step7 INTERACT V5N >= 1) INTERACT RV5 >= 4
 Y3_good_step7_f = Y3_comb_step7 INTERACT RV5 >= 5
 Y3_good_step7 = OR Y3_good_step7_a Y3_good_step7_b Y3_good_step7_c Y3_good_step7_d Y3_good_step7_e Y3_good_step7_f
 // 
 Y3_wide_chk_8 = Y3_wide_chk_7 INTERACT (WIDE_all_raw NOT INTERACT Y3_good_step7)
 Y3_comb_step8 = SIZE Y3_comb_step7 BY 0.035 INSIDE OF Y3_wide_chk_8 STEP 0.035 // step8: 0.035
 Y3_good_step8_a = Y3_comb_step8 INTERACT V5N >= 9
 Y3_good_step8_b = (Y3_comb_step8 INTERACT V5N >= 7) INTERACT RV5 >= 1
 Y3_good_step8_c = (Y3_comb_step8 INTERACT V5N >= 5) INTERACT RV5 >= 2
 Y3_good_step8_d = (Y3_comb_step8 INTERACT V5N >= 3) INTERACT RV5 >= 3
 Y3_good_step8_e = (Y3_comb_step8 INTERACT V5N >= 1) INTERACT RV5 >= 4
 Y3_good_step8_f = Y3_comb_step8 INTERACT RV5 >= 5
 Y3_good_step8 = OR Y3_good_step8_a Y3_good_step8_b Y3_good_step8_c Y3_good_step8_d Y3_good_step8_e Y3_good_step8_f
 // 
 Y3_wide_chk_9 = Y3_wide_chk_8 INTERACT (WIDE_all_raw NOT INTERACT Y3_good_step8)
 Y3_comb_step9 = SIZE Y3_comb_step8 BY 0.07 INSIDE OF Y3_wide_chk_9 STEP 0.035 // step9: 0.385-0.07-0.035*7=0.07
 Y3_good_step9_a = Y3_comb_step9 INTERACT V5N >= 9
 Y3_good_step9_b = (Y3_comb_step9 INTERACT V5N >= 7) INTERACT RV5 >= 1
 Y3_good_step9_c = (Y3_comb_step9 INTERACT V5N >= 5) INTERACT RV5 >= 2
 Y3_good_step9_d = (Y3_comb_step9 INTERACT V5N >= 3) INTERACT RV5 >= 3
 Y3_good_step9_e = (Y3_comb_step9 INTERACT V5N >= 1) INTERACT RV5 >= 4
 Y3_good_step9_f = Y3_comb_step9 INTERACT RV5 >= 5
 Y3_good_step9 = OR Y3_good_step9_a Y3_good_step9_b Y3_good_step9_c Y3_good_step9_d Y3_good_step9_e Y3_good_step9_f
 Y3_good = WIDE_all_raw AND (OR Y3_good_step1 Y3_good_step2 Y3_good_step3 Y3_good_step4 Y3_good_step5 Y3_good_step6 Y3_good_step7 Y3_good_step8 Y3_good_step9)
 // 
 err1 = (WIDE_all_raw OUTSIDE (OR Y1_good Y2_good Y3_good)) INTERACT V5
 (err1 NOT INTERACT 125xv5_BAR) NOT INSIDE OCCD
}
 
125xRv5_R_4_M5 {
@ There should be at least two square 1.25xVn or one rectangular 1.25xVn in the intersection area of bottom metal and upper metal, when either wide metal 1.25xMy/1.25xMn or 1.25xMn+1 length >= 0.162um and width >= 0.162um, the space between either via and wide metal <= 1.48um (S, S is the shortest running path length from Via to the wide metal). (except via bar)
@ DRC flags each intersecting area ({bottom metal AND upper metal}) with single square Via within the branch check region
 wide_M5 = (WITH WIDTH M5 > 0.162-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 0.162-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 0.162-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M5_real = wide_M5 NOT OUTSIDE ((SIZE wide_M5 BY 1.48+GLOBAL_TOLERANCE) INTERACT V5)
 all_down_and_up = (M5 INTERACT wide_M5) AND M6
 dis_down_arm_wide_all = SIZE wide_M5_real BY 1.48+GLOBAL_TOLERANCE INSIDE OF M5 STEP 0.025
 dis_down_and_up = dis_down_arm_wide_all AND all_down_and_up
 dis_down_and_up_arm = (dis_down_and_up NOT wide_M5) AND M5
 dis_down_arm = (dis_down_arm_wide_all NOT wide_M5) AND M5
 // 
 dis_down_arm_good_a = dis_down_and_up_arm INTERACT V5N >= 2
 dis_down_arm_good_b = dis_down_and_up_arm INTERACT RV5
 dis_down_arm_good = OR dis_down_arm_good_a dis_down_arm_good_b
 dis_down_arm_bad = (dis_down_and_up_arm NOT dis_down_arm_good) INTERACT (all_down_and_up INTERACT V5N == 1)
 // 
 dis_down_arm_err_stack = (dis_down_arm_bad AND dis_down_and_up_arm) INTERACT V5N
 dis_down_arm_err = dis_down_arm INTERACT dis_down_arm_err_stack
 err1_met_down = (dis_down_arm_err INTERACT (V5N NOT OUTSIDE dis_down_arm_err)) NOT INTERACT RV5
 // 
 wide_M6 = (WITH WIDTH M6 > 0.162-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 0.162-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 0.162-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M6_real = wide_M6 NOT OUTSIDE ((SIZE wide_M6 BY 1.48+GLOBAL_TOLERANCE) INTERACT V5)
 all_up_and_down = (M6 INTERACT wide_M6) AND M5
 dis_up_arm_wide_all = SIZE wide_M6_real BY 1.48+GLOBAL_TOLERANCE INSIDE OF M6 STEP 0.025
 dis_up_and_down = dis_up_arm_wide_all AND all_up_and_down
 dis_up_and_down_arm = (dis_up_and_down NOT wide_M6) AND M6
 dis_up_arm = (dis_up_arm_wide_all NOT wide_M6) AND M6
 // 
 dis_up_arm_good_a = dis_up_and_down_arm INTERACT V5N >= 2
 dis_up_arm_good_b = dis_up_and_down_arm INTERACT RV5
 dis_up_arm_good = OR dis_up_arm_good_a dis_up_arm_good_b
 dis_up_arm_bad = (dis_up_and_down_arm NOT dis_up_arm_good) INTERACT (all_up_and_down INTERACT V5N == 1)
 // 
 dis_up_arm_err_stack = (dis_up_arm_bad AND dis_up_and_down_arm) INTERACT V5N
 dis_up_arm_err = dis_up_arm INTERACT dis_up_arm_err_stack
 err2_met_up = (dis_up_arm_err INTERACT (V5N NOT OUTSIDE dis_up_arm_err)) NOT INTERACT RV5
 err1_met_down NOT INTERACT 125xv5_BAR
}
 
125xRv5_R_4_M6 {
@ There should be at least two square 1.25xVn or one rectangular 1.25xVn in the intersection area of bottom metal and upper metal, when either wide metal 1.25xMy/1.25xMn or 1.25xMn+1 length >= 0.162um and width >= 0.162um, the space between either via and wide metal <= 1.48um (S, S is the shortest running path length from Via to the wide metal). (except via bar)
@ DRC flags each intersecting area ({bottom metal AND upper metal}) with single square Via within the branch check region
 wide_M5 = (WITH WIDTH M5 > 0.162-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 0.162-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 0.162-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M5_real = wide_M5 NOT OUTSIDE ((SIZE wide_M5 BY 1.48+GLOBAL_TOLERANCE) INTERACT V5)
 all_down_and_up = (M5 INTERACT wide_M5) AND M6
 dis_down_arm_wide_all = SIZE wide_M5_real BY 1.48+GLOBAL_TOLERANCE INSIDE OF M5 STEP 0.025
 dis_down_and_up = dis_down_arm_wide_all AND all_down_and_up
 dis_down_and_up_arm = (dis_down_and_up NOT wide_M5) AND M5
 dis_down_arm = (dis_down_arm_wide_all NOT wide_M5) AND M5
 // 
 dis_down_arm_good_a = dis_down_and_up_arm INTERACT V5N >= 2
 dis_down_arm_good_b = dis_down_and_up_arm INTERACT RV5
 dis_down_arm_good = OR dis_down_arm_good_a dis_down_arm_good_b
 dis_down_arm_bad = (dis_down_and_up_arm NOT dis_down_arm_good) INTERACT (all_down_and_up INTERACT V5N == 1)
 // 
 dis_down_arm_err_stack = (dis_down_arm_bad AND dis_down_and_up_arm) INTERACT V5N
 dis_down_arm_err = dis_down_arm INTERACT dis_down_arm_err_stack
 err1_met_down = (dis_down_arm_err INTERACT (V5N NOT OUTSIDE dis_down_arm_err)) NOT INTERACT RV5
 // 
 wide_M6 = (WITH WIDTH M6 > 0.162-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 0.162-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 0.162-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M6_real = wide_M6 NOT OUTSIDE ((SIZE wide_M6 BY 1.48+GLOBAL_TOLERANCE) INTERACT V5)
 all_up_and_down = (M6 INTERACT wide_M6) AND M5
 dis_up_arm_wide_all = SIZE wide_M6_real BY 1.48+GLOBAL_TOLERANCE INSIDE OF M6 STEP 0.025
 dis_up_and_down = dis_up_arm_wide_all AND all_up_and_down
 dis_up_and_down_arm = (dis_up_and_down NOT wide_M6) AND M6
 dis_up_arm = (dis_up_arm_wide_all NOT wide_M6) AND M6
 // 
 dis_up_arm_good_a = dis_up_and_down_arm INTERACT V5N >= 2
 dis_up_arm_good_b = dis_up_and_down_arm INTERACT RV5
 dis_up_arm_good = OR dis_up_arm_good_a dis_up_arm_good_b
 dis_up_arm_bad = (dis_up_and_down_arm NOT dis_up_arm_good) INTERACT (all_up_and_down INTERACT V5N == 1)
 // 
 dis_up_arm_err_stack = (dis_up_arm_bad AND dis_up_and_down_arm) INTERACT V5N
 dis_up_arm_err = dis_up_arm INTERACT dis_up_arm_err_stack
 err2_met_up = (dis_up_arm_err INTERACT (V5N NOT OUTSIDE dis_up_arm_err)) NOT INTERACT RV5
 err2_met_up NOT INTERACT 125xv5_BAR
}
 
125xRv5_R_5_M5 {
@ There should be at least two square 1.25xVn or one rectangular 1.25xVn in the intersection area of bottom metal and upper metal, when either wide metal 1.25xMy/1.25xMn or 1.25xMn+1 length >= 0.91um and width >= 0.91um, the space between either via and wide metal <= 3.59um (S, S is the shortest running path length from Via to the wide metal). (except via bar)
@ DRC flags each intersecting area ({bottom metal AND upper metal}) with single square Via within the branch check region
 wide_M5 = (WITH WIDTH M5 > 0.91-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 0.91-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 0.91-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M5_real = wide_M5 NOT OUTSIDE ((SIZE wide_M5 BY 3.59+GLOBAL_TOLERANCE) INTERACT V5)
 all_down_and_up = (M5 INTERACT wide_M5) AND M6
 dis_down_arm_wide_all = SIZE wide_M5_real BY 3.59+GLOBAL_TOLERANCE INSIDE OF M5 STEP 0.025
 dis_down_and_up = dis_down_arm_wide_all AND all_down_and_up
 dis_down_and_up_arm = (dis_down_and_up NOT wide_M5) AND M5
 dis_down_arm = (dis_down_arm_wide_all NOT wide_M5) AND M5
 // 
 dis_down_arm_good_a = dis_down_and_up_arm INTERACT V5N >= 2
 dis_down_arm_good_b = dis_down_and_up_arm INTERACT RV5
 dis_down_arm_good = OR dis_down_arm_good_a dis_down_arm_good_b
 dis_down_arm_bad = (dis_down_and_up_arm NOT dis_down_arm_good) INTERACT (all_down_and_up INTERACT V5N == 1)
 // 
 dis_down_arm_err_stack = (dis_down_arm_bad AND dis_down_and_up_arm) INTERACT V5N
 dis_down_arm_err = dis_down_arm INTERACT dis_down_arm_err_stack
 err1_met_down = (dis_down_arm_err INTERACT (V5N NOT OUTSIDE dis_down_arm_err)) NOT INTERACT RV5
 // 
 wide_M6 = (WITH WIDTH M6 > 0.91-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 0.91-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 0.91-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M6_real = wide_M6 NOT OUTSIDE ((SIZE wide_M6 BY 3.59+GLOBAL_TOLERANCE) INTERACT V5)
 all_up_and_down = (M6 INTERACT wide_M6) AND M5
 dis_up_arm_wide_all = SIZE wide_M6_real BY 3.59+GLOBAL_TOLERANCE INSIDE OF M6 STEP 0.025
 dis_up_and_down = dis_up_arm_wide_all AND all_up_and_down
 dis_up_and_down_arm = (dis_up_and_down NOT wide_M6) AND M6
 dis_up_arm = (dis_up_arm_wide_all NOT wide_M6) AND M6
 // 
 dis_up_arm_good_a = dis_up_and_down_arm INTERACT V5N >= 2
 dis_up_arm_good_b = dis_up_and_down_arm INTERACT RV5
 dis_up_arm_good = OR dis_up_arm_good_a dis_up_arm_good_b
 dis_up_arm_bad = (dis_up_and_down_arm NOT dis_up_arm_good) INTERACT (all_up_and_down INTERACT V5N == 1)
 // 
 dis_up_arm_err_stack = (dis_up_arm_bad AND dis_up_and_down_arm) INTERACT V5N
 dis_up_arm_err = dis_up_arm INTERACT dis_up_arm_err_stack
 err2_met_up = (dis_up_arm_err INTERACT (V5N NOT OUTSIDE dis_up_arm_err)) NOT INTERACT RV5
 err1_met_down NOT INTERACT 125xv5_BAR
}
 
125xRv5_R_5_M6 {
@ There should be at least two square 1.25xVn or one rectangular 1.25xVn in the intersection area of bottom metal and upper metal, when either wide metal 1.25xMy/1.25xMn or 1.25xMn+1 length >= 0.91um and width >= 0.91um, the space between either via and wide metal <= 3.59um (S, S is the shortest running path length from Via to the wide metal). (except via bar)
@ DRC flags each intersecting area ({bottom metal AND upper metal}) with single square Via within the branch check region
 wide_M5 = (WITH WIDTH M5 > 0.91-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 0.91-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 0.91-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M5_real = wide_M5 NOT OUTSIDE ((SIZE wide_M5 BY 3.59+GLOBAL_TOLERANCE) INTERACT V5)
 all_down_and_up = (M5 INTERACT wide_M5) AND M6
 dis_down_arm_wide_all = SIZE wide_M5_real BY 3.59+GLOBAL_TOLERANCE INSIDE OF M5 STEP 0.025
 dis_down_and_up = dis_down_arm_wide_all AND all_down_and_up
 dis_down_and_up_arm = (dis_down_and_up NOT wide_M5) AND M5
 dis_down_arm = (dis_down_arm_wide_all NOT wide_M5) AND M5
 // 
 dis_down_arm_good_a = dis_down_and_up_arm INTERACT V5N >= 2
 dis_down_arm_good_b = dis_down_and_up_arm INTERACT RV5
 dis_down_arm_good = OR dis_down_arm_good_a dis_down_arm_good_b
 dis_down_arm_bad = (dis_down_and_up_arm NOT dis_down_arm_good) INTERACT (all_down_and_up INTERACT V5N == 1)
 // 
 dis_down_arm_err_stack = (dis_down_arm_bad AND dis_down_and_up_arm) INTERACT V5N
 dis_down_arm_err = dis_down_arm INTERACT dis_down_arm_err_stack
 err1_met_down = (dis_down_arm_err INTERACT (V5N NOT OUTSIDE dis_down_arm_err)) NOT INTERACT RV5
 // 
 wide_M6 = (WITH WIDTH M6 > 0.91-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 0.91-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 0.91-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M6_real = wide_M6 NOT OUTSIDE ((SIZE wide_M6 BY 3.59+GLOBAL_TOLERANCE) INTERACT V5)
 all_up_and_down = (M6 INTERACT wide_M6) AND M5
 dis_up_arm_wide_all = SIZE wide_M6_real BY 3.59+GLOBAL_TOLERANCE INSIDE OF M6 STEP 0.025
 dis_up_and_down = dis_up_arm_wide_all AND all_up_and_down
 dis_up_and_down_arm = (dis_up_and_down NOT wide_M6) AND M6
 dis_up_arm = (dis_up_arm_wide_all NOT wide_M6) AND M6
 // 
 dis_up_arm_good_a = dis_up_and_down_arm INTERACT V5N >= 2
 dis_up_arm_good_b = dis_up_and_down_arm INTERACT RV5
 dis_up_arm_good = OR dis_up_arm_good_a dis_up_arm_good_b
 dis_up_arm_bad = (dis_up_and_down_arm NOT dis_up_arm_good) INTERACT (all_up_and_down INTERACT V5N == 1)
 // 
 dis_up_arm_err_stack = (dis_up_arm_bad AND dis_up_and_down_arm) INTERACT V5N
 dis_up_arm_err = dis_up_arm INTERACT dis_up_arm_err_stack
 err2_met_up = (dis_up_arm_err INTERACT (V5N NOT OUTSIDE dis_up_arm_err)) NOT INTERACT RV5
 err2_met_up NOT INTERACT 125xv5_BAR
}
 
125xRv5_R_6_M5 {
@ There should be at least two square 1.25xVn or one rectangular 1.25xVn in the intersection area of bottom metal and upper metal, when either wide metal 1.25xMy/1.25xMn or 1.25xMn+1 length >= 1.36um and width >= 1.36um, the space between either via and wide metal <= 9um (S, S is the shortest running path length from Via to the wide metal). (except via bar)
@ DRC flags each intersecting area ({bottom metal AND upper metal}) with single square Via within the branch check region
 wide_M5 = (WITH WIDTH M5 > 1.36-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 1.36-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 1.36-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M5_real = wide_M5 NOT OUTSIDE ((SIZE wide_M5 BY 9+GLOBAL_TOLERANCE) INTERACT V5)
 all_down_and_up = (M5 INTERACT wide_M5) AND M6
 dis_down_arm_wide_all = SIZE wide_M5_real BY 9+GLOBAL_TOLERANCE INSIDE OF M5 STEP 0.025
 dis_down_and_up = dis_down_arm_wide_all AND all_down_and_up
 dis_down_and_up_arm = (dis_down_and_up NOT wide_M5) AND M5
 dis_down_arm = (dis_down_arm_wide_all NOT wide_M5) AND M5
 // 
 dis_down_arm_good_a = dis_down_and_up_arm INTERACT V5N >= 2
 dis_down_arm_good_b = dis_down_and_up_arm INTERACT RV5
 dis_down_arm_good = OR dis_down_arm_good_a dis_down_arm_good_b
 dis_down_arm_bad = (dis_down_and_up_arm NOT dis_down_arm_good) INTERACT (all_down_and_up INTERACT V5N == 1)
 // 
 dis_down_arm_err_stack = (dis_down_arm_bad AND dis_down_and_up_arm) INTERACT V5N
 dis_down_arm_err = dis_down_arm INTERACT dis_down_arm_err_stack
 err1_met_down = (dis_down_arm_err INTERACT (V5N NOT OUTSIDE dis_down_arm_err)) NOT INTERACT RV5
 // 
 wide_M6 = (WITH WIDTH M6 > 1.36-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 1.36-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 1.36-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M6_real = wide_M6 NOT OUTSIDE ((SIZE wide_M6 BY 9+GLOBAL_TOLERANCE) INTERACT V5)
 all_up_and_down = (M6 INTERACT wide_M6) AND M5
 dis_up_arm_wide_all = SIZE wide_M6_real BY 9+GLOBAL_TOLERANCE INSIDE OF M6 STEP 0.025
 dis_up_and_down = dis_up_arm_wide_all AND all_up_and_down
 dis_up_and_down_arm = (dis_up_and_down NOT wide_M6) AND M6
 dis_up_arm = (dis_up_arm_wide_all NOT wide_M6) AND M6
 // 
 dis_up_arm_good_a = dis_up_and_down_arm INTERACT V5N >= 2
 dis_up_arm_good_b = dis_up_and_down_arm INTERACT RV5
 dis_up_arm_good = OR dis_up_arm_good_a dis_up_arm_good_b
 dis_up_arm_bad = (dis_up_and_down_arm NOT dis_up_arm_good) INTERACT (all_up_and_down INTERACT V5N == 1)
 // 
 dis_up_arm_err_stack = (dis_up_arm_bad AND dis_up_and_down_arm) INTERACT V5N
 dis_up_arm_err = dis_up_arm INTERACT dis_up_arm_err_stack
 err2_met_up = (dis_up_arm_err INTERACT (V5N NOT OUTSIDE dis_up_arm_err)) NOT INTERACT RV5
 err1_met_down NOT INTERACT 125xv5_BAR
}
 
125xRv5_R_6_M6 {
@ There should be at least two square 1.25xVn or one rectangular 1.25xVn in the intersection area of bottom metal and upper metal, when either wide metal 1.25xMy/1.25xMn or 1.25xMn+1 length >= 1.36um and width >= 1.36um, the space between either via and wide metal <= 9um (S, S is the shortest running path length from Via to the wide metal). (except via bar)
@ DRC flags each intersecting area ({bottom metal AND upper metal}) with single square Via within the branch check region
 wide_M5 = (WITH WIDTH M5 > 1.36-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 1.36-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 1.36-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M5_real = wide_M5 NOT OUTSIDE ((SIZE wide_M5 BY 9+GLOBAL_TOLERANCE) INTERACT V5)
 all_down_and_up = (M5 INTERACT wide_M5) AND M6
 dis_down_arm_wide_all = SIZE wide_M5_real BY 9+GLOBAL_TOLERANCE INSIDE OF M5 STEP 0.025
 dis_down_and_up = dis_down_arm_wide_all AND all_down_and_up
 dis_down_and_up_arm = (dis_down_and_up NOT wide_M5) AND M5
 dis_down_arm = (dis_down_arm_wide_all NOT wide_M5) AND M5
 // 
 dis_down_arm_good_a = dis_down_and_up_arm INTERACT V5N >= 2
 dis_down_arm_good_b = dis_down_and_up_arm INTERACT RV5
 dis_down_arm_good = OR dis_down_arm_good_a dis_down_arm_good_b
 dis_down_arm_bad = (dis_down_and_up_arm NOT dis_down_arm_good) INTERACT (all_down_and_up INTERACT V5N == 1)
 // 
 dis_down_arm_err_stack = (dis_down_arm_bad AND dis_down_and_up_arm) INTERACT V5N
 dis_down_arm_err = dis_down_arm INTERACT dis_down_arm_err_stack
 err1_met_down = (dis_down_arm_err INTERACT (V5N NOT OUTSIDE dis_down_arm_err)) NOT INTERACT RV5
 // 
 wide_M6 = (WITH WIDTH M6 > 1.36-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 1.36-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 1.36-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M6_real = wide_M6 NOT OUTSIDE ((SIZE wide_M6 BY 9+GLOBAL_TOLERANCE) INTERACT V5)
 all_up_and_down = (M6 INTERACT wide_M6) AND M5
 dis_up_arm_wide_all = SIZE wide_M6_real BY 9+GLOBAL_TOLERANCE INSIDE OF M6 STEP 0.025
 dis_up_and_down = dis_up_arm_wide_all AND all_up_and_down
 dis_up_and_down_arm = (dis_up_and_down NOT wide_M6) AND M6
 dis_up_arm = (dis_up_arm_wide_all NOT wide_M6) AND M6
 // 
 dis_up_arm_good_a = dis_up_and_down_arm INTERACT V5N >= 2
 dis_up_arm_good_b = dis_up_and_down_arm INTERACT RV5
 dis_up_arm_good = OR dis_up_arm_good_a dis_up_arm_good_b
 dis_up_arm_bad = (dis_up_and_down_arm NOT dis_up_arm_good) INTERACT (all_up_and_down INTERACT V5N == 1)
 // 
 dis_up_arm_err_stack = (dis_up_arm_bad AND dis_up_and_down_arm) INTERACT V5N
 dis_up_arm_err = dis_up_arm INTERACT dis_up_arm_err_stack
 err2_met_up = (dis_up_arm_err INTERACT (V5N NOT OUTSIDE dis_up_arm_err)) NOT INTERACT RV5
 err2_met_up NOT INTERACT 125xv5_BAR
}
 
125xRv5_R_7 {
@ 45-degree 1.25xRVn is not allowed
 err1 = ANGLE (V5 NOT 125xv5_BAR) > 44.5 < 45.5
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 

#IFDEF Delta_Voltage_Rules_Check YES

125xRv5_R_8 {
@ Maximum delta V >= 5.6V is not allowed, when space between 1.25xRVn is < 0.410um
 chk_VIA = V5 INTERACT DVK_V5_RE
 err1 = DFM DV chk_VIA V5 < 0.410 DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" >= 5.6 ANNOTATE NOT CONNECTED SINGULAR
 DFM COPY err1
}

#ENDIF


// =======================================================
// 1.25xVn design rules
// =======================================================

GROUP G125xv6 125xv6_?
 
125xv6_BAR = (OR V6_BAR_100_all V6_BAR_450_all) INSIDE MARKS_MARKG
 
125xv6_W_1_L_1 {
@ 1.25xVn width and length, except 0.04*0.1um 1.25xVn, MARKS, MARKG and LOGO regions = 0.04um
 err1 = (V6 NOT RV6) NOT V6N
 err1 NOT INSIDE MARKS_MARKG_LOGO
}
 
125xv6_W_2 {
@ 1.25xVn bar width in MARKG/MARKS regions = 0.1, 0.45um
 err1 = (V6 NOT (OR V6_SR V6_BAR_100_all V6_BAR_450_all V6N_Seal_Ring)) INSIDE MARKS_MARKG
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xv6_S_1 {
@ Space between two 1.25xVn >= 0.056um
 err1 = EXT V6_SR < 0.056 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xv6_S_2 {
@ Space between two 1.25xVn when PRL > -0.04um. >= 0.074um
 err1 = EXT V6_SR < 0.074 ABUT<90 OPPOSITE EXTENDED 0.040 REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xv6_S_3 {
@ Space between 1.25xVn (1.25xVn enclosure by upper metal > 0um) and Vy/1.25xVn-1 at different net and PRL > 0um. >= 0.055um
 chk_via = (V6 INTERACT (V6N INSIDE M7)) NOT COIN EDGE M7
 err1 = EXT chk_via V5 < 0.055 ABUT<90 OPPOSITE REGION NOT CONNECTED
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xv6_S_4_M6 {
@ Space between two square 1.25xVn with PRL > -0.119um. >= 0.119um
@ When:
@ 1) 1.25xVn enclosure by 1.25xMy/1.25xMn/1.25xMn+1 < 0.01um at opposite side
@ 2) Space between 1.25xVn and 1.25xMy/1.25xMn/1.25xMn+1 <= 0.052um with PRL >= -0.046um at opposite side
@ DRC doesn't flag space between 1.25xVn and 1.25xMy/1.25xMn/1.25xMn+1 <= 0.052um with PRL >= -0.046um on both sides
 ncp_axis = ANGLE (ENC [V6N] M6 < 0.01 ABUT<90 OPPOSITE) == 0
 y1 = ANGLE (V6N TOUCH EDGE ncp_axis) == 0
 y2 = EXT [y1] M6 <= 0.052 ABUT<90 OPPOSITE EXTENDED 0.046+GLOBAL_TOLERANCE MEASURE ALL
 y3 = V6N TOUCH EDGE y2
 y4 = INT [V6N] y3 == 0.040 ABUT<90 OPPOSITE
 err1 = EXT (y4 NOT TOUCH EDGE y2) V6_SR < 0.119 ABUT<90 OPPOSITE EXTENDED 0.119 REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xv6_S_4_M7 {
@ Space between two square 1.25xVn with PRL > -0.119um. >= 0.119um
@ When:
@ 1) 1.25xVn enclosure by 1.25xMy/1.25xMn/1.25xMn+1 < 0.01um at opposite side
@ 2) Space between 1.25xVn and 1.25xMy/1.25xMn/1.25xMn+1 <= 0.052um with PRL >= -0.046um at opposite side
@ DRC doesn't flag space between 1.25xVn and 1.25xMy/1.25xMn/1.25xMn+1 <= 0.052um with PRL >= -0.046um on both sides
 ncp_axis = ANGLE (ENC [V6N] M7 < 0.01 ABUT<90 OPPOSITE) == 90
 y1 = ANGLE (V6N TOUCH EDGE ncp_axis) == 90
 y2 = EXT [y1] M7 <= 0.052 ABUT<90 OPPOSITE EXTENDED 0.046+GLOBAL_TOLERANCE MEASURE ALL
 y3 = V6N TOUCH EDGE y2
 y4 = INT [V6N] y3 == 0.040 ABUT<90 OPPOSITE
 err1 = EXT (y4 NOT TOUCH EDGE y2) V6_SR < 0.119 ABUT<90 OPPOSITE EXTENDED 0.119 REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xv6_S_5 {
@ Space between 1.25xVn bar (width = 0.1/0.45um) and (1.25xVn or 1.25xRVn) >= 0.34um
 err1 = EXT (OR V6_BAR_100_all V6_BAR_450_all) V6_SR < 0.34 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xv6_S_6 {
@ Space between 1.25xVn bar (width = 0.1/0.45um), DRC only check the space between parallel edge when the 1.25xVn bar is inside MARKS >= 0.55um
 err1 = EXT ((OR V6_BAR_100_all V6_BAR_450_all) INTERACT MARKS_MARKG) < 0.55 SINGULAR ANGLED!=1 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xv6_EN_1 {
@ 1.25xVn must be fully enclosed by 1.25xMy or 1.25xMn where 1.25xMy or 1.25xMn is the metal layer direct underneath 1.25xVn
@ Enclosure by 1.25xMy or 1.25xMn must follow one of 1.25xVn.EN.2 or 1.25xVn.EN.3 or 1.25xVn.EN.4 or 1.25xVn.EN.5 or 1.25xVn.EN.6 or 1.25xVn.EN.7
 err1 = V6N NOT M6
 err1 NOT INSIDE SealR_NOT_BULK
}
 
//;beginning of the 125xVn.EN.2 derivations
met_125xv6_2 = M6 WITH WIDTH == 0.040
via_125xv6_2 = V6N NOT OUTSIDE met_125xv6_2
via_125xv6_2_bad = RECTANGLE ENCLOSURE via_125xv6_2 M6 ABUT<90 SINGULAR 
GOOD 0 0.049 OPPOSITE 0 0.049 OPPOSITE
via_125xv6_2_good = via_125xv6_2 NOT via_125xv6_2_bad
//;end of the 125xVn.EN.2 derivations
 
125xv6_EN_2 {
@ 1.25xVn enclosure by 1.25xMy or 1.25xMn (width = 0.04um) for two opposite sides with the other two sides >= 0um. >= 0.049um
 err1 = COPY via_125xv6_2_bad
 err1 NOT INSIDE SealR_NOT_BULK
}
 
//;beginning of the 125xVn.EN.2a derivations
met_125xv6_2a = M6 WITH WIDTH == 0.042
via_125xv6_2a = V6N NOT OUTSIDE met_125xv6_2a
via_125xv6_2a_bad = RECTANGLE ENCLOSURE via_125xv6_2a M6 ABUT<90 SINGULAR 
GOOD 0.001 0.049 OPPOSITE 0.001 0.049 OPPOSITE
via_125xv6_2a_good = via_125xv6_2a NOT via_125xv6_2a_bad
//;end of the 125xVn.EN.2a derivations
 
125xv6_EN_2a {
@ 1.25xVn enclosure by 1.25xMy or 1.25xMn (width = 0.042um) for two opposite sides with the other two sides >= 0.001um. >= 0.049um
 err1 = via_125xv6_2a_bad NOT via_125xv6_2_good
 err1 NOT INSIDE SealR_NOT_BULK
}
 
//;beginning of the 125xVn.EN.3 derivations
met_125xv6_3 = M6 WITH WIDTH == 0.044
via_125xv6_3 = V6N NOT OUTSIDE met_125xv6_3
via_125xv6_3_bad = RECTANGLE ENCLOSURE via_125xv6_3 M6 ABUT<90 SINGULAR 
GOOD 0.002 0.049 OPPOSITE 0.002 0.049 OPPOSITE
via_125xv6_3_good = via_125xv6_3 NOT via_125xv6_3_bad
//;end of the 125xVn.EN.3 derivations
 
125xv6_EN_3 {
@ 1.25xVn enclosure by 1.25xMy or 1.25xMn (width = 0.044um) for two opposite sides with the other two sides >= 0.002um. >= 0.049um
 err1 = via_125xv6_3_bad NOT (OR via_125xv6_2_good via_125xv6_2a_good)
 err1 NOT INSIDE SealR_NOT_BULK
}
 
//;beginning of the 125xVn.EN.3a derivations
met_125xv6_4 = M6 WITH WIDTH == 0.046
via_125xv6_4 = V6N NOT OUTSIDE met_125xv6_4
via_125xv6_4_bad = RECTANGLE ENCLOSURE via_125xv6_4 M6 ABUT<90 SINGULAR 
GOOD 0.003 0.049 OPPOSITE 0.003 0.049 OPPOSITE
via_125xv6_4_good = via_125xv6_4 NOT via_125xv6_4_bad
//;end of the 125xVn.EN.3a derivations
 
125xv6_EN_4 {
@ 1.25xVn enclosure by 1.25xMy or 1.25xMn (width = 0.046um) for two opposite sides with the other two sides >= 0.003um. >= 0.049um
 err1 = via_125xv6_4_bad NOT (OR via_125xv6_2_good via_125xv6_2a_good via_125xv6_3_good)
 err1 NOT INSIDE SealR_NOT_BULK
}
 
//;beginning of the 125xVn.EN.5 derivations
met_125xv6_5 = M6 WITH WIDTH >= 0.060 < 0.08
via_125xv6_5 = V6N NOT OUTSIDE met_125xv6_5
via_125xv6_5_bad = RECTANGLE ENCLOSURE via_125xv6_5 M6 ABUT<90 SINGULAR 
GOOD 0.01 0.049 OPPOSITE 0.01 0.049 OPPOSITE
via_125xv6_5_good = via_125xv6_5 NOT via_125xv6_5_bad
//;end of the 125xVn.EN.5 derivations
 
125xv6_EN_5 {
@ 1.25xVn enclosure by 1.25xMy or 1.25xMn (0.06 <= width < 0.08um) for two opposite sides with the other two sides >= 0.01um. >= 0.049um
 err1 = via_125xv6_5_bad NOT (OR via_125xv6_2_good via_125xv6_2a_good via_125xv6_3_good via_125xv6_4_good)
 err1 NOT INSIDE SealR_NOT_BULK
}
 
// 125xVn.EN.5: purposely blank
 
//;beginning of the 125xVn.EN.6 derivations
met_125xv6_6 = M6 WITH WIDTH == 0.080
via_125xv6_6 = V6N NOT OUTSIDE met_125xv6_6
via_125xv6_6_bad = RECTANGLE ENCLOSURE via_125xv6_6 M6 ABUT<90 SINGULAR 
GOOD 0.02 0.02 0.02 0.02 OPPOSITE
via_125xv6_6_good = via_125xv6_6 NOT via_125xv6_6_bad
//;end of the 125xVn.EN.6 derivations
via_125xv6_2_3_4_good = OR via_125xv6_2_good via_125xv6_2a_good via_125xv6_3_good via_125xv6_4_good via_125xv6_5_good
via_125xv6_2_3_4_6_good = OR via_125xv6_2_3_4_good via_125xv6_6_good
 
125xv6_EN_6 {
@ 1.25xVn enclosure by 1.25xMy or 1.25xMn (width = 0.08um) for all sides >= 0.02um
 err1 = via_125xv6_6_bad NOT via_125xv6_2_3_4_good
 err1 NOT INSIDE SealR_NOT_BULK
 err2 = ENC via_125xv6_6 M6 < 0.02 ABUT<90 SINGULAR REGION //for via corner enclosure check
 err2 NOT INSIDE SealR_NOT_BULK
}
 
//;beginning of the 125xVn.EN.7 derivations
met_125xv6_7 = M6 WITH WIDTH > 0.080
via_125xv6_7 = V6N NOT OUTSIDE met_125xv6_7
via_125xv6_7_bad = RECTANGLE ENCLOSURE via_125xv6_7 M6 ABUT<90 SINGULAR 
GOOD 0.02 0.029 OPPOSITE 0.02 0.029 OPPOSITE
via_125xv6_7_good = via_125xv6_7 NOT via_125xv6_7_bad
//;end of the 125xVn.EN.7 derivations
 
125xv6_EN_7 {
@ 1.25xVn enclosure by 1.25xMy or 1.25xMn (width > 0.08um) for two opposite sides with the other two sides >= 0.02um. >= 0.029um
 err1 = via_125xv6_7_bad NOT via_125xv6_2_3_4_6_good
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xv6_EN_8 {
@ 1.25xVn bar enclosure by 1.25xMy or 1.25xMn >= 0.098um
 err1 = (V6_BAR_100_all OR V6_BAR_450_all) NOT M6
 err2 = ENC V6_BAR_100_all M6 < 0.098 ABUT<90 SINGULAR REGION
 err3 = ENC V6_BAR_450_all M6 < 0.098 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
}
 
125xv6_EN_9 {
@ 1.25xVn must be fully enclosed by 1.25xMn+1 where 1.25xMn+1 is the metal layer directly above 1.25xVn
@ Enclosure by 1.25xMn+1 must follow one of 1.25xVn.EN.10 or 1.25xVn.EN.11 or 1.25xVn.EN.12 or 1.25xVn.EN.13 or 1.25xVn.EN.14
 err1 = V6N NOT M7
 err1 NOT INSIDE SealR_NOT_BULK
}
 
//;beginning of the 125xVn.EN.10 derivations
met_125xv6_10 = M7 WITH WIDTH == 0.040
via_125xv6_10 = V6N NOT OUTSIDE met_125xv6_10
via_125xv6_10_bad = RECTANGLE ENCLOSURE via_125xv6_10 M7 ABUT<90 SINGULAR 
GOOD 0 0.049 OPPOSITE 0 0.049 OPPOSITE
via_125xv6_10_good = via_125xv6_10 NOT via_125xv6_10_bad
//;end of the 125xVn.EN.10 derivations
 
125xv6_EN_10 {
@ 1.25xVn enclosure by 1.25xMn+1 (width = 0.04um) for two opposite sides with the other two sides >= 0um. >= 0.049um
 err1 = copy via_125xv6_10_bad
 err1 NOT INSIDE SealR_NOT_BULK
}
 
//;beginning of the 125xVn.EN.10a derivations
met_125xv6_10a = M7 WITH WIDTH == 0.042
via_125xv6_10a = V6N NOT OUTSIDE met_125xv6_10a
via_125xv6_10a_bad = RECTANGLE ENCLOSURE via_125xv6_10a M7 ABUT<90 SINGULAR 
GOOD 0.001 0.049 OPPOSITE 0.001 0.049 OPPOSITE
via_125xv6_10a_good = via_125xv6_10a NOT via_125xv6_10a_bad
//;end of the 125xVn.EN.10a derivations
 
125xv6_EN_10a {
@ 1.25xVn enclosure by 1.25xMn+1 (width = 0.042um) for two opposite sides with the other two sides >= 0.001um. >= 0.049um
 err1 = via_125xv6_10a_bad NOT via_125xv6_10_good
 err1 NOT INSIDE SealR_NOT_BULK
}
 
//;beginning of the 125xVn.EN.11 derivations
met_125xv6_11 = M7 WITH WIDTH == 0.044
via_125xv6_11_TMP = V6N NOT OUTSIDE met_125xv6_11
via_125xv6_11 = via_125xv6_11_TMP NOT via_125xv6_10_good
via_125xv6_11_bad = RECTANGLE ENCLOSURE via_125xv6_11 M7 ABUT<90 SINGULAR 
GOOD 0.002 0.049 OPPOSITE 0.002 0.049 OPPOSITE
via_125xv6_11_good = via_125xv6_11 NOT via_125xv6_11_bad
//;end of the 125xVn.EN.11 derivations
 
125xv6_EN_11 {
@ 1.25xVn enclosure by 1.25xMn+1 (width = 0.044um) for two opposite sides with the other two sides >= 0.002um. >= 0.049um
 err1 = via_125xv6_11_bad NOT (OR via_125xv6_10_good via_125xv6_10a_good)
 err1 NOT INSIDE SealR_NOT_BULK
}
 
//;beginning of the 125xVn.EN.11 derivations
met_125xv6_11a = M7 WITH WIDTH == 0.046
via_125xv6_11a = V6N NOT OUTSIDE met_125xv6_11a
via_125xv6_11a_bad = RECTANGLE ENCLOSURE via_125xv6_11a M7 ABUT<90 SINGULAR 
GOOD 0.003 0.049 OPPOSITE 0.003 0.049 OPPOSITE
via_125xv6_11a_good = via_125xv6_11a NOT via_125xv6_11a_bad
//;end of the 125xVn.EN.11 derivations
 
125xv6_EN_11a {
@ 1.25xVn enclosure by 1.25xMn+1 (width = 0.046um) for two opposite sides with the other two sides >= 0.003um. >= 0.049um
 err1 = via_125xv6_11a_bad NOT (OR via_125xv6_10_good via_125xv6_10a_good via_125xv6_11_good)
 err1 NOT INSIDE SealR_NOT_BULK
}
 
//;beginning of the 125xVn.EN.12 derivations
met_125xv6_12 = M7 WITH WIDTH >= 0.060 < 0.08
via_125xv6_12 = V6N NOT OUTSIDE met_125xv6_12
via_125xv6_12_bad = RECTANGLE ENCLOSURE via_125xv6_12 M7 ABUT<90 SINGULAR 
GOOD 0.01 0.049 OPPOSITE 0.01 0.049 OPPOSITE
via_125xv6_12_good = via_125xv6_12 NOT via_125xv6_12_bad
//;end of the 125xVn.EN.12 derivations
via_125xv6_10_11_good = OR via_125xv6_10_good via_125xv6_10a_good via_125xv6_11_good via_125xv6_11a_good
via_125xv6_10_11_12_good = OR via_125xv6_10_11_good via_125xv6_12_good
 
125xv6_EN_12 {
@ 1.25xVn enclosure by 1.25xMn+1 (0.06 <= width < 0.08um) for two opposite sides with the other two sides >= 0.01um. >= 0.049um
 err1 = via_125xv6_12_bad NOT via_125xv6_10_11_good
 err1 NOT INSIDE SealR_NOT_BULK
}
 
//;beginning of the 125xVn.EN.13 derivations
met_125xv6_13 = M7 WITH WIDTH == 0.080
via_125xv6_13 = V6N NOT OUTSIDE met_125xv6_13
via_125xv6_13_bad = RECTANGLE ENCLOSURE via_125xv6_13 M7 ABUT<90 SINGULAR 
GOOD 0.02 0.02 0.02 0.02 OPPOSITE
via_125xv6_13_good = via_125xv6_13 NOT via_125xv6_13_bad
//;end of the 125xVn.EN.13 derivations
 
125xv6_EN_13 {
@ 1.25xVn enclosure by 1.25xMn+1 (width = 0.08um) for all sides >= 0.02um
 err1 = via_125xv6_13_bad NOT via_125xv6_10_11_12_good
 err1 NOT INSIDE SealR_NOT_BULK
 err2 = ENC via_125xv6_13 M7 < 0.02 ABUT<90 SINGULAR REGION //for via corner enclosure check
 err2 NOT INSIDE SealR_NOT_BULK
}
 
//;beginning of the 125xVn.EN.14 derivations
met_125xv6_14 = M7 WITH WIDTH > 0.080
via_125xv6_14 = V6N NOT OUTSIDE met_125xv6_14
via_125xv6_14_bad = RECTANGLE ENCLOSURE via_125xv6_14 M7 ABUT<90 SINGULAR 
GOOD 0.02 0.029 OPPOSITE 0.02 0.029 OPPOSITE
via_125xv6_14_good = via_125xv6_14 NOT via_125xv6_14_bad
//;end of the 125xVn.EN.14 derivations
 
125xv6_EN_14 {
@ 1.25xVn enclosure by 1.25xMn+1 (width > 0.08um) for two opposite sides with the other two sides >= 0.02um. >= 0.029um
 err1 = via_125xv6_14_bad NOT (OR via_125xv6_10_11_12_good via_125xv6_13_good)
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xv6_EN_15 {
@ 1.25xVn enclosure by 1.25xMn+1 edge (between two consecutive 90-270 degree corners, length < 0.16um), when PRL > 0um. >= 0.029um
 chk_edge = CONVEX EDGE M7 ANGLE1 == 90 ANGLE2 == 270 WITH LENGTH < 0.16
 err1_TMP = chk_edge TOUCH EDGE (EXT chk_edge M7_convex_270_90_edges < 0.005 ABUT==90 INTERSECTING ONLY REGION)
 err1 = ENC V6N err1_TMP < 0.029 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xv6_EN_16 {
@ 1.25xVn enclosure by 1.25xMn+1 for two opposite sides (PRL > 0) with the other side enclosure < 0.04um (corresponding edge length < 0.16um between two consecutive 90-270 degree corners) >= 0.04um
 correspond_EDG = CONVEX EDGE M7 ANGLE1 == 90 ANGLE2 == 270 WITH LENGTH < 0.16
 correspond_ENC = ENC [V6N] correspond_EDG < 0.04 ABUT<90 OPPOSITE EXTENDED 0.001
 correspond_VIA_ENC_EDGE = V6N TOUCH EDGE correspond_ENC
 correspond_VIA_EDG_CORN = INT [V6N] correspond_VIA_ENC_EDGE < 0.001 ABUT==90 INTERSECTING ONLY
 correspond_VIA_EDG = V6N TOUCH EDGE correspond_VIA_EDG_CORN
 err1_RAW = ENC [correspond_VIA_EDG] M7 < 0.040 ABUT<90 OPPOSITE EXTENDED 0.001
 err1_TMP = INT correspond_VIA_ENC_EDGE (correspond_VIA_EDG TOUCH EDGE err1_RAW) < 0.005 ABUT==90 INTERSECTING ONLY REGION
 err1 = EXPAND EDGE (V6N TOUCH EDGE err1_TMP) INSIDE BY 0.001
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xv6_EN_17 {
@ 1.25xVn bar fully enclosure by 1.25xMn+1 >= 0.2um
 err1 = (V6_BAR_100_all OR V6_BAR_450_all) NOT M7
 err2 = ENC V6_BAR_100_all M7 < 0.2 ABUT<90 SINGULAR REGION
 err3 = ENC V6_BAR_450_all M7 < 0.2 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
}

#IFDEF RECOMMENDED_CHECK YES

 
125xv6_D_1_R {
@ (1.25xVn OR 1.25xRVn) density (window 5um*5um, stepping 2.5um) < 12%
 check_region = copy CHIP_NOT_MARKS
 check_pattern = (V6 NOT 125xv6_BAR) AND check_region
 // 
 check_window1 = check_region WITH WIDTH >= 5/4
 err1_TMP1 = DENSITY check_pattern check_window1 check_region [!!AREA(check_window1)*AREA(check_pattern)/AREA(check_region)] >= 12/100 WINDOW 5 STEP 5/2 BACKUP INSIDE OF LAYER DRC:1 BY POLYGON
 // 
 check_window2 = WITH WIDTH (check_region AND err1_TMP1) >= 5/4
 err1_TMP2 = DENSITY check_pattern check_window2 check_region [!!AREA(check_window2)*AREA(check_pattern)/AREA(check_region)] >= 12/100 WINDOW 5 STEP 5/2 BACKUP INSIDE OF LAYER err1_TMP1 BY POLYGON
 // 
 check_window3 = WITH WIDTH (check_region AND err1_TMP2) >= 5/4
 DENSITY check_pattern check_window3 check_region [!!AREA(check_window3)*AREA(check_pattern)/AREA(check_region)] >= 12/100 WINDOW 5 STEP 5/2 BACKUP INSIDE OF LAYER err1_TMP2 BY POLYGON PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_125xv6_D_1_R.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_125xv6_D_1_R.rdb"
}

#ENDIF

 
125xv6_R_1 {
@ 45-degree 1.25xVn is not allowed
 err1 = ANGLE (V6 NOT 125xv6_BAR) > 44.5 < 45.5
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
125xv6_R_2 {
@ It is not allowed to have single 1.25xVn in "H-shape" 1.25xMn+1 when all of the following conditions come into existence:
@ 1) The 1.25xMn+1 has "H-shape" interact two metal holes: both two metal hole length <= 4.5um and two metal hole area <= 4.05um2
@ 2) The 1.25xVn overlaps on the center metal bar of this "H-shape" 1.25xMn+1
@ 3) The center metal bar length <= 0.9um and the metal bar width <= 0.162um
 hole_area_meet = AREA (HOLES M7 INNER) <= 4.05
 hole_area_meet_len = (hole_area_meet WITH EDGE (LENGTH hole_area_meet <= 0.9)) NOT WITH EDGE (LENGTH hole_area_meet > 4.5)
 hole_area_real = (hole_area_meet_len NOT ENCLOSE RECTANGLE 0.9+GLOBAL_TOLERANCE 4.5) NOT ENCLOSE RECTANGLE 0.9 4.5+GLOBAL_TOLERANCE
 hole_bars_len = M7 COIN EDGE hole_area_real
 // 
 hole_bars = INT hole_bars_len <= 0.162 ABUT<90 OPPOSITE REGION EXCLUDE SHIELDED
 hole_bars_real = hole_bars WITH EDGE (LENGTH hole_bars_len <= 0.9)
 hole_bars_vias_sq = V6N INTERACT ((hole_bars_real INTERACT hole_area_real == 2) NOT ENCLOSE RV6)
 err1 = hole_bars_real INTERACT hole_bars_vias_sq == 1
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xv6_R_3 {
@ The numbers of neighboring square 1.25xVn to each edge of 1.25xVn <= 0.065um is not allowed < 2
 // based on 125xVn.S.6 and 125xVn.S.1, so only check the space range 0.056~0.065um with PRL <= 0.04
 Y1 = EXT V6N >= 0.056 <= 0.065 ABUT CORNER TO CORNER
 Y2 = DFM PROPERTY Y1 [-= (EWXP(Y1) > 0.040 && EWYP(Y1) > 0.040) ? 1 : 0] > 0
 Y3 = INT [V6N] < 0.001 ABUT INTERSECTING ONLY
 Y4 = Y3 COIN EDGE (DFM COPY Y2 EDGE)
 Y5 = INT Y4 V6N < 0.001 ABUT==90 INTERSECTING ONLY REGION
 Y6 = INT (V6N COIN EDGE Y5) == 0.040 OPPOSITE REGION
 err1 = V6N INTERACT Y6
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xv6_R_4 {
@ The numbers of neighboring square 1.25xVn in one group (space <= 0.065um) <= 3
 err1 = WITH NEIGHBOR V6N > 2 SPACE <= 0.065
 err1 NOT INSIDE SealR_NOT_BULK
}
 

#IFDEF Delta_Voltage_Rules_Check YES

125xv6_R_5 {
@ Maximum delta V >= 5.6V is not allowed, when space between 1.25xVn is < 0.410um
 chk_VIA = V6 INTERACT DVK_V6_SQ
 err1 = DFM DV chk_VIA V6 < 0.410 DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" >= 5.6 ANNOTATE NOT CONNECTED SINGULAR
 DFM COPY err1
}

#ENDIF

// 1.25xVn.R.8[NC] 1.25xVn pattern must be drawn on data type 50
 
125xv6_R_9 {
@ It's not allowed 1.25xVn overlap with the metal resistor directly underneath and above the 1.25xVn
 err1 = V6 AND (M6RES AND M6)
 err2 = V6 AND (M7RES AND M7)
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

#IFDEF RECOMMENDED_CHECK YES

 
125xv6_R_10_R {
@ Recommend space between a square 1.25xVn and another (1.25xVn OR 1.25xRVn OR DUM_1.25xVn) < 4um to avoid single square 1.25xVn
 ALL_VIA_CHECK = OR V6_SR V6DUM_all V6DOP_all
 STEP_1 = SIZE V6_SR BY 1.4
 // 4/1.414 = 2.828
 STEP_1_GOOD = STEP_1 INTERACT ALL_VIA_CHECK > 1
 STEP_1_FILTER = V6N NOT INTERACT STEP_1_GOOD
 err1 = STEP_1_FILTER NOT WITH EDGE (EXT [STEP_1_FILTER] ALL_VIA_CHECK < 4 PERP ALSO)
 err1 NOT INSIDE SealR_NOT_BULK
}

#ENDIF


// =======================================================
// 1.25xVn design rules: Rectangular 1.25xVn
// =======================================================

GROUP G125xRv6 125xRv6_?
 
125xRv6_W_1_L_1 {
@ 1.25xRVn.W.1: 1.25xRVn width, except MARKS, MARKG and LOGO regions = 0.04um
@ 1.25xRVn.L.1: Length of 1.25xRVn (width = 0.04um) = 0.1um
 err1 = (V6 NOT V6N) NOT RV6
 err1 NOT INSIDE MARKS_MARKG_LOGO
}
 
125xRv6_S_1a {
@ Space between (1.25xVn or 1.25xRVn) and 1.25xRVn >= 0.074um
 err1 = EXT RV6 V6_SR < 0.074 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xRv6_S_1b {
@ Space between (1.25xVn or 1.25xRVn) and 1.25xRVn when PRL > -0.04um. >= 0.079um
 err1 = EXT RV6 V6_SR < 0.079 ABUT<90 OPPOSITE EXTENDED 0.04 REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xRv6_S_1c {
@ Space between the short side of 1.25xRVn and (1.25xVn or 1.25xRVn) when PRL > -0.04um. >= 0.089um
 err1 = EXT RV6_W V6_SR < 0.089 ABUT<90 OPPOSITE EXTENDED 0.04 REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xRv6_S_3 {
@ Space between 1.25xRVn and (1.25xRVn-1 or 1.25xVn-1) at different net and PRL > 0um, when 1.25xMn+1 enclosure of 1.25xRVn > 0um. >= 0.055um
 chk_via = (V6 INTERACT RV6) NOT COIN EDGE M7
 err1 = EXT chk_via V5 < 0.055 ABUT<90 OPPOSITE REGION NOT CONNECTED
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xRv6_S_4_M6 {
@ Space between 1.25xRVn when PRL >= -0.119um. >= 0.119um
@ When:
@ 1) 1.25xRVn enclosure by 1.25xMy/1.25xMn/1.25xMn+1 < 0.01um at opposite side
@ 2) Space between 1.25xRVn and 1.25xMy/1.25xMn/1.25xMn+1 <= 0.052um with PRL >= -0.046um at opposite side
@ DRC doesn't flag space between 1.25xRVn and 1.25xMy/1.25xMn/1.25xMn+1 <= 0.052um with PRL >= -0.046um on both sides
 ncp_axis = ANGLE (ENC [RV6] M6 < 0.01 ABUT<90 OPPOSITE) == 0
 y1 = ANGLE (RV6 TOUCH EDGE ncp_axis) == 0
 y2 = EXT [y1] M6 <= 0.052 ABUT<90 OPPOSITE EXTENDED 0.046+GLOBAL_TOLERANCE MEASURE ALL
 y3 = RV6 TOUCH EDGE y2
 y4 = INT [RV6] y3 == 0.040 ABUT<90 OPPOSITE
 err1 = EXT (y4 NOT TOUCH EDGE y2) V6_SR < 0.119 ABUT<90 OPPOSITE EXTENDED 0.119+GLOBAL_TOLERANCE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xRv6_S_4_M7 {
@ Space between 1.25xRVn when PRL >= -0.119um. >= 0.119um
@ When:
@ 1) 1.25xRVn enclosure by 1.25xMy/1.25xMn/1.25xMn+1 < 0.01um at opposite side
@ 2) Space between 1.25xRVn and 1.25xMy/1.25xMn/1.25xMn+1 <= 0.052um with PRL >= -0.046um at opposite side
@ DRC doesn't flag space between 1.25xRVn and 1.25xMy/1.25xMn/1.25xMn+1 <= 0.052um with PRL >= -0.046um on both sides
 ncp_axis = ANGLE (ENC [RV6] M7 < 0.01 ABUT<90 OPPOSITE) == 90
 y1 = ANGLE (RV6 TOUCH EDGE ncp_axis) == 90
 y2 = EXT [y1] M7 <= 0.052 ABUT<90 OPPOSITE EXTENDED 0.046+GLOBAL_TOLERANCE MEASURE ALL
 y3 = RV6 TOUCH EDGE y2
 y4 = INT [RV6] y3 == 0.040 ABUT<90 OPPOSITE
 err1 = EXT (y4 NOT TOUCH EDGE y2) V6_SR < 0.119 ABUT<90 OPPOSITE EXTENDED 0.119+GLOBAL_TOLERANCE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xRv6_EN_1 {
@ 1.25xRVn must be fully enclosed by 1.25xMy or 1.25xMn where 1.25xMy or 1.25xMn is the metal layer directly underneath 1.25xRVn. Enclosure by 1.25xMy or 1.25xMn must follow one of 1.25xRVn.EN.2 or 1.25xRVn.EN.3 or 1.25xRVn.EN.4 or 1.25xRVn.EN.5 or 1.25xRVn.EN.6 or 1.25xRVn.EN.7 or 1.25xRVn.EN.8
 err1 = RV6 NOT M6
 err1 NOT INSIDE SealR_NOT_BULK
}
 
//;beginning of the 125xRVn.EN.2 derivations
met_125xRv6_2 = M6 WITH WIDTH == 0.040
via_125xRv6_2 = RV6 NOT OUTSIDE met_125xRv6_2
via_125xRv6_2_bad = RECTANGLE ENCLOSURE via_125xRv6_2 M6 ABUT<90 SINGULAR 
GOOD 0 0.049 OPPOSITE 0 0.049 OPPOSITE
via_125xRv6_2_good = via_125xRv6_2 NOT via_125xRv6_2_bad
//;end of the 125xRVn.EN.2 derivations
 
125xRv6_EN_2 {
@ 1.25xRVn enclosure by 1.25xMy or 1.25xMn (width = 0.04um) for two opposite sides with the other two sides >= 0um. >= 0.049um
 err1 = copy via_125xRv6_2_bad
 err1 NOT INSIDE SealR_NOT_BULK
}
 
//;beginning of the 125xRVn.EN.2a derivations
met_125xRv6_2a = M6 WITH WIDTH == 0.042
via_125xRv6_2a = RV6 NOT OUTSIDE met_125xRv6_2a
via_125xRv6_2a_bad = RECTANGLE ENCLOSURE via_125xRv6_2a M6 ABUT<90 SINGULAR 
GOOD 0.001 0.049 OPPOSITE 0.001 0.049 OPPOSITE
via_125xRv6_2a_good = via_125xRv6_2a NOT via_125xRv6_2a_bad
//;end of the 125xRVn.EN.2a derivations
 
125xRv6_EN_2a {
@ 1.25xRVn enclosure by 1.25xMy or 1.25xMn (width = 0.042um) for two opposite sides with the other two sides >= 0.001um. >= 0.049um
 err1 = via_125xRv6_2a_bad NOT via_125xRv6_2_good
 err1 NOT INSIDE SealR_NOT_BULK
}
 
//;beginning of the 125xRVn.EN.3 derivations
met_125xRv6_3 = M6 WITH WIDTH == 0.044
via_125xRv6_3 = RV6 NOT OUTSIDE met_125xRv6_3
via_125xRv6_3_bad = RECTANGLE ENCLOSURE via_125xRv6_3 M6 ABUT<90 SINGULAR 
GOOD 0.002 0.049 OPPOSITE 0.002 0.049 OPPOSITE
via_125xRv6_3_good = via_125xRv6_3 NOT via_125xRv6_3_bad
//;end of the 125xRVn.EN.3 derivations
 
125xRv6_EN_3 {
@ 1.25xRVn enclosure by 1.25xMy or 1.25xMn (width = 0.044um) for two opposite sides with the other two sides >= 0.002um. >= 0.049um
 err1 = via_125xRv6_3_bad NOT (OR via_125xRv6_2_good via_125xRv6_2a_good)
 err1 NOT INSIDE SealR_NOT_BULK
}
 
//;beginning of the 125xRVn.EN.3a derivations
met_125xRv6_3a = M6 WITH WIDTH == 0.046
via_125xRv6_3a = RV6 NOT OUTSIDE met_125xRv6_3a
via_125xRv6_3a_bad = RECTANGLE ENCLOSURE via_125xRv6_3a M6 ABUT<90 SINGULAR 
GOOD 0.003 0.049 OPPOSITE 0.003 0.049 OPPOSITE
via_125xRv6_3a_good = via_125xRv6_3a NOT via_125xRv6_3a_bad
//;end of the 125xRVn.EN.3a derivations
 
125xRv6_EN_3a {
@ 1.25xRVn enclosure by 1.25xMy or 1.25xMn (width = 0.046um) for two opposite sides with the other two sides >= 0.003um. >= 0.049um
 err1 = via_125xRv6_3a_bad NOT (OR via_125xRv6_2_good via_125xRv6_2a_good via_125xRv6_3_good)
 err1 NOT INSIDE SealR_NOT_BULK
}
 
//;beginning of the 125xRVn.EN.4 derivations
met_125xRv6_4 = M6 WITH WIDTH >= 0.060 < 0.08
via_125xRv6_4 = RV6 NOT OUTSIDE met_125xRv6_4
via_125xRv6_4_bad = RECTANGLE ENCLOSURE via_125xRv6_4 M6 ABUT<90 SINGULAR 
GOOD 0.01 0.049 OPPOSITE 0.010 0.049 OPPOSITE
via_125xRv6_4_good = via_125xRv6_4 NOT via_125xRv6_4_bad
//;end of the 125xRVn.EN.4 derivations
via_125xRv6_2_3_good = OR via_125xRv6_2_good via_125xRv6_2a_good via_125xRv6_3_good via_125xRv6_3a_good
via_125xRv6_2_3_4_good = OR via_125xRv6_2_3_good via_125xRv6_4_good
 
125xRv6_EN_4 {
@ 1.25xRVn enclosure by 1.25xMy or 1.25xMn (0.06um <= width < 0.08um) for two opposite sides with the other two sides >= 0.01um. >= 0.049um
 err1 = via_125xRv6_4_bad NOT via_125xRv6_2_3_good
 err1 NOT INSIDE SealR_NOT_BULK
}
 
//;beginning of the 125xRVn.EN.5 derivations
met_125xRv6_5 = M6 WITH WIDTH == 0.080
via_125xRv6_5 = RV6 NOT OUTSIDE met_125xRv6_5
via_125xRv6_5_bad = RECTANGLE ENCLOSURE via_125xRv6_5 M6 ABUT<90 SINGULAR 
GOOD 0.02 0.02 0.02 0.02 OPPOSITE
via_125xRv6_5_good = via_125xRv6_5 NOT via_125xRv6_5_bad
//;end of the 125xRVn.EN.5 derivations
 
125xRv6_EN_5 {
@ 1.25xRVn enclosure by 1.25xMy or 1.25xMn (width = 0.08um) for all sides >= 0.02um
 err1 = via_125xRv6_5_bad NOT via_125xRv6_2_3_4_good
 err1 NOT INSIDE SealR_NOT_BULK
 err2 = ENC via_125xRv6_5 M6 < 0.02 ABUT<90 SINGULAR REGION
 err2 NOT INSIDE SealR_NOT_BULK
}
 
 //--------------Definition of 1.25xRVn array----------------- 
125xRv_16 = EXT [RV6_L] == 0.08 ABUT<90 OPPOSITE
125xRv_26 = LENGTH 125xRv_16 == 0.1
125xRv_06 = (EXT RV6_L == 0.08 ABUT<90 OPPOSITE REGION) WITH EDGE 125xRv_26
125xRv_36 = RV6 WITH EDGE 125xRv_16
125xRv_array6 = (125xRv_36 OR 125xRv_06) INTERACT 125xRv_36 > 1
 
//;beginning of the 125xRVn.EN.6 derivations
met_125xRv6_6 = M6 WITH WIDTH > 0.080
via_125xRv6_6 = (RV6 INTERACT met_125xRv6_6) NOT INTERACT 125xRv_array6
via_125xRv6_6_bad = RECTANGLE ENCLOSURE via_125xRv6_6 M6 ABUT<90 SINGULAR 
GOOD 0.02 0.029 OPPOSITE 0.02 0.029 OPPOSITE
via_125xRv6_6_good = via_125xRv6_6 NOT via_125xRv6_6_bad
//;end of the 125xRVn.EN.6 derivations
 
125xRv6_EN_6 {
@ 1.25xRVn enclosure by 1.25xMy or 1.25xMn (width > 0.08um) for two opposite sides with the other two sides >= 0.02um (except rectangular 1.25xRVn array) >= 0.029um
 err1 = via_125xRv6_6_bad NOT (OR via_125xRv6_2_3_4_good via_125xRv6_5_good via_125xRv6_7_good) //125xRv.EN.6~7: the width conditions are covered by each other
 err1 NOT INSIDE SealR_NOT_BULK
}
 
//;beginning of the 125xRVn.EN.7 derivations
met_125xRv6_7 = M6 WITH WIDTH > 0.080
via_125xRv6_7 = (RV6 INTERACT met_125xRv6_7) NOT INTERACT 125xRv_array6
via_125xRv6_7_L_edges = LENGTH via_125xRv6_7 == 0.10
via_125xRv6_7_W_edges = LENGTH via_125xRv6_7 == 0.04
via_125xRv6_7_x = ENC [via_125xRv6_7_L_edges] M6 < 0.039 ABUT<90 OPPOSITE
via_125xRv6_7_y = ENC [via_125xRv6_7_W_edges] M6 < 0.01 ABUT<90 OPPOSITE
via_125xRv6_7_bad = via_125xRv6_7 WITH EDGE (OR EDGE via_125xRv6_7_x via_125xRv6_7_y)
via_125xRv6_7_good = via_125xRv6_7 NOT via_125xRv6_7_bad
//;end of the 125xRVn.EN.7 derivations
 
125xRv6_EN_7 {
@ 1.25xRVn enclosure by short side of 1.25xMy or 1.25xMn (width > 0.08um) with long side enclosure >= 0.039um (except rectangular 1.25xRVn array) >= 0.01um
 err1 = via_125xRv6_7_bad NOT (OR via_125xRv6_2_3_4_good via_125xRv6_5_good via_125xRv6_6_good)
 err1 NOT INSIDE SealR_NOT_BULK
}
 
//;beginning of the 125xRVn.EN.8 derivations
met_125xRv6_8 = COPY M6
via_125xRv6_8 = (RV6 INTERACT met_125xRv6_8) INTERACT 125xRv_array6
via_125xRv6_8_bad = RECTANGLE ENCLOSURE via_125xRv6_8 M6 ABUT<90 SINGULAR 
GOOD 0.01 0.02 OPPOSITE 0.01 0.02 OPPOSITE
via_125xRv6_8_good = via_125xRv6_8 NOT via_125xRv6_8_bad
//;end of the 125xRVn.EN.8 derivations
 
125xRv6_EN_8 {
@ 1.25xRVn array enclosed by 1.25xMn/1.25xMy for two opposite sides with the other two sides (rectangular 1.25xVn array edge length = 0.1um) >= 0.02um
@ Definition of 1.25xRVn array:
@ 1.25xVn long side space = 0.08um (PRL = 0.1um) >= 0.01um
 err1 = via_125xRv6_8_bad NOT (OR via_125xRv6_2_3_4_good via_125xRv6_5_good via_125xRv6_6_good via_125xRv6_7_good)
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xRv6_EN_9 {
@ 1.25xRVn must be fully enclosed by 1.25xMn+1 where 1.25xMn+1 is the metal layer directly above 1.25xRVn. Enclosures by 1.25xMn+1 must follow one of 1.25xRVn.EN.10 or 1.25xRVn.EN.11 or 1.25xRVn.EN.12 or 1.25xRVn.EN.13 or 1.25xRVn.EN.14.
 err1 = RV6 NOT M7
 err1 NOT INSIDE SealR_NOT_BULK
}
 
//;beginning of the 125xRVn.EN.10 derivations
met_125xRv6_10 = M7 WITH WIDTH == 0.040
via_125xRv6_10 = RV6 NOT OUTSIDE met_125xRv6_10
via_125xRv6_10_bad = RECTANGLE ENCLOSURE via_125xRv6_10 M7 ABUT<90 SINGULAR 
GOOD 0 0.039 OPPOSITE 0 0.039 OPPOSITE
via_125xRv6_10_good = via_125xRv6_10 NOT via_125xRv6_10_bad
//;end of the 125xRVn.EN.10 derivations
 
125xRv6_EN_10 {
@ 1.25xRVn enclosure by 1.25xMn+1 (width = 0.04um) for two opposite sides with the other two sides >= 0um. >= 0.039um
 err1 = copy via_125xRv6_10_bad
 err1 NOT INSIDE SealR_NOT_BULK
}
 
//;beginning of the 125xRVn.EN.10a derivations
met_125xRv6_10a = M7 WITH WIDTH == 0.042
via_125xRv6_10a = RV6 NOT OUTSIDE met_125xRv6_10a
via_125xRv6_10a_bad = RECTANGLE ENCLOSURE via_125xRv6_10a M7 ABUT<90 SINGULAR 
GOOD 0.001 0.039 OPPOSITE 0.001 0.039 OPPOSITE
via_125xRv6_10a_good = via_125xRv6_10a NOT via_125xRv6_10a_bad
//;end of the 125xRVn.EN.10a derivations
 
125xRv6_EN_10a {
@ 1.25xRVn enclosure by 1.25xMn+1 (width = 0.042um) for two opposite sides with the other two sides >= 0.001um. >= 0.039um
 err1 = via_125xRv6_10a_bad NOT via_125xRv6_10_good
 err1 NOT INSIDE SealR_NOT_BULK
}
 
//;beginning of the 125xRVn.EN.10b derivations
met_125xRv6_10b = M7 WITH WIDTH == 0.044
via_125xRv6_10b = RV6 NOT OUTSIDE met_125xRv6_10b
via_125xRv6_10b_bad = RECTANGLE ENCLOSURE via_125xRv6_10b M7 ABUT<90 SINGULAR 
GOOD 0.002 0.039 OPPOSITE 0.002 0.039 OPPOSITE
via_125xRv6_10b_good = via_125xRv6_10b NOT via_125xRv6_10b_bad
//;end of the 125xRVn.EN.10b derivations
 
125xRv6_EN_10b {
@ 1.25xRVn enclosure by 1.25xMn+1 (width = 0.044um) for two opposite sides with the other two sides >= 0.002um. >= 0.039um
 err1 = via_125xRv6_10b_bad NOT (OR via_125xRv6_10_good via_125xRv6_10a_good)
 err1 NOT INSIDE SealR_NOT_BULK
}
 
//;beginning of the 125xRVn.EN.10c derivations
met_125xRv6_10c = M7 WITH WIDTH == 0.046
via_125xRv6_10c = RV6 NOT OUTSIDE met_125xRv6_10c
via_125xRv6_10c_bad = RECTANGLE ENCLOSURE via_125xRv6_10c M7 ABUT<90 SINGULAR 
GOOD 0.003 0.039 OPPOSITE 0.003 0.039 OPPOSITE
via_125xRv6_10c_good = via_125xRv6_10c NOT via_125xRv6_10c_bad
//;end of the 125xRVn.EN.10c derivations
 
125xRv6_EN_10c {
@ 1.25xRVn enclosure by 1.25xMn+1 (width = 0.046um) for two opposite sides with the other two sides >= 0.003um. >= 0.039um
 err1 = via_125xRv6_10c_bad NOT (OR via_125xRv6_10_good via_125xRv6_10a_good via_125xRv6_10b_good)
 err1 NOT INSIDE SealR_NOT_BULK
}
 
//;beginning of the 125xRVn.EN.10d derivations
met_125xRv6_10d = M7 WITH WIDTH >= 0.060 < 0.08
via_125xRv6_10d = RV6 NOT OUTSIDE met_125xRv6_10d
via_125xRv6_10d_bad = RECTANGLE ENCLOSURE via_125xRv6_10d M7 ABUT<90 SINGULAR 
GOOD 0.01 0.039 OPPOSITE 0.01 0.039 OPPOSITE
via_125xRv6_10d_good = via_125xRv6_10d NOT via_125xRv6_10d_bad
//;end of the 125xRVn.EN.10d derivations
 
125xRv6_EN_10d {
@ 1.25xRVn enclosure by 1.25xMn+1 (width >= 0.06 < 0.08um) for two opposite sides with the other two sides >= 0.01um. >= 0.039um
 err1 = via_125xRv6_10d_bad NOT (OR via_125xRv6_10_good via_125xRv6_10a_good via_125xRv6_10b_good via_125xRv6_10c_good)
 err1 NOT INSIDE SealR_NOT_BULK
}
 
//;beginning of the 125xRVn.EN.11 derivations
met_125xRv6_11 = M7 WITH WIDTH == 0.080
via_125xRv6_11 = RV6 NOT OUTSIDE met_125xRv6_11
via_125xRv6_11_bad = RECTANGLE ENCLOSURE via_125xRv6_11 M7 ABUT<90 SINGULAR 
GOOD 0.02 0.02 0.02 0.02 OPPOSITE
via_125xRv6_11_good = via_125xRv6_11 NOT via_125xRv6_11_bad
//;end of the 125xRVn.EN.11 derivations
via_125xRv6_10_10abcd_good = OR via_125xRv6_10_good via_125xRv6_10a_good via_125xRv6_10b_good via_125xRv6_10c_good via_125xRv6_10d_good
via_125xRv6_10_10a_10b_10c_10d_11_good = OR via_125xRv6_10_10abcd_good via_125xRv6_11_good
 
125xRv6_EN_11 {
@ 1.25xRVn enclosure by 1.25xMn+1 (width = 0.08um) for all sides >= 0.02um
 err1 = via_125xRv6_11_bad NOT via_125xRv6_10_10abcd_good
 err1 NOT INSIDE SealR_NOT_BULK
 err2 = ENC via_125xRv6_11 M7 < 0.02 ABUT<90 SINGULAR REGION
 err2 NOT INSIDE SealR_NOT_BULK
}
 
//;beginning of the 125xRVn.EN.12 derivations
met_125xRv6_12 = M7 WITH WIDTH > 0.08
via_125xRv6_12 = (RV6 INTERACT met_125xRv6_12) NOT INTERACT 125xRv_array6
via_125xRv6_12_bad = RECTANGLE ENCLOSURE via_125xRv6_12 M7 ABUT<90 SINGULAR 
GOOD 0.02 0.029 OPPOSITE 0.02 0.029 OPPOSITE
via_125xRv6_12_good = via_125xRv6_12 NOT via_125xRv6_12_bad
//;end of the 125xRVn.EN.12 derivations
 
125xRv6_EN_12 {
@ 1.25xRVn enclosure by 1.25xMn+1 (width > 0.080um) for two opposite sides with the other two sides >= 0.02um (except rectangular 1.25xVn array) >= 0.029um
 err1 = via_125xRv6_12_bad NOT (OR via_125xRv6_10_10a_10b_10c_10d_11_good via_125xRv6_13_13a_good) //125xRv.EN.12~13: the width conditions are covered by each other
 err1 NOT INSIDE SealR_NOT_BULK
}
 
//;beginning of the 125xRVn.EN.13a derivations
met_125xRv6_13a = (M7 WITH WIDTH > 0.08) WITH WIDTH >= 0.12
via_125xRv6_13a = (RV6 INTERACT met_125xRv6_13a) NOT INTERACT 125xRv_array6
via_125xRv6_13a_bad = RECTANGLE ENCLOSURE via_125xRv6_13a M7 ABUT<90 SINGULAR 
GOOD 0.02 0.029 OPPOSITE 0.02 0.029 OPPOSITE
via_125xRv6_13a_good = via_125xRv6_13a NOT via_125xRv6_13a_bad
//;end of the 125xRVn.EN.13a derivations
 
//;beginning of the 125xRVn.EN.13 derivations
met_125xRv6_13 = (M7 WITH WIDTH > 0.08) WITH WIDTH >= 0.12
via_125xRv6_13_TMP = (RV6 INTERACT met_125xRv6_13) NOT INTERACT 125xRv_array6
via_125xRv6_13 = via_125xRv6_13_TMP NOT (OR via_125xRv6_10_10a_10b_10c_10d_11_good via_125xRv6_12_good)
via_125xRv6_13_L_edges = LENGTH via_125xRv6_13 == 0.10
via_125xRv6_13_W_edges = LENGTH via_125xRv6_13 == 0.04
via_125xRv6_13_x = ENC [via_125xRv6_13_L_edges] M7 < 0.039 ABUT<90 OPPOSITE
via_125xRv6_13_y = ENC [via_125xRv6_13_W_edges] M7 < 0.01 ABUT<90 OPPOSITE
via_125xRv6_13_bad = via_125xRv6_13 WITH EDGE (OR EDGE via_125xRv6_13_x via_125xRv6_13_y)
via_125xRv6_13_good = via_125xRv6_13 NOT via_125xRv6_13_bad
via_125xRv6_13_13a_good = OR via_125xRv6_13_good via_125xRv6_13a_good
//;end of the 125xRVn.EN.13 derivations
 
125xRv6_EN_13a {
@ 1.25xRVn enclosure by 1.25xMn+1 (width >= 0.12um) for two opposite sides with the other two sides >= 0.02um (except rectangle 1.25xVn array) >= 0.029um
 err1 = via_125xRv6_13a_bad NOT (OR via_125xRv6_10_10a_10b_10c_10d_11_good via_125xRv6_12_good via_125xRv6_13_good) //125xRv.EN.13 already covered by 125xRv.EN.12
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xRv6_EN_13 {
@ 1.25xRVn short side enclosed by 1.25xMn+1, 1.25xMn+1 (width >= 0.12um) with long sides enclosure >= 0.039um (except rectangular 1.25xVn array) >= 0.01um
 err1 = via_125xRv6_13_bad NOT (OR via_125xRv6_10_10a_10b_10c_10d_11_good via_125xRv6_12_good via_125xRv6_13a_good) //125xRv.EN.12~13: the width conditions are covered by each other
 err1 NOT INSIDE SealR_NOT_BULK
}
 
//;beginning of the 125xRVn.EN.14a derivations
met_125xRv6_14 = COPY M7
via_125xRv6_14_TMP = (RV6 INTERACT met_125xRv6_14) INTERACT 125xRv_array6
via_125xRv6_14 = via_125xRv6_14_TMP NOT (OR via_125xRv6_10_10a_10b_10c_10d_11_good via_125xRv6_12_good via_125xRv6_13_13a_good)
via_125xRv6_14_bad = RECTANGLE ENCLOSURE via_125xRv6_14 M7 ABUT<90 SINGULAR 
GOOD 0.01 0.02 OPPOSITE 0.01 0.02 OPPOSITE
via_125xRv6_14_good = via_125xRv6_14 NOT via_125xRv6_14_bad
//;end of the 125xRVn.EN.14 derivations
 
125xRv6_EN_14 {
@ 1.25xRVn array enclosed by 1.25xMn+1 for two opposite sides with the other two sides (rectangular 1.25xVn array edge length = 0.1um) >= 0.02um
@ Definition of rectangular 1.25xVn array:
@ 1.25xVn long side space = 0.08um (PRL = 0.10um) >= 0.01um
 err1 = copy via_125xRv6_14_bad
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xRv6_EN_15 {
@ 1.25xRVn enclosure by 1.25xMn+1 edge (between two consecutive 90-270 degree corners, length < 0.16um), when PRL > 0. >= 0.029um
 chk_edge = CONVEX EDGE M7 ANGLE1 == 90 ANGLE2 == 270 WITH LENGTH < 0.16
 err1_TMP = chk_edge TOUCH EDGE (EXT chk_edge M7_convex_270_90_edges < 0.005 ABUT==90 INTERSECTING ONLY REGION)
 err1 = ENC RV6 err1_TMP < 0.029 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xRv6_EN_16 {
@ 1.25xRVn enclosure by 1.25xMn+1 for two opposite sides (PRL > 0) with the other side enclosure < 0.04um (corresponding edge length < 0.16um between two consecutive 90-270 degree corners) >= 0.04um
 correspond_EDG = CONVEX EDGE M7 ANGLE1 == 90 ANGLE2 == 270 WITH LENGTH < 0.16
 correspond_ENC = ENC [RV6] correspond_EDG < 0.04 ABUT<90 OPPOSITE EXTENDED 0.001
 correspond_VIA_ENC_EDGE = RV6 TOUCH EDGE correspond_ENC
 correspond_VIA_EDG_CORN = INT [RV6] correspond_VIA_ENC_EDGE < 0.001 ABUT==90 INTERSECTING ONLY
 correspond_VIA_EDG = RV6 TOUCH EDGE correspond_VIA_EDG_CORN
 err1_RAW = ENC [correspond_VIA_EDG] M7 < 0.040 ABUT<90 OPPOSITE EXTENDED 0.001
 err1_TMP = INT correspond_VIA_ENC_EDGE (correspond_VIA_EDG TOUCH EDGE err1_RAW) < 0.005 ABUT==90 INTERSECTING ONLY REGION
 err1 = EXPAND EDGE (RV6 TOUCH EDGE err1_TMP) INSIDE BY 0.001
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xRv6_R_1 {
@ Single 1.25xRVn is not allowed in "H-shape" 1.25xMn+1, when:
@ 1. The 1.25xMn+1 has "H-shape" interacting with two metal holes: both two metal holes length <= 4.5um and two metal hole area <= 4.05um2
@ 2. The 1.25xRVn overlaps on the center metal bar of this "H-shape" 1.25xMn+1
@ 3. The center metal bar length <= 0.9um and the metal bar width <= 0.162um
@ DRC doesn't check when one or more square 1.25xRVn is also on H-shape 1.25xMn+1 region
 hole_area_meet = AREA (HOLES M7 INNER) <= 4.05
 hole_area_meet_len = (hole_area_meet WITH EDGE (LENGTH hole_area_meet <= 0.9)) NOT WITH EDGE (LENGTH hole_area_meet > 4.5)
 hole_area_real = (hole_area_meet_len NOT ENCLOSE RECTANGLE 0.9+GLOBAL_TOLERANCE 4.5) NOT ENCLOSE RECTANGLE 0.9 4.5+GLOBAL_TOLERANCE
 hole_bars_len = M7 COIN EDGE hole_area_real
 // 
 hole_bars = INT hole_bars_len <= 0.162 ABUT<90 OPPOSITE REGION EXCLUDE SHIELDED
 hole_bars_real = hole_bars WITH EDGE (LENGTH hole_bars_len <= 0.9)
 hole_bars_vias_rect = RV6 INTERACT ((hole_bars_real INTERACT hole_area_real == 2) NOT ENCLOSE V6N >= 2)
 err1 = hole_bars_real INTERACT hole_bars_vias_rect == 1
 err1 NOT INSIDE SealR_NOT_BULK
}
 
125xRv6_R_2 {
@ Redundant via requirement must be obeyed by one of following conditions of via numbers and space for 1.25xMy/1.25xMn, 1.25xMn+1 connection (one of 1.25xMy/1.25xMn or 1.25xMn+1 have width and length >= 0.164um, two square vias are equal to one rectangular via for below conditions) (Except VIA bar)
@ 1) At least one rectangular 1.25xVn
@ 2) At least two square 1.25xVn with space <= 0.091um
@ 3) At least four square 1.25xVn with space <= 0.59um
 X1a = WITH WIDTH M6 > 0.164-GLOBAL_TOLERANCE <= 0.398-GLOBAL_TOLERANCE
 X1b = WITH WIDTH M7 > 0.164-GLOBAL_TOLERANCE <= 0.398-GLOBAL_TOLERANCE
 Y1a = WITH WIDTH M6 > 0.398-GLOBAL_TOLERANCE
 Y1b = WITH WIDTH M7 > 0.398-GLOBAL_TOLERANCE
 WIDE_1 = (X1a AND M7) ENCLOSE V6
 WIDE_2 = (M6 AND X1b) ENCLOSE V6
 WIDE_3 = (Y1a AND M7) ENCLOSE V6
 WIDE_4 = (M6 AND Y1b) ENCLOSE V6
 WIDE_all_raw = (WIDE_1 OR WIDE_2) NOT (WIDE_3 OR WIDE_4)
 WIDE_all = (M6 AND M7) NOT OUTSIDE WIDE_all_raw
 // 
 // condition 1
 Y1_good = WIDE_all_raw AND RV6
 // condition 2
 Y2_wide_all = WIDE_all_raw NOT INTERACT Y1_good
 Y2_wide = (WIDE_all INTERACT Y2_wide_all) INTERACT V6_SR >= 2
 Y2_comb_step = SIZE V6_SR BY 0.091/2 INSIDE OF Y2_wide STEP 0.030
 Y2_good_step = OR (Y2_comb_step INTERACT V6N >= 2) (Y2_comb_step INTERACT RV6)
 Y2_good = WIDE_all_raw AND Y2_good_step
 // 
 // condition 3
 Y3_wide_all = WIDE_all_raw NOT INTERACT (OR Y1_good Y2_good)
 Y3_wide = (WIDE_all INTERACT Y3_wide_all) INTERACT V6_SR >= 2 // rectangle array 0.59/2=0.295
 Y3_vias_input = V6_SR AND Y3_wide
 Y3_wide_chk_1 = Y3_wide INTERACT Y3_wide_all
 Y3_comb_step1 = SIZE Y3_vias_input BY 0.04 INSIDE OF Y3_wide_chk_1 STEP 0.04 // via minimum space = 0.075
 Y3_good_step1 = OR (Y3_comb_step1 INTERACT V6N >= 4) (Y3_comb_step1 INTERACT RV6) // step1: 0.050
 // 
 Y3_wide_chk_2 = Y3_wide_chk_1 INTERACT (WIDE_all_raw NOT INTERACT Y3_good_step1)
 Y3_comb_step2 = SIZE Y3_comb_step1 BY 0.04 INSIDE OF Y3_wide_chk_2 STEP 0.04
 Y3_good_step2 = OR (Y3_comb_step2 INTERACT V6N >= 4) (Y3_comb_step2 INTERACT RV6) // step2: 0.04
 // 
 Y3_wide_chk_3 = Y3_wide_chk_2 INTERACT (WIDE_all_raw NOT INTERACT Y3_good_step2)
 Y3_comb_step3 = SIZE Y3_comb_step2 BY 0.04 INSIDE OF Y3_wide_chk_3 STEP 0.04
 Y3_good_step3 = OR (Y3_comb_step3 INTERACT V6N >= 4) (Y3_comb_step3 INTERACT RV6) // step3: 0.04
 // 
 Y3_wide_chk_4 = Y3_wide_chk_3 INTERACT (WIDE_all_raw NOT INTERACT Y3_good_step3)
 Y3_comb_step4 = SIZE Y3_comb_step3 BY 0.04 INSIDE OF Y3_wide_chk_4 STEP 0.04
 Y3_good_step4 = OR (Y3_comb_step4 INTERACT V6N >= 4) (Y3_comb_step4 INTERACT RV6) // step4: 0.04
 // 
 Y3_wide_chk_5 = Y3_wide_chk_4 INTERACT (WIDE_all_raw NOT INTERACT Y3_good_step4)
 Y3_comb_step5 = SIZE Y3_comb_step4 BY 0.04 INSIDE OF Y3_wide_chk_5 STEP 0.04
 Y3_good_step5 = OR (Y3_comb_step5 INTERACT V6N >= 4) (Y3_comb_step5 INTERACT RV6) // step5: 0.04
 // 
 Y3_wide_chk_6 = Y3_wide_chk_5 INTERACT (WIDE_all_raw NOT INTERACT Y3_good_step5)
 Y3_comb_step6 = SIZE Y3_comb_step5 BY 0.04 INSIDE OF Y3_wide_chk_6 STEP 0.04
 Y3_good_step6 = OR (Y3_comb_step6 INTERACT V6N >= 4) (Y3_comb_step6 INTERACT RV6) // step6: 0.04
 // 
 Y3_wide_chk_7 = Y3_wide_chk_6 INTERACT (WIDE_all_raw NOT INTERACT Y3_good_step6)
 Y3_comb_step7 = SIZE Y3_comb_step6 BY 0.04 INSIDE OF Y3_wide_chk_7 STEP 0.04
 Y3_good_step7 = OR (Y3_comb_step7 INTERACT V6N >= 4) (Y3_comb_step7 INTERACT RV6) // step7: 0.04
 // 
 Y3_wide_chk_8 = Y3_wide_chk_7 INTERACT (WIDE_all_raw NOT INTERACT Y3_good_step7)
 Y3_comb_step8 = SIZE Y3_comb_step7 BY 0.015 INSIDE OF Y3_wide_chk_8 STEP 0.015
 Y3_good_step8 = OR (Y3_comb_step8 INTERACT V6N >= 4) (Y3_comb_step8 INTERACT RV6) // step8: 0.295-0.04*7=0.015
 Y3_good = WIDE_all_raw AND (OR Y3_good_step1 Y3_good_step2 Y3_good_step3 Y3_good_step4 Y3_good_step5 Y3_good_step6 Y3_good_step7 Y3_good_step8)
 // 
 err1 = (WIDE_all_raw OUTSIDE (OR Y1_good Y2_good Y3_good)) INTERACT V6
 err1 NOT INTERACT 125xv6_BAR
}
 
125xRv6_R_3 {
@ Redundant via requirement must be obeyed by one of following conditions of 1.25xVn numbers and space for 1.25xMy/1.25xMn and 1.25xMn+1 connection (one of 1.25xMy/1.25xMn or 1.25xMn+1 have width and length >= 0.398um, two square vias are equal to one rectangular via for below conditions), except VIA bar, OCCD region
@ 1) At least 4 square 1.25xVn with space <= 0.091um
@ 2) At least 2 square 1.25xVn and 1 rectangular 1.25xVn with space <= 0.118um
@ 3) At least 9 square 1.25xVn with space <= 0.77um
@ For condition 2) and 3) 2 square 1.25xVn can be replaced by 1 rectangular 1.25xVn
 X1a = WITH WIDTH M6 > 0.398-GLOBAL_TOLERANCE
 X1b = WITH WIDTH M7 > 0.398-GLOBAL_TOLERANCE
 WIDE_1 = (X1a AND M7) ENCLOSE V6
 WIDE_2 = (M6 AND X1b) ENCLOSE V6
 WIDE_all_raw = WIDE_1 OR WIDE_2
 WIDE_all = (M6 AND M7) NOT OUTSIDE WIDE_all_raw
 // 
 // condition 1
 Y2_wide = WIDE_all INTERACT V6N >= 4
 Y2_vias_input = V6N AND Y2_wide
 Y2_wide_chk_1 = COPY Y2_wide // rectangle array 0.09/2=0.0455
 Y2_comb_step1 = SIZE Y2_vias_input BY 0.030 INSIDE OF Y2_wide_chk_1 STEP 0.030 // step1: 0.030, via minimum space = 0.056
 Y2_good_step1 = Y2_comb_step1 INTERACT V6N >= 4
 // 
 Y2_wide_chk_2 = Y2_wide_chk_1 INTERACT (WIDE_all_raw NOT INTERACT Y2_good_step1)
 Y2_comb_step2 = SIZE Y2_comb_step1 BY 0.0155 INSIDE OF Y2_wide_chk_2 STEP 0.015 // step2: 0.0155
 Y2_good_step2 = Y2_comb_step2 INTERACT V6N >= 4
 Y2_good = WIDE_all_raw AND (OR Y2_good_step1 Y2_good_step2)
 // 
 // condition 2
 Y1_wide_all = WIDE_all_raw NOT INTERACT Y2_good // rectangle array 0.118/2=0.059
 Y1_wide = (WIDE_all INTERACT Y1_wide_all) INTERACT V6 >= 2
 Y1_vias_input = V6 AND Y1_wide
 Y1_wide_chk_1 = Y1_wide INTERACT Y1_wide_all
 Y1_comb_step1 = SIZE Y1_vias_input BY 0.030 INSIDE OF Y1_wide_chk_1 STEP 0.030 // step1: 0.030, via minimum space = 0.100
 Y1_good_step1_a = Y1_comb_step1 INTERACT RV6 >= 2
 Y1_good_step1_b = (Y1_comb_step1 INTERACT V6N >= 2) INTERACT RV6 >= 1
 Y1_good_step1 = OR Y1_good_step1_a Y1_good_step1_b
 // 
 Y1_wide_chk_2 = Y1_wide_chk_1 INTERACT (WIDE_all_raw NOT INTERACT Y1_good_step1)
 Y1_comb_step2 = SIZE Y1_comb_step1 BY 0.029 INSIDE OF Y1_wide_chk_2 STEP 0.025 // step2: 0.059-0.030=0.029
 Y1_good_step2_a = Y1_comb_step2 INTERACT RV6 >= 2
 Y1_good_step2_b = (Y1_comb_step2 INTERACT V6N >= 2) INTERACT RV6 >= 1
 Y1_good_step2 = OR Y1_good_step2_a Y1_good_step2_b
 Y1_good = WIDE_all_raw AND (OR Y1_good_step1 Y1_good_step2)
 // 
 // condition 3
 Y3_wide_all = WIDE_all_raw NOT INTERACT (OR Y2_good Y1_good)
 Y3_wide = (WIDE_all INTERACT Y3_wide_all) INTERACT V6 >= 5
 Y3_vias_input = V6N AND Y3_wide
 Y3_wide_chk_1 = Y3_wide INTERACT Y3_wide_all // rectangle array 0.77/2=0.385
 Y3_comb_step1 = SIZE Y3_vias_input BY 0.070 INSIDE OF Y3_wide_chk_1 STEP 0.035 // step1: 0.070, via minimum space = 0.056
 Y3_good_step1_a = Y3_comb_step1 INTERACT V6N >= 9
 Y3_good_step1_b = (Y3_comb_step1 INTERACT V6N >= 7) INTERACT RV6 >= 1
 Y3_good_step1_c = (Y3_comb_step1 INTERACT V6N >= 5) INTERACT RV6 >= 2
 Y3_good_step1_d = (Y3_comb_step1 INTERACT V6N >= 3) INTERACT RV6 >= 3
 Y3_good_step1_e = (Y3_comb_step1 INTERACT V6N >= 1) INTERACT RV6 >= 4
 Y3_good_step1_f = Y3_comb_step1 INTERACT RV6 >= 5
 Y3_good_step1 = OR Y3_good_step1_a Y3_good_step1_b Y3_good_step1_c Y3_good_step1_d Y3_good_step1_e Y3_good_step1_f
 // 
 Y3_wide_chk_2 = Y3_wide_chk_1 INTERACT (WIDE_all_raw NOT INTERACT Y3_good_step1)
 Y3_comb_step2 = SIZE Y3_comb_step1 BY 0.035 INSIDE OF Y3_wide_chk_2 STEP 0.035 // step2: 0.035
 Y3_good_step2_a = Y3_comb_step2 INTERACT V6N >= 9
 Y3_good_step2_b = (Y3_comb_step2 INTERACT V6N >= 7) INTERACT RV6 >= 1
 Y3_good_step2_c = (Y3_comb_step2 INTERACT V6N >= 5) INTERACT RV6 >= 2
 Y3_good_step2_d = (Y3_comb_step2 INTERACT V6N >= 3) INTERACT RV6 >= 3
 Y3_good_step2_e = (Y3_comb_step2 INTERACT V6N >= 1) INTERACT RV6 >= 4
 Y3_good_step2_f = Y3_comb_step2 INTERACT RV6 >= 5
 Y3_good_step2 = OR Y3_good_step2_a Y3_good_step2_b Y3_good_step2_c Y3_good_step2_d Y3_good_step2_e Y3_good_step2_f
 // 
 Y3_wide_chk_3 = Y3_wide_chk_2 INTERACT (WIDE_all_raw NOT INTERACT Y3_good_step2)
 Y3_comb_step3 = SIZE Y3_comb_step2 BY 0.035 INSIDE OF Y3_wide_chk_3 STEP 0.035 // step3: 0.035
 Y3_good_step3_a = Y3_comb_step3 INTERACT V6N >= 9
 Y3_good_step3_b = (Y3_comb_step3 INTERACT V6N >= 7) INTERACT RV6 >= 1
 Y3_good_step3_c = (Y3_comb_step3 INTERACT V6N >= 5) INTERACT RV6 >= 2
 Y3_good_step3_d = (Y3_comb_step3 INTERACT V6N >= 3) INTERACT RV6 >= 3
 Y3_good_step3_e = (Y3_comb_step3 INTERACT V6N >= 1) INTERACT RV6 >= 4
 Y3_good_step3_f = Y3_comb_step3 INTERACT RV6 >= 5
 Y3_good_step3 = OR Y3_good_step3_a Y3_good_step3_b Y3_good_step3_c Y3_good_step3_d Y3_good_step3_e Y3_good_step3_f
 // 
 Y3_wide_chk_4 = Y3_wide_chk_3 INTERACT (WIDE_all_raw NOT INTERACT Y3_good_step3)
 Y3_comb_step4 = SIZE Y3_comb_step3 BY 0.035 INSIDE OF Y3_wide_chk_4 STEP 0.035 // step4: 0.035
 Y3_good_step4_a = Y3_comb_step4 INTERACT V6N >= 9
 Y3_good_step4_b = (Y3_comb_step4 INTERACT V6N >= 7) INTERACT RV6 >= 1
 Y3_good_step4_c = (Y3_comb_step4 INTERACT V6N >= 5) INTERACT RV6 >= 2
 Y3_good_step4_d = (Y3_comb_step4 INTERACT V6N >= 3) INTERACT RV6 >= 3
 Y3_good_step4_e = (Y3_comb_step4 INTERACT V6N >= 1) INTERACT RV6 >= 4
 Y3_good_step4_f = Y3_comb_step4 INTERACT RV6 >= 5
 Y3_good_step4 = OR Y3_good_step4_a Y3_good_step4_b Y3_good_step4_c Y3_good_step4_d Y3_good_step4_e Y3_good_step4_f
 // 
 Y3_wide_chk_5 = Y3_wide_chk_4 INTERACT (WIDE_all_raw NOT INTERACT Y3_good_step4)
 Y3_comb_step5 = SIZE Y3_comb_step4 BY 0.035 INSIDE OF Y3_wide_chk_5 STEP 0.035 // step5: 0.035
 Y3_good_step5_a = Y3_comb_step5 INTERACT V6N >= 9
 Y3_good_step5_b = (Y3_comb_step5 INTERACT V6N >= 7) INTERACT RV6 >= 1
 Y3_good_step5_c = (Y3_comb_step5 INTERACT V6N >= 5) INTERACT RV6 >= 2
 Y3_good_step5_d = (Y3_comb_step5 INTERACT V6N >= 3) INTERACT RV6 >= 3
 Y3_good_step5_e = (Y3_comb_step5 INTERACT V6N >= 1) INTERACT RV6 >= 4
 Y3_good_step5_f = Y3_comb_step5 INTERACT RV6 >= 5
 Y3_good_step5 = OR Y3_good_step5_a Y3_good_step5_b Y3_good_step5_c Y3_good_step5_d Y3_good_step5_e Y3_good_step5_f
 // 
 Y3_wide_chk_6 = Y3_wide_chk_5 INTERACT (WIDE_all_raw NOT INTERACT Y3_good_step5)
 Y3_comb_step6 = SIZE Y3_comb_step5 BY 0.035 INSIDE OF Y3_wide_chk_6 STEP 0.035 // step6: 0.035
 Y3_good_step6_a = Y3_comb_step6 INTERACT V6N >= 9
 Y3_good_step6_b = (Y3_comb_step6 INTERACT V6N >= 7) INTERACT RV6 >= 1
 Y3_good_step6_c = (Y3_comb_step6 INTERACT V6N >= 5) INTERACT RV6 >= 2
 Y3_good_step6_d = (Y3_comb_step6 INTERACT V6N >= 3) INTERACT RV6 >= 3
 Y3_good_step6_e = (Y3_comb_step6 INTERACT V6N >= 1) INTERACT RV6 >= 4
 Y3_good_step6_f = Y3_comb_step6 INTERACT RV6 >= 5
 Y3_good_step6 = OR Y3_good_step6_a Y3_good_step6_b Y3_good_step6_c Y3_good_step6_d Y3_good_step6_e Y3_good_step6_f
 // 
 Y3_wide_chk_7 = Y3_wide_chk_6 INTERACT (WIDE_all_raw NOT INTERACT Y3_good_step6)
 Y3_comb_step7 = SIZE Y3_comb_step6 BY 0.035 INSIDE OF Y3_wide_chk_7 STEP 0.035 // step7: 0.035
 Y3_good_step7_a = Y3_comb_step7 INTERACT V6N >= 9
 Y3_good_step7_b = (Y3_comb_step7 INTERACT V6N >= 7) INTERACT RV6 >= 1
 Y3_good_step7_c = (Y3_comb_step7 INTERACT V6N >= 5) INTERACT RV6 >= 2
 Y3_good_step7_d = (Y3_comb_step7 INTERACT V6N >= 3) INTERACT RV6 >= 3
 Y3_good_step7_e = (Y3_comb_step7 INTERACT V6N >= 1) INTERACT RV6 >= 4
 Y3_good_step7_f = Y3_comb_step7 INTERACT RV6 >= 5
 Y3_good_step7 = OR Y3_good_step7_a Y3_good_step7_b Y3_good_step7_c Y3_good_step7_d Y3_good_step7_e Y3_good_step7_f
 // 
 Y3_wide_chk_8 = Y3_wide_chk_7 INTERACT (WIDE_all_raw NOT INTERACT Y3_good_step7)
 Y3_comb_step8 = SIZE Y3_comb_step7 BY 0.035 INSIDE OF Y3_wide_chk_8 STEP 0.035 // step8: 0.035
 Y3_good_step8_a = Y3_comb_step8 INTERACT V6N >= 9
 Y3_good_step8_b = (Y3_comb_step8 INTERACT V6N >= 7) INTERACT RV6 >= 1
 Y3_good_step8_c = (Y3_comb_step8 INTERACT V6N >= 5) INTERACT RV6 >= 2
 Y3_good_step8_d = (Y3_comb_step8 INTERACT V6N >= 3) INTERACT RV6 >= 3
 Y3_good_step8_e = (Y3_comb_step8 INTERACT V6N >= 1) INTERACT RV6 >= 4
 Y3_good_step8_f = Y3_comb_step8 INTERACT RV6 >= 5
 Y3_good_step8 = OR Y3_good_step8_a Y3_good_step8_b Y3_good_step8_c Y3_good_step8_d Y3_good_step8_e Y3_good_step8_f
 // 
 Y3_wide_chk_9 = Y3_wide_chk_8 INTERACT (WIDE_all_raw NOT INTERACT Y3_good_step8)
 Y3_comb_step9 = SIZE Y3_comb_step8 BY 0.07 INSIDE OF Y3_wide_chk_9 STEP 0.035 // step9: 0.385-0.07-0.035*7=0.07
 Y3_good_step9_a = Y3_comb_step9 INTERACT V6N >= 9
 Y3_good_step9_b = (Y3_comb_step9 INTERACT V6N >= 7) INTERACT RV6 >= 1
 Y3_good_step9_c = (Y3_comb_step9 INTERACT V6N >= 5) INTERACT RV6 >= 2
 Y3_good_step9_d = (Y3_comb_step9 INTERACT V6N >= 3) INTERACT RV6 >= 3
 Y3_good_step9_e = (Y3_comb_step9 INTERACT V6N >= 1) INTERACT RV6 >= 4
 Y3_good_step9_f = Y3_comb_step9 INTERACT RV6 >= 5
 Y3_good_step9 = OR Y3_good_step9_a Y3_good_step9_b Y3_good_step9_c Y3_good_step9_d Y3_good_step9_e Y3_good_step9_f
 Y3_good = WIDE_all_raw AND (OR Y3_good_step1 Y3_good_step2 Y3_good_step3 Y3_good_step4 Y3_good_step5 Y3_good_step6 Y3_good_step7 Y3_good_step8 Y3_good_step9)
 // 
 err1 = (WIDE_all_raw OUTSIDE (OR Y1_good Y2_good Y3_good)) INTERACT V6
 (err1 NOT INTERACT 125xv6_BAR) NOT INSIDE OCCD
}
 
125xRv6_R_4_M6 {
@ There should be at least two square 1.25xVn or one rectangular 1.25xVn in the intersection area of bottom metal and upper metal, when either wide metal 1.25xMy/1.25xMn or 1.25xMn+1 length >= 0.162um and width >= 0.162um, the space between either via and wide metal <= 1.48um (S, S is the shortest running path length from Via to the wide metal). (except via bar)
@ DRC flags each intersecting area ({bottom metal AND upper metal}) with single square Via within the branch check region
 wide_M6 = (WITH WIDTH M6 > 0.162-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 0.162-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 0.162-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M6_real = wide_M6 NOT OUTSIDE ((SIZE wide_M6 BY 1.48+GLOBAL_TOLERANCE) INTERACT V6)
 all_down_and_up = (M6 INTERACT wide_M6) AND M7
 dis_down_arm_wide_all = SIZE wide_M6_real BY 1.48+GLOBAL_TOLERANCE INSIDE OF M6 STEP 0.025
 dis_down_and_up = dis_down_arm_wide_all AND all_down_and_up
 dis_down_and_up_arm = (dis_down_and_up NOT wide_M6) AND M6
 dis_down_arm = (dis_down_arm_wide_all NOT wide_M6) AND M6
 // 
 dis_down_arm_good_a = dis_down_and_up_arm INTERACT V6N >= 2
 dis_down_arm_good_b = dis_down_and_up_arm INTERACT RV6
 dis_down_arm_good = OR dis_down_arm_good_a dis_down_arm_good_b
 dis_down_arm_bad = (dis_down_and_up_arm NOT dis_down_arm_good) INTERACT (all_down_and_up INTERACT V6N == 1)
 // 
 dis_down_arm_err_stack = (dis_down_arm_bad AND dis_down_and_up_arm) INTERACT V6N
 dis_down_arm_err = dis_down_arm INTERACT dis_down_arm_err_stack
 err1_met_down = (dis_down_arm_err INTERACT (V6N NOT OUTSIDE dis_down_arm_err)) NOT INTERACT RV6
 // 
 wide_M7 = (WITH WIDTH M7 > 0.162-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 0.162-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 0.162-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M7_real = wide_M7 NOT OUTSIDE ((SIZE wide_M7 BY 1.48+GLOBAL_TOLERANCE) INTERACT V6)
 all_up_and_down = (M7 INTERACT wide_M7) AND M6
 dis_up_arm_wide_all = SIZE wide_M7_real BY 1.48+GLOBAL_TOLERANCE INSIDE OF M7 STEP 0.025
 dis_up_and_down = dis_up_arm_wide_all AND all_up_and_down
 dis_up_and_down_arm = (dis_up_and_down NOT wide_M7) AND M7
 dis_up_arm = (dis_up_arm_wide_all NOT wide_M7) AND M7
 // 
 dis_up_arm_good_a = dis_up_and_down_arm INTERACT V6N >= 2
 dis_up_arm_good_b = dis_up_and_down_arm INTERACT RV6
 dis_up_arm_good = OR dis_up_arm_good_a dis_up_arm_good_b
 dis_up_arm_bad = (dis_up_and_down_arm NOT dis_up_arm_good) INTERACT (all_up_and_down INTERACT V6N == 1)
 // 
 dis_up_arm_err_stack = (dis_up_arm_bad AND dis_up_and_down_arm) INTERACT V6N
 dis_up_arm_err = dis_up_arm INTERACT dis_up_arm_err_stack
 err2_met_up = (dis_up_arm_err INTERACT (V6N NOT OUTSIDE dis_up_arm_err)) NOT INTERACT RV6
 err1_met_down NOT INTERACT 125xv6_BAR
}
 
125xRv6_R_4_M7 {
@ There should be at least two square 1.25xVn or one rectangular 1.25xVn in the intersection area of bottom metal and upper metal, when either wide metal 1.25xMy/1.25xMn or 1.25xMn+1 length >= 0.162um and width >= 0.162um, the space between either via and wide metal <= 1.48um (S, S is the shortest running path length from Via to the wide metal). (except via bar)
@ DRC flags each intersecting area ({bottom metal AND upper metal}) with single square Via within the branch check region
 wide_M6 = (WITH WIDTH M6 > 0.162-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 0.162-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 0.162-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M6_real = wide_M6 NOT OUTSIDE ((SIZE wide_M6 BY 1.48+GLOBAL_TOLERANCE) INTERACT V6)
 all_down_and_up = (M6 INTERACT wide_M6) AND M7
 dis_down_arm_wide_all = SIZE wide_M6_real BY 1.48+GLOBAL_TOLERANCE INSIDE OF M6 STEP 0.025
 dis_down_and_up = dis_down_arm_wide_all AND all_down_and_up
 dis_down_and_up_arm = (dis_down_and_up NOT wide_M6) AND M6
 dis_down_arm = (dis_down_arm_wide_all NOT wide_M6) AND M6
 // 
 dis_down_arm_good_a = dis_down_and_up_arm INTERACT V6N >= 2
 dis_down_arm_good_b = dis_down_and_up_arm INTERACT RV6
 dis_down_arm_good = OR dis_down_arm_good_a dis_down_arm_good_b
 dis_down_arm_bad = (dis_down_and_up_arm NOT dis_down_arm_good) INTERACT (all_down_and_up INTERACT V6N == 1)
 // 
 dis_down_arm_err_stack = (dis_down_arm_bad AND dis_down_and_up_arm) INTERACT V6N
 dis_down_arm_err = dis_down_arm INTERACT dis_down_arm_err_stack
 err1_met_down = (dis_down_arm_err INTERACT (V6N NOT OUTSIDE dis_down_arm_err)) NOT INTERACT RV6
 // 
 wide_M7 = (WITH WIDTH M7 > 0.162-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 0.162-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 0.162-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M7_real = wide_M7 NOT OUTSIDE ((SIZE wide_M7 BY 1.48+GLOBAL_TOLERANCE) INTERACT V6)
 all_up_and_down = (M7 INTERACT wide_M7) AND M6
 dis_up_arm_wide_all = SIZE wide_M7_real BY 1.48+GLOBAL_TOLERANCE INSIDE OF M7 STEP 0.025
 dis_up_and_down = dis_up_arm_wide_all AND all_up_and_down
 dis_up_and_down_arm = (dis_up_and_down NOT wide_M7) AND M7
 dis_up_arm = (dis_up_arm_wide_all NOT wide_M7) AND M7
 // 
 dis_up_arm_good_a = dis_up_and_down_arm INTERACT V6N >= 2
 dis_up_arm_good_b = dis_up_and_down_arm INTERACT RV6
 dis_up_arm_good = OR dis_up_arm_good_a dis_up_arm_good_b
 dis_up_arm_bad = (dis_up_and_down_arm NOT dis_up_arm_good) INTERACT (all_up_and_down INTERACT V6N == 1)
 // 
 dis_up_arm_err_stack = (dis_up_arm_bad AND dis_up_and_down_arm) INTERACT V6N
 dis_up_arm_err = dis_up_arm INTERACT dis_up_arm_err_stack
 err2_met_up = (dis_up_arm_err INTERACT (V6N NOT OUTSIDE dis_up_arm_err)) NOT INTERACT RV6
 err2_met_up NOT INTERACT 125xv6_BAR
}
 
125xRv6_R_5_M6 {
@ There should be at least two square 1.25xVn or one rectangular 1.25xVn in the intersection area of bottom metal and upper metal, when either wide metal 1.25xMy/1.25xMn or 1.25xMn+1 length >= 0.91um and width >= 0.91um, the space between either via and wide metal <= 3.59um (S, S is the shortest running path length from Via to the wide metal). (except via bar)
@ DRC flags each intersecting area ({bottom metal AND upper metal}) with single square Via within the branch check region
 wide_M6 = (WITH WIDTH M6 > 0.91-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 0.91-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 0.91-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M6_real = wide_M6 NOT OUTSIDE ((SIZE wide_M6 BY 3.59+GLOBAL_TOLERANCE) INTERACT V6)
 all_down_and_up = (M6 INTERACT wide_M6) AND M7
 dis_down_arm_wide_all = SIZE wide_M6_real BY 3.59+GLOBAL_TOLERANCE INSIDE OF M6 STEP 0.025
 dis_down_and_up = dis_down_arm_wide_all AND all_down_and_up
 dis_down_and_up_arm = (dis_down_and_up NOT wide_M6) AND M6
 dis_down_arm = (dis_down_arm_wide_all NOT wide_M6) AND M6
 // 
 dis_down_arm_good_a = dis_down_and_up_arm INTERACT V6N >= 2
 dis_down_arm_good_b = dis_down_and_up_arm INTERACT RV6
 dis_down_arm_good = OR dis_down_arm_good_a dis_down_arm_good_b
 dis_down_arm_bad = (dis_down_and_up_arm NOT dis_down_arm_good) INTERACT (all_down_and_up INTERACT V6N == 1)
 // 
 dis_down_arm_err_stack = (dis_down_arm_bad AND dis_down_and_up_arm) INTERACT V6N
 dis_down_arm_err = dis_down_arm INTERACT dis_down_arm_err_stack
 err1_met_down = (dis_down_arm_err INTERACT (V6N NOT OUTSIDE dis_down_arm_err)) NOT INTERACT RV6
 // 
 wide_M7 = (WITH WIDTH M7 > 0.91-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 0.91-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 0.91-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M7_real = wide_M7 NOT OUTSIDE ((SIZE wide_M7 BY 3.59+GLOBAL_TOLERANCE) INTERACT V6)
 all_up_and_down = (M7 INTERACT wide_M7) AND M6
 dis_up_arm_wide_all = SIZE wide_M7_real BY 3.59+GLOBAL_TOLERANCE INSIDE OF M7 STEP 0.025
 dis_up_and_down = dis_up_arm_wide_all AND all_up_and_down
 dis_up_and_down_arm = (dis_up_and_down NOT wide_M7) AND M7
 dis_up_arm = (dis_up_arm_wide_all NOT wide_M7) AND M7
 // 
 dis_up_arm_good_a = dis_up_and_down_arm INTERACT V6N >= 2
 dis_up_arm_good_b = dis_up_and_down_arm INTERACT RV6
 dis_up_arm_good = OR dis_up_arm_good_a dis_up_arm_good_b
 dis_up_arm_bad = (dis_up_and_down_arm NOT dis_up_arm_good) INTERACT (all_up_and_down INTERACT V6N == 1)
 // 
 dis_up_arm_err_stack = (dis_up_arm_bad AND dis_up_and_down_arm) INTERACT V6N
 dis_up_arm_err = dis_up_arm INTERACT dis_up_arm_err_stack
 err2_met_up = (dis_up_arm_err INTERACT (V6N NOT OUTSIDE dis_up_arm_err)) NOT INTERACT RV6
 err1_met_down NOT INTERACT 125xv6_BAR
}
 
125xRv6_R_5_M7 {
@ There should be at least two square 1.25xVn or one rectangular 1.25xVn in the intersection area of bottom metal and upper metal, when either wide metal 1.25xMy/1.25xMn or 1.25xMn+1 length >= 0.91um and width >= 0.91um, the space between either via and wide metal <= 3.59um (S, S is the shortest running path length from Via to the wide metal). (except via bar)
@ DRC flags each intersecting area ({bottom metal AND upper metal}) with single square Via within the branch check region
 wide_M6 = (WITH WIDTH M6 > 0.91-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 0.91-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 0.91-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M6_real = wide_M6 NOT OUTSIDE ((SIZE wide_M6 BY 3.59+GLOBAL_TOLERANCE) INTERACT V6)
 all_down_and_up = (M6 INTERACT wide_M6) AND M7
 dis_down_arm_wide_all = SIZE wide_M6_real BY 3.59+GLOBAL_TOLERANCE INSIDE OF M6 STEP 0.025
 dis_down_and_up = dis_down_arm_wide_all AND all_down_and_up
 dis_down_and_up_arm = (dis_down_and_up NOT wide_M6) AND M6
 dis_down_arm = (dis_down_arm_wide_all NOT wide_M6) AND M6
 // 
 dis_down_arm_good_a = dis_down_and_up_arm INTERACT V6N >= 2
 dis_down_arm_good_b = dis_down_and_up_arm INTERACT RV6
 dis_down_arm_good = OR dis_down_arm_good_a dis_down_arm_good_b
 dis_down_arm_bad = (dis_down_and_up_arm NOT dis_down_arm_good) INTERACT (all_down_and_up INTERACT V6N == 1)
 // 
 dis_down_arm_err_stack = (dis_down_arm_bad AND dis_down_and_up_arm) INTERACT V6N
 dis_down_arm_err = dis_down_arm INTERACT dis_down_arm_err_stack
 err1_met_down = (dis_down_arm_err INTERACT (V6N NOT OUTSIDE dis_down_arm_err)) NOT INTERACT RV6
 // 
 wide_M7 = (WITH WIDTH M7 > 0.91-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 0.91-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 0.91-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M7_real = wide_M7 NOT OUTSIDE ((SIZE wide_M7 BY 3.59+GLOBAL_TOLERANCE) INTERACT V6)
 all_up_and_down = (M7 INTERACT wide_M7) AND M6
 dis_up_arm_wide_all = SIZE wide_M7_real BY 3.59+GLOBAL_TOLERANCE INSIDE OF M7 STEP 0.025
 dis_up_and_down = dis_up_arm_wide_all AND all_up_and_down
 dis_up_and_down_arm = (dis_up_and_down NOT wide_M7) AND M7
 dis_up_arm = (dis_up_arm_wide_all NOT wide_M7) AND M7
 // 
 dis_up_arm_good_a = dis_up_and_down_arm INTERACT V6N >= 2
 dis_up_arm_good_b = dis_up_and_down_arm INTERACT RV6
 dis_up_arm_good = OR dis_up_arm_good_a dis_up_arm_good_b
 dis_up_arm_bad = (dis_up_and_down_arm NOT dis_up_arm_good) INTERACT (all_up_and_down INTERACT V6N == 1)
 // 
 dis_up_arm_err_stack = (dis_up_arm_bad AND dis_up_and_down_arm) INTERACT V6N
 dis_up_arm_err = dis_up_arm INTERACT dis_up_arm_err_stack
 err2_met_up = (dis_up_arm_err INTERACT (V6N NOT OUTSIDE dis_up_arm_err)) NOT INTERACT RV6
 err2_met_up NOT INTERACT 125xv6_BAR
}
 
125xRv6_R_6_M6 {
@ There should be at least two square 1.25xVn or one rectangular 1.25xVn in the intersection area of bottom metal and upper metal, when either wide metal 1.25xMy/1.25xMn or 1.25xMn+1 length >= 1.36um and width >= 1.36um, the space between either via and wide metal <= 9um (S, S is the shortest running path length from Via to the wide metal). (except via bar)
@ DRC flags each intersecting area ({bottom metal AND upper metal}) with single square Via within the branch check region
 wide_M6 = (WITH WIDTH M6 > 1.36-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 1.36-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 1.36-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M6_real = wide_M6 NOT OUTSIDE ((SIZE wide_M6 BY 9+GLOBAL_TOLERANCE) INTERACT V6)
 all_down_and_up = (M6 INTERACT wide_M6) AND M7
 dis_down_arm_wide_all = SIZE wide_M6_real BY 9+GLOBAL_TOLERANCE INSIDE OF M6 STEP 0.025
 dis_down_and_up = dis_down_arm_wide_all AND all_down_and_up
 dis_down_and_up_arm = (dis_down_and_up NOT wide_M6) AND M6
 dis_down_arm = (dis_down_arm_wide_all NOT wide_M6) AND M6
 // 
 dis_down_arm_good_a = dis_down_and_up_arm INTERACT V6N >= 2
 dis_down_arm_good_b = dis_down_and_up_arm INTERACT RV6
 dis_down_arm_good = OR dis_down_arm_good_a dis_down_arm_good_b
 dis_down_arm_bad = (dis_down_and_up_arm NOT dis_down_arm_good) INTERACT (all_down_and_up INTERACT V6N == 1)
 // 
 dis_down_arm_err_stack = (dis_down_arm_bad AND dis_down_and_up_arm) INTERACT V6N
 dis_down_arm_err = dis_down_arm INTERACT dis_down_arm_err_stack
 err1_met_down = (dis_down_arm_err INTERACT (V6N NOT OUTSIDE dis_down_arm_err)) NOT INTERACT RV6
 // 
 wide_M7 = (WITH WIDTH M7 > 1.36-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 1.36-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 1.36-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M7_real = wide_M7 NOT OUTSIDE ((SIZE wide_M7 BY 9+GLOBAL_TOLERANCE) INTERACT V6)
 all_up_and_down = (M7 INTERACT wide_M7) AND M6
 dis_up_arm_wide_all = SIZE wide_M7_real BY 9+GLOBAL_TOLERANCE INSIDE OF M7 STEP 0.025
 dis_up_and_down = dis_up_arm_wide_all AND all_up_and_down
 dis_up_and_down_arm = (dis_up_and_down NOT wide_M7) AND M7
 dis_up_arm = (dis_up_arm_wide_all NOT wide_M7) AND M7
 // 
 dis_up_arm_good_a = dis_up_and_down_arm INTERACT V6N >= 2
 dis_up_arm_good_b = dis_up_and_down_arm INTERACT RV6
 dis_up_arm_good = OR dis_up_arm_good_a dis_up_arm_good_b
 dis_up_arm_bad = (dis_up_and_down_arm NOT dis_up_arm_good) INTERACT (all_up_and_down INTERACT V6N == 1)
 // 
 dis_up_arm_err_stack = (dis_up_arm_bad AND dis_up_and_down_arm) INTERACT V6N
 dis_up_arm_err = dis_up_arm INTERACT dis_up_arm_err_stack
 err2_met_up = (dis_up_arm_err INTERACT (V6N NOT OUTSIDE dis_up_arm_err)) NOT INTERACT RV6
 err1_met_down NOT INTERACT 125xv6_BAR
}
 
125xRv6_R_6_M7 {
@ There should be at least two square 1.25xVn or one rectangular 1.25xVn in the intersection area of bottom metal and upper metal, when either wide metal 1.25xMy/1.25xMn or 1.25xMn+1 length >= 1.36um and width >= 1.36um, the space between either via and wide metal <= 9um (S, S is the shortest running path length from Via to the wide metal). (except via bar)
@ DRC flags each intersecting area ({bottom metal AND upper metal}) with single square Via within the branch check region
 wide_M6 = (WITH WIDTH M6 > 1.36-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 1.36-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 1.36-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M6_real = wide_M6 NOT OUTSIDE ((SIZE wide_M6 BY 9+GLOBAL_TOLERANCE) INTERACT V6)
 all_down_and_up = (M6 INTERACT wide_M6) AND M7
 dis_down_arm_wide_all = SIZE wide_M6_real BY 9+GLOBAL_TOLERANCE INSIDE OF M6 STEP 0.025
 dis_down_and_up = dis_down_arm_wide_all AND all_down_and_up
 dis_down_and_up_arm = (dis_down_and_up NOT wide_M6) AND M6
 dis_down_arm = (dis_down_arm_wide_all NOT wide_M6) AND M6
 // 
 dis_down_arm_good_a = dis_down_and_up_arm INTERACT V6N >= 2
 dis_down_arm_good_b = dis_down_and_up_arm INTERACT RV6
 dis_down_arm_good = OR dis_down_arm_good_a dis_down_arm_good_b
 dis_down_arm_bad = (dis_down_and_up_arm NOT dis_down_arm_good) INTERACT (all_down_and_up INTERACT V6N == 1)
 // 
 dis_down_arm_err_stack = (dis_down_arm_bad AND dis_down_and_up_arm) INTERACT V6N
 dis_down_arm_err = dis_down_arm INTERACT dis_down_arm_err_stack
 err1_met_down = (dis_down_arm_err INTERACT (V6N NOT OUTSIDE dis_down_arm_err)) NOT INTERACT RV6
 // 
 wide_M7 = (WITH WIDTH M7 > 1.36-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 1.36-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 1.36-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M7_real = wide_M7 NOT OUTSIDE ((SIZE wide_M7 BY 9+GLOBAL_TOLERANCE) INTERACT V6)
 all_up_and_down = (M7 INTERACT wide_M7) AND M6
 dis_up_arm_wide_all = SIZE wide_M7_real BY 9+GLOBAL_TOLERANCE INSIDE OF M7 STEP 0.025
 dis_up_and_down = dis_up_arm_wide_all AND all_up_and_down
 dis_up_and_down_arm = (dis_up_and_down NOT wide_M7) AND M7
 dis_up_arm = (dis_up_arm_wide_all NOT wide_M7) AND M7
 // 
 dis_up_arm_good_a = dis_up_and_down_arm INTERACT V6N >= 2
 dis_up_arm_good_b = dis_up_and_down_arm INTERACT RV6
 dis_up_arm_good = OR dis_up_arm_good_a dis_up_arm_good_b
 dis_up_arm_bad = (dis_up_and_down_arm NOT dis_up_arm_good) INTERACT (all_up_and_down INTERACT V6N == 1)
 // 
 dis_up_arm_err_stack = (dis_up_arm_bad AND dis_up_and_down_arm) INTERACT V6N
 dis_up_arm_err = dis_up_arm INTERACT dis_up_arm_err_stack
 err2_met_up = (dis_up_arm_err INTERACT (V6N NOT OUTSIDE dis_up_arm_err)) NOT INTERACT RV6
 err2_met_up NOT INTERACT 125xv6_BAR
}
 
125xRv6_R_7 {
@ 45-degree 1.25xRVn is not allowed
 err1 = ANGLE (V6 NOT 125xv6_BAR) > 44.5 < 45.5
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 

#IFDEF Delta_Voltage_Rules_Check YES

125xRv6_R_8 {
@ Maximum delta V >= 5.6V is not allowed, when space between 1.25xRVn is < 0.410um
 chk_VIA = V6 INTERACT DVK_V6_RE
 err1 = DFM DV chk_VIA V6 < 0.410 DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" >= 5.6 ANNOTATE NOT CONNECTED SINGULAR
 DFM COPY err1
}

#ENDIF


// =======================================================
// 10xTVn (TV2) Via design rules
// =======================================================

GROUP G10xTV2 10xTV2_?
 
10xTV2_W_1 {
@ Square 10xTVn size, except MARKS and MARKG regions = 0.324um
 err1 = TV2 NOT TV2N
 err1 NOT INSIDE MARKS_MARKG
}
 
10xTV2_S_1 {
@ Space between 10xTVns >= 0.306um
 err1 = EXT TV2 < 0.306 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
10xTV2_S_2 {
@ Space between 10xTVn and its neighboring 10xTVn(T) >= 0.484um
@ The definition of neighboring 10xTVn(T)
@ 1) 10xTVn(T) is in a 10xTVn group
@ 2) The number of 10xTVn group is >= 4, there are at least 3 10xTVns neighboring to 10xTVn(T)
@ 3) The space between 10xTVn(T) to other 10xTVns in this group < 0.504um
 via_group = TV2 WITH NEIGHBOR >= 3 SPACE < 0.504
 err1 = EXT via_group TV2 < 0.484 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
10xTV2_EN_1 {
@ 10xTVn must be fully enclosed by 1.25xMn, 2xMn, 10xTMn-1, MIM, or CTOP, and must follow 10xTVn.EN.2a 10xTVn.EN.2b, MIM.3 or CTOP.5, where 1.25xMn, 2xMn, 10xTMn-1, MIM, or CTOP is the metal layer directly underneath 10xTVn
 err1 = (TV2 NOT M7) NOT (OR MIM CTOP)
 err1 NOT INSIDE SealR_NOT_BULK
}
 
10xTV2_EN_2a_2 {
@ 10xTVn.EN.2a: 10xTVn must be fully enclosed by 1.25xMn, 2xMn, 10xTMn-1 >= 0.018um
@ 10xTVn.EN.2b: 10xTVn enclosure by 1.25xMn, 2xMn, 10xTMn-1 for two opposite sides with the other two sides >= 0.018um. >= 0.071um
 err1 = RECTANGLE ENCLOSURE (TV2N NOT OUTSIDE M7) M7 ABUT<90 SINGULAR OUTSIDE ALSO 
 GOOD 0.018 0.071 OPPOSITE 0.018 0.071 OPPOSITE
 err1 NOT INSIDE SealR_NOT_BULK
}
 
10xTV2_EN_3 {
@ 10xTVn must be fully enclosed by 10xTMn and must follow 10xTVn.EN.4a, 10xTVn.EN.4b as below, 10xTMn is the metal layer directly above 10xTVn
 err1 = TV2 NOT TM2
 err1 NOT INSIDE SealR_NOT_BULK
}
 
10xTV2_EN_4a_4 {
@ 10xTVn.EN.4a: 10xTVn fully enclosure by 10xTMn >= 0.018um
@ 10xTVn.EN.4b: 10xTVn enclosure by 10xTMn for two opposite sides with the other two sides >= 0.018um. >= 0.071um
 err1 = RECTANGLE ENCLOSURE TV2N TM2 ABUT<90 SINGULAR 
 GOOD 0.018 0.071 OPPOSITE 0.018 0.071 OPPOSITE
 err1 NOT INSIDE SealR_NOT_BULK
}
 
10xTV2_R_2 {
@ 45-degree rotated 10xTVn is not allowed
 WAIVE_BAR = (DONUT TV2) INSIDE MARKS
 err1 = ANGLE (TV2 NOT WAIVE_BAR) > 44.5 < 45.5
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
10xTV2_R_3_M7 {
@ There should be at least two 10xTVns with space <= 1.54um (S1) in 1.25xMn, 2xMn, 10xTMn-1 and 10xTMn intersection area, when either 1.25xMn, 2xMn, 10xTMn-1 and 10xTMn width and length (W1) > 1.63um
 wide_vias = RECTANGLE TV2 ORTHOGONAL ONLY
 wide_M7 = (WITH WIDTH M7 > 1.63) ENCLOSE RECTANGLE 1.63+GLOBAL_TOLERANCE 1.63+GLOBAL_TOLERANCE
 wide_M7_real = wide_M7 NOT OUTSIDE wide_vias
 all_down_and_up = ((M7 INTERACT wide_M7) AND TM2) NOT OUTSIDE wide_M7_real
 all_down_and_up_dis = SIZE wide_vias BY 1.54/2 INSIDE OF all_down_and_up STEP 0.05
 all_down_and_up_good = all_down_and_up_dis INTERACT wide_vias >= 2
 all_down_and_up_bad = (all_down_and_up AND wide_M7_real) OUTSIDE all_down_and_up_good
 err1 = all_down_and_up_bad NOT OUTSIDE wide_vias
 // 
 wide_TM2 = (WITH WIDTH TM2 > 1.63) ENCLOSE RECTANGLE 1.63+GLOBAL_TOLERANCE 1.63+GLOBAL_TOLERANCE
 wide_TM2_real = wide_TM2 NOT OUTSIDE wide_vias
 all_up_and_down = ((TM2 INTERACT wide_TM2) AND M7) NOT OUTSIDE wide_TM2_real
 all_up_and_down_dis = SIZE wide_vias BY 1.54/2 INSIDE OF all_up_and_down STEP 0.05
 all_up_and_down_good = all_up_and_down_dis INTERACT wide_vias >= 2
 all_up_and_down_bad = (all_up_and_down AND wide_TM2_real) OUTSIDE all_up_and_down_good
 err2 = all_up_and_down_bad NOT OUTSIDE wide_vias
 err1 NOT INSIDE SealR_NOT_BULK
}
 
10xTV2_R_3_TM2 {
@ There should be at least two 10xTVns with space <= 1.54um (S1) in 1.25xMn, 2xMn, 10xTMn-1 and 10xTMn intersection area, when either 1.25xMn, 2xMn, 10xTMn-1 and 10xTMn width and length (W1) > 1.63um
 wide_vias = RECTANGLE TV2 ORTHOGONAL ONLY
 wide_M7 = (WITH WIDTH M7 > 1.63) ENCLOSE RECTANGLE 1.63+GLOBAL_TOLERANCE 1.63+GLOBAL_TOLERANCE
 wide_M7_real = wide_M7 NOT OUTSIDE wide_vias
 all_down_and_up = ((M7 INTERACT wide_M7) AND TM2) NOT OUTSIDE wide_M7_real
 all_down_and_up_dis = SIZE wide_vias BY 1.54/2 INSIDE OF all_down_and_up STEP 0.05
 all_down_and_up_good = all_down_and_up_dis INTERACT wide_vias >= 2
 all_down_and_up_bad = (all_down_and_up AND wide_M7_real) OUTSIDE all_down_and_up_good
 err1 = all_down_and_up_bad NOT OUTSIDE wide_vias
 // 
 wide_TM2 = (WITH WIDTH TM2 > 1.63) ENCLOSE RECTANGLE 1.63+GLOBAL_TOLERANCE 1.63+GLOBAL_TOLERANCE
 wide_TM2_real = wide_TM2 NOT OUTSIDE wide_vias
 all_up_and_down = ((TM2 INTERACT wide_TM2) AND M7) NOT OUTSIDE wide_TM2_real
 all_up_and_down_dis = SIZE wide_vias BY 1.54/2 INSIDE OF all_up_and_down STEP 0.05
 all_up_and_down_good = all_up_and_down_dis INTERACT wide_vias >= 2
 all_up_and_down_bad = (all_up_and_down AND wide_TM2_real) OUTSIDE all_up_and_down_good
 err2 = all_up_and_down_bad NOT OUTSIDE wide_vias
 err2 NOT INSIDE SealR_NOT_BULK
}
 
10xTV2_R_4_M7 {
@ There should be at least two 10xTVns in the intersection area of 1.25xMn, 2xMn, 10xTMn-1 and 10xTMn, when either wide metal of 1.25xMn, 2xMn, 10xTMn-1 and 10xTMn with both width W > 2.75um and length L > 9.1um, the space between either via and wide metal is <= 5.4um (D3, D3 is the shortest running path length from 10xTVn to the wide metal)
@ DRC flags each intersecting area ((bottom metal AND upper metal)) with single square Via within the branch check region
 wide_vias = RECTANGLE TV2 ORTHOGONAL ONLY
 wide_M7 = (WITH WIDTH M7 > 2.75) ENCLOSE RECTANGLE 2.75+GLOBAL_TOLERANCE 9.1+GLOBAL_TOLERANCE
 wide_M7_real = wide_M7 NOT OUTSIDE ((SIZE wide_M7 BY 5.4+GLOBAL_TOLERANCE) INTERACT TV2)
 all_down_and_up = (M7 INTERACT wide_M7) AND TM2
 dis_down_arm_wide_all = SIZE wide_M7_real BY 5.4+GLOBAL_TOLERANCE INSIDE OF M7 STEP 0.04
 dis_down_and_up = dis_down_arm_wide_all AND all_down_and_up
 dis_down_and_up_arm = (dis_down_and_up NOT wide_M7) AND M7
 dis_down_arm = (dis_down_arm_wide_all NOT wide_M7) AND M7
 // 
 dis_down_arm_good = dis_down_and_up_arm INTERACT wide_vias >= 2
 dis_down_arm_bad = (dis_down_and_up_arm NOT dis_down_arm_good) INTERACT (all_down_and_up INTERACT wide_vias == 1)
 dis_down_arm_err_stack = (dis_down_arm_bad AND dis_down_and_up_arm) INTERACT wide_vias
 dis_down_arm_err = dis_down_arm INTERACT dis_down_arm_err_stack
 err1 = dis_down_arm_err INTERACT (wide_vias NOT OUTSIDE dis_down_arm_err)
 // 
 wide_TM2 = (WITH WIDTH TM2 > 2.75) ENCLOSE RECTANGLE 2.75+GLOBAL_TOLERANCE 9.1+GLOBAL_TOLERANCE
 wide_TM2_real = wide_TM2 NOT OUTSIDE ((SIZE wide_TM2 BY 5.4+GLOBAL_TOLERANCE) INTERACT TV2)
 all_up_and_down = (TM2 INTERACT wide_TM2) AND M7
 dis_up_arm_wide_all = SIZE wide_TM2_real BY 5.4+GLOBAL_TOLERANCE INSIDE OF TM2 STEP 0.04
 dis_up_and_down = dis_up_arm_wide_all AND all_up_and_down
 dis_up_and_down_arm = (dis_up_and_down NOT wide_TM2) AND TM2
 dis_up_arm = (dis_up_arm_wide_all NOT wide_TM2) AND TM2
 // 
 dis_up_arm_good = dis_up_and_down_arm INTERACT wide_vias >= 2
 dis_up_arm_bad = (dis_up_and_down_arm NOT dis_up_arm_good) INTERACT (all_up_and_down INTERACT wide_vias == 1)
 dis_up_arm_err_stack = (dis_up_arm_bad AND dis_up_and_down_arm) INTERACT wide_vias
 dis_up_arm_err = dis_up_arm INTERACT dis_up_arm_err_stack
 err2 = dis_up_arm_err INTERACT (wide_vias NOT OUTSIDE dis_up_arm_err)
 err1 NOT INSIDE SealR_NOT_BULK
}
 
10xTV2_R_4_TM2 {
@ There should be at least two 10xTVns in the intersection area of 1.25xMn, 2xMn, 10xTMn-1 and 10xTMn, when either wide metal of 1.25xMn, 2xMn, 10xTMn-1 and 10xTMn with both width W > 2.75um and length L > 9.1um, the space between either via and wide metal is <= 5.4um (D3, D3 is the shortest running path length from 10xTVn to the wide metal)
@ DRC flags each intersecting area ((bottom metal AND upper metal)) with single square Via within the branch check region
 wide_vias = RECTANGLE TV2 ORTHOGONAL ONLY
 wide_M7 = (WITH WIDTH M7 > 2.75) ENCLOSE RECTANGLE 2.75+GLOBAL_TOLERANCE 9.1+GLOBAL_TOLERANCE
 wide_M7_real = wide_M7 NOT OUTSIDE ((SIZE wide_M7 BY 5.4+GLOBAL_TOLERANCE) INTERACT TV2)
 all_down_and_up = (M7 INTERACT wide_M7) AND TM2
 dis_down_arm_wide_all = SIZE wide_M7_real BY 5.4+GLOBAL_TOLERANCE INSIDE OF M7 STEP 0.04
 dis_down_and_up = dis_down_arm_wide_all AND all_down_and_up
 dis_down_and_up_arm = (dis_down_and_up NOT wide_M7) AND M7
 dis_down_arm = (dis_down_arm_wide_all NOT wide_M7) AND M7
 // 
 dis_down_arm_good = dis_down_and_up_arm INTERACT wide_vias >= 2
 dis_down_arm_bad = (dis_down_and_up_arm NOT dis_down_arm_good) INTERACT (all_down_and_up INTERACT wide_vias == 1)
 dis_down_arm_err_stack = (dis_down_arm_bad AND dis_down_and_up_arm) INTERACT wide_vias
 dis_down_arm_err = dis_down_arm INTERACT dis_down_arm_err_stack
 err1 = dis_down_arm_err INTERACT (wide_vias NOT OUTSIDE dis_down_arm_err)
 // 
 wide_TM2 = (WITH WIDTH TM2 > 2.75) ENCLOSE RECTANGLE 2.75+GLOBAL_TOLERANCE 9.1+GLOBAL_TOLERANCE
 wide_TM2_real = wide_TM2 NOT OUTSIDE ((SIZE wide_TM2 BY 5.4+GLOBAL_TOLERANCE) INTERACT TV2)
 all_up_and_down = (TM2 INTERACT wide_TM2) AND M7
 dis_up_arm_wide_all = SIZE wide_TM2_real BY 5.4+GLOBAL_TOLERANCE INSIDE OF TM2 STEP 0.04
 dis_up_and_down = dis_up_arm_wide_all AND all_up_and_down
 dis_up_and_down_arm = (dis_up_and_down NOT wide_TM2) AND TM2
 dis_up_arm = (dis_up_arm_wide_all NOT wide_TM2) AND TM2
 // 
 dis_up_arm_good = dis_up_and_down_arm INTERACT wide_vias >= 2
 dis_up_arm_bad = (dis_up_and_down_arm NOT dis_up_arm_good) INTERACT (all_up_and_down INTERACT wide_vias == 1)
 dis_up_arm_err_stack = (dis_up_arm_bad AND dis_up_and_down_arm) INTERACT wide_vias
 dis_up_arm_err = dis_up_arm INTERACT dis_up_arm_err_stack
 err2 = dis_up_arm_err INTERACT (wide_vias NOT OUTSIDE dis_up_arm_err)
 err2 NOT INSIDE SealR_NOT_BULK
}
 

#IFDEF Delta_Voltage_Rules_Check YES

10xTV2_R_5 {
@ It is not allowed for maximum delta V >= 5.6V, when space between 10xTVn is < 0.410um
 err1 = DFM DV V7 < 0.410 DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" >= 5.6 ANNOTATE NOT CONNECTED SINGULAR
 DFM COPY err1
}

#ENDIF

 
10xTV2_R_1_6 {
@ 10xTVn.R.1: 10xTVn and 14xTVn can't be used on same chip
@ 10xTVn.R.6: 10xTVn must be drawn on data type of 0
 err1 = TV2_40 INTERACT DRC:1
 err1 NOT INSIDE SealR_NOT_BULK
}
 
10xTV2_R_7 {
@ It's not allowed 10xTVn overlap with the metal resistor directly underneath and above the 10xTVn
 err1 = TV2 AND (M7RES AND M7)
 err2 = TV2 AND (TM2RES AND TM2)
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}
 //;10xTVn.R.10 Recommend to use redundant vias to avoid high Rc 

// =======================================================
// 10xTMn (TM1/TM2/TM3) Via design rules
// =======================================================

GROUP G10xTM2 10xTM2_?
 
10xTM2_W_1 {
@ 10xTMn width >= 0.36um
 err1 = INT TM2 < 0.36 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
10xTM2_W_2 {
@ 10xTMn width, except AL pad, DUPMK1 and INDMY regions <= 11um
 chk_mn = TM2 NOT (OR MD DUPMK1 INDMY)
 err1 = chk_mn WITH WIDTH > 11
 err1 NOT INSIDE SealR_NOT_BULK
}
 
10xTM2_S_1 {
@ Space between 10xTMns, except LOGO region >= 0.36um
 err1 = EXT TM2 < 0.36 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE LOGO
}
 
10xTM2_S_2 {
@ Space between two 10xTMns when one or both 10xTMn widths are > 1.35um and PRL > 1.35um. >= 0.448um
 met_wid_all = TM2 WITH WIDTH >= 1.35+GLOBAL_TOLERANCE
 met_err_RAW = EXT TM2 met_wid_all < 0.448 OPPOSITE REGION MEASURE ALL
 met_err_CRN = EXT (ANGLE TM2 > 44 < 46) met_wid_all < 0.448 OPPOSITE1 REGION MEASURE ALL
 err1 = met_err_RAW ENCLOSE RECTANGLE 0.001 1.351 ORTHOGONAL ONLY
 err2 = met_err_CRN ENCLOSE RECTANGLE 0.36 1.351
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}
 
10xTM2_S_3 {
@ Space between two 10xTMns when one or both 10xTMn widths is > 4.08um and PRL > 4.08um. >= 1.33um
 met_wid_all = TM2 WITH WIDTH >= 4.08+GLOBAL_TOLERANCE
 met_err_RAW = EXT TM2 met_wid_all < 1.33 OPPOSITE REGION MEASURE ALL
 met_err_CRN = EXT (ANGLE TM2 > 44 < 46) met_wid_all < 1.33 OPPOSITE1 REGION MEASURE ALL
 err1 = met_err_RAW ENCLOSE RECTANGLE 0.001 4.081 ORTHOGONAL ONLY
 err2 = met_err_CRN ENCLOSE RECTANGLE 0.36 4.081
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}
 
10xTM2_A_1 {
@ 10xTMn area >= 0.453um2
 err1 = AREA TM2 < 0.453
 err1 NOT INSIDE SealR_NOT_BULK
}
 
10xTM2_A_2 {
@ 10xTMn enclosed area >= 0.463um2
 err1 = AREA ((HOLES TM2 INNER) NOT TM2) < 0.463
 err1 NOT INSIDE SealR_NOT_BULK
}
 

#IFDEF IP_LEVEL_DENSITY_CHECK YES
#IFDEF MINIMUM_DENSITY_CHECK YES

10xTM2_DN_1 {
@ 10xTMn density (window112um*112um, stepping 112um/step_number), except DUPMK1, PAD, INDMY, LOGO regions >= 10.5%
 check_region = CHIP_NOT_MARKS NOT (OR DUPMK1 MD INDMY LOGO)
 check_pattern = TM2_all AND check_region
 // 
 check_window1 = check_region WITH WIDTH >= 112/4
 err1_TMP1 = DENSITY check_pattern check_window1 check_region [!AREA(check_window1) + !!AREA(check_window1)*AREA(check_pattern)/AREA(check_region)] < 0.105 WINDOW 112 STEP 112/step_number BACKUP INSIDE OF LAYER DRC:1 BY POLYGON
 // 
 check_window2 = WITH WIDTH (check_region AND err1_TMP1) >= 112/4
 err1_TMP2 = DENSITY check_pattern check_window2 check_region [!AREA(check_window2) + !!AREA(check_window2)*AREA(check_pattern)/AREA(check_region)] < 0.105 WINDOW 112 STEP 112/step_number BACKUP INSIDE OF LAYER err1_TMP1 BY POLYGON
 // 
 check_window3 = WITH WIDTH (check_region AND err1_TMP2) >= 112/4
 DENSITY check_pattern check_window3 check_region [!AREA(check_window3) + !!AREA(check_window3)*AREA(check_pattern)/AREA(check_region)] < 0.105 WINDOW 112 STEP 112/step_number BACKUP INSIDE OF LAYER err1_TMP2 BY POLYGON PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_10xTM2_DN_1.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_10xTM2_DN_1.rdb"
}

#ENDIF

 
10xTM2_DN_2 {
@ 10xTMn density (window112um*112um, stepping 112um/step_number), except DUPMK, PAD, LOGO regions <= 80.8%
 check_region = CHIP_NOT_MARKS NOT (OR DUPMK1 MD LOGO)
 check_pattern = TM2_all AND check_region
 // 
 check_window1 = check_region WITH WIDTH >= 112/4
 err1_TMP1 = DENSITY check_pattern check_window1 check_region [!!AREA(check_window1)*AREA(check_pattern)/AREA(check_region)] > 0.808 WINDOW 112 STEP 112/step_number BACKUP INSIDE OF LAYER DRC:1 BY POLYGON
 // 
 check_window2 = WITH WIDTH (check_region AND err1_TMP1) >= 112/4
 err1_TMP2 = DENSITY check_pattern check_window2 check_region [!!AREA(check_window2)*AREA(check_pattern)/AREA(check_region)] > 0.808 WINDOW 112 STEP 112/step_number BACKUP INSIDE OF LAYER err1_TMP1 BY POLYGON
 // 
 check_window3 = WITH WIDTH (check_region AND err1_TMP2) >= 112/4
 DENSITY check_pattern check_window3 check_region [!!AREA(check_window3)*AREA(check_pattern)/AREA(check_region)] > 0.808 WINDOW 112 STEP 112/step_number BACKUP INSIDE OF LAYER err1_TMP2 BY POLYGON PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_10xTM2_DN_2.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_10xTM2_DN_2.rdb"
}
 
10xTM2_DN_3 {
@ 10xTMn density difference between any two neighboring checking windows (window 180um*180um, stepping 360um/step_number), except NODMF su 0.4um region <= 47.5%
 check_pattern = (TM2_all NOT MARKS) NOT NODMF_SIZE_0.4
 check_region = CHIP_NOT_MARKS NOT NODMF_SIZE_0.4
 DENSITY check_pattern check_region [AREA(check_pattern)/AREA(check_region)] >= 0 WINDOW 180 STEP 360/step_number GRADIENT > 0.475 ABSOLUTE BACKUP PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_10xTM2_DN_3.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_10xTM2_DN_3.rdb"
}
 

#IFDEF MINIMUM_DENSITY_CHECK YES

10xTM2_DN_4 {
@ 10xTMn full chip density >= 20%
 check_pattern = TM2_all NOT MARKS
 DENSITY check_pattern CHIP_NOT_MARKS [AREA(check_pattern)/AREA(CHIP_NOT_MARKS)] < 0.20 PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_10xTM2_DN_4.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_10xTM2_DN_4.rdb"
}

#ENDIF
#ENDIF

 

#IFDEF IP_LEVEL_DENSITY_CHECK NO
#IFDEF MINIMUM_DENSITY_CHECK YES

10xTM2_DN_1 {
@ 10xTMn density (window112um*112um, stepping 56um), except DUPMK1, PAD, INDMY, LOGO regions >= 10%
 check_region = CHIP_NOT_MARKS NOT (OR DUPMK1 MD INDMY LOGO)
 check_pattern = TM2_all AND check_region
 // 
 check_window1 = check_region WITH WIDTH >= 112/4
 err1_TMP1 = DENSITY check_pattern check_window1 check_region [!AREA(check_window1) + !!AREA(check_window1)*AREA(check_pattern)/AREA(check_region)] < 0.1 WINDOW 112 STEP 56 BACKUP INSIDE OF LAYER DRC:1 BY POLYGON
 // 
 check_window2 = WITH WIDTH (check_region AND err1_TMP1) >= 112/4
 err1_TMP2 = DENSITY check_pattern check_window2 check_region [!AREA(check_window2) + !!AREA(check_window2)*AREA(check_pattern)/AREA(check_region)] < 0.1 WINDOW 112 STEP 56 BACKUP INSIDE OF LAYER err1_TMP1 BY POLYGON
 // 
 check_window3 = WITH WIDTH (check_region AND err1_TMP2) >= 112/4
 DENSITY check_pattern check_window3 check_region [!AREA(check_window3) + !!AREA(check_window3)*AREA(check_pattern)/AREA(check_region)] < 0.1 WINDOW 112 STEP 56 BACKUP INSIDE OF LAYER err1_TMP2 BY POLYGON PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_10xTM2_DN_1.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_10xTM2_DN_1.rdb"
}

#ENDIF

 
10xTM2_DN_2 {
@ 10xTMn density (window112um*112um, stepping 56um), except DUPMK, PAD, LOGO regions <= 85%
 check_region = CHIP_NOT_MARKS NOT (OR DUPMK1 MD LOGO)
 check_pattern = TM2_all AND check_region
 // 
 check_window1 = check_region WITH WIDTH >= 112/4
 err1_TMP1 = DENSITY check_pattern check_window1 check_region [!!AREA(check_window1)*AREA(check_pattern)/AREA(check_region)] > 0.85 WINDOW 112 STEP 56 BACKUP INSIDE OF LAYER DRC:1 BY POLYGON
 // 
 check_window2 = WITH WIDTH (check_region AND err1_TMP1) >= 112/4
 err1_TMP2 = DENSITY check_pattern check_window2 check_region [!!AREA(check_window2)*AREA(check_pattern)/AREA(check_region)] > 0.85 WINDOW 112 STEP 56 BACKUP INSIDE OF LAYER err1_TMP1 BY POLYGON
 // 
 check_window3 = WITH WIDTH (check_region AND err1_TMP2) >= 112/4
 DENSITY check_pattern check_window3 check_region [!!AREA(check_window3)*AREA(check_pattern)/AREA(check_region)] > 0.85 WINDOW 112 STEP 56 BACKUP INSIDE OF LAYER err1_TMP2 BY POLYGON PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_10xTM2_DN_2.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_10xTM2_DN_2.rdb"
}
 
10xTM2_DN_3 {
@ 10xTMn density difference between any two neighboring checking windows (window 180um*180um, stepping 180um), except NODMF su 0.4um region <= 50%
 check_pattern = (TM2_all NOT MARKS) NOT NODMF_SIZE_0.4
 check_region = CHIP_NOT_MARKS NOT NODMF_SIZE_0.4
 DENSITY check_pattern check_region [AREA(check_pattern)/AREA(check_region)] >= 0 WINDOW 180 STEP 180 GRADIENT > 0.5 ABSOLUTE BACKUP PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_10xTM2_DN_3.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_10xTM2_DN_3.rdb"
}
 

#IFDEF MINIMUM_DENSITY_CHECK YES

10xTM2_DN_4 {
@ 10xTMn full chip density >= 20%
 check_pattern = TM2_all NOT MARKS
 DENSITY check_pattern CHIP_NOT_MARKS [AREA(check_pattern)/AREA(CHIP_NOT_MARKS)] < 0.20 PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_10xTM2_DN_4.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_10xTM2_DN_4.rdb"
}

#ENDIF
#ENDIF

 
10xTM2_R_1_2 {
@ 10xTMn.R.1: 10xTMn must be drawn on data type of 0
@ 10xTMn.R.2: 10xTMn and 14xTMn can't be used on same chip
 TM2_40 INTERACT DRC:1
}
 

#IFDEF Delta_Voltage_Rules_Check YES

 
10xTM2_R_3_TM2 {
@ Maximum delta V >= 5.6V is not allowed, when space between 10xTMn and 10xTMn/10xTVn-1/10xTVn is < 3.6um
 err1 = DFM DV M8 < 3.600 DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" >= 5.6 ANNOTATE NOT CONNECTED SINGULAR
 DFM COPY err1
}
 
10xTM2_R_3_TV2 {
@ Maximum delta V >= 5.6V is not allowed, when space between 10xTMn and 10xTMn/10xTVn-1/10xTVn is < 3.6um
 err1 = DFM DV M8 V7 < 3.600 DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" >= 5.6 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err1
}

#ENDIF

 

#IFDEF Delta_Voltage_Rules_Check YES


#ENDIF

 
st_0 = (M0 AND M1) ENCLOSE V0 == 1
st_1 = (M1 AND M2) ENCLOSE V1 == 1
st_2 = (M2 AND M3) ENCLOSE V2 == 1
st_3 = (M3 AND M4) ENCLOSE V3 == 1
st_4 = (M4 AND M5) ENCLOSE V4 == 1
st_5 = (M5 AND M6) ENCLOSE V5 == 1
st_6 = (M6 AND M7) ENCLOSE V6 == 1
st_7 = (M7 AND M8) ENCLOSE V7 == 1
stack_0 = RECTANGLE (V0 INTERACT st_0) ASPECT == 1
stack_1 = RECTANGLE (V1 INTERACT st_1) ASPECT == 1
stack_2 = RECTANGLE (V2 INTERACT st_2) ASPECT == 1
stack_3 = RECTANGLE (V3 INTERACT st_3) ASPECT == 1
stack_4 = RECTANGLE (V4 INTERACT st_4) ASPECT == 1
stack_5 = RECTANGLE (V5 INTERACT st_5) ASPECT == 1
stack_6 = RECTANGLE (V6 INTERACT st_6) ASPECT == 1
stack_7 = RECTANGLE (V7 INTERACT st_7) ASPECT == 1

#IFDEF DFM_RULES_PRIORITY_1 YES

 
TV_R_10_V0V1V2V3V4_DFM1 {
@ 10xTV.R.10.DFM: Recommended maximum continuous stacked VIA layers (including V0), which has only one square via for each via layer to avoid high Rc <= 4
@ 14xTV.R.10.DFM: Recommended maximum continuous stacked VIA layers (including V0), which has only one square via for each via layer to avoid high Rc <= 4
@ UTV.R.10.DFM: Recommended maximum continuous stacked VIA layers (including V0), which has only one square via for each via layer to avoid high Rc <= 4
 stack_3_vias = stack_3 INTERACT (stack_3 AND stack_4)
 stack_4_vias = stack_2 INTERACT (stack_2 AND stack_3_vias)
 stack_5_vias = stack_1 INTERACT (stack_1 AND stack_4_vias)
 err1 = stack_0 INTERACT (stack_0 AND stack_5_vias)
 err1 NOT INSIDE SealR_NOT_BULK
}
 
TV_R_10_V1V2V3V4V5_DFM1 {
@ 10xTV.R.10.DFM: Recommended maximum continuous stacked VIA layers (including V0), which has only one square via for each via layer to avoid high Rc <= 4
@ 14xTV.R.10.DFM: Recommended maximum continuous stacked VIA layers (including V0), which has only one square via for each via layer to avoid high Rc <= 4
@ UTV.R.10.DFM: Recommended maximum continuous stacked VIA layers (including V0), which has only one square via for each via layer to avoid high Rc <= 4
 stack_3_vias = stack_4 INTERACT (stack_4 AND stack_5)
 stack_4_vias = stack_3 INTERACT (stack_3 AND stack_3_vias)
 stack_5_vias = stack_2 INTERACT (stack_2 AND stack_4_vias)
 err1 = stack_1 INTERACT (stack_1 AND stack_5_vias)
 err1 NOT INSIDE SealR_NOT_BULK
}
 
TV_R_10_V2V3V4V5V6_DFM1 {
@ 10xTV.R.10.DFM: Recommended maximum continuous stacked VIA layers (including V0), which has only one square via for each via layer to avoid high Rc <= 4
@ 14xTV.R.10.DFM: Recommended maximum continuous stacked VIA layers (including V0), which has only one square via for each via layer to avoid high Rc <= 4
@ UTV.R.10.DFM: Recommended maximum continuous stacked VIA layers (including V0), which has only one square via for each via layer to avoid high Rc <= 4
 stack_3_vias = stack_5 INTERACT (stack_5 AND stack_6)
 stack_4_vias = stack_4 INTERACT (stack_4 AND stack_3_vias)
 stack_5_vias = stack_3 INTERACT (stack_3 AND stack_4_vias)
 err1 = stack_2 INTERACT (stack_2 AND stack_5_vias)
 err1 NOT INSIDE SealR_NOT_BULK
}
 
TV_R_10_V3V4V5V6V7_DFM1 {
@ 10xTV.R.10.DFM: Recommended maximum continuous stacked VIA layers (including V0), which has only one square via for each via layer to avoid high Rc <= 4
@ 14xTV.R.10.DFM: Recommended maximum continuous stacked VIA layers (including V0), which has only one square via for each via layer to avoid high Rc <= 4
@ UTV.R.10.DFM: Recommended maximum continuous stacked VIA layers (including V0), which has only one square via for each via layer to avoid high Rc <= 4
 stack_3_vias = stack_6 INTERACT (stack_6 AND stack_7)
 stack_4_vias = stack_5 INTERACT (stack_5 AND stack_3_vias)
 stack_5_vias = stack_4 INTERACT (stack_4 AND stack_4_vias)
 err1 = stack_3 INTERACT (stack_3 AND stack_5_vias)
 err1 NOT INSIDE SealR_NOT_BULK
}

#ENDIF


#IFDEF IP_LEVEL_DENSITY_CHECK YES
#IFDEF MINIMUM_DENSITY_CHECK YES


#ENDIF
#ENDIF


#IFDEF IP_LEVEL_DENSITY_CHECK YES
#IFDEF MINIMUM_DENSITY_CHECK YES


#ENDIF
#ENDIF


#IFDEF IP_LEVEL_DENSITY_CHECK YES
#IFDEF MINIMUM_DENSITY_CHECK YES

 
125xmn_DN_6_M2M3M4 {
@ Mxy.D.6: It is not allowed to have local density of all three consecutive metal (Mxy, Mxy+1, Mxy+2) over any 30um*30um (stepping 30um/step_number), except NODMF su 0.4um region
@ The metal layers of Mxy+1 and Mxy+2 include Mxy, 1.25xMy, 1.25xMn, and relevant dummy metals <= 5.3%
@ 125xMy.DN.5: It is not allowed to have local density < 5.3% of all 3 consecutive metal layers over any 30um*30um window (stepping 30um/step_number), except (NODMF su 0.4um) region
@ The metal layers of Mxy+1 and Mxy+2 include Mxy, 1.25xMy, 1.25xMn, and relevant dummy metals
@ 125xMn.DN.6: It is not allowed to have local density < 5.3% of all 3 consecutive metal layers over any 30um*30um window (stepping 30um/step_number), except (NODMF) su 0.4um region
 check_region = ((DRC:1 NOT NODMF_SIZE_0.4) NOT LDNMK1) WITH WIDTH >= 15
 except_area = (NODMF_SIZE_0.4 OR LDNMK1) OR MARKS
 N = (check_region NOT MARKS) WITH WIDTH >= 15
 P = (M2_all NOT except_area) AND N
 Q = (M3_all NOT except_area) AND N
 M = (M4_all NOT except_area) AND N
 DENSITY P Q M N > 0 WINDOW 30 STEP 30/step_number BACKUP PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_125xmn_DN_6_M2M3M4.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_125xmn_DN_6_M2M3M4.rdb" [(~~(0.053 - AREA(P)/AREA(N)))*(~~(0.053 - AREA(Q)/AREA(N)))*(~~(0.053 - AREA(M)/AREA(N)))]
}
 
125xmn_DN_6_M3M4M5 {
@ Mxy.D.6: It is not allowed to have local density of all three consecutive metal (Mxy, Mxy+1, Mxy+2) over any 30um*30um (stepping 30um/step_number), except NODMF su 0.4um region
@ The metal layers of Mxy+1 and Mxy+2 include Mxy, 1.25xMy, 1.25xMn, and relevant dummy metals <= 5.3%
@ 125xMy.DN.5: It is not allowed to have local density < 5.3% of all 3 consecutive metal layers over any 30um*30um window (stepping 30um/step_number), except (NODMF su 0.4um) region
@ The metal layers of Mxy+1 and Mxy+2 include Mxy, 1.25xMy, 1.25xMn, and relevant dummy metals
@ 125xMn.DN.6: It is not allowed to have local density < 5.3% of all 3 consecutive metal layers over any 30um*30um window (stepping 30um/step_number), except (NODMF) su 0.4um region
 check_region = ((DRC:1 NOT NODMF_SIZE_0.4) NOT LDNMK1) WITH WIDTH >= 15
 except_area = (NODMF_SIZE_0.4 OR LDNMK1) OR MARKS
 N = (check_region NOT MARKS) WITH WIDTH >= 15
 P = (M3_all NOT except_area) AND N
 Q = (M4_all NOT except_area) AND N
 M = (M5_all NOT except_area) AND N
 DENSITY P Q M N > 0 WINDOW 30 STEP 30/step_number BACKUP PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_125xmn_DN_6_M3M4M5.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_125xmn_DN_6_M3M4M5.rdb" [(~~(0.053 - AREA(P)/AREA(N)))*(~~(0.053 - AREA(Q)/AREA(N)))*(~~(0.053 - AREA(M)/AREA(N)))]
}
 
125xmn_DN_6_M4M5M6 {
@ Mxy.D.6: It is not allowed to have local density of all three consecutive metal (Mxy, Mxy+1, Mxy+2) over any 30um*30um (stepping 30um/step_number), except NODMF su 0.4um region
@ The metal layers of Mxy+1 and Mxy+2 include Mxy, 1.25xMy, 1.25xMn, and relevant dummy metals <= 5.3%
@ 125xMy.DN.5: It is not allowed to have local density < 5.3% of all 3 consecutive metal layers over any 30um*30um window (stepping 30um/step_number), except (NODMF su 0.4um) region
@ The metal layers of Mxy+1 and Mxy+2 include Mxy, 1.25xMy, 1.25xMn, and relevant dummy metals
@ 125xMn.DN.6: It is not allowed to have local density < 5.3% of all 3 consecutive metal layers over any 30um*30um window (stepping 30um/step_number), except (NODMF) su 0.4um region
 check_region = ((DRC:1 NOT NODMF_SIZE_0.4) NOT LDNMK1) WITH WIDTH >= 15
 except_area = (NODMF_SIZE_0.4 OR LDNMK1) OR MARKS
 N = (check_region NOT MARKS) WITH WIDTH >= 15
 P = (M4_all NOT except_area) AND N
 Q = (M5_all NOT except_area) AND N
 M = (M6_all NOT except_area) AND N
 DENSITY P Q M N > 0 WINDOW 30 STEP 30/step_number BACKUP PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_125xmn_DN_6_M4M5M6.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_125xmn_DN_6_M4M5M6.rdb" [(~~(0.053 - AREA(P)/AREA(N)))*(~~(0.053 - AREA(Q)/AREA(N)))*(~~(0.053 - AREA(M)/AREA(N)))]
}
 
125xmn_DN_6_M5M6M7 {
@ Mxy.D.6: It is not allowed to have local density of all three consecutive metal (Mxy, Mxy+1, Mxy+2) over any 30um*30um (stepping 30um/step_number), except NODMF su 0.4um region
@ The metal layers of Mxy+1 and Mxy+2 include Mxy, 1.25xMy, 1.25xMn, and relevant dummy metals <= 5.3%
@ 125xMy.DN.5: It is not allowed to have local density < 5.3% of all 3 consecutive metal layers over any 30um*30um window (stepping 30um/step_number), except (NODMF su 0.4um) region
@ The metal layers of Mxy+1 and Mxy+2 include Mxy, 1.25xMy, 1.25xMn, and relevant dummy metals
@ 125xMn.DN.6: It is not allowed to have local density < 5.3% of all 3 consecutive metal layers over any 30um*30um window (stepping 30um/step_number), except (NODMF) su 0.4um region
 check_region = ((DRC:1 NOT NODMF_SIZE_0.4) NOT LDNMK1) WITH WIDTH >= 15
 except_area = (NODMF_SIZE_0.4 OR LDNMK1) OR MARKS
 N = (check_region NOT MARKS) WITH WIDTH >= 15
 P = (M5_all NOT except_area) AND N
 Q = (M6_all NOT except_area) AND N
 M = (M7_all NOT except_area) AND N
 DENSITY P Q M N > 0 WINDOW 30 STEP 30/step_number BACKUP PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_125xmn_DN_6_M5M6M7.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_125xmn_DN_6_M5M6M7.rdb" [(~~(0.053 - AREA(P)/AREA(N)))*(~~(0.053 - AREA(Q)/AREA(N)))*(~~(0.053 - AREA(M)/AREA(N)))]
}

#ENDIF
#ENDIF


#IFDEF IP_LEVEL_DENSITY_CHECK YES
#IFDEF MINIMUM_DENSITY_CHECK YES


#ENDIF
#ENDIF


#IFDEF IP_LEVEL_DENSITY_CHECK YES
#IFDEF MINIMUM_DENSITY_CHECK YES


#ENDIF
#ENDIF


#IFDEF IP_LEVEL_DENSITY_CHECK NO
#IFDEF MINIMUM_DENSITY_CHECK YES


#ENDIF
#ENDIF


#IFDEF IP_LEVEL_DENSITY_CHECK NO
#IFDEF MINIMUM_DENSITY_CHECK YES


#ENDIF
#ENDIF


#IFDEF IP_LEVEL_DENSITY_CHECK NO
#IFDEF MINIMUM_DENSITY_CHECK YES

 
125xmn_DN_6_M2M3M4 {
@ Mxy.D.6: It is not allowed to have local density of all three consecutive metal (Mxy, Mxy+1, Mxy+2) over any 30um*30um (stepping 15um), except NODMF su 0.4um region
@ The metal layers of Mxy+1 and Mxy+2 include Mxy, 1.25xMy, 1.25xMn, and relevant dummy metals <= 5%
@ 125xMy.DN.5: It is not allowed to have local density < 5% of all 3 consecutive metal layers over any 30um*30um window (stepping 15um), except (NODMF su 0.4um) region
@ The metal layers of Mxy+1 and Mxy+2 include Mxy, 1.25xMy, 1.25xMn, and relevant dummy metals
@ 125xMn.DN.6: It is not allowed to have local density < 5% of all 3 consecutive metal layers over any 30um*30um window (stepping 15um), except (NODMF) su 0.4um region
 check_region = ((DRC:1 NOT NODMF_SIZE_0.4) NOT LDNMK1) WITH WIDTH >= 15
 except_area = (NODMF_SIZE_0.4 OR LDNMK1) OR MARKS
 N = (check_region NOT MARKS) WITH WIDTH >= 15
 P = (M2_all NOT except_area) AND N
 Q = (M3_all NOT except_area) AND N
 M = (M4_all NOT except_area) AND N
 DENSITY P Q M N > 0 WINDOW 30 STEP 15 BACKUP PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_125xmn_DN_6_M2M3M4.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_125xmn_DN_6_M2M3M4.rdb" [(~~(0.05 - AREA(P)/AREA(N)))*(~~(0.05 - AREA(Q)/AREA(N)))*(~~(0.05 - AREA(M)/AREA(N)))]
}
 
125xmn_DN_6_M3M4M5 {
@ Mxy.D.6: It is not allowed to have local density of all three consecutive metal (Mxy, Mxy+1, Mxy+2) over any 30um*30um (stepping 15um), except NODMF su 0.4um region
@ The metal layers of Mxy+1 and Mxy+2 include Mxy, 1.25xMy, 1.25xMn, and relevant dummy metals <= 5%
@ 125xMy.DN.5: It is not allowed to have local density < 5% of all 3 consecutive metal layers over any 30um*30um window (stepping 15um), except (NODMF su 0.4um) region
@ The metal layers of Mxy+1 and Mxy+2 include Mxy, 1.25xMy, 1.25xMn, and relevant dummy metals
@ 125xMn.DN.6: It is not allowed to have local density < 5% of all 3 consecutive metal layers over any 30um*30um window (stepping 15um), except (NODMF) su 0.4um region
 check_region = ((DRC:1 NOT NODMF_SIZE_0.4) NOT LDNMK1) WITH WIDTH >= 15
 except_area = (NODMF_SIZE_0.4 OR LDNMK1) OR MARKS
 N = (check_region NOT MARKS) WITH WIDTH >= 15
 P = (M3_all NOT except_area) AND N
 Q = (M4_all NOT except_area) AND N
 M = (M5_all NOT except_area) AND N
 DENSITY P Q M N > 0 WINDOW 30 STEP 15 BACKUP PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_125xmn_DN_6_M3M4M5.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_125xmn_DN_6_M3M4M5.rdb" [(~~(0.05 - AREA(P)/AREA(N)))*(~~(0.05 - AREA(Q)/AREA(N)))*(~~(0.05 - AREA(M)/AREA(N)))]
}
 
125xmn_DN_6_M4M5M6 {
@ Mxy.D.6: It is not allowed to have local density of all three consecutive metal (Mxy, Mxy+1, Mxy+2) over any 30um*30um (stepping 15um), except NODMF su 0.4um region
@ The metal layers of Mxy+1 and Mxy+2 include Mxy, 1.25xMy, 1.25xMn, and relevant dummy metals <= 5%
@ 125xMy.DN.5: It is not allowed to have local density < 5% of all 3 consecutive metal layers over any 30um*30um window (stepping 15um), except (NODMF su 0.4um) region
@ The metal layers of Mxy+1 and Mxy+2 include Mxy, 1.25xMy, 1.25xMn, and relevant dummy metals
@ 125xMn.DN.6: It is not allowed to have local density < 5% of all 3 consecutive metal layers over any 30um*30um window (stepping 15um), except (NODMF) su 0.4um region
 check_region = ((DRC:1 NOT NODMF_SIZE_0.4) NOT LDNMK1) WITH WIDTH >= 15
 except_area = (NODMF_SIZE_0.4 OR LDNMK1) OR MARKS
 N = (check_region NOT MARKS) WITH WIDTH >= 15
 P = (M4_all NOT except_area) AND N
 Q = (M5_all NOT except_area) AND N
 M = (M6_all NOT except_area) AND N
 DENSITY P Q M N > 0 WINDOW 30 STEP 15 BACKUP PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_125xmn_DN_6_M4M5M6.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_125xmn_DN_6_M4M5M6.rdb" [(~~(0.05 - AREA(P)/AREA(N)))*(~~(0.05 - AREA(Q)/AREA(N)))*(~~(0.05 - AREA(M)/AREA(N)))]
}
 
125xmn_DN_6_M5M6M7 {
@ Mxy.D.6: It is not allowed to have local density of all three consecutive metal (Mxy, Mxy+1, Mxy+2) over any 30um*30um (stepping 15um), except NODMF su 0.4um region
@ The metal layers of Mxy+1 and Mxy+2 include Mxy, 1.25xMy, 1.25xMn, and relevant dummy metals <= 5%
@ 125xMy.DN.5: It is not allowed to have local density < 5% of all 3 consecutive metal layers over any 30um*30um window (stepping 15um), except (NODMF su 0.4um) region
@ The metal layers of Mxy+1 and Mxy+2 include Mxy, 1.25xMy, 1.25xMn, and relevant dummy metals
@ 125xMn.DN.6: It is not allowed to have local density < 5% of all 3 consecutive metal layers over any 30um*30um window (stepping 15um), except (NODMF) su 0.4um region
 check_region = ((DRC:1 NOT NODMF_SIZE_0.4) NOT LDNMK1) WITH WIDTH >= 15
 except_area = (NODMF_SIZE_0.4 OR LDNMK1) OR MARKS
 N = (check_region NOT MARKS) WITH WIDTH >= 15
 P = (M5_all NOT except_area) AND N
 Q = (M6_all NOT except_area) AND N
 M = (M7_all NOT except_area) AND N
 DENSITY P Q M N > 0 WINDOW 30 STEP 15 BACKUP PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_125xmn_DN_6_M5M6M7.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_125xmn_DN_6_M5M6M7.rdb" [(~~(0.05 - AREA(P)/AREA(N)))*(~~(0.05 - AREA(Q)/AREA(N)))*(~~(0.05 - AREA(M)/AREA(N)))]
}

#ENDIF
#ENDIF


#IFDEF IP_LEVEL_DENSITY_CHECK NO
#IFDEF MINIMUM_DENSITY_CHECK YES


#ENDIF
#ENDIF


#IFDEF IP_LEVEL_DENSITY_CHECK NO
#IFDEF MINIMUM_DENSITY_CHECK YES


#ENDIF
#ENDIF

 

#IFDEF DFM_RULES_PRIORITY_1 YES

 
125XM_R_1_M1M2M3M4M5_DFM1 {
@ Maximum number of stacked metal layers (including M1) of high density area (density > 70% in window size 800um*800um, stepping size 100um) <= 4
@ For 1.25xMy.R.1.DFM, 1.25xMn.R.1.DFM
 X1 = M1_all NOT MARKS
 X2 = M2_all NOT MARKS
 X3 = M3_all NOT MARKS
 X4 = M4_all NOT MARKS
 X5 = M5_all NOT MARKS
 N = COPY CHIP_NOT_MARKS
 DENSITY X1 X2 X3 X4 X5 N > 0 WINDOW 800 STEP 100 BACKUP PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_125XM_R_1_M1M2M3M4M5_DFM1.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_125XM_R_1_M1M2M3M4M5_DFM1.rdb" [(~~(AREA(X1)/AREA(N) -0.7))*(~~(AREA(X2)/AREA(N) -0.7))*(~~(AREA(X3)/AREA(N) -0.7))*(~~(AREA(X4)/AREA(N) -0.7))*(~~(AREA(X5)/AREA(N) -0.7))]
}
 
125XM_R_1_M2M3M4M5M6_DFM1 {
@ Maximum number of stacked metal layers (including M1) of high density area (density > 70% in window size 800um*800um, stepping size 100um) <= 4
@ For 1.25xMy.R.1.DFM, 1.25xMn.R.1.DFM
 X1 = M2_all NOT MARKS
 X2 = M3_all NOT MARKS
 X3 = M4_all NOT MARKS
 X4 = M5_all NOT MARKS
 X5 = M6_all NOT MARKS
 N = COPY CHIP_NOT_MARKS
 DENSITY X1 X2 X3 X4 X5 N > 0 WINDOW 800 STEP 100 BACKUP PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_125XM_R_1_M2M3M4M5M6_DFM1.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_125XM_R_1_M2M3M4M5M6_DFM1.rdb" [(~~(AREA(X1)/AREA(N) -0.7))*(~~(AREA(X2)/AREA(N) -0.7))*(~~(AREA(X3)/AREA(N) -0.7))*(~~(AREA(X4)/AREA(N) -0.7))*(~~(AREA(X5)/AREA(N) -0.7))]
}
 
125XM_R_1_M3M4M5M6M7_DFM1 {
@ Maximum number of stacked metal layers (including M1) of high density area (density > 70% in window size 800um*800um, stepping size 100um) <= 4
@ For 1.25xMy.R.1.DFM, 1.25xMn.R.1.DFM
 X1 = M3_all NOT MARKS
 X2 = M4_all NOT MARKS
 X3 = M5_all NOT MARKS
 X4 = M6_all NOT MARKS
 X5 = M7_all NOT MARKS
 N = COPY CHIP_NOT_MARKS
 DENSITY X1 X2 X3 X4 X5 N > 0 WINDOW 800 STEP 100 BACKUP PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_125XM_R_1_M3M4M5M6M7_DFM1.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_125XM_R_1_M3M4M5M6M7_DFM1.rdb" [(~~(AREA(X1)/AREA(N) -0.7))*(~~(AREA(X2)/AREA(N) -0.7))*(~~(AREA(X3)/AREA(N) -0.7))*(~~(AREA(X4)/AREA(N) -0.7))*(~~(AREA(X5)/AREA(N) -0.7))]
}

#ENDIF


// =======================================================
// PA design rules
// =======================================================

GROUP GPA PA_?

//;below definition is based on ALPA.R.3
ALPA_PAD = ALPA WITH WIDTH >= 35
ALRDL = ALPA WITH WIDTH < 35

PA_in_ALRDL = (PA NOT INSIDE MD) NOT INSIDE ALPA_PAD
PA_in_ALRDL_PAD = (PA NOT OUTSIDE MD) NOT OUTSIDE ALPA_PAD

PA_in_ALRDL_18 = RECTANGLE PA_in_ALRDL == 1.8 BY == 1.8 ORTHOGONAL ONLY
PA_in_ALRDL_27 = RECTANGLE PA_in_ALRDL == 2.7 BY == 2.7 ORTHOGONAL ONLY

PA_in_ALRDL_indmy = PA_in_ALRDL NOT OUTSIDE INDMY
PA_in_ALRDL_indmy_skew_edge = ANGLE PA_in_ALRDL_indmy > 44 < 46

PA_in_ALRDL_PAD_indmy = PA_in_ALRDL_PAD NOT OUTSIDE INDMY
PA_in_ALRDL_PAD_indmy_skew_edge = ANGLE PA_in_ALRDL_PAD_indmy > 44 < 46

PA_h_edges = ANGLE PA == 0
PA_v_edges = ANGLE PA == 90
PA_s_edges = ANGLE PA > 44 < 46

PA_W_1 {
@ PA width and length if PA not overlap with MD, except MARKS and LOGO regions = 1.8, 2.7um
 err1 = PA_in_ALRDL NOT (OR PA_in_ALRDL_18 PA_in_ALRDL_27)
 err1 NOT INSIDE MARKS_LOGO

//; err2 = INT PA_in_ALRDL_indmy PA_in_ALRDL_indmy_skew_edge < 1.8-0.009 ABUT<86 OPPOSITE2 REGION
//; err3 = INT PA_in_ALRDL_indmy PA_in_ALRDL_indmy_skew_edge > 1.8+0.009 < 2.7-0.009 ABUT<86 OPPOSITE2 REGION
//; err4 = PA_in_ALRDL_indmy WITH EDGE (INT PA_in_ALRDL_indmy (PA_in_ALRDL_indmy_skew_edge) < 2.7+0.009 ABUT<86 OPPOSITE2)
//; err5 = (RECTANGLE PA_in_ALRDL_indmy ORTHOGONAL ONLY) NOT (OR PA_in_ALRDL_18 PA_in_ALRDL_27)

//; err2 NOT INSIDE MARKS_LOGO
//; err3 NOT INSIDE MARKS_LOGO
//; err4 NOT INSIDE MARKS_LOGO
//; err5 NOT INSIDE MARKS_LOGO
}

PA_W_2 {
@ PA width if PA overlap with MD, except MARKS and LOGO regions >= 30.6um
 err1 = INT PA_in_ALRDL_PAD < 30.6 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE MARKS_LOGO
}

PA_S_1 {
@ Space between two PA, except LOGO region >= 1.8um
 err1 = EXT PA < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE LOGO
}

PA_EN_1 {
@ PA fully enclosure by ALPA if PA not overlap with MD, except LOGO region >= 0.45um
@ It allows 0.009um DRC checking tolerance in INDMY region
 err1 = (ENC PA_in_ALRDL ALPA < 0.45 ABUT<90 SINGULAR REGION OUTSIDE ALSO) NOT INSIDE LOGO
 err2 = (ENC PA_in_ALRDL ALPA < 0.45 ABUT<90 SINGULAR REGION ANGLED==0 OUTSIDE ALSO) NOT INSIDE LOGO
 err3 = (ENC (PA_in_ALRDL COIN EDGE PA_s_edges) ALPA < 0.45-0.009 ABUT<90 OPPOSITE1 REGION OUTSIDE ALSO) NOT INSIDE LOGO
 err4 = (PA_in_ALRDL NOT ALPA) NOT INSIDE LOGO

 err1 NOT INSIDE INDMY
 err2 NOT OUTSIDE INDMY
 err3 NOT OUTSIDE INDMY
 err4 NOT INSIDE INDMY
}

PA_EN_1a {
@ PA fully enclosure by ALPA if PA overlap with MD, except LOGO region >= 0.9um
@ It allows 0.009um DRC checking tolerance in INDMY region
 err1 = (ENC PA_in_ALRDL_PAD ALPA < 0.90 ABUT<90 SINGULAR REGION OUTSIDE ALSO) NOT INSIDE LOGO
 err2 = (ENC PA_in_ALRDL_PAD ALPA < 0.90 ABUT<90 SINGULAR REGION ANGLED==0 OUTSIDE ALSO) NOT INSIDE LOGO
 err3 = (ENC (PA_in_ALRDL_PAD COIN EDGE PA_s_edges) ALPA < 0.90-0.009 ABUT<90 OPPOSITE1 REGION OUTSIDE ALSO) NOT INSIDE LOGO
 err4 = (PA_in_ALRDL_PAD NOT ALPA) NOT INSIDE LOGO

 err1 NOT INSIDE INDMY
 err2 NOT OUTSIDE INDMY
 err3 NOT OUTSIDE INDMY
 err4 NOT INSIDE INDMY
}

PA_EN_2 {
@ PA fully enclosure by UTM/14xTMn/10xTMn, except LOGO region >= 0.45um
@ It allows 0.009um DRC checking tolerance in INDMY region
 err1 = (ENC PA TM < 0.45 ABUT<90 SINGULAR REGION OUTSIDE ALSO) NOT INSIDE LOGO
 err2 = (ENC PA TM < 0.45 ABUT<90 SINGULAR REGION ANGLED==0 OUTSIDE ALSO) NOT INSIDE LOGO
 err3 = (ENC PA_s_edges TM < 0.45-0.009 ABUT<90 OPPOSITE1 REGION OUTSIDE ALSO) NOT INSIDE LOGO
 err4 = (PA NOT TM) NOT INSIDE LOGO

 err1 NOT INSIDE INDMY
 err2 NOT OUTSIDE INDMY
 err3 NOT OUTSIDE INDMY
 err4 NOT INSIDE INDMY
}

PA_R_1 {
@ 45-degree rotated PA is not allowed, except INDMY region
 err1 = (PA NOT WITH EDGE PA_h_edges) NOT WITH EDGE PA_v_edges
 err1 NOT INSIDE INDMY
}

// =======================================================
// ALPA design rules
// =======================================================

GROUP GALPA ALPA_?

ALPA_with_dummy = ALPA OR ALDUM

ALPA_in_INDMY = ALPA NOT OUTSIDE INDMY
ALPA_in_INDMY_skew_edge = ANGLE ALPA_in_INDMY > 44 < 46
ALPA_in_INDMY_orth_edge = ALPA_in_INDMY NOT COIN EDGE ALPA_in_INDMY_skew_edge

ALPA_W_1 {
@ ALPA width, except LOGO region >= 1.8um
@ It allows 0.009um DRC checking tolerance in INDMY region
 err1 = (INT ALPA < 1.8 ABUT<90 SINGULAR REGION) NOT INSIDE LOGO
 err2 = (INT ALPA ALPA_in_INDMY_skew_edge < 1.8-0.009 ABUT<90 OPPOSITE2 REGION) NOT INSIDE LOGO
 err3 = (INT ALPA_in_INDMY_orth_edge < 1.8 ABUT<90 OPPOSITE REGION) NOT INSIDE LOGO
 err4 = (INT ALPA < 0.001 ABUT<90 SINGULAR REGION) NOT INSIDE LOGO

 err1 NOT INSIDE INDMY
 err2 NOT OUTSIDE INDMY
 err3 NOT OUTSIDE INDMY
 err4 NOT OUTSIDE INDMY
}

ALPA_S_1 {
@ ALPA space, except LOGO region >= 1.8um
@ DRC waive space in same polygon
@ It allows 0.009um DRC checking tolerance in INDMY region
 err1 = (EXT ALPA < 1.8 ABUT<90 SINGULAR REGION SPACE) NOT INSIDE LOGO
 err2 = (EXT ALPA ALPA_in_INDMY_skew_edge < 1.8-0.009 ABUT<90 OPPOSITE2 REGION SPACE) NOT INSIDE LOGO
 err3 = (EXT ALPA_in_INDMY_orth_edge < 1.8 ABUT<90 REGION SPACE) NOT INSIDE LOGO

 err1 NOT INSIDE INDMY
 err2 NOT OUTSIDE INDMY
 err3 NOT OUTSIDE INDMY
}

ALPA_W_gt_10 = WITH WIDTH ALPA > 10
ALRDL_W_gt_10 = WITH WIDTH ALRDL > 10
ALRDL_W_lt_10 = WITH WIDTH ALRDL <= 10

ALPA_S_1a {
@ Space between ALPA when one or both ALPA width larger than 10um, except ALPA.S.2. >= 2.69um
//;RDL(10~35um) to RDL (10~35um) space, RDL (10~35um) to RDL (<=10um) space
 err1 = EXT (ALPA COIN EDGE ALRDL_W_gt_10) < 2.69 ABUT<90 REGION
 err2 = EXT (ALPA COIN EDGE ALRDL_W_gt_10) (ALPA COIN EDGE ALRDL_W_lt_10) < 2.69 ABUT<90 REGION
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

ALPA_in_MD_ov_3 = ALPA AND (SIZE MD BY 3)

ALPA_S_2 {
@ Space between (ALPA AND (MD sizing up 3um)) and (ALPA AND (MD sizing up 3um)) or ALRDL >= 2.25um
@ DRC waive space in same polygon
@ It allows 0.009um DRC checking tolerance in INDMY region
 err1 = EXT ALPA_in_MD_ov_3 < 2.25 ABUT<90 SINGULAR REGION SPACE
 err2 = EXT ALPA_in_MD_ov_3 ALRDL < 2.25 ABUT<90 SINGULAR REGION MEASURE ALL
 err3 = EXT ALPA_in_MD_ov_3 < 2.25 ABUT<90 SINGULAR REGION ANGLED==0 SPACE
 err4 = EXT ALPA_in_MD_ov_3 ALRDL < 2.25 ABUT<90 SINGULAR REGION MEASURE ALL ANGLED==0
 err5 = EXT ALPA_in_MD_ov_3 (ANGLE ALPA_in_MD_ov_3 > 44 < 46) < 2.25-0.009 ABUT<90 OPPOSITE2 REGION SPACE
 err6 = EXT ALPA_in_MD_ov_3 (ANGLE ALRDL > 44 < 46) < 2.25-0.009 ABUT<90 OPPOSITE2 REGION MEASURE ALL
 err7 = EXT (ANGLE ALPA_in_MD_ov_3 > 44 < 46) ALRDL < 2.25-0.009 ABUT<90 OPPOSITE1 REGION MEASURE ALL

 err1 NOT INSIDE INDMY
 err2 NOT INSIDE INDMY
 err3 NOT OUTSIDE INDMY
 err4 NOT OUTSIDE INDMY
 err5 NOT OUTSIDE INDMY
 err6 NOT OUTSIDE INDMY
 err7 NOT OUTSIDE INDMY
}

//;ALPA_S_2a {
//;@ Space between ALPA and ALRDL with one or both width larger than 10um. >= 2.7um
//; err1 = EXT (ALPA COIN EDGE ALPA_W_gt_10) (ALPA COIN EDGE ALRDL) < 2.7 ABUT>0<90 REGION
//; err2 = EXT (ALPA COIN EDGE ALRDL_W_gt_10) ALPA < 2.7 ABUT>0<90 REGION
//; err1 NOT INSIDE SealR_NOT_BULK
//; err2 NOT INSIDE SealR_NOT_BULK
//;}

ALPA_S_3 {
@ Space between ALPA pad and Fuse window edge >= 44.5um
 err1 = EXT ALPA_PAD FUSE < 44.5 ABUT<90 SINGULAR REGION MEASURE ALL
 err1 NOT INSIDE SealR_NOT_BULK
}

ALPA_ALRDL_ALL_not_MARKS = (ALPA_with_dummy OR ALRDL) NOT MARKS
ALPA_not_MARKS = ALPA_with_dummy NOT MARKS

#IFDEF MINIMUM_DENSITY_CHECK YES
ALPA_DN_1 {
@ ALPA.DN.1: ALPA full chip density >= 10%
@ ALPA.R.2: ALPA is must drawn layer
 DENSITY ALPA_not_MARKS CHIP_NOT_MARKS [AREA(ALPA_not_MARKS)/AREA(CHIP_NOT_MARKS)] < 0.1 PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_ALPA_DN_1.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_ALPA_DN_1.rdb"
}
#ENDIF

ALPA_DN_2 {
@ ALPA full chip density <= 70%
 DENSITY ALPA_not_MARKS CHIP_NOT_MARKS [AREA(ALPA_not_MARKS)/AREA(CHIP_NOT_MARKS)] > 0.7 PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_ALPA_DN_2.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_ALPA_DN_2.rdb"
}

//;ALPA.R.1[NC]	ALPA includes ALPA Pad and ALRDL
//;ALRDL is defined as ALPA layer width equal or smaller than 35um
//;ALPA pad is defined as ALPA layer width larger than 35um

#IFDEF DFM_RULES_PRIORITY_1 YES
ALPA_W_2_DFM1 {
@ Recommended ALRDL width connected with AL bump pad >= 18um
 err1 = INT (ALRDL INTERACT ALPA_PAD) < 18 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
#ENDIF

 

#IFDEF Delta_Voltage_Rules_Check YES


#ENDIF

 

#IFDEF Delta_Voltage_Rules_Check YES


#ENDIF


// =======================================================
// MD (Passivation 2) design rules
// =======================================================

GROUP GMD MD_?

MD_notch_space = (EXT MD < 4.5 ABUT<90 SINGULAR REGION NOTCH) WITH EDGE (CONVEX EDGE MD == 0)

MD_W_1 {
@ MD width, except LOGO region >= 12.5um
 err1 = INT MD < 12.5 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE LOGO
}

MD_S_1 {
@ MD space, except LOGO region >= 4.49um
 err1 = (EXT MD < 4.49 ABUT<90 SINGULAR REGION) NOT MD_notch_space
 err1 NOT INSIDE LOGO
}

MD_S_2 {
@ Space between MD and PA (space = 0 is allowed), except LOGO region >= 1.52um
 err1 = EXT MD PA < 1.52 ABUT>0<90 SINGULAR REGION MEASURE ALL
 err1 NOT INSIDE LOGO
}

MD_EN_1 {
@ MD fully enclosure by ALPA, except LOGO region >= 0.9um
 err1 = ENC MD ALPA < 0.9 ABUT<90 SINGULAR REGION OUTSIDE ALSO
 err1 NOT INSIDE LOGO

 err2 = MD NOT ALPA
 err2 NOT INSIDE LOGO
}

MD_R_1 {
@ MD must be a drawn layer
 err1 = DRC:1 NOT INTERACT MD
 err1 NOT INSIDE SealR_NOT_BULK
}

MD_R_2 {
@ MD interact PA (PA size <= 2.7um) is not allowed, except LOGO region
 err1 = MD INTERACT (PA WITH WIDTH <= 2.7)
 err1 NOT INSIDE LOGO
}

MD_R_3 {
@ Inductor under MD wire-bond pad opening is not allowed
 err1 = INDMY AND DUP_area
 err1 NOT INSIDE SealR_NOT_BULK
}

// =======================================================
// DUP (Device Under Pad) design rules
// DUPMK1 (89,156) is the marking layer for DUP pad
// =======================================================

GROUP GWBPAD WBPAD_?

DUP_area = (DUPMK1 AND MD) OR (SIZE (MD NOT INTERACT DUPMK1) BY 17.2 UNDEROVER)

//;WBPAD_1: can't be coded rule DUPMK1 is must for wire bond pad region

WBPAD_2 {
@ DUPMK1 width
@ DRC waive the 3um jog violation for each side >= 35um
 chk_dup = DUPMK1 NOT COIN EDGE (CONVEX EDGE DUPMK1 == 1 WITH LENGTH <= 3)
 err1 = INT chk_dup < 35 ABUT<90 REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

WBPAD_3 {
@ MD must be fully enclosed by DUPMK1 >= 0um
 err1 = (MD INTERACT DUPMK1) NOT DUPMK1
 err1 NOT INSIDE SealR_NOT_BULK
}

WBPAD_4 {
@ In wire bond pad area, MD must interact with PA. (MD AND PA) width
@ DRC waive the 3um jog violation for each side >= 35um
 chk_mn = (MD INTERACT DUP_area) AND PA
 chk_waive = CONVEX EDGE chk_mn == 1 WITH LENGTH <= 3
 chk_md = chk_mn NOT COIN EDGE chk_waive
 err1 = (INT [chk_md] < 35 ABUT<90) NOT COIN EDGE chk_waive
 err2 = (MD INTERACT DUP_area) NOT INTERACT PA

 err1 NOT INSIDE EDGE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

WBPAD_5 {
@ Wire bond pad design should include one layer of solid ALPA and two layers of solid Cu metal (TM and TM-1). It is not allowed to draw metal slot for ALPA, TM and TM-1 in wire bond pad area
@ For example:
@ For two thick top metal case: TM2 and TM1 should be solid
@ For one thick top metal case: TM2 and M7 should be solid
 err1 = DUP_area ENCLOSE (DUP_area NOT TM_1)  //;enclose by ALPA will be gated by ALPA/WBPAD_8
 err2 = DUP_area ENCLOSE (DUP_area NOT TM)
 err1 NOT INSIDE EDGE SealR_NOT_BULK
 err2 NOT INSIDE EDGE SealR_NOT_BULK
}

#IFDEF IP_LEVEL_DENSITY_CHECK YES
WBPAD_6 {
@ Wire bond pad design must have dense TV between TM and TM-1 >= 10.5%
@ The TV density under wire bond pad
@ DRC check the (wire bond pad sd 1um) area where density ratio = (TV area)/(wire bond pad area), with window size 10umx10um, step 10um/step_number
 check_region = SIZE DUP_area BY -1
 check_pattern = TV AND check_region

 check_window1 = check_region WITH WIDTH >= 10/4
 err1_TMP1 = DENSITY check_pattern check_window1 check_region [!AREA(check_window1) + !!AREA(check_window1)*AREA(check_pattern)/AREA(check_region)] < 0.105 WINDOW 10 STEP 10/step_number BACKUP INSIDE OF LAYER DRC:1 BY POLYGON

 check_window2 = WITH WIDTH (check_region AND err1_TMP1) >= 10/4
 err1_TMP2 = DENSITY check_pattern check_window2 check_region [!AREA(check_window2) + !!AREA(check_window2)*AREA(check_pattern)/AREA(check_region)] < 0.105 WINDOW 10 STEP 10/step_number BACKUP INSIDE OF LAYER err1_TMP1 BY POLYGON

 check_window3 = WITH WIDTH (check_region AND err1_TMP2) >= 10/4
 DENSITY check_pattern check_window3 check_region [!AREA(check_window3) + !!AREA(check_window3)*AREA(check_pattern)/AREA(check_region)] < 0.105 WINDOW 10 STEP 10/step_number BACKUP INSIDE OF LAYER err1_TMP2 BY POLYGON PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_WBPAD_6.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_WBPAD_6.rdb"
}
#ENDIF

#IFDEF IP_LEVEL_DENSITY_CHECK NO
WBPAD_6 {
@ Wire bond pad design must have dense TV between TM and TM-1 >= 10%
@ The TV density under wire bond pad
@ DRC check the (wire bond pad sd 1um) area where density ratio = (TV area)/(wire bond pad area), with window size 10umx10um, step 5um
 check_region = SIZE DUP_area BY -1
 check_pattern = TV AND check_region

 check_window1 = check_region WITH WIDTH >= 10/4
 err1_TMP1 = DENSITY check_pattern check_window1 check_region [!AREA(check_window1) + !!AREA(check_window1)*AREA(check_pattern)/AREA(check_region)] < 0.10 WINDOW 10 STEP 5 BACKUP INSIDE OF LAYER DRC:1 BY POLYGON

 check_window2 = WITH WIDTH (check_region AND err1_TMP1) >= 10/4
 err1_TMP2 = DENSITY check_pattern check_window2 check_region [!AREA(check_window2) + !!AREA(check_window2)*AREA(check_pattern)/AREA(check_region)] < 0.10 WINDOW 10 STEP 5 BACKUP INSIDE OF LAYER err1_TMP1 BY POLYGON

 check_window3 = WITH WIDTH (check_region AND err1_TMP2) >= 10/4
 DENSITY check_pattern check_window3 check_region [!AREA(check_window3) + !!AREA(check_window3)*AREA(check_pattern)/AREA(check_region)] < 0.10 WINDOW 10 STEP 5 BACKUP INSIDE OF LAYER err1_TMP2 BY POLYGON PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_WBPAD_6.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_WBPAD_6.rdb"
}
#ENDIF

WBPAD_7 {
@ TV-1 pattern must be outside of wire bond pad area
@ For example:
@ For two thick top metal case: TV1 must outside of wire bond pad area
@ For one thick top metal case: V6 must outside of wire bond pad area
 err1 = DUP_area AND TV_1
 err1 NOT INSIDE SealR_NOT_BULK
}

WBPAD_8 {
@ ALPA, TM, TM-1 should fully enclose wire bond pad area >= 1um
 err1 = ENC (MD AND DUP_area) ALPA < 1 ABUT<90 SINGULAR REGION OUTSIDE ALSO
 err2 = ENC (MD AND DUP_area) TM_1 < 1 ABUT<90 SINGULAR REGION OUTSIDE ALSO
 err3 = ENC (MD AND DUP_area) TM < 1 ABUT<90 SINGULAR REGION OUTSIDE ALSO

 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
}

#IFDEF RECOMMENDED_CHECK YES
WBPAD_9_R {
@ MD/ALPA/PA/TM/TM-1 patterns in wire bond pad area should have 4 corners with 45° cut for corner stress relief. The length of corner cut >= 2um <= 5um
 md_WAIVE_2_convex = CONVEX EDGE MD ANGLE1==270 ANGLE2==270
 md_WAIVE_1_convex = LENGTH (CONVEX EDGE MD ANGLE1==270 ANGLE2==90) < 3
 md_WAIVE_2_convex_EXP = (EXPAND EDGE md_WAIVE_2_convex OUTSIDE BY 0.001) WITH EDGE md_WAIVE_1_convex == 2
 md_WAIVE_1_convex_EXP = ((EXPAND EDGE md_WAIVE_1_convex OUTSIDE BY 0.001) WITH EDGE md_WAIVE_2_convex == 1) INTERACT md_WAIVE_2_convex_EXP
 md_WAIVE_ALL = EXTENTS (OR md_WAIVE_1_convex_EXP md_WAIVE_2_convex_EXP)

 md_IN_pad = (MD OR md_WAIVE_ALL) NOT OUTSIDE DUP_area
 md_IN_pad_SKEW = ANGLE md_IN_pad > 44 < 46
 md_IN_pad_ORTV = ANGLE (CONVEX EDGE md_IN_pad == 2) == 90
 md_IN_pad_ORTH = ANGLE (CONVEX EDGE md_IN_pad == 2) == 0
 md_IN_pad_GOOD = ((md_IN_pad WITH EDGE md_IN_pad_ORTV == 2) WITH EDGE md_IN_pad_ORTH == 2) WITH EDGE md_IN_pad_SKEW == 4
 md_IN_pad_EXTENT = EXTENTS md_IN_pad_GOOD
 md_IN_pad_CORNER_less = INT md_IN_pad_EXTENT < 1.414-GLOBAL_TOLERANCE ABUT==90 INTERSECTING ONLY REGION
 md_IN_pad_CORNER_more = INT md_IN_pad_EXTENT < 3.536+GLOBAL_TOLERANCE ABUT==90 INTERSECTING ONLY REGION

 err1 = (md_IN_pad NOT md_IN_pad_GOOD) OR (INT MD < 0.1 ABUT<90 INTERSECTING ONLY REGION)
 err2 = EXPAND EDGE (md_IN_pad_SKEW INSIDE EDGE md_IN_pad_CORNER_less) OUTSIDE BY 0.001
 err3 = EXPAND EDGE (md_IN_pad_SKEW OUTSIDE EDGE md_IN_pad_CORNER_more) OUTSIDE BY 0.001
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
}

WBPAD_9_R_ALPA {
@ MD/ALPA/PA/TM/TM-1 patterns in wire bond pad area should have 4 corners with 45° cut for corner stress relief. The length of corner cut >= 2um <= 5um
 md_CHECK = ALPA_PAD ENCLOSE DUP_area
 md_WAIVE_2_convex = CONVEX EDGE md_CHECK ANGLE1==270 ANGLE2==270
 md_WAIVE_1_convex = LENGTH (CONVEX EDGE md_CHECK ANGLE1==270 ANGLE2==90) < 3
 md_WAIVE_2_convex_EXP = (EXPAND EDGE md_WAIVE_2_convex OUTSIDE BY 0.001) WITH EDGE md_WAIVE_1_convex == 2
 md_WAIVE_1_convex_EXP = ((EXPAND EDGE md_WAIVE_1_convex OUTSIDE BY 0.001) WITH EDGE md_WAIVE_2_convex == 1) INTERACT md_WAIVE_2_convex_EXP
 md_WAIVE_ALL = EXTENTS (OR md_WAIVE_1_convex_EXP md_WAIVE_2_convex_EXP)

 md_IN_pad = (md_CHECK OR md_WAIVE_ALL) NOT OUTSIDE DUP_area
 md_IN_pad_SKEW = ANGLE md_IN_pad > 44 < 46
 md_IN_pad_ORTV = ANGLE (CONVEX EDGE md_IN_pad == 2) == 90
 md_IN_pad_ORTH = ANGLE (CONVEX EDGE md_IN_pad == 2) == 0
 md_IN_pad_GOOD = ((md_IN_pad WITH EDGE md_IN_pad_ORTV == 2) WITH EDGE md_IN_pad_ORTH == 2) WITH EDGE md_IN_pad_SKEW == 4
 md_IN_pad_EXTENT = EXTENTS md_IN_pad_GOOD
 md_IN_pad_CORNER_less = INT md_IN_pad_EXTENT < 1.414-GLOBAL_TOLERANCE ABUT==90 INTERSECTING ONLY REGION
 md_IN_pad_CORNER_more = INT md_IN_pad_EXTENT < 3.536+GLOBAL_TOLERANCE ABUT==90 INTERSECTING ONLY REGION

 err1 = (md_IN_pad NOT md_IN_pad_GOOD) OR (INT md_CHECK < 0.1 ABUT<90 INTERSECTING ONLY REGION)
 err2 = EXPAND EDGE (md_IN_pad_SKEW INSIDE EDGE md_IN_pad_CORNER_less) OUTSIDE BY 0.001
 err3 = EXPAND EDGE (md_IN_pad_SKEW OUTSIDE EDGE md_IN_pad_CORNER_more) OUTSIDE BY 0.001
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
}

WBPAD_9_R_PA {
@ MD/ALPA/PA/TM/TM-1 patterns in wire bond pad area should have 4 corners with 45° cut for corner stress relief. The length of corner cut >= 2um <= 5um
 md_CHECK = ((PA INTERACT DUP_area) WITH WIDTH > 20) INTERACT DUP_area
 md_WAIVE_2_convex = CONVEX EDGE md_CHECK ANGLE1==270 ANGLE2==270
 md_WAIVE_1_convex = LENGTH (CONVEX EDGE md_CHECK ANGLE1==270 ANGLE2==90) < 3
 md_WAIVE_2_convex_EXP = (EXPAND EDGE md_WAIVE_2_convex OUTSIDE BY 0.001) WITH EDGE md_WAIVE_1_convex == 2
 md_WAIVE_1_convex_EXP = ((EXPAND EDGE md_WAIVE_1_convex OUTSIDE BY 0.001) WITH EDGE md_WAIVE_2_convex == 1) INTERACT md_WAIVE_2_convex_EXP
 md_WAIVE_ALL = EXTENTS (OR md_WAIVE_1_convex_EXP md_WAIVE_2_convex_EXP)

 md_IN_pad = (md_CHECK OR md_WAIVE_ALL) NOT OUTSIDE DUP_area
 md_IN_pad_SKEW = ANGLE md_IN_pad > 44 < 46
 md_IN_pad_ORTV = ANGLE (CONVEX EDGE md_IN_pad == 2) == 90
 md_IN_pad_ORTH = ANGLE (CONVEX EDGE md_IN_pad == 2) == 0
 md_IN_pad_GOOD = ((md_IN_pad WITH EDGE md_IN_pad_ORTV == 2) WITH EDGE md_IN_pad_ORTH == 2) WITH EDGE md_IN_pad_SKEW == 4
 md_IN_pad_EXTENT = EXTENTS md_IN_pad_GOOD
 md_IN_pad_CORNER_less = INT md_IN_pad_EXTENT < 1.414-GLOBAL_TOLERANCE ABUT==90 INTERSECTING ONLY REGION
 md_IN_pad_CORNER_more = INT md_IN_pad_EXTENT < 3.536+GLOBAL_TOLERANCE ABUT==90 INTERSECTING ONLY REGION

 err1 = (md_IN_pad NOT md_IN_pad_GOOD) OR (INT md_CHECK < 0.1 ABUT<90 INTERSECTING ONLY REGION)
 err2 = EXPAND EDGE (md_IN_pad_SKEW INSIDE EDGE md_IN_pad_CORNER_less) OUTSIDE BY 0.001
 err3 = EXPAND EDGE (md_IN_pad_SKEW OUTSIDE EDGE md_IN_pad_CORNER_more) OUTSIDE BY 0.001
 err4 = OR ((PA INTERACT DUP_area) VERTEX != 8) (EXT (PA INTERACT DUP_area) < 0.005 ABUT INTERSECTING REGION)
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
 err4 NOT INSIDE SealR_NOT_BULK
}

WBPAD_9_R_TM {
@ MD/ALPA/PA/TM/TM-1 patterns in wire bond pad area should have 4 corners with 45° cut for corner stress relief. The length of corner cut >= 2um <= 5um
 md_CHECK = ((TM INTERACT DUP_area) WITH WIDTH > 20) INTERACT DUP_area
 md_WAIVE_2_convex = CONVEX EDGE md_CHECK ANGLE1==270 ANGLE2==270
 md_WAIVE_1_convex = LENGTH (CONVEX EDGE md_CHECK ANGLE1==270 ANGLE2==90) < 3
 md_WAIVE_2_convex_EXP = (EXPAND EDGE md_WAIVE_2_convex OUTSIDE BY 0.001) WITH EDGE md_WAIVE_1_convex == 2
 md_WAIVE_1_convex_EXP = ((EXPAND EDGE md_WAIVE_1_convex OUTSIDE BY 0.001) WITH EDGE md_WAIVE_2_convex == 1) INTERACT md_WAIVE_2_convex_EXP
 md_WAIVE_ALL = EXTENTS (OR md_WAIVE_1_convex_EXP md_WAIVE_2_convex_EXP)

 md_IN_pad = (md_CHECK OR md_WAIVE_ALL) NOT OUTSIDE DUP_area
 md_IN_pad_SKEW = ANGLE md_IN_pad > 44 < 46
 md_IN_pad_ORTV = ANGLE (CONVEX EDGE md_IN_pad == 2) == 90
 md_IN_pad_ORTH = ANGLE (CONVEX EDGE md_IN_pad == 2) == 0
 md_IN_pad_GOOD = ((md_IN_pad WITH EDGE md_IN_pad_ORTV == 2) WITH EDGE md_IN_pad_ORTH == 2) WITH EDGE md_IN_pad_SKEW == 4
 md_IN_pad_EXTENT = EXTENTS md_IN_pad_GOOD
 md_IN_pad_CORNER_less = INT md_IN_pad_EXTENT < 1.414-GLOBAL_TOLERANCE ABUT==90 INTERSECTING ONLY REGION
 md_IN_pad_CORNER_more = INT md_IN_pad_EXTENT < 3.536+GLOBAL_TOLERANCE ABUT==90 INTERSECTING ONLY REGION

 err1 = (md_IN_pad NOT md_IN_pad_GOOD) OR (INT md_CHECK < 0.1 ABUT<90 INTERSECTING ONLY REGION)
 err2 = EXPAND EDGE (md_IN_pad_SKEW INSIDE EDGE md_IN_pad_CORNER_less) OUTSIDE BY 0.001
 err3 = EXPAND EDGE (md_IN_pad_SKEW OUTSIDE EDGE md_IN_pad_CORNER_more) OUTSIDE BY 0.001
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
}

WBPAD_9_R_TM_1 {
@ MD/ALPA/PA/TM/TM-1 patterns in wire bond pad area should have 4 corners with 45° cut for corner stress relief. The length of corner cut >= 2um <= 5um
 md_CHECK = ((TM_1 INTERACT DUP_area) WITH WIDTH > 20) INTERACT DUP_area
 md_WAIVE_2_convex = CONVEX EDGE md_CHECK ANGLE1==270 ANGLE2==270
 md_WAIVE_1_convex = LENGTH (CONVEX EDGE md_CHECK ANGLE1==270 ANGLE2==90) < 3
 md_WAIVE_2_convex_EXP = (EXPAND EDGE md_WAIVE_2_convex OUTSIDE BY 0.001) WITH EDGE md_WAIVE_1_convex == 2
 md_WAIVE_1_convex_EXP = ((EXPAND EDGE md_WAIVE_1_convex OUTSIDE BY 0.001) WITH EDGE md_WAIVE_2_convex == 1) INTERACT md_WAIVE_2_convex_EXP
 md_WAIVE_ALL = EXTENTS (OR md_WAIVE_1_convex_EXP md_WAIVE_2_convex_EXP)

 md_IN_pad = (md_CHECK OR md_WAIVE_ALL) NOT OUTSIDE DUP_area
 md_IN_pad_SKEW = ANGLE md_IN_pad > 44 < 46
 md_IN_pad_ORTV = ANGLE (CONVEX EDGE md_IN_pad == 2) == 90
 md_IN_pad_ORTH = ANGLE (CONVEX EDGE md_IN_pad == 2) == 0
 md_IN_pad_GOOD = ((md_IN_pad WITH EDGE md_IN_pad_ORTV == 2) WITH EDGE md_IN_pad_ORTH == 2) WITH EDGE md_IN_pad_SKEW == 4
 md_IN_pad_EXTENT = EXTENTS md_IN_pad_GOOD
 md_IN_pad_CORNER_less = INT md_IN_pad_EXTENT < 1.414-GLOBAL_TOLERANCE ABUT==90 INTERSECTING ONLY REGION
 md_IN_pad_CORNER_more = INT md_IN_pad_EXTENT < 3.536+GLOBAL_TOLERANCE ABUT==90 INTERSECTING ONLY REGION

 err1 = (md_IN_pad NOT md_IN_pad_GOOD) OR (INT md_CHECK < 0.1 ABUT<90 INTERSECTING ONLY REGION)
 err2 = EXPAND EDGE (md_IN_pad_SKEW INSIDE EDGE md_IN_pad_CORNER_less) OUTSIDE BY 0.001
 err3 = EXPAND EDGE (md_IN_pad_SKEW OUTSIDE EDGE md_IN_pad_CORNER_more) OUTSIDE BY 0.001
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
}
#ENDIF


CHIPB_convex_eq_two_v_edges = ANGLE (CONVEX EDGE CHIPB == 2) == 90
OCCD_OCOVL_h_edges = ANGLE (OR OCCD OCOVL) == 0

// =======================================================
// CHIPB: Chip boundary design rules
// CHIPB is used to define chip edge, n>=0 and n is integer
// =======================================================

#IFDEF CHIPB_RULES_CHECK YES
GROUP GCHIPB CHIPB_?

CHIPB_W_1 {
@ CHIPB width in GATE poly direction = 1.056+0.096*num
 err1 = INT CHIPB_h_edges < 1.056 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK

 err2 = DFM PROPERTY CHIPB_convex_eq_two_v_edges CHIPB OVERLAP ABUT ALSO MULTI [-= ABS(REMAINDER((LENGTH(CHIPB_convex_eq_two_v_edges) - 1.056),0.096))] > 0
 err2 NOT INSIDE EDGE SealR_NOT_BULK
}

CHIPB_EN_1 {
@ CHIPB enclosure of (CELLB OR DMCB1) in GATE poly direction (Cut is not allowed) = 0.384+0.048*num
@ DRC tips:: Please check the distance between the CELLB horizontal edge and the CHIPB bottom side
 err1 = ENC CELLB_ALL CHIPB_h_edges < 0.384 ABUT<90 OPPOSITE REGION
 err2 = CHIPB INSIDE EDGE CELLB_ALL
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE EDGE SealR_NOT_BULK

 err3 = DFM COPY (OFFGRID CELLB_ALL_h_edges 1 480 INSIDE OF LAYER CHIPB ABSOLUTE) REGION
 err3 NOT INSIDE SealR_NOT_BULK
}

CHIPB_EN_2 {
@ CHIPB enclosure of OCCDFH in GATE poly direction = 0.048*num
@ DRC tips:: Please check the distance between the OCCDFH horizontal edge and the CHIPB bottom side
 err1 = CHIPB_h_edges NOT OUTSIDE EDGE OCCDFH
 err1 NOT INSIDE EDGE SealR_NOT_BULK

 err2 = DFM COPY (OFFGRID OCCDFH_h_edges 1 480 INSIDE OF LAYER CHIPB ABSOLUTE) REGION
 err2 NOT INSIDE SealR_NOT_BULK
}

CHIPB_EN_3_AA {
@ CHIPB must enclose all chip layout patterns (all chip design, excluding MARKS, NODMF marking layer) if seal ring is inserted by SMIC. DRC waive if the chip has been added seal ring by designer >= 0.45um
@ DRC check layers: AA, AADMP, AR, NW, PSUB, SVT_N, SVT_P, LVT_N, LVT_P, HVT_N, HVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, DG, GT, GTDMP, P2, P2DMP, SN, SP, M0, M0DMP, M0G, M0GDMP, M0C, M0CDMP, DIR, DIRDMP, V0, M1, Vy, Mxy, 1.25xMy, 1.25xVn, 1.25xMn, 2xVn, 2xMn, 10xTVn, 10xTMn, 14xTVn, 14xTMn, UTV, UTM, PA, ALPA, MD, MIM, CTOP
@ DRC only check AA and AADMP enclosure in S/D direction
 err1 = ENC AA_v_edges CHIPB < 0.45 ABUT<90 OPPOSITE REGION
 err2 = ENC AA CHIPB < 0.001 ABUT<90 SINGULAR REGION OUTSIDE ALSO

 err1 NOT INSIDE (OR MARKS NODMF)
 err2 NOT INSIDE (OR MARKS NODMF)
}

CHIPB_EN_3_AADMP {
@ CHIPB must enclose all chip layout patterns (all chip design, excluding MARKS, NODMF marking layer) if seal ring is inserted by SMIC. DRC waive if the chip has been added seal ring by designer >= 0.45um
@ DRC check layers: AA, AADMP, AR, NW, PSUB, SVT_N, SVT_P, LVT_N, LVT_P, HVT_N, HVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, DG, GT, GTDMP, P2, P2DMP, SN, SP, M0, M0DMP, M0G, M0GDMP, M0C, M0CDMP, DIR, DIRDMP, V0, M1, Vy, Mxy, 1.25xMy, 1.25xVn, 1.25xMn, 2xVn, 2xMn, 10xTVn, 10xTMn, 14xTVn, 14xTMn, UTV, UTM, PA, ALPA, MD, MIM, CTOP
@ DRC only check AA and AADMP enclosure in S/D direction
 err1 = ENC (ANGLE AADMP == 90) CHIPB < 0.45 ABUT<90 OPPOSITE REGION
 err2 = ENC AADMP CHIPB < 0.001 ABUT<90 SINGULAR REGION OUTSIDE ALSO

 err1 NOT INSIDE (OR MARKS NODMF)
 err2 NOT INSIDE (OR MARKS NODMF)
}
 
CHIPB_EN_3_AR {
@ CHIPB must enclose all chip layout patterns (all chip design, excluding MARKS, NODMF marking layer) if seal ring is inserted by SMIC. DRC waive if the chip has been added seal ring by designer >= 0.45um
@ DRC check layers: AA, AADMP, AR, NW, PSUB, SVT_N, SVT_P, LVT_N, LVT_P, HVT_N, HVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, DG, GT, GTDMP, P2, P2DMP, SN, SP, M0, M0DMP, M0G, M0GDMP, M0C, M0CDMP, DIR, DIRDMP, V0, M1, Vy, Mxy, 1.25xMy, 1.25xVn, 1.25xMn, 2xVn, 2xMn, 10xTVn, 10xTMn, 14xTVn, 14xTMn, UTV, UTM, PA, ALPA, MD, MIM, CTOP
@ DRC only check AA and AADMP enclosure in S/D direction
 err1 = ENC AR CHIPB < 0.45 ABUT<90 SINGULAR REGION OUTSIDE ALSO
 err1 NOT INSIDE (OR MARKS NODMF)
}
 
CHIPB_EN_3_NW {
@ CHIPB must enclose all chip layout patterns (all chip design, excluding MARKS, NODMF marking layer) if seal ring is inserted by SMIC. DRC waive if the chip has been added seal ring by designer >= 0.45um
@ DRC check layers: AA, AADMP, AR, NW, PSUB, SVT_N, SVT_P, LVT_N, LVT_P, HVT_N, HVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, DG, GT, GTDMP, P2, P2DMP, SN, SP, M0, M0DMP, M0G, M0GDMP, M0C, M0CDMP, DIR, DIRDMP, V0, M1, Vy, Mxy, 1.25xMy, 1.25xVn, 1.25xMn, 2xVn, 2xMn, 10xTVn, 10xTMn, 14xTVn, 14xTMn, UTV, UTM, PA, ALPA, MD, MIM, CTOP
@ DRC only check AA and AADMP enclosure in S/D direction
 err1 = ENC NW CHIPB < 0.45 ABUT<90 SINGULAR REGION OUTSIDE ALSO
 err1 NOT INSIDE (OR MARKS NODMF)
}
 
CHIPB_EN_3_PSUB {
@ CHIPB must enclose all chip layout patterns (all chip design, excluding MARKS, NODMF marking layer) if seal ring is inserted by SMIC. DRC waive if the chip has been added seal ring by designer >= 0.45um
@ DRC check layers: AA, AADMP, AR, NW, PSUB, SVT_N, SVT_P, LVT_N, LVT_P, HVT_N, HVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, DG, GT, GTDMP, P2, P2DMP, SN, SP, M0, M0DMP, M0G, M0GDMP, M0C, M0CDMP, DIR, DIRDMP, V0, M1, Vy, Mxy, 1.25xMy, 1.25xVn, 1.25xMn, 2xVn, 2xMn, 10xTVn, 10xTMn, 14xTVn, 14xTMn, UTV, UTM, PA, ALPA, MD, MIM, CTOP
@ DRC only check AA and AADMP enclosure in S/D direction
 err1 = ENC PSUB CHIPB < 0.45 ABUT<90 SINGULAR REGION OUTSIDE ALSO
 err1 NOT INSIDE (OR MARKS NODMF)
}
 
CHIPB_EN_3_SVT_N {
@ CHIPB must enclose all chip layout patterns (all chip design, excluding MARKS, NODMF marking layer) if seal ring is inserted by SMIC. DRC waive if the chip has been added seal ring by designer >= 0.45um
@ DRC check layers: AA, AADMP, AR, NW, PSUB, SVT_N, SVT_P, LVT_N, LVT_P, HVT_N, HVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, DG, GT, GTDMP, P2, P2DMP, SN, SP, M0, M0DMP, M0G, M0GDMP, M0C, M0CDMP, DIR, DIRDMP, V0, M1, Vy, Mxy, 1.25xMy, 1.25xVn, 1.25xMn, 2xVn, 2xMn, 10xTVn, 10xTMn, 14xTVn, 14xTMn, UTV, UTM, PA, ALPA, MD, MIM, CTOP
@ DRC only check AA and AADMP enclosure in S/D direction
 err1 = ENC SVT_N CHIPB < 0.45 ABUT<90 SINGULAR REGION OUTSIDE ALSO
 err1 NOT INSIDE (OR MARKS NODMF)
}
 
CHIPB_EN_3_SVT_P {
@ CHIPB must enclose all chip layout patterns (all chip design, excluding MARKS, NODMF marking layer) if seal ring is inserted by SMIC. DRC waive if the chip has been added seal ring by designer >= 0.45um
@ DRC check layers: AA, AADMP, AR, NW, PSUB, SVT_N, SVT_P, LVT_N, LVT_P, HVT_N, HVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, DG, GT, GTDMP, P2, P2DMP, SN, SP, M0, M0DMP, M0G, M0GDMP, M0C, M0CDMP, DIR, DIRDMP, V0, M1, Vy, Mxy, 1.25xMy, 1.25xVn, 1.25xMn, 2xVn, 2xMn, 10xTVn, 10xTMn, 14xTVn, 14xTMn, UTV, UTM, PA, ALPA, MD, MIM, CTOP
@ DRC only check AA and AADMP enclosure in S/D direction
 err1 = ENC SVT_P CHIPB < 0.45 ABUT<90 SINGULAR REGION OUTSIDE ALSO
 err1 NOT INSIDE (OR MARKS NODMF)
}
 
CHIPB_EN_3_LVT_N {
@ CHIPB must enclose all chip layout patterns (all chip design, excluding MARKS, NODMF marking layer) if seal ring is inserted by SMIC. DRC waive if the chip has been added seal ring by designer >= 0.45um
@ DRC check layers: AA, AADMP, AR, NW, PSUB, SVT_N, SVT_P, LVT_N, LVT_P, HVT_N, HVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, DG, GT, GTDMP, P2, P2DMP, SN, SP, M0, M0DMP, M0G, M0GDMP, M0C, M0CDMP, DIR, DIRDMP, V0, M1, Vy, Mxy, 1.25xMy, 1.25xVn, 1.25xMn, 2xVn, 2xMn, 10xTVn, 10xTMn, 14xTVn, 14xTMn, UTV, UTM, PA, ALPA, MD, MIM, CTOP
@ DRC only check AA and AADMP enclosure in S/D direction
 err1 = ENC LVT_N CHIPB < 0.45 ABUT<90 SINGULAR REGION OUTSIDE ALSO
 err1 NOT INSIDE (OR MARKS NODMF)
}
 
CHIPB_EN_3_LVT_P {
@ CHIPB must enclose all chip layout patterns (all chip design, excluding MARKS, NODMF marking layer) if seal ring is inserted by SMIC. DRC waive if the chip has been added seal ring by designer >= 0.45um
@ DRC check layers: AA, AADMP, AR, NW, PSUB, SVT_N, SVT_P, LVT_N, LVT_P, HVT_N, HVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, DG, GT, GTDMP, P2, P2DMP, SN, SP, M0, M0DMP, M0G, M0GDMP, M0C, M0CDMP, DIR, DIRDMP, V0, M1, Vy, Mxy, 1.25xMy, 1.25xVn, 1.25xMn, 2xVn, 2xMn, 10xTVn, 10xTMn, 14xTVn, 14xTMn, UTV, UTM, PA, ALPA, MD, MIM, CTOP
@ DRC only check AA and AADMP enclosure in S/D direction
 err1 = ENC LVT_P CHIPB < 0.45 ABUT<90 SINGULAR REGION OUTSIDE ALSO
 err1 NOT INSIDE (OR MARKS NODMF)
}
 
CHIPB_EN_3_HVT_N {
@ CHIPB must enclose all chip layout patterns (all chip design, excluding MARKS, NODMF marking layer) if seal ring is inserted by SMIC. DRC waive if the chip has been added seal ring by designer >= 0.45um
@ DRC check layers: AA, AADMP, AR, NW, PSUB, SVT_N, SVT_P, LVT_N, LVT_P, HVT_N, HVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, DG, GT, GTDMP, P2, P2DMP, SN, SP, M0, M0DMP, M0G, M0GDMP, M0C, M0CDMP, DIR, DIRDMP, V0, M1, Vy, Mxy, 1.25xMy, 1.25xVn, 1.25xMn, 2xVn, 2xMn, 10xTVn, 10xTMn, 14xTVn, 14xTMn, UTV, UTM, PA, ALPA, MD, MIM, CTOP
@ DRC only check AA and AADMP enclosure in S/D direction
 err1 = ENC HVT_N CHIPB < 0.45 ABUT<90 SINGULAR REGION OUTSIDE ALSO
 err1 NOT INSIDE (OR MARKS NODMF)
}
 
CHIPB_EN_3_HVT_P {
@ CHIPB must enclose all chip layout patterns (all chip design, excluding MARKS, NODMF marking layer) if seal ring is inserted by SMIC. DRC waive if the chip has been added seal ring by designer >= 0.45um
@ DRC check layers: AA, AADMP, AR, NW, PSUB, SVT_N, SVT_P, LVT_N, LVT_P, HVT_N, HVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, DG, GT, GTDMP, P2, P2DMP, SN, SP, M0, M0DMP, M0G, M0GDMP, M0C, M0CDMP, DIR, DIRDMP, V0, M1, Vy, Mxy, 1.25xMy, 1.25xVn, 1.25xMn, 2xVn, 2xMn, 10xTVn, 10xTMn, 14xTVn, 14xTMn, UTV, UTM, PA, ALPA, MD, MIM, CTOP
@ DRC only check AA and AADMP enclosure in S/D direction
 err1 = ENC HVT_P CHIPB < 0.45 ABUT<90 SINGULAR REGION OUTSIDE ALSO
 err1 NOT INSIDE (OR MARKS NODMF)
}
 
CHIPB_EN_3_ULVT_N {
@ CHIPB must enclose all chip layout patterns (all chip design, excluding MARKS, NODMF marking layer) if seal ring is inserted by SMIC. DRC waive if the chip has been added seal ring by designer >= 0.45um
@ DRC check layers: AA, AADMP, AR, NW, PSUB, SVT_N, SVT_P, LVT_N, LVT_P, HVT_N, HVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, DG, GT, GTDMP, P2, P2DMP, SN, SP, M0, M0DMP, M0G, M0GDMP, M0C, M0CDMP, DIR, DIRDMP, V0, M1, Vy, Mxy, 1.25xMy, 1.25xVn, 1.25xMn, 2xVn, 2xMn, 10xTVn, 10xTMn, 14xTVn, 14xTMn, UTV, UTM, PA, ALPA, MD, MIM, CTOP
@ DRC only check AA and AADMP enclosure in S/D direction
 err1 = ENC ULVT_N CHIPB < 0.45 ABUT<90 SINGULAR REGION OUTSIDE ALSO
 err1 NOT INSIDE (OR MARKS NODMF)
}
 
CHIPB_EN_3_ULVT_P {
@ CHIPB must enclose all chip layout patterns (all chip design, excluding MARKS, NODMF marking layer) if seal ring is inserted by SMIC. DRC waive if the chip has been added seal ring by designer >= 0.45um
@ DRC check layers: AA, AADMP, AR, NW, PSUB, SVT_N, SVT_P, LVT_N, LVT_P, HVT_N, HVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, DG, GT, GTDMP, P2, P2DMP, SN, SP, M0, M0DMP, M0G, M0GDMP, M0C, M0CDMP, DIR, DIRDMP, V0, M1, Vy, Mxy, 1.25xMy, 1.25xVn, 1.25xMn, 2xVn, 2xMn, 10xTVn, 10xTMn, 14xTVn, 14xTMn, UTV, UTM, PA, ALPA, MD, MIM, CTOP
@ DRC only check AA and AADMP enclosure in S/D direction
 err1 = ENC ULVT_P CHIPB < 0.45 ABUT<90 SINGULAR REGION OUTSIDE ALSO
 err1 NOT INSIDE (OR MARKS NODMF)
}
 
CHIPB_EN_3_LFN_N {
@ CHIPB must enclose all chip layout patterns (all chip design, excluding MARKS, NODMF marking layer) if seal ring is inserted by SMIC. DRC waive if the chip has been added seal ring by designer >= 0.45um
@ DRC check layers: AA, AADMP, AR, NW, PSUB, SVT_N, SVT_P, LVT_N, LVT_P, HVT_N, HVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, DG, GT, GTDMP, P2, P2DMP, SN, SP, M0, M0DMP, M0G, M0GDMP, M0C, M0CDMP, DIR, DIRDMP, V0, M1, Vy, Mxy, 1.25xMy, 1.25xVn, 1.25xMn, 2xVn, 2xMn, 10xTVn, 10xTMn, 14xTVn, 14xTMn, UTV, UTM, PA, ALPA, MD, MIM, CTOP
@ DRC only check AA and AADMP enclosure in S/D direction
 err1 = ENC LFN_N CHIPB < 0.45 ABUT<90 SINGULAR REGION OUTSIDE ALSO
 err1 NOT INSIDE (OR MARKS NODMF)
}
 
CHIPB_EN_3_LFN_P {
@ CHIPB must enclose all chip layout patterns (all chip design, excluding MARKS, NODMF marking layer) if seal ring is inserted by SMIC. DRC waive if the chip has been added seal ring by designer >= 0.45um
@ DRC check layers: AA, AADMP, AR, NW, PSUB, SVT_N, SVT_P, LVT_N, LVT_P, HVT_N, HVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, DG, GT, GTDMP, P2, P2DMP, SN, SP, M0, M0DMP, M0G, M0GDMP, M0C, M0CDMP, DIR, DIRDMP, V0, M1, Vy, Mxy, 1.25xMy, 1.25xVn, 1.25xMn, 2xVn, 2xMn, 10xTVn, 10xTMn, 14xTVn, 14xTMn, UTV, UTM, PA, ALPA, MD, MIM, CTOP
@ DRC only check AA and AADMP enclosure in S/D direction
 err1 = ENC LFN_P CHIPB < 0.45 ABUT<90 SINGULAR REGION OUTSIDE ALSO
 err1 NOT INSIDE (OR MARKS NODMF)
}
 
CHIPB_EN_3_DG {
@ CHIPB must enclose all chip layout patterns (all chip design, excluding MARKS, NODMF marking layer) if seal ring is inserted by SMIC. DRC waive if the chip has been added seal ring by designer >= 0.45um
@ DRC check layers: AA, AADMP, AR, NW, PSUB, SVT_N, SVT_P, LVT_N, LVT_P, HVT_N, HVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, DG, GT, GTDMP, P2, P2DMP, SN, SP, M0, M0DMP, M0G, M0GDMP, M0C, M0CDMP, DIR, DIRDMP, V0, M1, Vy, Mxy, 1.25xMy, 1.25xVn, 1.25xMn, 2xVn, 2xMn, 10xTVn, 10xTMn, 14xTVn, 14xTMn, UTV, UTM, PA, ALPA, MD, MIM, CTOP
@ DRC only check AA and AADMP enclosure in S/D direction
 err1 = ENC DG CHIPB < 0.45 ABUT<90 SINGULAR REGION OUTSIDE ALSO
 err1 NOT INSIDE (OR MARKS NODMF)
}
 
CHIPB_EN_3_GT {
@ CHIPB must enclose all chip layout patterns (all chip design, excluding MARKS, NODMF marking layer) if seal ring is inserted by SMIC. DRC waive if the chip has been added seal ring by designer >= 0.45um
@ DRC check layers: AA, AADMP, AR, NW, PSUB, SVT_N, SVT_P, LVT_N, LVT_P, HVT_N, HVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, DG, GT, GTDMP, P2, P2DMP, SN, SP, M0, M0DMP, M0G, M0GDMP, M0C, M0CDMP, DIR, DIRDMP, V0, M1, Vy, Mxy, 1.25xMy, 1.25xVn, 1.25xMn, 2xVn, 2xMn, 10xTVn, 10xTMn, 14xTVn, 14xTMn, UTV, UTM, PA, ALPA, MD, MIM, CTOP
@ DRC only check AA and AADMP enclosure in S/D direction
 err1 = ENC GT CHIPB < 0.45 ABUT<90 SINGULAR REGION OUTSIDE ALSO
 err1 NOT INSIDE (OR MARKS NODMF)
}
 
CHIPB_EN_3_GTDMP {
@ CHIPB must enclose all chip layout patterns (all chip design, excluding MARKS, NODMF marking layer) if seal ring is inserted by SMIC. DRC waive if the chip has been added seal ring by designer >= 0.45um
@ DRC check layers: AA, AADMP, AR, NW, PSUB, SVT_N, SVT_P, LVT_N, LVT_P, HVT_N, HVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, DG, GT, GTDMP, P2, P2DMP, SN, SP, M0, M0DMP, M0G, M0GDMP, M0C, M0CDMP, DIR, DIRDMP, V0, M1, Vy, Mxy, 1.25xMy, 1.25xVn, 1.25xMn, 2xVn, 2xMn, 10xTVn, 10xTMn, 14xTVn, 14xTMn, UTV, UTM, PA, ALPA, MD, MIM, CTOP
@ DRC only check AA and AADMP enclosure in S/D direction
 err1 = ENC GTDMP CHIPB < 0.45 ABUT<90 SINGULAR REGION OUTSIDE ALSO
 err1 NOT INSIDE (OR MARKS NODMF)
}
 
CHIPB_EN_3_P2 {
@ CHIPB must enclose all chip layout patterns (all chip design, excluding MARKS, NODMF marking layer) if seal ring is inserted by SMIC. DRC waive if the chip has been added seal ring by designer >= 0.45um
@ DRC check layers: AA, AADMP, AR, NW, PSUB, SVT_N, SVT_P, LVT_N, LVT_P, HVT_N, HVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, DG, GT, GTDMP, P2, P2DMP, SN, SP, M0, M0DMP, M0G, M0GDMP, M0C, M0CDMP, DIR, DIRDMP, V0, M1, Vy, Mxy, 1.25xMy, 1.25xVn, 1.25xMn, 2xVn, 2xMn, 10xTVn, 10xTMn, 14xTVn, 14xTMn, UTV, UTM, PA, ALPA, MD, MIM, CTOP
@ DRC only check AA and AADMP enclosure in S/D direction
 err1 = ENC P2 CHIPB < 0.45 ABUT<90 SINGULAR REGION OUTSIDE ALSO
 err1 NOT INSIDE (OR MARKS NODMF)
}
 
CHIPB_EN_3_P2DMP {
@ CHIPB must enclose all chip layout patterns (all chip design, excluding MARKS, NODMF marking layer) if seal ring is inserted by SMIC. DRC waive if the chip has been added seal ring by designer >= 0.45um
@ DRC check layers: AA, AADMP, AR, NW, PSUB, SVT_N, SVT_P, LVT_N, LVT_P, HVT_N, HVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, DG, GT, GTDMP, P2, P2DMP, SN, SP, M0, M0DMP, M0G, M0GDMP, M0C, M0CDMP, DIR, DIRDMP, V0, M1, Vy, Mxy, 1.25xMy, 1.25xVn, 1.25xMn, 2xVn, 2xMn, 10xTVn, 10xTMn, 14xTVn, 14xTMn, UTV, UTM, PA, ALPA, MD, MIM, CTOP
@ DRC only check AA and AADMP enclosure in S/D direction
 err1 = ENC P2DMP CHIPB < 0.45 ABUT<90 SINGULAR REGION OUTSIDE ALSO
 err1 NOT INSIDE (OR MARKS NODMF)
}
 
CHIPB_EN_3_SN {
@ CHIPB must enclose all chip layout patterns (all chip design, excluding MARKS, NODMF marking layer) if seal ring is inserted by SMIC. DRC waive if the chip has been added seal ring by designer >= 0.45um
@ DRC check layers: AA, AADMP, AR, NW, PSUB, SVT_N, SVT_P, LVT_N, LVT_P, HVT_N, HVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, DG, GT, GTDMP, P2, P2DMP, SN, SP, M0, M0DMP, M0G, M0GDMP, M0C, M0CDMP, DIR, DIRDMP, V0, M1, Vy, Mxy, 1.25xMy, 1.25xVn, 1.25xMn, 2xVn, 2xMn, 10xTVn, 10xTMn, 14xTVn, 14xTMn, UTV, UTM, PA, ALPA, MD, MIM, CTOP
@ DRC only check AA and AADMP enclosure in S/D direction
 err1 = ENC SN CHIPB < 0.45 ABUT<90 SINGULAR REGION OUTSIDE ALSO
 err1 NOT INSIDE (OR MARKS NODMF)
}
 
CHIPB_EN_3_SP {
@ CHIPB must enclose all chip layout patterns (all chip design, excluding MARKS, NODMF marking layer) if seal ring is inserted by SMIC. DRC waive if the chip has been added seal ring by designer >= 0.45um
@ DRC check layers: AA, AADMP, AR, NW, PSUB, SVT_N, SVT_P, LVT_N, LVT_P, HVT_N, HVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, DG, GT, GTDMP, P2, P2DMP, SN, SP, M0, M0DMP, M0G, M0GDMP, M0C, M0CDMP, DIR, DIRDMP, V0, M1, Vy, Mxy, 1.25xMy, 1.25xVn, 1.25xMn, 2xVn, 2xMn, 10xTVn, 10xTMn, 14xTVn, 14xTMn, UTV, UTM, PA, ALPA, MD, MIM, CTOP
@ DRC only check AA and AADMP enclosure in S/D direction
 err1 = ENC SP CHIPB < 0.45 ABUT<90 SINGULAR REGION OUTSIDE ALSO
 err1 NOT INSIDE (OR MARKS NODMF)
}
 
CHIPB_EN_3_M0 {
@ CHIPB must enclose all chip layout patterns (all chip design, excluding MARKS, NODMF marking layer) if seal ring is inserted by SMIC. DRC waive if the chip has been added seal ring by designer >= 0.45um
@ DRC check layers: AA, AADMP, AR, NW, PSUB, SVT_N, SVT_P, LVT_N, LVT_P, HVT_N, HVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, DG, GT, GTDMP, P2, P2DMP, SN, SP, M0, M0DMP, M0G, M0GDMP, M0C, M0CDMP, DIR, DIRDMP, V0, M1, Vy, Mxy, 1.25xMy, 1.25xVn, 1.25xMn, 2xVn, 2xMn, 10xTVn, 10xTMn, 14xTVn, 14xTMn, UTV, UTM, PA, ALPA, MD, MIM, CTOP
@ DRC only check AA and AADMP enclosure in S/D direction
 err1 = ENC M0 CHIPB < 0.45 ABUT<90 SINGULAR REGION OUTSIDE ALSO
 err1 NOT INSIDE (OR MARKS NODMF)
}
 
CHIPB_EN_3_M0DMP {
@ CHIPB must enclose all chip layout patterns (all chip design, excluding MARKS, NODMF marking layer) if seal ring is inserted by SMIC. DRC waive if the chip has been added seal ring by designer >= 0.45um
@ DRC check layers: AA, AADMP, AR, NW, PSUB, SVT_N, SVT_P, LVT_N, LVT_P, HVT_N, HVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, DG, GT, GTDMP, P2, P2DMP, SN, SP, M0, M0DMP, M0G, M0GDMP, M0C, M0CDMP, DIR, DIRDMP, V0, M1, Vy, Mxy, 1.25xMy, 1.25xVn, 1.25xMn, 2xVn, 2xMn, 10xTVn, 10xTMn, 14xTVn, 14xTMn, UTV, UTM, PA, ALPA, MD, MIM, CTOP
@ DRC only check AA and AADMP enclosure in S/D direction
 err1 = ENC M0DMP CHIPB < 0.45 ABUT<90 SINGULAR REGION OUTSIDE ALSO
 err1 NOT INSIDE (OR MARKS NODMF)
}
 
CHIPB_EN_3_M0G {
@ CHIPB must enclose all chip layout patterns (all chip design, excluding MARKS, NODMF marking layer) if seal ring is inserted by SMIC. DRC waive if the chip has been added seal ring by designer >= 0.45um
@ DRC check layers: AA, AADMP, AR, NW, PSUB, SVT_N, SVT_P, LVT_N, LVT_P, HVT_N, HVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, DG, GT, GTDMP, P2, P2DMP, SN, SP, M0, M0DMP, M0G, M0GDMP, M0C, M0CDMP, DIR, DIRDMP, V0, M1, Vy, Mxy, 1.25xMy, 1.25xVn, 1.25xMn, 2xVn, 2xMn, 10xTVn, 10xTMn, 14xTVn, 14xTMn, UTV, UTM, PA, ALPA, MD, MIM, CTOP
@ DRC only check AA and AADMP enclosure in S/D direction
 err1 = ENC M0G CHIPB < 0.45 ABUT<90 SINGULAR REGION OUTSIDE ALSO
 err1 NOT INSIDE (OR MARKS NODMF)
}
 
CHIPB_EN_3_M0GDMP {
@ CHIPB must enclose all chip layout patterns (all chip design, excluding MARKS, NODMF marking layer) if seal ring is inserted by SMIC. DRC waive if the chip has been added seal ring by designer >= 0.45um
@ DRC check layers: AA, AADMP, AR, NW, PSUB, SVT_N, SVT_P, LVT_N, LVT_P, HVT_N, HVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, DG, GT, GTDMP, P2, P2DMP, SN, SP, M0, M0DMP, M0G, M0GDMP, M0C, M0CDMP, DIR, DIRDMP, V0, M1, Vy, Mxy, 1.25xMy, 1.25xVn, 1.25xMn, 2xVn, 2xMn, 10xTVn, 10xTMn, 14xTVn, 14xTMn, UTV, UTM, PA, ALPA, MD, MIM, CTOP
@ DRC only check AA and AADMP enclosure in S/D direction
 err1 = ENC M0GDMP CHIPB < 0.45 ABUT<90 SINGULAR REGION OUTSIDE ALSO
 err1 NOT INSIDE (OR MARKS NODMF)
}
 
CHIPB_EN_3_M0C {
@ CHIPB must enclose all chip layout patterns (all chip design, excluding MARKS, NODMF marking layer) if seal ring is inserted by SMIC. DRC waive if the chip has been added seal ring by designer >= 0.45um
@ DRC check layers: AA, AADMP, AR, NW, PSUB, SVT_N, SVT_P, LVT_N, LVT_P, HVT_N, HVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, DG, GT, GTDMP, P2, P2DMP, SN, SP, M0, M0DMP, M0G, M0GDMP, M0C, M0CDMP, DIR, DIRDMP, V0, M1, Vy, Mxy, 1.25xMy, 1.25xVn, 1.25xMn, 2xVn, 2xMn, 10xTVn, 10xTMn, 14xTVn, 14xTMn, UTV, UTM, PA, ALPA, MD, MIM, CTOP
@ DRC only check AA and AADMP enclosure in S/D direction
 err1 = ENC M0C CHIPB < 0.45 ABUT<90 SINGULAR REGION OUTSIDE ALSO
 err1 NOT INSIDE (OR MARKS NODMF)
}
 
CHIPB_EN_3_M0CDMP {
@ CHIPB must enclose all chip layout patterns (all chip design, excluding MARKS, NODMF marking layer) if seal ring is inserted by SMIC. DRC waive if the chip has been added seal ring by designer >= 0.45um
@ DRC check layers: AA, AADMP, AR, NW, PSUB, SVT_N, SVT_P, LVT_N, LVT_P, HVT_N, HVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, DG, GT, GTDMP, P2, P2DMP, SN, SP, M0, M0DMP, M0G, M0GDMP, M0C, M0CDMP, DIR, DIRDMP, V0, M1, Vy, Mxy, 1.25xMy, 1.25xVn, 1.25xMn, 2xVn, 2xMn, 10xTVn, 10xTMn, 14xTVn, 14xTMn, UTV, UTM, PA, ALPA, MD, MIM, CTOP
@ DRC only check AA and AADMP enclosure in S/D direction
 err1 = ENC M0CDMP CHIPB < 0.45 ABUT<90 SINGULAR REGION OUTSIDE ALSO
 err1 NOT INSIDE (OR MARKS NODMF)
}
 
CHIPB_EN_3_DIR {
@ CHIPB must enclose all chip layout patterns (all chip design, excluding MARKS, NODMF marking layer) if seal ring is inserted by SMIC. DRC waive if the chip has been added seal ring by designer >= 0.45um
@ DRC check layers: AA, AADMP, AR, NW, PSUB, SVT_N, SVT_P, LVT_N, LVT_P, HVT_N, HVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, DG, GT, GTDMP, P2, P2DMP, SN, SP, M0, M0DMP, M0G, M0GDMP, M0C, M0CDMP, DIR, DIRDMP, V0, M1, Vy, Mxy, 1.25xMy, 1.25xVn, 1.25xMn, 2xVn, 2xMn, 10xTVn, 10xTMn, 14xTVn, 14xTMn, UTV, UTM, PA, ALPA, MD, MIM, CTOP
@ DRC only check AA and AADMP enclosure in S/D direction
 err1 = ENC DIR CHIPB < 0.45 ABUT<90 SINGULAR REGION OUTSIDE ALSO
 err1 NOT INSIDE (OR MARKS NODMF)
}
 
CHIPB_EN_3_DIRDMP {
@ CHIPB must enclose all chip layout patterns (all chip design, excluding MARKS, NODMF marking layer) if seal ring is inserted by SMIC. DRC waive if the chip has been added seal ring by designer >= 0.45um
@ DRC check layers: AA, AADMP, AR, NW, PSUB, SVT_N, SVT_P, LVT_N, LVT_P, HVT_N, HVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, DG, GT, GTDMP, P2, P2DMP, SN, SP, M0, M0DMP, M0G, M0GDMP, M0C, M0CDMP, DIR, DIRDMP, V0, M1, Vy, Mxy, 1.25xMy, 1.25xVn, 1.25xMn, 2xVn, 2xMn, 10xTVn, 10xTMn, 14xTVn, 14xTMn, UTV, UTM, PA, ALPA, MD, MIM, CTOP
@ DRC only check AA and AADMP enclosure in S/D direction
 err1 = ENC DIRDMP CHIPB < 0.45 ABUT<90 SINGULAR REGION OUTSIDE ALSO
 err1 NOT INSIDE (OR MARKS NODMF)
}
 
CHIPB_EN_3_V0 {
@ CHIPB must enclose all chip layout patterns (all chip design, excluding MARKS, NODMF marking layer) if seal ring is inserted by SMIC. DRC waive if the chip has been added seal ring by designer >= 0.45um
@ DRC check layers: AA, AADMP, AR, NW, PSUB, SVT_N, SVT_P, LVT_N, LVT_P, HVT_N, HVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, DG, GT, GTDMP, P2, P2DMP, SN, SP, M0, M0DMP, M0G, M0GDMP, M0C, M0CDMP, DIR, DIRDMP, V0, M1, Vy, Mxy, 1.25xMy, 1.25xVn, 1.25xMn, 2xVn, 2xMn, 10xTVn, 10xTMn, 14xTVn, 14xTMn, UTV, UTM, PA, ALPA, MD, MIM, CTOP
@ DRC only check AA and AADMP enclosure in S/D direction
 err1 = ENC V0 CHIPB < 0.45 ABUT<90 SINGULAR REGION OUTSIDE ALSO
 err1 NOT INSIDE (OR MARKS NODMF)
}
 
CHIPB_EN_3_PA {
@ CHIPB must enclose all chip layout patterns (all chip design, excluding MARKS, NODMF marking layer) if seal ring is inserted by SMIC. DRC waive if the chip has been added seal ring by designer >= 0.45um
@ DRC check layers: AA, AADMP, AR, NW, PSUB, SVT_N, SVT_P, LVT_N, LVT_P, HVT_N, HVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, DG, GT, GTDMP, P2, P2DMP, SN, SP, M0, M0DMP, M0G, M0GDMP, M0C, M0CDMP, DIR, DIRDMP, V0, M1, Vy, Mxy, 1.25xMy, 1.25xVn, 1.25xMn, 2xVn, 2xMn, 10xTVn, 10xTMn, 14xTVn, 14xTMn, UTV, UTM, PA, ALPA, MD, MIM, CTOP
@ DRC only check AA and AADMP enclosure in S/D direction
 err1 = ENC PA CHIPB < 0.45 ABUT<90 SINGULAR REGION OUTSIDE ALSO
 err1 NOT INSIDE (OR MARKS NODMF)
}
 
CHIPB_EN_3_ALPA {
@ CHIPB must enclose all chip layout patterns (all chip design, excluding MARKS, NODMF marking layer) if seal ring is inserted by SMIC. DRC waive if the chip has been added seal ring by designer >= 0.45um
@ DRC check layers: AA, AADMP, AR, NW, PSUB, SVT_N, SVT_P, LVT_N, LVT_P, HVT_N, HVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, DG, GT, GTDMP, P2, P2DMP, SN, SP, M0, M0DMP, M0G, M0GDMP, M0C, M0CDMP, DIR, DIRDMP, V0, M1, Vy, Mxy, 1.25xMy, 1.25xVn, 1.25xMn, 2xVn, 2xMn, 10xTVn, 10xTMn, 14xTVn, 14xTMn, UTV, UTM, PA, ALPA, MD, MIM, CTOP
@ DRC only check AA and AADMP enclosure in S/D direction
 err1 = ENC ALPA CHIPB < 0.45 ABUT<90 SINGULAR REGION OUTSIDE ALSO
 err1 NOT INSIDE (OR MARKS NODMF)
}
 
CHIPB_EN_3_MD {
@ CHIPB must enclose all chip layout patterns (all chip design, excluding MARKS, NODMF marking layer) if seal ring is inserted by SMIC. DRC waive if the chip has been added seal ring by designer >= 0.45um
@ DRC check layers: AA, AADMP, AR, NW, PSUB, SVT_N, SVT_P, LVT_N, LVT_P, HVT_N, HVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, DG, GT, GTDMP, P2, P2DMP, SN, SP, M0, M0DMP, M0G, M0GDMP, M0C, M0CDMP, DIR, DIRDMP, V0, M1, Vy, Mxy, 1.25xMy, 1.25xVn, 1.25xMn, 2xVn, 2xMn, 10xTVn, 10xTMn, 14xTVn, 14xTMn, UTV, UTM, PA, ALPA, MD, MIM, CTOP
@ DRC only check AA and AADMP enclosure in S/D direction
 err1 = ENC MD CHIPB < 0.45 ABUT<90 SINGULAR REGION OUTSIDE ALSO
 err1 NOT INSIDE (OR MARKS NODMF)
}
 
CHIPB_EN_3_MIM {
@ CHIPB must enclose all chip layout patterns (all chip design, excluding MARKS, NODMF marking layer) if seal ring is inserted by SMIC. DRC waive if the chip has been added seal ring by designer >= 0.45um
@ DRC check layers: AA, AADMP, AR, NW, PSUB, SVT_N, SVT_P, LVT_N, LVT_P, HVT_N, HVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, DG, GT, GTDMP, P2, P2DMP, SN, SP, M0, M0DMP, M0G, M0GDMP, M0C, M0CDMP, DIR, DIRDMP, V0, M1, Vy, Mxy, 1.25xMy, 1.25xVn, 1.25xMn, 2xVn, 2xMn, 10xTVn, 10xTMn, 14xTVn, 14xTMn, UTV, UTM, PA, ALPA, MD, MIM, CTOP
@ DRC only check AA and AADMP enclosure in S/D direction
 err1 = ENC MIM CHIPB < 0.45 ABUT<90 SINGULAR REGION OUTSIDE ALSO
 err1 NOT INSIDE (OR MARKS NODMF)
}
 
CHIPB_EN_3_CTOP {
@ CHIPB must enclose all chip layout patterns (all chip design, excluding MARKS, NODMF marking layer) if seal ring is inserted by SMIC. DRC waive if the chip has been added seal ring by designer >= 0.45um
@ DRC check layers: AA, AADMP, AR, NW, PSUB, SVT_N, SVT_P, LVT_N, LVT_P, HVT_N, HVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, DG, GT, GTDMP, P2, P2DMP, SN, SP, M0, M0DMP, M0G, M0GDMP, M0C, M0CDMP, DIR, DIRDMP, V0, M1, Vy, Mxy, 1.25xMy, 1.25xVn, 1.25xMn, 2xVn, 2xMn, 10xTVn, 10xTMn, 14xTVn, 14xTMn, UTV, UTM, PA, ALPA, MD, MIM, CTOP
@ DRC only check AA and AADMP enclosure in S/D direction
 err1 = ENC CTOP CHIPB < 0.45 ABUT<90 SINGULAR REGION OUTSIDE ALSO
 err1 NOT INSIDE (OR MARKS NODMF)
}
 
CHIPB_EN_3_M1 {
@ CHIPB must enclose all chip layout patterns (all chip design, excluding MARKS, NODMF marking layer) if seal ring is inserted by SMIC. DRC waive if the chip has been added seal ring by designer >= 0.45um
@ DRC check layers: AA, AADMP, AR, NW, PSUB, SVT_N, SVT_P, LVT_N, LVT_P, HVT_N, HVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, DG, GT, GTDMP, P2, P2DMP, SN, SP, M0, M0DMP, M0G, M0GDMP, M0C, M0CDMP, DIR, DIRDMP, V0, M1, Vy, Mxy, 1.25xMy, 1.25xVn, 1.25xMn, 2xVn, 2xMn, 10xTVn, 10xTMn, 14xTVn, 14xTMn, UTV, UTM, PA, ALPA, MD, MIM, CTOP
@ DRC only check AA and AADMP enclosure in S/D direction
 err1 = ENC M1 CHIPB < 0.45 ABUT<90 SINGULAR REGION OUTSIDE ALSO
 err1 NOT INSIDE (OR MARKS NODMF)
}
 
CHIPB_EN_3_M2 {
@ CHIPB must enclose all chip layout patterns (all chip design, excluding MARKS, NODMF marking layer) if seal ring is inserted by SMIC. DRC waive if the chip has been added seal ring by designer >= 0.45um
@ DRC check layers: AA, AADMP, AR, NW, PSUB, SVT_N, SVT_P, LVT_N, LVT_P, HVT_N, HVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, DG, GT, GTDMP, P2, P2DMP, SN, SP, M0, M0DMP, M0G, M0GDMP, M0C, M0CDMP, DIR, DIRDMP, V0, M1, Vy, Mxy, 1.25xMy, 1.25xVn, 1.25xMn, 2xVn, 2xMn, 10xTVn, 10xTMn, 14xTVn, 14xTMn, UTV, UTM, PA, ALPA, MD, MIM, CTOP
@ DRC only check AA and AADMP enclosure in S/D direction
 err1 = ENC M2 CHIPB < 0.45 ABUT<90 SINGULAR REGION OUTSIDE ALSO
 err1 NOT INSIDE (OR MARKS NODMF)
}
 
CHIPB_EN_3_M3 {
@ CHIPB must enclose all chip layout patterns (all chip design, excluding MARKS, NODMF marking layer) if seal ring is inserted by SMIC. DRC waive if the chip has been added seal ring by designer >= 0.45um
@ DRC check layers: AA, AADMP, AR, NW, PSUB, SVT_N, SVT_P, LVT_N, LVT_P, HVT_N, HVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, DG, GT, GTDMP, P2, P2DMP, SN, SP, M0, M0DMP, M0G, M0GDMP, M0C, M0CDMP, DIR, DIRDMP, V0, M1, Vy, Mxy, 1.25xMy, 1.25xVn, 1.25xMn, 2xVn, 2xMn, 10xTVn, 10xTMn, 14xTVn, 14xTMn, UTV, UTM, PA, ALPA, MD, MIM, CTOP
@ DRC only check AA and AADMP enclosure in S/D direction
 err1 = ENC M3 CHIPB < 0.45 ABUT<90 SINGULAR REGION OUTSIDE ALSO
 err1 NOT INSIDE (OR MARKS NODMF)
}
 
CHIPB_EN_3_M4 {
@ CHIPB must enclose all chip layout patterns (all chip design, excluding MARKS, NODMF marking layer) if seal ring is inserted by SMIC. DRC waive if the chip has been added seal ring by designer >= 0.45um
@ DRC check layers: AA, AADMP, AR, NW, PSUB, SVT_N, SVT_P, LVT_N, LVT_P, HVT_N, HVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, DG, GT, GTDMP, P2, P2DMP, SN, SP, M0, M0DMP, M0G, M0GDMP, M0C, M0CDMP, DIR, DIRDMP, V0, M1, Vy, Mxy, 1.25xMy, 1.25xVn, 1.25xMn, 2xVn, 2xMn, 10xTVn, 10xTMn, 14xTVn, 14xTMn, UTV, UTM, PA, ALPA, MD, MIM, CTOP
@ DRC only check AA and AADMP enclosure in S/D direction
 err1 = ENC M4 CHIPB < 0.45 ABUT<90 SINGULAR REGION OUTSIDE ALSO
 err1 NOT INSIDE (OR MARKS NODMF)
}
 
CHIPB_EN_3_M5 {
@ CHIPB must enclose all chip layout patterns (all chip design, excluding MARKS, NODMF marking layer) if seal ring is inserted by SMIC. DRC waive if the chip has been added seal ring by designer >= 0.45um
@ DRC check layers: AA, AADMP, AR, NW, PSUB, SVT_N, SVT_P, LVT_N, LVT_P, HVT_N, HVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, DG, GT, GTDMP, P2, P2DMP, SN, SP, M0, M0DMP, M0G, M0GDMP, M0C, M0CDMP, DIR, DIRDMP, V0, M1, Vy, Mxy, 1.25xMy, 1.25xVn, 1.25xMn, 2xVn, 2xMn, 10xTVn, 10xTMn, 14xTVn, 14xTMn, UTV, UTM, PA, ALPA, MD, MIM, CTOP
@ DRC only check AA and AADMP enclosure in S/D direction
 err1 = ENC M5 CHIPB < 0.45 ABUT<90 SINGULAR REGION OUTSIDE ALSO
 err1 NOT INSIDE (OR MARKS NODMF)
}
 
CHIPB_EN_3_M6 {
@ CHIPB must enclose all chip layout patterns (all chip design, excluding MARKS, NODMF marking layer) if seal ring is inserted by SMIC. DRC waive if the chip has been added seal ring by designer >= 0.45um
@ DRC check layers: AA, AADMP, AR, NW, PSUB, SVT_N, SVT_P, LVT_N, LVT_P, HVT_N, HVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, DG, GT, GTDMP, P2, P2DMP, SN, SP, M0, M0DMP, M0G, M0GDMP, M0C, M0CDMP, DIR, DIRDMP, V0, M1, Vy, Mxy, 1.25xMy, 1.25xVn, 1.25xMn, 2xVn, 2xMn, 10xTVn, 10xTMn, 14xTVn, 14xTMn, UTV, UTM, PA, ALPA, MD, MIM, CTOP
@ DRC only check AA and AADMP enclosure in S/D direction
 err1 = ENC M6 CHIPB < 0.45 ABUT<90 SINGULAR REGION OUTSIDE ALSO
 err1 NOT INSIDE (OR MARKS NODMF)
}
 
CHIPB_EN_3_M7 {
@ CHIPB must enclose all chip layout patterns (all chip design, excluding MARKS, NODMF marking layer) if seal ring is inserted by SMIC. DRC waive if the chip has been added seal ring by designer >= 0.45um
@ DRC check layers: AA, AADMP, AR, NW, PSUB, SVT_N, SVT_P, LVT_N, LVT_P, HVT_N, HVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, DG, GT, GTDMP, P2, P2DMP, SN, SP, M0, M0DMP, M0G, M0GDMP, M0C, M0CDMP, DIR, DIRDMP, V0, M1, Vy, Mxy, 1.25xMy, 1.25xVn, 1.25xMn, 2xVn, 2xMn, 10xTVn, 10xTMn, 14xTVn, 14xTMn, UTV, UTM, PA, ALPA, MD, MIM, CTOP
@ DRC only check AA and AADMP enclosure in S/D direction
 err1 = ENC M7 CHIPB < 0.45 ABUT<90 SINGULAR REGION OUTSIDE ALSO
 err1 NOT INSIDE (OR MARKS NODMF)
}
 
CHIPB_EN_3_TM2 {
@ CHIPB must enclose all chip layout patterns (all chip design, excluding MARKS, NODMF marking layer) if seal ring is inserted by SMIC. DRC waive if the chip has been added seal ring by designer >= 0.45um
@ DRC check layers: AA, AADMP, AR, NW, PSUB, SVT_N, SVT_P, LVT_N, LVT_P, HVT_N, HVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, DG, GT, GTDMP, P2, P2DMP, SN, SP, M0, M0DMP, M0G, M0GDMP, M0C, M0CDMP, DIR, DIRDMP, V0, M1, Vy, Mxy, 1.25xMy, 1.25xVn, 1.25xMn, 2xVn, 2xMn, 10xTVn, 10xTMn, 14xTVn, 14xTMn, UTV, UTM, PA, ALPA, MD, MIM, CTOP
@ DRC only check AA and AADMP enclosure in S/D direction
 err1 = ENC TM2 CHIPB < 0.45 ABUT<90 SINGULAR REGION OUTSIDE ALSO
 err1 NOT INSIDE (OR MARKS NODMF)
}
 
CHIPB_EN_3_V1 {
@ CHIPB must enclose all chip layout patterns (all chip design, excluding MARKS, NODMF marking layer) if seal ring is inserted by SMIC. DRC waive if the chip has been added seal ring by designer >= 0.45um
@ DRC check layers: AA, AADMP, AR, NW, PSUB, SVT_N, SVT_P, LVT_N, LVT_P, HVT_N, HVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, DG, GT, GTDMP, P2, P2DMP, SN, SP, M0, M0DMP, M0G, M0GDMP, M0C, M0CDMP, DIR, DIRDMP, V0, M1, Vy, Mxy, 1.25xMy, 1.25xVn, 1.25xMn, 2xVn, 2xMn, 10xTVn, 10xTMn, 14xTVn, 14xTMn, UTV, UTM, PA, ALPA, MD, MIM, CTOP
@ DRC only check AA and AADMP enclosure in S/D direction
 err1 = ENC V1 CHIPB < 0.45 ABUT<90 SINGULAR REGION OUTSIDE ALSO
 err1 NOT INSIDE (OR MARKS NODMF)
}
 
CHIPB_EN_3_V2 {
@ CHIPB must enclose all chip layout patterns (all chip design, excluding MARKS, NODMF marking layer) if seal ring is inserted by SMIC. DRC waive if the chip has been added seal ring by designer >= 0.45um
@ DRC check layers: AA, AADMP, AR, NW, PSUB, SVT_N, SVT_P, LVT_N, LVT_P, HVT_N, HVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, DG, GT, GTDMP, P2, P2DMP, SN, SP, M0, M0DMP, M0G, M0GDMP, M0C, M0CDMP, DIR, DIRDMP, V0, M1, Vy, Mxy, 1.25xMy, 1.25xVn, 1.25xMn, 2xVn, 2xMn, 10xTVn, 10xTMn, 14xTVn, 14xTMn, UTV, UTM, PA, ALPA, MD, MIM, CTOP
@ DRC only check AA and AADMP enclosure in S/D direction
 err1 = ENC V2 CHIPB < 0.45 ABUT<90 SINGULAR REGION OUTSIDE ALSO
 err1 NOT INSIDE (OR MARKS NODMF)
}
 
CHIPB_EN_3_V3 {
@ CHIPB must enclose all chip layout patterns (all chip design, excluding MARKS, NODMF marking layer) if seal ring is inserted by SMIC. DRC waive if the chip has been added seal ring by designer >= 0.45um
@ DRC check layers: AA, AADMP, AR, NW, PSUB, SVT_N, SVT_P, LVT_N, LVT_P, HVT_N, HVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, DG, GT, GTDMP, P2, P2DMP, SN, SP, M0, M0DMP, M0G, M0GDMP, M0C, M0CDMP, DIR, DIRDMP, V0, M1, Vy, Mxy, 1.25xMy, 1.25xVn, 1.25xMn, 2xVn, 2xMn, 10xTVn, 10xTMn, 14xTVn, 14xTMn, UTV, UTM, PA, ALPA, MD, MIM, CTOP
@ DRC only check AA and AADMP enclosure in S/D direction
 err1 = ENC V3 CHIPB < 0.45 ABUT<90 SINGULAR REGION OUTSIDE ALSO
 err1 NOT INSIDE (OR MARKS NODMF)
}
 
CHIPB_EN_3_V4 {
@ CHIPB must enclose all chip layout patterns (all chip design, excluding MARKS, NODMF marking layer) if seal ring is inserted by SMIC. DRC waive if the chip has been added seal ring by designer >= 0.45um
@ DRC check layers: AA, AADMP, AR, NW, PSUB, SVT_N, SVT_P, LVT_N, LVT_P, HVT_N, HVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, DG, GT, GTDMP, P2, P2DMP, SN, SP, M0, M0DMP, M0G, M0GDMP, M0C, M0CDMP, DIR, DIRDMP, V0, M1, Vy, Mxy, 1.25xMy, 1.25xVn, 1.25xMn, 2xVn, 2xMn, 10xTVn, 10xTMn, 14xTVn, 14xTMn, UTV, UTM, PA, ALPA, MD, MIM, CTOP
@ DRC only check AA and AADMP enclosure in S/D direction
 err1 = ENC V4 CHIPB < 0.45 ABUT<90 SINGULAR REGION OUTSIDE ALSO
 err1 NOT INSIDE (OR MARKS NODMF)
}
 
CHIPB_EN_3_V5 {
@ CHIPB must enclose all chip layout patterns (all chip design, excluding MARKS, NODMF marking layer) if seal ring is inserted by SMIC. DRC waive if the chip has been added seal ring by designer >= 0.45um
@ DRC check layers: AA, AADMP, AR, NW, PSUB, SVT_N, SVT_P, LVT_N, LVT_P, HVT_N, HVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, DG, GT, GTDMP, P2, P2DMP, SN, SP, M0, M0DMP, M0G, M0GDMP, M0C, M0CDMP, DIR, DIRDMP, V0, M1, Vy, Mxy, 1.25xMy, 1.25xVn, 1.25xMn, 2xVn, 2xMn, 10xTVn, 10xTMn, 14xTVn, 14xTMn, UTV, UTM, PA, ALPA, MD, MIM, CTOP
@ DRC only check AA and AADMP enclosure in S/D direction
 err1 = ENC V5 CHIPB < 0.45 ABUT<90 SINGULAR REGION OUTSIDE ALSO
 err1 NOT INSIDE (OR MARKS NODMF)
}
 
CHIPB_EN_3_V6 {
@ CHIPB must enclose all chip layout patterns (all chip design, excluding MARKS, NODMF marking layer) if seal ring is inserted by SMIC. DRC waive if the chip has been added seal ring by designer >= 0.45um
@ DRC check layers: AA, AADMP, AR, NW, PSUB, SVT_N, SVT_P, LVT_N, LVT_P, HVT_N, HVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, DG, GT, GTDMP, P2, P2DMP, SN, SP, M0, M0DMP, M0G, M0GDMP, M0C, M0CDMP, DIR, DIRDMP, V0, M1, Vy, Mxy, 1.25xMy, 1.25xVn, 1.25xMn, 2xVn, 2xMn, 10xTVn, 10xTMn, 14xTVn, 14xTMn, UTV, UTM, PA, ALPA, MD, MIM, CTOP
@ DRC only check AA and AADMP enclosure in S/D direction
 err1 = ENC V6 CHIPB < 0.45 ABUT<90 SINGULAR REGION OUTSIDE ALSO
 err1 NOT INSIDE (OR MARKS NODMF)
}
 
CHIPB_EN_3_TV2 {
@ CHIPB must enclose all chip layout patterns (all chip design, excluding MARKS, NODMF marking layer) if seal ring is inserted by SMIC. DRC waive if the chip has been added seal ring by designer >= 0.45um
@ DRC check layers: AA, AADMP, AR, NW, PSUB, SVT_N, SVT_P, LVT_N, LVT_P, HVT_N, HVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, DG, GT, GTDMP, P2, P2DMP, SN, SP, M0, M0DMP, M0G, M0GDMP, M0C, M0CDMP, DIR, DIRDMP, V0, M1, Vy, Mxy, 1.25xMy, 1.25xVn, 1.25xMn, 2xVn, 2xMn, 10xTVn, 10xTMn, 14xTVn, 14xTMn, UTV, UTM, PA, ALPA, MD, MIM, CTOP
@ DRC only check AA and AADMP enclosure in S/D direction
 err1 = ENC TV2 CHIPB < 0.45 ABUT<90 SINGULAR REGION OUTSIDE ALSO
 err1 NOT INSIDE (OR MARKS NODMF)
}

CHIPB_EN_4 {
@ CHIPB enclosure of ALL_AA in GATE poly direction, except INST region = 0.528+0.048*num
@ DRC hints:: Please check the distance between the AA horizontal edge and the CHIPB bottom side
 chk_AA = ALL_AA NOT INSIDE EDGE INST
 chk_AA_side = ALL_AA_h_edges NOT INSIDE EDGE INST
 err1 = ENC chk_AA CHIPB_h_edges < 0.528 ABUT<90 OPPOSITE REGION
 err2 = CHIPB_h_edges NOT OUTSIDE EDGE ALL_AA
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE EDGE SealR_NOT_BULK

 err3 = DFM COPY (OFFGRID chk_AA_side 1 480 INSIDE OF LAYER CHIPB ABSOLUTE) REGION
 err3 NOT INSIDE SealR_NOT_BULK
}

CHIPB_EN_5 {
@ CHIPB ensclosure of FIN in GATE poly direction, except INST region = 0.019+0.048*num
@ DRC hints:: Please check the distance between the FIN horizontal edge and the CHIPB bottom side
 chk_FIN_TMP = FIN NOT INST
 chk_FIN_WAIVE = DFM COPY (DFM SPACE chk_FIN_TMP < FIN_WIDTH BY INT VERTICAL) REGION
 chk_FIN = chk_FIN_TMP NOT chk_FIN_WAIVE
 err1 = ENC chk_FIN CHIPB_h_edges < 0.019 ABUT<90 OPPOSITE REGION EXCLUDE SHIELDED
 err1 NOT INSIDE SealR_NOT_BULK

 OFFGRID chk_FIN 1 480 OFFSET 0 190+50 INSIDE OF LAYER CHIPB ABSOLUTE CENTERS HINT
}

CHIPB_EN_6 {
@ CHIPB enclosure of DNW if seal ring is inserted by SMIC >= 3um
 err1 = ENC DNW CHIPB < 3.0 ABUT<90 SINGULAR REGION OUTSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

CHIPB_EN_7 {
@ CHIPB enclosure of MD if seal ring is inserted by SMIC >= 3um
 err1 = ENC MD CHIPB < 3.0 ABUT<90 SINGULAR REGION OUTSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

CHIPB_EN_8 {
@ CHIPB enclosure of seal ring outer ring outline edge (except seal ring corner stress relief area) if seal ring is inserted by designers >= 0.7um
 met_in_Sring = all_metal_layer AND MARKS
 met_in_Sring_OR_Holes = OR (HOLES met_in_Sring INNER) met_in_Sring
 err1 = ENC met_in_Sring_OR_Holes CHIPB < 0.7 ABUT<90 SINGULAR REGION OUTSIDE ALSO
 err1 NOT INSIDE NODMF
}

CHIPB_R_1 {
@ CELLB must be fully covered by CHIPB
@ Notice: CHIPB must be drawn for CELLB on-grid check
 err1 = CELLB NOT CHIPB
 err1 NOT INSIDE SealR_NOT_BULK
}

CHIPB_R_1a {
@ CHIPB layer (GDS No: 127;3) must be drawn
 err1 = DRC:1 NOT INTERACT CHIPB
 err1 NOT INSIDE SealR_NOT_BULK
}

CHIPB_R_2 {
@ CHIPB must be rectangular and orthogonal to grid
 err1 = NOT RECTANGLE CHIPB ORTHOGONAL ONLY
 err1 NOT INSIDE SealR_NOT_BULK
}

CHIPB_R_3_no_CHIPB {
@ Only one CHIPB is allowed in a chip
@ Notice: CHIPB must be drawn for CELLB on-grid check
//; DRC:1:LOGO = EXTENT DRAWN ORIGINAL IGNORE LOGO
 err1 = BULK NOT INTERACT CHIPB
 err1 NOT INSIDE SealR_NOT_BULK
}

CHIPB_R_3_more_than_2_CHIPB {
@ Only one CHIPB is allowed in a chip
@ Notice: CHIPB must be drawn for CELLB on-grid check
//; DRC:1:LOGO = EXTENT DRAWN ORIGINAL IGNORE LOGO
 err1 = CHIPB INTERACT (DRC:1 INTERACT CHIPB > 1)
 err1 NOT INSIDE SealR_NOT_BULK
}

CHIPB_R_4 {
@ CHIPB edge must be on an integer multiple of 0.010um
 err1 = LENGTH CHIPB < 0.010
 err2 = DFM PROPERTY CHIPB_h_edges CHIPB OVERLAP ABUT ALSO MULTI [-= ABS(REMAINDER((LENGTH(CHIPB_h_edges) - 0.010),0.010))] > 0
 err3 = DFM PROPERTY CHIPB_v_edges CHIPB OVERLAP ABUT ALSO MULTI [-= ABS(REMAINDER((LENGTH(CHIPB_v_edges) - 0.010),0.010))] > 0
 err1 NOT INSIDE EDGE SealR_NOT_BULK
 err2 NOT INSIDE EDGE SealR_NOT_BULK
 err3 NOT INSIDE EDGE SealR_NOT_BULK
}
#ENDIF


// =======================================================
// OCCD design guidelines
// =======================================================
#IFDEF OCCD_RULES_CHECK YES

GROUP GOCCD OCCD_?

OCCD_W_1 {
@ OCCDFH is for FEOL OCCD marker recognition, width and length of OCCDFH = 4.128um
 err1 = OCCDFH NOT RECTANGLE == 4.128 BY == 4.128 ORTHOGONAL ONLY
 err1 NOT INSIDE SealR_NOT_BULK
}

OCCD_W_2_3 {
@ OCCD_W_2: OCCDM1 is for M1 OCCD marker recognition, width and length of OCCDM1 = 4.5um
@ OCCD_W_3: OCCDMn (n = 2~8) is for Mn OCCD marker recognition, width and length of OCCDMn = 4.5um
 err1 = OCCDM1 NOT RECTANGLE == 4.5 BY == 4.5 ORTHOGONAL ONLY
 err2 = OCCDM2 NOT RECTANGLE == 4.5 BY == 4.5 ORTHOGONAL ONLY
 err3 = OCCDM3 NOT RECTANGLE == 4.5 BY == 4.5 ORTHOGONAL ONLY
 err4 = OCCDM4 NOT RECTANGLE == 4.5 BY == 4.5 ORTHOGONAL ONLY
 err5 = OCCDM5 NOT RECTANGLE == 4.5 BY == 4.5 ORTHOGONAL ONLY
 err6 = OCCDM6 NOT RECTANGLE == 4.5 BY == 4.5 ORTHOGONAL ONLY
 err7 = OCCDM7 NOT RECTANGLE == 4.5 BY == 4.5 ORTHOGONAL ONLY
 err8 = OCCDM8 NOT RECTANGLE == 4.5 BY == 4.5 ORTHOGONAL ONLY
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
 err4 NOT INSIDE SealR_NOT_BULK
 err5 NOT INSIDE SealR_NOT_BULK
 err6 NOT INSIDE SealR_NOT_BULK
 err7 NOT INSIDE SealR_NOT_BULK
 err8 NOT INSIDE SealR_NOT_BULK
}

OCCD_W_4 {
@ OCCDBn (n = 1~2) is for Bn OCCD marker recognition, width and length of OCCDBn = 4.5um
 err1 = OCCDB1 NOT RECTANGLE == 4.5 BY == 4.5 ORTHOGONAL ONLY
 err2 = OCCDB2 NOT RECTANGLE == 4.5 BY == 4.5 ORTHOGONAL ONLY
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

OCCD_S_1 {
@ Space between OCCDFH >= 4.5um
 err1 = EXT OCCDFH < 4.5 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

OCCD_S_2_4 {
@ OCCD.S.2: Space between OCCDM1 >= 4.5um
@ OCCD.S.4: Space between OCCDMn (n = 2~8, respectively) >= 4.5um
 err1 = EXT OCCDM1 < 4.5 ABUT<90 SINGULAR REGION
 err2 = EXT OCCDM2 < 4.5 ABUT<90 SINGULAR REGION
 err3 = EXT OCCDM3 < 4.5 ABUT<90 SINGULAR REGION
 err4 = EXT OCCDM4 < 4.5 ABUT<90 SINGULAR REGION
 err5 = EXT OCCDM5 < 4.5 ABUT<90 SINGULAR REGION
 err6 = EXT OCCDM6 < 4.5 ABUT<90 SINGULAR REGION
 err7 = EXT OCCDM7 < 4.5 ABUT<90 SINGULAR REGION
 err8 = EXT OCCDM8 < 4.5 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
 err4 NOT INSIDE SealR_NOT_BULK
 err5 NOT INSIDE SealR_NOT_BULK
 err6 NOT INSIDE SealR_NOT_BULK
 err7 NOT INSIDE SealR_NOT_BULK
 err8 NOT INSIDE SealR_NOT_BULK
}

OCCD_S_3 {
@ Space between OCCDFH and OCCDM1 >= 4.5um
 err1 = EXT OCCDFH OCCDM1 < 4.5 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

OCCD_S_5 {
@ Space between OCCDBn (n = 1~2, respectively) >= 4.5um
 err1 = EXT OCCDB1 < 4.5 ABUT<90 SINGULAR REGION
 err2 = EXT OCCDB2 < 4.5 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

OCCD_S_6_R {
@ Recommended space between OCCDFH >= 140um
 err1 = EXT OCCDFH < 140 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

OCCD_S_7_8_9_R {
@ OCCD.S.7: Recommended space between OCCDM1 >= 140um
@ OCCD.S.8: Recommended space between OCCDMn (n = 2~8, respectively) >= 140um
@ OCCD.S.9: Recommended space between OCCDBn (n = 1~2, respectively) >= 140um
 err1 = EXT OCCDM1 < 140 ABUT<90 SINGULAR REGION
 err2 = EXT OCCDM2 < 140 ABUT<90 SINGULAR REGION
 err3 = EXT OCCDM3 < 140 ABUT<90 SINGULAR REGION
 err4 = EXT OCCDM4 < 140 ABUT<90 SINGULAR REGION
 err5 = EXT OCCDM5 < 140 ABUT<90 SINGULAR REGION
 err6 = EXT OCCDM6 < 140 ABUT<90 SINGULAR REGION
 err7 = EXT OCCDM7 < 140 ABUT<90 SINGULAR REGION
 err8 = EXT OCCDM8 < 140 ABUT<90 SINGULAR REGION
 err9 = EXT OCCDB1 < 140 ABUT<90 SINGULAR REGION
 err0 = EXT OCCDB2 < 140 ABUT<90 SINGULAR REGION

 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
 err4 NOT INSIDE SealR_NOT_BULK
 err5 NOT INSIDE SealR_NOT_BULK
 err6 NOT INSIDE SealR_NOT_BULK
 err7 NOT INSIDE SealR_NOT_BULK
 err8 NOT INSIDE SealR_NOT_BULK
 err9 NOT INSIDE SealR_NOT_BULK
 err0 NOT INSIDE SealR_NOT_BULK
}
 
OCCD_S_10_DNW {
@ Space between OCCDFH and DNW, NW, PSUB, AA, AR, GT, GT_P96, P2, SN, SP, DG, M0, M0G, M0C, V0, M1, LOGO, INST, MARKS, MARKG, NODMF, OCOVL, DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, V0DUB, M1DUB, EFUSE, RESNW, RESP1, RESP2, ESDIO2, DSTR, DIOMK2, DMPNP, VARMOS, LDBK, INDMY, FUSEMK1, NPAA, PPAA, AR_H, AR_V, DIOMK1, ESDIO1, SVT_N edge, SVT_P edge, HVT_N edge, HVT_P edge, LVT_N edge, LVT_P edge, ULVT_N edge, ULVT_P edge, LFN_N edge, LFN_P edge, MTFUSE, CTOP >= 1.8um
 err1 = EXT OCCDFH DNW < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCCD_S_10_NW {
@ Space between OCCDFH and DNW, NW, PSUB, AA, AR, GT, GT_P96, P2, SN, SP, DG, M0, M0G, M0C, V0, M1, LOGO, INST, MARKS, MARKG, NODMF, OCOVL, DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, V0DUB, M1DUB, EFUSE, RESNW, RESP1, RESP2, ESDIO2, DSTR, DIOMK2, DMPNP, VARMOS, LDBK, INDMY, FUSEMK1, NPAA, PPAA, AR_H, AR_V, DIOMK1, ESDIO1, SVT_N edge, SVT_P edge, HVT_N edge, HVT_P edge, LVT_N edge, LVT_P edge, ULVT_N edge, ULVT_P edge, LFN_N edge, LFN_P edge, MTFUSE, CTOP >= 1.8um
 err1 = EXT OCCDFH NW < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCCD_S_10_PSUB {
@ Space between OCCDFH and DNW, NW, PSUB, AA, AR, GT, GT_P96, P2, SN, SP, DG, M0, M0G, M0C, V0, M1, LOGO, INST, MARKS, MARKG, NODMF, OCOVL, DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, V0DUB, M1DUB, EFUSE, RESNW, RESP1, RESP2, ESDIO2, DSTR, DIOMK2, DMPNP, VARMOS, LDBK, INDMY, FUSEMK1, NPAA, PPAA, AR_H, AR_V, DIOMK1, ESDIO1, SVT_N edge, SVT_P edge, HVT_N edge, HVT_P edge, LVT_N edge, LVT_P edge, ULVT_N edge, ULVT_P edge, LFN_N edge, LFN_P edge, MTFUSE, CTOP >= 1.8um
 err1 = EXT OCCDFH PSUB < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCCD_S_10_AA {
@ Space between OCCDFH and DNW, NW, PSUB, AA, AR, GT, GT_P96, P2, SN, SP, DG, M0, M0G, M0C, V0, M1, LOGO, INST, MARKS, MARKG, NODMF, OCOVL, DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, V0DUB, M1DUB, EFUSE, RESNW, RESP1, RESP2, ESDIO2, DSTR, DIOMK2, DMPNP, VARMOS, LDBK, INDMY, FUSEMK1, NPAA, PPAA, AR_H, AR_V, DIOMK1, ESDIO1, SVT_N edge, SVT_P edge, HVT_N edge, HVT_P edge, LVT_N edge, LVT_P edge, ULVT_N edge, ULVT_P edge, LFN_N edge, LFN_P edge, MTFUSE, CTOP >= 1.8um
 err1 = EXT OCCDFH AA < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCCD_S_10_AR {
@ Space between OCCDFH and DNW, NW, PSUB, AA, AR, GT, GT_P96, P2, SN, SP, DG, M0, M0G, M0C, V0, M1, LOGO, INST, MARKS, MARKG, NODMF, OCOVL, DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, V0DUB, M1DUB, EFUSE, RESNW, RESP1, RESP2, ESDIO2, DSTR, DIOMK2, DMPNP, VARMOS, LDBK, INDMY, FUSEMK1, NPAA, PPAA, AR_H, AR_V, DIOMK1, ESDIO1, SVT_N edge, SVT_P edge, HVT_N edge, HVT_P edge, LVT_N edge, LVT_P edge, ULVT_N edge, ULVT_P edge, LFN_N edge, LFN_P edge, MTFUSE, CTOP >= 1.8um
 err1 = EXT OCCDFH AR < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCCD_S_10_GT {
@ Space between OCCDFH and DNW, NW, PSUB, AA, AR, GT, GT_P96, P2, SN, SP, DG, M0, M0G, M0C, V0, M1, LOGO, INST, MARKS, MARKG, NODMF, OCOVL, DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, V0DUB, M1DUB, EFUSE, RESNW, RESP1, RESP2, ESDIO2, DSTR, DIOMK2, DMPNP, VARMOS, LDBK, INDMY, FUSEMK1, NPAA, PPAA, AR_H, AR_V, DIOMK1, ESDIO1, SVT_N edge, SVT_P edge, HVT_N edge, HVT_P edge, LVT_N edge, LVT_P edge, ULVT_N edge, ULVT_P edge, LFN_N edge, LFN_P edge, MTFUSE, CTOP >= 1.8um
 err1 = EXT OCCDFH GT < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCCD_S_10_GT_P96 {
@ Space between OCCDFH and DNW, NW, PSUB, AA, AR, GT, GT_P96, P2, SN, SP, DG, M0, M0G, M0C, V0, M1, LOGO, INST, MARKS, MARKG, NODMF, OCOVL, DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, V0DUB, M1DUB, EFUSE, RESNW, RESP1, RESP2, ESDIO2, DSTR, DIOMK2, DMPNP, VARMOS, LDBK, INDMY, FUSEMK1, NPAA, PPAA, AR_H, AR_V, DIOMK1, ESDIO1, SVT_N edge, SVT_P edge, HVT_N edge, HVT_P edge, LVT_N edge, LVT_P edge, ULVT_N edge, ULVT_P edge, LFN_N edge, LFN_P edge, MTFUSE, CTOP >= 1.8um
 err1 = EXT OCCDFH GT_P96 < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCCD_S_10_P2 {
@ Space between OCCDFH and DNW, NW, PSUB, AA, AR, GT, GT_P96, P2, SN, SP, DG, M0, M0G, M0C, V0, M1, LOGO, INST, MARKS, MARKG, NODMF, OCOVL, DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, V0DUB, M1DUB, EFUSE, RESNW, RESP1, RESP2, ESDIO2, DSTR, DIOMK2, DMPNP, VARMOS, LDBK, INDMY, FUSEMK1, NPAA, PPAA, AR_H, AR_V, DIOMK1, ESDIO1, SVT_N edge, SVT_P edge, HVT_N edge, HVT_P edge, LVT_N edge, LVT_P edge, ULVT_N edge, ULVT_P edge, LFN_N edge, LFN_P edge, MTFUSE, CTOP >= 1.8um
 err1 = EXT OCCDFH P2 < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCCD_S_10_SN {
@ Space between OCCDFH and DNW, NW, PSUB, AA, AR, GT, GT_P96, P2, SN, SP, DG, M0, M0G, M0C, V0, M1, LOGO, INST, MARKS, MARKG, NODMF, OCOVL, DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, V0DUB, M1DUB, EFUSE, RESNW, RESP1, RESP2, ESDIO2, DSTR, DIOMK2, DMPNP, VARMOS, LDBK, INDMY, FUSEMK1, NPAA, PPAA, AR_H, AR_V, DIOMK1, ESDIO1, SVT_N edge, SVT_P edge, HVT_N edge, HVT_P edge, LVT_N edge, LVT_P edge, ULVT_N edge, ULVT_P edge, LFN_N edge, LFN_P edge, MTFUSE, CTOP >= 1.8um
 err1 = EXT OCCDFH SN < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCCD_S_10_SP {
@ Space between OCCDFH and DNW, NW, PSUB, AA, AR, GT, GT_P96, P2, SN, SP, DG, M0, M0G, M0C, V0, M1, LOGO, INST, MARKS, MARKG, NODMF, OCOVL, DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, V0DUB, M1DUB, EFUSE, RESNW, RESP1, RESP2, ESDIO2, DSTR, DIOMK2, DMPNP, VARMOS, LDBK, INDMY, FUSEMK1, NPAA, PPAA, AR_H, AR_V, DIOMK1, ESDIO1, SVT_N edge, SVT_P edge, HVT_N edge, HVT_P edge, LVT_N edge, LVT_P edge, ULVT_N edge, ULVT_P edge, LFN_N edge, LFN_P edge, MTFUSE, CTOP >= 1.8um
 err1 = EXT OCCDFH SP < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCCD_S_10_DG {
@ Space between OCCDFH and DNW, NW, PSUB, AA, AR, GT, GT_P96, P2, SN, SP, DG, M0, M0G, M0C, V0, M1, LOGO, INST, MARKS, MARKG, NODMF, OCOVL, DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, V0DUB, M1DUB, EFUSE, RESNW, RESP1, RESP2, ESDIO2, DSTR, DIOMK2, DMPNP, VARMOS, LDBK, INDMY, FUSEMK1, NPAA, PPAA, AR_H, AR_V, DIOMK1, ESDIO1, SVT_N edge, SVT_P edge, HVT_N edge, HVT_P edge, LVT_N edge, LVT_P edge, ULVT_N edge, ULVT_P edge, LFN_N edge, LFN_P edge, MTFUSE, CTOP >= 1.8um
 err1 = EXT OCCDFH DG < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCCD_S_10_M0 {
@ Space between OCCDFH and DNW, NW, PSUB, AA, AR, GT, GT_P96, P2, SN, SP, DG, M0, M0G, M0C, V0, M1, LOGO, INST, MARKS, MARKG, NODMF, OCOVL, DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, V0DUB, M1DUB, EFUSE, RESNW, RESP1, RESP2, ESDIO2, DSTR, DIOMK2, DMPNP, VARMOS, LDBK, INDMY, FUSEMK1, NPAA, PPAA, AR_H, AR_V, DIOMK1, ESDIO1, SVT_N edge, SVT_P edge, HVT_N edge, HVT_P edge, LVT_N edge, LVT_P edge, ULVT_N edge, ULVT_P edge, LFN_N edge, LFN_P edge, MTFUSE, CTOP >= 1.8um
 err1 = EXT OCCDFH M0 < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCCD_S_10_M0G {
@ Space between OCCDFH and DNW, NW, PSUB, AA, AR, GT, GT_P96, P2, SN, SP, DG, M0, M0G, M0C, V0, M1, LOGO, INST, MARKS, MARKG, NODMF, OCOVL, DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, V0DUB, M1DUB, EFUSE, RESNW, RESP1, RESP2, ESDIO2, DSTR, DIOMK2, DMPNP, VARMOS, LDBK, INDMY, FUSEMK1, NPAA, PPAA, AR_H, AR_V, DIOMK1, ESDIO1, SVT_N edge, SVT_P edge, HVT_N edge, HVT_P edge, LVT_N edge, LVT_P edge, ULVT_N edge, ULVT_P edge, LFN_N edge, LFN_P edge, MTFUSE, CTOP >= 1.8um
 err1 = EXT OCCDFH M0G < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCCD_S_10_M0C {
@ Space between OCCDFH and DNW, NW, PSUB, AA, AR, GT, GT_P96, P2, SN, SP, DG, M0, M0G, M0C, V0, M1, LOGO, INST, MARKS, MARKG, NODMF, OCOVL, DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, V0DUB, M1DUB, EFUSE, RESNW, RESP1, RESP2, ESDIO2, DSTR, DIOMK2, DMPNP, VARMOS, LDBK, INDMY, FUSEMK1, NPAA, PPAA, AR_H, AR_V, DIOMK1, ESDIO1, SVT_N edge, SVT_P edge, HVT_N edge, HVT_P edge, LVT_N edge, LVT_P edge, ULVT_N edge, ULVT_P edge, LFN_N edge, LFN_P edge, MTFUSE, CTOP >= 1.8um
 err1 = EXT OCCDFH M0C < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCCD_S_10_V0 {
@ Space between OCCDFH and DNW, NW, PSUB, AA, AR, GT, GT_P96, P2, SN, SP, DG, M0, M0G, M0C, V0, M1, LOGO, INST, MARKS, MARKG, NODMF, OCOVL, DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, V0DUB, M1DUB, EFUSE, RESNW, RESP1, RESP2, ESDIO2, DSTR, DIOMK2, DMPNP, VARMOS, LDBK, INDMY, FUSEMK1, NPAA, PPAA, AR_H, AR_V, DIOMK1, ESDIO1, SVT_N edge, SVT_P edge, HVT_N edge, HVT_P edge, LVT_N edge, LVT_P edge, ULVT_N edge, ULVT_P edge, LFN_N edge, LFN_P edge, MTFUSE, CTOP >= 1.8um
 err1 = EXT OCCDFH V0 < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCCD_S_10_M1 {
@ Space between OCCDFH and DNW, NW, PSUB, AA, AR, GT, GT_P96, P2, SN, SP, DG, M0, M0G, M0C, V0, M1, LOGO, INST, MARKS, MARKG, NODMF, OCOVL, DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, V0DUB, M1DUB, EFUSE, RESNW, RESP1, RESP2, ESDIO2, DSTR, DIOMK2, DMPNP, VARMOS, LDBK, INDMY, FUSEMK1, NPAA, PPAA, AR_H, AR_V, DIOMK1, ESDIO1, SVT_N edge, SVT_P edge, HVT_N edge, HVT_P edge, LVT_N edge, LVT_P edge, ULVT_N edge, ULVT_P edge, LFN_N edge, LFN_P edge, MTFUSE, CTOP >= 1.8um
 err1 = EXT OCCDFH M1 < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCCD_S_10_LOGO {
@ Space between OCCDFH and DNW, NW, PSUB, AA, AR, GT, GT_P96, P2, SN, SP, DG, M0, M0G, M0C, V0, M1, LOGO, INST, MARKS, MARKG, NODMF, OCOVL, DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, V0DUB, M1DUB, EFUSE, RESNW, RESP1, RESP2, ESDIO2, DSTR, DIOMK2, DMPNP, VARMOS, LDBK, INDMY, FUSEMK1, NPAA, PPAA, AR_H, AR_V, DIOMK1, ESDIO1, SVT_N edge, SVT_P edge, HVT_N edge, HVT_P edge, LVT_N edge, LVT_P edge, ULVT_N edge, ULVT_P edge, LFN_N edge, LFN_P edge, MTFUSE, CTOP >= 1.8um
 err1 = EXT OCCDFH LOGO < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCCD_S_10_INST {
@ Space between OCCDFH and DNW, NW, PSUB, AA, AR, GT, GT_P96, P2, SN, SP, DG, M0, M0G, M0C, V0, M1, LOGO, INST, MARKS, MARKG, NODMF, OCOVL, DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, V0DUB, M1DUB, EFUSE, RESNW, RESP1, RESP2, ESDIO2, DSTR, DIOMK2, DMPNP, VARMOS, LDBK, INDMY, FUSEMK1, NPAA, PPAA, AR_H, AR_V, DIOMK1, ESDIO1, SVT_N edge, SVT_P edge, HVT_N edge, HVT_P edge, LVT_N edge, LVT_P edge, ULVT_N edge, ULVT_P edge, LFN_N edge, LFN_P edge, MTFUSE, CTOP >= 1.8um
 err1 = EXT OCCDFH INST < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCCD_S_10_MARKS {
@ Space between OCCDFH and DNW, NW, PSUB, AA, AR, GT, GT_P96, P2, SN, SP, DG, M0, M0G, M0C, V0, M1, LOGO, INST, MARKS, MARKG, NODMF, OCOVL, DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, V0DUB, M1DUB, EFUSE, RESNW, RESP1, RESP2, ESDIO2, DSTR, DIOMK2, DMPNP, VARMOS, LDBK, INDMY, FUSEMK1, NPAA, PPAA, AR_H, AR_V, DIOMK1, ESDIO1, SVT_N edge, SVT_P edge, HVT_N edge, HVT_P edge, LVT_N edge, LVT_P edge, ULVT_N edge, ULVT_P edge, LFN_N edge, LFN_P edge, MTFUSE, CTOP >= 1.8um
 err1 = EXT OCCDFH MARKS < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCCD_S_10_MARKG {
@ Space between OCCDFH and DNW, NW, PSUB, AA, AR, GT, GT_P96, P2, SN, SP, DG, M0, M0G, M0C, V0, M1, LOGO, INST, MARKS, MARKG, NODMF, OCOVL, DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, V0DUB, M1DUB, EFUSE, RESNW, RESP1, RESP2, ESDIO2, DSTR, DIOMK2, DMPNP, VARMOS, LDBK, INDMY, FUSEMK1, NPAA, PPAA, AR_H, AR_V, DIOMK1, ESDIO1, SVT_N edge, SVT_P edge, HVT_N edge, HVT_P edge, LVT_N edge, LVT_P edge, ULVT_N edge, ULVT_P edge, LFN_N edge, LFN_P edge, MTFUSE, CTOP >= 1.8um
 err1 = EXT OCCDFH MARKG < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCCD_S_10_NODMF {
@ Space between OCCDFH and DNW, NW, PSUB, AA, AR, GT, GT_P96, P2, SN, SP, DG, M0, M0G, M0C, V0, M1, LOGO, INST, MARKS, MARKG, NODMF, OCOVL, DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, V0DUB, M1DUB, EFUSE, RESNW, RESP1, RESP2, ESDIO2, DSTR, DIOMK2, DMPNP, VARMOS, LDBK, INDMY, FUSEMK1, NPAA, PPAA, AR_H, AR_V, DIOMK1, ESDIO1, SVT_N edge, SVT_P edge, HVT_N edge, HVT_P edge, LVT_N edge, LVT_P edge, ULVT_N edge, ULVT_P edge, LFN_N edge, LFN_P edge, MTFUSE, CTOP >= 1.8um
 err1 = EXT OCCDFH NODMF < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCCD_S_10_OCOVL {
@ Space between OCCDFH and DNW, NW, PSUB, AA, AR, GT, GT_P96, P2, SN, SP, DG, M0, M0G, M0C, V0, M1, LOGO, INST, MARKS, MARKG, NODMF, OCOVL, DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, V0DUB, M1DUB, EFUSE, RESNW, RESP1, RESP2, ESDIO2, DSTR, DIOMK2, DMPNP, VARMOS, LDBK, INDMY, FUSEMK1, NPAA, PPAA, AR_H, AR_V, DIOMK1, ESDIO1, SVT_N edge, SVT_P edge, HVT_N edge, HVT_P edge, LVT_N edge, LVT_P edge, ULVT_N edge, ULVT_P edge, LFN_N edge, LFN_P edge, MTFUSE, CTOP >= 1.8um
 err1 = EXT OCCDFH OCOVL < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCCD_S_10_DUMBA {
@ Space between OCCDFH and DNW, NW, PSUB, AA, AR, GT, GT_P96, P2, SN, SP, DG, M0, M0G, M0C, V0, M1, LOGO, INST, MARKS, MARKG, NODMF, OCOVL, DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, V0DUB, M1DUB, EFUSE, RESNW, RESP1, RESP2, ESDIO2, DSTR, DIOMK2, DMPNP, VARMOS, LDBK, INDMY, FUSEMK1, NPAA, PPAA, AR_H, AR_V, DIOMK1, ESDIO1, SVT_N edge, SVT_P edge, HVT_N edge, HVT_P edge, LVT_N edge, LVT_P edge, ULVT_N edge, ULVT_P edge, LFN_N edge, LFN_P edge, MTFUSE, CTOP >= 1.8um
 err1 = EXT OCCDFH DUMBA < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCCD_S_10_DUMBP {
@ Space between OCCDFH and DNW, NW, PSUB, AA, AR, GT, GT_P96, P2, SN, SP, DG, M0, M0G, M0C, V0, M1, LOGO, INST, MARKS, MARKG, NODMF, OCOVL, DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, V0DUB, M1DUB, EFUSE, RESNW, RESP1, RESP2, ESDIO2, DSTR, DIOMK2, DMPNP, VARMOS, LDBK, INDMY, FUSEMK1, NPAA, PPAA, AR_H, AR_V, DIOMK1, ESDIO1, SVT_N edge, SVT_P edge, HVT_N edge, HVT_P edge, LVT_N edge, LVT_P edge, ULVT_N edge, ULVT_P edge, LFN_N edge, LFN_P edge, MTFUSE, CTOP >= 1.8um
 err1 = EXT OCCDFH DUMBP < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCCD_S_10_ARDUB {
@ Space between OCCDFH and DNW, NW, PSUB, AA, AR, GT, GT_P96, P2, SN, SP, DG, M0, M0G, M0C, V0, M1, LOGO, INST, MARKS, MARKG, NODMF, OCOVL, DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, V0DUB, M1DUB, EFUSE, RESNW, RESP1, RESP2, ESDIO2, DSTR, DIOMK2, DMPNP, VARMOS, LDBK, INDMY, FUSEMK1, NPAA, PPAA, AR_H, AR_V, DIOMK1, ESDIO1, SVT_N edge, SVT_P edge, HVT_N edge, HVT_P edge, LVT_N edge, LVT_P edge, ULVT_N edge, ULVT_P edge, LFN_N edge, LFN_P edge, MTFUSE, CTOP >= 1.8um
 err1 = EXT OCCDFH ARDUB < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCCD_S_10_P2DUB {
@ Space between OCCDFH and DNW, NW, PSUB, AA, AR, GT, GT_P96, P2, SN, SP, DG, M0, M0G, M0C, V0, M1, LOGO, INST, MARKS, MARKG, NODMF, OCOVL, DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, V0DUB, M1DUB, EFUSE, RESNW, RESP1, RESP2, ESDIO2, DSTR, DIOMK2, DMPNP, VARMOS, LDBK, INDMY, FUSEMK1, NPAA, PPAA, AR_H, AR_V, DIOMK1, ESDIO1, SVT_N edge, SVT_P edge, HVT_N edge, HVT_P edge, LVT_N edge, LVT_P edge, ULVT_N edge, ULVT_P edge, LFN_N edge, LFN_P edge, MTFUSE, CTOP >= 1.8um
 err1 = EXT OCCDFH P2DUB < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCCD_S_10_M0DUB {
@ Space between OCCDFH and DNW, NW, PSUB, AA, AR, GT, GT_P96, P2, SN, SP, DG, M0, M0G, M0C, V0, M1, LOGO, INST, MARKS, MARKG, NODMF, OCOVL, DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, V0DUB, M1DUB, EFUSE, RESNW, RESP1, RESP2, ESDIO2, DSTR, DIOMK2, DMPNP, VARMOS, LDBK, INDMY, FUSEMK1, NPAA, PPAA, AR_H, AR_V, DIOMK1, ESDIO1, SVT_N edge, SVT_P edge, HVT_N edge, HVT_P edge, LVT_N edge, LVT_P edge, ULVT_N edge, ULVT_P edge, LFN_N edge, LFN_P edge, MTFUSE, CTOP >= 1.8um
 err1 = EXT OCCDFH M0DUB < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCCD_S_10_M0CDUB {
@ Space between OCCDFH and DNW, NW, PSUB, AA, AR, GT, GT_P96, P2, SN, SP, DG, M0, M0G, M0C, V0, M1, LOGO, INST, MARKS, MARKG, NODMF, OCOVL, DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, V0DUB, M1DUB, EFUSE, RESNW, RESP1, RESP2, ESDIO2, DSTR, DIOMK2, DMPNP, VARMOS, LDBK, INDMY, FUSEMK1, NPAA, PPAA, AR_H, AR_V, DIOMK1, ESDIO1, SVT_N edge, SVT_P edge, HVT_N edge, HVT_P edge, LVT_N edge, LVT_P edge, ULVT_N edge, ULVT_P edge, LFN_N edge, LFN_P edge, MTFUSE, CTOP >= 1.8um
 err1 = EXT OCCDFH M0CDUB < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCCD_S_10_M0GDUB {
@ Space between OCCDFH and DNW, NW, PSUB, AA, AR, GT, GT_P96, P2, SN, SP, DG, M0, M0G, M0C, V0, M1, LOGO, INST, MARKS, MARKG, NODMF, OCOVL, DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, V0DUB, M1DUB, EFUSE, RESNW, RESP1, RESP2, ESDIO2, DSTR, DIOMK2, DMPNP, VARMOS, LDBK, INDMY, FUSEMK1, NPAA, PPAA, AR_H, AR_V, DIOMK1, ESDIO1, SVT_N edge, SVT_P edge, HVT_N edge, HVT_P edge, LVT_N edge, LVT_P edge, ULVT_N edge, ULVT_P edge, LFN_N edge, LFN_P edge, MTFUSE, CTOP >= 1.8um
 err1 = EXT OCCDFH M0GDUB < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCCD_S_10_V0DUB {
@ Space between OCCDFH and DNW, NW, PSUB, AA, AR, GT, GT_P96, P2, SN, SP, DG, M0, M0G, M0C, V0, M1, LOGO, INST, MARKS, MARKG, NODMF, OCOVL, DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, V0DUB, M1DUB, EFUSE, RESNW, RESP1, RESP2, ESDIO2, DSTR, DIOMK2, DMPNP, VARMOS, LDBK, INDMY, FUSEMK1, NPAA, PPAA, AR_H, AR_V, DIOMK1, ESDIO1, SVT_N edge, SVT_P edge, HVT_N edge, HVT_P edge, LVT_N edge, LVT_P edge, ULVT_N edge, ULVT_P edge, LFN_N edge, LFN_P edge, MTFUSE, CTOP >= 1.8um
 err1 = EXT OCCDFH V0DUB < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCCD_S_10_M1DUB {
@ Space between OCCDFH and DNW, NW, PSUB, AA, AR, GT, GT_P96, P2, SN, SP, DG, M0, M0G, M0C, V0, M1, LOGO, INST, MARKS, MARKG, NODMF, OCOVL, DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, V0DUB, M1DUB, EFUSE, RESNW, RESP1, RESP2, ESDIO2, DSTR, DIOMK2, DMPNP, VARMOS, LDBK, INDMY, FUSEMK1, NPAA, PPAA, AR_H, AR_V, DIOMK1, ESDIO1, SVT_N edge, SVT_P edge, HVT_N edge, HVT_P edge, LVT_N edge, LVT_P edge, ULVT_N edge, ULVT_P edge, LFN_N edge, LFN_P edge, MTFUSE, CTOP >= 1.8um
 err1 = EXT OCCDFH M1DUB < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCCD_S_10_EFUSE {
@ Space between OCCDFH and DNW, NW, PSUB, AA, AR, GT, GT_P96, P2, SN, SP, DG, M0, M0G, M0C, V0, M1, LOGO, INST, MARKS, MARKG, NODMF, OCOVL, DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, V0DUB, M1DUB, EFUSE, RESNW, RESP1, RESP2, ESDIO2, DSTR, DIOMK2, DMPNP, VARMOS, LDBK, INDMY, FUSEMK1, NPAA, PPAA, AR_H, AR_V, DIOMK1, ESDIO1, SVT_N edge, SVT_P edge, HVT_N edge, HVT_P edge, LVT_N edge, LVT_P edge, ULVT_N edge, ULVT_P edge, LFN_N edge, LFN_P edge, MTFUSE, CTOP >= 1.8um
 err1 = EXT OCCDFH EFUSE < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCCD_S_10_RESNW {
@ Space between OCCDFH and DNW, NW, PSUB, AA, AR, GT, GT_P96, P2, SN, SP, DG, M0, M0G, M0C, V0, M1, LOGO, INST, MARKS, MARKG, NODMF, OCOVL, DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, V0DUB, M1DUB, EFUSE, RESNW, RESP1, RESP2, ESDIO2, DSTR, DIOMK2, DMPNP, VARMOS, LDBK, INDMY, FUSEMK1, NPAA, PPAA, AR_H, AR_V, DIOMK1, ESDIO1, SVT_N edge, SVT_P edge, HVT_N edge, HVT_P edge, LVT_N edge, LVT_P edge, ULVT_N edge, ULVT_P edge, LFN_N edge, LFN_P edge, MTFUSE, CTOP >= 1.8um
 err1 = EXT OCCDFH RESNW < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCCD_S_10_RESP1 {
@ Space between OCCDFH and DNW, NW, PSUB, AA, AR, GT, GT_P96, P2, SN, SP, DG, M0, M0G, M0C, V0, M1, LOGO, INST, MARKS, MARKG, NODMF, OCOVL, DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, V0DUB, M1DUB, EFUSE, RESNW, RESP1, RESP2, ESDIO2, DSTR, DIOMK2, DMPNP, VARMOS, LDBK, INDMY, FUSEMK1, NPAA, PPAA, AR_H, AR_V, DIOMK1, ESDIO1, SVT_N edge, SVT_P edge, HVT_N edge, HVT_P edge, LVT_N edge, LVT_P edge, ULVT_N edge, ULVT_P edge, LFN_N edge, LFN_P edge, MTFUSE, CTOP >= 1.8um
 err1 = EXT OCCDFH RESP1 < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCCD_S_10_RESP2 {
@ Space between OCCDFH and DNW, NW, PSUB, AA, AR, GT, GT_P96, P2, SN, SP, DG, M0, M0G, M0C, V0, M1, LOGO, INST, MARKS, MARKG, NODMF, OCOVL, DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, V0DUB, M1DUB, EFUSE, RESNW, RESP1, RESP2, ESDIO2, DSTR, DIOMK2, DMPNP, VARMOS, LDBK, INDMY, FUSEMK1, NPAA, PPAA, AR_H, AR_V, DIOMK1, ESDIO1, SVT_N edge, SVT_P edge, HVT_N edge, HVT_P edge, LVT_N edge, LVT_P edge, ULVT_N edge, ULVT_P edge, LFN_N edge, LFN_P edge, MTFUSE, CTOP >= 1.8um
 err1 = EXT OCCDFH RESP2 < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCCD_S_10_ESDIO2 {
@ Space between OCCDFH and DNW, NW, PSUB, AA, AR, GT, GT_P96, P2, SN, SP, DG, M0, M0G, M0C, V0, M1, LOGO, INST, MARKS, MARKG, NODMF, OCOVL, DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, V0DUB, M1DUB, EFUSE, RESNW, RESP1, RESP2, ESDIO2, DSTR, DIOMK2, DMPNP, VARMOS, LDBK, INDMY, FUSEMK1, NPAA, PPAA, AR_H, AR_V, DIOMK1, ESDIO1, SVT_N edge, SVT_P edge, HVT_N edge, HVT_P edge, LVT_N edge, LVT_P edge, ULVT_N edge, ULVT_P edge, LFN_N edge, LFN_P edge, MTFUSE, CTOP >= 1.8um
 err1 = EXT OCCDFH ESDIO2 < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCCD_S_10_DSTR {
@ Space between OCCDFH and DNW, NW, PSUB, AA, AR, GT, GT_P96, P2, SN, SP, DG, M0, M0G, M0C, V0, M1, LOGO, INST, MARKS, MARKG, NODMF, OCOVL, DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, V0DUB, M1DUB, EFUSE, RESNW, RESP1, RESP2, ESDIO2, DSTR, DIOMK2, DMPNP, VARMOS, LDBK, INDMY, FUSEMK1, NPAA, PPAA, AR_H, AR_V, DIOMK1, ESDIO1, SVT_N edge, SVT_P edge, HVT_N edge, HVT_P edge, LVT_N edge, LVT_P edge, ULVT_N edge, ULVT_P edge, LFN_N edge, LFN_P edge, MTFUSE, CTOP >= 1.8um
 err1 = EXT OCCDFH DSTR < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCCD_S_10_DIOMK2 {
@ Space between OCCDFH and DNW, NW, PSUB, AA, AR, GT, GT_P96, P2, SN, SP, DG, M0, M0G, M0C, V0, M1, LOGO, INST, MARKS, MARKG, NODMF, OCOVL, DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, V0DUB, M1DUB, EFUSE, RESNW, RESP1, RESP2, ESDIO2, DSTR, DIOMK2, DMPNP, VARMOS, LDBK, INDMY, FUSEMK1, NPAA, PPAA, AR_H, AR_V, DIOMK1, ESDIO1, SVT_N edge, SVT_P edge, HVT_N edge, HVT_P edge, LVT_N edge, LVT_P edge, ULVT_N edge, ULVT_P edge, LFN_N edge, LFN_P edge, MTFUSE, CTOP >= 1.8um
 err1 = EXT OCCDFH DIOMK2 < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCCD_S_10_DMPNP {
@ Space between OCCDFH and DNW, NW, PSUB, AA, AR, GT, GT_P96, P2, SN, SP, DG, M0, M0G, M0C, V0, M1, LOGO, INST, MARKS, MARKG, NODMF, OCOVL, DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, V0DUB, M1DUB, EFUSE, RESNW, RESP1, RESP2, ESDIO2, DSTR, DIOMK2, DMPNP, VARMOS, LDBK, INDMY, FUSEMK1, NPAA, PPAA, AR_H, AR_V, DIOMK1, ESDIO1, SVT_N edge, SVT_P edge, HVT_N edge, HVT_P edge, LVT_N edge, LVT_P edge, ULVT_N edge, ULVT_P edge, LFN_N edge, LFN_P edge, MTFUSE, CTOP >= 1.8um
 err1 = EXT OCCDFH DMPNP < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCCD_S_10_VARMOS {
@ Space between OCCDFH and DNW, NW, PSUB, AA, AR, GT, GT_P96, P2, SN, SP, DG, M0, M0G, M0C, V0, M1, LOGO, INST, MARKS, MARKG, NODMF, OCOVL, DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, V0DUB, M1DUB, EFUSE, RESNW, RESP1, RESP2, ESDIO2, DSTR, DIOMK2, DMPNP, VARMOS, LDBK, INDMY, FUSEMK1, NPAA, PPAA, AR_H, AR_V, DIOMK1, ESDIO1, SVT_N edge, SVT_P edge, HVT_N edge, HVT_P edge, LVT_N edge, LVT_P edge, ULVT_N edge, ULVT_P edge, LFN_N edge, LFN_P edge, MTFUSE, CTOP >= 1.8um
 err1 = EXT OCCDFH VARMOS < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCCD_S_10_LDBK {
@ Space between OCCDFH and DNW, NW, PSUB, AA, AR, GT, GT_P96, P2, SN, SP, DG, M0, M0G, M0C, V0, M1, LOGO, INST, MARKS, MARKG, NODMF, OCOVL, DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, V0DUB, M1DUB, EFUSE, RESNW, RESP1, RESP2, ESDIO2, DSTR, DIOMK2, DMPNP, VARMOS, LDBK, INDMY, FUSEMK1, NPAA, PPAA, AR_H, AR_V, DIOMK1, ESDIO1, SVT_N edge, SVT_P edge, HVT_N edge, HVT_P edge, LVT_N edge, LVT_P edge, ULVT_N edge, ULVT_P edge, LFN_N edge, LFN_P edge, MTFUSE, CTOP >= 1.8um
 err1 = EXT OCCDFH LDBK < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCCD_S_10_INDMY {
@ Space between OCCDFH and DNW, NW, PSUB, AA, AR, GT, GT_P96, P2, SN, SP, DG, M0, M0G, M0C, V0, M1, LOGO, INST, MARKS, MARKG, NODMF, OCOVL, DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, V0DUB, M1DUB, EFUSE, RESNW, RESP1, RESP2, ESDIO2, DSTR, DIOMK2, DMPNP, VARMOS, LDBK, INDMY, FUSEMK1, NPAA, PPAA, AR_H, AR_V, DIOMK1, ESDIO1, SVT_N edge, SVT_P edge, HVT_N edge, HVT_P edge, LVT_N edge, LVT_P edge, ULVT_N edge, ULVT_P edge, LFN_N edge, LFN_P edge, MTFUSE, CTOP >= 1.8um
 err1 = EXT OCCDFH INDMY < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCCD_S_10_FUSEMK1 {
@ Space between OCCDFH and DNW, NW, PSUB, AA, AR, GT, GT_P96, P2, SN, SP, DG, M0, M0G, M0C, V0, M1, LOGO, INST, MARKS, MARKG, NODMF, OCOVL, DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, V0DUB, M1DUB, EFUSE, RESNW, RESP1, RESP2, ESDIO2, DSTR, DIOMK2, DMPNP, VARMOS, LDBK, INDMY, FUSEMK1, NPAA, PPAA, AR_H, AR_V, DIOMK1, ESDIO1, SVT_N edge, SVT_P edge, HVT_N edge, HVT_P edge, LVT_N edge, LVT_P edge, ULVT_N edge, ULVT_P edge, LFN_N edge, LFN_P edge, MTFUSE, CTOP >= 1.8um
 err1 = EXT OCCDFH FUSEMK1 < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCCD_S_10_NPAA {
@ Space between OCCDFH and DNW, NW, PSUB, AA, AR, GT, GT_P96, P2, SN, SP, DG, M0, M0G, M0C, V0, M1, LOGO, INST, MARKS, MARKG, NODMF, OCOVL, DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, V0DUB, M1DUB, EFUSE, RESNW, RESP1, RESP2, ESDIO2, DSTR, DIOMK2, DMPNP, VARMOS, LDBK, INDMY, FUSEMK1, NPAA, PPAA, AR_H, AR_V, DIOMK1, ESDIO1, SVT_N edge, SVT_P edge, HVT_N edge, HVT_P edge, LVT_N edge, LVT_P edge, ULVT_N edge, ULVT_P edge, LFN_N edge, LFN_P edge, MTFUSE, CTOP >= 1.8um
 err1 = EXT OCCDFH NPAA < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCCD_S_10_PPAA {
@ Space between OCCDFH and DNW, NW, PSUB, AA, AR, GT, GT_P96, P2, SN, SP, DG, M0, M0G, M0C, V0, M1, LOGO, INST, MARKS, MARKG, NODMF, OCOVL, DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, V0DUB, M1DUB, EFUSE, RESNW, RESP1, RESP2, ESDIO2, DSTR, DIOMK2, DMPNP, VARMOS, LDBK, INDMY, FUSEMK1, NPAA, PPAA, AR_H, AR_V, DIOMK1, ESDIO1, SVT_N edge, SVT_P edge, HVT_N edge, HVT_P edge, LVT_N edge, LVT_P edge, ULVT_N edge, ULVT_P edge, LFN_N edge, LFN_P edge, MTFUSE, CTOP >= 1.8um
 err1 = EXT OCCDFH PPAA < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCCD_S_10_AR_H {
@ Space between OCCDFH and DNW, NW, PSUB, AA, AR, GT, GT_P96, P2, SN, SP, DG, M0, M0G, M0C, V0, M1, LOGO, INST, MARKS, MARKG, NODMF, OCOVL, DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, V0DUB, M1DUB, EFUSE, RESNW, RESP1, RESP2, ESDIO2, DSTR, DIOMK2, DMPNP, VARMOS, LDBK, INDMY, FUSEMK1, NPAA, PPAA, AR_H, AR_V, DIOMK1, ESDIO1, SVT_N edge, SVT_P edge, HVT_N edge, HVT_P edge, LVT_N edge, LVT_P edge, ULVT_N edge, ULVT_P edge, LFN_N edge, LFN_P edge, MTFUSE, CTOP >= 1.8um
 err1 = EXT OCCDFH AR_H < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCCD_S_10_AR_V {
@ Space between OCCDFH and DNW, NW, PSUB, AA, AR, GT, GT_P96, P2, SN, SP, DG, M0, M0G, M0C, V0, M1, LOGO, INST, MARKS, MARKG, NODMF, OCOVL, DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, V0DUB, M1DUB, EFUSE, RESNW, RESP1, RESP2, ESDIO2, DSTR, DIOMK2, DMPNP, VARMOS, LDBK, INDMY, FUSEMK1, NPAA, PPAA, AR_H, AR_V, DIOMK1, ESDIO1, SVT_N edge, SVT_P edge, HVT_N edge, HVT_P edge, LVT_N edge, LVT_P edge, ULVT_N edge, ULVT_P edge, LFN_N edge, LFN_P edge, MTFUSE, CTOP >= 1.8um
 err1 = EXT OCCDFH AR_V < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCCD_S_10_DIOMK1 {
@ Space between OCCDFH and DNW, NW, PSUB, AA, AR, GT, GT_P96, P2, SN, SP, DG, M0, M0G, M0C, V0, M1, LOGO, INST, MARKS, MARKG, NODMF, OCOVL, DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, V0DUB, M1DUB, EFUSE, RESNW, RESP1, RESP2, ESDIO2, DSTR, DIOMK2, DMPNP, VARMOS, LDBK, INDMY, FUSEMK1, NPAA, PPAA, AR_H, AR_V, DIOMK1, ESDIO1, SVT_N edge, SVT_P edge, HVT_N edge, HVT_P edge, LVT_N edge, LVT_P edge, ULVT_N edge, ULVT_P edge, LFN_N edge, LFN_P edge, MTFUSE, CTOP >= 1.8um
 err1 = EXT OCCDFH DIOMK1 < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCCD_S_10_ESDIO1 {
@ Space between OCCDFH and DNW, NW, PSUB, AA, AR, GT, GT_P96, P2, SN, SP, DG, M0, M0G, M0C, V0, M1, LOGO, INST, MARKS, MARKG, NODMF, OCOVL, DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, V0DUB, M1DUB, EFUSE, RESNW, RESP1, RESP2, ESDIO2, DSTR, DIOMK2, DMPNP, VARMOS, LDBK, INDMY, FUSEMK1, NPAA, PPAA, AR_H, AR_V, DIOMK1, ESDIO1, SVT_N edge, SVT_P edge, HVT_N edge, HVT_P edge, LVT_N edge, LVT_P edge, ULVT_N edge, ULVT_P edge, LFN_N edge, LFN_P edge, MTFUSE, CTOP >= 1.8um
 err1 = EXT OCCDFH ESDIO1 < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCCD_S_10_MTFUSE {
@ Space between OCCDFH and DNW, NW, PSUB, AA, AR, GT, GT_P96, P2, SN, SP, DG, M0, M0G, M0C, V0, M1, LOGO, INST, MARKS, MARKG, NODMF, OCOVL, DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, V0DUB, M1DUB, EFUSE, RESNW, RESP1, RESP2, ESDIO2, DSTR, DIOMK2, DMPNP, VARMOS, LDBK, INDMY, FUSEMK1, NPAA, PPAA, AR_H, AR_V, DIOMK1, ESDIO1, SVT_N edge, SVT_P edge, HVT_N edge, HVT_P edge, LVT_N edge, LVT_P edge, ULVT_N edge, ULVT_P edge, LFN_N edge, LFN_P edge, MTFUSE, CTOP >= 1.8um
 err1 = EXT OCCDFH MTFUSE < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCCD_S_10_CTOP {
@ Space between OCCDFH and DNW, NW, PSUB, AA, AR, GT, GT_P96, P2, SN, SP, DG, M0, M0G, M0C, V0, M1, LOGO, INST, MARKS, MARKG, NODMF, OCOVL, DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, V0DUB, M1DUB, EFUSE, RESNW, RESP1, RESP2, ESDIO2, DSTR, DIOMK2, DMPNP, VARMOS, LDBK, INDMY, FUSEMK1, NPAA, PPAA, AR_H, AR_V, DIOMK1, ESDIO1, SVT_N edge, SVT_P edge, HVT_N edge, HVT_P edge, LVT_N edge, LVT_P edge, ULVT_N edge, ULVT_P edge, LFN_N edge, LFN_P edge, MTFUSE, CTOP >= 1.8um
 err1 = EXT OCCDFH CTOP < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCCD_S_10_SVT_N {
@ Space between OCCDFH and DNW, NW, PSUB, AA, AR, GT, GT_P96, P2, SN, SP, DG, M0, M0G, M0C, V0, M1, LOGO, INST, MARKS, MARKG, NODMF, OCOVL, DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, V0DUB, M1DUB, EFUSE, RESNW, RESP1, RESP2, ESDIO2, DSTR, DIOMK2, DMPNP, VARMOS, LDBK, INDMY, FUSEMK1, NPAA, PPAA, AR_H, AR_V, DIOMK1, ESDIO1, SVT_N edge, SVT_P edge, HVT_N edge, HVT_P edge, LVT_N edge, LVT_P edge, ULVT_N edge, ULVT_P edge, LFN_N edge, LFN_P edge, MTFUSE, CTOP >= 1.8um
 err1 = OCCDFH AND ((SIZE SVT_N BY 1.8) NOT (SIZE SVT_N BY -1.8))
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCCD_S_10_SVT_P {
@ Space between OCCDFH and DNW, NW, PSUB, AA, AR, GT, GT_P96, P2, SN, SP, DG, M0, M0G, M0C, V0, M1, LOGO, INST, MARKS, MARKG, NODMF, OCOVL, DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, V0DUB, M1DUB, EFUSE, RESNW, RESP1, RESP2, ESDIO2, DSTR, DIOMK2, DMPNP, VARMOS, LDBK, INDMY, FUSEMK1, NPAA, PPAA, AR_H, AR_V, DIOMK1, ESDIO1, SVT_N edge, SVT_P edge, HVT_N edge, HVT_P edge, LVT_N edge, LVT_P edge, ULVT_N edge, ULVT_P edge, LFN_N edge, LFN_P edge, MTFUSE, CTOP >= 1.8um
 err1 = OCCDFH AND ((SIZE SVT_P BY 1.8) NOT (SIZE SVT_P BY -1.8))
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCCD_S_10_HVT_N {
@ Space between OCCDFH and DNW, NW, PSUB, AA, AR, GT, GT_P96, P2, SN, SP, DG, M0, M0G, M0C, V0, M1, LOGO, INST, MARKS, MARKG, NODMF, OCOVL, DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, V0DUB, M1DUB, EFUSE, RESNW, RESP1, RESP2, ESDIO2, DSTR, DIOMK2, DMPNP, VARMOS, LDBK, INDMY, FUSEMK1, NPAA, PPAA, AR_H, AR_V, DIOMK1, ESDIO1, SVT_N edge, SVT_P edge, HVT_N edge, HVT_P edge, LVT_N edge, LVT_P edge, ULVT_N edge, ULVT_P edge, LFN_N edge, LFN_P edge, MTFUSE, CTOP >= 1.8um
 err1 = OCCDFH AND ((SIZE HVT_N BY 1.8) NOT (SIZE HVT_N BY -1.8))
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCCD_S_10_HVT_P {
@ Space between OCCDFH and DNW, NW, PSUB, AA, AR, GT, GT_P96, P2, SN, SP, DG, M0, M0G, M0C, V0, M1, LOGO, INST, MARKS, MARKG, NODMF, OCOVL, DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, V0DUB, M1DUB, EFUSE, RESNW, RESP1, RESP2, ESDIO2, DSTR, DIOMK2, DMPNP, VARMOS, LDBK, INDMY, FUSEMK1, NPAA, PPAA, AR_H, AR_V, DIOMK1, ESDIO1, SVT_N edge, SVT_P edge, HVT_N edge, HVT_P edge, LVT_N edge, LVT_P edge, ULVT_N edge, ULVT_P edge, LFN_N edge, LFN_P edge, MTFUSE, CTOP >= 1.8um
 err1 = OCCDFH AND ((SIZE HVT_P BY 1.8) NOT (SIZE HVT_P BY -1.8))
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCCD_S_10_LVT_N {
@ Space between OCCDFH and DNW, NW, PSUB, AA, AR, GT, GT_P96, P2, SN, SP, DG, M0, M0G, M0C, V0, M1, LOGO, INST, MARKS, MARKG, NODMF, OCOVL, DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, V0DUB, M1DUB, EFUSE, RESNW, RESP1, RESP2, ESDIO2, DSTR, DIOMK2, DMPNP, VARMOS, LDBK, INDMY, FUSEMK1, NPAA, PPAA, AR_H, AR_V, DIOMK1, ESDIO1, SVT_N edge, SVT_P edge, HVT_N edge, HVT_P edge, LVT_N edge, LVT_P edge, ULVT_N edge, ULVT_P edge, LFN_N edge, LFN_P edge, MTFUSE, CTOP >= 1.8um
 err1 = OCCDFH AND ((SIZE LVT_N BY 1.8) NOT (SIZE LVT_N BY -1.8))
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCCD_S_10_LVT_P {
@ Space between OCCDFH and DNW, NW, PSUB, AA, AR, GT, GT_P96, P2, SN, SP, DG, M0, M0G, M0C, V0, M1, LOGO, INST, MARKS, MARKG, NODMF, OCOVL, DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, V0DUB, M1DUB, EFUSE, RESNW, RESP1, RESP2, ESDIO2, DSTR, DIOMK2, DMPNP, VARMOS, LDBK, INDMY, FUSEMK1, NPAA, PPAA, AR_H, AR_V, DIOMK1, ESDIO1, SVT_N edge, SVT_P edge, HVT_N edge, HVT_P edge, LVT_N edge, LVT_P edge, ULVT_N edge, ULVT_P edge, LFN_N edge, LFN_P edge, MTFUSE, CTOP >= 1.8um
 err1 = OCCDFH AND ((SIZE LVT_P BY 1.8) NOT (SIZE LVT_P BY -1.8))
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCCD_S_10_ULVT_N {
@ Space between OCCDFH and DNW, NW, PSUB, AA, AR, GT, GT_P96, P2, SN, SP, DG, M0, M0G, M0C, V0, M1, LOGO, INST, MARKS, MARKG, NODMF, OCOVL, DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, V0DUB, M1DUB, EFUSE, RESNW, RESP1, RESP2, ESDIO2, DSTR, DIOMK2, DMPNP, VARMOS, LDBK, INDMY, FUSEMK1, NPAA, PPAA, AR_H, AR_V, DIOMK1, ESDIO1, SVT_N edge, SVT_P edge, HVT_N edge, HVT_P edge, LVT_N edge, LVT_P edge, ULVT_N edge, ULVT_P edge, LFN_N edge, LFN_P edge, MTFUSE, CTOP >= 1.8um
 err1 = OCCDFH AND ((SIZE ULVT_N BY 1.8) NOT (SIZE ULVT_N BY -1.8))
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCCD_S_10_ULVT_P {
@ Space between OCCDFH and DNW, NW, PSUB, AA, AR, GT, GT_P96, P2, SN, SP, DG, M0, M0G, M0C, V0, M1, LOGO, INST, MARKS, MARKG, NODMF, OCOVL, DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, V0DUB, M1DUB, EFUSE, RESNW, RESP1, RESP2, ESDIO2, DSTR, DIOMK2, DMPNP, VARMOS, LDBK, INDMY, FUSEMK1, NPAA, PPAA, AR_H, AR_V, DIOMK1, ESDIO1, SVT_N edge, SVT_P edge, HVT_N edge, HVT_P edge, LVT_N edge, LVT_P edge, ULVT_N edge, ULVT_P edge, LFN_N edge, LFN_P edge, MTFUSE, CTOP >= 1.8um
 err1 = OCCDFH AND ((SIZE ULVT_P BY 1.8) NOT (SIZE ULVT_P BY -1.8))
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCCD_S_10_LFN_N {
@ Space between OCCDFH and DNW, NW, PSUB, AA, AR, GT, GT_P96, P2, SN, SP, DG, M0, M0G, M0C, V0, M1, LOGO, INST, MARKS, MARKG, NODMF, OCOVL, DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, V0DUB, M1DUB, EFUSE, RESNW, RESP1, RESP2, ESDIO2, DSTR, DIOMK2, DMPNP, VARMOS, LDBK, INDMY, FUSEMK1, NPAA, PPAA, AR_H, AR_V, DIOMK1, ESDIO1, SVT_N edge, SVT_P edge, HVT_N edge, HVT_P edge, LVT_N edge, LVT_P edge, ULVT_N edge, ULVT_P edge, LFN_N edge, LFN_P edge, MTFUSE, CTOP >= 1.8um
 err1 = OCCDFH AND ((SIZE LFN_N BY 1.8) NOT (SIZE LFN_N BY -1.8))
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCCD_S_10_LFN_P {
@ Space between OCCDFH and DNW, NW, PSUB, AA, AR, GT, GT_P96, P2, SN, SP, DG, M0, M0G, M0C, V0, M1, LOGO, INST, MARKS, MARKG, NODMF, OCOVL, DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, V0DUB, M1DUB, EFUSE, RESNW, RESP1, RESP2, ESDIO2, DSTR, DIOMK2, DMPNP, VARMOS, LDBK, INDMY, FUSEMK1, NPAA, PPAA, AR_H, AR_V, DIOMK1, ESDIO1, SVT_N edge, SVT_P edge, HVT_N edge, HVT_P edge, LVT_N edge, LVT_P edge, ULVT_N edge, ULVT_P edge, LFN_N edge, LFN_P edge, MTFUSE, CTOP >= 1.8um
 err1 = OCCDFH AND ((SIZE LFN_P BY 1.8) NOT (SIZE LFN_P BY -1.8))
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCCD_S_11_DUM_AA {
@ Space between OCCDFH and DUM_AA, DUM_AR, DUM_GT, DUM_P2, DUM_M0, DUM_M0C, DUM_M0G, DUM_V0, DUM_M1, SNDUM, SPDUM, AR_HDOP, AR_VDOP >= 0.2um
 err1 = EXT OCCDFH DUM_AA < 0.2 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCCD_S_11_DUM_AR {
@ Space between OCCDFH and DUM_AA, DUM_AR, DUM_GT, DUM_P2, DUM_M0, DUM_M0C, DUM_M0G, DUM_V0, DUM_M1, SNDUM, SPDUM, AR_HDOP, AR_VDOP >= 0.2um
 err1 = EXT OCCDFH DUM_AR < 0.2 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCCD_S_11_DUM_GT {
@ Space between OCCDFH and DUM_AA, DUM_AR, DUM_GT, DUM_P2, DUM_M0, DUM_M0C, DUM_M0G, DUM_V0, DUM_M1, SNDUM, SPDUM, AR_HDOP, AR_VDOP >= 0.2um
 err1 = EXT OCCDFH DUM_GT < 0.2 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCCD_S_11_DUM_P2 {
@ Space between OCCDFH and DUM_AA, DUM_AR, DUM_GT, DUM_P2, DUM_M0, DUM_M0C, DUM_M0G, DUM_V0, DUM_M1, SNDUM, SPDUM, AR_HDOP, AR_VDOP >= 0.2um
 err1 = EXT OCCDFH DUM_P2 < 0.2 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCCD_S_11_DUM_M0 {
@ Space between OCCDFH and DUM_AA, DUM_AR, DUM_GT, DUM_P2, DUM_M0, DUM_M0C, DUM_M0G, DUM_V0, DUM_M1, SNDUM, SPDUM, AR_HDOP, AR_VDOP >= 0.2um
 err1 = EXT OCCDFH DUM_M0 < 0.2 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCCD_S_11_DUM_M0C {
@ Space between OCCDFH and DUM_AA, DUM_AR, DUM_GT, DUM_P2, DUM_M0, DUM_M0C, DUM_M0G, DUM_V0, DUM_M1, SNDUM, SPDUM, AR_HDOP, AR_VDOP >= 0.2um
 err1 = EXT OCCDFH DUM_M0C < 0.2 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCCD_S_11_DUM_M0G {
@ Space between OCCDFH and DUM_AA, DUM_AR, DUM_GT, DUM_P2, DUM_M0, DUM_M0C, DUM_M0G, DUM_V0, DUM_M1, SNDUM, SPDUM, AR_HDOP, AR_VDOP >= 0.2um
 err1 = EXT OCCDFH DUM_M0G < 0.2 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCCD_S_11_DUM_V0 {
@ Space between OCCDFH and DUM_AA, DUM_AR, DUM_GT, DUM_P2, DUM_M0, DUM_M0C, DUM_M0G, DUM_V0, DUM_M1, SNDUM, SPDUM, AR_HDOP, AR_VDOP >= 0.2um
 err1 = EXT OCCDFH DUM_V0 < 0.2 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCCD_S_11_DUM_M1 {
@ Space between OCCDFH and DUM_AA, DUM_AR, DUM_GT, DUM_P2, DUM_M0, DUM_M0C, DUM_M0G, DUM_V0, DUM_M1, SNDUM, SPDUM, AR_HDOP, AR_VDOP >= 0.2um
 err1 = EXT OCCDFH DUM_M1 < 0.2 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCCD_S_11_SNDUM {
@ Space between OCCDFH and DUM_AA, DUM_AR, DUM_GT, DUM_P2, DUM_M0, DUM_M0C, DUM_M0G, DUM_V0, DUM_M1, SNDUM, SPDUM, AR_HDOP, AR_VDOP >= 0.2um
 err1 = EXT OCCDFH SNDUM < 0.2 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCCD_S_11_SPDUM {
@ Space between OCCDFH and DUM_AA, DUM_AR, DUM_GT, DUM_P2, DUM_M0, DUM_M0C, DUM_M0G, DUM_V0, DUM_M1, SNDUM, SPDUM, AR_HDOP, AR_VDOP >= 0.2um
 err1 = EXT OCCDFH SPDUM < 0.2 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCCD_S_11_AR_HDOP {
@ Space between OCCDFH and DUM_AA, DUM_AR, DUM_GT, DUM_P2, DUM_M0, DUM_M0C, DUM_M0G, DUM_V0, DUM_M1, SNDUM, SPDUM, AR_HDOP, AR_VDOP >= 0.2um
 err1 = EXT OCCDFH AR_HDOP < 0.2 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCCD_S_11_AR_VDOP {
@ Space between OCCDFH and DUM_AA, DUM_AR, DUM_GT, DUM_P2, DUM_M0, DUM_M0C, DUM_M0G, DUM_V0, DUM_M1, SNDUM, SPDUM, AR_HDOP, AR_VDOP >= 0.2um
 err1 = EXT OCCDFH AR_VDOP < 0.2 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCCD_S_12_M1 {
@ Space between OCCDM1 and M1, INDMY, INST, LOGO, MARKS, MARKG, NODMF, OCOVL, M1DUB, MTFUSE, MOMDMY, FUSEMK1, CTOP >= 1.8um
 err1 = EXT OCCDM1 M1 < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCCD_S_12_INDMY {
@ Space between OCCDM1 and M1, INDMY, INST, LOGO, MARKS, MARKG, NODMF, OCOVL, M1DUB, MTFUSE, MOMDMY, FUSEMK1, CTOP >= 1.8um
 err1 = EXT OCCDM1 INDMY < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCCD_S_12_INST {
@ Space between OCCDM1 and M1, INDMY, INST, LOGO, MARKS, MARKG, NODMF, OCOVL, M1DUB, MTFUSE, MOMDMY, FUSEMK1, CTOP >= 1.8um
 err1 = EXT OCCDM1 INST < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCCD_S_12_LOGO {
@ Space between OCCDM1 and M1, INDMY, INST, LOGO, MARKS, MARKG, NODMF, OCOVL, M1DUB, MTFUSE, MOMDMY, FUSEMK1, CTOP >= 1.8um
 err1 = EXT OCCDM1 LOGO < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCCD_S_12_MARKS {
@ Space between OCCDM1 and M1, INDMY, INST, LOGO, MARKS, MARKG, NODMF, OCOVL, M1DUB, MTFUSE, MOMDMY, FUSEMK1, CTOP >= 1.8um
 err1 = EXT OCCDM1 MARKS < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCCD_S_12_MARKG {
@ Space between OCCDM1 and M1, INDMY, INST, LOGO, MARKS, MARKG, NODMF, OCOVL, M1DUB, MTFUSE, MOMDMY, FUSEMK1, CTOP >= 1.8um
 err1 = EXT OCCDM1 MARKG < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCCD_S_12_NODMF {
@ Space between OCCDM1 and M1, INDMY, INST, LOGO, MARKS, MARKG, NODMF, OCOVL, M1DUB, MTFUSE, MOMDMY, FUSEMK1, CTOP >= 1.8um
 err1 = EXT OCCDM1 NODMF < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCCD_S_12_OCOVL {
@ Space between OCCDM1 and M1, INDMY, INST, LOGO, MARKS, MARKG, NODMF, OCOVL, M1DUB, MTFUSE, MOMDMY, FUSEMK1, CTOP >= 1.8um
 err1 = EXT OCCDM1 OCOVL < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCCD_S_12_M1DUB {
@ Space between OCCDM1 and M1, INDMY, INST, LOGO, MARKS, MARKG, NODMF, OCOVL, M1DUB, MTFUSE, MOMDMY, FUSEMK1, CTOP >= 1.8um
 err1 = EXT OCCDM1 M1DUB < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCCD_S_12_MTFUSE {
@ Space between OCCDM1 and M1, INDMY, INST, LOGO, MARKS, MARKG, NODMF, OCOVL, M1DUB, MTFUSE, MOMDMY, FUSEMK1, CTOP >= 1.8um
 err1 = EXT OCCDM1 MTFUSE < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCCD_S_12_MOMDMY {
@ Space between OCCDM1 and M1, INDMY, INST, LOGO, MARKS, MARKG, NODMF, OCOVL, M1DUB, MTFUSE, MOMDMY, FUSEMK1, CTOP >= 1.8um
 err1 = EXT OCCDM1 MOMDMY < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCCD_S_12_FUSEMK1 {
@ Space between OCCDM1 and M1, INDMY, INST, LOGO, MARKS, MARKG, NODMF, OCOVL, M1DUB, MTFUSE, MOMDMY, FUSEMK1, CTOP >= 1.8um
 err1 = EXT OCCDM1 FUSEMK1 < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCCD_S_12_CTOP {
@ Space between OCCDM1 and M1, INDMY, INST, LOGO, MARKS, MARKG, NODMF, OCOVL, M1DUB, MTFUSE, MOMDMY, FUSEMK1, CTOP >= 1.8um
 err1 = EXT OCCDM1 CTOP < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCCD_S_13 {
@ Space between OCCDM1 and DUM_M1 >= 0.2um
 err1 = EXT OCCDM1 DUM_M1 < 0.2 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCCD_S_14_OCCDM2 {
@ Space between OCCDMn (n = 2~8, respectively) and Mn, INDMY, INST, LOGO, MARKS, MARKG, NODMF, OCOVL, MnDUB, MTFUSE, MOMDMY, FUSEMK1, CTOP >= 1.8um
 err1 = EXT OCCDM2 M2 < 1.8 ABUT<90 SINGULAR REGION
 err2 = EXT OCCDM2 INDMY < 1.8 ABUT<90 SINGULAR REGION
 err3 = EXT OCCDM2 INST < 1.8 ABUT<90 SINGULAR REGION
 err4 = EXT OCCDM2 LOGO < 1.8 ABUT<90 SINGULAR REGION
 err5 = EXT OCCDM2 MARKS < 1.8 ABUT<90 SINGULAR REGION
 err6 = EXT OCCDM2 MARKG < 1.8 ABUT<90 SINGULAR REGION
 err7 = EXT OCCDM2 NODMF < 1.8 ABUT<90 SINGULAR REGION
 err8 = EXT OCCDM2 OCOVL < 1.8 ABUT<90 SINGULAR REGION
 err9 = EXT OCCDM2 M2DUB < 1.8 ABUT<90 SINGULAR REGION
 err10 = EXT OCCDM2 MTFUSE < 1.8 ABUT<90 SINGULAR REGION
 err11 = EXT OCCDM2 MOMDMY < 1.8 ABUT<90 SINGULAR REGION
 err12 = EXT OCCDM2 FUSEMK1 < 1.8 ABUT<90 SINGULAR REGION
 err13 = EXT OCCDM2 CTOP < 1.8 ABUT<90 SINGULAR REGION
 // 
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
 err4 NOT INSIDE SealR_NOT_BULK
 err5 NOT INSIDE SealR_NOT_BULK
 err6 NOT INSIDE SealR_NOT_BULK
 err7 NOT INSIDE SealR_NOT_BULK
 err8 NOT INSIDE SealR_NOT_BULK
 err9 NOT INSIDE SealR_NOT_BULK
 err10 NOT INSIDE SealR_NOT_BULK
 err11 NOT INSIDE SealR_NOT_BULK
 err12 NOT INSIDE SealR_NOT_BULK
 err13 NOT INSIDE SealR_NOT_BULK
}
 
OCCD_S_15_OCCDM2 {
@ Space between OCCDMn (n = 2~8, respectively) and DUM_Mn >= 0.2um
 err1 = EXT OCCDM2 DUM_M2 < 0.2 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCCD_S_14_OCCDM3 {
@ Space between OCCDMn (n = 2~8, respectively) and Mn, INDMY, INST, LOGO, MARKS, MARKG, NODMF, OCOVL, MnDUB, MTFUSE, MOMDMY, FUSEMK1, CTOP >= 1.8um
 err1 = EXT OCCDM3 M3 < 1.8 ABUT<90 SINGULAR REGION
 err2 = EXT OCCDM3 INDMY < 1.8 ABUT<90 SINGULAR REGION
 err3 = EXT OCCDM3 INST < 1.8 ABUT<90 SINGULAR REGION
 err4 = EXT OCCDM3 LOGO < 1.8 ABUT<90 SINGULAR REGION
 err5 = EXT OCCDM3 MARKS < 1.8 ABUT<90 SINGULAR REGION
 err6 = EXT OCCDM3 MARKG < 1.8 ABUT<90 SINGULAR REGION
 err7 = EXT OCCDM3 NODMF < 1.8 ABUT<90 SINGULAR REGION
 err8 = EXT OCCDM3 OCOVL < 1.8 ABUT<90 SINGULAR REGION
 err9 = EXT OCCDM3 M3DUB < 1.8 ABUT<90 SINGULAR REGION
 err10 = EXT OCCDM3 MTFUSE < 1.8 ABUT<90 SINGULAR REGION
 err11 = EXT OCCDM3 MOMDMY < 1.8 ABUT<90 SINGULAR REGION
 err12 = EXT OCCDM3 FUSEMK1 < 1.8 ABUT<90 SINGULAR REGION
 err13 = EXT OCCDM3 CTOP < 1.8 ABUT<90 SINGULAR REGION
 // 
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
 err4 NOT INSIDE SealR_NOT_BULK
 err5 NOT INSIDE SealR_NOT_BULK
 err6 NOT INSIDE SealR_NOT_BULK
 err7 NOT INSIDE SealR_NOT_BULK
 err8 NOT INSIDE SealR_NOT_BULK
 err9 NOT INSIDE SealR_NOT_BULK
 err10 NOT INSIDE SealR_NOT_BULK
 err11 NOT INSIDE SealR_NOT_BULK
 err12 NOT INSIDE SealR_NOT_BULK
 err13 NOT INSIDE SealR_NOT_BULK
}
 
OCCD_S_15_OCCDM3 {
@ Space between OCCDMn (n = 2~8, respectively) and DUM_Mn >= 0.2um
 err1 = EXT OCCDM3 DUM_M3 < 0.2 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCCD_S_14_OCCDM4 {
@ Space between OCCDMn (n = 2~8, respectively) and Mn, INDMY, INST, LOGO, MARKS, MARKG, NODMF, OCOVL, MnDUB, MTFUSE, MOMDMY, FUSEMK1, CTOP >= 1.8um
 err1 = EXT OCCDM4 M4 < 1.8 ABUT<90 SINGULAR REGION
 err2 = EXT OCCDM4 INDMY < 1.8 ABUT<90 SINGULAR REGION
 err3 = EXT OCCDM4 INST < 1.8 ABUT<90 SINGULAR REGION
 err4 = EXT OCCDM4 LOGO < 1.8 ABUT<90 SINGULAR REGION
 err5 = EXT OCCDM4 MARKS < 1.8 ABUT<90 SINGULAR REGION
 err6 = EXT OCCDM4 MARKG < 1.8 ABUT<90 SINGULAR REGION
 err7 = EXT OCCDM4 NODMF < 1.8 ABUT<90 SINGULAR REGION
 err8 = EXT OCCDM4 OCOVL < 1.8 ABUT<90 SINGULAR REGION
 err9 = EXT OCCDM4 M4DUB < 1.8 ABUT<90 SINGULAR REGION
 err10 = EXT OCCDM4 MTFUSE < 1.8 ABUT<90 SINGULAR REGION
 err11 = EXT OCCDM4 MOMDMY < 1.8 ABUT<90 SINGULAR REGION
 err12 = EXT OCCDM4 FUSEMK1 < 1.8 ABUT<90 SINGULAR REGION
 err13 = EXT OCCDM4 CTOP < 1.8 ABUT<90 SINGULAR REGION
 // 
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
 err4 NOT INSIDE SealR_NOT_BULK
 err5 NOT INSIDE SealR_NOT_BULK
 err6 NOT INSIDE SealR_NOT_BULK
 err7 NOT INSIDE SealR_NOT_BULK
 err8 NOT INSIDE SealR_NOT_BULK
 err9 NOT INSIDE SealR_NOT_BULK
 err10 NOT INSIDE SealR_NOT_BULK
 err11 NOT INSIDE SealR_NOT_BULK
 err12 NOT INSIDE SealR_NOT_BULK
 err13 NOT INSIDE SealR_NOT_BULK
}
 
OCCD_S_15_OCCDM4 {
@ Space between OCCDMn (n = 2~8, respectively) and DUM_Mn >= 0.2um
 err1 = EXT OCCDM4 DUM_M4 < 0.2 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCCD_S_14_OCCDM5 {
@ Space between OCCDMn (n = 2~8, respectively) and Mn, INDMY, INST, LOGO, MARKS, MARKG, NODMF, OCOVL, MnDUB, MTFUSE, MOMDMY, FUSEMK1, CTOP >= 1.8um
 err1 = EXT OCCDM5 M5 < 1.8 ABUT<90 SINGULAR REGION
 err2 = EXT OCCDM5 INDMY < 1.8 ABUT<90 SINGULAR REGION
 err3 = EXT OCCDM5 INST < 1.8 ABUT<90 SINGULAR REGION
 err4 = EXT OCCDM5 LOGO < 1.8 ABUT<90 SINGULAR REGION
 err5 = EXT OCCDM5 MARKS < 1.8 ABUT<90 SINGULAR REGION
 err6 = EXT OCCDM5 MARKG < 1.8 ABUT<90 SINGULAR REGION
 err7 = EXT OCCDM5 NODMF < 1.8 ABUT<90 SINGULAR REGION
 err8 = EXT OCCDM5 OCOVL < 1.8 ABUT<90 SINGULAR REGION
 err9 = EXT OCCDM5 M5DUB < 1.8 ABUT<90 SINGULAR REGION
 err10 = EXT OCCDM5 MTFUSE < 1.8 ABUT<90 SINGULAR REGION
 err11 = EXT OCCDM5 MOMDMY < 1.8 ABUT<90 SINGULAR REGION
 err12 = EXT OCCDM5 FUSEMK1 < 1.8 ABUT<90 SINGULAR REGION
 err13 = EXT OCCDM5 CTOP < 1.8 ABUT<90 SINGULAR REGION
 // 
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
 err4 NOT INSIDE SealR_NOT_BULK
 err5 NOT INSIDE SealR_NOT_BULK
 err6 NOT INSIDE SealR_NOT_BULK
 err7 NOT INSIDE SealR_NOT_BULK
 err8 NOT INSIDE SealR_NOT_BULK
 err9 NOT INSIDE SealR_NOT_BULK
 err10 NOT INSIDE SealR_NOT_BULK
 err11 NOT INSIDE SealR_NOT_BULK
 err12 NOT INSIDE SealR_NOT_BULK
 err13 NOT INSIDE SealR_NOT_BULK
}
 
OCCD_S_15_OCCDM5 {
@ Space between OCCDMn (n = 2~8, respectively) and DUM_Mn >= 0.2um
 err1 = EXT OCCDM5 DUM_M5 < 0.2 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCCD_S_14_OCCDM6 {
@ Space between OCCDMn (n = 2~8, respectively) and Mn, INDMY, INST, LOGO, MARKS, MARKG, NODMF, OCOVL, MnDUB, MTFUSE, MOMDMY, FUSEMK1, CTOP >= 1.8um
 err1 = EXT OCCDM6 M6 < 1.8 ABUT<90 SINGULAR REGION
 err2 = EXT OCCDM6 INDMY < 1.8 ABUT<90 SINGULAR REGION
 err3 = EXT OCCDM6 INST < 1.8 ABUT<90 SINGULAR REGION
 err4 = EXT OCCDM6 LOGO < 1.8 ABUT<90 SINGULAR REGION
 err5 = EXT OCCDM6 MARKS < 1.8 ABUT<90 SINGULAR REGION
 err6 = EXT OCCDM6 MARKG < 1.8 ABUT<90 SINGULAR REGION
 err7 = EXT OCCDM6 NODMF < 1.8 ABUT<90 SINGULAR REGION
 err8 = EXT OCCDM6 OCOVL < 1.8 ABUT<90 SINGULAR REGION
 err9 = EXT OCCDM6 M6DUB < 1.8 ABUT<90 SINGULAR REGION
 err10 = EXT OCCDM6 MTFUSE < 1.8 ABUT<90 SINGULAR REGION
 err11 = EXT OCCDM6 MOMDMY < 1.8 ABUT<90 SINGULAR REGION
 err12 = EXT OCCDM6 FUSEMK1 < 1.8 ABUT<90 SINGULAR REGION
 err13 = EXT OCCDM6 CTOP < 1.8 ABUT<90 SINGULAR REGION
 // 
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
 err4 NOT INSIDE SealR_NOT_BULK
 err5 NOT INSIDE SealR_NOT_BULK
 err6 NOT INSIDE SealR_NOT_BULK
 err7 NOT INSIDE SealR_NOT_BULK
 err8 NOT INSIDE SealR_NOT_BULK
 err9 NOT INSIDE SealR_NOT_BULK
 err10 NOT INSIDE SealR_NOT_BULK
 err11 NOT INSIDE SealR_NOT_BULK
 err12 NOT INSIDE SealR_NOT_BULK
 err13 NOT INSIDE SealR_NOT_BULK
}
 
OCCD_S_15_OCCDM6 {
@ Space between OCCDMn (n = 2~8, respectively) and DUM_Mn >= 0.2um
 err1 = EXT OCCDM6 DUM_M6 < 0.2 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCCD_S_14_OCCDM7 {
@ Space between OCCDMn (n = 2~8, respectively) and Mn, INDMY, INST, LOGO, MARKS, MARKG, NODMF, OCOVL, MnDUB, MTFUSE, MOMDMY, FUSEMK1, CTOP >= 1.8um
 err1 = EXT OCCDM7 M7 < 1.8 ABUT<90 SINGULAR REGION
 err2 = EXT OCCDM7 INDMY < 1.8 ABUT<90 SINGULAR REGION
 err3 = EXT OCCDM7 INST < 1.8 ABUT<90 SINGULAR REGION
 err4 = EXT OCCDM7 LOGO < 1.8 ABUT<90 SINGULAR REGION
 err5 = EXT OCCDM7 MARKS < 1.8 ABUT<90 SINGULAR REGION
 err6 = EXT OCCDM7 MARKG < 1.8 ABUT<90 SINGULAR REGION
 err7 = EXT OCCDM7 NODMF < 1.8 ABUT<90 SINGULAR REGION
 err8 = EXT OCCDM7 OCOVL < 1.8 ABUT<90 SINGULAR REGION
 err9 = EXT OCCDM7 M7DUB < 1.8 ABUT<90 SINGULAR REGION
 err10 = EXT OCCDM7 MTFUSE < 1.8 ABUT<90 SINGULAR REGION
 err11 = EXT OCCDM7 MOMDMY < 1.8 ABUT<90 SINGULAR REGION
 err12 = EXT OCCDM7 FUSEMK1 < 1.8 ABUT<90 SINGULAR REGION
 err13 = EXT OCCDM7 CTOP < 1.8 ABUT<90 SINGULAR REGION
 // 
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
 err4 NOT INSIDE SealR_NOT_BULK
 err5 NOT INSIDE SealR_NOT_BULK
 err6 NOT INSIDE SealR_NOT_BULK
 err7 NOT INSIDE SealR_NOT_BULK
 err8 NOT INSIDE SealR_NOT_BULK
 err9 NOT INSIDE SealR_NOT_BULK
 err10 NOT INSIDE SealR_NOT_BULK
 err11 NOT INSIDE SealR_NOT_BULK
 err12 NOT INSIDE SealR_NOT_BULK
 err13 NOT INSIDE SealR_NOT_BULK
}
 
OCCD_S_15_OCCDM7 {
@ Space between OCCDMn (n = 2~8, respectively) and DUM_Mn >= 0.2um
 err1 = EXT OCCDM7 DUM_M7 < 0.2 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

OCCD_S_16_OCCDB1 {
@ Space between OCCDBn (n = 1~2, respectively) and Bn, INDMY, INST, LOGO, MARKS, MARKG, NODMF, OCOVL, BnDUB, MTFUSE, MOMDMY, FUSEMK1, CTOP >= 1.8um
 err1 = EXT OCCDB1 B1i < 1.8 ABUT<90 SINGULAR REGION
 err2 = EXT OCCDB1 INDMY < 1.8 ABUT<90 SINGULAR REGION
 err3 = EXT OCCDB1 INST < 1.8 ABUT<90 SINGULAR REGION
 err4 = EXT OCCDB1 LOGO < 1.8 ABUT<90 SINGULAR REGION
 err5 = EXT OCCDB1 MARKS < 1.8 ABUT<90 SINGULAR REGION
 err6 = EXT OCCDB1 MARKG < 1.8 ABUT<90 SINGULAR REGION
 err7 = EXT OCCDB1 NODMF < 1.8 ABUT<90 SINGULAR REGION
 err8 = EXT OCCDB1 OCOVL < 1.8 ABUT<90 SINGULAR REGION
 err9 = EXT OCCDB1 B1DUB < 1.8 ABUT<90 SINGULAR REGION
 err10 = EXT OCCDB1 MTFUSE < 1.8 ABUT<90 SINGULAR REGION
 err11 = EXT OCCDB1 MOMDMY < 1.8 ABUT<90 SINGULAR REGION
 err12 = EXT OCCDB1 FUSEMK1 < 1.8 ABUT<90 SINGULAR REGION
 err13 = EXT OCCDB1 CTOP < 1.8 ABUT<90 SINGULAR REGION

 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
 err4 NOT INSIDE SealR_NOT_BULK
 err5 NOT INSIDE SealR_NOT_BULK
 err6 NOT INSIDE SealR_NOT_BULK
 err7 NOT INSIDE SealR_NOT_BULK
 err8 NOT INSIDE SealR_NOT_BULK
 err9 NOT INSIDE SealR_NOT_BULK
 err10 NOT INSIDE SealR_NOT_BULK
 err11 NOT INSIDE SealR_NOT_BULK
 err12 NOT INSIDE SealR_NOT_BULK
 err13 NOT INSIDE SealR_NOT_BULK
}

OCCD_S_16_OCCDB2 {
@ Space between OCCDBn (n = 1~2, respectively) and Bn, INDMY, INST, LOGO, MARKS, MARKG, NODMF, OCOVL, BnDUB, MTFUSE, MOMDMY, FUSEMK1, CTOP >= 1.8um
 err1 = EXT OCCDB2 B2i < 1.8 ABUT<90 SINGULAR REGION
 err2 = EXT OCCDB2 INDMY < 1.8 ABUT<90 SINGULAR REGION
 err3 = EXT OCCDB2 INST < 1.8 ABUT<90 SINGULAR REGION
 err4 = EXT OCCDB2 LOGO < 1.8 ABUT<90 SINGULAR REGION
 err5 = EXT OCCDB2 MARKS < 1.8 ABUT<90 SINGULAR REGION
 err6 = EXT OCCDB2 MARKG < 1.8 ABUT<90 SINGULAR REGION
 err7 = EXT OCCDB2 NODMF < 1.8 ABUT<90 SINGULAR REGION
 err8 = EXT OCCDB2 OCOVL < 1.8 ABUT<90 SINGULAR REGION
 err9 = EXT OCCDB2 B2DUB < 1.8 ABUT<90 SINGULAR REGION
 err10 = EXT OCCDB2 MTFUSE < 1.8 ABUT<90 SINGULAR REGION
 err11 = EXT OCCDB2 MOMDMY < 1.8 ABUT<90 SINGULAR REGION
 err12 = EXT OCCDB2 FUSEMK1 < 1.8 ABUT<90 SINGULAR REGION
 err13 = EXT OCCDB2 CTOP < 1.8 ABUT<90 SINGULAR REGION

 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
 err4 NOT INSIDE SealR_NOT_BULK
 err5 NOT INSIDE SealR_NOT_BULK
 err6 NOT INSIDE SealR_NOT_BULK
 err7 NOT INSIDE SealR_NOT_BULK
 err8 NOT INSIDE SealR_NOT_BULK
 err9 NOT INSIDE SealR_NOT_BULK
 err10 NOT INSIDE SealR_NOT_BULK
 err11 NOT INSIDE SealR_NOT_BULK
 err12 NOT INSIDE SealR_NOT_BULK
 err13 NOT INSIDE SealR_NOT_BULK
}

OCCD_S_17_OCCDB1 {
@ Space between OCCDBn (n = 1~2, respectively) and DUM_Bn >= 0.2um
 err1 = EXT OCCDB1 DUM_B1i < 0.2 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

OCCD_S_17_OCCDB2 {
@ Space between OCCDBn (n = 1~2, respectively) and DUM_Bn >= 0.2um
 err1 = EXT OCCDB2 DUM_B2i < 0.2 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

#IFDEF CHIPB_RULES_CHECK YES
OCCD_EN_1 {
@ OCCD enclosure by CHIPB >= 1.8um
 err1 = ENC OCCD CHIPB < 1.8 ABUT<90 SINGULAR REGION OUTSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
#ENDIF

OCCD_R_1 {
@ OCCDB is for all BEOL OCCD marker recognition, OCCDB must be drawn the same as ((OCCDM1 OR OCCDMn) OR OCCDBn)
 err1 = OCCDB NOT COIN INSIDE EDGE (OR OCCDM1 OCCDM2 OCCDM3 OCCDM4 OCCDM5 OCCDM6 OCCDM7 OCCDM8 OCCDB1 OCCDB2)
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

OCCD_R_2 {
@ OCCD is for all OCCD markers recognition, OCCD must be drawn the same as (OCCDFH OR OCCDB)
 err1 = OCCD NOT COIN INSIDE EDGE (OR OCCDFH OCCDB)
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
OCCD_R_3 {
@ OCCDFH overlap with PSUB, DG, LOGO, INST, MARKS, MARKG, NODMF, OCOVL, DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, V0DUB, M1DUB, EFUSE, RESNW, RESP1, RESP2, ESDIO2, DSTR, DIOMK2, DMPNP, VARMOS, LDBK, INDMY, FUSEMK1, DUM_AA, DUM_AR, DUM_GT, DUM_P2, DUM_M0, DUM_M0C, DUM_M0G, DUM_V0, DUM_M1, SNDUM, SPDUM, NPAA, PPAA, AR_H, AR_V, DIOMK1, ESDIO1, SVT_N edge, SVT_P edge, HVT_N edge, HVT_P edge, LVT_N edge, LVT_P edge, ULVT_N edge, ULVT_P edge, LFN_N edge, LFN_P edge, MTFUSE, CTOP, AR_HDOP, AR_VDOP OCCDM1 is not allowed
 err1 = OCCDFH AND (OR PSUB DG LOGO INST MARKS MARKG NODMF OCOVL DUMBA DUMBP ARDUB P2DUB M0DUB M0CDUB M0GDUB V0DUB M1DUB EFUSE RESNW RESP1 RESP2 ESDIO2 DSTR DIOMK2 DMPNP VARMOS LDBK INDMY FUSEMK1 DUM_AA DUM_AR DUM_GT DUM_P2 DUM_M0 DUM_M0C DUM_M0G DUM_V0 DUM_M1 SNDUM SPDUM NPAA PPAA AR_H AR_V DIOMK1 ESDIO1 MTFUSE CTOP AR_HDOP AR_VDOP OCCDM1)
 err1 NOT INSIDE SealR_NOT_BULK
 err2_SVT_N = SVT_N NOT OUTSIDE EDGE OCCDFH
 err2_SVT_N NOT INSIDE EDGE SealR_NOT_BULK
 err2_SVT_P = SVT_P NOT OUTSIDE EDGE OCCDFH
 err2_SVT_P NOT INSIDE EDGE SealR_NOT_BULK
 err2_HVT_N = HVT_N NOT OUTSIDE EDGE OCCDFH
 err2_HVT_N NOT INSIDE EDGE SealR_NOT_BULK
 err2_HVT_P = HVT_P NOT OUTSIDE EDGE OCCDFH
 err2_HVT_P NOT INSIDE EDGE SealR_NOT_BULK
 err2_LVT_N = LVT_N NOT OUTSIDE EDGE OCCDFH
 err2_LVT_N NOT INSIDE EDGE SealR_NOT_BULK
 err2_LVT_P = LVT_P NOT OUTSIDE EDGE OCCDFH
 err2_LVT_P NOT INSIDE EDGE SealR_NOT_BULK
 err2_ULVT_N = ULVT_N NOT OUTSIDE EDGE OCCDFH
 err2_ULVT_N NOT INSIDE EDGE SealR_NOT_BULK
 err2_ULVT_P = ULVT_P NOT OUTSIDE EDGE OCCDFH
 err2_ULVT_P NOT INSIDE EDGE SealR_NOT_BULK
 err2_LFN_N = LFN_N NOT OUTSIDE EDGE OCCDFH
 err2_LFN_N NOT INSIDE EDGE SealR_NOT_BULK
 err2_LFN_P = LFN_P NOT OUTSIDE EDGE OCCDFH
 err2_LFN_P NOT INSIDE EDGE SealR_NOT_BULK
}
 
OCCD_R_4 {
@ OCCDM1 overlap with INST, LOGO, MARKS, MARKG, NODMF, OCOVL, M1DUB, MTFUSE, MOMDMY, INDMY, FUSEMK1, DUM_M1, CTOP is not allowed
 err1 = OCCDM1 AND (OR INDMY INST LOGO MARKS MARKG NODMF OCOVL M1DUB MTFUSE MOMDMY FUSEMK1 DUM_M1 CTOP)
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCCD_R_5_OCCDM2 {
@ OCCDMn (n = 2~8, respectively) overlap with INST, LOGO, MARKS, MARKG, NODMF, OCOVL, MnDUB, MTFUSE, MOMDMY, INDMY, FUSEMK1, DUM_Mn, CTOP is not allowed
 err1 = OCCDM2 AND (OR INDMY INST LOGO MARKS MARKG NODMF OCOVL M2DUB MTFUSE MOMDMY FUSEMK1 DUM_M2 CTOP)
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCCD_R_5_OCCDM3 {
@ OCCDMn (n = 2~8, respectively) overlap with INST, LOGO, MARKS, MARKG, NODMF, OCOVL, MnDUB, MTFUSE, MOMDMY, INDMY, FUSEMK1, DUM_Mn, CTOP is not allowed
 err1 = OCCDM3 AND (OR INDMY INST LOGO MARKS MARKG NODMF OCOVL M3DUB MTFUSE MOMDMY FUSEMK1 DUM_M3 CTOP)
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCCD_R_5_OCCDM4 {
@ OCCDMn (n = 2~8, respectively) overlap with INST, LOGO, MARKS, MARKG, NODMF, OCOVL, MnDUB, MTFUSE, MOMDMY, INDMY, FUSEMK1, DUM_Mn, CTOP is not allowed
 err1 = OCCDM4 AND (OR INDMY INST LOGO MARKS MARKG NODMF OCOVL M4DUB MTFUSE MOMDMY FUSEMK1 DUM_M4 CTOP)
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCCD_R_5_OCCDM5 {
@ OCCDMn (n = 2~8, respectively) overlap with INST, LOGO, MARKS, MARKG, NODMF, OCOVL, MnDUB, MTFUSE, MOMDMY, INDMY, FUSEMK1, DUM_Mn, CTOP is not allowed
 err1 = OCCDM5 AND (OR INDMY INST LOGO MARKS MARKG NODMF OCOVL M5DUB MTFUSE MOMDMY FUSEMK1 DUM_M5 CTOP)
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCCD_R_5_OCCDM6 {
@ OCCDMn (n = 2~8, respectively) overlap with INST, LOGO, MARKS, MARKG, NODMF, OCOVL, MnDUB, MTFUSE, MOMDMY, INDMY, FUSEMK1, DUM_Mn, CTOP is not allowed
 err1 = OCCDM6 AND (OR INDMY INST LOGO MARKS MARKG NODMF OCOVL M6DUB MTFUSE MOMDMY FUSEMK1 DUM_M6 CTOP)
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCCD_R_5_OCCDM7 {
@ OCCDMn (n = 2~8, respectively) overlap with INST, LOGO, MARKS, MARKG, NODMF, OCOVL, MnDUB, MTFUSE, MOMDMY, INDMY, FUSEMK1, DUM_Mn, CTOP is not allowed
 err1 = OCCDM7 AND (OR INDMY INST LOGO MARKS MARKG NODMF OCOVL M7DUB MTFUSE MOMDMY FUSEMK1 DUM_M7 CTOP)
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCCD_R_6_OCCDB1 {
@ OCCDBn (n = 1~2, respectively) overlap with INDMY, INST, LOGO, MARKS, MARKG, NODMF, OCOVL, BnDUB, MOMDMY, FUSEMK1, DUM_Bn, CTOP is not allowed
 err1 = OCCDB1 AND (OR INDMY INST LOGO MARKS MARKG NODMF OCOVL B1DUB MOMDMY FUSEMK1 DUM_B1i CTOP)
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCCD_R_6_OCCDB2 {
@ OCCDBn (n = 1~2, respectively) overlap with INDMY, INST, LOGO, MARKS, MARKG, NODMF, OCOVL, BnDUB, MOMDMY, FUSEMK1, DUM_Bn, CTOP is not allowed
 err1 = OCCDB2 AND (OR INDMY INST LOGO MARKS MARKG NODMF OCOVL B2DUB MOMDMY FUSEMK1 DUM_B2i CTOP)
 err1 NOT INSIDE SealR_NOT_BULK
}
 
chip_window = DRC:1 WITH WIDTH >= 500

#IFDEF RECOMMENDED_CHECK YES

 
OCCD_R_7_R {
@ Recommended at least one OCCDFH in each 2000umx2000um window of chip
 err1 = DENSITY OCCDFH chip_window [!AREA(chip_window) + AREA(OCCDFH)] == 0 WINDOW 2000 STEP 1000 BACKUP INSIDE OF LAYER DRC:1 BY POLYGON
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCCD_R_8_R {
@ Recommended at least one OCCDM1 in each 2000umx2000um window of chip
 err1 = DENSITY OCCDM1 chip_window [!AREA(chip_window) + AREA(OCCDM1)] == 0 WINDOW 2000 STEP 1000 BACKUP INSIDE OF LAYER DRC:1 BY POLYGON
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCCD_R_9_OCCDM2_R {
@ Recommended at least one OCCDMn (n = 2~8, respectively) in each 2000umx2000um window of chip
 err1 = DENSITY OCCDM2 chip_window [!AREA(chip_window) + AREA(OCCDM2)] == 0 WINDOW 2000 STEP 1000 BACKUP INSIDE OF LAYER DRC:1 BY POLYGON
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCCD_R_9_OCCDM3_R {
@ Recommended at least one OCCDMn (n = 2~8, respectively) in each 2000umx2000um window of chip
 err1 = DENSITY OCCDM3 chip_window [!AREA(chip_window) + AREA(OCCDM3)] == 0 WINDOW 2000 STEP 1000 BACKUP INSIDE OF LAYER DRC:1 BY POLYGON
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCCD_R_9_OCCDM4_R {
@ Recommended at least one OCCDMn (n = 2~8, respectively) in each 2000umx2000um window of chip
 err1 = DENSITY OCCDM4 chip_window [!AREA(chip_window) + AREA(OCCDM4)] == 0 WINDOW 2000 STEP 1000 BACKUP INSIDE OF LAYER DRC:1 BY POLYGON
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCCD_R_9_OCCDM5_R {
@ Recommended at least one OCCDMn (n = 2~8, respectively) in each 2000umx2000um window of chip
 err1 = DENSITY OCCDM5 chip_window [!AREA(chip_window) + AREA(OCCDM5)] == 0 WINDOW 2000 STEP 1000 BACKUP INSIDE OF LAYER DRC:1 BY POLYGON
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCCD_R_9_OCCDM6_R {
@ Recommended at least one OCCDMn (n = 2~8, respectively) in each 2000umx2000um window of chip
 err1 = DENSITY OCCDM6 chip_window [!AREA(chip_window) + AREA(OCCDM6)] == 0 WINDOW 2000 STEP 1000 BACKUP INSIDE OF LAYER DRC:1 BY POLYGON
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCCD_R_9_OCCDM7_R {
@ Recommended at least one OCCDMn (n = 2~8, respectively) in each 2000umx2000um window of chip
 err1 = DENSITY OCCDM7 chip_window [!AREA(chip_window) + AREA(OCCDM7)] == 0 WINDOW 2000 STEP 1000 BACKUP INSIDE OF LAYER DRC:1 BY POLYGON
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCCD_R_10_OCCDB1_R {
@ Recommended at least one OCCDBn (n = 1~2, respectively) in each 2000umx2000um window of chip
 err1 = DENSITY OCCDB1 chip_window [!AREA(chip_window) + AREA(OCCDB1)] == 0 WINDOW 2000 STEP 1000 BACKUP INSIDE OF LAYER DRC:1 BY POLYGON
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCCD_R_10_OCCDB2_R {
@ Recommended at least one OCCDBn (n = 1~2, respectively) in each 2000umx2000um window of chip
 err1 = DENSITY OCCDB2 chip_window [!AREA(chip_window) + AREA(OCCDB2)] == 0 WINDOW 2000 STEP 1000 BACKUP INSIDE OF LAYER DRC:1 BY POLYGON
 err1 NOT INSIDE SealR_NOT_BULK
}

#ENDIF
#ENDIF


// =======================================================
// OCOVL design guidelines
// =======================================================
#IFDEF OCOVL_RULES_CHECK YES

GROUP GOCOVL OCOVL_?

OCOVL_FEOL = OR OCOVLAR OCOVLARH OCOVLARV OCOVLGT1 OCOVLGT2 OCOVLP2A OCOVLP2B OCOVLM0C OCOVLM0 OCOVLM0G1 OCOVLM0G2
OCOVL_BEOL = OR OCOVLM1CA OCOVLM1CB OCOVLM2CA OCOVLM4 OCOVLV0

OCOVL_W_1 {
@ OCOVL width and length = 20um
 err1 = OCOVL NOT RECTANGLE == 20 BY == 20 ORTHOGONAL ONLY
 err1 NOT INSIDE SealR_NOT_BULK
}

OCOVL_S_1 {
@ Space between OCOVL >= 100um
 err1 = EXT OCOVL < 100 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_2_DNW {
@ OCOVL_FEOL space to DNW, NW, PSUB, AA, AR, GT, GT_P96, P2, SN, SP, DG, M0, M0G, M0C, V0, LOGO, INST, MARKS, MARKG, NODMF, OCCD, DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, V0DUB, EFUSE, RESNW, RESP1, RESP2, ESDIO2, DSTR, DIOMK2, DMPNP, VARMOS, LDBK, INDMY, FUSEMK1, NPAA, PPAA, AR_H, AR_V, CELLB edge, DIOMK1, ESDIO1, SVT_N edge, SVT_P edge, HVT_N edge, HVT_P edge, LVT_N edge, LVT_P edge, ULVT_N edge, ULVT_P edge, LFN_N edge, LFN_P edge, MTFUSE, CTOP >= 1.8um
 err1 = EXT OCOVL_FEOL DNW < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_2_NW {
@ OCOVL_FEOL space to DNW, NW, PSUB, AA, AR, GT, GT_P96, P2, SN, SP, DG, M0, M0G, M0C, V0, LOGO, INST, MARKS, MARKG, NODMF, OCCD, DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, V0DUB, EFUSE, RESNW, RESP1, RESP2, ESDIO2, DSTR, DIOMK2, DMPNP, VARMOS, LDBK, INDMY, FUSEMK1, NPAA, PPAA, AR_H, AR_V, CELLB edge, DIOMK1, ESDIO1, SVT_N edge, SVT_P edge, HVT_N edge, HVT_P edge, LVT_N edge, LVT_P edge, ULVT_N edge, ULVT_P edge, LFN_N edge, LFN_P edge, MTFUSE, CTOP >= 1.8um
 err1 = EXT OCOVL_FEOL NW < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_2_PSUB {
@ OCOVL_FEOL space to DNW, NW, PSUB, AA, AR, GT, GT_P96, P2, SN, SP, DG, M0, M0G, M0C, V0, LOGO, INST, MARKS, MARKG, NODMF, OCCD, DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, V0DUB, EFUSE, RESNW, RESP1, RESP2, ESDIO2, DSTR, DIOMK2, DMPNP, VARMOS, LDBK, INDMY, FUSEMK1, NPAA, PPAA, AR_H, AR_V, CELLB edge, DIOMK1, ESDIO1, SVT_N edge, SVT_P edge, HVT_N edge, HVT_P edge, LVT_N edge, LVT_P edge, ULVT_N edge, ULVT_P edge, LFN_N edge, LFN_P edge, MTFUSE, CTOP >= 1.8um
 err1 = EXT OCOVL_FEOL PSUB < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_2_AA {
@ OCOVL_FEOL space to DNW, NW, PSUB, AA, AR, GT, GT_P96, P2, SN, SP, DG, M0, M0G, M0C, V0, LOGO, INST, MARKS, MARKG, NODMF, OCCD, DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, V0DUB, EFUSE, RESNW, RESP1, RESP2, ESDIO2, DSTR, DIOMK2, DMPNP, VARMOS, LDBK, INDMY, FUSEMK1, NPAA, PPAA, AR_H, AR_V, CELLB edge, DIOMK1, ESDIO1, SVT_N edge, SVT_P edge, HVT_N edge, HVT_P edge, LVT_N edge, LVT_P edge, ULVT_N edge, ULVT_P edge, LFN_N edge, LFN_P edge, MTFUSE, CTOP >= 1.8um
 err1 = EXT OCOVL_FEOL AA < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_2_AR {
@ OCOVL_FEOL space to DNW, NW, PSUB, AA, AR, GT, GT_P96, P2, SN, SP, DG, M0, M0G, M0C, V0, LOGO, INST, MARKS, MARKG, NODMF, OCCD, DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, V0DUB, EFUSE, RESNW, RESP1, RESP2, ESDIO2, DSTR, DIOMK2, DMPNP, VARMOS, LDBK, INDMY, FUSEMK1, NPAA, PPAA, AR_H, AR_V, CELLB edge, DIOMK1, ESDIO1, SVT_N edge, SVT_P edge, HVT_N edge, HVT_P edge, LVT_N edge, LVT_P edge, ULVT_N edge, ULVT_P edge, LFN_N edge, LFN_P edge, MTFUSE, CTOP >= 1.8um
 err1 = EXT OCOVL_FEOL AR < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_2_GT {
@ OCOVL_FEOL space to DNW, NW, PSUB, AA, AR, GT, GT_P96, P2, SN, SP, DG, M0, M0G, M0C, V0, LOGO, INST, MARKS, MARKG, NODMF, OCCD, DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, V0DUB, EFUSE, RESNW, RESP1, RESP2, ESDIO2, DSTR, DIOMK2, DMPNP, VARMOS, LDBK, INDMY, FUSEMK1, NPAA, PPAA, AR_H, AR_V, CELLB edge, DIOMK1, ESDIO1, SVT_N edge, SVT_P edge, HVT_N edge, HVT_P edge, LVT_N edge, LVT_P edge, ULVT_N edge, ULVT_P edge, LFN_N edge, LFN_P edge, MTFUSE, CTOP >= 1.8um
 err1 = EXT OCOVL_FEOL GT < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_2_GT_P96 {
@ OCOVL_FEOL space to DNW, NW, PSUB, AA, AR, GT, GT_P96, P2, SN, SP, DG, M0, M0G, M0C, V0, LOGO, INST, MARKS, MARKG, NODMF, OCCD, DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, V0DUB, EFUSE, RESNW, RESP1, RESP2, ESDIO2, DSTR, DIOMK2, DMPNP, VARMOS, LDBK, INDMY, FUSEMK1, NPAA, PPAA, AR_H, AR_V, CELLB edge, DIOMK1, ESDIO1, SVT_N edge, SVT_P edge, HVT_N edge, HVT_P edge, LVT_N edge, LVT_P edge, ULVT_N edge, ULVT_P edge, LFN_N edge, LFN_P edge, MTFUSE, CTOP >= 1.8um
 err1 = EXT OCOVL_FEOL GT_P96 < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_2_P2 {
@ OCOVL_FEOL space to DNW, NW, PSUB, AA, AR, GT, GT_P96, P2, SN, SP, DG, M0, M0G, M0C, V0, LOGO, INST, MARKS, MARKG, NODMF, OCCD, DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, V0DUB, EFUSE, RESNW, RESP1, RESP2, ESDIO2, DSTR, DIOMK2, DMPNP, VARMOS, LDBK, INDMY, FUSEMK1, NPAA, PPAA, AR_H, AR_V, CELLB edge, DIOMK1, ESDIO1, SVT_N edge, SVT_P edge, HVT_N edge, HVT_P edge, LVT_N edge, LVT_P edge, ULVT_N edge, ULVT_P edge, LFN_N edge, LFN_P edge, MTFUSE, CTOP >= 1.8um
 err1 = EXT OCOVL_FEOL P2 < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_2_SN {
@ OCOVL_FEOL space to DNW, NW, PSUB, AA, AR, GT, GT_P96, P2, SN, SP, DG, M0, M0G, M0C, V0, LOGO, INST, MARKS, MARKG, NODMF, OCCD, DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, V0DUB, EFUSE, RESNW, RESP1, RESP2, ESDIO2, DSTR, DIOMK2, DMPNP, VARMOS, LDBK, INDMY, FUSEMK1, NPAA, PPAA, AR_H, AR_V, CELLB edge, DIOMK1, ESDIO1, SVT_N edge, SVT_P edge, HVT_N edge, HVT_P edge, LVT_N edge, LVT_P edge, ULVT_N edge, ULVT_P edge, LFN_N edge, LFN_P edge, MTFUSE, CTOP >= 1.8um
 err1 = EXT OCOVL_FEOL SN < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_2_SP {
@ OCOVL_FEOL space to DNW, NW, PSUB, AA, AR, GT, GT_P96, P2, SN, SP, DG, M0, M0G, M0C, V0, LOGO, INST, MARKS, MARKG, NODMF, OCCD, DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, V0DUB, EFUSE, RESNW, RESP1, RESP2, ESDIO2, DSTR, DIOMK2, DMPNP, VARMOS, LDBK, INDMY, FUSEMK1, NPAA, PPAA, AR_H, AR_V, CELLB edge, DIOMK1, ESDIO1, SVT_N edge, SVT_P edge, HVT_N edge, HVT_P edge, LVT_N edge, LVT_P edge, ULVT_N edge, ULVT_P edge, LFN_N edge, LFN_P edge, MTFUSE, CTOP >= 1.8um
 err1 = EXT OCOVL_FEOL SP < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_2_DG {
@ OCOVL_FEOL space to DNW, NW, PSUB, AA, AR, GT, GT_P96, P2, SN, SP, DG, M0, M0G, M0C, V0, LOGO, INST, MARKS, MARKG, NODMF, OCCD, DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, V0DUB, EFUSE, RESNW, RESP1, RESP2, ESDIO2, DSTR, DIOMK2, DMPNP, VARMOS, LDBK, INDMY, FUSEMK1, NPAA, PPAA, AR_H, AR_V, CELLB edge, DIOMK1, ESDIO1, SVT_N edge, SVT_P edge, HVT_N edge, HVT_P edge, LVT_N edge, LVT_P edge, ULVT_N edge, ULVT_P edge, LFN_N edge, LFN_P edge, MTFUSE, CTOP >= 1.8um
 err1 = EXT OCOVL_FEOL DG < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_2_M0 {
@ OCOVL_FEOL space to DNW, NW, PSUB, AA, AR, GT, GT_P96, P2, SN, SP, DG, M0, M0G, M0C, V0, LOGO, INST, MARKS, MARKG, NODMF, OCCD, DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, V0DUB, EFUSE, RESNW, RESP1, RESP2, ESDIO2, DSTR, DIOMK2, DMPNP, VARMOS, LDBK, INDMY, FUSEMK1, NPAA, PPAA, AR_H, AR_V, CELLB edge, DIOMK1, ESDIO1, SVT_N edge, SVT_P edge, HVT_N edge, HVT_P edge, LVT_N edge, LVT_P edge, ULVT_N edge, ULVT_P edge, LFN_N edge, LFN_P edge, MTFUSE, CTOP >= 1.8um
 err1 = EXT OCOVL_FEOL M0 < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_2_M0G {
@ OCOVL_FEOL space to DNW, NW, PSUB, AA, AR, GT, GT_P96, P2, SN, SP, DG, M0, M0G, M0C, V0, LOGO, INST, MARKS, MARKG, NODMF, OCCD, DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, V0DUB, EFUSE, RESNW, RESP1, RESP2, ESDIO2, DSTR, DIOMK2, DMPNP, VARMOS, LDBK, INDMY, FUSEMK1, NPAA, PPAA, AR_H, AR_V, CELLB edge, DIOMK1, ESDIO1, SVT_N edge, SVT_P edge, HVT_N edge, HVT_P edge, LVT_N edge, LVT_P edge, ULVT_N edge, ULVT_P edge, LFN_N edge, LFN_P edge, MTFUSE, CTOP >= 1.8um
 err1 = EXT OCOVL_FEOL M0G < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_2_M0C {
@ OCOVL_FEOL space to DNW, NW, PSUB, AA, AR, GT, GT_P96, P2, SN, SP, DG, M0, M0G, M0C, V0, LOGO, INST, MARKS, MARKG, NODMF, OCCD, DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, V0DUB, EFUSE, RESNW, RESP1, RESP2, ESDIO2, DSTR, DIOMK2, DMPNP, VARMOS, LDBK, INDMY, FUSEMK1, NPAA, PPAA, AR_H, AR_V, CELLB edge, DIOMK1, ESDIO1, SVT_N edge, SVT_P edge, HVT_N edge, HVT_P edge, LVT_N edge, LVT_P edge, ULVT_N edge, ULVT_P edge, LFN_N edge, LFN_P edge, MTFUSE, CTOP >= 1.8um
 err1 = EXT OCOVL_FEOL M0C < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_2_V0 {
@ OCOVL_FEOL space to DNW, NW, PSUB, AA, AR, GT, GT_P96, P2, SN, SP, DG, M0, M0G, M0C, V0, LOGO, INST, MARKS, MARKG, NODMF, OCCD, DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, V0DUB, EFUSE, RESNW, RESP1, RESP2, ESDIO2, DSTR, DIOMK2, DMPNP, VARMOS, LDBK, INDMY, FUSEMK1, NPAA, PPAA, AR_H, AR_V, CELLB edge, DIOMK1, ESDIO1, SVT_N edge, SVT_P edge, HVT_N edge, HVT_P edge, LVT_N edge, LVT_P edge, ULVT_N edge, ULVT_P edge, LFN_N edge, LFN_P edge, MTFUSE, CTOP >= 1.8um
 err1 = EXT OCOVL_FEOL V0 < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_2_LOGO {
@ OCOVL_FEOL space to DNW, NW, PSUB, AA, AR, GT, GT_P96, P2, SN, SP, DG, M0, M0G, M0C, V0, LOGO, INST, MARKS, MARKG, NODMF, OCCD, DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, V0DUB, EFUSE, RESNW, RESP1, RESP2, ESDIO2, DSTR, DIOMK2, DMPNP, VARMOS, LDBK, INDMY, FUSEMK1, NPAA, PPAA, AR_H, AR_V, CELLB edge, DIOMK1, ESDIO1, SVT_N edge, SVT_P edge, HVT_N edge, HVT_P edge, LVT_N edge, LVT_P edge, ULVT_N edge, ULVT_P edge, LFN_N edge, LFN_P edge, MTFUSE, CTOP >= 1.8um
 err1 = EXT OCOVL_FEOL LOGO < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_2_INST {
@ OCOVL_FEOL space to DNW, NW, PSUB, AA, AR, GT, GT_P96, P2, SN, SP, DG, M0, M0G, M0C, V0, LOGO, INST, MARKS, MARKG, NODMF, OCCD, DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, V0DUB, EFUSE, RESNW, RESP1, RESP2, ESDIO2, DSTR, DIOMK2, DMPNP, VARMOS, LDBK, INDMY, FUSEMK1, NPAA, PPAA, AR_H, AR_V, CELLB edge, DIOMK1, ESDIO1, SVT_N edge, SVT_P edge, HVT_N edge, HVT_P edge, LVT_N edge, LVT_P edge, ULVT_N edge, ULVT_P edge, LFN_N edge, LFN_P edge, MTFUSE, CTOP >= 1.8um
 err1 = EXT OCOVL_FEOL INST < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_2_MARKS {
@ OCOVL_FEOL space to DNW, NW, PSUB, AA, AR, GT, GT_P96, P2, SN, SP, DG, M0, M0G, M0C, V0, LOGO, INST, MARKS, MARKG, NODMF, OCCD, DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, V0DUB, EFUSE, RESNW, RESP1, RESP2, ESDIO2, DSTR, DIOMK2, DMPNP, VARMOS, LDBK, INDMY, FUSEMK1, NPAA, PPAA, AR_H, AR_V, CELLB edge, DIOMK1, ESDIO1, SVT_N edge, SVT_P edge, HVT_N edge, HVT_P edge, LVT_N edge, LVT_P edge, ULVT_N edge, ULVT_P edge, LFN_N edge, LFN_P edge, MTFUSE, CTOP >= 1.8um
 err1 = EXT OCOVL_FEOL MARKS < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_2_MARKG {
@ OCOVL_FEOL space to DNW, NW, PSUB, AA, AR, GT, GT_P96, P2, SN, SP, DG, M0, M0G, M0C, V0, LOGO, INST, MARKS, MARKG, NODMF, OCCD, DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, V0DUB, EFUSE, RESNW, RESP1, RESP2, ESDIO2, DSTR, DIOMK2, DMPNP, VARMOS, LDBK, INDMY, FUSEMK1, NPAA, PPAA, AR_H, AR_V, CELLB edge, DIOMK1, ESDIO1, SVT_N edge, SVT_P edge, HVT_N edge, HVT_P edge, LVT_N edge, LVT_P edge, ULVT_N edge, ULVT_P edge, LFN_N edge, LFN_P edge, MTFUSE, CTOP >= 1.8um
 err1 = EXT OCOVL_FEOL MARKG < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_2_NODMF {
@ OCOVL_FEOL space to DNW, NW, PSUB, AA, AR, GT, GT_P96, P2, SN, SP, DG, M0, M0G, M0C, V0, LOGO, INST, MARKS, MARKG, NODMF, OCCD, DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, V0DUB, EFUSE, RESNW, RESP1, RESP2, ESDIO2, DSTR, DIOMK2, DMPNP, VARMOS, LDBK, INDMY, FUSEMK1, NPAA, PPAA, AR_H, AR_V, CELLB edge, DIOMK1, ESDIO1, SVT_N edge, SVT_P edge, HVT_N edge, HVT_P edge, LVT_N edge, LVT_P edge, ULVT_N edge, ULVT_P edge, LFN_N edge, LFN_P edge, MTFUSE, CTOP >= 1.8um
 err1 = EXT OCOVL_FEOL NODMF < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_2_OCCD {
@ OCOVL_FEOL space to DNW, NW, PSUB, AA, AR, GT, GT_P96, P2, SN, SP, DG, M0, M0G, M0C, V0, LOGO, INST, MARKS, MARKG, NODMF, OCCD, DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, V0DUB, EFUSE, RESNW, RESP1, RESP2, ESDIO2, DSTR, DIOMK2, DMPNP, VARMOS, LDBK, INDMY, FUSEMK1, NPAA, PPAA, AR_H, AR_V, CELLB edge, DIOMK1, ESDIO1, SVT_N edge, SVT_P edge, HVT_N edge, HVT_P edge, LVT_N edge, LVT_P edge, ULVT_N edge, ULVT_P edge, LFN_N edge, LFN_P edge, MTFUSE, CTOP >= 1.8um
 err1 = EXT OCOVL_FEOL OCCD < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_2_DUMBA {
@ OCOVL_FEOL space to DNW, NW, PSUB, AA, AR, GT, GT_P96, P2, SN, SP, DG, M0, M0G, M0C, V0, LOGO, INST, MARKS, MARKG, NODMF, OCCD, DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, V0DUB, EFUSE, RESNW, RESP1, RESP2, ESDIO2, DSTR, DIOMK2, DMPNP, VARMOS, LDBK, INDMY, FUSEMK1, NPAA, PPAA, AR_H, AR_V, CELLB edge, DIOMK1, ESDIO1, SVT_N edge, SVT_P edge, HVT_N edge, HVT_P edge, LVT_N edge, LVT_P edge, ULVT_N edge, ULVT_P edge, LFN_N edge, LFN_P edge, MTFUSE, CTOP >= 1.8um
 err1 = EXT OCOVL_FEOL DUMBA < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_2_DUMBP {
@ OCOVL_FEOL space to DNW, NW, PSUB, AA, AR, GT, GT_P96, P2, SN, SP, DG, M0, M0G, M0C, V0, LOGO, INST, MARKS, MARKG, NODMF, OCCD, DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, V0DUB, EFUSE, RESNW, RESP1, RESP2, ESDIO2, DSTR, DIOMK2, DMPNP, VARMOS, LDBK, INDMY, FUSEMK1, NPAA, PPAA, AR_H, AR_V, CELLB edge, DIOMK1, ESDIO1, SVT_N edge, SVT_P edge, HVT_N edge, HVT_P edge, LVT_N edge, LVT_P edge, ULVT_N edge, ULVT_P edge, LFN_N edge, LFN_P edge, MTFUSE, CTOP >= 1.8um
 err1 = EXT OCOVL_FEOL DUMBP < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_2_ARDUB {
@ OCOVL_FEOL space to DNW, NW, PSUB, AA, AR, GT, GT_P96, P2, SN, SP, DG, M0, M0G, M0C, V0, LOGO, INST, MARKS, MARKG, NODMF, OCCD, DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, V0DUB, EFUSE, RESNW, RESP1, RESP2, ESDIO2, DSTR, DIOMK2, DMPNP, VARMOS, LDBK, INDMY, FUSEMK1, NPAA, PPAA, AR_H, AR_V, CELLB edge, DIOMK1, ESDIO1, SVT_N edge, SVT_P edge, HVT_N edge, HVT_P edge, LVT_N edge, LVT_P edge, ULVT_N edge, ULVT_P edge, LFN_N edge, LFN_P edge, MTFUSE, CTOP >= 1.8um
 err1 = EXT OCOVL_FEOL ARDUB < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_2_P2DUB {
@ OCOVL_FEOL space to DNW, NW, PSUB, AA, AR, GT, GT_P96, P2, SN, SP, DG, M0, M0G, M0C, V0, LOGO, INST, MARKS, MARKG, NODMF, OCCD, DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, V0DUB, EFUSE, RESNW, RESP1, RESP2, ESDIO2, DSTR, DIOMK2, DMPNP, VARMOS, LDBK, INDMY, FUSEMK1, NPAA, PPAA, AR_H, AR_V, CELLB edge, DIOMK1, ESDIO1, SVT_N edge, SVT_P edge, HVT_N edge, HVT_P edge, LVT_N edge, LVT_P edge, ULVT_N edge, ULVT_P edge, LFN_N edge, LFN_P edge, MTFUSE, CTOP >= 1.8um
 err1 = EXT OCOVL_FEOL P2DUB < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_2_M0DUB {
@ OCOVL_FEOL space to DNW, NW, PSUB, AA, AR, GT, GT_P96, P2, SN, SP, DG, M0, M0G, M0C, V0, LOGO, INST, MARKS, MARKG, NODMF, OCCD, DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, V0DUB, EFUSE, RESNW, RESP1, RESP2, ESDIO2, DSTR, DIOMK2, DMPNP, VARMOS, LDBK, INDMY, FUSEMK1, NPAA, PPAA, AR_H, AR_V, CELLB edge, DIOMK1, ESDIO1, SVT_N edge, SVT_P edge, HVT_N edge, HVT_P edge, LVT_N edge, LVT_P edge, ULVT_N edge, ULVT_P edge, LFN_N edge, LFN_P edge, MTFUSE, CTOP >= 1.8um
 err1 = EXT OCOVL_FEOL M0DUB < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_2_M0CDUB {
@ OCOVL_FEOL space to DNW, NW, PSUB, AA, AR, GT, GT_P96, P2, SN, SP, DG, M0, M0G, M0C, V0, LOGO, INST, MARKS, MARKG, NODMF, OCCD, DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, V0DUB, EFUSE, RESNW, RESP1, RESP2, ESDIO2, DSTR, DIOMK2, DMPNP, VARMOS, LDBK, INDMY, FUSEMK1, NPAA, PPAA, AR_H, AR_V, CELLB edge, DIOMK1, ESDIO1, SVT_N edge, SVT_P edge, HVT_N edge, HVT_P edge, LVT_N edge, LVT_P edge, ULVT_N edge, ULVT_P edge, LFN_N edge, LFN_P edge, MTFUSE, CTOP >= 1.8um
 err1 = EXT OCOVL_FEOL M0CDUB < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_2_M0GDUB {
@ OCOVL_FEOL space to DNW, NW, PSUB, AA, AR, GT, GT_P96, P2, SN, SP, DG, M0, M0G, M0C, V0, LOGO, INST, MARKS, MARKG, NODMF, OCCD, DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, V0DUB, EFUSE, RESNW, RESP1, RESP2, ESDIO2, DSTR, DIOMK2, DMPNP, VARMOS, LDBK, INDMY, FUSEMK1, NPAA, PPAA, AR_H, AR_V, CELLB edge, DIOMK1, ESDIO1, SVT_N edge, SVT_P edge, HVT_N edge, HVT_P edge, LVT_N edge, LVT_P edge, ULVT_N edge, ULVT_P edge, LFN_N edge, LFN_P edge, MTFUSE, CTOP >= 1.8um
 err1 = EXT OCOVL_FEOL M0GDUB < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_2_V0DUB {
@ OCOVL_FEOL space to DNW, NW, PSUB, AA, AR, GT, GT_P96, P2, SN, SP, DG, M0, M0G, M0C, V0, LOGO, INST, MARKS, MARKG, NODMF, OCCD, DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, V0DUB, EFUSE, RESNW, RESP1, RESP2, ESDIO2, DSTR, DIOMK2, DMPNP, VARMOS, LDBK, INDMY, FUSEMK1, NPAA, PPAA, AR_H, AR_V, CELLB edge, DIOMK1, ESDIO1, SVT_N edge, SVT_P edge, HVT_N edge, HVT_P edge, LVT_N edge, LVT_P edge, ULVT_N edge, ULVT_P edge, LFN_N edge, LFN_P edge, MTFUSE, CTOP >= 1.8um
 err1 = EXT OCOVL_FEOL V0DUB < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_2_EFUSE {
@ OCOVL_FEOL space to DNW, NW, PSUB, AA, AR, GT, GT_P96, P2, SN, SP, DG, M0, M0G, M0C, V0, LOGO, INST, MARKS, MARKG, NODMF, OCCD, DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, V0DUB, EFUSE, RESNW, RESP1, RESP2, ESDIO2, DSTR, DIOMK2, DMPNP, VARMOS, LDBK, INDMY, FUSEMK1, NPAA, PPAA, AR_H, AR_V, CELLB edge, DIOMK1, ESDIO1, SVT_N edge, SVT_P edge, HVT_N edge, HVT_P edge, LVT_N edge, LVT_P edge, ULVT_N edge, ULVT_P edge, LFN_N edge, LFN_P edge, MTFUSE, CTOP >= 1.8um
 err1 = EXT OCOVL_FEOL EFUSE < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_2_RESNW {
@ OCOVL_FEOL space to DNW, NW, PSUB, AA, AR, GT, GT_P96, P2, SN, SP, DG, M0, M0G, M0C, V0, LOGO, INST, MARKS, MARKG, NODMF, OCCD, DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, V0DUB, EFUSE, RESNW, RESP1, RESP2, ESDIO2, DSTR, DIOMK2, DMPNP, VARMOS, LDBK, INDMY, FUSEMK1, NPAA, PPAA, AR_H, AR_V, CELLB edge, DIOMK1, ESDIO1, SVT_N edge, SVT_P edge, HVT_N edge, HVT_P edge, LVT_N edge, LVT_P edge, ULVT_N edge, ULVT_P edge, LFN_N edge, LFN_P edge, MTFUSE, CTOP >= 1.8um
 err1 = EXT OCOVL_FEOL RESNW < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_2_RESP1 {
@ OCOVL_FEOL space to DNW, NW, PSUB, AA, AR, GT, GT_P96, P2, SN, SP, DG, M0, M0G, M0C, V0, LOGO, INST, MARKS, MARKG, NODMF, OCCD, DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, V0DUB, EFUSE, RESNW, RESP1, RESP2, ESDIO2, DSTR, DIOMK2, DMPNP, VARMOS, LDBK, INDMY, FUSEMK1, NPAA, PPAA, AR_H, AR_V, CELLB edge, DIOMK1, ESDIO1, SVT_N edge, SVT_P edge, HVT_N edge, HVT_P edge, LVT_N edge, LVT_P edge, ULVT_N edge, ULVT_P edge, LFN_N edge, LFN_P edge, MTFUSE, CTOP >= 1.8um
 err1 = EXT OCOVL_FEOL RESP1 < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_2_RESP2 {
@ OCOVL_FEOL space to DNW, NW, PSUB, AA, AR, GT, GT_P96, P2, SN, SP, DG, M0, M0G, M0C, V0, LOGO, INST, MARKS, MARKG, NODMF, OCCD, DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, V0DUB, EFUSE, RESNW, RESP1, RESP2, ESDIO2, DSTR, DIOMK2, DMPNP, VARMOS, LDBK, INDMY, FUSEMK1, NPAA, PPAA, AR_H, AR_V, CELLB edge, DIOMK1, ESDIO1, SVT_N edge, SVT_P edge, HVT_N edge, HVT_P edge, LVT_N edge, LVT_P edge, ULVT_N edge, ULVT_P edge, LFN_N edge, LFN_P edge, MTFUSE, CTOP >= 1.8um
 err1 = EXT OCOVL_FEOL RESP2 < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_2_ESDIO2 {
@ OCOVL_FEOL space to DNW, NW, PSUB, AA, AR, GT, GT_P96, P2, SN, SP, DG, M0, M0G, M0C, V0, LOGO, INST, MARKS, MARKG, NODMF, OCCD, DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, V0DUB, EFUSE, RESNW, RESP1, RESP2, ESDIO2, DSTR, DIOMK2, DMPNP, VARMOS, LDBK, INDMY, FUSEMK1, NPAA, PPAA, AR_H, AR_V, CELLB edge, DIOMK1, ESDIO1, SVT_N edge, SVT_P edge, HVT_N edge, HVT_P edge, LVT_N edge, LVT_P edge, ULVT_N edge, ULVT_P edge, LFN_N edge, LFN_P edge, MTFUSE, CTOP >= 1.8um
 err1 = EXT OCOVL_FEOL ESDIO2 < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_2_DSTR {
@ OCOVL_FEOL space to DNW, NW, PSUB, AA, AR, GT, GT_P96, P2, SN, SP, DG, M0, M0G, M0C, V0, LOGO, INST, MARKS, MARKG, NODMF, OCCD, DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, V0DUB, EFUSE, RESNW, RESP1, RESP2, ESDIO2, DSTR, DIOMK2, DMPNP, VARMOS, LDBK, INDMY, FUSEMK1, NPAA, PPAA, AR_H, AR_V, CELLB edge, DIOMK1, ESDIO1, SVT_N edge, SVT_P edge, HVT_N edge, HVT_P edge, LVT_N edge, LVT_P edge, ULVT_N edge, ULVT_P edge, LFN_N edge, LFN_P edge, MTFUSE, CTOP >= 1.8um
 err1 = EXT OCOVL_FEOL DSTR < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_2_DIOMK2 {
@ OCOVL_FEOL space to DNW, NW, PSUB, AA, AR, GT, GT_P96, P2, SN, SP, DG, M0, M0G, M0C, V0, LOGO, INST, MARKS, MARKG, NODMF, OCCD, DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, V0DUB, EFUSE, RESNW, RESP1, RESP2, ESDIO2, DSTR, DIOMK2, DMPNP, VARMOS, LDBK, INDMY, FUSEMK1, NPAA, PPAA, AR_H, AR_V, CELLB edge, DIOMK1, ESDIO1, SVT_N edge, SVT_P edge, HVT_N edge, HVT_P edge, LVT_N edge, LVT_P edge, ULVT_N edge, ULVT_P edge, LFN_N edge, LFN_P edge, MTFUSE, CTOP >= 1.8um
 err1 = EXT OCOVL_FEOL DIOMK2 < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_2_DMPNP {
@ OCOVL_FEOL space to DNW, NW, PSUB, AA, AR, GT, GT_P96, P2, SN, SP, DG, M0, M0G, M0C, V0, LOGO, INST, MARKS, MARKG, NODMF, OCCD, DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, V0DUB, EFUSE, RESNW, RESP1, RESP2, ESDIO2, DSTR, DIOMK2, DMPNP, VARMOS, LDBK, INDMY, FUSEMK1, NPAA, PPAA, AR_H, AR_V, CELLB edge, DIOMK1, ESDIO1, SVT_N edge, SVT_P edge, HVT_N edge, HVT_P edge, LVT_N edge, LVT_P edge, ULVT_N edge, ULVT_P edge, LFN_N edge, LFN_P edge, MTFUSE, CTOP >= 1.8um
 err1 = EXT OCOVL_FEOL DMPNP < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_2_VARMOS {
@ OCOVL_FEOL space to DNW, NW, PSUB, AA, AR, GT, GT_P96, P2, SN, SP, DG, M0, M0G, M0C, V0, LOGO, INST, MARKS, MARKG, NODMF, OCCD, DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, V0DUB, EFUSE, RESNW, RESP1, RESP2, ESDIO2, DSTR, DIOMK2, DMPNP, VARMOS, LDBK, INDMY, FUSEMK1, NPAA, PPAA, AR_H, AR_V, CELLB edge, DIOMK1, ESDIO1, SVT_N edge, SVT_P edge, HVT_N edge, HVT_P edge, LVT_N edge, LVT_P edge, ULVT_N edge, ULVT_P edge, LFN_N edge, LFN_P edge, MTFUSE, CTOP >= 1.8um
 err1 = EXT OCOVL_FEOL VARMOS < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_2_LDBK {
@ OCOVL_FEOL space to DNW, NW, PSUB, AA, AR, GT, GT_P96, P2, SN, SP, DG, M0, M0G, M0C, V0, LOGO, INST, MARKS, MARKG, NODMF, OCCD, DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, V0DUB, EFUSE, RESNW, RESP1, RESP2, ESDIO2, DSTR, DIOMK2, DMPNP, VARMOS, LDBK, INDMY, FUSEMK1, NPAA, PPAA, AR_H, AR_V, CELLB edge, DIOMK1, ESDIO1, SVT_N edge, SVT_P edge, HVT_N edge, HVT_P edge, LVT_N edge, LVT_P edge, ULVT_N edge, ULVT_P edge, LFN_N edge, LFN_P edge, MTFUSE, CTOP >= 1.8um
 err1 = EXT OCOVL_FEOL LDBK < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_2_INDMY {
@ OCOVL_FEOL space to DNW, NW, PSUB, AA, AR, GT, GT_P96, P2, SN, SP, DG, M0, M0G, M0C, V0, LOGO, INST, MARKS, MARKG, NODMF, OCCD, DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, V0DUB, EFUSE, RESNW, RESP1, RESP2, ESDIO2, DSTR, DIOMK2, DMPNP, VARMOS, LDBK, INDMY, FUSEMK1, NPAA, PPAA, AR_H, AR_V, CELLB edge, DIOMK1, ESDIO1, SVT_N edge, SVT_P edge, HVT_N edge, HVT_P edge, LVT_N edge, LVT_P edge, ULVT_N edge, ULVT_P edge, LFN_N edge, LFN_P edge, MTFUSE, CTOP >= 1.8um
 err1 = EXT OCOVL_FEOL INDMY < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_2_FUSEMK1 {
@ OCOVL_FEOL space to DNW, NW, PSUB, AA, AR, GT, GT_P96, P2, SN, SP, DG, M0, M0G, M0C, V0, LOGO, INST, MARKS, MARKG, NODMF, OCCD, DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, V0DUB, EFUSE, RESNW, RESP1, RESP2, ESDIO2, DSTR, DIOMK2, DMPNP, VARMOS, LDBK, INDMY, FUSEMK1, NPAA, PPAA, AR_H, AR_V, CELLB edge, DIOMK1, ESDIO1, SVT_N edge, SVT_P edge, HVT_N edge, HVT_P edge, LVT_N edge, LVT_P edge, ULVT_N edge, ULVT_P edge, LFN_N edge, LFN_P edge, MTFUSE, CTOP >= 1.8um
 err1 = EXT OCOVL_FEOL FUSEMK1 < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_2_NPAA {
@ OCOVL_FEOL space to DNW, NW, PSUB, AA, AR, GT, GT_P96, P2, SN, SP, DG, M0, M0G, M0C, V0, LOGO, INST, MARKS, MARKG, NODMF, OCCD, DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, V0DUB, EFUSE, RESNW, RESP1, RESP2, ESDIO2, DSTR, DIOMK2, DMPNP, VARMOS, LDBK, INDMY, FUSEMK1, NPAA, PPAA, AR_H, AR_V, CELLB edge, DIOMK1, ESDIO1, SVT_N edge, SVT_P edge, HVT_N edge, HVT_P edge, LVT_N edge, LVT_P edge, ULVT_N edge, ULVT_P edge, LFN_N edge, LFN_P edge, MTFUSE, CTOP >= 1.8um
 err1 = EXT OCOVL_FEOL NPAA < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_2_PPAA {
@ OCOVL_FEOL space to DNW, NW, PSUB, AA, AR, GT, GT_P96, P2, SN, SP, DG, M0, M0G, M0C, V0, LOGO, INST, MARKS, MARKG, NODMF, OCCD, DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, V0DUB, EFUSE, RESNW, RESP1, RESP2, ESDIO2, DSTR, DIOMK2, DMPNP, VARMOS, LDBK, INDMY, FUSEMK1, NPAA, PPAA, AR_H, AR_V, CELLB edge, DIOMK1, ESDIO1, SVT_N edge, SVT_P edge, HVT_N edge, HVT_P edge, LVT_N edge, LVT_P edge, ULVT_N edge, ULVT_P edge, LFN_N edge, LFN_P edge, MTFUSE, CTOP >= 1.8um
 err1 = EXT OCOVL_FEOL PPAA < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_2_AR_H {
@ OCOVL_FEOL space to DNW, NW, PSUB, AA, AR, GT, GT_P96, P2, SN, SP, DG, M0, M0G, M0C, V0, LOGO, INST, MARKS, MARKG, NODMF, OCCD, DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, V0DUB, EFUSE, RESNW, RESP1, RESP2, ESDIO2, DSTR, DIOMK2, DMPNP, VARMOS, LDBK, INDMY, FUSEMK1, NPAA, PPAA, AR_H, AR_V, CELLB edge, DIOMK1, ESDIO1, SVT_N edge, SVT_P edge, HVT_N edge, HVT_P edge, LVT_N edge, LVT_P edge, ULVT_N edge, ULVT_P edge, LFN_N edge, LFN_P edge, MTFUSE, CTOP >= 1.8um
 err1 = EXT OCOVL_FEOL AR_H < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_2_AR_V {
@ OCOVL_FEOL space to DNW, NW, PSUB, AA, AR, GT, GT_P96, P2, SN, SP, DG, M0, M0G, M0C, V0, LOGO, INST, MARKS, MARKG, NODMF, OCCD, DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, V0DUB, EFUSE, RESNW, RESP1, RESP2, ESDIO2, DSTR, DIOMK2, DMPNP, VARMOS, LDBK, INDMY, FUSEMK1, NPAA, PPAA, AR_H, AR_V, CELLB edge, DIOMK1, ESDIO1, SVT_N edge, SVT_P edge, HVT_N edge, HVT_P edge, LVT_N edge, LVT_P edge, ULVT_N edge, ULVT_P edge, LFN_N edge, LFN_P edge, MTFUSE, CTOP >= 1.8um
 err1 = EXT OCOVL_FEOL AR_V < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_2_DIOMK1 {
@ OCOVL_FEOL space to DNW, NW, PSUB, AA, AR, GT, GT_P96, P2, SN, SP, DG, M0, M0G, M0C, V0, LOGO, INST, MARKS, MARKG, NODMF, OCCD, DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, V0DUB, EFUSE, RESNW, RESP1, RESP2, ESDIO2, DSTR, DIOMK2, DMPNP, VARMOS, LDBK, INDMY, FUSEMK1, NPAA, PPAA, AR_H, AR_V, CELLB edge, DIOMK1, ESDIO1, SVT_N edge, SVT_P edge, HVT_N edge, HVT_P edge, LVT_N edge, LVT_P edge, ULVT_N edge, ULVT_P edge, LFN_N edge, LFN_P edge, MTFUSE, CTOP >= 1.8um
 err1 = EXT OCOVL_FEOL DIOMK1 < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_2_ESDIO1 {
@ OCOVL_FEOL space to DNW, NW, PSUB, AA, AR, GT, GT_P96, P2, SN, SP, DG, M0, M0G, M0C, V0, LOGO, INST, MARKS, MARKG, NODMF, OCCD, DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, V0DUB, EFUSE, RESNW, RESP1, RESP2, ESDIO2, DSTR, DIOMK2, DMPNP, VARMOS, LDBK, INDMY, FUSEMK1, NPAA, PPAA, AR_H, AR_V, CELLB edge, DIOMK1, ESDIO1, SVT_N edge, SVT_P edge, HVT_N edge, HVT_P edge, LVT_N edge, LVT_P edge, ULVT_N edge, ULVT_P edge, LFN_N edge, LFN_P edge, MTFUSE, CTOP >= 1.8um
 err1 = EXT OCOVL_FEOL ESDIO1 < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_2_MTFUSE {
@ OCOVL_FEOL space to DNW, NW, PSUB, AA, AR, GT, GT_P96, P2, SN, SP, DG, M0, M0G, M0C, V0, LOGO, INST, MARKS, MARKG, NODMF, OCCD, DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, V0DUB, EFUSE, RESNW, RESP1, RESP2, ESDIO2, DSTR, DIOMK2, DMPNP, VARMOS, LDBK, INDMY, FUSEMK1, NPAA, PPAA, AR_H, AR_V, CELLB edge, DIOMK1, ESDIO1, SVT_N edge, SVT_P edge, HVT_N edge, HVT_P edge, LVT_N edge, LVT_P edge, ULVT_N edge, ULVT_P edge, LFN_N edge, LFN_P edge, MTFUSE, CTOP >= 1.8um
 err1 = EXT OCOVL_FEOL MTFUSE < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_2_CTOP {
@ OCOVL_FEOL space to DNW, NW, PSUB, AA, AR, GT, GT_P96, P2, SN, SP, DG, M0, M0G, M0C, V0, LOGO, INST, MARKS, MARKG, NODMF, OCCD, DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, V0DUB, EFUSE, RESNW, RESP1, RESP2, ESDIO2, DSTR, DIOMK2, DMPNP, VARMOS, LDBK, INDMY, FUSEMK1, NPAA, PPAA, AR_H, AR_V, CELLB edge, DIOMK1, ESDIO1, SVT_N edge, SVT_P edge, HVT_N edge, HVT_P edge, LVT_N edge, LVT_P edge, ULVT_N edge, ULVT_P edge, LFN_N edge, LFN_P edge, MTFUSE, CTOP >= 1.8um
 err1 = EXT OCOVL_FEOL CTOP < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_2_CELLB {
@ OCOVL_FEOL space to DNW, NW, PSUB, AA, AR, GT, GT_P96, P2, SN, SP, DG, M0, M0G, M0C, V0, LOGO, INST, MARKS, MARKG, NODMF, OCCD, DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, V0DUB, EFUSE, RESNW, RESP1, RESP2, ESDIO2, DSTR, DIOMK2, DMPNP, VARMOS, LDBK, INDMY, FUSEMK1, NPAA, PPAA, AR_H, AR_V, CELLB edge, DIOMK1, ESDIO1, SVT_N edge, SVT_P edge, HVT_N edge, HVT_P edge, LVT_N edge, LVT_P edge, ULVT_N edge, ULVT_P edge, LFN_N edge, LFN_P edge, MTFUSE, CTOP >= 1.8um
 err1 = OCOVL_FEOL AND ((SIZE CELLB BY 1.8) NOT (SIZE CELLB BY -1.8))
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_2_SVT_N {
@ OCOVL_FEOL space to DNW, NW, PSUB, AA, AR, GT, GT_P96, P2, SN, SP, DG, M0, M0G, M0C, V0, LOGO, INST, MARKS, MARKG, NODMF, OCCD, DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, V0DUB, EFUSE, RESNW, RESP1, RESP2, ESDIO2, DSTR, DIOMK2, DMPNP, VARMOS, LDBK, INDMY, FUSEMK1, NPAA, PPAA, AR_H, AR_V, CELLB edge, DIOMK1, ESDIO1, SVT_N edge, SVT_P edge, HVT_N edge, HVT_P edge, LVT_N edge, LVT_P edge, ULVT_N edge, ULVT_P edge, LFN_N edge, LFN_P edge, MTFUSE, CTOP >= 1.8um
 err1 = OCOVL_FEOL AND ((SIZE SVT_N BY 1.8) NOT (SIZE SVT_N BY -1.8))
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_2_SVT_P {
@ OCOVL_FEOL space to DNW, NW, PSUB, AA, AR, GT, GT_P96, P2, SN, SP, DG, M0, M0G, M0C, V0, LOGO, INST, MARKS, MARKG, NODMF, OCCD, DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, V0DUB, EFUSE, RESNW, RESP1, RESP2, ESDIO2, DSTR, DIOMK2, DMPNP, VARMOS, LDBK, INDMY, FUSEMK1, NPAA, PPAA, AR_H, AR_V, CELLB edge, DIOMK1, ESDIO1, SVT_N edge, SVT_P edge, HVT_N edge, HVT_P edge, LVT_N edge, LVT_P edge, ULVT_N edge, ULVT_P edge, LFN_N edge, LFN_P edge, MTFUSE, CTOP >= 1.8um
 err1 = OCOVL_FEOL AND ((SIZE SVT_P BY 1.8) NOT (SIZE SVT_P BY -1.8))
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_2_HVT_N {
@ OCOVL_FEOL space to DNW, NW, PSUB, AA, AR, GT, GT_P96, P2, SN, SP, DG, M0, M0G, M0C, V0, LOGO, INST, MARKS, MARKG, NODMF, OCCD, DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, V0DUB, EFUSE, RESNW, RESP1, RESP2, ESDIO2, DSTR, DIOMK2, DMPNP, VARMOS, LDBK, INDMY, FUSEMK1, NPAA, PPAA, AR_H, AR_V, CELLB edge, DIOMK1, ESDIO1, SVT_N edge, SVT_P edge, HVT_N edge, HVT_P edge, LVT_N edge, LVT_P edge, ULVT_N edge, ULVT_P edge, LFN_N edge, LFN_P edge, MTFUSE, CTOP >= 1.8um
 err1 = OCOVL_FEOL AND ((SIZE HVT_N BY 1.8) NOT (SIZE HVT_N BY -1.8))
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_2_HVT_P {
@ OCOVL_FEOL space to DNW, NW, PSUB, AA, AR, GT, GT_P96, P2, SN, SP, DG, M0, M0G, M0C, V0, LOGO, INST, MARKS, MARKG, NODMF, OCCD, DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, V0DUB, EFUSE, RESNW, RESP1, RESP2, ESDIO2, DSTR, DIOMK2, DMPNP, VARMOS, LDBK, INDMY, FUSEMK1, NPAA, PPAA, AR_H, AR_V, CELLB edge, DIOMK1, ESDIO1, SVT_N edge, SVT_P edge, HVT_N edge, HVT_P edge, LVT_N edge, LVT_P edge, ULVT_N edge, ULVT_P edge, LFN_N edge, LFN_P edge, MTFUSE, CTOP >= 1.8um
 err1 = OCOVL_FEOL AND ((SIZE HVT_P BY 1.8) NOT (SIZE HVT_P BY -1.8))
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_2_LVT_N {
@ OCOVL_FEOL space to DNW, NW, PSUB, AA, AR, GT, GT_P96, P2, SN, SP, DG, M0, M0G, M0C, V0, LOGO, INST, MARKS, MARKG, NODMF, OCCD, DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, V0DUB, EFUSE, RESNW, RESP1, RESP2, ESDIO2, DSTR, DIOMK2, DMPNP, VARMOS, LDBK, INDMY, FUSEMK1, NPAA, PPAA, AR_H, AR_V, CELLB edge, DIOMK1, ESDIO1, SVT_N edge, SVT_P edge, HVT_N edge, HVT_P edge, LVT_N edge, LVT_P edge, ULVT_N edge, ULVT_P edge, LFN_N edge, LFN_P edge, MTFUSE, CTOP >= 1.8um
 err1 = OCOVL_FEOL AND ((SIZE LVT_N BY 1.8) NOT (SIZE LVT_N BY -1.8))
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_2_LVT_P {
@ OCOVL_FEOL space to DNW, NW, PSUB, AA, AR, GT, GT_P96, P2, SN, SP, DG, M0, M0G, M0C, V0, LOGO, INST, MARKS, MARKG, NODMF, OCCD, DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, V0DUB, EFUSE, RESNW, RESP1, RESP2, ESDIO2, DSTR, DIOMK2, DMPNP, VARMOS, LDBK, INDMY, FUSEMK1, NPAA, PPAA, AR_H, AR_V, CELLB edge, DIOMK1, ESDIO1, SVT_N edge, SVT_P edge, HVT_N edge, HVT_P edge, LVT_N edge, LVT_P edge, ULVT_N edge, ULVT_P edge, LFN_N edge, LFN_P edge, MTFUSE, CTOP >= 1.8um
 err1 = OCOVL_FEOL AND ((SIZE LVT_P BY 1.8) NOT (SIZE LVT_P BY -1.8))
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_2_ULVT_N {
@ OCOVL_FEOL space to DNW, NW, PSUB, AA, AR, GT, GT_P96, P2, SN, SP, DG, M0, M0G, M0C, V0, LOGO, INST, MARKS, MARKG, NODMF, OCCD, DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, V0DUB, EFUSE, RESNW, RESP1, RESP2, ESDIO2, DSTR, DIOMK2, DMPNP, VARMOS, LDBK, INDMY, FUSEMK1, NPAA, PPAA, AR_H, AR_V, CELLB edge, DIOMK1, ESDIO1, SVT_N edge, SVT_P edge, HVT_N edge, HVT_P edge, LVT_N edge, LVT_P edge, ULVT_N edge, ULVT_P edge, LFN_N edge, LFN_P edge, MTFUSE, CTOP >= 1.8um
 err1 = OCOVL_FEOL AND ((SIZE ULVT_N BY 1.8) NOT (SIZE ULVT_N BY -1.8))
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_2_ULVT_P {
@ OCOVL_FEOL space to DNW, NW, PSUB, AA, AR, GT, GT_P96, P2, SN, SP, DG, M0, M0G, M0C, V0, LOGO, INST, MARKS, MARKG, NODMF, OCCD, DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, V0DUB, EFUSE, RESNW, RESP1, RESP2, ESDIO2, DSTR, DIOMK2, DMPNP, VARMOS, LDBK, INDMY, FUSEMK1, NPAA, PPAA, AR_H, AR_V, CELLB edge, DIOMK1, ESDIO1, SVT_N edge, SVT_P edge, HVT_N edge, HVT_P edge, LVT_N edge, LVT_P edge, ULVT_N edge, ULVT_P edge, LFN_N edge, LFN_P edge, MTFUSE, CTOP >= 1.8um
 err1 = OCOVL_FEOL AND ((SIZE ULVT_P BY 1.8) NOT (SIZE ULVT_P BY -1.8))
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_2_LFN_N {
@ OCOVL_FEOL space to DNW, NW, PSUB, AA, AR, GT, GT_P96, P2, SN, SP, DG, M0, M0G, M0C, V0, LOGO, INST, MARKS, MARKG, NODMF, OCCD, DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, V0DUB, EFUSE, RESNW, RESP1, RESP2, ESDIO2, DSTR, DIOMK2, DMPNP, VARMOS, LDBK, INDMY, FUSEMK1, NPAA, PPAA, AR_H, AR_V, CELLB edge, DIOMK1, ESDIO1, SVT_N edge, SVT_P edge, HVT_N edge, HVT_P edge, LVT_N edge, LVT_P edge, ULVT_N edge, ULVT_P edge, LFN_N edge, LFN_P edge, MTFUSE, CTOP >= 1.8um
 err1 = OCOVL_FEOL AND ((SIZE LFN_N BY 1.8) NOT (SIZE LFN_N BY -1.8))
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_2_LFN_P {
@ OCOVL_FEOL space to DNW, NW, PSUB, AA, AR, GT, GT_P96, P2, SN, SP, DG, M0, M0G, M0C, V0, LOGO, INST, MARKS, MARKG, NODMF, OCCD, DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, V0DUB, EFUSE, RESNW, RESP1, RESP2, ESDIO2, DSTR, DIOMK2, DMPNP, VARMOS, LDBK, INDMY, FUSEMK1, NPAA, PPAA, AR_H, AR_V, CELLB edge, DIOMK1, ESDIO1, SVT_N edge, SVT_P edge, HVT_N edge, HVT_P edge, LVT_N edge, LVT_P edge, ULVT_N edge, ULVT_P edge, LFN_N edge, LFN_P edge, MTFUSE, CTOP >= 1.8um
 err1 = OCOVL_FEOL AND ((SIZE LFN_P BY 1.8) NOT (SIZE LFN_P BY -1.8))
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_3_DUM_AA {
@ OCOVL_FEOL space to DUM_AA, DUM_AR, DUM_GT, DUM_P2, DUM_M0, DUM_M0C, DUM_M0G, DUM_V0, SNDUM, SPDUM, AR_HDOP, AR_VDOP >= 0.4um
 err1 = EXT OCOVL_FEOL DUM_AA < 0.4 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_3_DUM_AR {
@ OCOVL_FEOL space to DUM_AA, DUM_AR, DUM_GT, DUM_P2, DUM_M0, DUM_M0C, DUM_M0G, DUM_V0, SNDUM, SPDUM, AR_HDOP, AR_VDOP >= 0.4um
 err1 = EXT OCOVL_FEOL DUM_AR < 0.4 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_3_DUM_GT {
@ OCOVL_FEOL space to DUM_AA, DUM_AR, DUM_GT, DUM_P2, DUM_M0, DUM_M0C, DUM_M0G, DUM_V0, SNDUM, SPDUM, AR_HDOP, AR_VDOP >= 0.4um
 err1 = EXT OCOVL_FEOL DUM_GT < 0.4 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_3_DUM_P2 {
@ OCOVL_FEOL space to DUM_AA, DUM_AR, DUM_GT, DUM_P2, DUM_M0, DUM_M0C, DUM_M0G, DUM_V0, SNDUM, SPDUM, AR_HDOP, AR_VDOP >= 0.4um
 err1 = EXT OCOVL_FEOL DUM_P2 < 0.4 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_3_DUM_M0 {
@ OCOVL_FEOL space to DUM_AA, DUM_AR, DUM_GT, DUM_P2, DUM_M0, DUM_M0C, DUM_M0G, DUM_V0, SNDUM, SPDUM, AR_HDOP, AR_VDOP >= 0.4um
 err1 = EXT OCOVL_FEOL DUM_M0 < 0.4 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_3_DUM_M0C {
@ OCOVL_FEOL space to DUM_AA, DUM_AR, DUM_GT, DUM_P2, DUM_M0, DUM_M0C, DUM_M0G, DUM_V0, SNDUM, SPDUM, AR_HDOP, AR_VDOP >= 0.4um
 err1 = EXT OCOVL_FEOL DUM_M0C < 0.4 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_3_DUM_M0G {
@ OCOVL_FEOL space to DUM_AA, DUM_AR, DUM_GT, DUM_P2, DUM_M0, DUM_M0C, DUM_M0G, DUM_V0, SNDUM, SPDUM, AR_HDOP, AR_VDOP >= 0.4um
 err1 = EXT OCOVL_FEOL DUM_M0G < 0.4 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_3_DUM_V0 {
@ OCOVL_FEOL space to DUM_AA, DUM_AR, DUM_GT, DUM_P2, DUM_M0, DUM_M0C, DUM_M0G, DUM_V0, SNDUM, SPDUM, AR_HDOP, AR_VDOP >= 0.4um
 err1 = EXT OCOVL_FEOL DUM_V0 < 0.4 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_3_SNDUM {
@ OCOVL_FEOL space to DUM_AA, DUM_AR, DUM_GT, DUM_P2, DUM_M0, DUM_M0C, DUM_M0G, DUM_V0, SNDUM, SPDUM, AR_HDOP, AR_VDOP >= 0.4um
 err1 = EXT OCOVL_FEOL SNDUM < 0.4 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_3_SPDUM {
@ OCOVL_FEOL space to DUM_AA, DUM_AR, DUM_GT, DUM_P2, DUM_M0, DUM_M0C, DUM_M0G, DUM_V0, SNDUM, SPDUM, AR_HDOP, AR_VDOP >= 0.4um
 err1 = EXT OCOVL_FEOL SPDUM < 0.4 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_3_AR_HDOP {
@ OCOVL_FEOL space to DUM_AA, DUM_AR, DUM_GT, DUM_P2, DUM_M0, DUM_M0C, DUM_M0G, DUM_V0, SNDUM, SPDUM, AR_HDOP, AR_VDOP >= 0.4um
 err1 = EXT OCOVL_FEOL AR_HDOP < 0.4 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_3_AR_VDOP {
@ OCOVL_FEOL space to DUM_AA, DUM_AR, DUM_GT, DUM_P2, DUM_M0, DUM_M0C, DUM_M0G, DUM_V0, SNDUM, SPDUM, AR_HDOP, AR_VDOP >= 0.4um
 err1 = EXT OCOVL_FEOL AR_VDOP < 0.4 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_4_AA {
@ OCOVLM1CA space to AA, M1, M0, GT, M0C, M0G, INDMY, INST, LOGO, MARKS, MARKG, NODMF, OCCD, MTFUSE, MOMDMY, FUSEMK1, DUMBA, M1DUB, M0DUB, DUMBP, M0CDUB, M0GDUB, CTOP >= 1.8um
 err1 = EXT OCOVLM1CA AA < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_4_M1 {
@ OCOVLM1CA space to AA, M1, M0, GT, M0C, M0G, INDMY, INST, LOGO, MARKS, MARKG, NODMF, OCCD, MTFUSE, MOMDMY, FUSEMK1, DUMBA, M1DUB, M0DUB, DUMBP, M0CDUB, M0GDUB, CTOP >= 1.8um
 err1 = EXT OCOVLM1CA M1 < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_4_M0 {
@ OCOVLM1CA space to AA, M1, M0, GT, M0C, M0G, INDMY, INST, LOGO, MARKS, MARKG, NODMF, OCCD, MTFUSE, MOMDMY, FUSEMK1, DUMBA, M1DUB, M0DUB, DUMBP, M0CDUB, M0GDUB, CTOP >= 1.8um
 err1 = EXT OCOVLM1CA M0 < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_4_GT {
@ OCOVLM1CA space to AA, M1, M0, GT, M0C, M0G, INDMY, INST, LOGO, MARKS, MARKG, NODMF, OCCD, MTFUSE, MOMDMY, FUSEMK1, DUMBA, M1DUB, M0DUB, DUMBP, M0CDUB, M0GDUB, CTOP >= 1.8um
 err1 = EXT OCOVLM1CA GT < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_4_M0C {
@ OCOVLM1CA space to AA, M1, M0, GT, M0C, M0G, INDMY, INST, LOGO, MARKS, MARKG, NODMF, OCCD, MTFUSE, MOMDMY, FUSEMK1, DUMBA, M1DUB, M0DUB, DUMBP, M0CDUB, M0GDUB, CTOP >= 1.8um
 err1 = EXT OCOVLM1CA M0C < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_4_M0G {
@ OCOVLM1CA space to AA, M1, M0, GT, M0C, M0G, INDMY, INST, LOGO, MARKS, MARKG, NODMF, OCCD, MTFUSE, MOMDMY, FUSEMK1, DUMBA, M1DUB, M0DUB, DUMBP, M0CDUB, M0GDUB, CTOP >= 1.8um
 err1 = EXT OCOVLM1CA M0G < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_4_INDMY {
@ OCOVLM1CA space to AA, M1, M0, GT, M0C, M0G, INDMY, INST, LOGO, MARKS, MARKG, NODMF, OCCD, MTFUSE, MOMDMY, FUSEMK1, DUMBA, M1DUB, M0DUB, DUMBP, M0CDUB, M0GDUB, CTOP >= 1.8um
 err1 = EXT OCOVLM1CA INDMY < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_4_INST {
@ OCOVLM1CA space to AA, M1, M0, GT, M0C, M0G, INDMY, INST, LOGO, MARKS, MARKG, NODMF, OCCD, MTFUSE, MOMDMY, FUSEMK1, DUMBA, M1DUB, M0DUB, DUMBP, M0CDUB, M0GDUB, CTOP >= 1.8um
 err1 = EXT OCOVLM1CA INST < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_4_LOGO {
@ OCOVLM1CA space to AA, M1, M0, GT, M0C, M0G, INDMY, INST, LOGO, MARKS, MARKG, NODMF, OCCD, MTFUSE, MOMDMY, FUSEMK1, DUMBA, M1DUB, M0DUB, DUMBP, M0CDUB, M0GDUB, CTOP >= 1.8um
 err1 = EXT OCOVLM1CA LOGO < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_4_MARKS {
@ OCOVLM1CA space to AA, M1, M0, GT, M0C, M0G, INDMY, INST, LOGO, MARKS, MARKG, NODMF, OCCD, MTFUSE, MOMDMY, FUSEMK1, DUMBA, M1DUB, M0DUB, DUMBP, M0CDUB, M0GDUB, CTOP >= 1.8um
 err1 = EXT OCOVLM1CA MARKS < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_4_MARKG {
@ OCOVLM1CA space to AA, M1, M0, GT, M0C, M0G, INDMY, INST, LOGO, MARKS, MARKG, NODMF, OCCD, MTFUSE, MOMDMY, FUSEMK1, DUMBA, M1DUB, M0DUB, DUMBP, M0CDUB, M0GDUB, CTOP >= 1.8um
 err1 = EXT OCOVLM1CA MARKG < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_4_NODMF {
@ OCOVLM1CA space to AA, M1, M0, GT, M0C, M0G, INDMY, INST, LOGO, MARKS, MARKG, NODMF, OCCD, MTFUSE, MOMDMY, FUSEMK1, DUMBA, M1DUB, M0DUB, DUMBP, M0CDUB, M0GDUB, CTOP >= 1.8um
 err1 = EXT OCOVLM1CA NODMF < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_4_OCCD {
@ OCOVLM1CA space to AA, M1, M0, GT, M0C, M0G, INDMY, INST, LOGO, MARKS, MARKG, NODMF, OCCD, MTFUSE, MOMDMY, FUSEMK1, DUMBA, M1DUB, M0DUB, DUMBP, M0CDUB, M0GDUB, CTOP >= 1.8um
 err1 = EXT OCOVLM1CA OCCD < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_4_MTFUSE {
@ OCOVLM1CA space to AA, M1, M0, GT, M0C, M0G, INDMY, INST, LOGO, MARKS, MARKG, NODMF, OCCD, MTFUSE, MOMDMY, FUSEMK1, DUMBA, M1DUB, M0DUB, DUMBP, M0CDUB, M0GDUB, CTOP >= 1.8um
 err1 = EXT OCOVLM1CA MTFUSE < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_4_MOMDMY {
@ OCOVLM1CA space to AA, M1, M0, GT, M0C, M0G, INDMY, INST, LOGO, MARKS, MARKG, NODMF, OCCD, MTFUSE, MOMDMY, FUSEMK1, DUMBA, M1DUB, M0DUB, DUMBP, M0CDUB, M0GDUB, CTOP >= 1.8um
 err1 = EXT OCOVLM1CA MOMDMY < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_4_FUSEMK1 {
@ OCOVLM1CA space to AA, M1, M0, GT, M0C, M0G, INDMY, INST, LOGO, MARKS, MARKG, NODMF, OCCD, MTFUSE, MOMDMY, FUSEMK1, DUMBA, M1DUB, M0DUB, DUMBP, M0CDUB, M0GDUB, CTOP >= 1.8um
 err1 = EXT OCOVLM1CA FUSEMK1 < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_4_DUMBA {
@ OCOVLM1CA space to AA, M1, M0, GT, M0C, M0G, INDMY, INST, LOGO, MARKS, MARKG, NODMF, OCCD, MTFUSE, MOMDMY, FUSEMK1, DUMBA, M1DUB, M0DUB, DUMBP, M0CDUB, M0GDUB, CTOP >= 1.8um
 err1 = EXT OCOVLM1CA DUMBA < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_4_M1DUB {
@ OCOVLM1CA space to AA, M1, M0, GT, M0C, M0G, INDMY, INST, LOGO, MARKS, MARKG, NODMF, OCCD, MTFUSE, MOMDMY, FUSEMK1, DUMBA, M1DUB, M0DUB, DUMBP, M0CDUB, M0GDUB, CTOP >= 1.8um
 err1 = EXT OCOVLM1CA M1DUB < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_4_M0DUB {
@ OCOVLM1CA space to AA, M1, M0, GT, M0C, M0G, INDMY, INST, LOGO, MARKS, MARKG, NODMF, OCCD, MTFUSE, MOMDMY, FUSEMK1, DUMBA, M1DUB, M0DUB, DUMBP, M0CDUB, M0GDUB, CTOP >= 1.8um
 err1 = EXT OCOVLM1CA M0DUB < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_4_DUMBP {
@ OCOVLM1CA space to AA, M1, M0, GT, M0C, M0G, INDMY, INST, LOGO, MARKS, MARKG, NODMF, OCCD, MTFUSE, MOMDMY, FUSEMK1, DUMBA, M1DUB, M0DUB, DUMBP, M0CDUB, M0GDUB, CTOP >= 1.8um
 err1 = EXT OCOVLM1CA DUMBP < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_4_M0CDUB {
@ OCOVLM1CA space to AA, M1, M0, GT, M0C, M0G, INDMY, INST, LOGO, MARKS, MARKG, NODMF, OCCD, MTFUSE, MOMDMY, FUSEMK1, DUMBA, M1DUB, M0DUB, DUMBP, M0CDUB, M0GDUB, CTOP >= 1.8um
 err1 = EXT OCOVLM1CA M0CDUB < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_4_M0GDUB {
@ OCOVLM1CA space to AA, M1, M0, GT, M0C, M0G, INDMY, INST, LOGO, MARKS, MARKG, NODMF, OCCD, MTFUSE, MOMDMY, FUSEMK1, DUMBA, M1DUB, M0DUB, DUMBP, M0CDUB, M0GDUB, CTOP >= 1.8um
 err1 = EXT OCOVLM1CA M0GDUB < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_4_CTOP {
@ OCOVLM1CA space to AA, M1, M0, GT, M0C, M0G, INDMY, INST, LOGO, MARKS, MARKG, NODMF, OCCD, MTFUSE, MOMDMY, FUSEMK1, DUMBA, M1DUB, M0DUB, DUMBP, M0CDUB, M0GDUB, CTOP >= 1.8um
 err1 = EXT OCOVLM1CA CTOP < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_5_DUM_AA {
@ OCOVLM1CA space to DUM_AA, DUM_M1, DUM_M0, DUM_GT, DUM_M0C, DUM_M0G >= 0.4um
 err1 = EXT OCOVLM1CA DUM_AA < 0.4 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_5_DUM_M1 {
@ OCOVLM1CA space to DUM_AA, DUM_M1, DUM_M0, DUM_GT, DUM_M0C, DUM_M0G >= 0.4um
 err1 = EXT OCOVLM1CA DUM_M1 < 0.4 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_5_DUM_M0 {
@ OCOVLM1CA space to DUM_AA, DUM_M1, DUM_M0, DUM_GT, DUM_M0C, DUM_M0G >= 0.4um
 err1 = EXT OCOVLM1CA DUM_M0 < 0.4 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_5_DUM_GT {
@ OCOVLM1CA space to DUM_AA, DUM_M1, DUM_M0, DUM_GT, DUM_M0C, DUM_M0G >= 0.4um
 err1 = EXT OCOVLM1CA DUM_GT < 0.4 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_5_DUM_M0C {
@ OCOVLM1CA space to DUM_AA, DUM_M1, DUM_M0, DUM_GT, DUM_M0C, DUM_M0G >= 0.4um
 err1 = EXT OCOVLM1CA DUM_M0C < 0.4 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_5_DUM_M0G {
@ OCOVLM1CA space to DUM_AA, DUM_M1, DUM_M0, DUM_GT, DUM_M0C, DUM_M0G >= 0.4um
 err1 = EXT OCOVLM1CA DUM_M0G < 0.4 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_6_M1 {
@ OCOVLM1CA space to M1, M0, M0C, M0G, INDMY, INST, LOGO, MARKS, MARKG, NODMF, OCCD, MTFUSE, MOMDMY, FUSEMK1, M1DUB, M0DUB, M0CDUB, M0GDUB, CTOP >= 1.8um
 err1 = copy (EXT OCOVLM1CA M1 < 1.8 ABUT<90 SINGULAR REGION)
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_6_M0 {
@ OCOVLM1CA space to M1, M0, M0C, M0G, INDMY, INST, LOGO, MARKS, MARKG, NODMF, OCCD, MTFUSE, MOMDMY, FUSEMK1, M1DUB, M0DUB, M0CDUB, M0GDUB, CTOP >= 1.8um
 err1 = copy (EXT OCOVLM1CA M0 < 1.8 ABUT<90 SINGULAR REGION)
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_6_M0C {
@ OCOVLM1CA space to M1, M0, M0C, M0G, INDMY, INST, LOGO, MARKS, MARKG, NODMF, OCCD, MTFUSE, MOMDMY, FUSEMK1, M1DUB, M0DUB, M0CDUB, M0GDUB, CTOP >= 1.8um
 err1 = copy (EXT OCOVLM1CA M0C < 1.8 ABUT<90 SINGULAR REGION)
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_6_M0G {
@ OCOVLM1CA space to M1, M0, M0C, M0G, INDMY, INST, LOGO, MARKS, MARKG, NODMF, OCCD, MTFUSE, MOMDMY, FUSEMK1, M1DUB, M0DUB, M0CDUB, M0GDUB, CTOP >= 1.8um
 err1 = copy (EXT OCOVLM1CA M0G < 1.8 ABUT<90 SINGULAR REGION)
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_6_INDMY {
@ OCOVLM1CA space to M1, M0, M0C, M0G, INDMY, INST, LOGO, MARKS, MARKG, NODMF, OCCD, MTFUSE, MOMDMY, FUSEMK1, M1DUB, M0DUB, M0CDUB, M0GDUB, CTOP >= 1.8um
 err1 = copy (EXT OCOVLM1CA INDMY < 1.8 ABUT<90 SINGULAR REGION)
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_6_INST {
@ OCOVLM1CA space to M1, M0, M0C, M0G, INDMY, INST, LOGO, MARKS, MARKG, NODMF, OCCD, MTFUSE, MOMDMY, FUSEMK1, M1DUB, M0DUB, M0CDUB, M0GDUB, CTOP >= 1.8um
 err1 = copy (EXT OCOVLM1CA INST < 1.8 ABUT<90 SINGULAR REGION)
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_6_LOGO {
@ OCOVLM1CA space to M1, M0, M0C, M0G, INDMY, INST, LOGO, MARKS, MARKG, NODMF, OCCD, MTFUSE, MOMDMY, FUSEMK1, M1DUB, M0DUB, M0CDUB, M0GDUB, CTOP >= 1.8um
 err1 = copy (EXT OCOVLM1CA LOGO < 1.8 ABUT<90 SINGULAR REGION)
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_6_MARKS {
@ OCOVLM1CA space to M1, M0, M0C, M0G, INDMY, INST, LOGO, MARKS, MARKG, NODMF, OCCD, MTFUSE, MOMDMY, FUSEMK1, M1DUB, M0DUB, M0CDUB, M0GDUB, CTOP >= 1.8um
 err1 = copy (EXT OCOVLM1CA MARKS < 1.8 ABUT<90 SINGULAR REGION)
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_6_MARKG {
@ OCOVLM1CA space to M1, M0, M0C, M0G, INDMY, INST, LOGO, MARKS, MARKG, NODMF, OCCD, MTFUSE, MOMDMY, FUSEMK1, M1DUB, M0DUB, M0CDUB, M0GDUB, CTOP >= 1.8um
 err1 = copy (EXT OCOVLM1CA MARKG < 1.8 ABUT<90 SINGULAR REGION)
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_6_NODMF {
@ OCOVLM1CA space to M1, M0, M0C, M0G, INDMY, INST, LOGO, MARKS, MARKG, NODMF, OCCD, MTFUSE, MOMDMY, FUSEMK1, M1DUB, M0DUB, M0CDUB, M0GDUB, CTOP >= 1.8um
 err1 = copy (EXT OCOVLM1CA NODMF < 1.8 ABUT<90 SINGULAR REGION)
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_6_OCCD {
@ OCOVLM1CA space to M1, M0, M0C, M0G, INDMY, INST, LOGO, MARKS, MARKG, NODMF, OCCD, MTFUSE, MOMDMY, FUSEMK1, M1DUB, M0DUB, M0CDUB, M0GDUB, CTOP >= 1.8um
 err1 = copy (EXT OCOVLM1CA OCCD < 1.8 ABUT<90 SINGULAR REGION)
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_6_MTFUSE {
@ OCOVLM1CA space to M1, M0, M0C, M0G, INDMY, INST, LOGO, MARKS, MARKG, NODMF, OCCD, MTFUSE, MOMDMY, FUSEMK1, M1DUB, M0DUB, M0CDUB, M0GDUB, CTOP >= 1.8um
 err1 = copy (EXT OCOVLM1CA MTFUSE < 1.8 ABUT<90 SINGULAR REGION)
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_6_MOMDMY {
@ OCOVLM1CA space to M1, M0, M0C, M0G, INDMY, INST, LOGO, MARKS, MARKG, NODMF, OCCD, MTFUSE, MOMDMY, FUSEMK1, M1DUB, M0DUB, M0CDUB, M0GDUB, CTOP >= 1.8um
 err1 = copy (EXT OCOVLM1CA MOMDMY < 1.8 ABUT<90 SINGULAR REGION)
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_6_FUSEMK1 {
@ OCOVLM1CA space to M1, M0, M0C, M0G, INDMY, INST, LOGO, MARKS, MARKG, NODMF, OCCD, MTFUSE, MOMDMY, FUSEMK1, M1DUB, M0DUB, M0CDUB, M0GDUB, CTOP >= 1.8um
 err1 = copy (EXT OCOVLM1CA FUSEMK1 < 1.8 ABUT<90 SINGULAR REGION)
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_6_M1DUB {
@ OCOVLM1CA space to M1, M0, M0C, M0G, INDMY, INST, LOGO, MARKS, MARKG, NODMF, OCCD, MTFUSE, MOMDMY, FUSEMK1, M1DUB, M0DUB, M0CDUB, M0GDUB, CTOP >= 1.8um
 err1 = copy (EXT OCOVLM1CA M1DUB < 1.8 ABUT<90 SINGULAR REGION)
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_6_M0DUB {
@ OCOVLM1CA space to M1, M0, M0C, M0G, INDMY, INST, LOGO, MARKS, MARKG, NODMF, OCCD, MTFUSE, MOMDMY, FUSEMK1, M1DUB, M0DUB, M0CDUB, M0GDUB, CTOP >= 1.8um
 err1 = copy (EXT OCOVLM1CA M0DUB < 1.8 ABUT<90 SINGULAR REGION)
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_6_M0CDUB {
@ OCOVLM1CA space to M1, M0, M0C, M0G, INDMY, INST, LOGO, MARKS, MARKG, NODMF, OCCD, MTFUSE, MOMDMY, FUSEMK1, M1DUB, M0DUB, M0CDUB, M0GDUB, CTOP >= 1.8um
 err1 = copy (EXT OCOVLM1CA M0CDUB < 1.8 ABUT<90 SINGULAR REGION)
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_6_M0GDUB {
@ OCOVLM1CA space to M1, M0, M0C, M0G, INDMY, INST, LOGO, MARKS, MARKG, NODMF, OCCD, MTFUSE, MOMDMY, FUSEMK1, M1DUB, M0DUB, M0CDUB, M0GDUB, CTOP >= 1.8um
 err1 = copy (EXT OCOVLM1CA M0GDUB < 1.8 ABUT<90 SINGULAR REGION)
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_6_CTOP {
@ OCOVLM1CA space to M1, M0, M0C, M0G, INDMY, INST, LOGO, MARKS, MARKG, NODMF, OCCD, MTFUSE, MOMDMY, FUSEMK1, M1DUB, M0DUB, M0CDUB, M0GDUB, CTOP >= 1.8um
 err1 = copy (EXT OCOVLM1CA CTOP < 1.8 ABUT<90 SINGULAR REGION)
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_7_DUM_M1 {
@ OCOVLM1CB space to DUM_M1, DUM_M0, DUM_M0C, DUM_M0G >= 0.4um
 err1 = EXT OCOVLM1CB DUM_M1 < 0.4 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_7_DUM_M0 {
@ OCOVLM1CB space to DUM_M1, DUM_M0, DUM_M0C, DUM_M0G >= 0.4um
 err1 = EXT OCOVLM1CB DUM_M0 < 0.4 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_7_DUM_M0C {
@ OCOVLM1CB space to DUM_M1, DUM_M0, DUM_M0C, DUM_M0G >= 0.4um
 err1 = EXT OCOVLM1CB DUM_M0C < 0.4 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_7_DUM_M0G {
@ OCOVLM1CB space to DUM_M1, DUM_M0, DUM_M0C, DUM_M0G >= 0.4um
 err1 = EXT OCOVLM1CB DUM_M0G < 0.4 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_8_M1 {
@ OCOVLM2CA space to M1, M2, M0G, M0C, M0, V0, INDMY, INST, LOGO, MARKS, MARKG, NODMF, OCCD, MTFUSE, MOMDMY, FUSEMK1, M1DUB, M2DUB, M0GDUB, M0CDUB, M0DUB, V0DUB, CTOP >= 1.8um
 err1 = EXT OCOVLM2CA M1 < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_8_M2 {
@ OCOVLM2CA space to M1, M2, M0G, M0C, M0, V0, INDMY, INST, LOGO, MARKS, MARKG, NODMF, OCCD, MTFUSE, MOMDMY, FUSEMK1, M1DUB, M2DUB, M0GDUB, M0CDUB, M0DUB, V0DUB, CTOP >= 1.8um
 err1 = EXT OCOVLM2CA M2 < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_8_M0G {
@ OCOVLM2CA space to M1, M2, M0G, M0C, M0, V0, INDMY, INST, LOGO, MARKS, MARKG, NODMF, OCCD, MTFUSE, MOMDMY, FUSEMK1, M1DUB, M2DUB, M0GDUB, M0CDUB, M0DUB, V0DUB, CTOP >= 1.8um
 err1 = EXT OCOVLM2CA M0G < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_8_M0C {
@ OCOVLM2CA space to M1, M2, M0G, M0C, M0, V0, INDMY, INST, LOGO, MARKS, MARKG, NODMF, OCCD, MTFUSE, MOMDMY, FUSEMK1, M1DUB, M2DUB, M0GDUB, M0CDUB, M0DUB, V0DUB, CTOP >= 1.8um
 err1 = EXT OCOVLM2CA M0C < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_8_M0 {
@ OCOVLM2CA space to M1, M2, M0G, M0C, M0, V0, INDMY, INST, LOGO, MARKS, MARKG, NODMF, OCCD, MTFUSE, MOMDMY, FUSEMK1, M1DUB, M2DUB, M0GDUB, M0CDUB, M0DUB, V0DUB, CTOP >= 1.8um
 err1 = EXT OCOVLM2CA M0 < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_8_V0 {
@ OCOVLM2CA space to M1, M2, M0G, M0C, M0, V0, INDMY, INST, LOGO, MARKS, MARKG, NODMF, OCCD, MTFUSE, MOMDMY, FUSEMK1, M1DUB, M2DUB, M0GDUB, M0CDUB, M0DUB, V0DUB, CTOP >= 1.8um
 err1 = EXT OCOVLM2CA V0 < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_8_INDMY {
@ OCOVLM2CA space to M1, M2, M0G, M0C, M0, V0, INDMY, INST, LOGO, MARKS, MARKG, NODMF, OCCD, MTFUSE, MOMDMY, FUSEMK1, M1DUB, M2DUB, M0GDUB, M0CDUB, M0DUB, V0DUB, CTOP >= 1.8um
 err1 = EXT OCOVLM2CA INDMY < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_8_INST {
@ OCOVLM2CA space to M1, M2, M0G, M0C, M0, V0, INDMY, INST, LOGO, MARKS, MARKG, NODMF, OCCD, MTFUSE, MOMDMY, FUSEMK1, M1DUB, M2DUB, M0GDUB, M0CDUB, M0DUB, V0DUB, CTOP >= 1.8um
 err1 = EXT OCOVLM2CA INST < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_8_LOGO {
@ OCOVLM2CA space to M1, M2, M0G, M0C, M0, V0, INDMY, INST, LOGO, MARKS, MARKG, NODMF, OCCD, MTFUSE, MOMDMY, FUSEMK1, M1DUB, M2DUB, M0GDUB, M0CDUB, M0DUB, V0DUB, CTOP >= 1.8um
 err1 = EXT OCOVLM2CA LOGO < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_8_MARKS {
@ OCOVLM2CA space to M1, M2, M0G, M0C, M0, V0, INDMY, INST, LOGO, MARKS, MARKG, NODMF, OCCD, MTFUSE, MOMDMY, FUSEMK1, M1DUB, M2DUB, M0GDUB, M0CDUB, M0DUB, V0DUB, CTOP >= 1.8um
 err1 = EXT OCOVLM2CA MARKS < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_8_MARKG {
@ OCOVLM2CA space to M1, M2, M0G, M0C, M0, V0, INDMY, INST, LOGO, MARKS, MARKG, NODMF, OCCD, MTFUSE, MOMDMY, FUSEMK1, M1DUB, M2DUB, M0GDUB, M0CDUB, M0DUB, V0DUB, CTOP >= 1.8um
 err1 = EXT OCOVLM2CA MARKG < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_8_NODMF {
@ OCOVLM2CA space to M1, M2, M0G, M0C, M0, V0, INDMY, INST, LOGO, MARKS, MARKG, NODMF, OCCD, MTFUSE, MOMDMY, FUSEMK1, M1DUB, M2DUB, M0GDUB, M0CDUB, M0DUB, V0DUB, CTOP >= 1.8um
 err1 = EXT OCOVLM2CA NODMF < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_8_OCCD {
@ OCOVLM2CA space to M1, M2, M0G, M0C, M0, V0, INDMY, INST, LOGO, MARKS, MARKG, NODMF, OCCD, MTFUSE, MOMDMY, FUSEMK1, M1DUB, M2DUB, M0GDUB, M0CDUB, M0DUB, V0DUB, CTOP >= 1.8um
 err1 = EXT OCOVLM2CA OCCD < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_8_MTFUSE {
@ OCOVLM2CA space to M1, M2, M0G, M0C, M0, V0, INDMY, INST, LOGO, MARKS, MARKG, NODMF, OCCD, MTFUSE, MOMDMY, FUSEMK1, M1DUB, M2DUB, M0GDUB, M0CDUB, M0DUB, V0DUB, CTOP >= 1.8um
 err1 = EXT OCOVLM2CA MTFUSE < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_8_MOMDMY {
@ OCOVLM2CA space to M1, M2, M0G, M0C, M0, V0, INDMY, INST, LOGO, MARKS, MARKG, NODMF, OCCD, MTFUSE, MOMDMY, FUSEMK1, M1DUB, M2DUB, M0GDUB, M0CDUB, M0DUB, V0DUB, CTOP >= 1.8um
 err1 = EXT OCOVLM2CA MOMDMY < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_8_FUSEMK1 {
@ OCOVLM2CA space to M1, M2, M0G, M0C, M0, V0, INDMY, INST, LOGO, MARKS, MARKG, NODMF, OCCD, MTFUSE, MOMDMY, FUSEMK1, M1DUB, M2DUB, M0GDUB, M0CDUB, M0DUB, V0DUB, CTOP >= 1.8um
 err1 = EXT OCOVLM2CA FUSEMK1 < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_8_M1DUB {
@ OCOVLM2CA space to M1, M2, M0G, M0C, M0, V0, INDMY, INST, LOGO, MARKS, MARKG, NODMF, OCCD, MTFUSE, MOMDMY, FUSEMK1, M1DUB, M2DUB, M0GDUB, M0CDUB, M0DUB, V0DUB, CTOP >= 1.8um
 err1 = EXT OCOVLM2CA M1DUB < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_8_M2DUB {
@ OCOVLM2CA space to M1, M2, M0G, M0C, M0, V0, INDMY, INST, LOGO, MARKS, MARKG, NODMF, OCCD, MTFUSE, MOMDMY, FUSEMK1, M1DUB, M2DUB, M0GDUB, M0CDUB, M0DUB, V0DUB, CTOP >= 1.8um
 err1 = EXT OCOVLM2CA M2DUB < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_8_M0GDUB {
@ OCOVLM2CA space to M1, M2, M0G, M0C, M0, V0, INDMY, INST, LOGO, MARKS, MARKG, NODMF, OCCD, MTFUSE, MOMDMY, FUSEMK1, M1DUB, M2DUB, M0GDUB, M0CDUB, M0DUB, V0DUB, CTOP >= 1.8um
 err1 = EXT OCOVLM2CA M0GDUB < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_8_M0CDUB {
@ OCOVLM2CA space to M1, M2, M0G, M0C, M0, V0, INDMY, INST, LOGO, MARKS, MARKG, NODMF, OCCD, MTFUSE, MOMDMY, FUSEMK1, M1DUB, M2DUB, M0GDUB, M0CDUB, M0DUB, V0DUB, CTOP >= 1.8um
 err1 = EXT OCOVLM2CA M0CDUB < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_8_M0DUB {
@ OCOVLM2CA space to M1, M2, M0G, M0C, M0, V0, INDMY, INST, LOGO, MARKS, MARKG, NODMF, OCCD, MTFUSE, MOMDMY, FUSEMK1, M1DUB, M2DUB, M0GDUB, M0CDUB, M0DUB, V0DUB, CTOP >= 1.8um
 err1 = EXT OCOVLM2CA M0DUB < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_8_V0DUB {
@ OCOVLM2CA space to M1, M2, M0G, M0C, M0, V0, INDMY, INST, LOGO, MARKS, MARKG, NODMF, OCCD, MTFUSE, MOMDMY, FUSEMK1, M1DUB, M2DUB, M0GDUB, M0CDUB, M0DUB, V0DUB, CTOP >= 1.8um
 err1 = EXT OCOVLM2CA V0DUB < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_8_CTOP {
@ OCOVLM2CA space to M1, M2, M0G, M0C, M0, V0, INDMY, INST, LOGO, MARKS, MARKG, NODMF, OCCD, MTFUSE, MOMDMY, FUSEMK1, M1DUB, M2DUB, M0GDUB, M0CDUB, M0DUB, V0DUB, CTOP >= 1.8um
 err1 = EXT OCOVLM2CA CTOP < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_9_DUM_M1 {
@ OCOVLM2CA space to DUM_M1, DUM_M2, DUM_M0G, DUM_M0C, DUM_M0, DUM_V0 >= 0.4um
 err1 = EXT OCOVLM2CA DUM_M1 < 0.4 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_9_DUM_M2 {
@ OCOVLM2CA space to DUM_M1, DUM_M2, DUM_M0G, DUM_M0C, DUM_M0, DUM_V0 >= 0.4um
 err1 = EXT OCOVLM2CA DUM_M2 < 0.4 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_9_DUM_M0G {
@ OCOVLM2CA space to DUM_M1, DUM_M2, DUM_M0G, DUM_M0C, DUM_M0, DUM_V0 >= 0.4um
 err1 = EXT OCOVLM2CA DUM_M0G < 0.4 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_9_DUM_M0C {
@ OCOVLM2CA space to DUM_M1, DUM_M2, DUM_M0G, DUM_M0C, DUM_M0, DUM_V0 >= 0.4um
 err1 = EXT OCOVLM2CA DUM_M0C < 0.4 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_9_DUM_M0 {
@ OCOVLM2CA space to DUM_M1, DUM_M2, DUM_M0G, DUM_M0C, DUM_M0, DUM_V0 >= 0.4um
 err1 = EXT OCOVLM2CA DUM_M0 < 0.4 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_9_DUM_V0 {
@ OCOVLM2CA space to DUM_M1, DUM_M2, DUM_M0G, DUM_M0C, DUM_M0, DUM_V0 >= 0.4um
 err1 = EXT OCOVLM2CA DUM_V0 < 0.4 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_10_M1 {
@ OCOVLM4 space to M1, M2, M3, M4, V0, V1, V2, V3, INDMY, INST, LOGO, MARKS, MARKG, NODMF, OCCD, MTFUSE, MOMDMY, FUSEMK1, M1DUB, M2DUB, M3DUB, M4DUB, CTOP >= 1.8um
 err1 = EXT OCOVLM4 M1 < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_10_M2 {
@ OCOVLM4 space to M1, M2, M3, M4, V0, V1, V2, V3, INDMY, INST, LOGO, MARKS, MARKG, NODMF, OCCD, MTFUSE, MOMDMY, FUSEMK1, M1DUB, M2DUB, M3DUB, M4DUB, CTOP >= 1.8um
 err1 = EXT OCOVLM4 M2 < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_10_M3 {
@ OCOVLM4 space to M1, M2, M3, M4, V0, V1, V2, V3, INDMY, INST, LOGO, MARKS, MARKG, NODMF, OCCD, MTFUSE, MOMDMY, FUSEMK1, M1DUB, M2DUB, M3DUB, M4DUB, CTOP >= 1.8um
 err1 = EXT OCOVLM4 M3 < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_10_M4 {
@ OCOVLM4 space to M1, M2, M3, M4, V0, V1, V2, V3, INDMY, INST, LOGO, MARKS, MARKG, NODMF, OCCD, MTFUSE, MOMDMY, FUSEMK1, M1DUB, M2DUB, M3DUB, M4DUB, CTOP >= 1.8um
 err1 = EXT OCOVLM4 M4 < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_10_V0 {
@ OCOVLM4 space to M1, M2, M3, M4, V0, V1, V2, V3, INDMY, INST, LOGO, MARKS, MARKG, NODMF, OCCD, MTFUSE, MOMDMY, FUSEMK1, M1DUB, M2DUB, M3DUB, M4DUB, CTOP >= 1.8um
 err1 = EXT OCOVLM4 V0 < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_10_V1 {
@ OCOVLM4 space to M1, M2, M3, M4, V0, V1, V2, V3, INDMY, INST, LOGO, MARKS, MARKG, NODMF, OCCD, MTFUSE, MOMDMY, FUSEMK1, M1DUB, M2DUB, M3DUB, M4DUB, CTOP >= 1.8um
 err1 = EXT OCOVLM4 V1 < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_10_V2 {
@ OCOVLM4 space to M1, M2, M3, M4, V0, V1, V2, V3, INDMY, INST, LOGO, MARKS, MARKG, NODMF, OCCD, MTFUSE, MOMDMY, FUSEMK1, M1DUB, M2DUB, M3DUB, M4DUB, CTOP >= 1.8um
 err1 = EXT OCOVLM4 V2 < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_10_V3 {
@ OCOVLM4 space to M1, M2, M3, M4, V0, V1, V2, V3, INDMY, INST, LOGO, MARKS, MARKG, NODMF, OCCD, MTFUSE, MOMDMY, FUSEMK1, M1DUB, M2DUB, M3DUB, M4DUB, CTOP >= 1.8um
 err1 = EXT OCOVLM4 V3 < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_10_INDMY {
@ OCOVLM4 space to M1, M2, M3, M4, V0, V1, V2, V3, INDMY, INST, LOGO, MARKS, MARKG, NODMF, OCCD, MTFUSE, MOMDMY, FUSEMK1, M1DUB, M2DUB, M3DUB, M4DUB, CTOP >= 1.8um
 err1 = EXT OCOVLM4 INDMY < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_10_INST {
@ OCOVLM4 space to M1, M2, M3, M4, V0, V1, V2, V3, INDMY, INST, LOGO, MARKS, MARKG, NODMF, OCCD, MTFUSE, MOMDMY, FUSEMK1, M1DUB, M2DUB, M3DUB, M4DUB, CTOP >= 1.8um
 err1 = EXT OCOVLM4 INST < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_10_LOGO {
@ OCOVLM4 space to M1, M2, M3, M4, V0, V1, V2, V3, INDMY, INST, LOGO, MARKS, MARKG, NODMF, OCCD, MTFUSE, MOMDMY, FUSEMK1, M1DUB, M2DUB, M3DUB, M4DUB, CTOP >= 1.8um
 err1 = EXT OCOVLM4 LOGO < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_10_MARKS {
@ OCOVLM4 space to M1, M2, M3, M4, V0, V1, V2, V3, INDMY, INST, LOGO, MARKS, MARKG, NODMF, OCCD, MTFUSE, MOMDMY, FUSEMK1, M1DUB, M2DUB, M3DUB, M4DUB, CTOP >= 1.8um
 err1 = EXT OCOVLM4 MARKS < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_10_MARKG {
@ OCOVLM4 space to M1, M2, M3, M4, V0, V1, V2, V3, INDMY, INST, LOGO, MARKS, MARKG, NODMF, OCCD, MTFUSE, MOMDMY, FUSEMK1, M1DUB, M2DUB, M3DUB, M4DUB, CTOP >= 1.8um
 err1 = EXT OCOVLM4 MARKG < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_10_NODMF {
@ OCOVLM4 space to M1, M2, M3, M4, V0, V1, V2, V3, INDMY, INST, LOGO, MARKS, MARKG, NODMF, OCCD, MTFUSE, MOMDMY, FUSEMK1, M1DUB, M2DUB, M3DUB, M4DUB, CTOP >= 1.8um
 err1 = EXT OCOVLM4 NODMF < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_10_OCCD {
@ OCOVLM4 space to M1, M2, M3, M4, V0, V1, V2, V3, INDMY, INST, LOGO, MARKS, MARKG, NODMF, OCCD, MTFUSE, MOMDMY, FUSEMK1, M1DUB, M2DUB, M3DUB, M4DUB, CTOP >= 1.8um
 err1 = EXT OCOVLM4 OCCD < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_10_MTFUSE {
@ OCOVLM4 space to M1, M2, M3, M4, V0, V1, V2, V3, INDMY, INST, LOGO, MARKS, MARKG, NODMF, OCCD, MTFUSE, MOMDMY, FUSEMK1, M1DUB, M2DUB, M3DUB, M4DUB, CTOP >= 1.8um
 err1 = EXT OCOVLM4 MTFUSE < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_10_MOMDMY {
@ OCOVLM4 space to M1, M2, M3, M4, V0, V1, V2, V3, INDMY, INST, LOGO, MARKS, MARKG, NODMF, OCCD, MTFUSE, MOMDMY, FUSEMK1, M1DUB, M2DUB, M3DUB, M4DUB, CTOP >= 1.8um
 err1 = EXT OCOVLM4 MOMDMY < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_10_FUSEMK1 {
@ OCOVLM4 space to M1, M2, M3, M4, V0, V1, V2, V3, INDMY, INST, LOGO, MARKS, MARKG, NODMF, OCCD, MTFUSE, MOMDMY, FUSEMK1, M1DUB, M2DUB, M3DUB, M4DUB, CTOP >= 1.8um
 err1 = EXT OCOVLM4 FUSEMK1 < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_10_M1DUB {
@ OCOVLM4 space to M1, M2, M3, M4, V0, V1, V2, V3, INDMY, INST, LOGO, MARKS, MARKG, NODMF, OCCD, MTFUSE, MOMDMY, FUSEMK1, M1DUB, M2DUB, M3DUB, M4DUB, CTOP >= 1.8um
 err1 = EXT OCOVLM4 M1DUB < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_10_M2DUB {
@ OCOVLM4 space to M1, M2, M3, M4, V0, V1, V2, V3, INDMY, INST, LOGO, MARKS, MARKG, NODMF, OCCD, MTFUSE, MOMDMY, FUSEMK1, M1DUB, M2DUB, M3DUB, M4DUB, CTOP >= 1.8um
 err1 = EXT OCOVLM4 M2DUB < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_10_M3DUB {
@ OCOVLM4 space to M1, M2, M3, M4, V0, V1, V2, V3, INDMY, INST, LOGO, MARKS, MARKG, NODMF, OCCD, MTFUSE, MOMDMY, FUSEMK1, M1DUB, M2DUB, M3DUB, M4DUB, CTOP >= 1.8um
 err1 = EXT OCOVLM4 M3DUB < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_10_M4DUB {
@ OCOVLM4 space to M1, M2, M3, M4, V0, V1, V2, V3, INDMY, INST, LOGO, MARKS, MARKG, NODMF, OCCD, MTFUSE, MOMDMY, FUSEMK1, M1DUB, M2DUB, M3DUB, M4DUB, CTOP >= 1.8um
 err1 = EXT OCOVLM4 M4DUB < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_10_CTOP {
@ OCOVLM4 space to M1, M2, M3, M4, V0, V1, V2, V3, INDMY, INST, LOGO, MARKS, MARKG, NODMF, OCCD, MTFUSE, MOMDMY, FUSEMK1, M1DUB, M2DUB, M3DUB, M4DUB, CTOP >= 1.8um
 err1 = EXT OCOVLM4 CTOP < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_11_DUM_M1 {
@ OCOVLM4 space to DUM_M1, DUM_M2, DUM_M3, DUM_M4, DUM_V0, DUM_V1, DUM_V2, DUM_V3 >= 0.4um
 err1 = EXT OCOVLM4 DUM_M1 < 0.4 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_11_DUM_M2 {
@ OCOVLM4 space to DUM_M1, DUM_M2, DUM_M3, DUM_M4, DUM_V0, DUM_V1, DUM_V2, DUM_V3 >= 0.4um
 err1 = EXT OCOVLM4 DUM_M2 < 0.4 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_11_DUM_M3 {
@ OCOVLM4 space to DUM_M1, DUM_M2, DUM_M3, DUM_M4, DUM_V0, DUM_V1, DUM_V2, DUM_V3 >= 0.4um
 err1 = EXT OCOVLM4 DUM_M3 < 0.4 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_11_DUM_M4 {
@ OCOVLM4 space to DUM_M1, DUM_M2, DUM_M3, DUM_M4, DUM_V0, DUM_V1, DUM_V2, DUM_V3 >= 0.4um
 err1 = EXT OCOVLM4 DUM_M4 < 0.4 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_11_DUM_V0 {
@ OCOVLM4 space to DUM_M1, DUM_M2, DUM_M3, DUM_M4, DUM_V0, DUM_V1, DUM_V2, DUM_V3 >= 0.4um
 err1 = EXT OCOVLM4 DUM_V0 < 0.4 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_11_DUM_V1 {
@ OCOVLM4 space to DUM_M1, DUM_M2, DUM_M3, DUM_M4, DUM_V0, DUM_V1, DUM_V2, DUM_V3 >= 0.4um
 err1 = EXT OCOVLM4 DUM_V1 < 0.4 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_11_DUM_V2 {
@ OCOVLM4 space to DUM_M1, DUM_M2, DUM_M3, DUM_M4, DUM_V0, DUM_V1, DUM_V2, DUM_V3 >= 0.4um
 err1 = EXT OCOVLM4 DUM_V2 < 0.4 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_11_DUM_V3 {
@ OCOVLM4 space to DUM_M1, DUM_M2, DUM_M3, DUM_M4, DUM_V0, DUM_V1, DUM_V2, DUM_V3 >= 0.4um
 err1 = EXT OCOVLM4 DUM_V3 < 0.4 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_12_V0 {
@ OCOVLV0 space to V0, M1, M0G, M0C, M0, INDMY, INST, LOGO, MARKS, MARKG, NODMF, OCCD, MTFUSE, MOMDMY, FUSEMK1, V0DUB, M1DUB, M0GDUB, M0CDUB, M0DUB, CTOP >= 1.8um
 err1 = EXT OCOVLV0 V0 < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_12_M1 {
@ OCOVLV0 space to V0, M1, M0G, M0C, M0, INDMY, INST, LOGO, MARKS, MARKG, NODMF, OCCD, MTFUSE, MOMDMY, FUSEMK1, V0DUB, M1DUB, M0GDUB, M0CDUB, M0DUB, CTOP >= 1.8um
 err1 = EXT OCOVLV0 M1 < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_12_M0G {
@ OCOVLV0 space to V0, M1, M0G, M0C, M0, INDMY, INST, LOGO, MARKS, MARKG, NODMF, OCCD, MTFUSE, MOMDMY, FUSEMK1, V0DUB, M1DUB, M0GDUB, M0CDUB, M0DUB, CTOP >= 1.8um
 err1 = EXT OCOVLV0 M0G < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_12_M0C {
@ OCOVLV0 space to V0, M1, M0G, M0C, M0, INDMY, INST, LOGO, MARKS, MARKG, NODMF, OCCD, MTFUSE, MOMDMY, FUSEMK1, V0DUB, M1DUB, M0GDUB, M0CDUB, M0DUB, CTOP >= 1.8um
 err1 = EXT OCOVLV0 M0C < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_12_M0 {
@ OCOVLV0 space to V0, M1, M0G, M0C, M0, INDMY, INST, LOGO, MARKS, MARKG, NODMF, OCCD, MTFUSE, MOMDMY, FUSEMK1, V0DUB, M1DUB, M0GDUB, M0CDUB, M0DUB, CTOP >= 1.8um
 err1 = EXT OCOVLV0 M0 < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_12_INDMY {
@ OCOVLV0 space to V0, M1, M0G, M0C, M0, INDMY, INST, LOGO, MARKS, MARKG, NODMF, OCCD, MTFUSE, MOMDMY, FUSEMK1, V0DUB, M1DUB, M0GDUB, M0CDUB, M0DUB, CTOP >= 1.8um
 err1 = EXT OCOVLV0 INDMY < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_12_INST {
@ OCOVLV0 space to V0, M1, M0G, M0C, M0, INDMY, INST, LOGO, MARKS, MARKG, NODMF, OCCD, MTFUSE, MOMDMY, FUSEMK1, V0DUB, M1DUB, M0GDUB, M0CDUB, M0DUB, CTOP >= 1.8um
 err1 = EXT OCOVLV0 INST < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_12_LOGO {
@ OCOVLV0 space to V0, M1, M0G, M0C, M0, INDMY, INST, LOGO, MARKS, MARKG, NODMF, OCCD, MTFUSE, MOMDMY, FUSEMK1, V0DUB, M1DUB, M0GDUB, M0CDUB, M0DUB, CTOP >= 1.8um
 err1 = EXT OCOVLV0 LOGO < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_12_MARKS {
@ OCOVLV0 space to V0, M1, M0G, M0C, M0, INDMY, INST, LOGO, MARKS, MARKG, NODMF, OCCD, MTFUSE, MOMDMY, FUSEMK1, V0DUB, M1DUB, M0GDUB, M0CDUB, M0DUB, CTOP >= 1.8um
 err1 = EXT OCOVLV0 MARKS < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_12_MARKG {
@ OCOVLV0 space to V0, M1, M0G, M0C, M0, INDMY, INST, LOGO, MARKS, MARKG, NODMF, OCCD, MTFUSE, MOMDMY, FUSEMK1, V0DUB, M1DUB, M0GDUB, M0CDUB, M0DUB, CTOP >= 1.8um
 err1 = EXT OCOVLV0 MARKG < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_12_NODMF {
@ OCOVLV0 space to V0, M1, M0G, M0C, M0, INDMY, INST, LOGO, MARKS, MARKG, NODMF, OCCD, MTFUSE, MOMDMY, FUSEMK1, V0DUB, M1DUB, M0GDUB, M0CDUB, M0DUB, CTOP >= 1.8um
 err1 = EXT OCOVLV0 NODMF < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_12_OCCD {
@ OCOVLV0 space to V0, M1, M0G, M0C, M0, INDMY, INST, LOGO, MARKS, MARKG, NODMF, OCCD, MTFUSE, MOMDMY, FUSEMK1, V0DUB, M1DUB, M0GDUB, M0CDUB, M0DUB, CTOP >= 1.8um
 err1 = EXT OCOVLV0 OCCD < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_12_MTFUSE {
@ OCOVLV0 space to V0, M1, M0G, M0C, M0, INDMY, INST, LOGO, MARKS, MARKG, NODMF, OCCD, MTFUSE, MOMDMY, FUSEMK1, V0DUB, M1DUB, M0GDUB, M0CDUB, M0DUB, CTOP >= 1.8um
 err1 = EXT OCOVLV0 MTFUSE < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_12_MOMDMY {
@ OCOVLV0 space to V0, M1, M0G, M0C, M0, INDMY, INST, LOGO, MARKS, MARKG, NODMF, OCCD, MTFUSE, MOMDMY, FUSEMK1, V0DUB, M1DUB, M0GDUB, M0CDUB, M0DUB, CTOP >= 1.8um
 err1 = EXT OCOVLV0 MOMDMY < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_12_FUSEMK1 {
@ OCOVLV0 space to V0, M1, M0G, M0C, M0, INDMY, INST, LOGO, MARKS, MARKG, NODMF, OCCD, MTFUSE, MOMDMY, FUSEMK1, V0DUB, M1DUB, M0GDUB, M0CDUB, M0DUB, CTOP >= 1.8um
 err1 = EXT OCOVLV0 FUSEMK1 < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_12_V0DUB {
@ OCOVLV0 space to V0, M1, M0G, M0C, M0, INDMY, INST, LOGO, MARKS, MARKG, NODMF, OCCD, MTFUSE, MOMDMY, FUSEMK1, V0DUB, M1DUB, M0GDUB, M0CDUB, M0DUB, CTOP >= 1.8um
 err1 = EXT OCOVLV0 V0DUB < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_12_M1DUB {
@ OCOVLV0 space to V0, M1, M0G, M0C, M0, INDMY, INST, LOGO, MARKS, MARKG, NODMF, OCCD, MTFUSE, MOMDMY, FUSEMK1, V0DUB, M1DUB, M0GDUB, M0CDUB, M0DUB, CTOP >= 1.8um
 err1 = EXT OCOVLV0 M1DUB < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_12_M0GDUB {
@ OCOVLV0 space to V0, M1, M0G, M0C, M0, INDMY, INST, LOGO, MARKS, MARKG, NODMF, OCCD, MTFUSE, MOMDMY, FUSEMK1, V0DUB, M1DUB, M0GDUB, M0CDUB, M0DUB, CTOP >= 1.8um
 err1 = EXT OCOVLV0 M0GDUB < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_12_M0CDUB {
@ OCOVLV0 space to V0, M1, M0G, M0C, M0, INDMY, INST, LOGO, MARKS, MARKG, NODMF, OCCD, MTFUSE, MOMDMY, FUSEMK1, V0DUB, M1DUB, M0GDUB, M0CDUB, M0DUB, CTOP >= 1.8um
 err1 = EXT OCOVLV0 M0CDUB < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_12_M0DUB {
@ OCOVLV0 space to V0, M1, M0G, M0C, M0, INDMY, INST, LOGO, MARKS, MARKG, NODMF, OCCD, MTFUSE, MOMDMY, FUSEMK1, V0DUB, M1DUB, M0GDUB, M0CDUB, M0DUB, CTOP >= 1.8um
 err1 = EXT OCOVLV0 M0DUB < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_12_CTOP {
@ OCOVLV0 space to V0, M1, M0G, M0C, M0, INDMY, INST, LOGO, MARKS, MARKG, NODMF, OCCD, MTFUSE, MOMDMY, FUSEMK1, V0DUB, M1DUB, M0GDUB, M0CDUB, M0DUB, CTOP >= 1.8um
 err1 = EXT OCOVLV0 CTOP < 1.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_13_DUM_V0 {
@ OCOVLV0 space to DUM_V0, DUM_M1, DUM_M0G, DUM_M0C, DUM_M0 >= 0.4um
 err1 = EXT OCOVLV0 DUM_V0 < 0.4 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_13_DUM_M1 {
@ OCOVLV0 space to DUM_V0, DUM_M1, DUM_M0G, DUM_M0C, DUM_M0 >= 0.4um
 err1 = EXT OCOVLV0 DUM_M1 < 0.4 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_13_DUM_M0G {
@ OCOVLV0 space to DUM_V0, DUM_M1, DUM_M0G, DUM_M0C, DUM_M0 >= 0.4um
 err1 = EXT OCOVLV0 DUM_M0G < 0.4 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_13_DUM_M0C {
@ OCOVLV0 space to DUM_V0, DUM_M1, DUM_M0G, DUM_M0C, DUM_M0 >= 0.4um
 err1 = EXT OCOVLV0 DUM_M0C < 0.4 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
OCOVL_S_13_DUM_M0 {
@ OCOVLV0 space to DUM_V0, DUM_M1, DUM_M0G, DUM_M0C, DUM_M0 >= 0.4um
 err1 = EXT OCOVLV0 DUM_M0 < 0.4 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

#IFDEF CHIPB_RULES_CHECK YES
OCOVL_EN_1 {
@ OCOVL enclosure by CHIPB >= 1.8um
 err1 = ENC OCOVL CHIPB < 1.8 ABUT<90 SINGULAR REGION OUTSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
#ENDIF

OCOVL_R_1 {
@ OCOVL should be drawn the same as (OCOVL_FEOL OR OCOVL_BEOL)
 err1 = OCOVL NOT COIN INSIDE EDGE (OR OCOVL_FEOL OCOVL_BEOL)
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
OCOVL_R_2 {
@ 16 OCOVL marks (OCOVLAR, OCOVLARH, OCOVLARV, OCOVLGT1, OCOVLGT2, OCOVLP2A, OCOVLP2B, OCOVLM0C, OCOVLM0, OCOVLM0G1, OCOVLM0G2, OCOVLM1CA, OCOVLM1CB, OCOVLM2CA, OCOVLM4, OCOVLV0) interact each other is not allowed
 err1 = OCOVLAR INTERACT (OR OCOVLARH OCOVLARV OCOVLGT1 OCOVLGT2 OCOVLP2A OCOVLP2B OCOVLM0C OCOVLM0 OCOVLM0G1 OCOVLM0G2 OCOVLM1CA OCOVLM1CB OCOVLM2CA OCOVLM4 OCOVLV0)
 err2 = OCOVLARH INTERACT (OR OCOVLAR OCOVLARV OCOVLGT1 OCOVLGT2 OCOVLP2A OCOVLP2B OCOVLM0C OCOVLM0 OCOVLM0G1 OCOVLM0G2 OCOVLM1CA OCOVLM1CB OCOVLM2CA OCOVLM4 OCOVLV0)
 err3 = OCOVLARV INTERACT (OR OCOVLAR OCOVLARH OCOVLGT1 OCOVLGT2 OCOVLP2A OCOVLP2B OCOVLM0C OCOVLM0 OCOVLM0G1 OCOVLM0G2 OCOVLM1CA OCOVLM1CB OCOVLM2CA OCOVLM4 OCOVLV0)
 err4 = OCOVLGT1 INTERACT (OR OCOVLAR OCOVLARH OCOVLARV OCOVLGT2 OCOVLP2A OCOVLP2B OCOVLM0C OCOVLM0 OCOVLM0G1 OCOVLM0G2 OCOVLM1CA OCOVLM1CB OCOVLM2CA OCOVLM4 OCOVLV0)
 err5 = OCOVLGT2 INTERACT (OR OCOVLAR OCOVLARH OCOVLARV OCOVLGT1 OCOVLP2A OCOVLP2B OCOVLM0C OCOVLM0 OCOVLM0G1 OCOVLM0G2 OCOVLM1CA OCOVLM1CB OCOVLM2CA OCOVLM4 OCOVLV0)
 err6 = OCOVLP2A INTERACT (OR OCOVLAR OCOVLARH OCOVLARV OCOVLGT1 OCOVLGT2 OCOVLP2B OCOVLM0C OCOVLM0 OCOVLM0G1 OCOVLM0G2 OCOVLM1CA OCOVLM1CB OCOVLM2CA OCOVLM4 OCOVLV0)
 err7 = OCOVLP2B INTERACT (OR OCOVLAR OCOVLARH OCOVLARV OCOVLGT1 OCOVLGT2 OCOVLP2A OCOVLM0C OCOVLM0 OCOVLM0G1 OCOVLM0G2 OCOVLM1CA OCOVLM1CB OCOVLM2CA OCOVLM4 OCOVLV0)
 err8 = OCOVLM0C INTERACT (OR OCOVLAR OCOVLARH OCOVLARV OCOVLGT1 OCOVLGT2 OCOVLP2A OCOVLP2B OCOVLM0 OCOVLM0G1 OCOVLM0G2 OCOVLM1CA OCOVLM1CB OCOVLM2CA OCOVLM4 OCOVLV0)
 err9 = OCOVLM0 INTERACT (OR OCOVLAR OCOVLARH OCOVLARV OCOVLGT1 OCOVLGT2 OCOVLP2A OCOVLP2B OCOVLM0C OCOVLM0G1 OCOVLM0G2 OCOVLM1CA OCOVLM1CB OCOVLM2CA OCOVLM4 OCOVLV0)
 err10 = OCOVLM0G1 INTERACT (OR OCOVLAR OCOVLARH OCOVLARV OCOVLGT1 OCOVLGT2 OCOVLP2A OCOVLP2B OCOVLM0C OCOVLM0 OCOVLM0G2 OCOVLM1CA OCOVLM1CB OCOVLM2CA OCOVLM4 OCOVLV0)
 err11 = OCOVLM0G2 INTERACT (OR OCOVLAR OCOVLARH OCOVLARV OCOVLGT1 OCOVLGT2 OCOVLP2A OCOVLP2B OCOVLM0C OCOVLM0 OCOVLM0G1 OCOVLM1CA OCOVLM1CB OCOVLM2CA OCOVLM4 OCOVLV0)
 err12 = OCOVLM1CA INTERACT (OR OCOVLAR OCOVLARH OCOVLARV OCOVLGT1 OCOVLGT2 OCOVLP2A OCOVLP2B OCOVLM0C OCOVLM0 OCOVLM0G1 OCOVLM0G2 OCOVLM1CB OCOVLM2CA OCOVLM4 OCOVLV0)
 err13 = OCOVLM1CB INTERACT (OR OCOVLAR OCOVLARH OCOVLARV OCOVLGT1 OCOVLGT2 OCOVLP2A OCOVLP2B OCOVLM0C OCOVLM0 OCOVLM0G1 OCOVLM0G2 OCOVLM1CA OCOVLM2CA OCOVLM4 OCOVLV0)
 err14 = OCOVLM2CA INTERACT (OR OCOVLAR OCOVLARH OCOVLARV OCOVLGT1 OCOVLGT2 OCOVLP2A OCOVLP2B OCOVLM0C OCOVLM0 OCOVLM0G1 OCOVLM0G2 OCOVLM1CA OCOVLM1CB OCOVLM4 OCOVLV0)
 err15 = OCOVLM4 INTERACT (OR OCOVLAR OCOVLARH OCOVLARV OCOVLGT1 OCOVLGT2 OCOVLP2A OCOVLP2B OCOVLM0C OCOVLM0 OCOVLM0G1 OCOVLM0G2 OCOVLM1CA OCOVLM1CB OCOVLM2CA OCOVLV0)
 err16 = OCOVLV0 INTERACT (OR OCOVLAR OCOVLARH OCOVLARV OCOVLGT1 OCOVLGT2 OCOVLP2A OCOVLP2B OCOVLM0C OCOVLM0 OCOVLM0G1 OCOVLM0G2 OCOVLM1CA OCOVLM1CB OCOVLM2CA OCOVLM4)
 // 
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
 err4 NOT INSIDE SealR_NOT_BULK
 err5 NOT INSIDE SealR_NOT_BULK
 err6 NOT INSIDE SealR_NOT_BULK
 err7 NOT INSIDE SealR_NOT_BULK
 err8 NOT INSIDE SealR_NOT_BULK
 err9 NOT INSIDE SealR_NOT_BULK
 err10 NOT INSIDE SealR_NOT_BULK
 err11 NOT INSIDE SealR_NOT_BULK
 err12 NOT INSIDE SealR_NOT_BULK
 err13 NOT INSIDE SealR_NOT_BULK
 err14 NOT INSIDE SealR_NOT_BULK
 err15 NOT INSIDE SealR_NOT_BULK
 err16 NOT INSIDE SealR_NOT_BULK
}

OCOVL_R_3 {
@ OCOVL_FEOL overlap DNW, NW, PSUB, AA, GT_P96, SN, SP, DG, V0, LOGO, INST, MARKS, MARKG, NODMF, OCCD, DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, V0DUB, EFUSE, RESNW, RESP1, RESP2, ESDIO2, DSTR, DIOMK2, DMPNP, VARMOS, LDBK, INDMY, FUSEMK1, DUM_AA, DUM_AR, DUM_GT, DUM_P2, DUM_M0, DUM_M0C, DUM_M0G, DUM_V0, SNDUM, SPDUM, NPAA, CELLB edge, DIOMK1, ESDIO1, SVT_N edge, SVT_P edge, HVT_N edge, HVT_P edge, LVT_N edge, LVT_P edge, ULVT_N edge, ULVT_P edge, LFN_N edge, LFN_P edge, MTFUSE, CTOP, AR_HDOP, AR_VDOP is not allowed
 err1 = OCOVL_FEOL and (OR DNW NW PSUB AA GT_P96 SN SP DG V0 LOGO INST MARKS MARKG NODMF OCCD DUMBA DUMBP ARDUB P2DUB M0DUB M0CDUB M0GDUB V0DUB EFUSE RESNW RESP1 RESP2 ESDIO2 DSTR DIOMK2 DMPNP VARMOS LDBK INDMY FUSEMK1 DUM_AA DUM_AR DUM_GT DUM_P2 DUM_M0 DUM_M0C DUM_M0G DUM_V0 SNDUM SPDUM NPAA MTFUSE CTOP AR_HDOP AR_VDOP DIOMK1 ESDIO1)
 err1 NOT INSIDE SealR_NOT_BULK
}

OCOVL_R_3_VT {
@ OCOVL_FEOL overlap DNW, NW, PSUB, AA, GT_P96, SN, SP, DG, V0, LOGO, INST, MARKS, MARKG, NODMF, OCCD, DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, V0DUB, EFUSE, RESNW, RESP1, RESP2, ESDIO2, DSTR, DIOMK2, DMPNP, VARMOS, LDBK, INDMY, FUSEMK1, DUM_AA, DUM_AR, DUM_GT, DUM_P2, DUM_M0, DUM_M0C, DUM_M0G, DUM_V0, SNDUM, SPDUM, NPAA, CELLB edge, DIOMK1, ESDIO1, SVT_N edge, SVT_P edge, HVT_N edge, HVT_P edge, LVT_N edge, LVT_P edge, ULVT_N edge, ULVT_P edge, LFN_N edge, LFN_P edge, MTFUSE, CTOP, AR_HDOP, AR_VDOP is not allowed
 err1 = (OR (EXPAND EDGE (CELLB INSIDE EDGE OCOVL_FEOL) BY 0.001) (EXPAND EDGE (SVT_N INSIDE EDGE OCOVL_FEOL) BY 0.001) (EXPAND EDGE (SVT_P INSIDE EDGE OCOVL_FEOL) BY 0.001) (EXPAND EDGE (HVT_N INSIDE EDGE OCOVL_FEOL) BY 0.001) (EXPAND EDGE (HVT_P INSIDE EDGE OCOVL_FEOL) BY 0.001) (EXPAND EDGE (LVT_N INSIDE EDGE OCOVL_FEOL) BY 0.001) (EXPAND EDGE (LVT_P INSIDE EDGE OCOVL_FEOL) BY 0.001) (EXPAND EDGE (ULVT_N INSIDE EDGE OCOVL_FEOL) BY 0.001) (EXPAND EDGE (ULVT_P INSIDE EDGE OCOVL_FEOL) BY 0.001) (EXPAND EDGE (LFN_N INSIDE EDGE OCOVL_FEOL) BY 0.001) (EXPAND EDGE (LFN_P INSIDE EDGE OCOVL_FEOL) BY 0.001)) AND OCOVL_FEOL
 err1 NOT INSIDE SealR_NOT_BULK
}

OCOVL_R_4 {
@ OCOVLM1CA overlap AA, M1CB, GT, M0C, M0G, INDMY, INST, LOGO, MARKS, MARKG, NODMF, OCCD, MTFUSE, MOMDMY, FUSEMK1, DUMBA, M1DUB, M0DUB, DUMBP, M0CDUB, M0GDUB, DUM_AA, DUM_M1, DUM_M0, DUM_GT, DUM_M0C, DUM_M0G, CTOP is not allowed
 err1 = OCOVLM1CA and (OR AA M1CB GT M0C M0G INDMY INST LOGO MARKS MARKG NODMF OCCD MTFUSE MOMDMY FUSEMK1 DUMBA M1DUB M0DUB DUMBP M0CDUB M0GDUB DUM_AA DUM_M1 DUM_M0 DUM_GT DUM_M0C DUM_M0G CTOP)
 err1 NOT INSIDE SealR_NOT_BULK
}

OCOVL_R_5 {
@ OCOVLM1CB overlap INDMY, INST, LOGO, MARKS, MARKG, NODMF, OCCD, MTFUSE, MOMDMY, FUSEMK1, M1DUB, M0DUB, M0CDUB, M0GDUB, DUM_M1, DUM_M0, DUM_M0C, DUM_M0G, CTOP is not allowed
 err1 = OCOVLM1CB and (OR INDMY INST LOGO MARKS MARKG NODMF OCCD MTFUSE MOMDMY FUSEMK1 M1DUB M0DUB M0CDUB M0GDUB DUM_M1 DUM_M0 DUM_M0C DUM_M0G CTOP)
 err1 NOT INSIDE SealR_NOT_BULK
}

OCOVL_R_6 {
@ OCOVLM2CA overlap M1CB, M2CB, M0C, M0, V0, INDMY, INST, LOGO, MARKS, MARKG, NODMF, OCCD, MTFUSE, MOMDMY, FUSEMK1, M1DUB, M2DUB, M0GDUB, M0CDUB, M0DUB, V0DUB, DUM_M1, DUM_M2, DUM_M0G, DUM_M0C, DUM_M0, DUM_V0, CTOP is not allowed
 err1 = OCOVLM2CA and (OR M1CB M2CB M0C M0 V0 INDMY INST LOGO MARKS MARKG NODMF OCCD MTFUSE MOMDMY FUSEMK1 M1DUB M2DUB M0GDUB M0CDUB M0DUB V0DUB DUM_M1 DUM_M2 DUM_M0G DUM_M0C DUM_M0 DUM_V0 CTOP)
 err1 NOT INSIDE SealR_NOT_BULK
}

OCOVL_R_7 {
@ OCOVLM4 overlap M1CB, M2CB, M3CB, V0, V1, V2, V3, INDMY, INST, LOGO, MARKS, MARKG, NODMF, OCCD, MTFUSE, MOMDMY, FUSEMK1, M3DUB, M4DUB, DUM_M1, DUM_M2, DUM_M3, DUM_M4, DUM_V0, DUM_V1, DUM_V2, DUM_V3, CTOP is not allowed
 err1 = OCOVLM4 and (OR M1CB M2CB M3CB V0 V1 V2 V3 INDMY INST LOGO MARKS MARKG NODMF OCCD MTFUSE MOMDMY FUSEMK1 M3DUB M4DUB DUM_M1 DUM_M2 DUM_M3 DUM_M4 DUM_V0 DUM_V1 DUM_V2 DUM_V3 CTOP)
 err1 NOT INSIDE SealR_NOT_BULK
}

OCOVL_R_8 {
@ OCOVLV0 overlap V0CB, M1CB, INDMY, INST, LOGO, MARKS, MARKG, NODMF, OCCD, MTFUSE, MOMDMY, FUSEMK1, V0DUB, M1DUB, M0GDUB, M0CDUB, M0DUB, DUM_V0, DUM_M1, DUM_M0G, DUM_M0C, DUM_M0, CTOP is not allowed
 err1 = OCOVLV0 and (OR V0CB M1CB INDMY INST LOGO MARKS MARKG NODMF OCCD MTFUSE MOMDMY FUSEMK1 V0DUB M1DUB M0GDUB M0CDUB M0DUB DUM_V0 DUM_M1 DUM_M0G DUM_M0C DUM_M0 CTOP)
 err1 NOT INSIDE SealR_NOT_BULK
}

OCOVL_R_9 {
@ V0, M1, M2, M3 inside OCOVL must be pre-colored
 err1 = (V0 NOT INTERACT (OR V0CA V0CB)) AND OCOVL
 err2 = (M1 NOT INTERACT (OR M1CA M1CB)) AND OCOVL
 err3 = (M2 NOT INTERACT (OR M2CA M2CB)) AND OCOVL
 err4 = (M3 NOT INTERACT (OR M3CA M3CB)) AND OCOVL

 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
 err4 NOT INSIDE SealR_NOT_BULK
}
#ENDIF

 
corn_met = OR  M1 M2 M3 M4 M5 M6 M7 TM2 
corn_via = OR  V1 V2 V3 V4 V5 V6 TV2 

#IFDEF CORN_RULES_CHECK YES
// =======================================================
// Chip Corner Design Rules
// chip Corner Requirement
// =======================================================

GROUP GCORN CORN_?

DRC:1:LOGO = EXTENT DRAWN ORIGINAL IGNORE LOGO
CHIP_CORNER_CHECK = INT DRC:1 < 66.6 ABUT REGION
CHIP_CORNER = INT DRC:1 < 66.6 ABUT REGION

CORN_1_no_NODMF {
@ NODMF is dummy block layer for chip corner chamfer area A, and must fully cover chamfer area A
 err1 = CHIP_CORNER_CHECK NOT NODMF
 err1 NOT INSIDE SealR_NOT_BULK
}

CORN_1_less_than_4_NODMF {
@ NODMF is dummy block layer for chip corner chamfer area A, and must fully cover chamfer area A
 err1 = CHIP_CORNER_CHECK INTERACT (DRC:1 INTERACT CHIP_CORNER_CHECK < 4)
 err1 NOT INSIDE SealR_NOT_BULK
}

CORN_2_3 {
@ Chamfer area A size at the chip corner = 66.6um
@ Chamfer area A size must be same as NODMF size
 NODMF_corner_edges = INT NODMF_v_edges NODMF_h_edges < 0.001 ABUT==90
 NODMF_corner_edges_whole = NODMF TOUCH EDGE (DFM COPY NODMF_corner_edges EDGE)
 err1 = LENGTH NODMF_corner_edges_whole < 66.6
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

CORN_5 {
@ The layers (listed in Note1) should not overlap with chamfer area A
 CHECK_LAYER = OR AA AADMP AR NW PSUB ALL_VT_IMP DG GT GTDMP P2 P2DMP SN SP M0 M0DMP M0G M0GDMP M0C M0CDMP DIR DIRDMP V0 PA ALPA MD MIM CTOP
 err1 = NODMF AND CHECK_LAYER
 err1 NOT INSIDE SealR_NOT_BULK
}

CORN_5_metal {
@ The layers (listed in Note1) should not overlap with chamfer area A
 err1 = NODMF AND corn_met
 err1 NOT INSIDE SealR_NOT_BULK
}

CORN_5_via {
@ The layers (listed in Note1) should not overlap with chamfer area A
 err1 = NODMF AND corn_via
 err1 NOT INSIDE SealR_NOT_BULK
}
#ENDIF


//#IFDEF EFUSE_RULES_CHECK YES
// =======================================================
// Metal E-Fuse/OTP layout guidelines
// =======================================================
// For the fuse component, it must be drawn EFUSE (81:2), MTFUSE (81:3), FUSEAD(81:4), FUSEMK1(81:152) marker layer
// E-fuse element is covered by EFUSE (81:2)
// E-fuse fuse link (function area) is marked with MTFUSE (81:3).
// E-fuse anode is marked with FUSEAD (81:4)
// All fuse component must be fully covered by FUSEMK1 (81:152)
// EFU.1a[G][NC] FUSEMK1(81:152) must fully cover all fuse component, including EFUSE (81:2) region, program transistor, etc
// EFU.2a[G][NC] EFUSE (81:2) must fully cover the whole fuse element and related dummy region
// EFU.3[G][NC] (MTFUSE AND M2) is just the EFUSE function area
// EFU.5[G][NC]	It is strongly recommended to adopt SMIC standard efuse element, including program transistor
// EFU.6[G][NC]	If designers plan to adopt customer own design, designers must provide efuse layout to SMIC for risk assessment before design start

GROUP GEFU EFU_?

EFU_1b_G {
@ FUSEMK1 (81;152) must interact with EFUSE (81;2) region
 err1 = FUSEMK1 NOT INTERACT EFUSE
 err1 NOT INSIDE SealR_NOT_BULK
}

EFU_1c_G {
@ EFUSE (81;2) region must be fully covered by FUSEMK1 (81;152)
 err1 = EFUSE NOT FUSEMK1
 err1 NOT INSIDE SealR_NOT_BULK
}

EFU_2b_G {
@ EFUSE (81;2) must interact with MTFUSE(81;3) and FUSEAD(81;4)
 err1 = EFUSE NOT INTERACT MTFUSE
 err2 = EFUSE NOT INTERACT FUSEAD
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

EFU_2c_G {
@ MTFUSE(81;3) and FUSEAD(81;4) must be fully covered by EFUSE (81;2)
 err1 = MTFUSE NOT EFUSE
 err2 = FUSEAD NOT EFUSE
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

EFU_4_G {
@ MTFUSE (81;3) region must exclude M1~M3 dummy patterns
 err1 = MTFUSE AND (OR M1DUM_all M1DOP_all)
 err2 = MTFUSE AND (OR M2DUM_all M2DOP_all)
 err3 = MTFUSE AND (OR M3DUM_all M3DOP_all)
//; err4 = MTFUSE AND (OR M4DUM_all M4DOP_all)
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
//; err4 NOT INSIDE SealR_NOT_BULK
}
//#ENDIF


// =======================
// High R Resistor
// =======================

GROUP GHR HR_?

DIR_WL_edges_a = DFM PROPERTY DIR DIR_h_edges DIR_v_edges OVERLAP ABUT ALSO MULTI [h_v_ratio = LENGTH(DIR_h_edges) - LENGTH(DIR_v_edges)] >= 0
DIR_WL_edges_b = DFM PROPERTY DIR DIR_h_edges DIR_v_edges OVERLAP ABUT ALSO MULTI [h_v_ratio = LENGTH(DIR_v_edges) - LENGTH(DIR_h_edges)] >= 0
DIR_W_edges = (DIR_v_edges COIN EDGE DIR_WL_edges_a) OR EDGE (DIR_h_edges COIN EDGE DIR_WL_edges_b)
DIR_L_edges = (DIR_h_edges COIN EDGE DIR_WL_edges_a) OR EDGE (DIR_v_edges COIN EDGE DIR_WL_edges_b)

DIRDMP_WL_edges_a = DFM PROPERTY DIRDMP DIRDMP_h_edges DIRDMP_v_edges OVERLAP ABUT ALSO MULTI [h_v_ratio = LENGTH(DIRDMP_h_edges) - LENGTH(DIRDMP_v_edges)] >= 0
DIRDMP_WL_edges_b = DFM PROPERTY DIRDMP DIRDMP_h_edges DIRDMP_v_edges OVERLAP ABUT ALSO MULTI [h_v_ratio = LENGTH(DIRDMP_v_edges) - LENGTH(DIRDMP_h_edges)] >= 0
DIRDMP_W_edges = (DIRDMP_v_edges COIN EDGE DIRDMP_WL_edges_a) OR EDGE (DIRDMP_h_edges COIN EDGE DIRDMP_WL_edges_b)
DIRDMP_L_edges = (DIRDMP_h_edges COIN EDGE DIRDMP_WL_edges_a) OR EDGE (DIRDMP_v_edges COIN EDGE DIRDMP_WL_edges_b)

ALL_DIR = DIR OR DIRDMP
HR_M0G_60 = M0G_060_ALL INTERACT DIR

DIR_AND_RESP1 = DIR AND RESP1
DIR_AND_RESP2 = DIR AND RESP2
ALL_DIR_AND_RESP2 = ALL_DIR AND RESP2

HR_W_1 {
@ DIR width = 0.12-1.8um
 err1 = INT DIR < 0.12 ABUT<90 SINGULAR REGION
 err2 = WITH WIDTH DIR > 1.8
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

HR_W_2 {
@ DIRDMP width = 0.192-1.8um
 err1 = INT DIRDMP < 0.192 ABUT<90 SINGULAR REGION
 err2 = WITH WIDTH DIRDMP > 1.8
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

HR_W_3 {
@ GTDMP width in S/D direction = 0.086um
 chk_mn = GTDMP INTERACT (RESP2 INTERACT ALL_DIR)
 err1 = INT chk_mn < 0.086 ABUT<90 SINGULAR REGION
 err2 = WITH WIDTH chk_mn > 0.086
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

HR_S_1 {
@ Space between (DIR OR DIRDMP) (DIR overlap with DIRDMP is not allowed) >= 0.192um
 err1 = EXT ALL_DIR < 0.192 ABUT<90 SINGULAR REGION
 err2 = DIR AND DIRDMP
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

HR_S_1_1 {
@ Space between (DIR OR DIRDMP) at length direction when PRL >= 0um. >= 0.192um
 err1 = EXT DIR_W_edges < 0.192 ABUT<90 PROJ>=0 REGION
 err2 = EXT DIRDMP_W_edges < 0.192 ABUT<90 PROJ>=0 REGION
 err3 = EXT DIR_W_edges DIRDMP_W_edges < 0.192 ABUT<90 PROJ>=0 REGION
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
}

HR_S_2 {
@ Space between (DIR OR DIRDMP) and (M0G OR M0) (Overlap is not allowed, except M0G (Width = 0.06um) INTERACT DIR) >= 0.345um
 err1_TMP = EXT ALL_DIR (M0G OR M0) < 0.345 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 = err1_TMP NOT INTERACT HR_M0G_60
 err1 NOT INSIDE SealR_NOT_BULK
}

HR_S_3 {
@ Space between (DIR OR DIRDMP) and (M0G INTERACT DIR) with width = 0.06um (M0G overlap with DIRDMP, DIR overlap with M0GDMP is not allowed) >= 0.178um
 err1 = EXT ALL_DIR HR_M0G_60 < 0.178 ABUT<90 SINGULAR REGION MEASURE ALL
 err2 = ((OR M0G M0GDMP) AND DIRDMP) OR (DIR AND M0GDMP)  //; M0GDMP overlap DIRDMP is also forbidden based on HR_S_4
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

HR_S_4 {
@ Space between (DIR OR DIRDMP) and (M0GDMP OR M0DMP) (Overlap is not allowed, except DIRDMP space to M0GDMP) >= 0.11um
 err1 = EXT DIR (M0GDMP OR M0DMP) < 0.11 ABUT<90 SINGULAR REGION INSIDE ALSO
 err2 = EXT DIRDMP M0DMP < 0.11 ABUT<90 SINGULAR REGION INSIDE ALSO
 err3 = DIRDMP AND M0GDMP
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
}

HR_S_6_1 {
@ Space between DIR and AOP_AA (Overlap is not allowed) >= 0.113um
 err1 = EXT DIR AOP_AA < 0.113 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

HR_S_6_2 {
@ Space between DIRDMP and AOP_AA (Overlap is not allowed) >= 0.078um
 err1 = EXT DIRDMP AOP_AA < 0.078 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

HR_S_7_1 {
@ Space between DIR and AOP_GT (Overlap is not allowed) >= 0.07um
 err1 = EXT DIR AOP_GT < 0.07 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

HR_S_7_2 {
@ Space between DIRDMP and GT (Overlap is not allowed) >= 0.07um
 err1 = EXT DIRDMP GT < 0.07 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

HR_S_8 {
@ Space between RESP1 and AOP_AA (Overlap with AA, cut with AADMP is not allowed) >= 0.065um
 err1 = EXT RESP1 AOP_AA < 0.065 ABUT<90 SINGULAR REGION
 err2 = RESP1 AND AA
 err3 = AADMP CUT RESP1
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
}

HR_S_9 {
@ Space between DIRDMP and GTDMP (overlap is not allowed) >= 0.035um
 err1 = EXT DIRDMP GTDMP < 0.035 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

HR_S_10 {
@ Space between DIR and RESP1 >= 0.257um
 err1 = EXT DIR RESP1 < 0.257 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

HR_EX_1 {
@ M0G (width = 0.06um) extension of DIR in DIR width direction at both sides (extension <= 0um is not allowed) = 0.014um
 err1 = INT (HR_M0G_60 NOT OUTSIDE EDGE DIR) < 0.002 ABUT==90 INTERSECTING ONLY REGION
 err1 NOT INSIDE SealR_NOT_BULK

 good_enc = ENC [DIR_L_edges] HR_M0G_60 == 0.014 ABUT<90 OPPOSITE
 err2 = (DIR_L_edges INSIDE EDGE HR_M0G_60) NOT COIN EDGE good_enc
 err2 NOT INSIDE EDGE SealR_NOT_BULK
}

HR_EX_2 {
@ DIR extension of M0G (width = 0.06um) in DIR length direction (extension <= 0um is not allowed) >= 0.063um
 err1 = INT (DIR NOT OUTSIDE EDGE HR_M0G_60) < 0.002 ABUT==90 INTERSECTING ONLY REGION
 err2 = ENC HR_M0G_60 DIR_W_edges < 0.063 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

HR_EN_1 {
@ RESP1 enclosure of ((AADMP OR DIRDMP) OR DIR) >= 0.065um
 err1 = ENC AADMP RESP1 < 0.065 ABUT<90 SINGULAR REGION
 err2 = ENC DIRDMP RESP1 < 0.065 ABUT<90 SINGULAR REGION
 err3 = ENC DIR RESP1 < 0.065 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
}

HR_EN_1a {
@ RESP1 enclosure of DIRDMP <= 0.36um
 chk_all = EXTENTS DIRDMP INSIDE OF LAYER RESP1
 chk_side = DIRDMP COIN EDGE chk_all
 err1 = ENC (chk_side) RESP1 <= 0.36 ABUT<90 OPPOSITE EXCLUDE SHIELDED
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

HR_L_1 {
@ Length of DIR or DIRDMP >= 0.61um
 err1 = LENGTH DIR_L_edges < 0.61
 err2 = LENGTH DIRDMP_L_edges < 0.61
 err3 = LENGTH (DIR TOUCH EDGE (DIR INSIDE EDGE RESP2)) < 0.61
 err4 = LENGTH (DIRDMP TOUCH EDGE (DIRDMP INSIDE EDGE RESP2)) < 0.61
 err1 NOT INSIDE EDGE SealR_NOT_BULK
 err2 NOT INSIDE EDGE SealR_NOT_BULK
 err3 NOT INSIDE EDGE SealR_NOT_BULK
 err4 NOT INSIDE EDGE SealR_NOT_BULK
}

HR_L_1_1 {
@ Length of high R resistor (DIR AND RESP2) >= 0.36um
 err1 = LENGTH (DIR_AND_RESP2 COIN EDGE DIR_L_edges) < 0.36
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

HR_L_2 {
@ Maximum length of high R resistor (DIR AND RESP2) <= 25um
 err1 = LENGTH DIR_AND_RESP2 > 25
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

HR_A_1 {
@ Area of DIR or DIRDMP >= 0.092um2
 err1 = AREA DIR < 0.092
 err2 = AREA DIRDMP < 0.092
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

HR_R_1 {
@ Square number (length/width) of high R resistor must be >= 1
 HR_w_side = DIR_AND_RESP2 INSIDE EDGE DIR
 HR_l_side = DIR NOT OUTSIDE EDGE RESP2
 err1 = DFM PROPERTY DIR_AND_RESP2 HR_w_side HR_l_side OVERLAP ABUT ALSO [squares = LENGTH(HR_l_side)/LENGTH(HR_w_side)] < 1
 err1 NOT INSIDE SealR_NOT_BULK
}

HR_R_2 {
@ DIRDMP must be placed 2-side beside high R resistor
@ RESP2/RESP1 must interact two DIRDMPs within 2.3um in HR resistor width direction
 hr_RES_A_area = (RESP2 NOT DIR) INTERACT DIR_AND_RESP2
 hr_RES_L_side = EXPAND EDGE (DIR_AND_RESP2 COIN EDGE DIR_L_edges) OUTSIDE BY 0.001
 hr_RES_L_s230 = SIZE hr_RES_L_side BY 2.299 INSIDE OF hr_RES_A_area STEP 0.1

 err1 = (hr_RES_L_s230 NOT INTERACT DIRDMP) TOUCH DIR == 1  //;only check the outer-most side
 err2 = RESP1 INTERACT DIRDMP < 2
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

HR_R_3 {
@ DIR, DIRDMP, and RESP2 (INTERACT DIR) must be 3 rectangle orthogonal to grid respectively
 err1 = NOT RECTANGLE DIR ORTHOGONAL ONLY
 err2 = NOT RECTANGLE DIRDMP ORTHOGONAL ONLY
 err3 = NOT RECTANGLE (RESP2 INTERACT DIR) ORTHOGONAL ONLY
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
}

HR_R_4 {
@ DIR resistor can only use M0G (width = 0.06um)
 err1 = (DIR NOT INTERACT M0G_060) OR ((M0G NOT M0G_060) INTERACT DIR)
 err1 NOT INSIDE SealR_NOT_BULK
}

HR_R_5 {
@ RESP2 must abut with M0G edge, RESP2 must interact at least two DIRDMP
 err1 = (DIR_AND_RESP2 INSIDE EDGE DIR) NOT COIN OUTSIDE EDGE M0G //; not abut with M0G edge
 err2 = RESP2 INTERACT DIRDMP == 1
 err3 = RESP2 NOT INTERACT DIRDMP
 err1 NOT INSIDE EDGE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
}

HR_R_6 {
@ RESP2 intersecting DIR or DIRDMP must form two or more DIRs or DIRDMPs
 err1 = INT (RESP2 INSIDE EDGE ALL_DIR) < 0.005 ABUT INTERSECTING ONLY REGION
 err2 = EXPAND EDGE ((DIR_W_edges OR EDGE DIRDMP_W_edges) NOT OUTSIDE EDGE RESP2) BY 0.001
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

DIR_W_edges_in_resp1 = DIR_W_edges NOT OUTSIDE EDGE RESP1
DIR_W_edges_in_resp1_v_edges = ANGLE DIR_W_edges_in_resp1 == 90
DIR_W_edges_in_resp1_h_edges = ANGLE DIR_W_edges_in_resp1 == 0

HR_R_7 {
@ DIR must be covered by RESP1, and must be uni-direction in the same RESP1
 direction_h_DIR = EXPAND EDGE DIR_W_edges_in_resp1_v_edges INSIDE BY 0.001
 direction_v_DIR = EXPAND EDGE DIR_W_edges_in_resp1_h_edges INSIDE BY 0.001
 err1_TMP = (RESP1 INTERACT direction_h_DIR) INTERACT direction_v_DIR
 err1 = direction_h_DIR INTERACT err1_TMP
 err1 NOT INSIDE SealR_NOT_BULK

 err2 = DIR NOT RESP1
 err2 NOT INSIDE SealR_NOT_BULK
}

HR_R_8 {
@ RESP1 and RESP2 must INTERACT DIR
 err1 = (RESP1 NOT INTERACT DIR) OR (RESP2 NOT INTERACT DIR)
 err1 NOT INSIDE SealR_NOT_BULK
}

HR_R_9 {
@ M0G (INTERACT DIR) INTERACT GT is not allowed
 err1 = (M0G INTERACT DIR) INTERACT GT
 err1 NOT INSIDE SealR_NOT_BULK
}

//HR_NET_vol_neg = HR_c INTERACT MG_NET_vol_neg
//HR_NET_vol_pos = HR_c INTERACT MG_NET_vol_pos
//HR_NET_vol_gt_pos_560 = HR_c INTERACT MG_NET_vol_gt_pos_560
//HR_NET_vol_lt_neg_560 = HR_c INTERACT MG_NET_vol_lt_neg_560

#IFDEF Delta_Voltage_Rules_Check YES
VARIABLE HR_R_10_DIR_2_DIR_val 1.6
VARIABLE HR_R_10_DIR_2_M0_val 3.6
VARIABLE HR_R_10_DIR_2_M0G_val 3.6
VARIABLE HR_R_10_DIR_2_GT_val 0.42
VARIABLE HR_R_10_DIR_2_GT_NOT_P2_val 0.72

HR_R_10_DIR_2_DIR {
@ Maximum delta V >= 5.6V is not allowed, when:
@ 1. Space between two DIR/DIRDMP is < 1.6um
@ 2. Space between DIR/DIRDMP and (AOP_M0G OR (M0 NOT M0C)) is < 3.6um
@ 3. Space between DIR and AOP_GT is < 0.42um
@ 4. DIR space to (AOP_GT NOT P2) is < 0.72um
 err1 = DFM DV HR_c < HR_R_10_DIR_2_DIR_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" >= 5.6 ANNOTATE NOT CONNECTED SINGULAR
 DFM COPY err1

 err2 = DFM DV HR_c DIRDMP < HR_R_10_DIR_2_DIR_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" >= 5.6 ANNOTATE NOT CONNECTED SINGULAR
 DFM COPY err2

/*
 err2 = EXT HR_NET_vol_gt_pos_560 DIRDMP < HR_R_10_DIR_2_DIR_val SINGULAR REGION
 err3 = EXT HR_NET_vol_lt_neg_560 DIRDMP < HR_R_10_DIR_2_DIR_val SINGULAR REGION
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
*/
}

HR_R_10_DIR_2_M0 {
@ Maximum delta V >= 5.6V is not allowed, when:
@ 1. Space between two DIR/DIRDMP is < 1.6um
@ 2. Space between DIR/DIRDMP and (AOP_M0G OR (M0 NOT M0C)) is < 3.6um
@ 3. Space between DIR and AOP_GT is < 0.42um
@ 4. DIR space to (AOP_GT NOT P2) is < 0.72um
 err1 = DFM DV HR_c M0_NOT_M0C < HR_R_10_DIR_2_M0_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" >= 5.6 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err1

 err2 = DFM DV HR_c delta_DOP_M0 < HR_R_10_DIR_2_M0_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" >= 5.6 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err2

 err3 = DFM DV M0_NOT_M0C DIRDMP < HR_R_10_DIR_2_M0_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" >= 5.6 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err3

/*
 err2 = EXT HR_NET_vol_gt_pos_560 delta_DOP_M0 < HR_R_10_DIR_2_M0_val SINGULAR REGION MEASURE ALL
 err3 = EXT HR_NET_vol_lt_neg_560 delta_DOP_M0 < HR_R_10_DIR_2_M0_val SINGULAR REGION MEASURE ALL
 err4 = EXT M0_NET_vol_gt_pos_560 DIRDMP < HR_R_10_DIR_2_M0_val SINGULAR REGION MEASURE ALL
 err5 = EXT M0_NET_vol_lt_neg_560 DIRDMP < HR_R_10_DIR_2_M0_val SINGULAR REGION MEASURE ALL
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
 err4 NOT INSIDE SealR_NOT_BULK
 err5 NOT INSIDE SealR_NOT_BULK
*/
}

HR_R_10_DIR_2_M0G {
@ Maximum delta V >= 5.6V is not allowed, when:
@ 1. Space between two DIR/DIRDMP is < 1.6um
@ 2. Space between DIR/DIRDMP and (AOP_M0G OR (M0 NOT M0C)) is < 3.6um
@ 3. Space between DIR and AOP_GT is < 0.42um
@ 4. DIR space to (AOP_GT NOT P2) is < 0.72um
 err1 = DFM DV HR_c M0G < HR_R_10_DIR_2_M0G_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" >= 5.6 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err1

 err2 = DFM DV HR_c DOP_M0G < HR_R_10_DIR_2_M0G_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" >= 5.6 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err2

 err3 = DFM DV M0G DIRDMP < HR_R_10_DIR_2_M0G_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" >= 5.6 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err3

/*
 err2 = EXT HR_NET_vol_gt_pos_560 DOP_M0G < HR_R_10_DIR_2_M0G_val SINGULAR REGION MEASURE ALL
 err3 = EXT HR_NET_vol_lt_neg_560 DOP_M0G < HR_R_10_DIR_2_M0G_val SINGULAR REGION MEASURE ALL
 err4 = EXT MG_NET_vol_gt_pos_560 DIRDMP < HR_R_10_DIR_2_M0G_val SINGULAR REGION MEASURE ALL
 err5 = EXT MG_NET_vol_lt_neg_560 DIRDMP < HR_R_10_DIR_2_M0G_val SINGULAR REGION MEASURE ALL
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
 err4 NOT INSIDE SealR_NOT_BULK
 err5 NOT INSIDE SealR_NOT_BULK
*/
}

HR_R_10_DIR_2_GT {
@ Maximum delta V >= 5.6V is not allowed, when:
@ 1. Space between two DIR/DIRDMP is < 1.6um
@ 2. Space between DIR/DIRDMP and (AOP_M0G OR (M0 NOT M0C)) is < 3.6um
@ 3. Space between DIR and AOP_GT is < 0.42um
@ 4. DIR space to (AOP_GT NOT P2) is < 0.72um
 err1 = DFM DV HR_c GT_0 < HR_R_10_DIR_2_GT_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" >= 5.6 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err1

 err2 = DFM DV HR_c DOP_GT < HR_R_10_DIR_2_GT_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" >= 5.6 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err2

 err3 = DFM DV GT_0 DIRDMP < HR_R_10_DIR_2_GT_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" >= 5.6 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err3

/*
 err2 = EXT HR_NET_vol_gt_pos_560 DOP_GT < HR_R_10_DIR_2_GT_val SINGULAR REGION MEASURE ALL
 err3 = EXT HR_NET_vol_lt_neg_560 DOP_GT < HR_R_10_DIR_2_GT_val SINGULAR REGION MEASURE ALL
 err4 = EXT GT_NET_vol_gt_pos_560 DIRDMP < HR_R_10_DIR_2_GT_val SINGULAR REGION MEASURE ALL
 err5 = EXT GT_NET_vol_lt_neg_560 DIRDMP < HR_R_10_DIR_2_GT_val SINGULAR REGION MEASURE ALL
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
 err4 NOT INSIDE SealR_NOT_BULK
 err5 NOT INSIDE SealR_NOT_BULK
*/
}

HR_R_10_DIR_2_GT_NOT_P2 {
@ Maximum delta V >= 5.6V is not allowed, when:
@ 1. Space between two DIR/DIRDMP is < 1.6um
@ 2. Space between DIR/DIRDMP and (AOP_M0G OR (M0 NOT M0C)) is < 3.6um
@ 3. Space between DIR and AOP_GT is < 0.42um
@ 4. DIR space to (AOP_GT NOT P2) is < 0.72um
 err1 = DFM DV HR_c GT_0 < HR_R_10_DIR_2_GT_NOT_P2_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" >= 5.6 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err1

 err2 = DFM DV HR_c DOP_GT_NOT_P2 < HR_R_10_DIR_2_GT_NOT_P2_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" >= 5.6 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err2

 err3 = DFM DV GT_0 DIRDMP < HR_R_10_DIR_2_GT_NOT_P2_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" >= 5.6 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err3

/*
 err2 = EXT HR_NET_vol_gt_pos_560 DOP_GT_NOT_P2 < HR_R_10_DIR_2_GT_NOT_P2_val SINGULAR REGION MEASURE ALL
 err3 = EXT HR_NET_vol_lt_neg_560 DOP_GT_NOT_P2 < HR_R_10_DIR_2_GT_NOT_P2_val SINGULAR REGION MEASURE ALL
 err4 = EXT GT_NET_vol_gt_pos_560 DIRDMP < HR_R_10_DIR_2_GT_NOT_P2_val SINGULAR REGION MEASURE ALL
 err5 = EXT GT_NET_vol_lt_neg_560 DIRDMP < HR_R_10_DIR_2_GT_NOT_P2_val SINGULAR REGION MEASURE ALL
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
 err4 NOT INSIDE SealR_NOT_BULK
 err5 NOT INSIDE SealR_NOT_BULK
*/
}
#ENDIF

HR_R_15 {
@ (RESP2 AND DIR) overlap M0G is not allowed
 err1 = DIR_AND_RESP2 AND M0G
 err1 NOT INSIDE SealR_NOT_BULK
}

HR_R_16 {
@ DIRDMP length must be same with DIR in DIR length direction
 chk_area = (RESP2 INTERACT ALL_DIR) NOT ALL_DIR_AND_RESP2
 chk_edge = ALL_DIR TOUCH EDGE (chk_area COIN EDGE ALL_DIR_AND_RESP2)
 err1 = DFM PROPERTY chk_area chk_edge OVERLAP ABUT ALSO MULTI [-= count(chk_edge)] == 2 [+= (max(length(chk_edge)) == min(length(chk_edge))) ? 1 : 0] == 0
 err1 NOT INSIDE SealR_NOT_BULK
}

HR_R_17_AADMP {
@ AADMP/GTDMP/M0GDMP must to be drawn in RESP2 region
@ DRC flags Without AADMP
 chk_area = ((RESP2 INTERACT ALL_DIR) NOT ALL_DIR_AND_RESP2) INTERACT ALL_DIR_AND_RESP2 == 2
 err1 = chk_area NOT INTERACT AADMP
 err1 NOT INSIDE SealR_NOT_BULK
}

HR_R_17_GTDMP {
@ AADMP/GTDMP/M0GDMP must to be drawn in RESP2 region
@ DRC flags Without GTDMP
 chk_area = ((RESP2 INTERACT ALL_DIR) NOT ALL_DIR_AND_RESP2) INTERACT ALL_DIR_AND_RESP2 == 2
 err1 = chk_area NOT INTERACT GTDMP
 err1 NOT INSIDE SealR_NOT_BULK
}

HR_R_17_M0GDMP {
@ AADMP/GTDMP/M0GDMP must to be drawn in RESP2 region
@ DRC flags Without M0GDMP
 chk_area = ((RESP2 INTERACT ALL_DIR) NOT ALL_DIR_AND_RESP2) INTERACT ALL_DIR_AND_RESP2 == 2
 err1 = chk_area NOT INTERACT M0GDMP
 err1 NOT INSIDE SealR_NOT_BULK
}

HR_R_18 {
@ M0DMP interact with RESP1 is not allowed
 err1 = M0DMP INTERACT RESP1
 err1 NOT INSIDE SealR_NOT_BULK
}

ALL_DIR_NOT_MARKS = ALL_DIR NOT MARKS

#IFDEF IP_LEVEL_DENSITY_CHECK YES
VARIABLE HR_DN_1_val 50
VARIABLE HR_DN_1_window 20

HR_DN_1 {
@ (DIR OR DIRDMP) density in window 20umx20um, stepping 20um/step_number. <= 50%
 check_region = COPY CHIP_NOT_MARKS
 check_pattern = ALL_DIR AND check_region

 check_window1 = check_region WITH WIDTH >= HR_DN_1_window/4
 err1_TMP1 = DENSITY check_pattern check_window1 check_region [!!AREA(check_window1)*AREA(check_pattern)/AREA(check_region)] > HR_DN_1_val/100 WINDOW HR_DN_1_window STEP HR_DN_1_window/step_number BACKUP INSIDE OF LAYER DRC:1 BY POLYGON

 check_window2 = WITH WIDTH (check_region AND err1_TMP1) >= HR_DN_1_window/4
 err1_TMP2 = DENSITY check_pattern check_window2 check_region [!!AREA(check_window2)*AREA(check_pattern)/AREA(check_region)] > HR_DN_1_val/100 WINDOW HR_DN_1_window STEP HR_DN_1_window/step_number BACKUP INSIDE OF LAYER err1_TMP1 BY POLYGON

 check_window3 = WITH WIDTH (check_region AND err1_TMP2) >= HR_DN_1_window/4
 DENSITY check_pattern check_window3 check_region [!!AREA(check_window3)*AREA(check_pattern)/AREA(check_region)] > HR_DN_1_val/100 WINDOW HR_DN_1_window STEP HR_DN_1_window/step_number BACKUP INSIDE OF LAYER err1_TMP2 BY POLYGON PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_HR_DN_1.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_HR_DN_1.rdb"
}

HR_DN_2 {
@ (DIR OR DIRDMP) full chip density <= 30%
 DENSITY ALL_DIR_NOT_MARKS CHIP_NOT_MARKS [AREA(ALL_DIR_NOT_MARKS)/AREA(CHIP_NOT_MARKS)] > 0.3 PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_HR_DN_2.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_HR_DN_2.rdb"
}
#ENDIF

#IFDEF IP_LEVEL_DENSITY_CHECK NO
VARIABLE HR_DN_1_val 50
VARIABLE HR_DN_1_window 20

HR_DN_1 {
@ (DIR OR DIRDMP) density in window 20umx20um, stepping 10um. <= 50%
 check_region = COPY CHIP_NOT_MARKS
 check_pattern = ALL_DIR AND check_region

 check_window1 = check_region WITH WIDTH >= HR_DN_1_window/4
 err1_TMP1 = DENSITY check_pattern check_window1 check_region [!!AREA(check_window1)*AREA(check_pattern)/AREA(check_region)] > HR_DN_1_val/100 WINDOW HR_DN_1_window STEP HR_DN_1_window/2 BACKUP INSIDE OF LAYER DRC:1 BY POLYGON

 check_window2 = WITH WIDTH (check_region AND err1_TMP1) >= HR_DN_1_window/4
 err1_TMP2 = DENSITY check_pattern check_window2 check_region [!!AREA(check_window2)*AREA(check_pattern)/AREA(check_region)] > HR_DN_1_val/100 WINDOW HR_DN_1_window STEP HR_DN_1_window/2 BACKUP INSIDE OF LAYER err1_TMP1 BY POLYGON

 check_window3 = WITH WIDTH (check_region AND err1_TMP2) >= HR_DN_1_window/4
 DENSITY check_pattern check_window3 check_region [!!AREA(check_window3)*AREA(check_pattern)/AREA(check_region)] > HR_DN_1_val/100 WINDOW HR_DN_1_window STEP HR_DN_1_window/2 BACKUP INSIDE OF LAYER err1_TMP2 BY POLYGON PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_HR_DN_1.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_HR_DN_1.rdb"
}

HR_DN_2 {
@ (DIR OR DIRDMP) full chip density <= 30%
 DENSITY ALL_DIR_NOT_MARKS CHIP_NOT_MARKS [AREA(ALL_DIR_NOT_MARKS)/AREA(CHIP_NOT_MARKS)] > 0.3 PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_HR_DN_2.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_HR_DN_2.rdb"
}
#ENDIF


// ====================
// NW_STI resistor design rules
// ====================

GROUP GRESNW RESNW_?

RESNW_W_1 {
@ Resistor NW width >= 1.584um
 chk_NW = NWR NOT OUTSIDE EDGE RESNW  //;based on RESNW.R.2
 err1 = INT chk_NW < 1.584 ABUT<90 REGION EXCLUDE SHIELDED
 err1 NOT INSIDE SealR_NOT_BULK
}

RESNW_W_1a {
@ Suggest Nsq of resistor (length/width ratio) >= 1 for stable resistance
 NWR_L_edges = NWR INSIDE EDGE RESNW  //;based on RESNW.R.1/2
 NWR_W_edges = NWR TOUCH OUTSIDE EDGE AA
 err1 = DFM PROPERTY NWR NWR_L_edges NWR_W_edges OVERLAP ABUT ALSO MULTI [l_w_ratio = length(NWR_L_edges) - length(NWR_W_edges)] < 0
 err1 NOT INSIDE SealR_NOT_BULK
}

RESNW_S_1 {
@ Space between Resistor NW and Resistor NW or NW >= 0.90um
 err1 = EXT NWR NW < 0.9 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

RESNW_S_2 {
@ Space between RESNW and ALL_AA (Overlap is not allowed) >= 0.432um
 err1 = EXT (ALL_AA NOT INTERACT NWRT) RESNW < 0.432 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

RESNW_EN_1 {
@ SN enclosure of (AA INTERACT Resistor NW) >= 0.341um
 err1 = ENC (AA_NWR AND SN) SN < 0.341 ABUT<90 SINGULAR REGION OUTSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK

 err2 = AA_NWR NOT SN
 err2 NOT INSIDE SealR_NOT_BULK
}

RESNW_EN_1a {
@ SN enclosure of (AA INTERACT Resistor NW) (AA vertical edge extend 1/2 GT width) in S/D direction >= 0.360um
 err1_c = ANGLE (OR AA_NWR (GT_and_GTMK1 INTERACT AA_NWR)) == 90
 err1 = ENC err1_c SN < 0.36 ABUT<90 EXCLUDE SHIELDED OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

RESNW_EX_1 {
@ AA extension outside of Resistor NW in GATE poly direction >= 0.289um
 err1 = ENC NWR AA_h_edges < 0.289 ABUT<90 OPPOSITE REGION
 err2 = INT (NWR NOT INSIDE EDGE AA_NWR) < 0.005 ABUT==90 INTERSECTING ONLY REGION
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

RESNW_EX_1a {
@ AA (vertical edge extend 1/2 GT width) extension outside of Resistor NW in S/D direction >= 0.270um
 chk_AA = OR AA_NWR (GT_and_GTMK1 INTERACT AA_NWR)
 err1 = ENC (ANGLE NWR > 88 <= 90) chk_AA < 0.27 ABUT<90 EXCLUDE SHIELDED OPPOSITE REGION //;nwr CUT GT is allowed
 err1 NOT INSIDE SealR_NOT_BULK
}

RESNW_EX_2 {
@ RESNW extension outside of NW resistor along resistor width direction <= 0.4um
 chk_RESNW = (RESNW INTERACT NWR) NOT TOUCH EDGE AA_NWR  //;based on RESNW_R_1
 err1 = ENC NW (chk_RESNW) <= 0.400 ABUT<90 OPPOSITE EXCLUDE SHIELDED
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

RESNW_R_1 {
@ RESNW horizontal edge must align with AA horizontal edge
 err1 = NWR_BODY TOUCH AA == 1
 err2 = NWR_BODY NOT TOUCH AA
 err3 = NWR_BODY AND AA
 err4 = (RESNW INSIDE EDGE NW) NOT TOUCH EDGE AA
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
 err4 NOT INSIDE EDGE SealR_NOT_BULK
}

RESNW_R_2 {
@ RESNW must separate Resistor NW into two or more NWs
 nwr_terminal = NWR NOT RESNW
 err1 = NWR_BODY NOT INTERACT nwr_terminal
 err2 = NWR_BODY INTERACT nwr_terminal == 1
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

RESNW_R_3 {
@ NW resistor must be rectangle
 err1 = NOT RECTANGLE NWR_BODY ORTHOGONAL ONLY
 err1 NOT INSIDE SealR_NOT_BULK
}

RESNW_R_4 {
@ DNW, SP, SVT_P, LVT_P, HVT_P, ULVT_P, LFN_P implant layers are not allowed in NW resistor area
 err1 = (OR DNW SP SVT_P LVT_P HVT_P ULVT_P LFN_P) AND (OR NWR_BODY AA_NWR)
 err1 NOT INSIDE SealR_NOT_BULK
}

RESNW_R_5 {
@ NW resistor length direction must be GATE poly direction
 err1 = ANGLE (NWR_BODY INSIDE EDGE RESNW) != 90
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

//=======================
//  Diode desing rules
//=======================

GROUP GDSTR DSTR_?

DIODE_IO_AA = (ACT AND DSTR) AND DG  //;exclude nw/rw diode
DIODE_CORE_AA = (ACT AND DSTR) NOT DG  //;exclude nw/rw diode

DSTR_CORE_SP = (HOLES SP INNER) ENCLOSE (DIODE_CORE_AA AND NACT)
DSTR_CORE_SN = (HOLES SN INNER) ENCLOSE (DIODE_CORE_AA AND PACT)
NTAP_DIODE_in_SN = NTAP_RAW INTERACT (SN INTERACT DSTR_CORE_SN)
PTAP_DIODE_in_SP = PTAP_RAW INTERACT (SP INTERACT DSTR_CORE_SP)

DSTR_W_1 {
@ DSTR width >= 0.192um
 err1 = INT DSTR < 0.192 ABUT<90 REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

DSTR_W_2 {
@ (GT AND GTMK1) width of core region in S/D direction except pickup area = 0.02um
 chk_GT = ((GT_and_GTMK1 AND DSTR) OUTSIDE DG) NOT INTERACT TAP_RAW
 err1 = INT chk_GT < 0.02 ABUT<90 SINGULAR REGION
 err2 = chk_GT WITH WIDTH > 0.02
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

DSTR_W_3 {
@ (GT AND GTMK1) width of I/O region and pickup of core region in S/D direction = 0.086um
 NTAP_DIODE_merged = NTAP_RAW WITH EDGE (EXT [NTAP_DIODE_in_SN] DSTR_CORE_SN < 0.55 ABUT<90 EXCLUDE SHIELDED)
 PTAP_DIODE_merged = PTAP_RAW WITH EDGE (EXT [PTAP_DIODE_in_SP] DSTR_CORE_SP < 0.55 ABUT<90 EXCLUDE SHIELDED)
 chk_CR = ((GT_and_GTMK1 AND DSTR) NOT OUTSIDE DG) NOT INTERACT TAP_RAW
 chk_IO = GT_and_GTMK1 NOT OUTSIDE (OR NTAP_DIODE_merged PTAP_DIODE_merged)
 chk_GT = OR chk_CR chk_IO

 err1 = INT chk_GT < 0.086 ABUT<90 SINGULAR REGION
 err2 = chk_GT WITH WIDTH > 0.086
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

DSTR_S_1 {
@ DSTR space >= 0.192um
 err1 = EXT DSTR < 0.192 ABUT<90 REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

DSTR_S_2 {
@ Space between DSTR (INTERACT ACTIVE) and ACTIVE (ACTIVE CUT DSTR is not allowed) >= 0.048um
 err1 = EXT (DSTR INTERACT ACT) ACT < 0.048 ABUT<90 REGION
 err2 = (DSTR CUT ACT) INSIDE EDGE ACT
 err3 = ACT CUT DSTR  //; abnormal relationship
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE EDGE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
}

DSTR_S_2a {
@ Space between DSTR (INTERACT ACTIVE) and ACTIVE (ACTIVE vertical edge expanding 1/2 GT width) in S/D direction, (ACTIVE CUT DSTR is not allowed) >= 0.065um
 chk_ACT = edge_gate_AA_act NOT OUTSIDE ACT
 chk_DSTR = ANGLE (DSTR INTERACT chk_ACT) == 90
 err1 = EXT chk_DSTR chk_ACT < 0.065 ABUT<90 OPPOSITE REGION
 err2 = (DSTR CUT chk_ACT) INSIDE EDGE chk_ACT
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE EDGE SealR_NOT_BULK
}

DSTR_S_3 {
@ Space between DSTR and ALL_GT >= 0.035um
 err1 = EXT DSTR ALL_GT < 0.035 ABUT<90 SINGULAR REGION MEASURE ALL
 err1 NOT INSIDE SealR_NOT_BULK
}

DSTR_EN_1 {
@ DSTR enclosure of ACTIVE (INTERACT M0) >= 0.048um
 err1 = ENC ((ACT INTERACT M0) AND DSTR) DSTR < 0.048 ABUT<90 REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

DSTR_EN_1a {
@ DSTR enclosure of ACTIVE (INTERACT M0, ACTIVE vertical edge expanding 1/2 GT width) in S/D direction >= 0.065um
 chk_aa = edge_gate_AA_act NOT OUTSIDE ACT
 chk_mn = chk_aa INTERACT M0
 err1 = ENC (chk_mn AND DSTR) (ANGLE DSTR != 0) < 0.065 ABUT<90 OPPOSITE REGION EXCLUDE SHIELDED
 err1 NOT INSIDE SealR_NOT_BULK
}

DSTR_EN_2 {
@ DSTR enclosure of ALL_GT (Except GT jog width <= 0.004um) >= 0.035um
 chk_GT = ALL_GT NOT COIN EDGE (LENGTH GT_convex_equal_one_edge <= 0.004)
 err1 = ENC chk_GT DSTR < 0.035 ABUT<90 REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

DSTR_A_1 {
@ Area of DSTR (INTERACT ACTIVE) >= 0.092um2
 err1 = AREA (DSTR INTERACT ACT) < 0.092
 err1 NOT INSIDE SealR_NOT_BULK
}

DSTR_A_2 {
@ Enclosed area of DSTR (INTERACT ACTIVE) >= 0.092um2
 err1 = AREA (((HOLES DSTR INNER) INTERACT ACT) NOT DSTR) < 0.092
 err1 NOT INSIDE SealR_NOT_BULK
}

DSTR_R_1 {
@ DSTR overlap SVT_N, SVT_P, LVT_N, LVT_P, HVT_N, HVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P is not allowed
 err1 = AND DSTR ALL_VT_IMP
 err1 NOT INSIDE SealR_NOT_BULK
}

DSTR_R_2 {
@ ((GT NOT P2) INTERACT ACTIVE) must connect to S/D ACTIVE in DSTR region
 chk_GT = (GT_0 INTERACT ACT) AND DSTR
 good_a = (NET AREA RATIO chk_GT real_NSD [!!AREA(chk_GT)*!!AREA(real_NSD)] > 0) OR (NET AREA RATIO chk_GT real_PSD [!!AREA(chk_GT)*!!AREA(real_PSD)] > 0)
 good_b = (NET AREA RATIO chk_GT N_inject [!!AREA(chk_GT)*!!AREA(N_inject)] > 0) OR (NET AREA RATIO chk_GT P_inject [!!AREA(chk_GT)*!!AREA(P_inject)] > 0)
 err1 = chk_GT NOT (OR good_a good_b)
 err1 NOT INSIDE SealR_NOT_BULK
}

#IFDEF Delta_Voltage_Rules_Check YES
DIO_GATE_CORE = ((GT_0 AND GATE_raw) AND DSTR) NOT DG

DIO_GATE_in_PW = DIO_GATE_CORE AND (ACT AND PW_0)
DIO_GATE_in_NW = DIO_GATE_CORE AND (ACT AND NW)
DIO_GATE_PW = PW_0 AND DIO_GATE_in_PW
DIO_GATE_NW = NW AND DIO_GATE_in_NW

DSTR_R_3_pdio {
@ Delta V > 3V between core diode GATE and core diode bulk is not allowed
//;exclude rw diode
 gate_netid = DFM PROPERTY DIO_GATE_in_PW net_vol_assign NODAL MULTI
 [max_vol = property(net_vol_assign, max_vol)]
 [min_vol = property(net_vol_assign, min_vol)]

 bulk_netid = DFM PROPERTY DIO_GATE_PW net_vol_assign NODAL MULTI
 [max_vol = property(net_vol_assign, max_vol)]
 [min_vol = property(net_vol_assign, min_vol)]

 err1 = DFM PROPERTY DIO_GATE_in_PW gate_netid bulk_netid ABUT ALSO OVERLAP MULTI
 [VH_1 = property(gate_netid, max_vol)]
 [VL_1 = property(gate_netid, min_vol)]
 [VH_2 = property(bulk_netid, max_vol)]
 [VL_2 = property(bulk_netid, min_vol)]
 [DT_v = fmax((property_ref(VH_1) - property_ref(VL_2)), (property_ref(VH_2) - property_ref(VL_1)))] > 3
 err1 NOT INSIDE SealR_NOT_BULK
}

DSTR_R_3_ndio {
@ Delta V > 3V between core diode GATE and core diode bulk is not allowed
//;exclude nwdio, dnwdio
 gate_netid = DFM PROPERTY DIO_GATE_in_NW net_vol_assign NODAL MULTI
 [max_vol = property(net_vol_assign, max_vol)]
 [min_vol = property(net_vol_assign, min_vol)]

 bulk_netid = DFM PROPERTY DIO_GATE_NW net_vol_assign NODAL MULTI
 [max_vol = property(net_vol_assign, max_vol)]
 [min_vol = property(net_vol_assign, min_vol)]

 err1 = DFM PROPERTY DIO_GATE_in_NW gate_netid bulk_netid ABUT ALSO OVERLAP MULTI
 [VH_1 = property(gate_netid, max_vol)]
 [VL_1 = property(gate_netid, min_vol)]
 [VH_2 = property(bulk_netid, max_vol)]
 [VL_2 = property(bulk_netid, min_vol)]
 [DT_v = fmax((property_ref(VH_1) - property_ref(VL_2)), (property_ref(VH_2) - property_ref(VL_1)))] > 3
 err1 NOT INSIDE SealR_NOT_BULK
}
#ENDIF


// =======================================================
// Gated Diode design rules
// =======================================================

GROUP GGATED GATED_?

GATE_DIOMK2 = (GATE_raw AND DIOMK2) AND AA
NGATE_DIOMK2 = GATE_DIOMK2 AND SN
PGATE_DIOMK2 = GATE_DIOMK2 AND SP
NGATE_DIOMK2_real = NGATE_DIOMK2 NOT WITH EDGE (NGATE_DIOMK2 COIN EDGE AA_v_edges)
PGATE_DIOMK2_real = PGATE_DIOMK2 NOT WITH EDGE (PGATE_DIOMK2 COIN EDGE AA_v_edges)
GATED_SOURCE_SIDE = (OR NTAP PTAP) INTERACT GATE_DIOMK2
AA_and_DIOMK2 = AA AND DIOMK2

GATED_W_1 {
@ Width of ((SN AND GATE) AND DIOMK2) (Except GATE abut AA vertical edge) = 0.076um
 chk_GATE = NGATE_DIOMK2_real INSIDE EDGE AA
 err1 = INT (chk_GATE) == 0.076 ABUT<90 OPPOSITE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

GATED_W_2 {
@ Width of ((SP AND GATE) AND DIOMK2) (Except GATE abut AA vertical edge) = 0.076um
 chk_GATE = PGATE_DIOMK2_real INSIDE EDGE AA
 err1 = INT (chk_GATE) == 0.076 ABUT<90 OPPOSITE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

GATED_W_3 {
@ Channle width INSIDE DIOMK2 region = 0.384~0.96um
 chk_GATE = (NGATE_DIOMK2 OR PGATE_DIOMK2) INSIDE EDGE AA
 err1 = LENGTH chk_GATE < 0.384
 err2 = LENGTH chk_GATE > 0.960
 err1 NOT INSIDE EDGE SealR_NOT_BULK
 err2 NOT INSIDE EDGE SealR_NOT_BULK
}

GATED_W_4 {
@ Width of (GATE AND DIOMK2) = 0.152um
 GATE_chk = GT INTERACT GATE_DIOMK2
 GATE_chk_side = GATE_chk INSIDE EDGE AA
 GATE_chk_fail = INT (GATE_chk) == 0.152 ABUT<90 OPPOSITE EXCLUDE SHIELDED
 err1 = GATE_chk_fail TOUCH EDGE GATE_chk_side
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

GATED_S_1 {
@ Space between DIOMK2 and AA >= 0.048um
 err1 = EXT DIOMK2 AA < 0.048 ABUT<90 SINGULAR REGION MEASURE ALL
 err1 NOT INSIDE SealR_NOT_BULK
}

GATED_S_2 {
@ Space between DIOMK2 and AA (AA vertical edge expanding 1/2 GT width) in S/D direction >= 0.065um
 err1 = EXT DIOMK2 edge_gate_AA_all_v_edges < 0.065 ABUT<90 REGION MEASURE ALL
 err1 NOT INSIDE SealR_NOT_BULK
}

GATED_S_3 {
@ GATE space on the same AA INSIDE DIOMK2 region = 0.118um
 chk_GATE = GATE_DIOMK2 INSIDE EDGE AA
 err1 = EXT (chk_GATE) == 0.118 ABUT<90 OPPOSITE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

GATED_S_4 {
@ Space between DIOMK2 and (ALL_GT NOT P2) >= 0.059um
 err1 = EXT ALL_GT_NOT_P2 DIOMK2 < 0.059 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

GATED_EN_1 {
@ DIOMK2 enclosure of AA >= 0.048um
 err1 = ENC AA_and_DIOMK2 DIOMK2 < 0.048 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

GATED_EN_1a {
@ DIOMK2 enclosure of AA (AA vertical edge extend 1/2 GT width) in S/D direction >= 0.065um
 err1 = ENC edge_gate_AA_all_v_edges DIOMK2 < 0.065 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

GATED_EN_2 {
@ DIOMK2 enclosure of (ALL_GT NOT P2) (Cut is not allowed) >= 0.059um
 err1 = ENC (ALL_GT_NOT_P2 AND DIOMK2) DIOMK2 < 0.059 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

GATED_R_1 {
@ AA CUT DIOMK2 is not allowed
 err1 = DIOMK2 INSIDE EDGE (AA CUT DIOMK2)
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

GATED_R_2 {
@ (DIOMK2 AND AA) must be fully covered by DG
 err1 = (DIOMK2 AND AA) NOT DG
 err1 NOT INSIDE SealR_NOT_BULK
}

GATED_R_3 {
@ DIOMK2 overlap DUM_GT is not allowed
 err1 = DIOMK2 AND DUM_GT
 err1 NOT INSIDE SealR_NOT_BULK
}

GATED_R_4 {
@ (AA NOT GT) INSIDE DIOMK2 must interact M0
 chk_pre = AA_SD_all AND DIOMK2
 err1 = chk_pre NOT INTERACT M0
 err1 NOT INSIDE SealR_NOT_BULK
}

// ====================
// BJT design rules
// ====================

GROUP GBJT BJT_?

BJT_AA = AA AND DMPNP
BJT_HOLES_NW = HOLES (NW AND DMPNP)

//;derivations of the opening AA BJT
//;pnp BJT
Collector_SP_PNP_1 = (SP NOT NW) AND DMPNP
Collector_SP_PNP_RING = Collector_SP_PNP_1 TOUCH (HOLES Collector_SP_PNP_1)  //; both PNP collector SP and NPN base SP will be selected
Collector_SP_PNP_CAKE = (Collector_SP_PNP_1 NOT TOUCH (HOLES Collector_SP_PNP_1)) INTERACT AA
Base_SN_PNP_1 = (SN AND NW) AND DMPNP
Base_SN_PNP_RING = Base_SN_PNP_1 TOUCH (HOLES Base_SN_PNP_1)  //; both PNP base SN and NPN collector SN will be selected
Base_SN_PNP_CAKE = (Base_SN_PNP_1 NOT TOUCH (HOLES Base_SN_PNP_1)) INTERACT AA

//;npn BJT
Collector_SN_NPN_1 = (SN AND NW) AND DMPNP
Collector_SN_NPN_RING = Collector_SN_NPN_1 TOUCH (HOLES Collector_SN_NPN_1)  //; both NPN collector SN and PNP base SN will be selected
Collector_SN_NPN_CAKE = (Collector_SN_NPN_1 NOT TOUCH (HOLES Collector_SN_NPN_1)) INTERACT AA
Base_SP_NPN_1 = (SP NOT NW) AND DMPNP
Base_SP_NPN_RING = Base_SP_NPN_1 TOUCH (HOLES Base_SP_NPN_1)  //; both NPN base SP and PNP collector SP will be selected
Base_SP_NPN_CAKE = (Base_SP_NPN_1 NOT TOUCH (HOLES Base_SP_NPN_1)) INTERACT AA

//;RING_pnp BJT
RING_Collector_SP_PNP = Collector_SP_PNP_RING TOUCH ((HOLES Collector_SP_PNP_RING) ENCLOSE Base_SN_PNP_RING)
RING_Base_SN_PNP = Base_SN_PNP_RING TOUCH ((HOLES Base_SN_PNP_RING) NOT ENCLOSE Base_SP_NPN_RING)

RING_Collector_AA_PNP = RING_Collector_SP_PNP AND BJT_AA
RING_Base_AA_PNP = RING_Base_SN_PNP AND BJT_AA

//;RING_npn BJT
RING_Collector_SN_NPN = Collector_SN_NPN_RING TOUCH ((HOLES Collector_SN_NPN_RING) ENCLOSE Base_SP_NPN_RING)
RING_Base_SP_NPN = Base_SP_NPN_RING TOUCH ((HOLES Base_SP_NPN_RING) NOT ENCLOSE Base_SN_PNP_RING)

RING_Collector_AA_NPN = RING_Collector_SN_NPN AND BJT_AA
RING_Base_AA_NPN = RING_Base_SP_NPN AND BJT_AA

//;CAKE_pnp BJT
CAKE_Collector_SP_PNP = Collector_SP_PNP_CAKE NOT BJT_HOLES_NW
CAKE_Base_SN_PNP = Base_SN_PNP_CAKE NOT ((NW AND DMPNP) TOUCH BJT_HOLES_NW)

CAKE_Collector_AA_PNP = CAKE_Collector_SP_PNP AND BJT_AA
CAKE_Base_AA_PNP = CAKE_Base_SN_PNP AND BJT_AA

//;CAKE_npn BJT
CAKE_Collector_SN_NPN = Collector_SN_NPN_CAKE AND ((NW AND DMPNP) TOUCH BJT_HOLES_NW)
CAKE_Base_SP_NPN = Base_SP_NPN_CAKE AND BJT_HOLES_NW

CAKE_Collector_AA_NPN = CAKE_Collector_SN_NPN AND BJT_AA
CAKE_Base_AA_NPN = CAKE_Base_SP_NPN AND BJT_AA

Emitter_AA_PNP = ((SP AND NW) AND BJT_AA) AND BIPOLA
Emitter_AA_NPN = ((SN NOT NW) AND BJT_AA) AND BIPOLA

//;CEB terminals of pnp / npn BJT
RING_Collector_AA = OR RING_Collector_AA_PNP RING_Collector_AA_NPN
RING_Base_AA = OR RING_Base_AA_PNP RING_Base_AA_NPN

CAKE_Collector_AA = (OR CAKE_Collector_AA_PNP CAKE_Collector_AA_NPN) NOT BIPOLA
CAKE_Base_AA = OR CAKE_Base_AA_PNP CAKE_Base_AA_NPN

Collector_AA = OR RING_Collector_AA CAKE_Collector_AA
Base_AA = OR RING_Base_AA CAKE_Base_AA
Emitter_AA = OR Emitter_AA_PNP Emitter_AA_NPN

//;CORE/IO BJT
BJT_AA_CORE = BJT_AA NOT DG
Collector_AA_CORE = Collector_AA NOT DG
Base_AA_CORE = Base_AA NOT DG
Emitter_AA_CORE = Emitter_AA NOT DG

BJT_AA_IO = BJT_AA AND DG
Collector_AA_IO = Collector_AA AND DG
Base_AA_IO = Base_AA AND DG
Base_AA_IO_IN_Emitter = Base_AA_IO AND BIPOLA
Base_AA_IO_OU_Emitter = Base_AA_IO NOT BIPOLA
Emitter_AA_IO = Emitter_AA AND DG

//;merged AA (RING type)
Base_AA_CORE_merged = SIZE Base_AA_CORE BY 0.12 OVERUNDER
Base_AA_merged = SIZE Base_AA BY 0.12 OVERUNDER
Collector_AA_CORE_merged = SIZE Collector_AA_CORE BY 0.12 OVERUNDER
Collector_AA_merged = SIZE Collector_AA BY 0.12 OVERUNDER

//;H/V edges
Base_AA_h_edges = ANGLE Base_AA == 0
Base_AA_v_edges = ANGLE Base_AA == 90
Emitter_AA_h_edges = ANGLE Emitter_AA == 0
Emitter_AA_v_edges = ANGLE Emitter_AA == 90
Collector_AA_h_edges = ANGLE Collector_AA == 0
Collector_AA_v_edges = ANGLE Collector_AA == 90

RING_Base_AA_h_edges = ANGLE RING_Base_AA == 0
RING_Base_AA_v_edges = ANGLE RING_Base_AA == 90
RING_Collector_AA_h_edges = ANGLE RING_Collector_AA == 0
RING_Collector_AA_v_edges = ANGLE RING_Collector_AA == 90

CAKE_Base_AA_h_edges = ANGLE CAKE_Base_AA == 0
CAKE_Base_AA_v_edges = ANGLE CAKE_Base_AA == 90
CAKE_Collector_AA_h_edges = ANGLE CAKE_Collector_AA == 0
CAKE_Collector_AA_v_edges = ANGLE CAKE_Collector_AA == 90

//;Collector AA & Base AA in vertical/S/D direction of the opening AA BJT only can be recognised based on the fixed distance between collector and base injector
Emitter_AA_PNP_GT = GT INTERACT Emitter_AA_PNP
Emitter_AA_NPN_GT = GT INTERACT Emitter_AA_NPN
Emitter_AA_PNP_GT_dorian = GT_0 AND Emitter_AA_PNP_GT
Emitter_AA_NPN_GT_dorian = GT_0 AND Emitter_AA_NPN_GT

Base_AA_in_VH_1 = Base_AA AND (NET AREA RATIO NTAP Emitter_AA_PNP_GT_dorian [!!AREA(NTAP)*!!AREA(Emitter_AA_PNP_GT_dorian)] > 0)  //; Based on BJT.R.4
Base_AA_in_VH_2 = Base_AA AND (NET AREA RATIO PTAP Emitter_AA_NPN_GT_dorian [!!AREA(PTAP)*!!AREA(Emitter_AA_NPN_GT_dorian)] > 0)
Base_AA_in_VH = Base_AA_in_VH_1 OR Base_AA_in_VH_2
Base_AA_in_V_1 = Base_AA_in_VH WITH EDGE (EXT [Base_AA_CORE] Collector_AA_h_edges == 0.240 ABUT<90 OPPOSITE)  //; Based on BJT.S.1
Base_AA_in_V_2 = Base_AA_in_VH WITH EDGE (EXT [Base_AA_IO] Emitter_AA_h_edges == 0.192 ABUT<90 OPPOSITE) //; Based on BJT.S.2b
Base_AA_in_V = OR Base_AA_in_V_1 Base_AA_in_V_2
Base_AA_in_H = Base_AA NOT Base_AA_in_V

Collector_AA_in_V = Collector_AA WITH EDGE (EXT [Collector_AA] Base_AA_h_edges == 0.240 ABUT<90 OPPOSITE)  //; Based on BJT.S.1
Collector_AA_in_H = Collector_AA WITH EDGE (EXT [Collector_AA] Base_AA_v_edges == 0.408 ABUT<90 OPPOSITE)  //; Based on BJT.S.3

Base_AA_CORE_in_V = Base_AA_in_V NOT DG
Base_AA_CORE_in_H = Base_AA_in_H NOT DG
Collector_AA_CORE_in_V = Collector_AA_in_V NOT DG
Collector_AA_CORE_in_H = Collector_AA_in_H NOT DG
//;end of the derivations of the opening AA BJT

//;Below rule checks will therefore influence each other

BJT_W_1a {
@ Base AA width in ENDCAP direction for (DMPNP NOT DG) >= 0.144um
 err1 = INT (Base_AA_h_edges TOUCH EDGE Base_AA_CORE_merged) < 0.144 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

BJT_W_1b {
@ Base AA width in ENDCAP direction for (DMPNP INSIDE DG) = 0.144um
 err1 = INT (CAKE_Base_AA_h_edges) == 0.144 ABUT<90 OPPOSITE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

BJT_W_2a {
@ Collector AA width in ENDCAP direction for (DMPNP NOT DG) >= 0.288um
 chk_collector = Collector_AA_h_edges COIN EDGE Collector_AA_CORE_in_V
 err1 = INT chk_collector < 0.288 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

real_Collector_AA_h_edges = EXT Base_AA_merged [Collector_AA_h_edges] == 0.24 ABUT<90 OPPOSITE EXCLUDE SHIELDED
real_Collector_AA_H = Collector_AA WITH EDGE real_Collector_AA_h_edges // BJT_S_1
real_Collector_AA = Collector_AA_merged INTERACT real_Collector_AA_H

real_Base_AA_h_edges = EXT [Base_AA_merged] Collector_AA_h_edges == 0.24 ABUT<90 OPPOSITE EXCLUDE SHIELDED
real_Base_AA_H = Base_AA WITH EDGE real_Base_AA_h_edges // BJT_S_1

BJT_W_2b {
@ Collector AA width in ENDCAP direction for (DMPNP INSIDE DG) = 0.144um
 chk_collector = CAKE_Collector_AA_h_edges COIN EDGE real_Collector_AA_h_edges  //;remove false when pick-up was drawn in DMPNP
 err1 = INT (chk_collector) CAKE_Collector_AA_h_edges == 0.144 ABUT<90 OPPOSITE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

BJT_W_3 {
@ Base AA and Collector AA width in S/D direction >= 0.204um
 BAA_v_edges = Base_AA_v_edges COIN EDGE Base_AA_CORE_in_H
 CAA_v_edges = Collector_AA_v_edges COIN EDGE Collector_AA_CORE_in_H
 err1 = INT BAA_v_edges < 0.204 ABUT<90 OPPOSITE REGION
 err2 = INT CAA_v_edges < 0.204 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

BJT_W_4 {
@ AOP_GT width in DMPNP region = 0.086um
 err1 = (AOP_GT AND DMPNP) NOT WITH WIDTH == 0.086
 err1 NOT INSIDE SealR_NOT_BULK
}

BJT_S_1 {
@ Space between Collector AA and Base AA in ENDCAP direction = 0.24um
@ //;DRC will also flag AA without M0G
 CAA_h_edges = Collector_AA_h_edges COIN EDGE Collector_AA
 BAA_h_edges_good = EXT [Base_AA_merged] CAA_h_edges == 0.24 ABUT<90 OPPOSITE EXCLUDE SHIELDED
 CAA_h_edges_good = EXT Base_AA_merged [CAA_h_edges] == 0.24 ABUT<90 OPPOSITE EXCLUDE SHIELDED
 err1 = ((Base_AA NOT BIPOLA) INTERACT M0G) NOT WITH EDGE BAA_h_edges_good  //;M0G only used in Base AA, exclude BASE AA in emitter
 err2 = (Base_AA WITH EDGE BAA_h_edges_good) NOT INTERACT M0G   //; base AA without M0G
 err3 = (Collector_AA WITH EDGE CAA_h_edges_good) NOT INTERACT M0G   //; base AA without M0G
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
}

BJT_S_2a {
@ Space between Emitter AA and Base AA in ENDCAP direction for (DMPNP NOT DG) = 0.48um
@ //;DRC will also flag AA without M0G
 EAA_CORE_check = Emitter_AA_h_edges COIN EDGE Emitter_AA_CORE
 BAA_CORE_block = Base_AA_CORE_merged INSIDE (HOLES Collector_AA_CORE_merged)
 BAA_CORE_check = Base_AA_CORE INTERACT (NOT RECTANGLE BAA_CORE_block)
 BAA_CORE_good = EXT EAA_CORE_check [Base_AA_CORE_merged] == 0.48 ABUT<90 OPPOSITE EXCLUDE SHIELDED
 err1 = (BAA_CORE_check INTERACT M0G) NOT WITH EDGE BAA_CORE_good
 err2 = (Base_AA_CORE WITH EDGE BAA_CORE_good) NOT INTERACT M0G
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

BJT_S_2b {
@ Space between Emitter AA and Base AA in ENDCAP direction for (DMPNP INSIDE DG) = 0.192um
@ //;DRC will also flag AA without M0G
 BAA_IO_h_edges = Emitter_AA_h_edges COIN EDGE Emitter_AA_IO
 BAA_IO_OU_h_edges_good = EXT BAA_IO_h_edges [Base_AA_IO_OU_Emitter] == 0.192 ABUT<90 OPPOSITE EXCLUDE SHIELDED
 BAA_IO_IN_h_edges_good = EXT BAA_IO_h_edges [Base_AA_IO_IN_Emitter] == 0.192 ABUT<90 OPPOSITE EXCLUDE SHIELDED
 BAA_IO_OU_Emitter_err1 = Base_AA_IO_OU_Emitter NOT WITH EDGE BAA_IO_OU_h_edges_good
 BAA_IO_IN_Emitter_err2 = Base_AA_IO_IN_Emitter NOT WITH EDGE BAA_IO_IN_h_edges_good == 2
 err1 = BAA_IO_OU_Emitter_err1 NOT INTERACT (HOLES Collector_AA_merged)
 err2 = BAA_IO_IN_Emitter_err2 NOT INTERACT (HOLES Collector_AA_merged)
 err3 = (Base_AA_IO_OU_Emitter WITH EDGE BAA_IO_OU_h_edges_good) NOT INTERACT M0G  //; base AA without M0G
 err4 = (Base_AA_IO_IN_Emitter WITH EDGE BAA_IO_IN_h_edges_good) NOT INTERACT M0G  //; base AA without M0G
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
 err4 NOT INSIDE SealR_NOT_BULK
}

BJT_S_3 {
@ Space between Collector AA and Base AA in S/D direction = 0.408um
 BAA_CORE_loop = Base_AA_CORE_merged INSIDE (HOLES Collector_AA_CORE_merged)
 BAA_CORE_good = EXT [Base_AA_CORE_merged] Collector_AA_v_edges == 0.408 ABUT<90 OPPOSITE EXTENDED 0.12 EXCLUDE SHIELDED
 BAA_CORE_check = Base_AA_CORE INTERACT BAA_CORE_loop
 err1 = (BAA_CORE_check NOT INTERACT M0G) NOT WITH EDGE BAA_CORE_good
 err1 NOT INSIDE SealR_NOT_BULK
}

discrete_base_AA_merged = Base_AA_CORE_merged INSIDE (HOLES Collector_AA_CORE_merged)  //; merge the discrete base AA (redue false)
discrete_base_AA_merged_v_edges = ANGLE discrete_base_AA_merged == 90
discrete_base_AA_merged_v_edges_good = EXT Emitter_AA [discrete_base_AA_merged_v_edges] == 0.612 ABUT<90 OPPOSITE EXCLUDE SHIELDED

BJT_S_4 {
@ Space between Emitter AA and Base AA in S/D direction = 0.612um
 err1 = (discrete_base_AA_merged_v_edges COIN EDGE (HOLES Base_AA_CORE_merged)) NOT TOUCH EDGE discrete_base_AA_merged_v_edges_good
 err2 = CONVEX EDGE Collector_AA_CORE_merged == 1  //;non-Rectangle collector AA
 err3 = CONVEX EDGE Base_AA_CORE_merged == 1  //;non-Rectangle base AA
 err1 NOT INSIDE EDGE SealR_NOT_BULK
 err2 NOT INSIDE EDGE SealR_NOT_BULK
 err3 NOT INSIDE EDGE SealR_NOT_BULK
}

Collector_AA_h_edges_IO = Collector_AA_h_edges COIN EDGE Collector_AA_IO
Collector_AA_h_edges_IO_good = EXT Base_AA_merged [Collector_AA_h_edges_IO] == 0.24 ABUT<90 OPPOSITE EXCLUDE SHIELDED
Collector_AA_outermost_TMP = CAKE_Collector_AA_h_edges COIN EDGE real_Collector_AA_h_edges
Collector_AA_outermost = Collector_AA_IO WITH EDGE (ENC [Collector_AA_outermost_TMP] DMPNP <= 1.0 ABUT<90 OPPOSITE EXCLUDE SHIELDED)  //;based on BJT_EN_1

BJT_S_5 {
@ Space between two Collector AA (PRL > 0um) between different units in same DMPNP (different units can not share same Collector AA) = 0.768~0.96um
// CAA_joint_all = SIZE (Collector_AA NOT Collector_AA_outermost) BY 0.96/2 INSIDE OF DMPNP STEP 0.25
// CAA_diffC_IO = (DMPNP NOT INTERACT DG) INTERACT CAA_joint_all >= 2
// CAA_sameC_CR = (DMPNP INTERACT DG) INTERACT (CAA_joint_all INTERACT Collector_AA == 1)
// err1 = OR (CAA_joint_all INTERACT CAA_diffC_IO) ((CAA_joint_all INTERACT Collector_AA == 1) INTERACT CAA_sameC_CR)

 CAA_space_err = EXT real_Collector_AA < 0.768 ABUT<90 OPPOSITE REGION EXCLUDE SHIELDED
 err1_TMP = WITH WIDTH ((SIZE DMPNP BY -0.768) NOT (SIZE BJT_AA BY 0.35 OVERUNDER)) > 0.96  //;based on BJT.EN.1 BJT.S.**
 err1 = err1_TMP INTERACT real_Collector_AA > 1  //; remove fasle cased by pick-up in DMPNP
 err2 = (CAA_space_err NOT INSIDE SN) NOT INSIDE SP  //;exclude core BJT ring inner space
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK

 err3 = INT Collector_AA_h_edges_IO_good == 0.144 ABUT<90 OPPOSITE REGION  //;share same io Collector AA
 err4 = OR ((HOLES Collector_AA_merged) INTERACT (HOLES Base_AA_merged) > 1) (Collector_AA_merged INTERACT (HOLES Collector_AA_merged) > 1)  //;share same core Collector AA
 err3 NOT INSIDE SealR_NOT_BULK
 err4 NOT INSIDE SealR_NOT_BULK
}

BJT_S_6 {
@ Space between DMPNP and ALL_GT >= 0.035um
 err1 = EXT DMPNP ALL_GT < 0.035 ABUT<90 SINGULAR REGION
 err2 = EXT DMPNP ALL_GT < 0.035 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

BJT_EN_1 {
@ DMPNP enclosure of Collector AA = 0.768-1.008um
 CHK_BJT_AA = BJT_AA NOT (Collector_AA_merged NOT real_Collector_AA)
 err1_TMP = (EXTENTS CHK_BJT_AA INSIDE OF LAYER DMPNP) NOT OUTSIDE EDGE DMPNP
 err1 = ENC (err1_TMP) DMPNP >= 0.768 <= 1.008 ABUT<90 OPPOSITE EXCLUDE SHIELDED
 err1 NOT INSIDE EDGE SealR_NOT_BULK

 err2 = ENC CHK_BJT_AA DMPNP < 0.768 ABUT<90 SINGULAR REGION
 err2 NOT INSIDE SealR_NOT_BULK

 err3 = DMPNP INSIDE EDGE AA
 err4 = DMPNP NOT TOUCH EDGE (DMPNP INSIDE EDGE (SIZE CHK_BJT_AA BY 1.008+GLOBAL_TOLERANCE))
 err3 NOT INSIDE EDGE SealR_NOT_BULK
 err4 NOT INSIDE EDGE SealR_NOT_BULK
}

BJT_EN_2 {
@ DMPNP enclosure of ALL_GT >= 0.035um
 err1 = ENC (ALL_GT AND DMPNP) DMPNP < 0.035 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

emitter_AA_size_ud_048 = SIZE Emitter_AA BY 0.048 OVERUNDER

BJT_R_1 {
@ ((Emitter AA SIZING 0.048um) SIZING -0.048um) must be one 1.632*1.728um or 2.04um*2.352um rectangle outside DG
 good_emitter_1 = RECTANGLE emitter_AA_size_ud_048 == 1.632 BY == 1.728
 good_emitter_2 = RECTANGLE emitter_AA_size_ud_048 == 2.040 BY == 2.352
 err1 = ((emitter_AA_size_ud_048 NOT good_emitter_1) NOT good_emitter_2) NOT DG
 err1 NOT INSIDE SealR_NOT_BULK
}

BJT_R_2 {
@ Overlap SVT_N, SVT_P, LVT_N, LVT_P, HVT_N, HVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, VARMOS, or INST is not allowed
 err1 = DMPNP AND (OR ALL_VT_IMP VARMOS INST)
 err1 NOT INSIDE SealR_NOT_BULK
}

BJT_R_3_1 {
@ BIPOLA must be inside DMPNP
@ DRC flags BIPOLA NOT totally INSIDE DMPNP
 err1 = (BIPOLA NOT INSIDE DMPNP) OR (DMPNP NOT ENCLOSE BIPOLA)
 err1 NOT INSIDE SealR_NOT_BULK
}

BJT_R_3_2 {
@ BIPOLA must be inside DMPNP
@ DRC flags BIPOLA CUT emitter/collector/base AA
//; abnormal BJT
 err1 = EXPAND EDGE (BIPOLA INSIDE EDGE AA) INSIDE BY 0.001 OUTSIDE BY 0.001
 err1 NOT INSIDE SealR_NOT_BULK
}

BJT_R_3_3 {
@ BIPOLA must be inside DMPNP
@ DRC flags BIPOLA overlap with RING collector/base AA
 err1 = BIPOLA AND (OR CAKE_Collector_AA RING_Collector_AA RING_Base_AA)
 err1 NOT INSIDE SealR_NOT_BULK
}

BJT_R_3_4 {
@ BIPOLA must be inside DMPNP
@ DRC flags DMPNP without any AA
 err1 = DMPNP NOT ENCLOSE BJT_AA
 err1 NOT INSIDE SealR_NOT_BULK
}

BJT_R_3_5 {
@ BIPOLA must be inside DMPNP
@ DRC flags DMPNP without B/C/E AA
@ DRC flags core BJT covered by DG and IO BJT not covered by DG
 err1 = DMPNP NOT ENCLOSE real_Collector_AA
 err2 = DMPNP NOT ENCLOSE Base_AA
 err3 = DMPNP NOT ENCLOSE Emitter_AA
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK

 err4 = OR (RING_Collector_AA AND DG) (RING_Base_AA AND DG) ((CAKE_Collector_AA INTERACT real_Collector_AA_H) NOT DG) ((CAKE_Base_AA INTERACT real_Base_AA_H) NOT DG)
 err4 NOT INSIDE SealR_NOT_BULK
}

BJT_R_3_6 {
@ BIPOLA must be inside DMPNP
@ DRC flags non-orthogonal B/C/E AA
 err1 = NOT RECTANGLE (OR (Collector_AA INTERACT real_Collector_AA) Base_AA Emitter_AA) ORTHOGONAL ONLY
 err1 NOT INSIDE SealR_NOT_BULK
}

BJT_R_4 {
@ GT on Emitter AA must connect to Base AA
 PNP_emitter_GT = GT_0 AND (GT INTERACT (Emitter_AA AND SP))
 NPN_emitter_GT = GT_0 AND (GT INTERACT (Emitter_AA AND SN))
 BJT_aa_connect = Base_AA AND M0_0

 err1 = PNP_emitter_GT NOT INTERACT (PNP_emitter_GT AND BJT_aa_connect)
 err2 = NPN_emitter_GT NOT INTERACT (NPN_emitter_GT AND BJT_aa_connect)
 err3 = PNP_emitter_GT INTERACT (PNP_emitter_GT AND BJT_aa_connect) < 2
 err4 = NPN_emitter_GT INTERACT (NPN_emitter_GT AND BJT_aa_connect) < 2
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
 err4 NOT INSIDE SealR_NOT_BULK
}

// =======================
// Varactor design rules
// =======================

GROUP GVAR VAR_?

VAR_W_1 {
@ Channel length of (GATE AND VARMOS) = 0.18~0.242um
 chk_GATE = (GATE AND VARMOS) COIN EDGE GT
 err1 = INT (chk_GATE) >= 0.180 <= 0.242 ABUT<90 OPPOSITE EXCLUDE SHIELDED
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

VAR_W_2 {
@ Channel width of (GATE AND VARMOS) >= 0.384um
 chk_GATE = (GATE AND VARMOS) COIN EDGE AA
 err1 = INT chk_GATE < 0.384 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

VAR_S_1 {
@ Space between VARMOS and ACTIVE >= 0.125um
 err1 = EXT ACT VARMOS < 0.125 ABUT<90 SINGULAR REGION //MEASURE ALL based on VAR_EN_1
 err1 NOT INSIDE SealR_NOT_BULK
}

VAR_S_1a {
@ Space between VARMOS and ACTIVE (ACTIVE vertical edge extend 1/2 GT width) in S/D direction >= 0.144um
 err1 = EXT edge_gate_AA_act VARMOS < 0.144 ABUT<90 SINGULAR REGION //MEASURE ALL based on VAR_EN_1
 err1 NOT INSIDE SealR_NOT_BULK
}

VAR_EN_1 {
@ VARMOS enclosure of AA >= 0.125um
 err1 = ENC (AA AND VARMOS) VARMOS < 0.125 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

VAR_EN_1a {
@ VARMOS enclosure of AA (AA vertical edge extend 1/2 GT width) in S/D direction >= 0.144um
 err1 = ENC edge_gate_AA_all_v_edges VARMOS < 0.144 ABUT<90 EXCLUDE SHIELDED OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

VAR_EN_2 {
@ VARMOS enclosure of ALL_GT >= 0.035um
 err1 = ENC ALL_GT VARMOS < 0.035 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

VAR_EN_3a {
@ SN fully enclosure (GATE AND VARMOS) AND NW) along the S/D direction >= 0.32um
 err1 = ENC ((GATE AND VARMOS) AND NW) SN_v_edges < 0.32 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

VAR_EN_3b {
@ SN fully enclosure (GATE AND VARMOS) AND NW) along GATE poly direction >= 0.125um
 err1 = ENC (((GATE AND VARMOS) AND NW) AND SN) SN < 0.125 ABUT<90 SINGULAR REGION //;minimum requirement
 err1 NOT INSIDE SealR_NOT_BULK
}

//;VAR.R.1[NC] VARMOS layer must be drawn to fully cover the varactor devices

VAR_R_2_PGATE {
@ VARMOS overlap (GATE AND SP), SVT_N, SVT_P, LVT_N, LVT_P, HVT_N, HVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, or PSUB is not allowed
 err1 = AND VARMOS (GATE AND SP)
 err1 NOT INSIDE SealR_NOT_BULK
}

VAR_R_2_VT_Layer {
@ VARMOS overlap (GATE AND SP), SVT_N, SVT_P, LVT_N, LVT_P, HVT_N, HVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, or PSUB is not allowed
 err1 = AND VARMOS ALL_VT_IMP
 err1 NOT INSIDE SealR_NOT_BULK
}

VAR_R_2_PSUB {
@ VARMOS overlap (GATE AND SP), SVT_N, SVT_P, LVT_N, LVT_P, HVT_N, HVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, or PSUB is not allowed
 err1 = AND VARMOS PSUB
 err1 NOT INSIDE SealR_NOT_BULK
}

VAR_R_3 {
@ SP overlap ((GATE AND NW) AND VARMOS) is not allowed
 err1 = SP AND ((GATE AND NW) AND VARMOS)
 err1 NOT INSIDE SealR_NOT_BULK
}

// =======================================================
// DRC methodology for net voltage design rules
// =======================================================


//; This operation creates a special unmerged polygon layer (since there are no limitations on how close two text objects can be together in the layout,the resulting marker polygons can overlap)
//; property for top HV TEXT layer. Find the max label in the same coordinate 
M1_HV_TOP_text = DFM TEXT M1_V_Hi_TOP PROPERTY NUMBER M1_H_vol_TOP_text
M1_HV_TOP_prop = DFM PROPERTY MERGE M1_HV_TOP_text [M1_HV_TOP = max(property(M1_HV_TOP_text, M1_H_vol_TOP_text))]
M2_HV_TOP_text = DFM TEXT M2_V_Hi_TOP PROPERTY NUMBER M2_H_vol_TOP_text
M2_HV_TOP_prop = DFM PROPERTY MERGE M2_HV_TOP_text [M2_HV_TOP = max(property(M2_HV_TOP_text, M2_H_vol_TOP_text))]
M3_HV_TOP_text = DFM TEXT M3_V_Hi_TOP PROPERTY NUMBER M3_H_vol_TOP_text
M3_HV_TOP_prop = DFM PROPERTY MERGE M3_HV_TOP_text [M3_HV_TOP = max(property(M3_HV_TOP_text, M3_H_vol_TOP_text))]
M4_HV_TOP_text = DFM TEXT M4_V_Hi_TOP PROPERTY NUMBER M4_H_vol_TOP_text
M4_HV_TOP_prop = DFM PROPERTY MERGE M4_HV_TOP_text [M4_HV_TOP = max(property(M4_HV_TOP_text, M4_H_vol_TOP_text))]
M5_HV_TOP_text = DFM TEXT M5_V_Hi_TOP PROPERTY NUMBER M5_H_vol_TOP_text
M5_HV_TOP_prop = DFM PROPERTY MERGE M5_HV_TOP_text [M5_HV_TOP = max(property(M5_HV_TOP_text, M5_H_vol_TOP_text))]
M6_HV_TOP_text = DFM TEXT M6_V_Hi_TOP PROPERTY NUMBER M6_H_vol_TOP_text
M6_HV_TOP_prop = DFM PROPERTY MERGE M6_HV_TOP_text [M6_HV_TOP = max(property(M6_HV_TOP_text, M6_H_vol_TOP_text))]
M7_HV_TOP_text = DFM TEXT M7_V_Hi_TOP PROPERTY NUMBER M7_H_vol_TOP_text
M7_HV_TOP_prop = DFM PROPERTY MERGE M7_HV_TOP_text [M7_HV_TOP = max(property(M7_HV_TOP_text, M7_H_vol_TOP_text))]
M8_HV_TOP_text = DFM TEXT TM2_V_Hi_TOP PROPERTY NUMBER M8_H_vol_TOP_text
M8_HV_TOP_prop = DFM PROPERTY MERGE M8_HV_TOP_text [M8_HV_TOP = max(property(M8_HV_TOP_text, M8_H_vol_TOP_text))]
ALPA_HV_TOP_text = DFM TEXT ALPA_V_Hi_TOP PROPERTY NUMBER ALPA_H_vol_TOP_text
ALPA_HV_TOP_prop = DFM PROPERTY MERGE ALPA_HV_TOP_text [ALPA_HV_TOP = max(property(ALPA_HV_TOP_text, ALPA_H_vol_TOP_text))]

//; property for top LV TEXT layer. Find the min label in the same coordinate 
M1_LV_TOP_text = DFM TEXT M1_V_Lo_TOP PROPERTY NUMBER M1_L_vol_TOP_text
M1_LV_TOP_prop = DFM PROPERTY MERGE M1_LV_TOP_text [M1_LV_TOP = min(property(M1_LV_TOP_text, M1_L_vol_TOP_text))]
M2_LV_TOP_text = DFM TEXT M2_V_Lo_TOP PROPERTY NUMBER M2_L_vol_TOP_text
M2_LV_TOP_prop = DFM PROPERTY MERGE M2_LV_TOP_text [M2_LV_TOP = min(property(M2_LV_TOP_text, M2_L_vol_TOP_text))]
M3_LV_TOP_text = DFM TEXT M3_V_Lo_TOP PROPERTY NUMBER M3_L_vol_TOP_text
M3_LV_TOP_prop = DFM PROPERTY MERGE M3_LV_TOP_text [M3_LV_TOP = min(property(M3_LV_TOP_text, M3_L_vol_TOP_text))]
M4_LV_TOP_text = DFM TEXT M4_V_Lo_TOP PROPERTY NUMBER M4_L_vol_TOP_text
M4_LV_TOP_prop = DFM PROPERTY MERGE M4_LV_TOP_text [M4_LV_TOP = min(property(M4_LV_TOP_text, M4_L_vol_TOP_text))]
M5_LV_TOP_text = DFM TEXT M5_V_Lo_TOP PROPERTY NUMBER M5_L_vol_TOP_text
M5_LV_TOP_prop = DFM PROPERTY MERGE M5_LV_TOP_text [M5_LV_TOP = min(property(M5_LV_TOP_text, M5_L_vol_TOP_text))]
M6_LV_TOP_text = DFM TEXT M6_V_Lo_TOP PROPERTY NUMBER M6_L_vol_TOP_text
M6_LV_TOP_prop = DFM PROPERTY MERGE M6_LV_TOP_text [M6_LV_TOP = min(property(M6_LV_TOP_text, M6_L_vol_TOP_text))]
M7_LV_TOP_text = DFM TEXT M7_V_Lo_TOP PROPERTY NUMBER M7_L_vol_TOP_text
M7_LV_TOP_prop = DFM PROPERTY MERGE M7_LV_TOP_text [M7_LV_TOP = min(property(M7_LV_TOP_text, M7_L_vol_TOP_text))]
M8_LV_TOP_text = DFM TEXT TM2_V_Lo_TOP PROPERTY NUMBER M8_L_vol_TOP_text
M8_LV_TOP_prop = DFM PROPERTY MERGE M8_LV_TOP_text [M8_LV_TOP = min(property(M8_LV_TOP_text, M8_L_vol_TOP_text))]
ALPA_LV_TOP_text = DFM TEXT ALPA_V_Lo_TOP PROPERTY NUMBER ALPA_L_vol_TOP_text
ALPA_LV_TOP_prop = DFM PROPERTY MERGE ALPA_LV_TOP_text [ALPA_LV_TOP = min(property(ALPA_LV_TOP_text, ALPA_L_vol_TOP_text))]

//; property for HV TEXT layer 
M1_HV_text = DFM TEXT M1_V_Hi PROPERTY NUMBER M1_H_vol_text
M1_HV_prop = DFM PROPERTY MERGE M1_HV_text [M1_HV = max(property(M1_HV_text, M1_H_vol_text))]
M2_HV_text = DFM TEXT M2_V_Hi PROPERTY NUMBER M2_H_vol_text
M2_HV_prop = DFM PROPERTY MERGE M2_HV_text [M2_HV = max(property(M2_HV_text, M2_H_vol_text))]
M3_HV_text = DFM TEXT M3_V_Hi PROPERTY NUMBER M3_H_vol_text
M3_HV_prop = DFM PROPERTY MERGE M3_HV_text [M3_HV = max(property(M3_HV_text, M3_H_vol_text))]
M4_HV_text = DFM TEXT M4_V_Hi PROPERTY NUMBER M4_H_vol_text
M4_HV_prop = DFM PROPERTY MERGE M4_HV_text [M4_HV = max(property(M4_HV_text, M4_H_vol_text))]
M5_HV_text = DFM TEXT M5_V_Hi PROPERTY NUMBER M5_H_vol_text
M5_HV_prop = DFM PROPERTY MERGE M5_HV_text [M5_HV = max(property(M5_HV_text, M5_H_vol_text))]
M6_HV_text = DFM TEXT M6_V_Hi PROPERTY NUMBER M6_H_vol_text
M6_HV_prop = DFM PROPERTY MERGE M6_HV_text [M6_HV = max(property(M6_HV_text, M6_H_vol_text))]
M7_HV_text = DFM TEXT M7_V_Hi PROPERTY NUMBER M7_H_vol_text
M7_HV_prop = DFM PROPERTY MERGE M7_HV_text [M7_HV = max(property(M7_HV_text, M7_H_vol_text))]
M8_HV_text = DFM TEXT TM2_V_Hi PROPERTY NUMBER M8_H_vol_text
M8_HV_prop = DFM PROPERTY MERGE M8_HV_text [M8_HV = max(property(M8_HV_text, M8_H_vol_text))]
ALPA_HV_text = DFM TEXT ALPA_V_Hi PROPERTY NUMBER ALPA_H_vol_text
ALPA_HV_prop = DFM PROPERTY MERGE ALPA_HV_text [ALPA_HV = max(property(ALPA_HV_text, ALPA_H_vol_text))]
MG_HV_text = DFM TEXT M0G_V_Hi PROPERTY NUMBER MG_H_vol_text
MG_HV_prop = DFM PROPERTY MERGE MG_HV_text [MG_HV = max(property(MG_HV_text, MG_H_vol_text))]
M0_HV_text = DFM TEXT M0_V_Hi PROPERTY NUMBER M0_H_vol_text
M0_HV_prop = DFM PROPERTY MERGE M0_HV_text [M0_HV = max(property(M0_HV_text, M0_H_vol_text))]
AA_HV_text = DFM TEXT AA_V_Hi PROPERTY NUMBER AA_H_vol_text
AA_HV_prop = DFM PROPERTY MERGE AA_HV_text [AA_HV = max(property(AA_HV_text, AA_H_vol_text))]
GT_HV_text = DFM TEXT GT_V_Hi PROPERTY NUMBER GT_H_vol_text
GT_HV_prop = DFM PROPERTY MERGE GT_HV_text [GT_HV = max(property(GT_HV_text, GT_H_vol_text))]

//; property for LV TEXT layer 
M1_LV_text = DFM TEXT M1_V_Lo PROPERTY NUMBER M1_L_vol_text
M1_LV_prop = DFM PROPERTY MERGE M1_LV_text [M1_LV = min(property(M1_LV_text, M1_L_vol_text))]
M2_LV_text = DFM TEXT M2_V_Lo PROPERTY NUMBER M2_L_vol_text
M2_LV_prop = DFM PROPERTY MERGE M2_LV_text [M2_LV = min(property(M2_LV_text, M2_L_vol_text))]
M3_LV_text = DFM TEXT M3_V_Lo PROPERTY NUMBER M3_L_vol_text
M3_LV_prop = DFM PROPERTY MERGE M3_LV_text [M3_LV = min(property(M3_LV_text, M3_L_vol_text))]
M4_LV_text = DFM TEXT M4_V_Lo PROPERTY NUMBER M4_L_vol_text
M4_LV_prop = DFM PROPERTY MERGE M4_LV_text [M4_LV = min(property(M4_LV_text, M4_L_vol_text))]
M5_LV_text = DFM TEXT M5_V_Lo PROPERTY NUMBER M5_L_vol_text
M5_LV_prop = DFM PROPERTY MERGE M5_LV_text [M5_LV = min(property(M5_LV_text, M5_L_vol_text))]
M6_LV_text = DFM TEXT M6_V_Lo PROPERTY NUMBER M6_L_vol_text
M6_LV_prop = DFM PROPERTY MERGE M6_LV_text [M6_LV = min(property(M6_LV_text, M6_L_vol_text))]
M7_LV_text = DFM TEXT M7_V_Lo PROPERTY NUMBER M7_L_vol_text
M7_LV_prop = DFM PROPERTY MERGE M7_LV_text [M7_LV = min(property(M7_LV_text, M7_L_vol_text))]
M8_LV_text = DFM TEXT TM2_V_Lo PROPERTY NUMBER M8_L_vol_text
M8_LV_prop = DFM PROPERTY MERGE M8_LV_text [M8_LV = min(property(M8_LV_text, M8_L_vol_text))]
ALPA_LV_text = DFM TEXT ALPA_V_Lo PROPERTY NUMBER ALPA_L_vol_text
ALPA_LV_prop = DFM PROPERTY MERGE ALPA_LV_text [ALPA_LV = min(property(ALPA_LV_text, ALPA_L_vol_text))]
MG_LV_text = DFM TEXT M0G_V_Lo PROPERTY NUMBER MG_L_vol_text
MG_LV_prop = DFM PROPERTY MERGE MG_LV_text [MG_LV = min(property(MG_LV_text, MG_L_vol_text))]
M0_LV_text = DFM TEXT M0_V_Lo PROPERTY NUMBER M0_L_vol_text
M0_LV_prop = DFM PROPERTY MERGE M0_LV_text [M0_LV = min(property(M0_LV_text, M0_L_vol_text))]
AA_LV_text = DFM TEXT AA_V_Lo PROPERTY NUMBER AA_L_vol_text
AA_LV_prop = DFM PROPERTY MERGE AA_LV_text [AA_LV = min(property(AA_LV_text, AA_L_vol_text))]
GT_LV_text = DFM TEXT GT_V_Lo PROPERTY NUMBER GT_L_vol_text
GT_LV_prop = DFM PROPERTY MERGE GT_LV_text [GT_LV = min(property(GT_LV_text, GT_L_vol_text))]

//; connect for HV TEXT layer 
CONNECT M1 M1_HV_TOP_prop
CONNECT M1 M1_HV_prop
CONNECT M2 M2_HV_TOP_prop
CONNECT M2 M2_HV_prop
CONNECT M3 M3_HV_TOP_prop
CONNECT M3 M3_HV_prop
CONNECT M4 M4_HV_TOP_prop
CONNECT M4 M4_HV_prop
CONNECT M5 M5_HV_TOP_prop
CONNECT M5 M5_HV_prop
CONNECT M6 M6_HV_TOP_prop
CONNECT M6 M6_HV_prop
CONNECT M7 M7_HV_TOP_prop
CONNECT M7 M7_HV_prop
CONNECT M8 M8_HV_TOP_prop
CONNECT M8 M8_HV_prop
CONNECT ALPA ALPA_HV_TOP_prop
CONNECT ALPA ALPA_HV_prop
CONNECT AA_c AA_HV_prop
CONNECT GT_0 GT_HV_prop
CONNECT M0G MG_HV_prop
CONNECT M0_NOT_M0C M0_HV_prop

//; connect for LV TEXT layer 
CONNECT M1 M1_LV_TOP_prop
CONNECT M1 M1_LV_prop
CONNECT M2 M2_LV_TOP_prop
CONNECT M2 M2_LV_prop
CONNECT M3 M3_LV_TOP_prop
CONNECT M3 M3_LV_prop
CONNECT M4 M4_LV_TOP_prop
CONNECT M4 M4_LV_prop
CONNECT M5 M5_LV_TOP_prop
CONNECT M5 M5_LV_prop
CONNECT M6 M6_LV_TOP_prop
CONNECT M6 M6_LV_prop
CONNECT M7 M7_LV_TOP_prop
CONNECT M7 M7_LV_prop
CONNECT M8 M8_LV_TOP_prop
CONNECT M8 M8_LV_prop
CONNECT ALPA ALPA_LV_TOP_prop
CONNECT ALPA ALPA_LV_prop
CONNECT AA_c AA_LV_prop
CONNECT GT_0 GT_LV_prop
CONNECT M0G MG_LV_prop
CONNECT M0_NOT_M0C M0_LV_prop

//; NET property for top HV TEXT layer 
M1_HV_TOP_NETID_rdm = COPY M1_HV_TOP_prop
M1_HV_TOP_NETID = DFM PROPERTY M1_HV_TOP_NETID_rdm M1_HV_TOP_prop NODAL [M1_HV_TOP = max(property(M1_HV_TOP_prop, M1_HV_TOP))]
M2_HV_TOP_NETID_rdm = COPY M2_HV_TOP_prop
M2_HV_TOP_NETID = DFM PROPERTY M2_HV_TOP_NETID_rdm M2_HV_TOP_prop NODAL [M2_HV_TOP = max(property(M2_HV_TOP_prop, M2_HV_TOP))]
M3_HV_TOP_NETID_rdm = COPY M3_HV_TOP_prop
M3_HV_TOP_NETID = DFM PROPERTY M3_HV_TOP_NETID_rdm M3_HV_TOP_prop NODAL [M3_HV_TOP = max(property(M3_HV_TOP_prop, M3_HV_TOP))]
M4_HV_TOP_NETID_rdm = COPY M4_HV_TOP_prop
M4_HV_TOP_NETID = DFM PROPERTY M4_HV_TOP_NETID_rdm M4_HV_TOP_prop NODAL [M4_HV_TOP = max(property(M4_HV_TOP_prop, M4_HV_TOP))]
M5_HV_TOP_NETID_rdm = COPY M5_HV_TOP_prop
M5_HV_TOP_NETID = DFM PROPERTY M5_HV_TOP_NETID_rdm M5_HV_TOP_prop NODAL [M5_HV_TOP = max(property(M5_HV_TOP_prop, M5_HV_TOP))]
M6_HV_TOP_NETID_rdm = COPY M6_HV_TOP_prop
M6_HV_TOP_NETID = DFM PROPERTY M6_HV_TOP_NETID_rdm M6_HV_TOP_prop NODAL [M6_HV_TOP = max(property(M6_HV_TOP_prop, M6_HV_TOP))]
M7_HV_TOP_NETID_rdm = COPY M7_HV_TOP_prop
M7_HV_TOP_NETID = DFM PROPERTY M7_HV_TOP_NETID_rdm M7_HV_TOP_prop NODAL [M7_HV_TOP = max(property(M7_HV_TOP_prop, M7_HV_TOP))]
M8_HV_TOP_NETID_rdm = COPY M8_HV_TOP_prop
M8_HV_TOP_NETID = DFM PROPERTY M8_HV_TOP_NETID_rdm M8_HV_TOP_prop NODAL [M8_HV_TOP = max(property(M8_HV_TOP_prop, M8_HV_TOP))]
ALPA_HV_TOP_NETID_rdm = COPY ALPA_HV_TOP_prop
ALPA_HV_TOP_NETID = DFM PROPERTY ALPA_HV_TOP_NETID_rdm ALPA_HV_TOP_prop NODAL [ALPA_HV_TOP = max(property(ALPA_HV_TOP_prop, ALPA_HV_TOP))]

//; NET property for top LV TEXT layer 
M1_LV_TOP_NETID_rdm = COPY M1_LV_TOP_prop
M1_LV_TOP_NETID = DFM PROPERTY M1_LV_TOP_NETID_rdm M1_LV_TOP_prop NODAL [M1_LV_TOP = min(property(M1_LV_TOP_prop, M1_LV_TOP))]
M2_LV_TOP_NETID_rdm = COPY M2_LV_TOP_prop
M2_LV_TOP_NETID = DFM PROPERTY M2_LV_TOP_NETID_rdm M2_LV_TOP_prop NODAL [M2_LV_TOP = min(property(M2_LV_TOP_prop, M2_LV_TOP))]
M3_LV_TOP_NETID_rdm = COPY M3_LV_TOP_prop
M3_LV_TOP_NETID = DFM PROPERTY M3_LV_TOP_NETID_rdm M3_LV_TOP_prop NODAL [M3_LV_TOP = min(property(M3_LV_TOP_prop, M3_LV_TOP))]
M4_LV_TOP_NETID_rdm = COPY M4_LV_TOP_prop
M4_LV_TOP_NETID = DFM PROPERTY M4_LV_TOP_NETID_rdm M4_LV_TOP_prop NODAL [M4_LV_TOP = min(property(M4_LV_TOP_prop, M4_LV_TOP))]
M5_LV_TOP_NETID_rdm = COPY M5_LV_TOP_prop
M5_LV_TOP_NETID = DFM PROPERTY M5_LV_TOP_NETID_rdm M5_LV_TOP_prop NODAL [M5_LV_TOP = min(property(M5_LV_TOP_prop, M5_LV_TOP))]
M6_LV_TOP_NETID_rdm = COPY M6_LV_TOP_prop
M6_LV_TOP_NETID = DFM PROPERTY M6_LV_TOP_NETID_rdm M6_LV_TOP_prop NODAL [M6_LV_TOP = min(property(M6_LV_TOP_prop, M6_LV_TOP))]
M7_LV_TOP_NETID_rdm = COPY M7_LV_TOP_prop
M7_LV_TOP_NETID = DFM PROPERTY M7_LV_TOP_NETID_rdm M7_LV_TOP_prop NODAL [M7_LV_TOP = min(property(M7_LV_TOP_prop, M7_LV_TOP))]
M8_LV_TOP_NETID_rdm = COPY M8_LV_TOP_prop
M8_LV_TOP_NETID = DFM PROPERTY M8_LV_TOP_NETID_rdm M8_LV_TOP_prop NODAL [M8_LV_TOP = min(property(M8_LV_TOP_prop, M8_LV_TOP))]
ALPA_LV_TOP_NETID_rdm = COPY ALPA_LV_TOP_prop
ALPA_LV_TOP_NETID = DFM PROPERTY ALPA_LV_TOP_NETID_rdm ALPA_LV_TOP_prop NODAL [ALPA_LV_TOP = min(property(ALPA_LV_TOP_prop, ALPA_LV_TOP))]

//; NET property for HV TEXT layer 
M1_HV_NETID_rdm = COPY M1_HV_prop
M1_HV_NETID = DFM PROPERTY M1_HV_NETID_rdm M1_HV_prop NODAL [M1_HV = max(property(M1_HV_prop, M1_HV))]
M2_HV_NETID_rdm = COPY M2_HV_prop
M2_HV_NETID = DFM PROPERTY M2_HV_NETID_rdm M2_HV_prop NODAL [M2_HV = max(property(M2_HV_prop, M2_HV))]
M3_HV_NETID_rdm = COPY M3_HV_prop
M3_HV_NETID = DFM PROPERTY M3_HV_NETID_rdm M3_HV_prop NODAL [M3_HV = max(property(M3_HV_prop, M3_HV))]
M4_HV_NETID_rdm = COPY M4_HV_prop
M4_HV_NETID = DFM PROPERTY M4_HV_NETID_rdm M4_HV_prop NODAL [M4_HV = max(property(M4_HV_prop, M4_HV))]
M5_HV_NETID_rdm = COPY M5_HV_prop
M5_HV_NETID = DFM PROPERTY M5_HV_NETID_rdm M5_HV_prop NODAL [M5_HV = max(property(M5_HV_prop, M5_HV))]
M6_HV_NETID_rdm = COPY M6_HV_prop
M6_HV_NETID = DFM PROPERTY M6_HV_NETID_rdm M6_HV_prop NODAL [M6_HV = max(property(M6_HV_prop, M6_HV))]
M7_HV_NETID_rdm = COPY M7_HV_prop
M7_HV_NETID = DFM PROPERTY M7_HV_NETID_rdm M7_HV_prop NODAL [M7_HV = max(property(M7_HV_prop, M7_HV))]
M8_HV_NETID_rdm = COPY M8_HV_prop
M8_HV_NETID = DFM PROPERTY M8_HV_NETID_rdm M8_HV_prop NODAL [M8_HV = max(property(M8_HV_prop, M8_HV))]
ALPA_HV_NETID_rdm = COPY ALPA_HV_prop
ALPA_HV_NETID = DFM PROPERTY ALPA_HV_NETID_rdm ALPA_HV_prop NODAL [ALPA_HV = max(property(ALPA_HV_prop, ALPA_HV))]
MG_HV_NETID_rdm = COPY MG_HV_prop
MG_HV_NETID = DFM PROPERTY MG_HV_NETID_rdm MG_HV_prop NODAL [MG_HV = max(property(MG_HV_prop, MG_HV))]
M0_HV_NETID_rdm = COPY M0_HV_prop
M0_HV_NETID = DFM PROPERTY M0_HV_NETID_rdm M0_HV_prop NODAL [M0_HV = max(property(M0_HV_prop, M0_HV))]
AA_HV_NETID_rdm = COPY AA_HV_prop
AA_HV_NETID = DFM PROPERTY AA_HV_NETID_rdm AA_HV_prop NODAL [AA_HV = max(property(AA_HV_prop, AA_HV))]
GT_HV_NETID_rdm = COPY GT_HV_prop
GT_HV_NETID = DFM PROPERTY GT_HV_NETID_rdm GT_HV_prop NODAL [GT_HV = max(property(GT_HV_prop, GT_HV))]

//; NET property for LV TEXT layer 
M1_LV_NETID_rdm = COPY M1_LV_prop
M1_LV_NETID = DFM PROPERTY M1_LV_NETID_rdm M1_LV_prop NODAL [M1_LV = min(property(M1_LV_prop, M1_LV))]
M2_LV_NETID_rdm = COPY M2_LV_prop
M2_LV_NETID = DFM PROPERTY M2_LV_NETID_rdm M2_LV_prop NODAL [M2_LV = min(property(M2_LV_prop, M2_LV))]
M3_LV_NETID_rdm = COPY M3_LV_prop
M3_LV_NETID = DFM PROPERTY M3_LV_NETID_rdm M3_LV_prop NODAL [M3_LV = min(property(M3_LV_prop, M3_LV))]
M4_LV_NETID_rdm = COPY M4_LV_prop
M4_LV_NETID = DFM PROPERTY M4_LV_NETID_rdm M4_LV_prop NODAL [M4_LV = min(property(M4_LV_prop, M4_LV))]
M5_LV_NETID_rdm = COPY M5_LV_prop
M5_LV_NETID = DFM PROPERTY M5_LV_NETID_rdm M5_LV_prop NODAL [M5_LV = min(property(M5_LV_prop, M5_LV))]
M6_LV_NETID_rdm = COPY M6_LV_prop
M6_LV_NETID = DFM PROPERTY M6_LV_NETID_rdm M6_LV_prop NODAL [M6_LV = min(property(M6_LV_prop, M6_LV))]
M7_LV_NETID_rdm = COPY M7_LV_prop
M7_LV_NETID = DFM PROPERTY M7_LV_NETID_rdm M7_LV_prop NODAL [M7_LV = min(property(M7_LV_prop, M7_LV))]
M8_LV_NETID_rdm = COPY M8_LV_prop
M8_LV_NETID = DFM PROPERTY M8_LV_NETID_rdm M8_LV_prop NODAL [M8_LV = min(property(M8_LV_prop, M8_LV))]
ALPA_LV_NETID_rdm = COPY ALPA_LV_prop
ALPA_LV_NETID = DFM PROPERTY ALPA_LV_NETID_rdm ALPA_LV_prop NODAL [ALPA_LV = min(property(ALPA_LV_prop, ALPA_LV))]
MG_LV_NETID_rdm = COPY MG_LV_prop
MG_LV_NETID = DFM PROPERTY MG_LV_NETID_rdm MG_LV_prop NODAL [MG_LV = min(property(MG_LV_prop, MG_LV))]
M0_LV_NETID_rdm = COPY M0_LV_prop
M0_LV_NETID = DFM PROPERTY M0_LV_NETID_rdm M0_LV_prop NODAL [M0_LV = min(property(M0_LV_prop, M0_LV))]
AA_LV_NETID_rdm = COPY AA_LV_prop
AA_LV_NETID = DFM PROPERTY AA_LV_NETID_rdm AA_LV_prop NODAL [AA_LV = min(property(AA_LV_prop, AA_LV))]
GT_LV_NETID_rdm = COPY GT_LV_prop
GT_LV_NETID = DFM PROPERTY GT_LV_NETID_rdm GT_LV_prop NODAL [GT_LV = min(property(GT_LV_prop, GT_LV))]

//; NET property for SYNC layer 
sync_M1 = DFM PROPERTY M1 M1V_SYNCH OVERLAP MULTI [-= count(M1V_SYNCH)] > 0 [syncID = netid(M1V_SYNCH, 1)]
sync_M2 = DFM PROPERTY M2 M2V_SYNCH OVERLAP MULTI [-= count(M2V_SYNCH)] > 0 [syncID = netid(M2V_SYNCH, 1)]
sync_M3 = DFM PROPERTY M3 M3V_SYNCH OVERLAP MULTI [-= count(M3V_SYNCH)] > 0 [syncID = netid(M3V_SYNCH, 1)]
sync_M4 = DFM PROPERTY M4 M4V_SYNCH OVERLAP MULTI [-= count(M4V_SYNCH)] > 0 [syncID = netid(M4V_SYNCH, 1)]
sync_M5 = DFM PROPERTY M5 M5V_SYNCH OVERLAP MULTI [-= count(M5V_SYNCH)] > 0 [syncID = netid(M5V_SYNCH, 1)]
sync_M6 = DFM PROPERTY M6 M6V_SYNCH OVERLAP MULTI [-= count(M6V_SYNCH)] > 0 [syncID = netid(M6V_SYNCH, 1)]
sync_M7 = DFM PROPERTY M7 M7V_SYNCH OVERLAP MULTI [-= count(M7V_SYNCH)] > 0 [syncID = netid(M7V_SYNCH, 1)]
sync_M8 = DFM PROPERTY M8 M8V_SYNCH OVERLAP MULTI [-= count(M8V_SYNCH)] > 0 [syncID = netid(M8V_SYNCH, 1)]
sync_ALPA = DFM PROPERTY ALPA ALPAV_SYNCH OVERLAP MULTI [-= count(ALPAV_SYNCH)] > 0 [syncID = netid(ALPAV_SYNCH, 1)]

//; connect for metal voltage mark layer 
M1V00_c = M1 AND M1V00
M1V01_c = M1 AND M1V01
M1V02_c = M1 AND M1V02
M1V03_c = M1 AND M1V03
M1V04_c = M1 AND M1V04
M1V05_c = M1 AND M1V05
M1V06_c = M1 AND M1V06
M1V07_c = M1 AND M1V07
M1V08_c = M1 AND M1V08
M1V09_c = M1 AND M1V09
M1V10_c = M1 AND M1V10
M1V11_c = M1 AND M1V11
M1V12_c = M1 AND M1V12
M1V13_c = M1 AND M1V13
M1V14_c = M1 AND M1V14
M1V15_c = M1 AND M1V15
M1V16_c = M1 AND M1V16
M1V17_c = M1 AND M1V17
M1V18_c = M1 AND M1V18
M1V25_c = M1 AND M1V25
M1V33_c = M1 AND M1V33
M1V42_c = M1 AND M1V42
M1V50_c = M1 AND M1V50
M1V70_c = M1 AND M1V70
M2V00_c = M2 AND M2V00
M2V01_c = M2 AND M2V01
M2V02_c = M2 AND M2V02
M2V03_c = M2 AND M2V03
M2V04_c = M2 AND M2V04
M2V05_c = M2 AND M2V05
M2V06_c = M2 AND M2V06
M2V07_c = M2 AND M2V07
M2V08_c = M2 AND M2V08
M2V09_c = M2 AND M2V09
M2V10_c = M2 AND M2V10
M2V11_c = M2 AND M2V11
M2V12_c = M2 AND M2V12
M2V13_c = M2 AND M2V13
M2V14_c = M2 AND M2V14
M2V15_c = M2 AND M2V15
M2V16_c = M2 AND M2V16
M2V17_c = M2 AND M2V17
M2V18_c = M2 AND M2V18
M2V25_c = M2 AND M2V25
M2V33_c = M2 AND M2V33
M2V42_c = M2 AND M2V42
M2V50_c = M2 AND M2V50
M2V70_c = M2 AND M2V70
M3V00_c = M3 AND M3V00
M3V01_c = M3 AND M3V01
M3V02_c = M3 AND M3V02
M3V03_c = M3 AND M3V03
M3V04_c = M3 AND M3V04
M3V05_c = M3 AND M3V05
M3V06_c = M3 AND M3V06
M3V07_c = M3 AND M3V07
M3V08_c = M3 AND M3V08
M3V09_c = M3 AND M3V09
M3V10_c = M3 AND M3V10
M3V11_c = M3 AND M3V11
M3V12_c = M3 AND M3V12
M3V13_c = M3 AND M3V13
M3V14_c = M3 AND M3V14
M3V15_c = M3 AND M3V15
M3V16_c = M3 AND M3V16
M3V17_c = M3 AND M3V17
M3V18_c = M3 AND M3V18
M3V25_c = M3 AND M3V25
M3V33_c = M3 AND M3V33
M3V42_c = M3 AND M3V42
M3V50_c = M3 AND M3V50
M3V70_c = M3 AND M3V70
M4V00_c = M4 AND M4V00
M4V01_c = M4 AND M4V01
M4V02_c = M4 AND M4V02
M4V03_c = M4 AND M4V03
M4V04_c = M4 AND M4V04
M4V05_c = M4 AND M4V05
M4V06_c = M4 AND M4V06
M4V07_c = M4 AND M4V07
M4V08_c = M4 AND M4V08
M4V09_c = M4 AND M4V09
M4V10_c = M4 AND M4V10
M4V11_c = M4 AND M4V11
M4V12_c = M4 AND M4V12
M4V13_c = M4 AND M4V13
M4V14_c = M4 AND M4V14
M4V15_c = M4 AND M4V15
M4V16_c = M4 AND M4V16
M4V17_c = M4 AND M4V17
M4V18_c = M4 AND M4V18
M4V25_c = M4 AND M4V25
M4V33_c = M4 AND M4V33
M4V42_c = M4 AND M4V42
M4V50_c = M4 AND M4V50
M4V70_c = M4 AND M4V70
M5V00_c = M5 AND M5V00
M5V01_c = M5 AND M5V01
M5V02_c = M5 AND M5V02
M5V03_c = M5 AND M5V03
M5V04_c = M5 AND M5V04
M5V05_c = M5 AND M5V05
M5V06_c = M5 AND M5V06
M5V07_c = M5 AND M5V07
M5V08_c = M5 AND M5V08
M5V09_c = M5 AND M5V09
M5V10_c = M5 AND M5V10
M5V11_c = M5 AND M5V11
M5V12_c = M5 AND M5V12
M5V13_c = M5 AND M5V13
M5V14_c = M5 AND M5V14
M5V15_c = M5 AND M5V15
M5V16_c = M5 AND M5V16
M5V17_c = M5 AND M5V17
M5V18_c = M5 AND M5V18
M5V25_c = M5 AND M5V25
M5V33_c = M5 AND M5V33
M5V42_c = M5 AND M5V42
M5V50_c = M5 AND M5V50
M5V70_c = M5 AND M5V70
M6V00_c = M6 AND M6V00
M6V01_c = M6 AND M6V01
M6V02_c = M6 AND M6V02
M6V03_c = M6 AND M6V03
M6V04_c = M6 AND M6V04
M6V05_c = M6 AND M6V05
M6V06_c = M6 AND M6V06
M6V07_c = M6 AND M6V07
M6V08_c = M6 AND M6V08
M6V09_c = M6 AND M6V09
M6V10_c = M6 AND M6V10
M6V11_c = M6 AND M6V11
M6V12_c = M6 AND M6V12
M6V13_c = M6 AND M6V13
M6V14_c = M6 AND M6V14
M6V15_c = M6 AND M6V15
M6V16_c = M6 AND M6V16
M6V17_c = M6 AND M6V17
M6V18_c = M6 AND M6V18
M6V25_c = M6 AND M6V25
M6V33_c = M6 AND M6V33
M6V42_c = M6 AND M6V42
M6V50_c = M6 AND M6V50
M6V70_c = M6 AND M6V70
M7V00_c = M7 AND M7V00
M7V01_c = M7 AND M7V01
M7V02_c = M7 AND M7V02
M7V03_c = M7 AND M7V03
M7V04_c = M7 AND M7V04
M7V05_c = M7 AND M7V05
M7V06_c = M7 AND M7V06
M7V07_c = M7 AND M7V07
M7V08_c = M7 AND M7V08
M7V09_c = M7 AND M7V09
M7V10_c = M7 AND M7V10
M7V11_c = M7 AND M7V11
M7V12_c = M7 AND M7V12
M7V13_c = M7 AND M7V13
M7V14_c = M7 AND M7V14
M7V15_c = M7 AND M7V15
M7V16_c = M7 AND M7V16
M7V17_c = M7 AND M7V17
M7V18_c = M7 AND M7V18
M7V25_c = M7 AND M7V25
M7V33_c = M7 AND M7V33
M7V42_c = M7 AND M7V42
M7V50_c = M7 AND M7V50
M7V70_c = M7 AND M7V70
M8V00_c = M8 AND M8V00
M8V01_c = M8 AND M8V01
M8V02_c = M8 AND M8V02
M8V03_c = M8 AND M8V03
M8V04_c = M8 AND M8V04
M8V05_c = M8 AND M8V05
M8V06_c = M8 AND M8V06
M8V07_c = M8 AND M8V07
M8V08_c = M8 AND M8V08
M8V09_c = M8 AND M8V09
M8V10_c = M8 AND M8V10
M8V11_c = M8 AND M8V11
M8V12_c = M8 AND M8V12
M8V13_c = M8 AND M8V13
M8V14_c = M8 AND M8V14
M8V15_c = M8 AND M8V15
M8V16_c = M8 AND M8V16
M8V17_c = M8 AND M8V17
M8V18_c = M8 AND M8V18
M8V25_c = M8 AND M8V25
M8V33_c = M8 AND M8V33
M8V42_c = M8 AND M8V42
M8V50_c = M8 AND M8V50
M8V70_c = M8 AND M8V70

#DECRYPT %36~(M&Z?`]6#/?-_@I8KV@D`B)U-N<M43"WYGEP)"OE5TE!#=<V#CZ(?+A$(=L2/L4BWFA!!"
O2+R:EP'(6/?..4?F."$\Q!!">94[VM_Q'CU/V"AH7S_W:Y"D#[&%0N@T..0"/=+-<,*GXEZ(E_S^_M"BV8,A/`2..",2[^CJ?W<V'5,J",@GD3O'@.!8D6HLF!<5]S!D,4GH^M7;-(RX#_4+"]LC?&8VO#UGU&TJA.E:.C/-4;;*,Q!!"
9?6]>*,;-,40%?-I"A=I91!!"AI&*E7Y*HJXS#Z3<]B0WO#F\68!5LUDB6L(VOWX.EMCZG)?L?GRY/XL?=G9@U?HZE<:SLK"F92$RF`$>2T&5!$/OQL%50[CW2ZI8X5,DNN$7<#=NDE'/O13WY82552?A7=+`$O)D_[.Z6(H;0)751M+;T.DK:LY7'?\*,%GU$L:X..,TMQ.T=0?!=^CZWWFH!
JI%;G@8+?:M\FYWJ'`B:VQ!!"8`:V&RX'"%L@GLO:],ATQ>C9[/O>UQWW[GLKR(-:>*E]2G(2L5W?("&ZP@;QNZW)LP)'&@YH@09E`&9>T;5M>&O72(:P,JR"%ZC#R$@M<333F0:P*L02=AW;`GHRU8!8!
=&261T#GLXT?1S`)AORH.A!!"!#`\A3($E;`4F"X+GB2"^>^"X.0)P6-%O*,B*P$H6HOM0`@*TB!`'ZW,OUI*[#RX^<+J0>:^#0>R&YT3!BCA`2R):>BJO"(8&7S1OH-=>FI!#
RO)\URN'8._@`RH`MP!]?A!!"*B?;SSQE8\4QZ*I+EP=K[OT)IU,WXU;H,Z8W9M[]_QJ]0`F>G+H9L(1`S^I@/(P,!
HUA]1@F"\Y`2!!%MG(1!^!!!"^O2KH.:WS<L8W`M`@97/GK>7R%2&IQ_($DWN@?X>]]<S0*&6*JLN78]'\R$1+3<F!
J^`OC35A`"YRA_[R=OHX*Q!!"S"3QJ1[D8/+%W>.S1.U/.1!!"
>._G[Q0O9OH:<BJB$Z\\B!!!"=A86]5803<*N+`=")8EM/.E/ZS#W]N;@ON\2@4\=S4H=_4CEW:J!%[%JR9TJLV:8J/XZ39/%VF;.O'R<GH<>V1!!"
[]HS!H'_"2>FHYLD$(ARFQ!!"E3$XO&F,%L[I;MD4P,V9>R>35I].X.3\.:6-[71N85D2K-7'M(E#_=EO5JB6`\RJ2M)49Y>(%NT0"<.DD(ULAK&^Z=X-CP['8M*7Q)MP2S'C_D-H`X-1S#IS6]O^U0_3!
>*$O<A^\=GTW15&7G:GR%1!!"3%)(?@]D#,$(J++<461G`9/>;MZI('7F@;<M4%+%3>7A6@'H'HPH,12J3D%EZ"#?$[LRCK"46B(JJ/?9[@YFL&J>`I4LHPN7P(X5IR(21Q495BH[ZR;RT;2S[0,R>C8"!
:H%(@C!B28[[-2`6R_QN<Q!!""TQ!LJ.'?.#\5'M("^7A`=Z%&M$U[>2P>0,1#7'\:#W:"SFL#T]B'[YD=5#`0;ISS%^ETG<<\Q2?,.$E<-N50P8B$$9PWI2_LX\\L7(H7W1!#
-AU91Y%F;!E0M:4N8T*H/!!!"N49>3'H,0^T,LG_?&%J=D<;;EMBS>WEQH.W'7(S(Y),K@7X&[*UO)M($;E'8CA@D]XO@MG.?2#DF;]L81<T';Q!!"
7?339[2>?&7J]S@)C+)JT1!!",6WB;J?*MM%R&:]"(A_?M9A>D<<O=9MA%8LJ"!GGNLWE?R72@@#+DB@<V5O<O%-"!
M716,\"'.G+0XYB9@`V8W!!!"CL8P]W.[%`XC..29:[30O!!!"
#LG1[7V/Z6;&!9N2[HM.SA!!"K83F9_KSMC?`@KX-K@.$F-%I0J[DP/-WP]I)S.ANZP'(^)#,;21=X9R3)?G`-].6(C^%A->^718@S"*J.#H+EA!!"
,(%]2,T_^6X6BHF=J!N[WQ!!"3(#Z-^S%S?QV^1`05W2GW^&?"6$M^]?35XMXS&.TMPQ!&2JZ9M2\V,V3ERSO06!T!
9&G9XO`FQ"$6FDA*<;P/>1!!"%`/FY-XH^)HK`9907\CP:](:C765#*ZMV7SCJ/9F)#NKM;3,OQ`^9S&7Z];R%(J@!
^5?Z!3I!B,T`D>G,\D/\_Q!!"L>]BN;71D**&"OV,@J`=,1!!"
(9N(ACIDN..,.K7ILI'%O!!!"1/$@7BO`$'0N[&5^M(=N?>[XZ8L/#M](,*[B3I>6AOMO1((V.>[>1;*F6K.WNWM\<YNU/IL^3'`SX51*W$7,G1!!"
9=B[$"=6'L?/?.6;W[(G<A!!"6D2_:WI"PIMV(X$L.7%/\%B>[L8P[%A,FX<7?S3*ZRCH@F\F(M&76EB0R0I">(X%8\\XGM2$6N8-@(WGB7#(B+N_YR/DTH_]$,;V5:V<>HWAA?T#C`KPKP7JE&9^5<`>!
W^5&ET5B0UG2?Z59TA+BQA!!"&E?X&C'#`2B^6IP)$J/DX\[G%V^'6EE?\=1KQ%SW(5LCB^0HCY4W5[EP?J9SEP>R!
Y#JR>#G_3P\N0/!%X("/AQ!!"':6OP-LVK<>"=/*B+@GNQ/.Z\+>9WZ=N#S1`[B7G5*6,(]L#):X`HXEI,$-@R8VK!
D:L3%CUG-B@8KW;PNVEC71!!"7[1]EFUG\BVQP0=)R=/;)A!!"
U;%.=(N.S-!Z4J*V"/CRK!!!"_6'C!S5SC+(31@:6JJ6^V1!!"
V55L.DTY$O![[B**D'MZG!!!"M3T/CVPD?>8"O<#DKV&"HAJ%*\4&C9$;H:R5$>DG[+4]CMGW4_AD=VDL"OU$HAO9!
L\?E940-M0VK?%6L$0DX91!!"5X`MD@!W^=>HTU9G<7-3"EC])\F_(?"'L\`+N[\@[YF_Z6:9)GE-L))E0.4=Q7D4!
/7H-?T3/=&J)6Q0G[E/E3Q!!"UJ5%F!$M9M$?7-A',WM[N&MOUP0@2O:52EU8R/L2U4Z)X0S'O(S:N3N#MG03G6.\!
E-!W8V6!)*A(+:`'+9AG;A!!"-EUYF;2"P/_MTD(1;E;Q*D%Y1]=Z4[<1"OL4K<%P(6-;SJJ-CJ@P0T;;3LK$GLK)!
&ZZK^4W#57!L`)&1#."4;Q!!":9H]71[CD4O,RN88],<`];!G_^\[%>7;SEA=^:59&Q47\MTR$E[J//-SK`1AF/SG!
QB"1TOIB#;/+:1:^N<N@61!!"N:M5"<-:K@>>EV(1XW-01#\O2;&H'IO]N8I5^FI'O[+4GBU+4I"N*RDX.O\!1-5\!
8`1`U3?&8[+,[\D`872`7A!!"5PF9"2-@BI%W1TGCCS9B7!!!"
"AJGY\2N>8)M*]B+!7<</A!!"2*TCXM_YH=)O^GHDB4$1\1!!"
[=W!)T&R"="96_/PJH.2I!!!"BF`P?!X&!/HQ77ZG<HO9M9SR?:`#]E'/E,;6Q*M%2R=0Z[)[@LS^',`$ZM'TD7VO!
-8P$8`A:FY^^38+%+TW:MA!!"W6Z87/!_CQKE&Q"]\J>5AJA^(I]L+VB^2-KF$0(3R6ERA2&[]>2&:3W8RS6F;+'&!
AC'$"RD<'Q`#.M<RZ$R6>!!!"T>0%Z,QWD`M,]X'MQ`HU`%YP;R_#EUN>%:/9-O-G,$=U:I%@A/D!'<TEQG'I;8";!
,I#!X"+5K`V'FY^`3E&&Z!!!"5++?`S7"H.W@_9Y\]K[B/%4J86TR(>.^;8!1@+BKUC7YECR['/4NF(C2S=39E*-`!
1[-U$AU?\S5+@@OJ9'-2!1!!"X>82NR0OL9$/`D*,7)@0FQ(T9OVWJZ?`W%HY$:;;R^C%L^T&U:<AZ$!A_B/T.%U2!
!-`>2TWX8C"MOPCQM<3BP1!!"5.:W&T[KE@C0284`RY0%_:&5D\E2>+3ORS-QKAUZ\$BK&=KR27C;[VCR"4LJYIX/!
SY;4X+5X2F.:@@'*+PZ'-A!!"(B=%T-Z'5NN=ANJ3K:(RH1!!"
1)G(O+=E^CL\7/1`5P_TD!!!"YQQ4V3+$K2H@3!JHL$5Q7A!!"
UI\-@Z#_9()/,^62FV&L/A!!"_IN17(V5`D>`&/K'#>).;LX/VY1$H"'"BS<#SZ6-N>1D3F*!F8)6M71ER[N,LVV<!
1%3X')%%[M?^'7H1!/@^91!!"E(VP'-X^,/2-%D9$TQ^,6!0:^@+S4/80UB&L%NQ-(VC0UW!*@)),#N&GA5Y.UU7N!
V4U-TES.-L)/T4>BOI56_Q!!"(GQ<(V$T_`(U;X:['O]B4P",ORGG;-E[T"58B&8;&?L;5P_V1/-#>>2@?S^)_I+&!
NZ'XUPO,%6UVFPV'1/+VX1!!";F*#I_(#)V=+0GTN?B\9PRB_@C?-4IIDLA?3UT%/`-UZ."<HFQ>>^==<,_ZH&T>?!
#?\6U3U+4UKW([ZX:"%$&A!!"J*X/7/#F&KHV3QC%@6]F)3V9VWNA)Q`.Y?A%=N-3B38O.">]-KV5V4)<1/FB6O/@!
]GYW1LT(MM\ZAM+-/CF?)1!!".!A(!=.)E921'E4(YL4_Z(O]"^YL)N-<`0D31MJHWB.J#,HE591=[K1"C!@BO)@C!
M3<_2DN4U`5Q2`LFG]:.Z1!!"&SJ9KNU->N#]=WB6O_>,H1!!"
#MU3,2;!=KSE.\??.R%))!!!",N#TW2:&['N0Q"X-9?B`)!!!"
SCC81YU](_.<SY@":H)+0!!!"06&?7=N^5S6TYH>PK5#C\;ZA5(=&[8II=;!S1P)(\8)=KS=K[M?3S4A##S9[NR"M!
RTZN-$Y00G(=E=GC[%5Y1!!!"#7#X.[&^AH*CKSP$JS_3=QSEM@`>Y.\DF1B,QLB/2W*4[*U*@B'8'NU>=R)RI"BK!
AL)NR`U:2FA_?AE:(:27A!!!"%*,*Z5N\3!=\VJ#M:O@-:>2D#NV@6N*BY($UF$$8'4WX4!KP$I#E3N6\M83Y(NZ1!
YR[ZE4]#2$AWW<&B)?UO!A!!"7J@X&,@@FJ!0?-=MM"W+@W8IH(I!^/>(P`K[2,K3J_N?7##,X1O2VW.L,@[[YZWY!
/\>*(F'R(_O-4SJ8QM#YD1!!"C[VZ=7.Q\8I%&0H=TTKWQ0B[QG"&W=OK8^&`@.7G#@Z#;$]L9M6,@G)U6&SM*V'[!
$N369_38%)_\&40]\1K,I1!!"J>RY^;81UG')WH+:$]!P_8F>7"8V:I`<HN?E'TSD04XJ1?'_"H'6K*D!V`H&Z<,U!
9Q4>)7W[;6YJ"44VM!EO/1!!"6P/SBB#XD?Q'9:LJ!L[->!!!"
<8DQ/:FQ"HF^LY:!M3C8S1!!"BT]S_4SU:4Q+9_!,4A/?_1!!"
_LC7P0D(]JK"A0-*?)Z.5A!!"Y"@RD,9G.,7X:P-JX%?H-)K285Y/]=8MRMLA:Y*^$+[ZT^:4C<:D;UF*W^/XS#(E!
,S$=&E-JM)UE^T"_A;?#/A!!"N&7Q?^+WXQQ8Q&=3.6X[@M?9G\;F9`?ZK6-D\LR*O7Z;_ZB,/)J'>'7OJ!#CL5]R!
^[#3%RGSV&G)&@9KXC1FB!!!"$/F)HE6#&MO5,*0$BDJMO?,C.G=1=HB5'.(OZ@Z<?UX%4<E)":Y8Y!!>"'\&/S+B!
;5SV_>6/Z'H_\U"J6UW!\!!!"$=+]R(`E[$E[A*9O;Q(<C1_U>U//-6BB'4N:,J\>K2;<"V8!1$J:>HYTDP7ZY$PZ!
W]./Z#>FSSZ%L5$]#<QIZ1!!"+#]E[*8H2,>XP)DPGPEM:WL'I9PC?0*KWO'3/)L5.Z$'BJ\=8[E#]'XOPFS2QQ'=!
!2Z+>OXO`M@ANB)`U9SBDA!!"!ZZOOUV+J(@S-BNYSF<_"*Y+0SZ+I9S!(4YO/>;JG2/K.6;JJDOCH&H],,9#'_?Q!
&64$+OJ33?PF2L/98[0@K!!!"J&E%1T"G,<D=?-*@Q8[(:1!!"
\/O)8J]659%4)^",88,BBQ!!"9CM#]VGDWQ@S.+(EZ"F/GA!!"
%#/(\V6QQ%W;<Z/#-/KZMA!!"`V,92SV^B7O'Q?@+.S@Y?SQ##,JF1G'N-1I+$$F03*1!#
HL`ZC!QVOHC_5K,O(G6S"!!!"]-7),9.^-;3$Q/*DF7FWSMVM33P4LPE[+OO"G5M*S8JRJZ/[9YGQ*_<BN=#T]ZER!
X>RKC42M"KZ6^F#K-26")1!!"J=IL9IFFMB_#VM&]=L3=8`:8U'A'Q!$_OO0QB88-4^7^=9-XW%PM&H5B>75F_TB9!
%SE7/!Z4N@O6_L]\@9C>"1!!"+DU4"'@:2Z.TJ_YO&HIJ,^6XIT\*F,?S^;'1'&^A)-,M]YKS#&`TI19]A[1.G&,2!
@'$71J\KNMXP0_T)%6HRP1!!"M`48(R"=Y?IGO&0\^Z]J[U\/;0JAR(7WT[`\I^%?EEV_*^$0#F86'I,QTTT0GBO5!
RIF8@$;%+9\B$4YCJR2OWQ!!"=+LA@(KACY%O9/U)H-SF:DN%3K">'?0@K=*5"'F[DK:]'OUBZ5P.PH'EL;EF$?#T!
!6'2?#5P#!B<*\9)'+8@8Q!!"R6;2`;(UH.V$26"_:Y+BN1!!"
`<3\M*.`*72R+CE18@-A%!!!"!.-V$W\Q\#=O@$[A[)>H=^`HU$\D/_PIRD%VRV+CW7!!#
H(OS.\F_'1,JVJ;XVZT9EA!!"K?$Q-UXZC/$N`KA0'9+I<H\3Q>WK^BI1T>#F/__._4@@9],1M=ZDOUT"."AI,%X:!
ZC.?T0LZ6-[=D_]=TSM-E!!!"QJ`@,Y!XU!36;'J=^$HH\G.CV2')![HV6*=E^Z<447^PUT@9VZ`O\`%0D[3]+'[K!
U&ZUU1<F)I(QTCTI6BIJRA!!""UN_P/`Z+.*J13,M2(YYY8`D?]E_/O^`@BN>B8<KT#9KM[I@=!^C9T4&>P<`HK5G!
]LBS2A19"!(Q$Z&5J^VA1Q!!"101B0IGL/H.K<I]JN,CH[6[^-%XG=+;:GSF,Q%GYV?4+:@4^R8'%[\X\QQ7.X>R*!
0<:/B7?AZ*#L5T]X\$[+MA!!"5?/#6\#`P'>S2?FE-U=*HA!!"
6\6:_G^D?CE,4,4H-T0W^!!!")J^?JI/EO%+UC0#';GTK$ACF$-H;#LZ*/`F^!A13&,5!#
-,-D2]#/(*CW><$1Q0S#C1!!"O4]=@1[M'V6<6<]6+(9M>6LOZ9OR?GLGY'!9$#C'/I(<"P3.@I+<@7.;D$U5DJ"+!
J,&H?2]0-@3,<>0H09G>B1!!"[!DX@WWL;\SU=F"MK!Y4L$@ECXV[?E!B;$N^H8N_<=-!#
VO)>/UE\N.LSIU*GB=SK=!!!"B1X53+(?5<>.XEE^HAXHSTG?0IF3NLB9;T;R'UJR$JS'61\0&[#'8+J'<.`"CM:X!
&`494**V.GROSP.G>PX?/!!!"Z+S&@LD[?33#>TVBV;\&;1!!"
[8'Z1,^0K4$8`-_-"^_?@Q!!"F-#$XTH\"I?81QE4RIH/DL9:@M;>@8#_D/%[>#IO5HA!#
@Y0)X",$K"0_CV?0X&JBCA!!"HYMM0L[#7@#3YK`1.JX<KAOM:7ER);!T)X[O5`@#=+%I8;/W0=G"G-^^5EOA6W-A!
W>JHH,W6@&L[&5H=,V6A>1!!"67)-N@-=1#C.6[@8KYBP[H:PKE%`C3Z*U4IWY,4A\DM!#
.CLVF+N#$P6KU6&$R[:VNQ!!"=G)JG>)5,C)S-%=LO+S6HMKZ'@Z'"(K9O!S'D,3(5NHD#L-."QCTR_ONR.F@&&-I!
R<0J4TKY!V4@W<;YX<V]A1!!">KN;)CT,<A6/ANO/277=@1!!"
GH_?;F"PD;GS!!:TO:IJ&1!!"^R^R-LLYC3N1IR")4LU%P_XK1#L+VT<9V=/EH_"2FT64"HLM2XQW#U3M(A=),O6/PX_[4B5FP4,:N7SRF[1]?Q!!"
*31K,:?-<"&U>WN3D'\X+!!!"B2TKJ70$5@V_1E2OC8%7;PO0E4S<_TWV6!P7]"`F5TD0,W*6;5`2]V6GG"\%][XV!
=MIR<]5&-Y#";M):FN/N[1!!"79S`@CA(Z\!V60)NP?RQE"A5OL,)Z"7U+E?8[Y1<R(;0+N,!%H:#Q%@W=[!:[@BP\%"]>8^&^R)@P[*RQ,^]GA!!"
4:%Y,MFK<@39OD#/E$`-JQ!!"3%+;E_BF4Z4)3'S-/>OQ9<C*T3R*9(M.W9:0XC1*Q&5MU]E*I@<$),?7,`N!8@]=!
U>96Y#/44@%T.5#:'IY!A!!!"2VY`T7\#%>J%O1BPKO>Q`A!!"
RQ8`X!H?7JG&[A8X#F-,U1!!"D8\L$CO[UUC&?'I)=.LS+A!!"
Y3H6VG6./:.)TFY>)@_^_!!!".YU(0$;<1-+RB^<U*I`++->RZPD^/16T"+<A23I0"5-I2/B[TG;G[B^RA9JZ`>5G*V/J7N@YL4!C`P+09[33``4N=E"<YM9(FI3A<SB:S0/X.1.T9I^@D(2CV41:=><',$PE`1EAJS$>^#-"<5*NC$L>4;0A$PP<;M,5COIBK>5!#
*''8Z/HIAUVDT1DO`B?X71!!"I./-P48Q&T5@<"<Y'R=8RQNAT8!;,_2(.6@$_)KP%RC:0U;DHH0]7Z>R#C"X[E[B!
&FOC+URZ9M96KPDE7"SF;Q!!"N<N.)5`\&#5O[&0@$_=HZQ!!"
<9`Y2<XQQ[U=3+<:()#"DQ!!"+ST\3_F>1/%91]`T_]YEBQ!!"
[9$'2BX!B1537]\M0&"I`A!!"A4./?/7(9MZ[D[@U<$KI>`V>SYU>9&>/%9B]+8V\?ZU!#
:^@`/=2**.?'.JH_Y]FBNA!!"UST7TD="&N#>\ZUM_R6:8;.KBQP2R;+SK;S#G=SB9/!!#
<`/3R/1ZG<>H'DLQV+;7P!!!"DG=3V9*X:O5$3:M_TYB&`1!!"
BVE7N;WT]E@GV%A**$Y?;Q!!"DZDR[B[VJ5.VDRUNEJ/+Y$3Z,R[2Q7[MXZ..9UP`7$U=_3;I1(A<2;56/)E6D\U>!
8)%,6%.=)[M`TZ<@H*+`3Q!!"2)Z?@Y;G>=\,.^QLM2!P]Y03>]2%.Y.*[?)D#Q@7\:5!#
5_PKAF&1F#Z9;)3!<$I:?Q!!"-.65I31A/D--(+1E!CIE?!!!"
.CF,M%%"NJ]*3SX"[@(7PQ!!"TD`&`N_UAFI0\($XAJ?P4@LRR3_O1)96JQ&8TRCI:I#M@7G5&=@U+7]=70.VN6/-!
*L?C)UY*WEFJSPC<93DR0Q!!"5S.5/2/)L&/QR5U7+_[OP35;Q?"A#-=!VH-:9J"PW+E!#
CB22"5H->A.UF:;>0Z>:/A!!"A>1=_#S`:5`R"91`JAY$GA!!"
L<"$)8^E6-1#I`O4CGZ,W!!!"Q!70(HYE(%*!\,@W23B%E>U6LGE=W]'4(Q"0^^*2O6%:2?^7QVR!-E6+URIW5DZ@!
J)3/>@,N@%=OJL2@#;K^,Q!!"!:@?-G?.O1@0(-91+Q%\[`P&"(CJG$H/B%4AT*"8<C!!#
#1>]%F%'W!HQ$(I,`N;TLA!!"\\1,,F0N%:MKK8XYO[2BP1!!"
5&?NI0\7D2<0H7@$;1M4"Q!!"%_+=E.-A.FQ>[\7:NG^.7A!!"
$`QK(X[5T"`^]KA8>'EH,Q!!"ASZEPA+DX70:3L:UEZ!MGA!!"
0CBLP%T[=\JDGT8;,_)>*!!!",]_BI=;-AF<!$[CJ2J2D#BWJAA&N4.Y&!!`X3DZYG:#-#.(>PP3[K+N]FUX[ZPJ@'EE+/_17FY#Q1)HFC-<2UQO1U-@89)-LA^O@)TUU>RA:(M&E#8J\2>*D7R,59`,FHH,\:"2.S"@D:=@#^I^(1>0"L_/CT$>"O`%M`YA746=!#
A\P'O8C3G5M+5)BGKL0_SA!!"Y6[SI$J.E',J'::6Q!MCH!!!"
)NQ"[`+$B1XX-[*'L-#DC!!!"AV]B"J#;3YK=01HSKK*3OC8D#A$G%DL*5,Q#.?6_C'%:CI*I_T/]0HG;&O7<=Z!C!
@*):EM<?Q^B77]#L.W".HA!!"Q%B'!\>3,1FM#S.+*XLZX47*!=G4F4C/VY"1,OS5CF2(@,K_\TC6(&Q`2/YT@:GC)J8')V'>R`])$ET$)>,S))=_NFXK7\J&#XP]CPF5@SE&"RU"2$1HO)YKI.-U;&NZ<Z;OK)5AC3">F6"T929+D/L)])Z>%"_<N$(,/NZCTE>'<_[8?(#GT14T!"?Z1@R*OYGQ/=[]ZYH1<T0<1RV;Y>8!_4:4%6":2P!F.0+V<;'X>6L?``1M'$B,74ELY.BHY&":(28^;+R=INS,88=(U.\MC0VK$\!(F>'"Z'T.E7O&/`M]@B8"-3RR_RV84R[RQ*><^4M[?M3ST[C3OF:TX!!!"
A(K9KC'XF)]!GXWL[I63E1!!"4Q\D>;Y909UR/DSOJK;M\.-]X:N^9S)><,E=.KN+^=<IU``8E)Q)3L'M,AC^B.UIF6[2PFF-&L.3_5UY0:Q=<]Y:!>)2R<R8V[P\4AI9BSQ);S/)S6#X<598><ZE<O#@[E5\`-SF&N?MM2[(PCDUOL5(021LY7*1+!PH:K]**?LR-4H:![K=5?`AX/PZ)KTR%^9MHI_Q9=6IXCCY61Q?CQSA9UQTD[#\="7/[[=UWG*J/BYV^*%PNTX-6.8YY,/WWS_+UB';MG(AD92Q_Q8;]$2<`T6$7X_MT*Z?.7Z1*M&+'!;"7FY?,Y9"X3-!(]T068>R(3AZM#B*]XZ//C$KN1!!"
&PJ'GF&ASO&.;?)5F+OT;Q!!"1R15!H.^Z<KZF1R%\UF'5!HVNQ4EH!<19[FC\I$E-Z7=YF2!8(%C29L/(O1YBFJHL(-T#TFH=U27EBD,D</?@U3/!AUGOP@T0-.31:*D:Z#V/Y5NI=J.A-,NQL-P^5)5&EXL4G*L+K&+>W"/+*C.>U,DMSAV`D?4[:L]-F=/\`C1"KYUY#4%"V.DL%,K>!#>DZ,C[A*3;4/L*UO1W!HZ[';9&:_VK$'T[<,N75Z\SCKK3![X#Z*HZ)+T6N;0#$Q,O-6><%8/ME6\UERM6UL*05D!3M=-8J11NZFXH.@>)K'_+J37![XM>;%&J2+@J:7ZPO6O=B73?(_V(RMPU(K$)A!!"
I6EUIER_C:Q?=PN!@:B!1!!!"8M0Q,.<8QZI,<QWJ"$=;XW`/&04U!0],-1M'WR:YPPIMB1.S9MU)D46>1AB>=)E<C8D>46/^MXSO"0)D@.RS\/GN.HV3]Y?F\E1B=L2&6R^2I'.0#VCNUE[M4[J($N<P;?B`!V6>&_%X%DQ#P-^P,],ZD<RF[8&&:D;.F($!P"]W.!VC-(4BZI]]Q:2+;7>Y#QSL1SAIC%HJD$S,A&@1F^5'>K3G#6)VLOJV%&<P%^#'^N#B\][QK\]8[-L@_5_K<[RIG!=`,%=4%SH2)[7I#J86V2/O0B%Q!&CI,T)+@B#6_G[JVM.[LR4M-\MC`)NTXLS&)8RIK%[YD`UL2L9O31!!"
$ZO3V11<(KD-'V)1*G&P_1!!";Q?$8!S"[]552N=L]B%QC?$XG)/D5N/XNMT]W$T%/!3@!1%^QRJ)"S]&V83MDS'O=C75AXIN+G!T)ETYLY$E.10G\GS)E,IH@_A#7`]'?<W1XCXXVJ\1:L-?M1"H9'!13VL5Y')AMM0[=2FY?Y$_@.9JG2:X0'2P&BW[0Z3,<F'):8E83LSGOP!""L6_&:!%&&HF2_[^+&IW5Z.,\)83''Y<^O\\>HCQTY$Z16H[/E#F]!<CP-0,5)%%\&F$Y^\$QEEA8L^5C.:%4KXKI;BU=(X[?Z<WA"N0,+"N>&,FH]F$&LK3[TCZ/M)3&$;!=^&1#`KR75/F[!L8YJ8JQ&5@$1!!"
?&;3-M8Q+:;G:EC.SHKU<A!!"L[\#P$`#M<Z_+AJC$@YEBK42R\=N'!#V@LS%3RW2YC./%_#^@BY(&R$5TH$E2I`"*4X1"M6$`IRY`=Y)1$=IXXKF9`Y0/#VC=WE719,'\<X)TXFI"&_)?1$1U>!K$>Q':J]%MJXSE,$91!)%A0Y$()&4M4U;N'XO3'HRN("6,FLZR:;0RCI,(VQ0I^B6W1TTOU;6#`/&0Z$?IMJ^;Q.,*7O+(GAWNG7WDJF!N1.6;_QMM>353N7T9_D52))QQ[NZ"^H,`7O43JAH=2PF:JIRNI35VX/R/Z\@*(*OF`8&3T[\G2,347T5'#[?P"6YQU*GAP-/O.%6ZBF*,<FEG+N:OQ!!"
]0ECT:7-@&='+W(4.$#X'1!!"JV^.RVT*QY3RM_.;+\'3%9P%!WZV@@<U]N<4ZE=Q0P:L]ZV6[#""+_"G=;J3@\3_VV>0BY/I1<.V7&V,^A1)B&[/OBQ3LYTXI(6^'J'H9U)W^(R_D5^F^2ZF7?WAF_+4^2IB\*Q%M&D6\)OR*[Z/T!X$PS2_+V6;>2#2K`2!'0WNAD>6$EQ(FXSAZ&?WV.R_V3<J'ND-_/I>'K"$Y:BJB#(<AT:+H2"0%<V$KFT,P?>VU8OV:2N#TJ9M'FA@"\&@.A`Z,KG2T"4-%3D1R7GR/V)"_-Q3`,EGV4KK<V;ORFE&"4\GL[GH8R5J-YT029I+[=C_G6W,&?AKM5#PUYFQY1!!"
H["Y]]6'7C^JYE%2"?+)JA!!")B#;/,981#:Z,8(%OYQ5.>7<K9)Q2<R\#77,F]V*73BK]%NB`VEX:>G\1.D`I4KQF@EX+)$1@TG(GJ9?[LPC:<V/X[`\,Y9:T9OE)*K7Y1VQ<54#P;75+WWFU;+&#;"Q8<->K&,+D?+C'B'MSG+_V1MH&TPJUM,U6BFOFR>UL#TOPZL((28OBO>"3A$K#]&,KG40(C_"0+Z\[(^:W\8O3SE05O)SPT*H'DRT.=;X9\8%]R'AMQKS@SVS:4(SDC'\='*U^'E'M16HW`_V&N"0'HA$:*+1@=VY-7G2%=4P;-'C_/;LW2=\<R1!X)]Q*+LB-HR4C6]WL"KYTX17<+3?PQ!!"
QL2E)RCD`9+$I_,GT9K=<!!!"6R:1._AG^^"7/^+Y%2I3DR4J0^F5Q*C\MY,&ND_UY14J:G54@=_M.FF+%R@72H571Z>SS?1+DPFAUT@G/6Y7F!OEKDX_D/92,XC%"JT@X!XX_8OT<Z'^_5.C"<?`YEUVA=O.8T*^B]&)PIG(5A.U-GB;!H'G<'),&`>;8];U<:P$J4K:["9H$A"H";EA\4L3MZP>?Y=Z:A22C2DZ!\[0NOXXE&)F%AE#=#R+)M'1BRI!#
OX=<+BDR[MC3J;2>V)N,(1!!"XUXFA$6H!S[K,&,'XY`SO$#*60$M\"[BIBPKO`=XI5+@E!AGUC?=9</3B\#C$9JJ<"L:='\\P\0M+?4')7_]:4\Q`@^4.2H/AJ)-)5.[4/!(I4;H+8Z^26WWXP:E1I3B*BW1_$1G__@(DU<%]/%3SSWBL2U4W0]9]L6[6/RUC&^C;JV?CU'*H,48#GFO0'DR4;-`58A@+#61PZGH[#Z(Q9=!^Y;XT_OV+5KSEILD+S5!#
%O`/8#UG9M=',L,72E<U!A!!"2?7+ZKY=Q`VNO^?\=7]-;(3G4`]RR))?L>X_6D!96L,3C&",8]9;".8#BT"OCOL"I6Y4F.'X<WHGZ-\VKV5M+F#=7-+WS?4+EQ<^:QXKH#N3+_P3DTR==J/3#/G,S!NFBNAKQ.,'ID/FI4!:V$UF\TW50,".H9S4*H,3N=CX.,3&!Y4=O`T80+Q2F+B+RWG`%API,JNV?W&8.^-ZWCAJ^Q[/D<.6O<T_>R(0%I?7.T%!#
)J/:JFKQPRA(H69Q_/]%8Q!!"4ER2'K[+GCE#(.G#6TPOH4IUA^#=EBJ`\$5OML&.$M7EL/U`/[GC;*6R/0FE5<PEY+R-"Q/ZA`\#"Y8NF5V,\?\]/ULH\6E?99`[>X!"]S*TWV?.NQE!=A$Y9B>?KW>Z4CG^;I=D6<IQ_4J&S"[.;;]38M-;G!-P,W&4&CE#G/G\3`8)^-;E,W!V=G!KQ-8B!
ENM1E@BKF'J8&\8IAP_$41!!"$3UPJ@4A0!;45MD&H\K=O!5J&>G_A.1U_[A4YRZ;T[7&FB=>=IC.:6DK,FU\N;D^C()U!M',_4T7J,([*B0T9#Q/T")OUZIQ^;AXO177>B)!#
E*C+;8YJ_->102TRP\$9&!!!"G)V<@XYC!3%A`TX/ERT?;DNA_6[[2K(A5PPB'IU.Q6]!#
.RS.(`@V4VO+8,$U8LTW*1!!"KH!*E6(DDFD24/I>!7K/AHLNVIR7Y4'(JX"MYW]RJ.8@PH^*NQ+7S?#%4P=&EW(YEH*/B'Y9D@0N1K).G%3:^`1WUF/7'U[6C[MQ.$SL]"&/$=,;+G$'9S^*TQ1_FKG6-8E*Z#R@[QE=MP6Y(#F/_)N:^@KD6580&0?B!+[<%UW?'W35J[*:-U?L4\@%^^$']A;71L_OC)+"!A49#[0I<.Z3\>"B$+>++HN^^U!XJ"&$HIE<JQ@6V`Z5_*I)'KC#L77?I(XZ.2H=96+9KJ7MUOQM%8\3%1>)E&OCPEZU)!4D2XSK\?G=7Q6=G?_3%EP+[R$`P-T"<Y"K<(%HJ^>G;Q%#<1UC,5B-2!>F@4[[*-?-#PJPHUCI8I;169VM7M>'SX,!<\6T]XA)V)#E=NP9>3S7VF"U)7N7XBO&"0.]<4:"-\`'3]'L41"O`GUK-K)T9DG>8"6#]R]I\8OBF4*+\W*!MH-(_PA/?HD`"^)H8_3B2IK@L,8"M)[MCNC@!N%26I(YAQB0)K4*&&]5TOOWU!_?1`2%K=P>/W53(0W),HWC'N4C.F8H)(C8&V,=VRN7#"MT;C_0/L6P=E%]67WTH6WD4%,?R!%0XBCZS-AK-9[6NW"]0]8S&O/@+J"(M2];U6`+PH"5KBOZCW1.DL\$W$3<6,<A"-`/\@XY%?3,.UAH*9F@Q/5*5CL-;7QC&]@>YW\9G'T;YQSK&Q.:^#A>@%OZ]6;P"+]\6^F<9#7B_E@4#S-%V\64\@7QZ/,AV6"6<(GRJMEKKX&/-S6QCLIBJ>**<NZ:LJ+Q4H&IAXO9%(('DXVUQYY*P$4F,SF?C)FP,)%WOTY$X^J@09).CCQZZ?2]/A*KC0V!SNU#],55YR2[RJ])E!&0GJZDS;)YD>D85^'(B3J__:HK5SMX/%\)EHH+VK(4XJ%=9RNW/D/.Q]NP_/ZLH0M976U:U6G8K<0^@^DQ_,>Z),,`;>Q#=&YJNF/?(3.(C8TXZ996LV87-33@2_Q%)+MYAIHJ3]IZ[M:A"Q;`-&-T>TU)^#^E"KBL+U;G=X,WG@5<N9-W"F*F%R&+C626I(_*L"RO`(F:2VTB&1/05M3BL=T;4:XFJ@T?PJ7CFP.1;H5E"0,(^ZCS8P%9`^?BBG$W.3/4)=[4"3])'-]6.VO+V=[7,16ZW'WHGW_^'K[%DYY.1CCOE6C@!W38'/%)C?16E:"<HQB_ZR7I;IQ6!4-QZD5X@\NG?A*+4>(WEBJ[+SSK4^[6G!\60G9!#
OFQT\PFB?2"O)FXZ3U+M:A!!"9'->,:\"6#Y^-*7?:SWWZ&X#AO,0-)Q`,,8%&(\KK8U!#
/YDXFE>Z.G>N(+-7E0]05!!!"3OLZA__,UD9N:0DL,R4%?O5^C&'`MP<VAI#@NX,GV/,U+':\=XZ5N[B2WZNXT0;+6.APJ2DN$J*-P?7H^+84LKW&`_T#J'2F60'Y-H^4]O0SPI^7PG>'BUZHSX,@/V/V)+L]<MH&6@"-_SL@F_;X='`++]5MKZ7:K$EN\ZKYP,*I+!"7VZ6.`@\U*T@C%AU)`EKE6Z[RW)]%ED=,WM2F$!E8%Z!='LCE1J1PJM0I1@;0X14PY?00^^8UU(D`X2%#(^HG4V.&0UU@N6F7T[RU+[`6GPT1^0A,YJHETMN0T6>D;\KRC"P9X/WGR9T(Z(8C>]NY\9EOLXA<?MQ]I^EW??5-%6?K,N1T81SJ0'C5\*EUY:+_9BQY.;JL24A[[SE.R/^:J(BD@C-;?U7K?2VB%,^G-/W`<'LXP@;XCU6@Y"4'6*12!WF,CQ-_([5P-Q:B;')<XUXB!=P!:*34X'@3,L`V$O$,RR,D;2ZWUWR@WW&#WH&_`U6V`3U0_56AYGC/_B?A&*Z)!3UPUW>Y&ERK(7E">P,PB97?0+[1C*@JH;-2Q4*&X1?FF%ZK:"'=;#O@>S(=D7\VBW0/(D(*CWGZ$0H/HZGXKSN2^(C"K6(6*[G<`8P`L>WQYR57]#^,^NXZC$"&:[?S?)A)"OU]=Y6:LR[^)X^9":E^.*+_.BQ<I4E)56E21NPM?-_V3O^:#-P:`403R_=D--,*%T_MA0FBURJUQ)AD:I<FXZC7`$M/2I(%)C9_TXRV@A(RV_2]/V@%NF2XP1[#.=1@=#I%_L(#1EHBEYBJ1Q)<P"4@:\<%X#N;^(SL,/],@O@)KI.:_5#D%?B_UU8B<%W]4_<$L3T3CW_!Q''!AWATO\*K%['`@@B3LQI3VPZ<PYK+JR&-L27?#;H&_\T<LXJB,O'HU0F31Q58KP#_=.XYYQ",*9>'O\(F`0Z`XXIH1+ZVFX2.FM7GALE<H/93&4HC:LW3/OQ%:/O9-#PF01-5&E]DKJ$2_;FLT8)S<-UMD&9;J/J'?PO#-ML>N*(5B%:#!HGL$<@\%*8TE;5R0W>WLK!8"%>V#G.3`]*SU5#R@&E0VPG,=KL15D3]"NL,NLPRR:[=3*T,?2[6R0[MYUM;X(Z=3A_:X6DJK<2[7)7Y9KN0)N1J;A8OA$+AH[IBHX&<Y,-=B$22O10VB#VVK-<D/#5;A_ZR*M)_9TQI:N9'8L<#:FN"*9G"N1!Z<F^>LOV-]6H*-](P6:Y/)(JP*[B\'8MFK9YP"91!#
=6T]E7@6G>`22Q"@,B6^@A!!""T:<]YP`SH-[(6F\8("<V/"QI]D_!U\J"4Z6^"`'R-S,^(=@)[`A9WP;W#B[B3@9*+!P";E\=MF=/AUB3<*H+1!!"
HSE^Y8G]GG0'H83;`4`=5Q!!"<&JH=EK3;@58!O`VE*$U`*:;MOHD`H*S*&%HIC3$ZY/]-=E,2#:B[,<7-4`#/';HMZ-@,^:F8V/7A*<5YDLUCCDH?BC4#35E7*2MTZ-,"MG"-$BD]MK#FQ@[@Y28KVZ<!
BBUCV9]"NBU:2@$<0<A>/Q!!"^-0',Z:+.8'ABN&'%0N..\D0S'9[8U9E"HYH@EA3HI@\'@\E>FD$L$[^Q*$.=0973J;:C6W"5KDSV$7(/85W#*;]9H3_QQT(D>[LC47J]#9!#
R9#N<%\'J#-K(/'-8U_[VQ!!""D/3>$J886W^<8'8VV()?_\__*,MX$DU%R_?XX<"NT'P@]@Y&I!GA*F;8@2^.5YGE&0VFC5^]OT#/^L'](ZF3J!:QA^=BB"J.8V.`;W_DJA!#
:74N)^,B&^N?(^6!64G9\1!!"Z6._6,7P-K,ZI3K;'']EJ;\Z&*1Q6W:XU:5YW+$Q1BO<&^F4)W[:^@H7EL\?^-C<76[J;Y)D&:9+4H%SA&^N!H\)R0!2+9>N@]/YHE!.U<!!#
=P9)R*DB_$V)#PD&NBTJXQ!!"ULR7Z]G.T:F=QU5DPR)6$L\T>0;U=.)%S5T6-IY`^EVU#TT%$B.-HAU1H=0`<5$D6(*!?Y)W;MI?F?TS/CY&1_T#'7$39&',W0PJ32*,-=A!#
&#UA,#FE\8_5WDBYBBLW;A!!"F$W$5W/4=H?.]Q<73DVV?2=RQS%S59]"1$#PX=T^(7+6X@EI>[<S3(U*-1D]F_9?'#X1AZZ4_U7<$@%8H8S:-$*C!G3T'JJ!U*LS[!D.$_9!#
L#;&O_(4D_%JUK8"$!&`YA!!"(!-_%D;`ZYT^B=)F\CY`EC6?L\M@8=W/OOJCE+EF_(3H5]LHT/4D'3TJ*+XT7XPX8>!)@N')YRU1T_*M_=XT<=T?FOC6A&3OED@M&HYX8,M!#
2=8W%B-,H;F%Y;#5CUGSDA!!"Y28;$,BN]EW4)@<%)*]O1+#E%W>[;S](;'--X32L;J8MV://JF[_SZ=!D"EH]B<RYEPJMH'OQ>;!]Z0P6=ON5`E0-4L()SA1Z%I0.%%#5%)!#
K"S%0SC7Y8W[%%XTN\\(^1!!"]>2)?Q_(]SE%/?-U9%6CI1?[ZXD>G##]6VIQ@^GO*OL0'^NU3LV_(02@N3:1Q[:B06/GK?@,O^XG1SXXYHZ9\:V6@_2-X0&;5ZW0H2^[\OU!#
FKZNDDF9C++$AYZN-&1>=A!!"0EZ>%41Z2-/LY0GZF9@J`$0`*.X=E9L;IFQ/=U$1(L60L^H+NG)/OPU1N%5E,^2))Q>=(R9%/[!J/X\L9,V;KAPBTMLT,RV:`,/L*JP%C25!#
'O.$_)=3&9IMAVE:%@MD`1!!"!#5+UO1HT+GS0,_SJIYS&L>HT8@[`NC=O.#($9^O(XM,^=M+QU:V<`T:5-[DNL.$NJQ/Q@*^;Q`D!XBC`@'>;4SSIQ+^@C;H>Y;W//.8.RI!#
[V<Q\<;B*`_#)!`.)6)AYQ!!"PR"@^M<?0X+KT0\PP*,"P8E:=`_1IR2WIJD5!ND7`(5MH?A6-KFU48H)[(P!U8'<R6*\F$EY=.`OBUVW5C\'9KO%H<_V1W$9B8MRC??+<-%!#
[7G9D48W_@$IAFID)/MS8!!!"AB?GSP"GEB\E-'K)M4P13PCQM8"7=Z$BY(C]]G(4NJ[\7WVW(:6S(R=O'UFMQ&21'TYP[O:9JPD#M94_,'I27F5'AA=V.5IPH0HJ@4UX!K5!#
`BAU1&.KUR9^LL?<[R1G&!!!")J:'V#\%B<#:^A45PIU,TBK![<Q#?Q1:L@?(>U5?O)9D^@5%'#@ZC&-Y85@B.:24O,YDM(^EJG@F=`&C!4_;SEN_=&5]N`DN93%7I23B-!T9IAB7-^C\D@-(]`ZFRVL?CW8,7B_L^DP:S4=\R'IC,)[FH>\Q'Q'`Q'&7RB)MRUKR?)^F(OE./5`1O2*5_^YD@A5";@;@=^C\;+)J5GN2.95KJ?D&=`.%QK6MUE>`R.I!#
RS\'8:2@$WQ^92',&=+C1!!!"*LRR3L7-HEHWL*?W7THV.)&;9D?\YG:OKG+%%06;S$#V0C2I)L:20XUX)3B\@,#5TIGC19MO*Q/PQ&7]B?2!,\1H8Y0_H7M\%Q"XRX>(IFM!#
B!&%_P>X0DW3A*DJ\(GK#A!!"7YJC*]QJ7ZMHV^O@JWM[B5EAW)J92[=D%"HT[4ZJC`#'NE\&VLEC5812'+EN(NX(5K@%/I((HHV*.??RP^<7W>,$9#)B]OO#1Z8C2/S`>89!#
,X6R*;IU;Y#=JU'8"N)6.!!!"[3S*&.-)Q1G2/(&;^D/K9B9QD37Q6\'*Z6I>S$L0TVLYE&S?_#0K."5];D_@IX2^S!-&Y20+ZYGY6+F@VUZE4-N9>93,,Y;>C?C(H3H#N\Q!#
RE.'<ZU>S7[Z+YPS@XC(!Q!!""X:N^W1\LKQ=I](*[+R;7_NJ>3-)+8O9?OYX7'6PCUI39ZB%)3N!X(WA$OJ5K8<EVO^=0=>XN^[8\?C!]@C)R;_]BI@[)8QGLKL_ZJ4YIDQ!#
Y",;TSP;$QM$$+-)4+V4<A!!"D4?#13D(![W7!Q9%MW.DL8/Z;I"5Y)"E>KZX;\"`(O)GCO=-.C)K1?:_H'ZJ))'0<WA28FG+5KB1^E,O*D[-&FX759VYN//6>"G]'K]PZ]U!#
-`)5C'"5GL72&6?ZBJ0]E1!!"^S!#=N,X3MY385RR)7)D1R$8>`X?2Y#;AU"ZGH7+5GN_H)#1.D^8/<4:%K_<'!);TTMFKQF='Z#GI2"'+/--XBV[Y9WV--X\EJZ\HHH!]$I!#
'SI52`#Y^5!3J$`#Y#\9I1!!"##EYTY^@Q!K!MQJ$A6MA]X0)Y=+76&C\"RQX#?*FI%<M=%TKO>_\O"5;J%$==E3_:FW\.*CU`M=%V!TBG%:X&SLMEPUF/.=1=7NS,9RZZ!U!#
W;9"P"(6_@IC=[!-,V931Q!!"UOZZ>BNH^]KD<8`=);8\JQU$*`6)=1A+ACAG(BQ;<2^"QGC_^B&S$Y=:?O(MN7-)ZDP/[BQC3RJ\F2(0[O@L-1H9IX5OFH`EII0<>&]F'1=!#
>NTJUPNNZ"V;+-^VY[S3MQ!!"2$<MDF))]O3!*:?LYX,92:_IN#HN5<EAN6+?7P&U_Z:"0^ML9@3,$4`I*M/OO/&+K:QJ)G"2>-*4R%DD0WF[EU-#^4WX#_/_($XKNZ:?,:Y!#
>>?QVP^7D^L\.#3]S:=%:1!!"]8@YS?A_B8@Q/!F@+FL<.?/&9T%<M`LH^<E8M$&4"+;A'=5@>_R1;09YD.ZDVE/#Y=Z[8=UXS]\YA*!I?5(DA>?=4R428RVG*N7K1&7&:QU!#
$75ZNUQ?72+\JV]E1^W0)Q!!"#\FA[FO=ZQ^ID[P<`H72'ZY<)X%$)3.9"!#3\:MEH?4]83(2\NNEF29J.UJ;A.0#?TVO5"K>;I*QEJ5MO0"WV`2,#HT$SI'J!3.#)A]4M_!!#
F5+%%5P^#H"2U;<_%A+'(1!!"'P[B[40[1)&J`K)PG\.:_O'C(9E[GHLV<W"(DJ:%.P&8A^M^@(+RC`Z!H?Y2B$,YC4VR.,K1$<]68R8Q2NZL94S-@%A5[T->(H-1$:[T:WY!#
I`L@-#>Z-R5ND*>(CCP>B!!!"WYUQ=41<O))1W^E2LER6#AC:WGV5A,I2\)0_WKQ=P`<\-W>S\08R(]M8C]414:#?Y\D[@US4RR?D1I_DD?A!(,\/2G`SQ$FQOLJ73&S!+TQ!#
DYB>^?;P,:$8`ZV6,@=<QA!!"FBYLR>:[&;6NUDIOC1>(S04TM:S='1E-#&YK(3QD=Q[%R^V6ZAE<ETQ&H/>WI(J'^<E'[/Z*+WCJ$"A=*>9Z[\B\TOI:;)O]%@LF,6>_/<5!#
=7O:U`D*V.VI:C'7EW)*,1!!"DW?WO=\V#A*VXILC+J"M3,LLBY#KA5#'./M!@8+D!4I@J3?Y\S4ZU#T&L'.Z%E,X2DN[_M?H?R\;OWF8CJ^#[/"^6FXE2Z]%(\R/</J]\[!!#
#,>LS(6G_-+8A.1;WP>#FQ!!"7P3]NS5TA)6Z_(TW<H<@(CC14_)50_-50O,U$.5[[;AOQ1:`Z/XIP/@5/NI!H,X9%3RHTETMUS9BS2F'??9`CVZ.=W\"K,-VO>RU6@<RY-I!#
&1/)BX]9O*K,_+[*WB_D"A!!"TF)+76K3>,R$^%9LXG#,$D[8:I%C,T=.^>D0M!]+TWH4LNK.@OPO+6S`^98Q<HLY!M-SF9&$.+R6P1,&YW\&$@^5)`6)6\!)2_VV:.X$SUA!#
6&35G.H+`-R5O`G<#0N%P1!!"?R0HL\SBE='6:Z*]+6R?;7F<HRG/1Y#_[2_BSE5F,(Y38[Z:B."9`^--UA,A:M7Z>*/N2[C]QKP.G;V(/H&3VYNSX=K-)-NC.(<D'SJ+#P5!#
GYHI'D>IZ%D)=934HTZ311!!"D]W*K!XIIN/HH1K,W6.!C1!!"
'Z@ZW&I;?T#&WYT`VXV!K!!!"Q&P12$*=CLBH;Q>N/YUEI#M\"S`E4XZ9?CG[V,YI_MM`?/;#)BX7)DXBD9VPH/(G)!UP/\RJ_2`E0R6D/W4?/Q!!"
PEL(X7PO<I1R\@M$&>L4(1!!"F$U70_9!*@B,?@V6@R]H/M:4&DL%E#GR?SO'JZ"U@6>B!@S^Q1@413""H#K7&L7@3`?CU[R-__AA5&(P`F-AP+6^ST!'JKV_$,F&OK"PW$`"[L^@BHSV>&FP\<1$"=[C!
9@(*S<L?;K)5O1@7IZ@;)1!!",%M<&5E`M_N%*:"RA\+KFJ4VS]Z%\#D@4,-6AIDDZLI\N[G,PVO&9D@@&X!2%6T[VR=!5GMDYC.NT<WV%@7!H:IWZVF4?YGH_8DOOJ-%3M)!#
B7,>.Y#`-]!0Z88-4E\+#A!!"X5)Z.,XB^`01]!,G?VB\*)W+"HH)ZUG-H)484`E@<E_[WCW8S667VKY\X@KR%37-E.'[(KA`RN4/L9U7#EH2^M*633B);AY'#FP\T0'/8&!!#
^\K,AP!S%7)'8.F"/52U#1!!"W*Z1CFX;5(/?B2/7KY`K=G`Q.GF2LK$;:/B:*W3B?(^.A&FXU`:17N0_(&J&[#Z:##1'2)#*=JKR,Z$)[(KX^4[*KPB-B`Z*^71`0?X\LB5!#
[(]UWGY"\C+@DUO2\H":'A!!"/I9TL`Y/W?\F9DYC1",KS'%8'I\,ZM?-4^UH1?S_[;AGC"@.6%6N7.@$YH9\IM=B"`)X*U']0+6N!Q:V^ML,GKL/I[/^T60#T>#]VJ]TWDY!#
W,\GGI+:_BR/V6I@>S$Z9!!!"10*<;#@/"$3.G24EZ\'L`:6QBW.0:K!.D`U0(@6?ERDX&=TC*4SWF"R>?]22'K.J/.&;/^7S%35%Z]QEI\-Z%5&93TC'"/")8R'0HMB&T`M!#
L?!F-[@A;1K0>5K&K"BLHQ!!"T4#2+WS`HQ8O`^ODT`4A-P;CU@V(65J^?]L+>`,($]+[E;A7@X88<9..;#D&(>A;74VCI7,.4EKE`/Z!U"G>YF1MI=X]]$W6\L]NQU=N(1A!#
P667R0LVF^$))0]^[R#Z%1!!"H'DN9%_$)RJZCY)8?/J+638%R<>D60%WE/AB\Y(V^W47W7)[)S>DJ'/[AJ%`FI(H"L]/^H<Q1CMF2K'<VHV[Y"U(PJLFR8^R!`7<EI"2=PM!#
]R"-F<OBZ@U2`,8XF^^5;1!!"S4"^=__<TRWQ_B&U%V'&_,=,&A_]U"1G&MA[)ASR=0Q<3V]-*OJ<$^A&(E>]W74"-OL8I-$T-IT'=^3]T_@61%(,6CCJXPX,+LECF-,.`3I!#
U=8QW9R7+,</7*EI2K+9CA!!"*D@EKN/5';T;:H[4F(@-P"<?P`]$__*P!<`W)Y\?#X@"GU'=&M8WT/Z"GT'O";)YBGA+0R-Z:0,\$MJ].X+RN0:$)_E1<OY='UA=1\.`2AI!#
)#%1X:_>&CTN$V,E8B.?8Q!!"@BG[O=MO35E'*C=T!QRQ4X\.2;8Q$`6L\)R`0.<T3<^>6XIDK-D`!,C'HN0TB?H9O)4E6TZ'-:\5,:L4#'KZ?.BZ!2EPG8]S"+/FD)T)8D%!#
/M)[:&B:+J-`3@`Q>OYG=1!!"5S29,^D:?\KY&[:*J-G59S5KWZ;X5JC3[86OY`4;[4"K=TLQ:B52=8_:_8F;%IULG-8#4-25(*LZFMGE.OBC-R6'LT$"=+70C3]2R=!D[:E!#
E."ZNV$VUY<S)XN@*,0E6!!!"3E73R#^^6DQ4%KFANNNAY&V\YKJ<!B'#U6U[-T45@[*Y#9%EI>8_<%I6-QJBX^=X$)>P4J6?C;"HPY3+:&C/N[_[))J]4^_,FA"-[7^ZWGY!#
:U,^Y5#F'VQ73\>0*!$Q]!!!""[<=&A9O6@"EC'['T$_))HTUX\L;J&\#0:5!*#P0^+;?=/+HVO*LR\%,[M1P`$D@,DKO%/%\<[`C364DMUS"''I=)1PLR+K%U6_?'G6&BN_RC[L&0^8[G^PPQ9?[(Q)6!.^D;@3^9F&JB:<FCU8-^\+K/KLL6*$2H&_C5;W9>G(A.;9WI3D*RZ&FXKB?J9)1%5/`X=?[])Z\GA'=N:_A*VZ.O['*(EPS-_:1+$J9K.9!#
A?Y8C%<W".N/2D:!OC3EJA!!"P#5=Y7DCF!]-9CD`(:1^J1"D)-Y!S5)9WD_!Q^;:*"!8I(CBXYY%&X:$#QHQL>1^F[4\HR4KL,-66@B64:UG;&;RITPU_XI[:TO'A?->QM5^-]XCJV3D)&QT/Y3Q-K"^!
5<M?J9DG#PNX,F3#S-R7^A!!"_<'%F9=^6_T>!3E$)W\:]-N)#MZ,]W(QJKM5,,H=,,=(DV?PPN4AFI"6Y.3PZ'OY_./#T#MUT7LG><:-1+[`#BVC-GD<XGI*4("S0_&[L!9!#
S@^H17B-2*/BPB,.MY?K2!!!"%XRPJPM/J[.<M"OP/;<7DM*:3'91^Q<%YU"[5V.0H6;68I.5,?!`;#:>Y(;U9DT3MU]"OEV[_E>#OCAM^S;F*!)6-]5FA*!HA-PXIW+&,I]!#
-DK3/G9#26HC&J`K8/K!6Q!!",7*P+/Q['6;H?#/EZ_;#/BCHR%>M`JGW6``WI;JVK'FA5CJ:_Z-50"G0AC$8%5Q0%HCG$BZZ;UVR/!BY*V_.>4#%S4L+6/=3+K$+8)QPH!]!#
.;2Y>Z)NAEFO/*5#WSIL7Q!!"#)<30=0IL5I.M8/#4\H$$-<S50W7+F4/^D26O8\/5..6EWOX_KZZP<,GCFA:T4)]3TG@6%((HL%@NG_NMI\=OM$3P`R0M`&$6#$.!10G32%!#
D7#!W5$.Q+C!VMZ>.=?JSQ!!"F]ZYXJ(J'4X?E1E*V8#Q/D'+ATW#RH-=.9!$H6<!5%I[IQF-+C>D2CQ##[:(+$\4'J3:`#2DE['&N.FE/3]I5Z<4WVS@,\\UWV!OA&9W\89!#
4*9/$7P\^L'3#]@*LK%\+!!!"CXAN(:NJ?O%57AG.U;\A1:U.ICT=XO%TQ_]K"3X2TV5G7$"K!B0H]Y<91RC?@@:3J#6H;@M5<ORIF+,Y!G[$=CLOUN=3\T8I2D*BB(YGS%Y!#
7(OE;N(KIGC^_8HMB38PBA!!"-RZ[6F67[T@EY'\+XP7"SPN&G+>GXN_&GW;6FZ*Y+[E?(!ZQ-&4"&FY@"7;L$;L];2,Y'_G0RUK"-CD;;NP.5%YWEQ^O&LE![GZ#:7D^9&M!#
INLF!)^$Z=@.S5;7.6]+UA!!"PW"G,I)53F,7H,K#+';R/7[?U@`GI*(YI?8+%V7]OY*]8ES/%%")A1M!?&.M#%GP/T'(JW([MJ\1G+&VL:G@G,#$9X/@9,`30.JD%''PI=1!#
R!+#RC[60`P^`Z]<,Z`O!Q!!"P@=U)Q7BFFN%H)8&\Y49BB0\-^AZK/NV.Y'&:@0'-03.(BF&F(",EF`EUY]Q#JTRM;`$4_<43&F-O3#E3F)K9B`&H9#N$EC_$`$4J,_ON/=!#
C'JV+/:K;9J153WXS&X^6!!!"3HC9;QCU*]3><A@,;LP^W[[.859J3VU!35B2V68Q;=E25#=$CU2\,!8(\,"^?JD>O&&:<VK='D&J'!4!Q3_$D41"O5X"&UKXPH"&%C;/PWA!#
_299&-$2"A_Q,'1:2QMZDA!!"Z<,PCOI,"/%$Z_WV3[I&4JO@]*TS*FRGX!!?42#@!Z)4YEIQ$B,I\<["0N?U6J?FIIX^[AH$#CR2'M@[Y/*U9!A9YO6#;DF$*+@4UF$XQG5!#
_U%TJIX6D1C7M!:X5H'N^!!!"JR<:0JR6,Q^MQ'HDJ>LN7-SW`3*]?%Q(QF=QT"1D3--I"US(]*\W[--T8*6Y;V8I(X=B&=4)Y`"]9CDV,S$)8^;.Y$@9BGCH+D81<R\YIX]!#
:NY]'TY_R,LX31"X4;V2&!!!"57?_J$E4S'^&>VKT/QM!/^\"R&M)`@5_SW')%19$B6DF4/TPTL>,WCYBJ')G(%/&G)_O@,10O'E24,XV:,?QG5=)GNAVBMC$Q[!+'JZX6XE!#
?!E?'V)A[''H]<B&RW`M.Q!!"7(?W(A`:+-8).>\=&T[)*%M:!'0,W0>/*ILH%P'GRULRD0*$0.QG5^[>-R;M`VC&+@6A/%C4M66G!2Q;?Z'6GGI/RN!I4IW6]-%Y$$>!ITQ!#
N"S;U`;7(9G4+*J1=4^V2A!!"E`A],2%:W-H*D\KXVID:S)KNQ``"MJVDB`G\!)H"`O=9'X#'BQR"`E7#+T%)X,\XPYFGM5Z<<`L7XGMNKW&I].X$_S%7QGK1^A'<+IG@ZP1!#
P]-9A27;B-)59^\/XFZC]Q!!"_SL*/Q"&%W\QV[VT!CGV0)`<%GIZOS@_D$`LS$FH1VHSI?8;Y&MJ+=3HOCT+MP;>9R3V8;T(2M,8F>9.Z&B=PUA7I+.0+>R$>O8&P-S(,Y)!#
5S&<SQJ:>7_O==_["XRW$1!!":C:W$`?-3.YA@YJ&(,A[DQJ`(JL^"GZ/>?V],]&BJS'CC5G#H66FO*/%&86N;N!!!':PFM=$F?D1"KJPQ\K:22!_<B1HM%_2"U<L4E``LA!!#
*:AZ!S!@U-<&'K[PY2-GZQ!!"_<PN':6\E3\$P&#<`%<:8Q!!"
1CER1<U_-`3\]8?U[+ZV+1!!":AL<*W]2X%:.70$%"&/Y!H<=G<7G'D#.I'I/<=S14K$B]BHPCN$YU$!T9IE9[CK@MEMCOWE(-KSPO9^RH'W_Q1!!"
^$]YQDJ2*M4`V#0U+:KAV!!!"&2&QKGFP*0"&DV<?ZW"F-Z#M*'$??$(SFP'EIF@6<ZUX#6@,/6U;8*XJ'\8420$3$H";GK'EVK%8M!^S;N;XH1!!"
%4@#[?]VX)9GH-R(*O2S`!!!"^8YXH[5)`Y,M'&B0BBL7GYA5SZ>P[&VSI'S*G.I=6&JU4%[/!1^7^F9,7EX$$PJWZO%Y-V!#%M"L>21.D!K/FQ!!"
C7I5<:'/`9!!;]%LO/"KZA!!"U9K)C"84>$E8@%@%>)M.[Y*%$YSAU]?`(X6M1E3#6$*ZK'A2:N-J*[G"3:+M[Y7V4IA3X_H52CYLL8TJW=1=(A!!"
.]X.GV@V=8BQ"Q75;C+TGQ!!"(B@%?`W?(S1B?,W>%?D,YATW>T=NWH]6JD1)WS:^HXT"0[VL!VQU<*B>>(U=_QOI739RFOP,5\B9#1?<\Y)4SA!!"
?4=?HW,=K$8>(5Q.@@)\E1!!"R83[(G(3]2HBI>G<WJ6\<A#K!8I)O$3\4F=;IIRYT"#A_`0FPH0`E*7)GZ$[XV(Z[E?Q)-SI>CP&T.JTZK=QZ1!!"
ZM^VFFW25BN&*B>[I]E*S1!!":%5_S(&&R47#,+<)[/\JIJ<P,_7DK7`=Y/VK",>T7TJIEKA.5![M?\4KSD<"2W-\!
5,T.?#I.[R\@I(>M8G=#R!!!"KVJ-]`?^_H**9LHUK31=P);2.?=G5.<1U$54U,?MOQFIX.*--C!.VAV/XI.4W]<7AT[N(:Y%AJC5\<=S<WL@;1!!"
?XZ)1>*[V("-1'M,0SVO51!!"AEDYIHB%Z?R^7?:DZ.?L=:[TGS*Z^+W4#*X1/D_UC-7R%4`#8".=CC6,GA"DW1;.3J-=H#J<IJ@:7N-<#0G9>A!!"
/7_*KL\STC'%(A+<QAN!BQ!!"$@IJ].P8O&&\,[.;V9(\6.I\3ZR=X:\HK[53XD=QS.V;E&"L?JODGXMAN25G$Y(&7>(A__8CF40Z.].Y@`.(!!!!"
(<\RTBL:CF,89I^#)MF:[A!!"I1&:N@2MYJ#I&U\O!,TPZEU%I^"/R!0;Z"CFD&2N![VLE3$K]A9>RP_HH!@N:SME')WV\2Q76B4F(2:+3<_&&1!!"
^WS=XN"<0TJ^4Q^!6;I</1!!"0<*\NZ0?Q%F'4_*\;8/5X0J2A<DL&]XX!*3V1`[U:8M3#93:HXZVM70)6:U_C#ZOAIOL63NWSXV&E6?1MF(-"!!!"
4R3%Y'!FH/ZOS"1X;#1(51!!",'ZR2U5L5$_.E=R'VQ%*8A"&EO:Z+8%TW$%3XBG6//NVX'6PED2+EC.BI.FPX58G#)+'QI-$=4K9>Q:N[>$KA!!!"
)MFELU7H8L,%;`"-$>N`=1!!"90B7%HQW9\KAQI1%LK>[I$GB+S"K7B%\VRPIF5UT&6P-#EM8MSZL;Q$_3=4Y_Z!-!
831E_27?QRCNI&QX^:+W'!!!"==8[XRV']?<)N/I>W/"S^R$?"CQ_-(^/ZK7E$JK!GRB$-'.QINQGY#Y#9DD2G'?5.$<1<=O75[E*=E%(SN3`ZQ!!"
BV>5EF^R8NWH'[5YOJ#Q%!!!"LS0A;-*QCO:^Q4[]$4OS'_#:NFVH)&@SPV9X\R1IP]A:\*-+V.J-^0#"W7<T[M[T[M!"=@\@0(48!#/AI:LP'1!!"
(0K>@8?1=/Y7.0%S+^=$NA!!"60OV8M+9UOS:\O;K(JV8)YV-NB9?_$RV'('G)W#\-!N9V*NDE!74!LIDHN=C$$->;'/Y609``YQ%`FI]UA+@U1!!"
+]*!5^::N)#._TO%=>9TFA!!"9X;RA#X*L.:`F5AVIPB00R)Q->>3[4><+X[O0(+SRTASMG82Q4D72-TPP^XAP1*5"V1\.+L&ZM=_[GO&'2$;-1!!"
@/_%6/P01\87.)^QBO2SX!!!")*R6FY0T9Q-3;T0Q9]J2.:%8HYJ9V$"?CC(A4^C]8U8A3R',__6B1&S@M[U#S'GS_:=0+X,6R!>&/L:W%R&G9!!!"
?#"E+U*QMY*T?<$3OF;+>1!!"X&Q@,XPR/E'!"R:/K9"G.V"CT"]\JK22;4=D5MI5-_BFV'I,8\OJZ^6T7-4WU;P:R)9,P$8R5#R(B%IEXU,A#Q!!"
PZ)UA22#-^/>4_50=`QHDQ!!"\0;_FLW08"*]J[LF6#\PHAD,KDK)-@CXN=GL_O.),,S7.7*5:S@U+&=A(8%"E@$3!
IU^/2:&*+1KC*DRX/RW%#Q!!"5V_SPO=@)4,1>$#JDNLV!):IA5J9IP#$5*F7]=C]6R<R.$"4XQ^&IP*<1)P#3^TCT[P.L:<Y<+%596SQ0#22(!!!"
7LM4ZVENLWVSQ/MM)[L5GA!!")NIY(::/.*RQIYQLSN[#2M2612JCG5MK.H,D,7O02$Q*)GF($2)^30`;X,!52U6(VU*AD#,\I(4CXP+Z@Q)VUA!!"
,X'O1;'YY'-#!Z[@4YG.OQ!!";S_+7?-.\=#J;1=LP\/$2Y?4MYS2(3?)`#ZLF`37MX]SCLC=_XMEUHQT3SH+IY&Q/-\,X&9=/T:3ZN4F*91N`!!!"
:=L&T+"234$B[CS_+,A`0A!!"&I8NXV*=L\Y0YYI3E8!^.[&%=</RNHK[*L0#$Y3EUWQE`12?0W\@T2#G[2J]$W[@RZT\,#Z7/'7(`&QNJU55$1!!"
;ZV<#$*=NF<__OK"#EY7-!!!"<M3!U=#&6R418I_Y:Q>Y%3QFL+X@<G2G?<HMKJ*K6,?8O)P87S%RV7>`109+O=YORYQ!P*6_%.;RNLCS2W\'+!!!"
F%VIZD5B-Z+#2.H@82.%>Q!!"[X09^M'@B?+0&7VL-1_RK?O9(YON!%S/+@(5Q'-&B\R]6`NRN512F.$AH82]P81U$0S7JUPHI29T\:$"ME?'JQ!!"
$&97"HF'VXLQ9G/T#44K!A!!"1>W7"J#9N(E9@%Z;^3$&9$K@OC+[U?<GGM4_T_>@PES'GKGYF]XU=@@)O(;U]/Z7!
P?<`L"_);U[+I13RLJX!,1!!"X[9EY-)V2A`\#W.\\)1I&&6#=9.[P45>)D@=H\;%A_,J4V5;6ZK69,=1ZVZ@89BV:Z'$FC(,IJ;-%8^E&9\F/Q!!"
VV4X\>;_IX8^F.A_2/+F'!!!"C"906.DE'];Q\A$RI8A1-?PU#ES&56(T-$9JCGOJ>'W;F;6J:TD[#%?DF'E%]X\_&]W?FR#Q)9/;.G93QAMU81!!"
_/**Z<VY*JQV(=^>?7%YL1!!"?7;17ES]\`W#6DII=P81P2+32PWK0.A,$"^5RN$2"1W[!W.2XL21C@QU"F'F:^-$*!ZP"T4]+KU[N;=`:-1H6Q!!"
"%&A<ZLMB:BI-4T<B/V5AQ!!"MO-1=G$(^B/9LRW3N67UWX\A@;4SDB%9$BK+7R47!-V,&0/Q7_/RN67&_^>-(!.A'XA)4@ZB*C&YJKLY5^2[H1!!"
H@M:.VO\RN"Y&(<S/-PIX1!!"!X2A%.,U:Y"J7(UU@4RFG1=RR=:JGT-U#_YHN]-02TF*),V/!81N]8DZ/^W]$?=B9!69@L`,S%H7,+,;(?4#]!!!"
WBGI3O-22F]!QG[-]OR"VA!!"'NE!ACM(,7ZLE?[BDS4^^(AUX?ZDP?SN(<[H!\\8EP^.KVY8L&'/6W(S'X6)/]K?^P)LJ:!6^\(S</QQL%P1*Q!!"
^PO<PRJL<V/VV&(I31(7(!!!"(%!GNXHXDTW<-7\PSS=RWUK`6&N=_8O@+/V.1,9)'7Y8(KB2J:)'ZO*F/2DKF^CC!
[-^.^D1+\ABQ'X-L^[4=8Q!!"C1?$XFB%]E^'XRJMM^%$$P"(BQK8U<DOLX4^3!19L\\BM-"2XZ."Y[/]H9L$PJ9+F>OE4/ZC`./UNAQ*@-.ODA!!"
P)Z"_[W71PMK(Z<L4BS;9A!!"<XZ`4#$X#JMT/P?M!4/MJ(;TK+0,&P!,;MN=->-4:/9R\]8K@$'.SJ9NEV+5,0HI1!NS%56[L[FAQ=;::DPJ0A!!"
C<$Q;-R:'`0JD6ZF"8^Z?A!!"'5<();ZYBC,3F>AY8F-<+_F4J^1KA[YWLI^,4)*AY9-K08`+R*F]%+P>0.TORY@NEL^1OQ[,.I)U8E]\^<@H\1!!"
96OR8Y*(:PLI;^CTQ`MI%Q!!"XK]1].3W0_I#V/'5LJ2+H2A.ZC0W8CZ#)2(?AW*#4+%D\*"WS_%@6]DD[@!1F_3<RL1]BD/O08HX:Y^3Y\::UA!!"
9S.8.J\`'LLYR24#/Q`Z$1!!"8KS0`%TM0:"AAA)WHBT2#,,8QAETHZ1EB6"2/4_21-KI/8DGOJO:X(H+"D@W#*R4]OF&+TTU(F&GKW(N@(MV7A!!"
D"C17(VK)"EV\8]!^BO=]1!!"Z/E&(PO:E4:<-[F/XOL&^$FERH-^6.&186<Y5ETX/-6>[IXF3&F<-`MUDY]^"^(L[M#IF<VBF):GJV4"!(%$N1!!"
L_+L2G_3+F^BTD-RLCE3I!!!"825.0Z,A!&_OE;11\0&M$J;=H!HD==[KG'S0U(24[U[6I1?H0L3277T^E=_]N7)+!
<.(80.CP>"%KD4H^.I'!*!!!"!-6I]E2[>"M>\47H5EV;`@Q`/?\]D2;+D?XDFBL'=6YA>]`?7HYJ4E&09@5$75U9]Y^0(C/=/9+HN]4R[#I/6!!!"
MTR\8JZ9-JMNH'@1C*&A-1!!"LC=:O5_M'D=E!DT6DM,[FI&I_.)N:,KQ=;MW:B]H2-72RK6[84$*T6"6[ECZHHQ)"]&$MICP#[<O?N0>%0S4ZQ!!"
VT+.-,V2BR4\_F(,Z6H;^!!!"/5QHE3KO>L<2<,,%`#?+_G3I86S)ROHA':AMM9KXSE([20561@B-!@#6]+YSA5"'#XH3I6D:=TM3C@^7IG`1-A!!"
?)E/CB-CVFE"U3_8A>``"A!!"=H,0IB7="K"X)A.L*L5GW^LUJ;^XGP)@0">PT44J(J7$/J?DTCD0XXLHF@"V-)Q+XEP_6=#=&I:H0;,!;US_T1!!"
'W\+XJ$M/+@#1YE#^%:!]1!!"<B_+`"\"\E@J`PW_!?WXQ8`_EX[99G*V7Z8R),W9S/#L[(!4YU28V!?A4=.2-MG,P(^/$_\Q#D2)5?+)!^G_`1!!"
F>/U=2/O#!7Y/.C=083XX!!!"Q1SG-]OV:YG<RU9I;@B1QOBON"U;>!DOF:'($T7%RA#S;>D>\^,MYUA'?MBU"#9`;.@9_JJ*_AG%'\SPS1[4@A!!"
>T'/5]`<3.D-;D7%)?%/FQ!!"+\-_"@Q]5J4X\OO@&(/>+GG+8846_M*&5U4U*>.ZGXN/*OC2$TM8H2:111S$(DR%!
O'2?.6Z*K(#3E.-&S"9I0A!!"GJ[G%4;*[(-F@A7!:5A#N+/$TQ)`.'!HG)BN;R'&.D5J<L/4[R'@K5`DVJL'60WAR^`4#O4450C-\E>O6:RO_A!!"
-#UU@IU.AX)(/&4]EY!=3Q!!"`QZI8-,LF$4=T5BM%*7$V;3P:]RS?MZSW7GMW[%L=#7:U.^.C#_)S"_2>W2'',R%0=->#HFTJSKPCLBLE_>\IA!!"
R&\>7Z72^UWLKU51QNC_61!!",'0<Y7D%]7>YK)U!`>XJ2KS<U)(PW^S=X*<_Y5G[.824F9&6JAA#K#7)N.E:-7YJCPYA&T-L"7I@]N=>8W$%IQ!!"
"I[Y69V-.?V">_?(S`-OT1!!"A\O3JY\G(3(U[^9S%2RN";)Y!D(*^S))4:!BW[['X.PF<.@&'YHF[-+7UNB=A@`X=^<3%#!A'A=>)U*`-:*!+1!!"
B3/1_AE'5\K<M2%N_O:U_1!!"`6W\Q;L;0RD(4@*WSDOH.73Z)R=HGI[$0LHL_N7CVW=Y^$`(ZDK9+Q`1+85_!#8<*Z%A%$,F(UZUK8`KN:M`)1!!"
W"N@D!7;TO=%N.7/12MYC!!!">EA00,B\W+(1Z4@62:QNOZI^=L@T[)A3\?'UCHMOO_2&]4^HG8\@PO%F,B5T)#7>ZM9E.-M4\-@%8B"%C4&V9Q!!"
-RR9SV'[C#R.V>[R-%%LS!!!"CUK@&&(SNG@;SD;YY=,"RT+ND/[X0#VI@0OSRI9Z/=>XU>T__\W<VEPW1,KA@4]_!
;UU83&;(OOLE<C<X?M5,'1!!"SAAN'BO:"%^"DTEXH_63+P;,L3O`'K"Q9<K3[&G\A:@8C99W-_?EX:N/2J,%O5:G?$4,<R$3I7\\OD<:KV*4#Q!!"
Z'!_G[R:W$G/<CF0P6RXGQ!!"<]`ZT1H!RJ:I,9#'=(`X1N&@[JEJL%%#&OX_2,6.B!D<!<YFV)!MR!!2]L#C:EDICLKGC2B[?D;0)K7WF&#M/A!!"
@2COG;S:^AR3IEN=!%PSD1!!"BD?I\$>9)"\8RA1Y_W&NX`A?/9K'1W6K%KB^S'QWBJ=0NX@U3V(]8;"*K*&@1(,=@F"1^;N4UPVK\TCQ@@8;0!!!"
Q%5\1H`,HO_"U`1+L6_*)Q!!"=RKY@FA?B6*[(V",V'&#WZ_&,I#N!NU/WS1FXM+1X&$X`@@SD*'BP7`@KG_W<R\E@E)K9HG7LI5O3"D<`OH]Y1!!"
E;5QMO^06(F5>C9/1/G<L1!!"A%$NCD6HBM5N[[16^UR+%`)$C;5*?YR]/-.$.\Z-F;'X8KTA1"9>#FRA8--Y38S!/"SHC)I2%6&JK#"H908E8A!!"
A.D%(0&L^TA]OMC=BYDGSA!!"ED^?RC^6Z-NT]TAIM);<E3;CI79I":1^W@E/C56M*-5C*"]_Q,R0(U-J?9K3]C6P7\[[/<L!VJT0GUSZRIM941!!"
UN&[CP:<;X$H_WE@D&^KAA!!"/Z'>,83AO_0+H."_UF%]#'X.DS#3./'KWB\=C4E+FL`2GO;=!@H\AAD5<NU5T%]P!
3_:UOE)F">]GF:.+;WSEHA!!"DD^*M^8@)4+.&7(<)%L)<(0254[6_/W5SGIP;0%+$JD`/@IRGB3FC>'YHC6@'?/*9#;OBYWSU^60N#IJ$%;:?1!!"
@IU$]37QQN5!#@?I@/Q&-Q!!"C.PI88IY3D"XAIE-,%"U?PH*O\H.OG,P\PHYE7'&*@O=G1U,[L_0>@5PX)2!R1<13)TAI;T&];_--L()@?<B_!!!"
2@&P.\+$`\U.6T@HYYL=PQ!!"BG+FS`J5V!OAGT=BA()6_&RDSFG=#\!71C^]B^T;83[`:X[(886Z6**[O&9@TZ),:I6"//`!/9MU`!P2'<7(AQ!!"
7HOE^<L:K5'>YFP'_453-1!!"CI_71O1+'-\,MQ,DI_Y"$XS5#*70\OMHQIQHCX(\'S'2,^$/JVV^O&?JYJ;?'C96&#I(M7/$)(;2LC1N3%Z<8!!!"
=T=-U?5HAE@O24IWGJRQ+!!!"D?]O=,C;J5%<`8,<M1@3#OD1V""]2+V>!2]%CUG.]QPE]_T&_)O;ZGIA;3G9DV0'2F.!EN#)*C<X-6!9.KTQ=Q!!"
.\70Q9OKF&:$YJ)&E4\H@Q!!"=QBRA-JB*<7Y;*_A;<N@GS084$R`%W`%UN3J!58*:1MQ;C:+F=>VARRN&[(:ZG4S=>2JB`"4D\DR#XA3]"TOTA!!"
@EAK>8"X`/6$V&89H'0_1Q!!"R(EN>Q"01'I'OOW&@FU7@4?[=_@!-./JN"B'EJ*!6=G4(NZC:`O9=G_R_A'6T%`?!
+`R^139O8TE4+T<XG+?]"1!!"+RU/BQ5N6:<4A^B(,3D8E/WLHR82,=2I2WC8ZDSL44<]Q-#!?\.WA-4/!128AF.A/=I;">.=/E@Z*NN$WM>QM1!!"
!$0%1F5K[FJVH.+@.QWN0!!!"\*N0W!,1O#NZ7:AZ;X?ZLJ&5K9]2#D*3@?3)%DFC`N[#D*S'_?H,GT5Z'WJI5`GE)?RBBSAHI70<\9?L$8S@?A!!"
<IEN$1#%9=.HX3.<)7)6QQ!!"[("+4VE/E::(9807[^K_K1H37Z$-S(P2SCU<S7`JY:33M_SLV\L=>Y`"9'F"-UK'1]3M6!K^!W)$^+TGH&\@"A!!"
1AFA#SK_P3..]J*'WBO?#1!!"CW(7VSB_(',79RA9;A>;Q6#^\P3\I\J&PT]PLK_1+:-+.HXZ"%/]<;<5"R=0EI'$G%"&$GF8XIEW(I&AZ#0MVQ!!"
5X=VE;QLFCO!@]<'RLY!MQ!!"K/8Y/S'D("6J8J+SP!`M680Z*CK:9VCPT0]KW"<JHD[54DM#5DKXOFQ8-JK1B_943_9EXK);@,T+M`@#%VL?;A!!"
5#)V=<-_(#PXRMDLJL@6E1!!"+-A7:TS9UA5S2_S48'QKY+Q2P+`I"`92VP5(QK0:_`_9:'3$7<Z8PLT2N61S>(+J?2;:!^]VL'8G:&7MP%39@A!!"
"TFCW@2Y[25D1_=]Z&U]X1!!"29F:%C=%.`U*LBD-6M9:DA"9[$TS9J)GLTU90>?A%LG;O:/)D&'6F9*RC/2C.^E,!
N:$BD-M_3*8ZIK*U8B])%Q!!";&[68?RX`^_TU/8Z9Z*TC:X[<-^.WZM&'Z$N%W/5]T(%@:\)<\.:%^D5WL)9JZ@6%LXN3&,9@8GE1?LHLWW&UQ!!"
(B>@F]F3VG.<%$W(!J3,`1!!".Y!G,\Q0O7??M<BI(;BR7+_AO"><'C;??/7N(L>@F_TGX;(G?).]49B,C9-FR5*>4PM+F3LI,B7?_G$-1O&1IQ!!"
+E_5X!;!.H>*-O()GK;C81!!"M/@$<5T/@IN63#9"5/(VK@$V%ZR019*R)`.,`_9BI[Y>=QD_^9;:#%/HEYOJ2U]NT)"P\71_6&[,]`+/2T2>G1!!"
=;P)$%CTWT*@:)XY=)^@`!!!"W=8/O-YIZVTJ:$M4D^JA"#%:>7?M7'*<,M$(*"MHP2%"\A+]]8`+%&O!^7L:/IDFO518%01@Q-'N__J_1A%<]1!!"
,FHE$-R7,U7B%@/%2R`N2!!!"UD>VUZ0MW$*&#(.?B%3%JNK\D7;"^\_KU;.5EG=4-F(DM)A1!&L(^Z:`_)IR9:/4&,HY+G!3ES>NK=Q'&N'$@Q!!"
8NKIE^"938&OP1U!NA+FXA!!"*7_DDYH)?Q5".L"LS.GKAK(")-6MZG@+2*VJ^[T=W%$^V_.!AM7.+%)3O27#U(1?NGEPIZIOB_L8)<W(/$YL7Q!!"
P4ZTPUZA#F=7-Z2(F,?CH!!!"(D1**2+^X.M&[X^#.G5_C$:5;%*?HKZ/I"JXN.K"3Z7W*\:$<8X9G8>(0,>`%?8#!
8/FX"76=.9.#J@DL0@K^[1!!"G$AXITQ3AF`,*<L_E>@J8'Z$'?K%H?L'4*=*XDN:%430??P!G1JY@3H9V>^0(S;`,++P#O7OCZ)8/>&FILN[2Q!!"
G<\#EKP1IG3.1&6JQ[Z;A!!!"G%;FD>_Y4WN&BLYQJ@BP4I;]U3>Y10[-N^]D9.+MA5-+8)"7N&5W^M>W-U1SF>]J;%7:<[_9749'M$*(.\Z6/A!!"
P&E++`F?DM1YI8\6=!VV:1!!"96J?PD/P3HS9W9.G-O!5,G;-IMM(H@:Y(,>C[8L13?MI;WA4Y+LL.XAJ',2_5*_5!OS;O#,8?:@QJEU2%CV&01!!"
P^#Y<O&H6OR(1NC2A%TQDA!!"R\'Q!EPU"H%="I@E?G?FL>_-%V+E0!3'JO_1[V:#+1]12MC4ALW4^W8YV[*KUL)/LPZDRASUD6-("7JT@T/6I!!!"
E7VV5B#/HM/"6:L?C>7[7Q!!"SQ'*8*T6)W@-NU`3M?>IS9*DU\"KL?J;.GS"3TYWQ?RPEOOMXV1N);81<D,5548Y48QM+&+>LZY^BVXJ2<$5HA!!"
4-%,JR=Q.C'#``U`)_O#'A!!"O`DV>>F/UKT1SW_RNI;Z\5>*,Y^8.@@/ZH0<IM!?[FMJP+F!,?H=*^L<*BU/]]#(H!%#NF*9J58.4.$9O`W%*Q!!"
!I^CWQ28M]D/<I0^:.($I!!!"I3*$I=5:%@5)\OH,E+24;(9G7PM?\-122UQO3`!VG`8E$)KY544^T_`J4?<XY2`4!
(G)$RV?J86L_1(VL4+RX2A!!"3A"3(T;>U-5T)92\Z,._KS@2^F(IM^\UE78'Y#\I+RD<U\6C<X%H[8;WBNVA]$\QRYRKMG"IEG,'FS%A`!`OQQ!!"
E`T'H!#Q8PDMP_QCLB^(*Q!!"+0=RQA7!&@38.V$0$8%/VFE`MSL=Q^F?KNQVRPR(?C(*&92']0@R]ES$*"=U%W\D*+1(D80_4J;]2E3\N-L\QA!!"
!,$/ONJ"+ZKT5<0.4Q=$\A!!"5Z>>NH9$)W.V5D9F@>?4^6/Q!,Q6PE<,2:+GI/(CLT,1>"7`TYQLSCYJ78O8S_X01:2R,#`L%6/"X\*?[%C=L1!!"
.;?>0OR]'*B[F;)F!$(;"1!!"^.TU`/%L`&:J;S-=SB6!MOB3O]?9DS&]HDJB8"32Y;A`[]Q>=[4P-R3@TC[A:[=04*H*ZB>0$(SQ0T(>,R)*O!!!"
?-BUVLU+V['\X$]CEH0"*1!!"E_8&<>%7RQC'V[+`]=9!@Q@]IO'X#)`[DNLA@2HY)<)2VC'TM?@+:)<6)Y8>FP4)]W\0X]C]3/L.9:DC0=L">!!!"
4-X\SJB8S>8<.G>(1.]:IQ!!"J&S*[TNV6Q\@X,X]2?%4W#^6@NKN&?/^A8Q%8P,P]W?HPK"Z3>8^":K49Y.M2`!:KEE%59WE3YU=FX01#$CN31!!"
*RFPM:ZRMAQ]F#*6N3+^QQ!!"WTAU6"P%"^WO:\"6J*R&6^:_WJ#Y&7C!@?>*RZSP/Y?1/NE&$;_#8[6"C:V&`Y'D!
PGN5%2;;<1\C;Q9I*F`9!Q!!"=HK/3SA_>:A*[DN[#<7+XXF`:986"";7OF^5"J)YV`K(K)@%(CS3!O]\6+D-(O$:U/'^5W%9)Y7]'RR+03QBA!!!"
LX)!Z\+F60*6WGKL=?;E)A!!"229]C1*L953GO`L-$S0J\Y;3;)%F;2\(U"?QQ<."%4A0FFA/)F=)K,)^7MM.0`-H8787]</K`&>\=^TQ?<S\<Q!!"
1';=<:BNZF3.9$#L2CJXY1!!"6I&MG_%DZ4/^`30>S^:[2OF*-)3,8]1FTY5:F\:;O:1/V1NP.)167&3'D_D*CW/)@6EG&Y."%7`O4TPOZ=PS&A!!"
`R7&3M6?<..4%@N2W%U=LQ!!"]AH.CHZ@LC]K\4JP5AQGU'"@D:.9^ZC:ZG.LG17=-^YHR/+8)TH^$DE=/?SB?AS7(LS;<+9\&(?-R\,%]W!;YQ!!"
B^Y;UYJ\KV;?_$22KJT'I!!!"V6E**CQJX+#C4`Z[G`ECXS""33M4-G@5GW+_TA<".5)VX9RX*4YR@%E,/\]+JWG-@8U&BE]=Q#]$Y!=-:9;3/1!!"
QWRYM';DUF0WQ<*WY65N#!!!":X7^&T:J]`'(-]RY20"CW'<FL'.#F:FO2GXNY`T,\F%`S`&.+8#)\[M+/CQ&JY'/*KSA/I1QHO5B#*V@YWBF2!!!"
C^M;`':F?W?.-X9VSI4Q\A!!"K5MF)@<P&CE7)AIZKDZB_HB:F>;?L^D/.8<BP<#'E5WBR4A\4/J(U;F3Y4HAM@$O!
TGU69;_)=7;<?YO)S-,-WA!!"(7K4@!6T)OG#4,0NT=G\XXI_B':?2X)\I9LQ)['-X]'%H/J29,_IE_WZ789MZVH.M$"[N,E`EK;HFX?-8^]L+!!!"
2P?T8OH#:.-92@!YY_`5;A!!"0M<A^&T7N0!><E0CSUM^Z>_6-.4RV7SD7"YU9Z3U&.VSVH98;A?%T1SVJSCI9UZ3A3#V>'A[B6A)9!W<*QA`$A!!"
R5^N"%ZWQLI#QL^<&#XK2A!!";DCCI1O.?*JB>ZU,0!_!&:5\7T%VL`2P\^ZD`&_E!GQ*(O,8$\FV`;'E]X+^;Z,VFE&P]31%O?6Y_`.%RL/1*!!!"
G87(U7LHMEB@DH&BWEG(3Q!!"C/4_V(@WU&]6/EX4Z34JONP"[,1DK\[Y1"A/P>Y[8UQ]:-"MW_(L>KIEOEJ1:F3-_!C:,AP\F;+C'(?>8!`TC!!!"
*-=N))H_Z8M)I,#,XZ2ODQ!!"IS:>4@8*;L7-TK4Z6I8%R<6$EQ\R/FJRTT]*V<[!$9'VRDW\)SY`P;CE=>KG>TKE`\!Q:[ND,$I`H=4YGLK@KQ!!"
_'479N5W3*93MT:"'BENIA!!",E&.R,F+K5<RS91OY**5M+#G6Q16NAZ*I.X)U%K3LUJ_OO$`X[XZ,U)/!1$U\"G3C2HA-ZE&ECE7T;H>F(\"I!!!"
@!:K'Y220\LNEP+(+ZE.2Q!!"!J&:GD)QW(B"PF7;I[V4HB][)8\5I[/"F#-DDG#H_A\X!U#`;J)Q@EY-IDMC=@=B!
QKI`CU6C\FI)RHK1Y$C5V1!!"`']!@&>0H1>(D[/7#L>$R)$>#KP%O@&V_.O^F7FW#.=#Y@HWV_0RX.P(R`'A5#+&4YR[],T9Z0C;GY"F_W&*3A!!"
'HK$&/"DS4,DV@HOYK((^1!!"M=`J7V2L26]AZ&TKS/,$@2OQ\?.1(7@8A?NQHL;=&I((_H^,G!_T/-/&G7;B5OXX(R6^\H`("[W4';&7<M>!7!!!"
&4NX1=]#HL9_AZGK#NAS(!!!"_K^ZW4*6'[;F_*E\@Y+A9G!"WK0$9YXO^\V"J%XMGUS]'/D\#54Y)P)1J9JN75-'FZBN1S(U/3[2:_%^873&,!!!"
3&V]@R1(E*,72V3,Q8%@]A!!"'/YYMCD+0HV#"-IZDXV>Z4Y"`DEDPX72XH"AWM7LH-O0!C6K;0.!G+N390O5%3(-8:-A$3P`+XZ%6B7M[7U;)A!!"
B6:WSND@T)%783X8L(15RA!!"[$F=&Y;(*30]L'FQGAW%EMK/=*Q4JJ/?UWNEHNUOF/X5=M%XZ//9!=7W5O>BK$%7W_]ZA5H:<]5=M>$M2FVICA!!"
._S*+G7U3YRF.\@[0:9C&!!!":HU9@I$CW/]@,WI$CB8@>^<RO8A1%.$F"W)E6.)SE4;$;A+Q1\@@LB#N)S&=:.T"1Y(T<ENQ9N>."YHPL44/+!!!"
6:I^7C5>%W4)S]EMBAM$"A!!"WW2"`1".IP5$QD?1Q@5HY^L?LVCC"8<,1@&%W'2PHSDP*J[3ZOO'F2M,#`*M"2"&!
K[0M(T+NX0GX\E]Y[@*/.1!!")@[]6W:I*H].SK=TX3LI0P/Z2Y?LIAI*]ZF%154*>\R)DF_D'&?DLL8/O9$`Y85M`BO9!Z)_MCQ:-HDL-2$A9A!!"
B?U&.R??<3T:Y(WXJJN.)!!!"TA.7\R8KC_4]S3I5@)>27I.3YG7$Z;<HM,=:5\.XJ6I9T@*J7DPIT:-?HJ8:6<5C?HWLSU8EA,XF[F!0C^$$(Q!!"
$8?5##)M?$0LY3:]T_VW!!!!")?07A^*]7`9EN<:X%_Z)>17!-F&*R_39)F6"+2!OOR@-2-H!;H:Q08YL6H\1,FMU_02^J^<W)O7]@^-D4-DV$A!!"
+TMR=,8MT$7D4"\7L5Q&A1!!"BTOEG&#$OA&=X[L24872FP4,VG0B/KO7?J5MI+,Z%#VR'-QM2`:+:GAIPRE3#FH]>#Y"H&Z^]'W<)OXV4P2^ZQ!!"
26[WI7BT6>1>!0=&%4,[Y1!!"27Q.O"7LU7;_Y*H>.=.N@"1/=NZ>1^QTN8Q13*KG)7S*K^7C#[Q'YG2Y&E3^0!8.?N#=%6ET'CD>C8.IU6_!7Q!!"
PU,'['("#TH!C^/0^A/9BA!!"*(6M,OK170-#M1GE#%*27H]V6&-2R?V=LO`OO+FSBUBH?%Z8Q2:[9J"'TA-T/\I?N.#KG,RF=4_@G_B?B2O&Z1!!"
S)J1_&-S*%CZ^I9M6K")51!!"M:9@R8?YK.4HOXNP0XG3':%B((?C"&L8ZBJ^.]H59D$!\''QDI3&=[DB!)[X5BH,!
J,N:"!4.^R0LOT3VSHT_F!!!">_MJ[`^D>E%2F5:W,DH:*6\ZIR:B0["`][LN]H_%,-U1EOUK9D%F^"+2[H(CI:42'`P'J'2L8O1,NH_BYTCI%1!!"
VQ13&^*&PY]@9^O%+=I8MQ!!"J;M)_`_A%R=.7K^YOLNF(4T\5BPBZ3VYEQ$,<Q$423Q![A-C`.0%JE7\>4T#;-`7V8L0'[:HW!?XN>^[D2=QGA!!"
_)L+V$?D/P+SH2MJ(M;)9Q!!"B_%VC@(5;J9ETN(U2"YT1?X1=I<U8NMN+9>!K_UU3%XAU'4'JUGC2=6'NF-W^0@:=`\99]]7!+3+""_%0A64_Q!!"
P,P!3&10UTBQA^+9-14P$1!!"90=Q7GV/C+T9&)+CC,JKU\;Q@+J)AR]K.EE)*3^0"K9E3)\)T.VFK<5TP)HEJFT5B7V<']W$[+TBQM4H%L=F(1!!"
3..F.>P^]UH&F@,"1`MAMQ!!"I22@,2UZU%Q_NX)A=B+&KF!ML7)\<0M^39V=>?:S0%\*P;>>739?9C_F#5?]AZ:5/@.BUT!N'LOE0L[.K(]=TQ!!"
!.TK*^;/QB%Q9?X5E8`1CA!!"AL>#RPL\B$(#UUIV6[;6C='KL*\O]@CX`$4_<S`2*\1QGIBM]W:X3$HS'"I555T@R_*=P8T[+5UFMN%6;?A_,1!!"
2M_BGH-:7SR[:3-.%8Y,*A!!"\`=KP+U%!V64]]=FIO<"4*JGVAB>IWWDVXFF$58DC:V.$=<+1[5[?V]CQK"T'QIL!
9O:3?OI&B!4L0JU#^`Q2>1!!",[_2<T@QO1ST[;:W`IZ0OW/^_#BF/H?3_&`'D.TK,(S'_0\(^O-,_![90<S>NR5VH^?AU4EPIHH3?)'%=26-A!!!"
BE<&G<-N4\7,N49EUO).*1!!"6J824?*Q85*V7XG&$-Q^E73LCA.#D=FU,8YBZ4_.SHSEMK]>*]`T"]R=,P5XHR)G9)<=T'+E$3$A0).?<F"O7A!!"
\J2[ZA!V@=X>N;U5F&--H!!!"A1D=43U9%#"D)2@;L#0?;/-."^XUDUM1)\>Z\EJ/LM9`D#1([E/Y*P`4Y;[4XEU6J<\497X^>2Q5**2AI@6CWA!!"
EO<8^.C$I@\F0^YB$A^%71!!"3&QPY)'5QQ-R**I#QUT.WX>J]`:A3%GW;=YH<!W@$.A4"&IC&W)BIQ+^),)C2K1;%]_<=-+4J,BIG9\)3<8C<!!!"
;D%7E&(\H]G[Y>712FY@N!!!"YU,"84*)X-@`>QLB0AE5*<G%WV'K^_LHXEO:[>9#4,[AM.HC@2A66P'.7[]L5.Q+A<^.\S7GYW;H>8DTB85'6Q!!"
!O/8[*?F;>T*PHOX\4!0^Q!!"*,S1@*\CDTUWFU^9!/@D%LV*5T03*,+<"T'*NF"=:'Y<W'R/?N`OAT#=PI;<.X'D5$1PTWF/APM,X4#NRTCN6A!!"
VL<PXYH$<WJ3!Z#D\814>1!!"F$E>,R0K7<4=PE>F*81Q6`E0BZ9E)H&..)!S",N1$12T@%/:C8\AKPX?P<?TN:TH!
1T#;/%)T_1:"9P[;]U;KE!!!"%#(]55YO18-NVUCL\/:NE^UVT]9N$U(L;:FH@988P_HJT7;^2TH\0L8LP*TP2"[!SJ"3&7S;U;/:ZQ5M>,:\=Q!!"
P<F?QY4[A3X,4YY`]6TWOA!!"W[C"5M9IJ$%4@WA:B?\)%"X61&R8W7R].<T#WGPE:%R7-\<)*_6-[-N%:*K'#KT(L$L[?*T0%S#@C.CAN-Y4=A!!"
M4&T`.O<HAC0`SA]IX)4GQ!!"YR9EA@;*.N(8H:OW&X^GZB/5<5AF!\QQ-?MB&=.?MJ*35%`J<[ZF&]-@0BT[!.12Y\R>(0V&:;WBXF8626#4L!!!"
Y?5Y($+$RS&Y8@O<-W+BG1!!"@@A55R1;]X2`FG=50M$GWT?F@P3<++\L>&C_K(:`6\-/:;G/1K&BUEBRH<G7%Z"+\V/P4B:/@%L;1XY_Y:U:8Q!!"
'@3N73C&K62OG:W*6-[.DQ!!"J\37VA1EM1'9)/<66;B\/VL=T8V.3";#?(TTT*?,\'N3PL\I#U"NV09.K-QM)-N8HE]N2OJZ"LQFY#H0K)1SZQ!!"
M-]49^%SKY"IOPVM*XI^T1!!"$+4EU0IWEN&)QP)$_,EB^58PD[O2NA#)2AK\-3[+'=&-6W=NE9S%WC2F]L-PYJ'.90\8GS^J[&\&<(OBQC0C1Q!!"
AQ5@;D%')X$@*[=]ZZI0T!!!"SGHZ"N8X$Z@)P/AZH>X%20KUI)"/P]<FTP"2(I=RJ?FH31HV9;^XB]JX+;B9WZ&V!
J&T+L\8/DF>L"^J3EO:-H!!!"C($O)8F>9@B!'2(SK]API'CMB`;\OT)M2:6<'&'_8ZE/5CC[TB&U,4Y)-6*Y`^I)7<,#<-%(GP>V++80H1%HYQ!!"
BK[:8UE[QRJ!?1H.-.&Q!1!!"I=Z".)&G.?D$`FCNH[PO$G+4ZPN"V$QB:F$[6![-.:^UQ:EO3XH22+':"Y=NE=E4L'%I%_M*KK*>](P."A=I-A!!"
9K?(M.YS?0/@+KF_(X(G:Q!!"'J48IB]M]W)5W$K\JPF5-.'*:]6F!E]X`@\^P=\P]B_M/MO*MLA"I5RH">"(]&:.+=23"NFB\./^;WC-@,H.&A!!"
"]TFUU(P67ZEK13Y^$0Q,!!!"8RO=H5X_>TO#%%PR>6LV'HKD/=R/Q6[FQ%Y_^KZE&A-*FJD*^7E+EGF"9\D-M5?0"2$"+BM+[+XE,?ZY!`Z[(1!!"
?ZO#LFREF-XHZ73\MA]E)!!!"?Z[%;U$$H1>!I*X-3PS^/^K\CQY1^R+Y>TXT4N;%KPKOE)JBZ,+QPR)L,\:&=R\.MJSI$/6,*M^+T64X]87F^!!!"
$X]$$9$HI6@<1PUZAEB$>Q!!")%BHSAE)+A)W$%3D+ESE=R;`:(2'=EI0(MD;V41W]Y?M)@L=<7FAVW/&L&@^698PR5@GMUAKFM?0$]9/+]T"XQ!!"
.VU!!"1O!MKX-%JKVQ>OK!!!"DH1$5L>:<44"_F%?'0?R-_DDX-'63F#X>5[?2YLT'\#7BU3V]2#0$W+JT0-)G*HB!
,=HFZ(D3Q)N_,Y)$-"<)#Q!!"GP]OWUN[VCRH`XS"U&@A6&M&;IMW6A7:$MM*BY([S(/2@!(&4E.$MDT;O`\ZZ+5*"PZ1S!8,/CTTNX]ELY+671!!"
39'5)W_-F"5/3SBU61M$]1!!"V0/&"IN,EX0[S\@2I&O\K&;);;ZYD`[!-AGK1B0^H!'Y,W#DL\R)U5R\V6D'+.I^W:7=H\*@07K)38$GBI0)XQ!!"
IT!$&T[]``U-UD.^E0."FQ!!"-I"+?KD2)+Q[TOYH@YS]%>2I`NVWPJ$4PZM/@9%#U^A:UFD2I#D@MSM''14,;>,V@[EWG63GW>R\22<DEA;7P!!!"
_DZU4.;PS$L-613!Q:4KHQ!!"+&WUHO!6>';-9>Y,WK\!WF+C?#%?)()]@>%<HH[2"+ZF+RY0]-XGZ]MI,-9R=!%UQ>+R=%M$1O3CY_""'Q+?)A!!"
?@N?T+[^>"OPWHY$%%"C>1!!"TR']NK55]M*=,PL@/OYRZZ34JV77<G9PLNR8X=-!]=9/;9^LWFNH822NOQ(I)0F:ZD7-.)FS.-7ZIF$^I07=P1!!"
5V9S6;Y,=8''7<#6#P%!MA!!"[9URJSS`\5;GI[$H="<X7<XHP7!L>),W2$)V3W_E%&>B<D/7`U5*0!;IN]?T";IPQ5FK(!W?SN3#ZA-@(IGP]Q!!"
?32$D<S]\Z0S\XSKI%W_Y1!!"F&)[PF(H0OW`('^1+MOWQ;O"(B<O5^L1QD&5L5<"()U)^0J_R'7Z*",=P`E"QRI)!
QR"L(QN_-M7W43D[0K9&'!!!"(JECOJI-V/HF-IE"KI!M8\RN`F=ELJEVMV2\T4PWU*3N>2*%@PS6>+17VF.GV'`PNBN.?7]/194*>NH31D,;9A!!"
#TQ742GH&>+*O'DL&/-\MQ!!"VFTC=MFI'ZL[7*A$&['A"(B)^U82(KFN0DL5<E!OVKZ59^)/Q_RRQ=*B)0W4:9E;Q_8=G)EO#T\9?HW[A:3C[Q!!"
P4IWQH`CWU5CW1FBPB_[Z!!!"C^]_6>^X&^=7Y<9I)?-"M5Y2EX`PX2(..MZ&$`7M56S]I,1$PMZR%XIMG?LX21KQMQ1<0"UWSJX4*X>D)*539!!!"
R"R>S^HJ=I@5#D`BI`>EUQ!!"-F,N[XJWU!:NG=^FG-O^!W>>BP4M-T96!O?1U`JD2Z5%SC_87T]VC+D.J0@3/_)9'Y;H\"<X[%0QRT`_-CC`LQ!!"
K>P?"Z1NBX^;`_$K?ZY=^!!!""ZK:,%\XS&VZ.!JVAO!C[$Z&(YAILA'3W88\1HX(U0-!LBC[`B;'_2I"<NK\.AE.5C_^3$F4E`=2S"A\16\+[!!!"
_<P()HK&!`P(S%Y>]YS[\!!!"I<(]D7S]B0WIG(4@`GDLB(3U#Z>II3\[0,#Z44<V.K:GNTC`BKB)FIG"VS`=I!Y)P.9H-JI;W(S'IYQY<M,%$1!!"
%5`)238&FUG&]5<:?#\+^!!!"_;7!B6F%/3U%]09H\+(=L52T(7E]F+6$[S+@S.:%.U9PB(%)P>1'*-O?$-XSQSQ\!
]#&ZO+3!<3A1P'W"T4U\O!!!"F<U2RE4I>4]3-7O<8]$4<YG:.5BM&/^E^3]\W2-0+;->Z*5I9=D8I&>\X%$P')XX!
:US@[VO";G"FY,$/7TFL[A!!"HGG'.7Q/E&6'F_Y=+)+SB:EPD"V:6G`KIY!B8J".-R84SS#;[2>Z&7#UT:H9]M^!!
\*)7W-'V?!9?["0T$WORJ1!!"UPUU.%IA9+C\<='T\WX[,<5NH-$B?G53#!*^AFQ(Q,-M)%@J':NBF?;N][.A-CET:4!MK["DQ]##`;2$LRXTXCD!^).$.`(O-2TB?*_&6RTC9[>^RH)@*,E]1@@<&D(3!
.L9_J`SEYJ@!.9,5E`C*,A!!"FY0:L=GQ]]=3R*@JW/#:,FZ/NADY2BUA]FQ!N^#U=C'PY`BY&)#;Y])H\L<@Z-Y61FUYHU`V.Q$VJ>D[WM\H(K1V0HCJ*R\#@&`%A^4FFE;=S"V0\DCB!N-)M4(49^F`!
$X;!P!_DL,!TT!],46MI]A!!"0*G^)+0--)@A0;WUQ$(&%G<Z!F+-H>76Q):*34:JK9G4(*C)Q%J+!*%X-P]5=$4I`G8?.["/DWS@;5[&R%'@2MT+Q6<1*7JJIRD9987Z8#99W`1:%#3SBC%!1<'^J!VY!
J#D:6HUF,11%"-/(+9;SQ1!!"[*4HV<3*`*.UDM)A:.\LH$.I]#!0L\NE3Y9#XTJ)+X,_;%J_G35G_,W65."AO$FFCY8EY'.3`O;**%!,$@!N@PYIAM3C)DDP!ERS>F[=?LGI=/_=TZ1*[FW=0;CV2ZM=!
?%@8GI#I<H"PR>49GB&+FA!!"-ZGT-J'T')U1>G5*!LBZO.![.?5,03\.Y3U(A24'7L9O;7)&_C^/R`"=3"#[#XT][M^&HMQG98#Q.>6F;52VSZUNXP8PZC607#O2WR+L[&842'H.D2"TOYB02/TKD1N+!
LZUI?"293"XIT^1)*_W$YA!!"<1B5%)CC'I`77_)1O&8XOP6B[E6@,X4:$/2EEO"OA'1R\`O7QIK4F@7AVWYB^E"S05?VEDB6!1(K)Z7,4W4^/E=S`F<ID5.23!O%=IR0)32CM^TUHXR@.[YC=/S%RT_8!
T9U703E61](174P<(,=4/Q!!"/VJ[UFPIAR)"?D]'08H>DO02QV``9M%O;.\\G?_AY)W^G3<`URB?`912'W\Q@V\AYBS&76_Q8>+[9ND]P!_ZS50=MPFV/>68R94X=:QYY`<,YXI:JZBG)5Z,>$<FK2.)!
JDJ:22'5PZT?[-')_]<)A!!!"Z`P>T![QTE1\(!.7%$HFL.]U^V^*=C!40P$+P48.[&AZ3,S2<-3+HGU9+KH;!><G5W/,:>KK[H#/5(V&N=<,*U-M6A%7*K-9@39:%!AB"T,ET8&94B2K3;BOX*G$)&6+!
?$:R6U;5A,"=;/1U4\IU\!!!"HOJ#[#]N80\O*)'+R.9DW&\Y.J/0T@MF/RAQ-&9><W=:(63-,MX$Z8+"8!"L<B#U>NX'FWW+6+S,,4[6Y`"$?^[SQ5<-?=/![WA["E+:*3$_#OV<HU+1ZNSV0[V>:_4Y!
FL\KDV<OPI"BE;\C-9'_;!!!"C_BLSI0`M2(:[S--VBR1B!_@+,BR]@?$[%UZCR2,\8Z5EUR"PNI`3@N=\Q`9\@\J%5OPV"2H__3-LBR?=>L&J<;)8@225HX-,B4^:'#G4B^0M$V\8A^9U$C[!1PE//RU!
[CJM31;-N?727?<OC!K,W1!!"*6,I78[6CQ%XT?XU$/^+D5$F85H=C1E&,LSMQ4!_0,_H('>)>57A:QB@U*SWD?I6[-H_5IX8O4OU9K?.V&U8N5,\WY?1E;24;I?B:7/;LCFL?U@>)FB]4V@3GEU4NQ7?!
;5T"$2&G**]U#NT#!'I;_A!!"6P.:9VD,W"6HU;CRY4-`EJ#'8]]^[N`GQ%:1YP!IAW@_[@#PE>1J@,O]_,+E+N9&`*D\!B0P=,PN3><?_LWE6)`I3&0TE9HY/?4[[S5+IR[X8V77*G'LEA\/0P=/#Y_W!
1HSX%78^DK.DV@TF2^)9A!!!"UT74[P`'7SA<_ZM_KBEJ%!!!"
_NNWX+:L\69X-WV2P:;"P!!!"5?5S'/=997SZN`4M]6C=42**O`$A#.VC8VV1BP[&9A#D\@A[#XJ9#X!;E@2M%R_D!
5=,RL1D@^;(E1!$R_KC1YQ!!".IX3)*'K_M7=I^4>4'T;S"SNGJW-V2^%0=.@\',J.-1WBY&0GA@J%CPT(\HVLYJ/+*JCQ^YN/S'%[`K%X4A?_#IS=<K($-5K"-:>!Z74;XET#\/IB._SCZS7.;:TWD$(!
MD21HA.A#JQ&M5HL]!3M#Q!!"LPRV>(WW,WW0+,_%78*:8^M#[OZ>:LN5DL1$*R8T#Z#95%>24@?E7,-Y9&[+]X^PDZ\Q?\)/R>3O.,Y)^C[RD$M,=]]/GX*I)#9C6Y-E&O0XRX$>T4!$^AJM?Y510V>M!
I-D-B0:FUX8L!8IEX^(I<1!!"U&-COGJ0[%WC>_F4E[/X`(K(*.^R?PBU3HI"0!R#CV=U?7>T$9U05MDR#$YVK^H@0Z="YI9EID2G3$N.:@D\7P#>Z%+?%.XUL)V4B$BEMU8\F<&IEY2V]MH,VI'*%_7H!
96:8BA6FX.XDWM_FS6*?3A!!"]G#Z?PV$YU1;Q.:C/-[;SUSH_:)S_9BA"`CC"%#U&?5;,#$2T[$UF[=<Z/6G5E5E:`WKR5Q;\_HD2)@&1(B@&;2EK#++5'K^B-LYZ<1_?O?="L'S=<^W0J(/D$8QTP(M!
EL:'?\=&!PVE)#:&&E7K*A!!"-^_D8G.)X0`DKOW)C/N9N^1C>"G88'KR]+NJ7^]5>IN'D;=(I)QQ'RKDZ<$)_40;'M'3]92]8)@T14E-*JVP>M+@:J>S`$'B&'D]ODWTND87,F8OQ_M];96T,JTC%_"*!
/$&3#&)F,S":FOX1O\B70Q!!"5Y,3(OJT8#*E"?:AZN)]J`4SZ,5UM>)`1K`526[Y0UT4DH/OS=.?U:#-H)-T%$\$(9.')B^55*/.S;3\&(WO8XA?E`'N<"Z=UVLS)=-_`7728#;".1F&1F#$*I#!]YWT!
4B!0!P*F2C4&5>F^E]2&,!!!"&W`@7ECK6'2[1JI-H5(@<FC!VQ`269]4_T*P,UK[#R)B,R'E0_A;$CJJ:?G80O<=147B+]'H^O:B[JG#V=4]<SXM?SS/=4N800,``LK+Z[("0#\E="L%R?"0.O]*P54L!
5C!O`O9OV2MOZ]TYJ?;V_!!!",FUZ4LK>DV]X2<:>FA.U!Q1J.U"7.%Q$K`T"JS8"-BC3_>Q(%@EZ_*^NI@_6Q:4/A31M/./ZBR@V?E^P>[@LO(KB`@=;UZ8&4--H7$CR%YFXAK)^1]-CV6!`2.V15"]B!
`!=%(3&(QM5&%?]169TE@Q!!"TQ>>[-]Z>J==PG?CFF\JW[V3?-#M;6K.P,2Q6WHQ@GZ(D,V@%XEO><I8FEQ^$:*H"H-B+3F^\868%H_=]LI^FM[X@CU81@X9RCG#+IP=-_&QN`H+]Y"#7(GI08CC$&5U!
>2Y9Y>*G*2H/$_GH'GLD01!!".6KKB?`<Q:G10')9'#Z&AZ>J9/3I)9N&$>,_Z^,?+(Q@M#"^WU=0*&EO5&6L6%HELE2L^:^`BS]F@`.)&F.QQ=QOI=)U!+3AR02\C`C6EM?K>_H(#)?T!$W86@!O:#6A!
6$43)'<4%X]L"\9K665U;!!!"(70PH\`K]3+'=V!%ZM*V:V<0H7TQ`[R4.<;BSQLD,F+T+3_-03*1&T'-S&%P4QD,";P^#O+_H0RW<T*%1V'VDK6EEO3]%LX:RC%3,LZ='HYR3QV<_X9L]&/!9QT<[.B,!
)7,05\BSWM.FP^Q(_]/O.A!!"$37H_/F-61^N`K1D"C"F$0E3@E\=N"#L773HL\\=];$M2I>EH"O&>[=;(&9)LXK!Q+[;I^%3OBR=R98>LNH<I+6+VO.?Q20._"(&*^N[X68::FCUL+?V'0\S'X6;K+#E!
)4<_*G8S%3Z^;?OG::&)XQ!!"7:S4EW>],+U3MK:T`+4;HQ!!"
^W$Z<:C$&HSH:J`.^CU*(A!!".7RW/!.!.6H^MON!4=H^P&D_RN.\S'LW(DY8,JN9-(G4E<HKOGA-"7F5#.()5U'<!
#3"6#INF3J],<S!W@'^B;A!!"8^W!%_C4D'ZF'0X(V"QXP\=RPQSO?_FZ'%\J52NP2_1:6;P`ZPK8`VBXK3.4?I30'&:O4TPY.Y=;^+4#8U#I7N#H5[5W4X^7TN0W))\!;H:2K"COIDMO@H!]$(;<P%>R!
%2$QT;>QT9]IQD;@$4%URQ!!"^!"TV?9^7/%*O>FTO0*/]D(*QX:=Q6VU30<"@(;^X"SA\XVO1;D']Z,QY0NMXMHJ>F2`#I433!`K,-W+2^TZCN<!NY[IAUAO54E2UXF^=*0EZ?#5(SD=GK([2\1KG0[&!
#2XX/.W(*4`!"%E&&1%BMA!!"KU/T!RY(QLH/"E4?:=!F/Q.9=\P\U1[^*$:+0@//;"79`)YS`DR[(5K*#FYN'>5BK`16X?5XYF.1Z)$CK\7//(Q=GS8O_JWKFJC1GCJM<YQC^L<&^:525G%NC*+LPA\D!
([IPH--S3K%$FDYDE4(8WQ!!"%R+X5E&CR;8I+;J!745,^.@Z%G,!("\T<^I_"CN40#IOK-RI`4'E)KCX`A<A'8O<>Q]BB#N5P-J$=]MM?ML/&^<7A[7>H0#D!Q>+J-B&>[N7>$$;K,,(O5-MJ9=XZ+G3!
:C:^EP-%>*!)J$.Z!.9(?A!!")AE(6(1A22D"CV8.D6Y[T5'/+\A<VP0#HELP5(KRI]<2F^@.ZWI89)`7@><A/6O*:EDA/M<70=,"`5P7?_*:M#@G6*/MSC7CNP543ZI^QP]KW"?9P3.X)L7:ZB75:G#]!
T3V#*&'V.U&R/R+-^E-.TA!!"9!;0E1QJ'&G[/M9L`FK_;+_10M++P2]E@&ZH&9]I$_,C.*1!9OK9B[OAH>!B+K\A#:."X"0$GEWC+ZL'+;7B*J7]$11R_7V:^<0,;PJ.7UAP2N)]^!,9I6[;^="!Y2CU!
E)3*K#<7XAO/34%OR&JY81!!"C8^J<_2!NR%;4S_<XS95C`.674ASG#[>5C!E+WNP2%GDGS8R_YP``.5U0+;'CDG6)=(D8'=ZIX->.1U*#ER0RE38GS%<QO]1[I"C_N?5\*^<3$5+2!83,T?6ZB=/7Z:I!
BK=YVHK[3M+CY9D7'<J#_A!!"QC`"T9KX;)Q7*UV5$YR/6*=O#^`36Y=]=<HOM;C2:2$P'R)R'CQB40U6R,O6*UCD\,9ZJ_7"1K_'],U!AP:Q(KFROG.S9T2;*(Z+*(,X(.R/#!_'BNMU+3>.C`HN$.7'!
MS;'2ZE,"-13BNU7IN)TJA!!"6@:*@`\].9,V^OY3^9_@MGSM9'R?>^"NT4XC-?CLBDS\AEC/Y_"$%5]GZZBYF"%SY>37R!=8]0:^4=;RL[2Y5Q3R25+$&UR5+GO/C:.S-%_#ZRGG];:K@9&UL\+HX'>\!
/H)&/\H%T4[VG%5YAP"&@A!!"=8!*M2!A)K#F*:],(9)(,>H>V(ZPC:-PE"?99(<Z=I#^W0'*#!H:YQ`.`H://KV"!@;_S=9]&'X`<"+$R-OHK`DJYT^&&9IP,6X1F$VL\7I1&*>??6J=@!Z#=D50E%DP!
2B508&YA]2X8ALS^V)H$@Q!!"ABX58=M2\BZHR,W!\]E)F<!5'EM5UHYRF/?<F6>G6HCKN[*^9#U<MC*N*5H4:H_*ME#L1W4Z3(%:.\[84XWO]/N;/[4!\JS*U3R!*E*5@0Q.OWJ_FA87RI&UM<J_7G:M!
LC[GRUT9M$MR"M&I6KM`.A!!":QQ[P_HY8D$R^UK:OK[VR<Y]?[+')]N$X2IPZLM8M/@YU-A2!*MUO/I18/5P]`?>E-/N88!U4LC52-X&)VW#TW+%RRYX@B1=[0]D"49;N"*^5W#MA_S]O/"+2JD<ECPN!
L_OG*G$Q_LVSLN)J1YZ)01!!"<RC=1@B$\.P?LN`HM?-GL1!!"
A59"]K#VV,G9K0="!O*6KA!!"@W42ELL(7`P&8,^SZC'/-Q!!"
(`_/'(GI%'@P/BE(%^'-SQ!!"9]=I&N!-&+IMN@CT=^O(#1!!"
4J0`^@:^S`^AZ3L?A-<K61!!"+U,PY@=(<="L*%S/II\T/E!05#*=V@]\U[P*A`!:YHO7=/DD!MI?UJF/;#._%4'[%2R)#;_FI0M6.&9#M&=""A!!"
^TX#03_G_`#@I1ZRH19/SA!!"JRNYX[_QFRPWAS]?T58/PN:Z9A304<S-_16+#=UG3ASD+?9$>>AE.EB(;E5("JK4`ON!Y*?'XCYYGJ$@"HOF"!!!"
KN*-_KB$><;RSX5C)NMMBQ!!"E65`?N1]35Z:+%(^D(^-QFNL&-+/R72MZ=2PF#UVH:FT/S*UEX[E+T_6%.'E:7]=G1!&Q%I0;XIN\..1GGKY`1!!"
3[OEE,*=JOZU3J[.7RZ8$Q!!":[UDJ+E/V[J$Z4\E.F:XN<ECT*J:T\M)&#2J@EXF@KY)=RQS_&V8I)]=S'6"IPZ8[QO4UY!.&]`5I!)#PK9<T1!!"
,:#'MK834=&N>#$F"FYNCA!!"EE[4<RCV*SU3F;4);E>GE'V`6),'1OPQ*M#O[<?*&2:\@Z8S#J]P<>"/0F?#'<TK,$EFGNS%M_.IS.`-O1Q+C1!!"
)]ERG,!,ABHC;UJS)P)&0A!!"N^BKB`8T,.VA*H[D?)YN8!]H.AV:\RC-MF4J@8O^]^>\=FH\]>R`D\B$S12I'C/]%CWDPH<%@M2B&FFGOSD-RA!!"
MXN=J,I@LJN-24R@Z/1#OA!!"'6\V>,$6#^)W`B(.5$P4*6SGC#NM,B!['&911JYYH]MX'IEE-QG^Z8F%AZ<)_=^SLPSRZ]PH$5<O479_L\$(%1!!"
7+<L;(W<Z")%RW[!T5C)8A!!"%5RB">GP32:B)0A0``<.YEPPUN^/6,8XV*KIA"P"6$>\[MZSP(D)3Q?0(\8@-YQ7I+V=#8ZAWCJ&J3KM"8BSS!!!"
MBQ/QX0`DH1]"6*"'-?WZ!!!"ZE#5"*V_;\1K?TA'`\/!)K6-9W^WQC1;+)9,>>LJOU^56YTIDS7<WD^QW6&^^54!G3B?+2[RAEY,)M8U;G7<2.-)VN&@S(<JT`J%`I'J?X]!#
<>GVJP<M`6>M'C`>;5>.<1!!"_Y?0TS+P&!69%`N.T_60(1!!"
EU??!N/Y0&ZJJ9<_CGZ62!!!":DV:,9W+_=0Q(%?^FETY,Q!!"
#ENDCRYPT


//;negetive/positive voltage NETID output 
M1_NETID_rdm = COPY M1
M2_NETID_rdm = COPY M2
M3_NETID_rdm = COPY M3
M4_NETID_rdm = COPY M4
M5_NETID_rdm = COPY M5
M6_NETID_rdm = COPY M6
M7_NETID_rdm = COPY M7
M8_NETID_rdm = COPY M8
ALPA_NETID_rdm = COPY ALPA
AA_NETID_rdm = COPY AA_c
GT_NETID_rdm = COPY GT_0
MG_NETID_rdm = COPY M0G
M0_NETID_rdm = COPY M0_NOT_M0C

//;negetive voltage NETID 

M1_NETID_vol_neg = DFM PROPERTY M1_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < 0
M2_NETID_vol_neg = DFM PROPERTY M2_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < 0
M3_NETID_vol_neg = DFM PROPERTY M3_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < 0
M4_NETID_vol_neg = DFM PROPERTY M4_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < 0
M5_NETID_vol_neg = DFM PROPERTY M5_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < 0
M6_NETID_vol_neg = DFM PROPERTY M6_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < 0
M7_NETID_vol_neg = DFM PROPERTY M7_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < 0
M8_NETID_vol_neg = DFM PROPERTY M8_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < 0

M1_NET_vol_neg = NET AREA RATIO M1 M1_NETID_vol_neg > 0
M2_NET_vol_neg = NET AREA RATIO M2 M2_NETID_vol_neg > 0
M3_NET_vol_neg = NET AREA RATIO M3 M3_NETID_vol_neg > 0
M4_NET_vol_neg = NET AREA RATIO M4 M4_NETID_vol_neg > 0
M5_NET_vol_neg = NET AREA RATIO M5 M5_NETID_vol_neg > 0
M6_NET_vol_neg = NET AREA RATIO M6 M6_NETID_vol_neg > 0
M7_NET_vol_neg = NET AREA RATIO M7 M7_NETID_vol_neg > 0
M8_NET_vol_neg = NET AREA RATIO M8 M8_NETID_vol_neg > 0

V1_NET_vol_neg = V1 INTERACT (OR M1_NET_vol_neg M2_NET_vol_neg)
V2_NET_vol_neg = V2 INTERACT (OR M2_NET_vol_neg M3_NET_vol_neg)
V3_NET_vol_neg = V3 INTERACT (OR M3_NET_vol_neg M4_NET_vol_neg)
V4_NET_vol_neg = V4 INTERACT (OR M4_NET_vol_neg M5_NET_vol_neg)
V5_NET_vol_neg = V5 INTERACT (OR M5_NET_vol_neg M6_NET_vol_neg)
V6_NET_vol_neg = V6 INTERACT (OR M6_NET_vol_neg M7_NET_vol_neg)
V7_NET_vol_neg = V7 INTERACT (OR M7_NET_vol_neg M8_NET_vol_neg)


AA_NETID_vol_neg = DFM PROPERTY AA_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < 0
GT_NETID_vol_neg = DFM PROPERTY GT_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < 0
M0_NETID_vol_neg = DFM PROPERTY M0_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < 0
MG_NETID_vol_neg = DFM PROPERTY MG_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < 0
NW_NETID_vol_neg = DFM PROPERTY NW net_vol_assign NODAL MULTI [min_vol = property(net_vol_assign, min_vol)] < 0
PW_NETID_vol_neg = DFM PROPERTY PW_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < 0
AA_NET_vol_neg = NET AREA RATIO AA_c AA_NETID_vol_neg > 0
GT_NET_vol_neg = NET AREA RATIO GT_0 GT_NETID_vol_neg > 0
MG_NET_vol_neg = NET AREA RATIO M0G MG_NETID_vol_neg > 0
M0_NET_vol_neg = NET AREA RATIO M0_NOT_M0C M0_NETID_vol_neg > 0
V0_NET_vol_neg = V0 INTERACT (MG_NET_vol_neg OR M0_NET_vol_neg)

// 
// < -5.599 negetive voltage NETID
// 
M1_NETID_vol_lt_neg_560 = DFM PROPERTY M1_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -5.599
M2_NETID_vol_lt_neg_560 = DFM PROPERTY M2_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -5.599
M3_NETID_vol_lt_neg_560 = DFM PROPERTY M3_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -5.599
M4_NETID_vol_lt_neg_560 = DFM PROPERTY M4_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -5.599
M5_NETID_vol_lt_neg_560 = DFM PROPERTY M5_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -5.599
M6_NETID_vol_lt_neg_560 = DFM PROPERTY M6_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -5.599
M7_NETID_vol_lt_neg_560 = DFM PROPERTY M7_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -5.599
M8_NETID_vol_lt_neg_560 = DFM PROPERTY M8_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -5.599
// 
M1_NET_vol_lt_neg_560 = NET AREA RATIO M1 M1_NETID_vol_lt_neg_560 > 0
M2_NET_vol_lt_neg_560 = NET AREA RATIO M2 M2_NETID_vol_lt_neg_560 > 0
M3_NET_vol_lt_neg_560 = NET AREA RATIO M3 M3_NETID_vol_lt_neg_560 > 0
M4_NET_vol_lt_neg_560 = NET AREA RATIO M4 M4_NETID_vol_lt_neg_560 > 0
M5_NET_vol_lt_neg_560 = NET AREA RATIO M5 M5_NETID_vol_lt_neg_560 > 0
M6_NET_vol_lt_neg_560 = NET AREA RATIO M6 M6_NETID_vol_lt_neg_560 > 0
M7_NET_vol_lt_neg_560 = NET AREA RATIO M7 M7_NETID_vol_lt_neg_560 > 0
M8_NET_vol_lt_neg_560 = NET AREA RATIO M8 M8_NETID_vol_lt_neg_560 > 0
// 
V1_NET_vol_lt_neg_560 = V1 INTERACT (OR M1_NET_vol_lt_neg_560 M2_NET_vol_lt_neg_560)
V2_NET_vol_lt_neg_560 = V2 INTERACT (OR M2_NET_vol_lt_neg_560 M3_NET_vol_lt_neg_560)
V3_NET_vol_lt_neg_560 = V3 INTERACT (OR M3_NET_vol_lt_neg_560 M4_NET_vol_lt_neg_560)
V4_NET_vol_lt_neg_560 = V4 INTERACT (OR M4_NET_vol_lt_neg_560 M5_NET_vol_lt_neg_560)
V5_NET_vol_lt_neg_560 = V5 INTERACT (OR M5_NET_vol_lt_neg_560 M6_NET_vol_lt_neg_560)
V6_NET_vol_lt_neg_560 = V6 INTERACT (OR M6_NET_vol_lt_neg_560 M7_NET_vol_lt_neg_560)
V7_NET_vol_lt_neg_560 = V7 INTERACT (OR M7_NET_vol_lt_neg_560 M8_NET_vol_lt_neg_560)
// 
// < -5.5 negetive voltage NETID
// 
M1_NETID_vol_lt_neg_550 = DFM PROPERTY M1_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -5.5
M2_NETID_vol_lt_neg_550 = DFM PROPERTY M2_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -5.5
M3_NETID_vol_lt_neg_550 = DFM PROPERTY M3_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -5.5
M4_NETID_vol_lt_neg_550 = DFM PROPERTY M4_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -5.5
M5_NETID_vol_lt_neg_550 = DFM PROPERTY M5_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -5.5
M6_NETID_vol_lt_neg_550 = DFM PROPERTY M6_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -5.5
M7_NETID_vol_lt_neg_550 = DFM PROPERTY M7_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -5.5
M8_NETID_vol_lt_neg_550 = DFM PROPERTY M8_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -5.5
// 
M1_NET_vol_lt_neg_550 = NET AREA RATIO M1 M1_NETID_vol_lt_neg_550 > 0
M2_NET_vol_lt_neg_550 = NET AREA RATIO M2 M2_NETID_vol_lt_neg_550 > 0
M3_NET_vol_lt_neg_550 = NET AREA RATIO M3 M3_NETID_vol_lt_neg_550 > 0
M4_NET_vol_lt_neg_550 = NET AREA RATIO M4 M4_NETID_vol_lt_neg_550 > 0
M5_NET_vol_lt_neg_550 = NET AREA RATIO M5 M5_NETID_vol_lt_neg_550 > 0
M6_NET_vol_lt_neg_550 = NET AREA RATIO M6 M6_NETID_vol_lt_neg_550 > 0
M7_NET_vol_lt_neg_550 = NET AREA RATIO M7 M7_NETID_vol_lt_neg_550 > 0
M8_NET_vol_lt_neg_550 = NET AREA RATIO M8 M8_NETID_vol_lt_neg_550 > 0
// 
V1_NET_vol_lt_neg_550 = V1 INTERACT (OR M1_NET_vol_lt_neg_550 M2_NET_vol_lt_neg_550)
V2_NET_vol_lt_neg_550 = V2 INTERACT (OR M2_NET_vol_lt_neg_550 M3_NET_vol_lt_neg_550)
V3_NET_vol_lt_neg_550 = V3 INTERACT (OR M3_NET_vol_lt_neg_550 M4_NET_vol_lt_neg_550)
V4_NET_vol_lt_neg_550 = V4 INTERACT (OR M4_NET_vol_lt_neg_550 M5_NET_vol_lt_neg_550)
V5_NET_vol_lt_neg_550 = V5 INTERACT (OR M5_NET_vol_lt_neg_550 M6_NET_vol_lt_neg_550)
V6_NET_vol_lt_neg_550 = V6 INTERACT (OR M6_NET_vol_lt_neg_550 M7_NET_vol_lt_neg_550)
V7_NET_vol_lt_neg_550 = V7 INTERACT (OR M7_NET_vol_lt_neg_550 M8_NET_vol_lt_neg_550)
// 
// < -3.63 negetive voltage NETID
// 
M1_NETID_vol_lt_neg_363 = DFM PROPERTY M1_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -3.63
M2_NETID_vol_lt_neg_363 = DFM PROPERTY M2_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -3.63
M3_NETID_vol_lt_neg_363 = DFM PROPERTY M3_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -3.63
M4_NETID_vol_lt_neg_363 = DFM PROPERTY M4_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -3.63
M5_NETID_vol_lt_neg_363 = DFM PROPERTY M5_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -3.63
M6_NETID_vol_lt_neg_363 = DFM PROPERTY M6_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -3.63
M7_NETID_vol_lt_neg_363 = DFM PROPERTY M7_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -3.63
M8_NETID_vol_lt_neg_363 = DFM PROPERTY M8_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -3.63
// 
M1_NET_vol_lt_neg_363 = NET AREA RATIO M1 M1_NETID_vol_lt_neg_363 > 0
M2_NET_vol_lt_neg_363 = NET AREA RATIO M2 M2_NETID_vol_lt_neg_363 > 0
M3_NET_vol_lt_neg_363 = NET AREA RATIO M3 M3_NETID_vol_lt_neg_363 > 0
M4_NET_vol_lt_neg_363 = NET AREA RATIO M4 M4_NETID_vol_lt_neg_363 > 0
M5_NET_vol_lt_neg_363 = NET AREA RATIO M5 M5_NETID_vol_lt_neg_363 > 0
M6_NET_vol_lt_neg_363 = NET AREA RATIO M6 M6_NETID_vol_lt_neg_363 > 0
M7_NET_vol_lt_neg_363 = NET AREA RATIO M7 M7_NETID_vol_lt_neg_363 > 0
M8_NET_vol_lt_neg_363 = NET AREA RATIO M8 M8_NETID_vol_lt_neg_363 > 0
// 
V1_NET_vol_lt_neg_363 = V1 INTERACT (OR M1_NET_vol_lt_neg_363 M2_NET_vol_lt_neg_363)
V2_NET_vol_lt_neg_363 = V2 INTERACT (OR M2_NET_vol_lt_neg_363 M3_NET_vol_lt_neg_363)
V3_NET_vol_lt_neg_363 = V3 INTERACT (OR M3_NET_vol_lt_neg_363 M4_NET_vol_lt_neg_363)
V4_NET_vol_lt_neg_363 = V4 INTERACT (OR M4_NET_vol_lt_neg_363 M5_NET_vol_lt_neg_363)
V5_NET_vol_lt_neg_363 = V5 INTERACT (OR M5_NET_vol_lt_neg_363 M6_NET_vol_lt_neg_363)
V6_NET_vol_lt_neg_363 = V6 INTERACT (OR M6_NET_vol_lt_neg_363 M7_NET_vol_lt_neg_363)
V7_NET_vol_lt_neg_363 = V7 INTERACT (OR M7_NET_vol_lt_neg_363 M8_NET_vol_lt_neg_363)
// 
// < -2.75 negetive voltage NETID
// 
M1_NETID_vol_lt_neg_275 = DFM PROPERTY M1_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -2.75
M2_NETID_vol_lt_neg_275 = DFM PROPERTY M2_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -2.75
M3_NETID_vol_lt_neg_275 = DFM PROPERTY M3_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -2.75
M4_NETID_vol_lt_neg_275 = DFM PROPERTY M4_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -2.75
M5_NETID_vol_lt_neg_275 = DFM PROPERTY M5_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -2.75
M6_NETID_vol_lt_neg_275 = DFM PROPERTY M6_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -2.75
M7_NETID_vol_lt_neg_275 = DFM PROPERTY M7_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -2.75
M8_NETID_vol_lt_neg_275 = DFM PROPERTY M8_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -2.75
// 
M1_NET_vol_lt_neg_275 = NET AREA RATIO M1 M1_NETID_vol_lt_neg_275 > 0
M2_NET_vol_lt_neg_275 = NET AREA RATIO M2 M2_NETID_vol_lt_neg_275 > 0
M3_NET_vol_lt_neg_275 = NET AREA RATIO M3 M3_NETID_vol_lt_neg_275 > 0
M4_NET_vol_lt_neg_275 = NET AREA RATIO M4 M4_NETID_vol_lt_neg_275 > 0
M5_NET_vol_lt_neg_275 = NET AREA RATIO M5 M5_NETID_vol_lt_neg_275 > 0
M6_NET_vol_lt_neg_275 = NET AREA RATIO M6 M6_NETID_vol_lt_neg_275 > 0
M7_NET_vol_lt_neg_275 = NET AREA RATIO M7 M7_NETID_vol_lt_neg_275 > 0
M8_NET_vol_lt_neg_275 = NET AREA RATIO M8 M8_NETID_vol_lt_neg_275 > 0
// 
V1_NET_vol_lt_neg_275 = V1 INTERACT (OR M1_NET_vol_lt_neg_275 M2_NET_vol_lt_neg_275)
V2_NET_vol_lt_neg_275 = V2 INTERACT (OR M2_NET_vol_lt_neg_275 M3_NET_vol_lt_neg_275)
V3_NET_vol_lt_neg_275 = V3 INTERACT (OR M3_NET_vol_lt_neg_275 M4_NET_vol_lt_neg_275)
V4_NET_vol_lt_neg_275 = V4 INTERACT (OR M4_NET_vol_lt_neg_275 M5_NET_vol_lt_neg_275)
V5_NET_vol_lt_neg_275 = V5 INTERACT (OR M5_NET_vol_lt_neg_275 M6_NET_vol_lt_neg_275)
V6_NET_vol_lt_neg_275 = V6 INTERACT (OR M6_NET_vol_lt_neg_275 M7_NET_vol_lt_neg_275)
V7_NET_vol_lt_neg_275 = V7 INTERACT (OR M7_NET_vol_lt_neg_275 M8_NET_vol_lt_neg_275)
// 
// < -1.98 negetive voltage NETID
// 
M1_NETID_vol_lt_neg_198 = DFM PROPERTY M1_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -1.98
M2_NETID_vol_lt_neg_198 = DFM PROPERTY M2_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -1.98
M3_NETID_vol_lt_neg_198 = DFM PROPERTY M3_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -1.98
M4_NETID_vol_lt_neg_198 = DFM PROPERTY M4_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -1.98
M5_NETID_vol_lt_neg_198 = DFM PROPERTY M5_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -1.98
M6_NETID_vol_lt_neg_198 = DFM PROPERTY M6_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -1.98
M7_NETID_vol_lt_neg_198 = DFM PROPERTY M7_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -1.98
M8_NETID_vol_lt_neg_198 = DFM PROPERTY M8_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -1.98
// 
M1_NET_vol_lt_neg_198 = NET AREA RATIO M1 M1_NETID_vol_lt_neg_198 > 0
M2_NET_vol_lt_neg_198 = NET AREA RATIO M2 M2_NETID_vol_lt_neg_198 > 0
M3_NET_vol_lt_neg_198 = NET AREA RATIO M3 M3_NETID_vol_lt_neg_198 > 0
M4_NET_vol_lt_neg_198 = NET AREA RATIO M4 M4_NETID_vol_lt_neg_198 > 0
M5_NET_vol_lt_neg_198 = NET AREA RATIO M5 M5_NETID_vol_lt_neg_198 > 0
M6_NET_vol_lt_neg_198 = NET AREA RATIO M6 M6_NETID_vol_lt_neg_198 > 0
M7_NET_vol_lt_neg_198 = NET AREA RATIO M7 M7_NETID_vol_lt_neg_198 > 0
M8_NET_vol_lt_neg_198 = NET AREA RATIO M8 M8_NETID_vol_lt_neg_198 > 0
// 
V1_NET_vol_lt_neg_198 = V1 INTERACT (OR M1_NET_vol_lt_neg_198 M2_NET_vol_lt_neg_198)
V2_NET_vol_lt_neg_198 = V2 INTERACT (OR M2_NET_vol_lt_neg_198 M3_NET_vol_lt_neg_198)
V3_NET_vol_lt_neg_198 = V3 INTERACT (OR M3_NET_vol_lt_neg_198 M4_NET_vol_lt_neg_198)
V4_NET_vol_lt_neg_198 = V4 INTERACT (OR M4_NET_vol_lt_neg_198 M5_NET_vol_lt_neg_198)
V5_NET_vol_lt_neg_198 = V5 INTERACT (OR M5_NET_vol_lt_neg_198 M6_NET_vol_lt_neg_198)
V6_NET_vol_lt_neg_198 = V6 INTERACT (OR M6_NET_vol_lt_neg_198 M7_NET_vol_lt_neg_198)
V7_NET_vol_lt_neg_198 = V7 INTERACT (OR M7_NET_vol_lt_neg_198 M8_NET_vol_lt_neg_198)
// 
// < -1.65 negetive voltage NETID
// 
M1_NETID_vol_lt_neg_165 = DFM PROPERTY M1_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -1.65
M2_NETID_vol_lt_neg_165 = DFM PROPERTY M2_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -1.65
M3_NETID_vol_lt_neg_165 = DFM PROPERTY M3_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -1.65
M4_NETID_vol_lt_neg_165 = DFM PROPERTY M4_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -1.65
M5_NETID_vol_lt_neg_165 = DFM PROPERTY M5_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -1.65
M6_NETID_vol_lt_neg_165 = DFM PROPERTY M6_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -1.65
M7_NETID_vol_lt_neg_165 = DFM PROPERTY M7_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -1.65
M8_NETID_vol_lt_neg_165 = DFM PROPERTY M8_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -1.65
// 
M1_NET_vol_lt_neg_165 = NET AREA RATIO M1 M1_NETID_vol_lt_neg_165 > 0
M2_NET_vol_lt_neg_165 = NET AREA RATIO M2 M2_NETID_vol_lt_neg_165 > 0
M3_NET_vol_lt_neg_165 = NET AREA RATIO M3 M3_NETID_vol_lt_neg_165 > 0
M4_NET_vol_lt_neg_165 = NET AREA RATIO M4 M4_NETID_vol_lt_neg_165 > 0
M5_NET_vol_lt_neg_165 = NET AREA RATIO M5 M5_NETID_vol_lt_neg_165 > 0
M6_NET_vol_lt_neg_165 = NET AREA RATIO M6 M6_NETID_vol_lt_neg_165 > 0
M7_NET_vol_lt_neg_165 = NET AREA RATIO M7 M7_NETID_vol_lt_neg_165 > 0
M8_NET_vol_lt_neg_165 = NET AREA RATIO M8 M8_NETID_vol_lt_neg_165 > 0
// 
V1_NET_vol_lt_neg_165 = V1 INTERACT (OR M1_NET_vol_lt_neg_165 M2_NET_vol_lt_neg_165)
V2_NET_vol_lt_neg_165 = V2 INTERACT (OR M2_NET_vol_lt_neg_165 M3_NET_vol_lt_neg_165)
V3_NET_vol_lt_neg_165 = V3 INTERACT (OR M3_NET_vol_lt_neg_165 M4_NET_vol_lt_neg_165)
V4_NET_vol_lt_neg_165 = V4 INTERACT (OR M4_NET_vol_lt_neg_165 M5_NET_vol_lt_neg_165)
V5_NET_vol_lt_neg_165 = V5 INTERACT (OR M5_NET_vol_lt_neg_165 M6_NET_vol_lt_neg_165)
V6_NET_vol_lt_neg_165 = V6 INTERACT (OR M6_NET_vol_lt_neg_165 M7_NET_vol_lt_neg_165)
V7_NET_vol_lt_neg_165 = V7 INTERACT (OR M7_NET_vol_lt_neg_165 M8_NET_vol_lt_neg_165)
// 
// < -1.32 negetive voltage NETID
// 
M1_NETID_vol_lt_neg_132 = DFM PROPERTY M1_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -1.32
M2_NETID_vol_lt_neg_132 = DFM PROPERTY M2_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -1.32
M3_NETID_vol_lt_neg_132 = DFM PROPERTY M3_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -1.32
M4_NETID_vol_lt_neg_132 = DFM PROPERTY M4_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -1.32
M5_NETID_vol_lt_neg_132 = DFM PROPERTY M5_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -1.32
M6_NETID_vol_lt_neg_132 = DFM PROPERTY M6_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -1.32
M7_NETID_vol_lt_neg_132 = DFM PROPERTY M7_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -1.32
M8_NETID_vol_lt_neg_132 = DFM PROPERTY M8_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -1.32
// 
M1_NET_vol_lt_neg_132 = NET AREA RATIO M1 M1_NETID_vol_lt_neg_132 > 0
M2_NET_vol_lt_neg_132 = NET AREA RATIO M2 M2_NETID_vol_lt_neg_132 > 0
M3_NET_vol_lt_neg_132 = NET AREA RATIO M3 M3_NETID_vol_lt_neg_132 > 0
M4_NET_vol_lt_neg_132 = NET AREA RATIO M4 M4_NETID_vol_lt_neg_132 > 0
M5_NET_vol_lt_neg_132 = NET AREA RATIO M5 M5_NETID_vol_lt_neg_132 > 0
M6_NET_vol_lt_neg_132 = NET AREA RATIO M6 M6_NETID_vol_lt_neg_132 > 0
M7_NET_vol_lt_neg_132 = NET AREA RATIO M7 M7_NETID_vol_lt_neg_132 > 0
M8_NET_vol_lt_neg_132 = NET AREA RATIO M8 M8_NETID_vol_lt_neg_132 > 0
// 
V1_NET_vol_lt_neg_132 = V1 INTERACT (OR M1_NET_vol_lt_neg_132 M2_NET_vol_lt_neg_132)
V2_NET_vol_lt_neg_132 = V2 INTERACT (OR M2_NET_vol_lt_neg_132 M3_NET_vol_lt_neg_132)
V3_NET_vol_lt_neg_132 = V3 INTERACT (OR M3_NET_vol_lt_neg_132 M4_NET_vol_lt_neg_132)
V4_NET_vol_lt_neg_132 = V4 INTERACT (OR M4_NET_vol_lt_neg_132 M5_NET_vol_lt_neg_132)
V5_NET_vol_lt_neg_132 = V5 INTERACT (OR M5_NET_vol_lt_neg_132 M6_NET_vol_lt_neg_132)
V6_NET_vol_lt_neg_132 = V6 INTERACT (OR M6_NET_vol_lt_neg_132 M7_NET_vol_lt_neg_132)
V7_NET_vol_lt_neg_132 = V7 INTERACT (OR M7_NET_vol_lt_neg_132 M8_NET_vol_lt_neg_132)
// 
// < -1.155 negetive voltage NETID
// 
M1_NETID_vol_lt_neg_1155 = DFM PROPERTY M1_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -1.155
M2_NETID_vol_lt_neg_1155 = DFM PROPERTY M2_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -1.155
M3_NETID_vol_lt_neg_1155 = DFM PROPERTY M3_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -1.155
M4_NETID_vol_lt_neg_1155 = DFM PROPERTY M4_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -1.155
M5_NETID_vol_lt_neg_1155 = DFM PROPERTY M5_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -1.155
M6_NETID_vol_lt_neg_1155 = DFM PROPERTY M6_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -1.155
M7_NETID_vol_lt_neg_1155 = DFM PROPERTY M7_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -1.155
M8_NETID_vol_lt_neg_1155 = DFM PROPERTY M8_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -1.155
// 
M1_NET_vol_lt_neg_1155 = NET AREA RATIO M1 M1_NETID_vol_lt_neg_1155 > 0
M2_NET_vol_lt_neg_1155 = NET AREA RATIO M2 M2_NETID_vol_lt_neg_1155 > 0
M3_NET_vol_lt_neg_1155 = NET AREA RATIO M3 M3_NETID_vol_lt_neg_1155 > 0
M4_NET_vol_lt_neg_1155 = NET AREA RATIO M4 M4_NETID_vol_lt_neg_1155 > 0
M5_NET_vol_lt_neg_1155 = NET AREA RATIO M5 M5_NETID_vol_lt_neg_1155 > 0
M6_NET_vol_lt_neg_1155 = NET AREA RATIO M6 M6_NETID_vol_lt_neg_1155 > 0
M7_NET_vol_lt_neg_1155 = NET AREA RATIO M7 M7_NETID_vol_lt_neg_1155 > 0
M8_NET_vol_lt_neg_1155 = NET AREA RATIO M8 M8_NETID_vol_lt_neg_1155 > 0
// 
V1_NET_vol_lt_neg_1155 = V1 INTERACT (OR M1_NET_vol_lt_neg_1155 M2_NET_vol_lt_neg_1155)
V2_NET_vol_lt_neg_1155 = V2 INTERACT (OR M2_NET_vol_lt_neg_1155 M3_NET_vol_lt_neg_1155)
V3_NET_vol_lt_neg_1155 = V3 INTERACT (OR M3_NET_vol_lt_neg_1155 M4_NET_vol_lt_neg_1155)
V4_NET_vol_lt_neg_1155 = V4 INTERACT (OR M4_NET_vol_lt_neg_1155 M5_NET_vol_lt_neg_1155)
V5_NET_vol_lt_neg_1155 = V5 INTERACT (OR M5_NET_vol_lt_neg_1155 M6_NET_vol_lt_neg_1155)
V6_NET_vol_lt_neg_1155 = V6 INTERACT (OR M6_NET_vol_lt_neg_1155 M7_NET_vol_lt_neg_1155)
V7_NET_vol_lt_neg_1155 = V7 INTERACT (OR M7_NET_vol_lt_neg_1155 M8_NET_vol_lt_neg_1155)
// 
// < -1.1 negetive voltage NETID
// 
M1_NETID_vol_lt_neg_110 = DFM PROPERTY M1_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -1.1
M2_NETID_vol_lt_neg_110 = DFM PROPERTY M2_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -1.1
M3_NETID_vol_lt_neg_110 = DFM PROPERTY M3_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -1.1
M4_NETID_vol_lt_neg_110 = DFM PROPERTY M4_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -1.1
M5_NETID_vol_lt_neg_110 = DFM PROPERTY M5_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -1.1
M6_NETID_vol_lt_neg_110 = DFM PROPERTY M6_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -1.1
M7_NETID_vol_lt_neg_110 = DFM PROPERTY M7_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -1.1
M8_NETID_vol_lt_neg_110 = DFM PROPERTY M8_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -1.1
// 
M1_NET_vol_lt_neg_110 = NET AREA RATIO M1 M1_NETID_vol_lt_neg_110 > 0
M2_NET_vol_lt_neg_110 = NET AREA RATIO M2 M2_NETID_vol_lt_neg_110 > 0
M3_NET_vol_lt_neg_110 = NET AREA RATIO M3 M3_NETID_vol_lt_neg_110 > 0
M4_NET_vol_lt_neg_110 = NET AREA RATIO M4 M4_NETID_vol_lt_neg_110 > 0
M5_NET_vol_lt_neg_110 = NET AREA RATIO M5 M5_NETID_vol_lt_neg_110 > 0
M6_NET_vol_lt_neg_110 = NET AREA RATIO M6 M6_NETID_vol_lt_neg_110 > 0
M7_NET_vol_lt_neg_110 = NET AREA RATIO M7 M7_NETID_vol_lt_neg_110 > 0
M8_NET_vol_lt_neg_110 = NET AREA RATIO M8 M8_NETID_vol_lt_neg_110 > 0
// 
V1_NET_vol_lt_neg_110 = V1 INTERACT (OR M1_NET_vol_lt_neg_110 M2_NET_vol_lt_neg_110)
V2_NET_vol_lt_neg_110 = V2 INTERACT (OR M2_NET_vol_lt_neg_110 M3_NET_vol_lt_neg_110)
V3_NET_vol_lt_neg_110 = V3 INTERACT (OR M3_NET_vol_lt_neg_110 M4_NET_vol_lt_neg_110)
V4_NET_vol_lt_neg_110 = V4 INTERACT (OR M4_NET_vol_lt_neg_110 M5_NET_vol_lt_neg_110)
V5_NET_vol_lt_neg_110 = V5 INTERACT (OR M5_NET_vol_lt_neg_110 M6_NET_vol_lt_neg_110)
V6_NET_vol_lt_neg_110 = V6 INTERACT (OR M6_NET_vol_lt_neg_110 M7_NET_vol_lt_neg_110)
V7_NET_vol_lt_neg_110 = V7 INTERACT (OR M7_NET_vol_lt_neg_110 M8_NET_vol_lt_neg_110)
// 
// < -1.05 negetive voltage NETID
// 
M1_NETID_vol_lt_neg_105 = DFM PROPERTY M1_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -1.05
M2_NETID_vol_lt_neg_105 = DFM PROPERTY M2_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -1.05
M3_NETID_vol_lt_neg_105 = DFM PROPERTY M3_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -1.05
M4_NETID_vol_lt_neg_105 = DFM PROPERTY M4_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -1.05
M5_NETID_vol_lt_neg_105 = DFM PROPERTY M5_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -1.05
M6_NETID_vol_lt_neg_105 = DFM PROPERTY M6_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -1.05
M7_NETID_vol_lt_neg_105 = DFM PROPERTY M7_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -1.05
M8_NETID_vol_lt_neg_105 = DFM PROPERTY M8_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -1.05
// 
M1_NET_vol_lt_neg_105 = NET AREA RATIO M1 M1_NETID_vol_lt_neg_105 > 0
M2_NET_vol_lt_neg_105 = NET AREA RATIO M2 M2_NETID_vol_lt_neg_105 > 0
M3_NET_vol_lt_neg_105 = NET AREA RATIO M3 M3_NETID_vol_lt_neg_105 > 0
M4_NET_vol_lt_neg_105 = NET AREA RATIO M4 M4_NETID_vol_lt_neg_105 > 0
M5_NET_vol_lt_neg_105 = NET AREA RATIO M5 M5_NETID_vol_lt_neg_105 > 0
M6_NET_vol_lt_neg_105 = NET AREA RATIO M6 M6_NETID_vol_lt_neg_105 > 0
M7_NET_vol_lt_neg_105 = NET AREA RATIO M7 M7_NETID_vol_lt_neg_105 > 0
M8_NET_vol_lt_neg_105 = NET AREA RATIO M8 M8_NETID_vol_lt_neg_105 > 0
// 
V1_NET_vol_lt_neg_105 = V1 INTERACT (OR M1_NET_vol_lt_neg_105 M2_NET_vol_lt_neg_105)
V2_NET_vol_lt_neg_105 = V2 INTERACT (OR M2_NET_vol_lt_neg_105 M3_NET_vol_lt_neg_105)
V3_NET_vol_lt_neg_105 = V3 INTERACT (OR M3_NET_vol_lt_neg_105 M4_NET_vol_lt_neg_105)
V4_NET_vol_lt_neg_105 = V4 INTERACT (OR M4_NET_vol_lt_neg_105 M5_NET_vol_lt_neg_105)
V5_NET_vol_lt_neg_105 = V5 INTERACT (OR M5_NET_vol_lt_neg_105 M6_NET_vol_lt_neg_105)
V6_NET_vol_lt_neg_105 = V6 INTERACT (OR M6_NET_vol_lt_neg_105 M7_NET_vol_lt_neg_105)
V7_NET_vol_lt_neg_105 = V7 INTERACT (OR M7_NET_vol_lt_neg_105 M8_NET_vol_lt_neg_105)
// 
// < -1.0 negetive voltage NETID
// 
M1_NETID_vol_lt_neg_100 = DFM PROPERTY M1_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -1.0
M2_NETID_vol_lt_neg_100 = DFM PROPERTY M2_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -1.0
M3_NETID_vol_lt_neg_100 = DFM PROPERTY M3_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -1.0
M4_NETID_vol_lt_neg_100 = DFM PROPERTY M4_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -1.0
M5_NETID_vol_lt_neg_100 = DFM PROPERTY M5_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -1.0
M6_NETID_vol_lt_neg_100 = DFM PROPERTY M6_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -1.0
M7_NETID_vol_lt_neg_100 = DFM PROPERTY M7_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -1.0
M8_NETID_vol_lt_neg_100 = DFM PROPERTY M8_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -1.0
// 
M1_NET_vol_lt_neg_100 = NET AREA RATIO M1 M1_NETID_vol_lt_neg_100 > 0
M2_NET_vol_lt_neg_100 = NET AREA RATIO M2 M2_NETID_vol_lt_neg_100 > 0
M3_NET_vol_lt_neg_100 = NET AREA RATIO M3 M3_NETID_vol_lt_neg_100 > 0
M4_NET_vol_lt_neg_100 = NET AREA RATIO M4 M4_NETID_vol_lt_neg_100 > 0
M5_NET_vol_lt_neg_100 = NET AREA RATIO M5 M5_NETID_vol_lt_neg_100 > 0
M6_NET_vol_lt_neg_100 = NET AREA RATIO M6 M6_NETID_vol_lt_neg_100 > 0
M7_NET_vol_lt_neg_100 = NET AREA RATIO M7 M7_NETID_vol_lt_neg_100 > 0
M8_NET_vol_lt_neg_100 = NET AREA RATIO M8 M8_NETID_vol_lt_neg_100 > 0
// 
V1_NET_vol_lt_neg_100 = V1 INTERACT (OR M1_NET_vol_lt_neg_100 M2_NET_vol_lt_neg_100)
V2_NET_vol_lt_neg_100 = V2 INTERACT (OR M2_NET_vol_lt_neg_100 M3_NET_vol_lt_neg_100)
V3_NET_vol_lt_neg_100 = V3 INTERACT (OR M3_NET_vol_lt_neg_100 M4_NET_vol_lt_neg_100)
V4_NET_vol_lt_neg_100 = V4 INTERACT (OR M4_NET_vol_lt_neg_100 M5_NET_vol_lt_neg_100)
V5_NET_vol_lt_neg_100 = V5 INTERACT (OR M5_NET_vol_lt_neg_100 M6_NET_vol_lt_neg_100)
V6_NET_vol_lt_neg_100 = V6 INTERACT (OR M6_NET_vol_lt_neg_100 M7_NET_vol_lt_neg_100)
V7_NET_vol_lt_neg_100 = V7 INTERACT (OR M7_NET_vol_lt_neg_100 M8_NET_vol_lt_neg_100)
// 
// < -0.935 negetive voltage NETID
// 
M1_NETID_vol_lt_neg_0935 = DFM PROPERTY M1_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -0.935
M2_NETID_vol_lt_neg_0935 = DFM PROPERTY M2_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -0.935
M3_NETID_vol_lt_neg_0935 = DFM PROPERTY M3_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -0.935
M4_NETID_vol_lt_neg_0935 = DFM PROPERTY M4_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -0.935
M5_NETID_vol_lt_neg_0935 = DFM PROPERTY M5_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -0.935
M6_NETID_vol_lt_neg_0935 = DFM PROPERTY M6_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -0.935
M7_NETID_vol_lt_neg_0935 = DFM PROPERTY M7_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -0.935
M8_NETID_vol_lt_neg_0935 = DFM PROPERTY M8_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -0.935
// 
M1_NET_vol_lt_neg_0935 = NET AREA RATIO M1 M1_NETID_vol_lt_neg_0935 > 0
M2_NET_vol_lt_neg_0935 = NET AREA RATIO M2 M2_NETID_vol_lt_neg_0935 > 0
M3_NET_vol_lt_neg_0935 = NET AREA RATIO M3 M3_NETID_vol_lt_neg_0935 > 0
M4_NET_vol_lt_neg_0935 = NET AREA RATIO M4 M4_NETID_vol_lt_neg_0935 > 0
M5_NET_vol_lt_neg_0935 = NET AREA RATIO M5 M5_NETID_vol_lt_neg_0935 > 0
M6_NET_vol_lt_neg_0935 = NET AREA RATIO M6 M6_NETID_vol_lt_neg_0935 > 0
M7_NET_vol_lt_neg_0935 = NET AREA RATIO M7 M7_NETID_vol_lt_neg_0935 > 0
M8_NET_vol_lt_neg_0935 = NET AREA RATIO M8 M8_NETID_vol_lt_neg_0935 > 0
// 
V1_NET_vol_lt_neg_0935 = V1 INTERACT (OR M1_NET_vol_lt_neg_0935 M2_NET_vol_lt_neg_0935)
V2_NET_vol_lt_neg_0935 = V2 INTERACT (OR M2_NET_vol_lt_neg_0935 M3_NET_vol_lt_neg_0935)
V3_NET_vol_lt_neg_0935 = V3 INTERACT (OR M3_NET_vol_lt_neg_0935 M4_NET_vol_lt_neg_0935)
V4_NET_vol_lt_neg_0935 = V4 INTERACT (OR M4_NET_vol_lt_neg_0935 M5_NET_vol_lt_neg_0935)
V5_NET_vol_lt_neg_0935 = V5 INTERACT (OR M5_NET_vol_lt_neg_0935 M6_NET_vol_lt_neg_0935)
V6_NET_vol_lt_neg_0935 = V6 INTERACT (OR M6_NET_vol_lt_neg_0935 M7_NET_vol_lt_neg_0935)
V7_NET_vol_lt_neg_0935 = V7 INTERACT (OR M7_NET_vol_lt_neg_0935 M8_NET_vol_lt_neg_0935)
// 
// < -0.88 negetive voltage NETID
// 
M1_NETID_vol_lt_neg_088 = DFM PROPERTY M1_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -0.88
M2_NETID_vol_lt_neg_088 = DFM PROPERTY M2_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -0.88
M3_NETID_vol_lt_neg_088 = DFM PROPERTY M3_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -0.88
M4_NETID_vol_lt_neg_088 = DFM PROPERTY M4_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -0.88
M5_NETID_vol_lt_neg_088 = DFM PROPERTY M5_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -0.88
M6_NETID_vol_lt_neg_088 = DFM PROPERTY M6_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -0.88
M7_NETID_vol_lt_neg_088 = DFM PROPERTY M7_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -0.88
M8_NETID_vol_lt_neg_088 = DFM PROPERTY M8_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -0.88
// 
M1_NET_vol_lt_neg_088 = NET AREA RATIO M1 M1_NETID_vol_lt_neg_088 > 0
M2_NET_vol_lt_neg_088 = NET AREA RATIO M2 M2_NETID_vol_lt_neg_088 > 0
M3_NET_vol_lt_neg_088 = NET AREA RATIO M3 M3_NETID_vol_lt_neg_088 > 0
M4_NET_vol_lt_neg_088 = NET AREA RATIO M4 M4_NETID_vol_lt_neg_088 > 0
M5_NET_vol_lt_neg_088 = NET AREA RATIO M5 M5_NETID_vol_lt_neg_088 > 0
M6_NET_vol_lt_neg_088 = NET AREA RATIO M6 M6_NETID_vol_lt_neg_088 > 0
M7_NET_vol_lt_neg_088 = NET AREA RATIO M7 M7_NETID_vol_lt_neg_088 > 0
M8_NET_vol_lt_neg_088 = NET AREA RATIO M8 M8_NETID_vol_lt_neg_088 > 0
// 
V1_NET_vol_lt_neg_088 = V1 INTERACT (OR M1_NET_vol_lt_neg_088 M2_NET_vol_lt_neg_088)
V2_NET_vol_lt_neg_088 = V2 INTERACT (OR M2_NET_vol_lt_neg_088 M3_NET_vol_lt_neg_088)
V3_NET_vol_lt_neg_088 = V3 INTERACT (OR M3_NET_vol_lt_neg_088 M4_NET_vol_lt_neg_088)
V4_NET_vol_lt_neg_088 = V4 INTERACT (OR M4_NET_vol_lt_neg_088 M5_NET_vol_lt_neg_088)
V5_NET_vol_lt_neg_088 = V5 INTERACT (OR M5_NET_vol_lt_neg_088 M6_NET_vol_lt_neg_088)
V6_NET_vol_lt_neg_088 = V6 INTERACT (OR M6_NET_vol_lt_neg_088 M7_NET_vol_lt_neg_088)
V7_NET_vol_lt_neg_088 = V7 INTERACT (OR M7_NET_vol_lt_neg_088 M8_NET_vol_lt_neg_088)
// 
// < -5.599 negetive voltage NETID
AA_NETID_vol_lt_neg_560 = DFM PROPERTY AA_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -5.599
GT_NETID_vol_lt_neg_560 = DFM PROPERTY GT_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -5.599
M0_NETID_vol_lt_neg_560 = DFM PROPERTY M0_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -5.599
MG_NETID_vol_lt_neg_560 = DFM PROPERTY MG_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -5.599
PW_NETID_vol_lt_neg_560 = DFM PROPERTY PW_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -5.599
AA_NET_vol_lt_neg_560 = NET AREA RATIO AA_c AA_NETID_vol_lt_neg_560 > 0
GT_NET_vol_lt_neg_560 = NET AREA RATIO GT_0 GT_NETID_vol_lt_neg_560 > 0
MG_NET_vol_lt_neg_560 = NET AREA RATIO M0G MG_NETID_vol_lt_neg_560 > 0
M0_NET_vol_lt_neg_560 = NET AREA RATIO M0_NOT_M0C M0_NETID_vol_lt_neg_560 > 0
V0_NET_vol_lt_neg_560 = V0 INTERACT (OR M0_NET_vol_lt_neg_560 MG_NET_vol_lt_neg_560)
// 
// < -5.5 negetive voltage NETID
AA_NETID_vol_lt_neg_550 = DFM PROPERTY AA_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -5.5
GT_NETID_vol_lt_neg_550 = DFM PROPERTY GT_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -5.5
M0_NETID_vol_lt_neg_550 = DFM PROPERTY M0_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -5.5
MG_NETID_vol_lt_neg_550 = DFM PROPERTY MG_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -5.5
PW_NETID_vol_lt_neg_550 = DFM PROPERTY PW_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -5.5
AA_NET_vol_lt_neg_550 = NET AREA RATIO AA_c AA_NETID_vol_lt_neg_550 > 0
GT_NET_vol_lt_neg_550 = NET AREA RATIO GT_0 GT_NETID_vol_lt_neg_550 > 0
MG_NET_vol_lt_neg_550 = NET AREA RATIO M0G MG_NETID_vol_lt_neg_550 > 0
M0_NET_vol_lt_neg_550 = NET AREA RATIO M0_NOT_M0C M0_NETID_vol_lt_neg_550 > 0
V0_NET_vol_lt_neg_550 = V0 INTERACT (OR M0_NET_vol_lt_neg_550 MG_NET_vol_lt_neg_550)
// 
// < -3.63 negetive voltage NETID
AA_NETID_vol_lt_neg_363 = DFM PROPERTY AA_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -3.63
GT_NETID_vol_lt_neg_363 = DFM PROPERTY GT_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -3.63
M0_NETID_vol_lt_neg_363 = DFM PROPERTY M0_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -3.63
MG_NETID_vol_lt_neg_363 = DFM PROPERTY MG_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -3.63
PW_NETID_vol_lt_neg_363 = DFM PROPERTY PW_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -3.63
AA_NET_vol_lt_neg_363 = NET AREA RATIO AA_c AA_NETID_vol_lt_neg_363 > 0
GT_NET_vol_lt_neg_363 = NET AREA RATIO GT_0 GT_NETID_vol_lt_neg_363 > 0
MG_NET_vol_lt_neg_363 = NET AREA RATIO M0G MG_NETID_vol_lt_neg_363 > 0
M0_NET_vol_lt_neg_363 = NET AREA RATIO M0_NOT_M0C M0_NETID_vol_lt_neg_363 > 0
V0_NET_vol_lt_neg_363 = V0 INTERACT (OR M0_NET_vol_lt_neg_363 MG_NET_vol_lt_neg_363)
// 
// < -2.75 negetive voltage NETID
AA_NETID_vol_lt_neg_275 = DFM PROPERTY AA_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -2.75
GT_NETID_vol_lt_neg_275 = DFM PROPERTY GT_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -2.75
M0_NETID_vol_lt_neg_275 = DFM PROPERTY M0_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -2.75
MG_NETID_vol_lt_neg_275 = DFM PROPERTY MG_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -2.75
PW_NETID_vol_lt_neg_275 = DFM PROPERTY PW_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -2.75
AA_NET_vol_lt_neg_275 = NET AREA RATIO AA_c AA_NETID_vol_lt_neg_275 > 0
GT_NET_vol_lt_neg_275 = NET AREA RATIO GT_0 GT_NETID_vol_lt_neg_275 > 0
MG_NET_vol_lt_neg_275 = NET AREA RATIO M0G MG_NETID_vol_lt_neg_275 > 0
M0_NET_vol_lt_neg_275 = NET AREA RATIO M0_NOT_M0C M0_NETID_vol_lt_neg_275 > 0
V0_NET_vol_lt_neg_275 = V0 INTERACT (OR M0_NET_vol_lt_neg_275 MG_NET_vol_lt_neg_275)
// 
// < -1.98 negetive voltage NETID
AA_NETID_vol_lt_neg_198 = DFM PROPERTY AA_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -1.98
GT_NETID_vol_lt_neg_198 = DFM PROPERTY GT_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -1.98
M0_NETID_vol_lt_neg_198 = DFM PROPERTY M0_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -1.98
MG_NETID_vol_lt_neg_198 = DFM PROPERTY MG_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -1.98
PW_NETID_vol_lt_neg_198 = DFM PROPERTY PW_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -1.98
AA_NET_vol_lt_neg_198 = NET AREA RATIO AA_c AA_NETID_vol_lt_neg_198 > 0
GT_NET_vol_lt_neg_198 = NET AREA RATIO GT_0 GT_NETID_vol_lt_neg_198 > 0
MG_NET_vol_lt_neg_198 = NET AREA RATIO M0G MG_NETID_vol_lt_neg_198 > 0
M0_NET_vol_lt_neg_198 = NET AREA RATIO M0_NOT_M0C M0_NETID_vol_lt_neg_198 > 0
V0_NET_vol_lt_neg_198 = V0 INTERACT (OR M0_NET_vol_lt_neg_198 MG_NET_vol_lt_neg_198)
// 
// < -1.65 negetive voltage NETID
AA_NETID_vol_lt_neg_165 = DFM PROPERTY AA_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -1.65
GT_NETID_vol_lt_neg_165 = DFM PROPERTY GT_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -1.65
M0_NETID_vol_lt_neg_165 = DFM PROPERTY M0_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -1.65
MG_NETID_vol_lt_neg_165 = DFM PROPERTY MG_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -1.65
PW_NETID_vol_lt_neg_165 = DFM PROPERTY PW_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -1.65
AA_NET_vol_lt_neg_165 = NET AREA RATIO AA_c AA_NETID_vol_lt_neg_165 > 0
GT_NET_vol_lt_neg_165 = NET AREA RATIO GT_0 GT_NETID_vol_lt_neg_165 > 0
MG_NET_vol_lt_neg_165 = NET AREA RATIO M0G MG_NETID_vol_lt_neg_165 > 0
M0_NET_vol_lt_neg_165 = NET AREA RATIO M0_NOT_M0C M0_NETID_vol_lt_neg_165 > 0
V0_NET_vol_lt_neg_165 = V0 INTERACT (OR M0_NET_vol_lt_neg_165 MG_NET_vol_lt_neg_165)
// 
// < -1.32 negetive voltage NETID
AA_NETID_vol_lt_neg_132 = DFM PROPERTY AA_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -1.32
GT_NETID_vol_lt_neg_132 = DFM PROPERTY GT_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -1.32
M0_NETID_vol_lt_neg_132 = DFM PROPERTY M0_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -1.32
MG_NETID_vol_lt_neg_132 = DFM PROPERTY MG_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -1.32
PW_NETID_vol_lt_neg_132 = DFM PROPERTY PW_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -1.32
AA_NET_vol_lt_neg_132 = NET AREA RATIO AA_c AA_NETID_vol_lt_neg_132 > 0
GT_NET_vol_lt_neg_132 = NET AREA RATIO GT_0 GT_NETID_vol_lt_neg_132 > 0
MG_NET_vol_lt_neg_132 = NET AREA RATIO M0G MG_NETID_vol_lt_neg_132 > 0
M0_NET_vol_lt_neg_132 = NET AREA RATIO M0_NOT_M0C M0_NETID_vol_lt_neg_132 > 0
V0_NET_vol_lt_neg_132 = V0 INTERACT (OR M0_NET_vol_lt_neg_132 MG_NET_vol_lt_neg_132)
// 
// < -1.155 negetive voltage NETID
AA_NETID_vol_lt_neg_1155 = DFM PROPERTY AA_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -1.155
GT_NETID_vol_lt_neg_1155 = DFM PROPERTY GT_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -1.155
M0_NETID_vol_lt_neg_1155 = DFM PROPERTY M0_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -1.155
MG_NETID_vol_lt_neg_1155 = DFM PROPERTY MG_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -1.155
PW_NETID_vol_lt_neg_1155 = DFM PROPERTY PW_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -1.155
AA_NET_vol_lt_neg_1155 = NET AREA RATIO AA_c AA_NETID_vol_lt_neg_1155 > 0
GT_NET_vol_lt_neg_1155 = NET AREA RATIO GT_0 GT_NETID_vol_lt_neg_1155 > 0
MG_NET_vol_lt_neg_1155 = NET AREA RATIO M0G MG_NETID_vol_lt_neg_1155 > 0
M0_NET_vol_lt_neg_1155 = NET AREA RATIO M0_NOT_M0C M0_NETID_vol_lt_neg_1155 > 0
V0_NET_vol_lt_neg_1155 = V0 INTERACT (OR M0_NET_vol_lt_neg_1155 MG_NET_vol_lt_neg_1155)
// 
// < -1.1 negetive voltage NETID
AA_NETID_vol_lt_neg_110 = DFM PROPERTY AA_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -1.1
GT_NETID_vol_lt_neg_110 = DFM PROPERTY GT_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -1.1
M0_NETID_vol_lt_neg_110 = DFM PROPERTY M0_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -1.1
MG_NETID_vol_lt_neg_110 = DFM PROPERTY MG_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -1.1
PW_NETID_vol_lt_neg_110 = DFM PROPERTY PW_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -1.1
AA_NET_vol_lt_neg_110 = NET AREA RATIO AA_c AA_NETID_vol_lt_neg_110 > 0
GT_NET_vol_lt_neg_110 = NET AREA RATIO GT_0 GT_NETID_vol_lt_neg_110 > 0
MG_NET_vol_lt_neg_110 = NET AREA RATIO M0G MG_NETID_vol_lt_neg_110 > 0
M0_NET_vol_lt_neg_110 = NET AREA RATIO M0_NOT_M0C M0_NETID_vol_lt_neg_110 > 0
V0_NET_vol_lt_neg_110 = V0 INTERACT (OR M0_NET_vol_lt_neg_110 MG_NET_vol_lt_neg_110)
// 
// < -1.05 negetive voltage NETID
AA_NETID_vol_lt_neg_105 = DFM PROPERTY AA_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -1.05
GT_NETID_vol_lt_neg_105 = DFM PROPERTY GT_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -1.05
M0_NETID_vol_lt_neg_105 = DFM PROPERTY M0_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -1.05
MG_NETID_vol_lt_neg_105 = DFM PROPERTY MG_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -1.05
PW_NETID_vol_lt_neg_105 = DFM PROPERTY PW_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -1.05
AA_NET_vol_lt_neg_105 = NET AREA RATIO AA_c AA_NETID_vol_lt_neg_105 > 0
GT_NET_vol_lt_neg_105 = NET AREA RATIO GT_0 GT_NETID_vol_lt_neg_105 > 0
MG_NET_vol_lt_neg_105 = NET AREA RATIO M0G MG_NETID_vol_lt_neg_105 > 0
M0_NET_vol_lt_neg_105 = NET AREA RATIO M0_NOT_M0C M0_NETID_vol_lt_neg_105 > 0
V0_NET_vol_lt_neg_105 = V0 INTERACT (OR M0_NET_vol_lt_neg_105 MG_NET_vol_lt_neg_105)
// 
// < -1.0 negetive voltage NETID
AA_NETID_vol_lt_neg_100 = DFM PROPERTY AA_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -1.0
GT_NETID_vol_lt_neg_100 = DFM PROPERTY GT_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -1.0
M0_NETID_vol_lt_neg_100 = DFM PROPERTY M0_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -1.0
MG_NETID_vol_lt_neg_100 = DFM PROPERTY MG_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -1.0
PW_NETID_vol_lt_neg_100 = DFM PROPERTY PW_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -1.0
AA_NET_vol_lt_neg_100 = NET AREA RATIO AA_c AA_NETID_vol_lt_neg_100 > 0
GT_NET_vol_lt_neg_100 = NET AREA RATIO GT_0 GT_NETID_vol_lt_neg_100 > 0
MG_NET_vol_lt_neg_100 = NET AREA RATIO M0G MG_NETID_vol_lt_neg_100 > 0
M0_NET_vol_lt_neg_100 = NET AREA RATIO M0_NOT_M0C M0_NETID_vol_lt_neg_100 > 0
V0_NET_vol_lt_neg_100 = V0 INTERACT (OR M0_NET_vol_lt_neg_100 MG_NET_vol_lt_neg_100)
// 
// < -0.935 negetive voltage NETID
AA_NETID_vol_lt_neg_0935 = DFM PROPERTY AA_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -0.935
GT_NETID_vol_lt_neg_0935 = DFM PROPERTY GT_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -0.935
M0_NETID_vol_lt_neg_0935 = DFM PROPERTY M0_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -0.935
MG_NETID_vol_lt_neg_0935 = DFM PROPERTY MG_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -0.935
PW_NETID_vol_lt_neg_0935 = DFM PROPERTY PW_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -0.935
AA_NET_vol_lt_neg_0935 = NET AREA RATIO AA_c AA_NETID_vol_lt_neg_0935 > 0
GT_NET_vol_lt_neg_0935 = NET AREA RATIO GT_0 GT_NETID_vol_lt_neg_0935 > 0
MG_NET_vol_lt_neg_0935 = NET AREA RATIO M0G MG_NETID_vol_lt_neg_0935 > 0
M0_NET_vol_lt_neg_0935 = NET AREA RATIO M0_NOT_M0C M0_NETID_vol_lt_neg_0935 > 0
V0_NET_vol_lt_neg_0935 = V0 INTERACT (OR M0_NET_vol_lt_neg_0935 MG_NET_vol_lt_neg_0935)
// 
// < -0.88 negetive voltage NETID
AA_NETID_vol_lt_neg_088 = DFM PROPERTY AA_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -0.88
GT_NETID_vol_lt_neg_088 = DFM PROPERTY GT_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -0.88
M0_NETID_vol_lt_neg_088 = DFM PROPERTY M0_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -0.88
MG_NETID_vol_lt_neg_088 = DFM PROPERTY MG_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -0.88
PW_NETID_vol_lt_neg_088 = DFM PROPERTY PW_NETID_rdm net_vol_assign NODAL MULTI [neg = property(net_vol_assign, min_vol)] < -0.88
AA_NET_vol_lt_neg_088 = NET AREA RATIO AA_c AA_NETID_vol_lt_neg_088 > 0
GT_NET_vol_lt_neg_088 = NET AREA RATIO GT_0 GT_NETID_vol_lt_neg_088 > 0
MG_NET_vol_lt_neg_088 = NET AREA RATIO M0G MG_NETID_vol_lt_neg_088 > 0
M0_NET_vol_lt_neg_088 = NET AREA RATIO M0_NOT_M0C M0_NETID_vol_lt_neg_088 > 0
V0_NET_vol_lt_neg_088 = V0 INTERACT (OR M0_NET_vol_lt_neg_088 MG_NET_vol_lt_neg_088)

//;positive voltage NETID 

M1_NETID_vol_pos = DFM PROPERTY M1_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 0
M2_NETID_vol_pos = DFM PROPERTY M2_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 0
M3_NETID_vol_pos = DFM PROPERTY M3_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 0
M4_NETID_vol_pos = DFM PROPERTY M4_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 0
M5_NETID_vol_pos = DFM PROPERTY M5_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 0
M6_NETID_vol_pos = DFM PROPERTY M6_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 0
M7_NETID_vol_pos = DFM PROPERTY M7_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 0
M8_NETID_vol_pos = DFM PROPERTY M8_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 0

M1_NET_vol_pos = NET AREA RATIO M1 M1_NETID_vol_pos > 0
M2_NET_vol_pos = NET AREA RATIO M2 M2_NETID_vol_pos > 0
M3_NET_vol_pos = NET AREA RATIO M3 M3_NETID_vol_pos > 0
M4_NET_vol_pos = NET AREA RATIO M4 M4_NETID_vol_pos > 0
M5_NET_vol_pos = NET AREA RATIO M5 M5_NETID_vol_pos > 0
M6_NET_vol_pos = NET AREA RATIO M6 M6_NETID_vol_pos > 0
M7_NET_vol_pos = NET AREA RATIO M7 M7_NETID_vol_pos > 0
M8_NET_vol_pos = NET AREA RATIO M8 M8_NETID_vol_pos > 0

V1_NET_vol_pos = V1 INTERACT (OR M1_NET_vol_pos M2_NET_vol_pos)
V2_NET_vol_pos = V2 INTERACT (OR M2_NET_vol_pos M3_NET_vol_pos)
V3_NET_vol_pos = V3 INTERACT (OR M3_NET_vol_pos M4_NET_vol_pos)
V4_NET_vol_pos = V4 INTERACT (OR M4_NET_vol_pos M5_NET_vol_pos)
V5_NET_vol_pos = V5 INTERACT (OR M5_NET_vol_pos M6_NET_vol_pos)
V6_NET_vol_pos = V6 INTERACT (OR M6_NET_vol_pos M7_NET_vol_pos)
V7_NET_vol_pos = V7 INTERACT (OR M7_NET_vol_pos M8_NET_vol_pos)


AA_NETID_vol_pos = DFM PROPERTY AA_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 0
GT_NETID_vol_pos = DFM PROPERTY GT_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 0
M0_NETID_vol_pos = DFM PROPERTY M0_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 0
MG_NETID_vol_pos = DFM PROPERTY MG_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 0
//;NW_NETID_vol_pos = DFM PROPERTY NW_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 0
PW_NETID_vol_pos = DFM PROPERTY PW_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 0
AA_NET_vol_pos = NET AREA RATIO AA_c AA_NETID_vol_pos > 0
GT_NET_vol_pos = NET AREA RATIO GT_0 GT_NETID_vol_pos > 0
MG_NET_vol_pos = NET AREA RATIO M0G MG_NETID_vol_pos > 0
M0_NET_vol_pos = NET AREA RATIO M0_NOT_M0C M0_NETID_vol_pos > 0
V0_NET_vol_pos = V0 INTERACT (OR M0_NET_vol_pos MG_NET_vol_pos)

// 
// < 5.599 positive voltage NETID
// 
M1_NETID_vol_gt_pos_560 = DFM PROPERTY M1_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 5.599
M2_NETID_vol_gt_pos_560 = DFM PROPERTY M2_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 5.599
M3_NETID_vol_gt_pos_560 = DFM PROPERTY M3_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 5.599
M4_NETID_vol_gt_pos_560 = DFM PROPERTY M4_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 5.599
M5_NETID_vol_gt_pos_560 = DFM PROPERTY M5_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 5.599
M6_NETID_vol_gt_pos_560 = DFM PROPERTY M6_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 5.599
M7_NETID_vol_gt_pos_560 = DFM PROPERTY M7_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 5.599
M8_NETID_vol_gt_pos_560 = DFM PROPERTY M8_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 5.599
// 
M1_NET_vol_gt_pos_560 = NET AREA RATIO M1 M1_NETID_vol_gt_pos_560 > 0
M2_NET_vol_gt_pos_560 = NET AREA RATIO M2 M2_NETID_vol_gt_pos_560 > 0
M3_NET_vol_gt_pos_560 = NET AREA RATIO M3 M3_NETID_vol_gt_pos_560 > 0
M4_NET_vol_gt_pos_560 = NET AREA RATIO M4 M4_NETID_vol_gt_pos_560 > 0
M5_NET_vol_gt_pos_560 = NET AREA RATIO M5 M5_NETID_vol_gt_pos_560 > 0
M6_NET_vol_gt_pos_560 = NET AREA RATIO M6 M6_NETID_vol_gt_pos_560 > 0
M7_NET_vol_gt_pos_560 = NET AREA RATIO M7 M7_NETID_vol_gt_pos_560 > 0
M8_NET_vol_gt_pos_560 = NET AREA RATIO M8 M8_NETID_vol_gt_pos_560 > 0
// 
V1_NET_vol_gt_pos_560 = V1 INTERACT (OR M1_NET_vol_gt_pos_560 M2_NET_vol_gt_pos_560)
V2_NET_vol_gt_pos_560 = V2 INTERACT (OR M2_NET_vol_gt_pos_560 M3_NET_vol_gt_pos_560)
V3_NET_vol_gt_pos_560 = V3 INTERACT (OR M3_NET_vol_gt_pos_560 M4_NET_vol_gt_pos_560)
V4_NET_vol_gt_pos_560 = V4 INTERACT (OR M4_NET_vol_gt_pos_560 M5_NET_vol_gt_pos_560)
V5_NET_vol_gt_pos_560 = V5 INTERACT (OR M5_NET_vol_gt_pos_560 M6_NET_vol_gt_pos_560)
V6_NET_vol_gt_pos_560 = V6 INTERACT (OR M6_NET_vol_gt_pos_560 M7_NET_vol_gt_pos_560)
V7_NET_vol_gt_pos_560 = V7 INTERACT (OR M7_NET_vol_gt_pos_560 M8_NET_vol_gt_pos_560)
// 
// < 5.5 positive voltage NETID
// 
M1_NETID_vol_gt_pos_550 = DFM PROPERTY M1_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 5.5
M2_NETID_vol_gt_pos_550 = DFM PROPERTY M2_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 5.5
M3_NETID_vol_gt_pos_550 = DFM PROPERTY M3_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 5.5
M4_NETID_vol_gt_pos_550 = DFM PROPERTY M4_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 5.5
M5_NETID_vol_gt_pos_550 = DFM PROPERTY M5_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 5.5
M6_NETID_vol_gt_pos_550 = DFM PROPERTY M6_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 5.5
M7_NETID_vol_gt_pos_550 = DFM PROPERTY M7_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 5.5
M8_NETID_vol_gt_pos_550 = DFM PROPERTY M8_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 5.5
// 
M1_NET_vol_gt_pos_550 = NET AREA RATIO M1 M1_NETID_vol_gt_pos_550 > 0
M2_NET_vol_gt_pos_550 = NET AREA RATIO M2 M2_NETID_vol_gt_pos_550 > 0
M3_NET_vol_gt_pos_550 = NET AREA RATIO M3 M3_NETID_vol_gt_pos_550 > 0
M4_NET_vol_gt_pos_550 = NET AREA RATIO M4 M4_NETID_vol_gt_pos_550 > 0
M5_NET_vol_gt_pos_550 = NET AREA RATIO M5 M5_NETID_vol_gt_pos_550 > 0
M6_NET_vol_gt_pos_550 = NET AREA RATIO M6 M6_NETID_vol_gt_pos_550 > 0
M7_NET_vol_gt_pos_550 = NET AREA RATIO M7 M7_NETID_vol_gt_pos_550 > 0
M8_NET_vol_gt_pos_550 = NET AREA RATIO M8 M8_NETID_vol_gt_pos_550 > 0
// 
V1_NET_vol_gt_pos_550 = V1 INTERACT (OR M1_NET_vol_gt_pos_550 M2_NET_vol_gt_pos_550)
V2_NET_vol_gt_pos_550 = V2 INTERACT (OR M2_NET_vol_gt_pos_550 M3_NET_vol_gt_pos_550)
V3_NET_vol_gt_pos_550 = V3 INTERACT (OR M3_NET_vol_gt_pos_550 M4_NET_vol_gt_pos_550)
V4_NET_vol_gt_pos_550 = V4 INTERACT (OR M4_NET_vol_gt_pos_550 M5_NET_vol_gt_pos_550)
V5_NET_vol_gt_pos_550 = V5 INTERACT (OR M5_NET_vol_gt_pos_550 M6_NET_vol_gt_pos_550)
V6_NET_vol_gt_pos_550 = V6 INTERACT (OR M6_NET_vol_gt_pos_550 M7_NET_vol_gt_pos_550)
V7_NET_vol_gt_pos_550 = V7 INTERACT (OR M7_NET_vol_gt_pos_550 M8_NET_vol_gt_pos_550)
// 
// < 3.63 positive voltage NETID
// 
M1_NETID_vol_gt_pos_363 = DFM PROPERTY M1_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 3.63
M2_NETID_vol_gt_pos_363 = DFM PROPERTY M2_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 3.63
M3_NETID_vol_gt_pos_363 = DFM PROPERTY M3_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 3.63
M4_NETID_vol_gt_pos_363 = DFM PROPERTY M4_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 3.63
M5_NETID_vol_gt_pos_363 = DFM PROPERTY M5_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 3.63
M6_NETID_vol_gt_pos_363 = DFM PROPERTY M6_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 3.63
M7_NETID_vol_gt_pos_363 = DFM PROPERTY M7_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 3.63
M8_NETID_vol_gt_pos_363 = DFM PROPERTY M8_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 3.63
// 
M1_NET_vol_gt_pos_363 = NET AREA RATIO M1 M1_NETID_vol_gt_pos_363 > 0
M2_NET_vol_gt_pos_363 = NET AREA RATIO M2 M2_NETID_vol_gt_pos_363 > 0
M3_NET_vol_gt_pos_363 = NET AREA RATIO M3 M3_NETID_vol_gt_pos_363 > 0
M4_NET_vol_gt_pos_363 = NET AREA RATIO M4 M4_NETID_vol_gt_pos_363 > 0
M5_NET_vol_gt_pos_363 = NET AREA RATIO M5 M5_NETID_vol_gt_pos_363 > 0
M6_NET_vol_gt_pos_363 = NET AREA RATIO M6 M6_NETID_vol_gt_pos_363 > 0
M7_NET_vol_gt_pos_363 = NET AREA RATIO M7 M7_NETID_vol_gt_pos_363 > 0
M8_NET_vol_gt_pos_363 = NET AREA RATIO M8 M8_NETID_vol_gt_pos_363 > 0
// 
V1_NET_vol_gt_pos_363 = V1 INTERACT (OR M1_NET_vol_gt_pos_363 M2_NET_vol_gt_pos_363)
V2_NET_vol_gt_pos_363 = V2 INTERACT (OR M2_NET_vol_gt_pos_363 M3_NET_vol_gt_pos_363)
V3_NET_vol_gt_pos_363 = V3 INTERACT (OR M3_NET_vol_gt_pos_363 M4_NET_vol_gt_pos_363)
V4_NET_vol_gt_pos_363 = V4 INTERACT (OR M4_NET_vol_gt_pos_363 M5_NET_vol_gt_pos_363)
V5_NET_vol_gt_pos_363 = V5 INTERACT (OR M5_NET_vol_gt_pos_363 M6_NET_vol_gt_pos_363)
V6_NET_vol_gt_pos_363 = V6 INTERACT (OR M6_NET_vol_gt_pos_363 M7_NET_vol_gt_pos_363)
V7_NET_vol_gt_pos_363 = V7 INTERACT (OR M7_NET_vol_gt_pos_363 M8_NET_vol_gt_pos_363)
// 
// < 2.75 positive voltage NETID
// 
M1_NETID_vol_gt_pos_275 = DFM PROPERTY M1_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 2.75
M2_NETID_vol_gt_pos_275 = DFM PROPERTY M2_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 2.75
M3_NETID_vol_gt_pos_275 = DFM PROPERTY M3_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 2.75
M4_NETID_vol_gt_pos_275 = DFM PROPERTY M4_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 2.75
M5_NETID_vol_gt_pos_275 = DFM PROPERTY M5_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 2.75
M6_NETID_vol_gt_pos_275 = DFM PROPERTY M6_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 2.75
M7_NETID_vol_gt_pos_275 = DFM PROPERTY M7_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 2.75
M8_NETID_vol_gt_pos_275 = DFM PROPERTY M8_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 2.75
// 
M1_NET_vol_gt_pos_275 = NET AREA RATIO M1 M1_NETID_vol_gt_pos_275 > 0
M2_NET_vol_gt_pos_275 = NET AREA RATIO M2 M2_NETID_vol_gt_pos_275 > 0
M3_NET_vol_gt_pos_275 = NET AREA RATIO M3 M3_NETID_vol_gt_pos_275 > 0
M4_NET_vol_gt_pos_275 = NET AREA RATIO M4 M4_NETID_vol_gt_pos_275 > 0
M5_NET_vol_gt_pos_275 = NET AREA RATIO M5 M5_NETID_vol_gt_pos_275 > 0
M6_NET_vol_gt_pos_275 = NET AREA RATIO M6 M6_NETID_vol_gt_pos_275 > 0
M7_NET_vol_gt_pos_275 = NET AREA RATIO M7 M7_NETID_vol_gt_pos_275 > 0
M8_NET_vol_gt_pos_275 = NET AREA RATIO M8 M8_NETID_vol_gt_pos_275 > 0
// 
V1_NET_vol_gt_pos_275 = V1 INTERACT (OR M1_NET_vol_gt_pos_275 M2_NET_vol_gt_pos_275)
V2_NET_vol_gt_pos_275 = V2 INTERACT (OR M2_NET_vol_gt_pos_275 M3_NET_vol_gt_pos_275)
V3_NET_vol_gt_pos_275 = V3 INTERACT (OR M3_NET_vol_gt_pos_275 M4_NET_vol_gt_pos_275)
V4_NET_vol_gt_pos_275 = V4 INTERACT (OR M4_NET_vol_gt_pos_275 M5_NET_vol_gt_pos_275)
V5_NET_vol_gt_pos_275 = V5 INTERACT (OR M5_NET_vol_gt_pos_275 M6_NET_vol_gt_pos_275)
V6_NET_vol_gt_pos_275 = V6 INTERACT (OR M6_NET_vol_gt_pos_275 M7_NET_vol_gt_pos_275)
V7_NET_vol_gt_pos_275 = V7 INTERACT (OR M7_NET_vol_gt_pos_275 M8_NET_vol_gt_pos_275)
// 
// < 1.98 positive voltage NETID
// 
M1_NETID_vol_gt_pos_198 = DFM PROPERTY M1_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 1.98
M2_NETID_vol_gt_pos_198 = DFM PROPERTY M2_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 1.98
M3_NETID_vol_gt_pos_198 = DFM PROPERTY M3_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 1.98
M4_NETID_vol_gt_pos_198 = DFM PROPERTY M4_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 1.98
M5_NETID_vol_gt_pos_198 = DFM PROPERTY M5_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 1.98
M6_NETID_vol_gt_pos_198 = DFM PROPERTY M6_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 1.98
M7_NETID_vol_gt_pos_198 = DFM PROPERTY M7_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 1.98
M8_NETID_vol_gt_pos_198 = DFM PROPERTY M8_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 1.98
// 
M1_NET_vol_gt_pos_198 = NET AREA RATIO M1 M1_NETID_vol_gt_pos_198 > 0
M2_NET_vol_gt_pos_198 = NET AREA RATIO M2 M2_NETID_vol_gt_pos_198 > 0
M3_NET_vol_gt_pos_198 = NET AREA RATIO M3 M3_NETID_vol_gt_pos_198 > 0
M4_NET_vol_gt_pos_198 = NET AREA RATIO M4 M4_NETID_vol_gt_pos_198 > 0
M5_NET_vol_gt_pos_198 = NET AREA RATIO M5 M5_NETID_vol_gt_pos_198 > 0
M6_NET_vol_gt_pos_198 = NET AREA RATIO M6 M6_NETID_vol_gt_pos_198 > 0
M7_NET_vol_gt_pos_198 = NET AREA RATIO M7 M7_NETID_vol_gt_pos_198 > 0
M8_NET_vol_gt_pos_198 = NET AREA RATIO M8 M8_NETID_vol_gt_pos_198 > 0
// 
V1_NET_vol_gt_pos_198 = V1 INTERACT (OR M1_NET_vol_gt_pos_198 M2_NET_vol_gt_pos_198)
V2_NET_vol_gt_pos_198 = V2 INTERACT (OR M2_NET_vol_gt_pos_198 M3_NET_vol_gt_pos_198)
V3_NET_vol_gt_pos_198 = V3 INTERACT (OR M3_NET_vol_gt_pos_198 M4_NET_vol_gt_pos_198)
V4_NET_vol_gt_pos_198 = V4 INTERACT (OR M4_NET_vol_gt_pos_198 M5_NET_vol_gt_pos_198)
V5_NET_vol_gt_pos_198 = V5 INTERACT (OR M5_NET_vol_gt_pos_198 M6_NET_vol_gt_pos_198)
V6_NET_vol_gt_pos_198 = V6 INTERACT (OR M6_NET_vol_gt_pos_198 M7_NET_vol_gt_pos_198)
V7_NET_vol_gt_pos_198 = V7 INTERACT (OR M7_NET_vol_gt_pos_198 M8_NET_vol_gt_pos_198)
// 
// < 1.65 positive voltage NETID
// 
M1_NETID_vol_gt_pos_165 = DFM PROPERTY M1_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 1.65
M2_NETID_vol_gt_pos_165 = DFM PROPERTY M2_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 1.65
M3_NETID_vol_gt_pos_165 = DFM PROPERTY M3_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 1.65
M4_NETID_vol_gt_pos_165 = DFM PROPERTY M4_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 1.65
M5_NETID_vol_gt_pos_165 = DFM PROPERTY M5_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 1.65
M6_NETID_vol_gt_pos_165 = DFM PROPERTY M6_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 1.65
M7_NETID_vol_gt_pos_165 = DFM PROPERTY M7_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 1.65
M8_NETID_vol_gt_pos_165 = DFM PROPERTY M8_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 1.65
// 
M1_NET_vol_gt_pos_165 = NET AREA RATIO M1 M1_NETID_vol_gt_pos_165 > 0
M2_NET_vol_gt_pos_165 = NET AREA RATIO M2 M2_NETID_vol_gt_pos_165 > 0
M3_NET_vol_gt_pos_165 = NET AREA RATIO M3 M3_NETID_vol_gt_pos_165 > 0
M4_NET_vol_gt_pos_165 = NET AREA RATIO M4 M4_NETID_vol_gt_pos_165 > 0
M5_NET_vol_gt_pos_165 = NET AREA RATIO M5 M5_NETID_vol_gt_pos_165 > 0
M6_NET_vol_gt_pos_165 = NET AREA RATIO M6 M6_NETID_vol_gt_pos_165 > 0
M7_NET_vol_gt_pos_165 = NET AREA RATIO M7 M7_NETID_vol_gt_pos_165 > 0
M8_NET_vol_gt_pos_165 = NET AREA RATIO M8 M8_NETID_vol_gt_pos_165 > 0
// 
V1_NET_vol_gt_pos_165 = V1 INTERACT (OR M1_NET_vol_gt_pos_165 M2_NET_vol_gt_pos_165)
V2_NET_vol_gt_pos_165 = V2 INTERACT (OR M2_NET_vol_gt_pos_165 M3_NET_vol_gt_pos_165)
V3_NET_vol_gt_pos_165 = V3 INTERACT (OR M3_NET_vol_gt_pos_165 M4_NET_vol_gt_pos_165)
V4_NET_vol_gt_pos_165 = V4 INTERACT (OR M4_NET_vol_gt_pos_165 M5_NET_vol_gt_pos_165)
V5_NET_vol_gt_pos_165 = V5 INTERACT (OR M5_NET_vol_gt_pos_165 M6_NET_vol_gt_pos_165)
V6_NET_vol_gt_pos_165 = V6 INTERACT (OR M6_NET_vol_gt_pos_165 M7_NET_vol_gt_pos_165)
V7_NET_vol_gt_pos_165 = V7 INTERACT (OR M7_NET_vol_gt_pos_165 M8_NET_vol_gt_pos_165)
// 
// < 1.32 positive voltage NETID
// 
M1_NETID_vol_gt_pos_132 = DFM PROPERTY M1_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 1.32
M2_NETID_vol_gt_pos_132 = DFM PROPERTY M2_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 1.32
M3_NETID_vol_gt_pos_132 = DFM PROPERTY M3_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 1.32
M4_NETID_vol_gt_pos_132 = DFM PROPERTY M4_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 1.32
M5_NETID_vol_gt_pos_132 = DFM PROPERTY M5_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 1.32
M6_NETID_vol_gt_pos_132 = DFM PROPERTY M6_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 1.32
M7_NETID_vol_gt_pos_132 = DFM PROPERTY M7_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 1.32
M8_NETID_vol_gt_pos_132 = DFM PROPERTY M8_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 1.32
// 
M1_NET_vol_gt_pos_132 = NET AREA RATIO M1 M1_NETID_vol_gt_pos_132 > 0
M2_NET_vol_gt_pos_132 = NET AREA RATIO M2 M2_NETID_vol_gt_pos_132 > 0
M3_NET_vol_gt_pos_132 = NET AREA RATIO M3 M3_NETID_vol_gt_pos_132 > 0
M4_NET_vol_gt_pos_132 = NET AREA RATIO M4 M4_NETID_vol_gt_pos_132 > 0
M5_NET_vol_gt_pos_132 = NET AREA RATIO M5 M5_NETID_vol_gt_pos_132 > 0
M6_NET_vol_gt_pos_132 = NET AREA RATIO M6 M6_NETID_vol_gt_pos_132 > 0
M7_NET_vol_gt_pos_132 = NET AREA RATIO M7 M7_NETID_vol_gt_pos_132 > 0
M8_NET_vol_gt_pos_132 = NET AREA RATIO M8 M8_NETID_vol_gt_pos_132 > 0
// 
V1_NET_vol_gt_pos_132 = V1 INTERACT (OR M1_NET_vol_gt_pos_132 M2_NET_vol_gt_pos_132)
V2_NET_vol_gt_pos_132 = V2 INTERACT (OR M2_NET_vol_gt_pos_132 M3_NET_vol_gt_pos_132)
V3_NET_vol_gt_pos_132 = V3 INTERACT (OR M3_NET_vol_gt_pos_132 M4_NET_vol_gt_pos_132)
V4_NET_vol_gt_pos_132 = V4 INTERACT (OR M4_NET_vol_gt_pos_132 M5_NET_vol_gt_pos_132)
V5_NET_vol_gt_pos_132 = V5 INTERACT (OR M5_NET_vol_gt_pos_132 M6_NET_vol_gt_pos_132)
V6_NET_vol_gt_pos_132 = V6 INTERACT (OR M6_NET_vol_gt_pos_132 M7_NET_vol_gt_pos_132)
V7_NET_vol_gt_pos_132 = V7 INTERACT (OR M7_NET_vol_gt_pos_132 M8_NET_vol_gt_pos_132)
// 
// < 1.155 positive voltage NETID
// 
M1_NETID_vol_gt_pos_1155 = DFM PROPERTY M1_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 1.155
M2_NETID_vol_gt_pos_1155 = DFM PROPERTY M2_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 1.155
M3_NETID_vol_gt_pos_1155 = DFM PROPERTY M3_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 1.155
M4_NETID_vol_gt_pos_1155 = DFM PROPERTY M4_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 1.155
M5_NETID_vol_gt_pos_1155 = DFM PROPERTY M5_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 1.155
M6_NETID_vol_gt_pos_1155 = DFM PROPERTY M6_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 1.155
M7_NETID_vol_gt_pos_1155 = DFM PROPERTY M7_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 1.155
M8_NETID_vol_gt_pos_1155 = DFM PROPERTY M8_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 1.155
// 
M1_NET_vol_gt_pos_1155 = NET AREA RATIO M1 M1_NETID_vol_gt_pos_1155 > 0
M2_NET_vol_gt_pos_1155 = NET AREA RATIO M2 M2_NETID_vol_gt_pos_1155 > 0
M3_NET_vol_gt_pos_1155 = NET AREA RATIO M3 M3_NETID_vol_gt_pos_1155 > 0
M4_NET_vol_gt_pos_1155 = NET AREA RATIO M4 M4_NETID_vol_gt_pos_1155 > 0
M5_NET_vol_gt_pos_1155 = NET AREA RATIO M5 M5_NETID_vol_gt_pos_1155 > 0
M6_NET_vol_gt_pos_1155 = NET AREA RATIO M6 M6_NETID_vol_gt_pos_1155 > 0
M7_NET_vol_gt_pos_1155 = NET AREA RATIO M7 M7_NETID_vol_gt_pos_1155 > 0
M8_NET_vol_gt_pos_1155 = NET AREA RATIO M8 M8_NETID_vol_gt_pos_1155 > 0
// 
V1_NET_vol_gt_pos_1155 = V1 INTERACT (OR M1_NET_vol_gt_pos_1155 M2_NET_vol_gt_pos_1155)
V2_NET_vol_gt_pos_1155 = V2 INTERACT (OR M2_NET_vol_gt_pos_1155 M3_NET_vol_gt_pos_1155)
V3_NET_vol_gt_pos_1155 = V3 INTERACT (OR M3_NET_vol_gt_pos_1155 M4_NET_vol_gt_pos_1155)
V4_NET_vol_gt_pos_1155 = V4 INTERACT (OR M4_NET_vol_gt_pos_1155 M5_NET_vol_gt_pos_1155)
V5_NET_vol_gt_pos_1155 = V5 INTERACT (OR M5_NET_vol_gt_pos_1155 M6_NET_vol_gt_pos_1155)
V6_NET_vol_gt_pos_1155 = V6 INTERACT (OR M6_NET_vol_gt_pos_1155 M7_NET_vol_gt_pos_1155)
V7_NET_vol_gt_pos_1155 = V7 INTERACT (OR M7_NET_vol_gt_pos_1155 M8_NET_vol_gt_pos_1155)
// 
// < 1.1 positive voltage NETID
// 
M1_NETID_vol_gt_pos_110 = DFM PROPERTY M1_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 1.1
M2_NETID_vol_gt_pos_110 = DFM PROPERTY M2_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 1.1
M3_NETID_vol_gt_pos_110 = DFM PROPERTY M3_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 1.1
M4_NETID_vol_gt_pos_110 = DFM PROPERTY M4_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 1.1
M5_NETID_vol_gt_pos_110 = DFM PROPERTY M5_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 1.1
M6_NETID_vol_gt_pos_110 = DFM PROPERTY M6_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 1.1
M7_NETID_vol_gt_pos_110 = DFM PROPERTY M7_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 1.1
M8_NETID_vol_gt_pos_110 = DFM PROPERTY M8_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 1.1
// 
M1_NET_vol_gt_pos_110 = NET AREA RATIO M1 M1_NETID_vol_gt_pos_110 > 0
M2_NET_vol_gt_pos_110 = NET AREA RATIO M2 M2_NETID_vol_gt_pos_110 > 0
M3_NET_vol_gt_pos_110 = NET AREA RATIO M3 M3_NETID_vol_gt_pos_110 > 0
M4_NET_vol_gt_pos_110 = NET AREA RATIO M4 M4_NETID_vol_gt_pos_110 > 0
M5_NET_vol_gt_pos_110 = NET AREA RATIO M5 M5_NETID_vol_gt_pos_110 > 0
M6_NET_vol_gt_pos_110 = NET AREA RATIO M6 M6_NETID_vol_gt_pos_110 > 0
M7_NET_vol_gt_pos_110 = NET AREA RATIO M7 M7_NETID_vol_gt_pos_110 > 0
M8_NET_vol_gt_pos_110 = NET AREA RATIO M8 M8_NETID_vol_gt_pos_110 > 0
// 
V1_NET_vol_gt_pos_110 = V1 INTERACT (OR M1_NET_vol_gt_pos_110 M2_NET_vol_gt_pos_110)
V2_NET_vol_gt_pos_110 = V2 INTERACT (OR M2_NET_vol_gt_pos_110 M3_NET_vol_gt_pos_110)
V3_NET_vol_gt_pos_110 = V3 INTERACT (OR M3_NET_vol_gt_pos_110 M4_NET_vol_gt_pos_110)
V4_NET_vol_gt_pos_110 = V4 INTERACT (OR M4_NET_vol_gt_pos_110 M5_NET_vol_gt_pos_110)
V5_NET_vol_gt_pos_110 = V5 INTERACT (OR M5_NET_vol_gt_pos_110 M6_NET_vol_gt_pos_110)
V6_NET_vol_gt_pos_110 = V6 INTERACT (OR M6_NET_vol_gt_pos_110 M7_NET_vol_gt_pos_110)
V7_NET_vol_gt_pos_110 = V7 INTERACT (OR M7_NET_vol_gt_pos_110 M8_NET_vol_gt_pos_110)
// 
// < 1.05 positive voltage NETID
// 
M1_NETID_vol_gt_pos_105 = DFM PROPERTY M1_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 1.05
M2_NETID_vol_gt_pos_105 = DFM PROPERTY M2_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 1.05
M3_NETID_vol_gt_pos_105 = DFM PROPERTY M3_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 1.05
M4_NETID_vol_gt_pos_105 = DFM PROPERTY M4_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 1.05
M5_NETID_vol_gt_pos_105 = DFM PROPERTY M5_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 1.05
M6_NETID_vol_gt_pos_105 = DFM PROPERTY M6_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 1.05
M7_NETID_vol_gt_pos_105 = DFM PROPERTY M7_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 1.05
M8_NETID_vol_gt_pos_105 = DFM PROPERTY M8_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 1.05
// 
M1_NET_vol_gt_pos_105 = NET AREA RATIO M1 M1_NETID_vol_gt_pos_105 > 0
M2_NET_vol_gt_pos_105 = NET AREA RATIO M2 M2_NETID_vol_gt_pos_105 > 0
M3_NET_vol_gt_pos_105 = NET AREA RATIO M3 M3_NETID_vol_gt_pos_105 > 0
M4_NET_vol_gt_pos_105 = NET AREA RATIO M4 M4_NETID_vol_gt_pos_105 > 0
M5_NET_vol_gt_pos_105 = NET AREA RATIO M5 M5_NETID_vol_gt_pos_105 > 0
M6_NET_vol_gt_pos_105 = NET AREA RATIO M6 M6_NETID_vol_gt_pos_105 > 0
M7_NET_vol_gt_pos_105 = NET AREA RATIO M7 M7_NETID_vol_gt_pos_105 > 0
M8_NET_vol_gt_pos_105 = NET AREA RATIO M8 M8_NETID_vol_gt_pos_105 > 0
// 
V1_NET_vol_gt_pos_105 = V1 INTERACT (OR M1_NET_vol_gt_pos_105 M2_NET_vol_gt_pos_105)
V2_NET_vol_gt_pos_105 = V2 INTERACT (OR M2_NET_vol_gt_pos_105 M3_NET_vol_gt_pos_105)
V3_NET_vol_gt_pos_105 = V3 INTERACT (OR M3_NET_vol_gt_pos_105 M4_NET_vol_gt_pos_105)
V4_NET_vol_gt_pos_105 = V4 INTERACT (OR M4_NET_vol_gt_pos_105 M5_NET_vol_gt_pos_105)
V5_NET_vol_gt_pos_105 = V5 INTERACT (OR M5_NET_vol_gt_pos_105 M6_NET_vol_gt_pos_105)
V6_NET_vol_gt_pos_105 = V6 INTERACT (OR M6_NET_vol_gt_pos_105 M7_NET_vol_gt_pos_105)
V7_NET_vol_gt_pos_105 = V7 INTERACT (OR M7_NET_vol_gt_pos_105 M8_NET_vol_gt_pos_105)
// 
// < 1.0 positive voltage NETID
// 
M1_NETID_vol_gt_pos_100 = DFM PROPERTY M1_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 1.0
M2_NETID_vol_gt_pos_100 = DFM PROPERTY M2_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 1.0
M3_NETID_vol_gt_pos_100 = DFM PROPERTY M3_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 1.0
M4_NETID_vol_gt_pos_100 = DFM PROPERTY M4_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 1.0
M5_NETID_vol_gt_pos_100 = DFM PROPERTY M5_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 1.0
M6_NETID_vol_gt_pos_100 = DFM PROPERTY M6_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 1.0
M7_NETID_vol_gt_pos_100 = DFM PROPERTY M7_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 1.0
M8_NETID_vol_gt_pos_100 = DFM PROPERTY M8_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 1.0
// 
M1_NET_vol_gt_pos_100 = NET AREA RATIO M1 M1_NETID_vol_gt_pos_100 > 0
M2_NET_vol_gt_pos_100 = NET AREA RATIO M2 M2_NETID_vol_gt_pos_100 > 0
M3_NET_vol_gt_pos_100 = NET AREA RATIO M3 M3_NETID_vol_gt_pos_100 > 0
M4_NET_vol_gt_pos_100 = NET AREA RATIO M4 M4_NETID_vol_gt_pos_100 > 0
M5_NET_vol_gt_pos_100 = NET AREA RATIO M5 M5_NETID_vol_gt_pos_100 > 0
M6_NET_vol_gt_pos_100 = NET AREA RATIO M6 M6_NETID_vol_gt_pos_100 > 0
M7_NET_vol_gt_pos_100 = NET AREA RATIO M7 M7_NETID_vol_gt_pos_100 > 0
M8_NET_vol_gt_pos_100 = NET AREA RATIO M8 M8_NETID_vol_gt_pos_100 > 0
// 
V1_NET_vol_gt_pos_100 = V1 INTERACT (OR M1_NET_vol_gt_pos_100 M2_NET_vol_gt_pos_100)
V2_NET_vol_gt_pos_100 = V2 INTERACT (OR M2_NET_vol_gt_pos_100 M3_NET_vol_gt_pos_100)
V3_NET_vol_gt_pos_100 = V3 INTERACT (OR M3_NET_vol_gt_pos_100 M4_NET_vol_gt_pos_100)
V4_NET_vol_gt_pos_100 = V4 INTERACT (OR M4_NET_vol_gt_pos_100 M5_NET_vol_gt_pos_100)
V5_NET_vol_gt_pos_100 = V5 INTERACT (OR M5_NET_vol_gt_pos_100 M6_NET_vol_gt_pos_100)
V6_NET_vol_gt_pos_100 = V6 INTERACT (OR M6_NET_vol_gt_pos_100 M7_NET_vol_gt_pos_100)
V7_NET_vol_gt_pos_100 = V7 INTERACT (OR M7_NET_vol_gt_pos_100 M8_NET_vol_gt_pos_100)
// 
// < 0.935 positive voltage NETID
// 
M1_NETID_vol_gt_pos_0935 = DFM PROPERTY M1_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 0.935
M2_NETID_vol_gt_pos_0935 = DFM PROPERTY M2_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 0.935
M3_NETID_vol_gt_pos_0935 = DFM PROPERTY M3_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 0.935
M4_NETID_vol_gt_pos_0935 = DFM PROPERTY M4_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 0.935
M5_NETID_vol_gt_pos_0935 = DFM PROPERTY M5_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 0.935
M6_NETID_vol_gt_pos_0935 = DFM PROPERTY M6_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 0.935
M7_NETID_vol_gt_pos_0935 = DFM PROPERTY M7_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 0.935
M8_NETID_vol_gt_pos_0935 = DFM PROPERTY M8_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 0.935
// 
M1_NET_vol_gt_pos_0935 = NET AREA RATIO M1 M1_NETID_vol_gt_pos_0935 > 0
M2_NET_vol_gt_pos_0935 = NET AREA RATIO M2 M2_NETID_vol_gt_pos_0935 > 0
M3_NET_vol_gt_pos_0935 = NET AREA RATIO M3 M3_NETID_vol_gt_pos_0935 > 0
M4_NET_vol_gt_pos_0935 = NET AREA RATIO M4 M4_NETID_vol_gt_pos_0935 > 0
M5_NET_vol_gt_pos_0935 = NET AREA RATIO M5 M5_NETID_vol_gt_pos_0935 > 0
M6_NET_vol_gt_pos_0935 = NET AREA RATIO M6 M6_NETID_vol_gt_pos_0935 > 0
M7_NET_vol_gt_pos_0935 = NET AREA RATIO M7 M7_NETID_vol_gt_pos_0935 > 0
M8_NET_vol_gt_pos_0935 = NET AREA RATIO M8 M8_NETID_vol_gt_pos_0935 > 0
// 
V1_NET_vol_gt_pos_0935 = V1 INTERACT (OR M1_NET_vol_gt_pos_0935 M2_NET_vol_gt_pos_0935)
V2_NET_vol_gt_pos_0935 = V2 INTERACT (OR M2_NET_vol_gt_pos_0935 M3_NET_vol_gt_pos_0935)
V3_NET_vol_gt_pos_0935 = V3 INTERACT (OR M3_NET_vol_gt_pos_0935 M4_NET_vol_gt_pos_0935)
V4_NET_vol_gt_pos_0935 = V4 INTERACT (OR M4_NET_vol_gt_pos_0935 M5_NET_vol_gt_pos_0935)
V5_NET_vol_gt_pos_0935 = V5 INTERACT (OR M5_NET_vol_gt_pos_0935 M6_NET_vol_gt_pos_0935)
V6_NET_vol_gt_pos_0935 = V6 INTERACT (OR M6_NET_vol_gt_pos_0935 M7_NET_vol_gt_pos_0935)
V7_NET_vol_gt_pos_0935 = V7 INTERACT (OR M7_NET_vol_gt_pos_0935 M8_NET_vol_gt_pos_0935)
// 
// < 0.88 positive voltage NETID
// 
M1_NETID_vol_gt_pos_088 = DFM PROPERTY M1_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 0.88
M2_NETID_vol_gt_pos_088 = DFM PROPERTY M2_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 0.88
M3_NETID_vol_gt_pos_088 = DFM PROPERTY M3_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 0.88
M4_NETID_vol_gt_pos_088 = DFM PROPERTY M4_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 0.88
M5_NETID_vol_gt_pos_088 = DFM PROPERTY M5_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 0.88
M6_NETID_vol_gt_pos_088 = DFM PROPERTY M6_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 0.88
M7_NETID_vol_gt_pos_088 = DFM PROPERTY M7_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 0.88
M8_NETID_vol_gt_pos_088 = DFM PROPERTY M8_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 0.88
// 
M1_NET_vol_gt_pos_088 = NET AREA RATIO M1 M1_NETID_vol_gt_pos_088 > 0
M2_NET_vol_gt_pos_088 = NET AREA RATIO M2 M2_NETID_vol_gt_pos_088 > 0
M3_NET_vol_gt_pos_088 = NET AREA RATIO M3 M3_NETID_vol_gt_pos_088 > 0
M4_NET_vol_gt_pos_088 = NET AREA RATIO M4 M4_NETID_vol_gt_pos_088 > 0
M5_NET_vol_gt_pos_088 = NET AREA RATIO M5 M5_NETID_vol_gt_pos_088 > 0
M6_NET_vol_gt_pos_088 = NET AREA RATIO M6 M6_NETID_vol_gt_pos_088 > 0
M7_NET_vol_gt_pos_088 = NET AREA RATIO M7 M7_NETID_vol_gt_pos_088 > 0
M8_NET_vol_gt_pos_088 = NET AREA RATIO M8 M8_NETID_vol_gt_pos_088 > 0
// 
V1_NET_vol_gt_pos_088 = V1 INTERACT (OR M1_NET_vol_gt_pos_088 M2_NET_vol_gt_pos_088)
V2_NET_vol_gt_pos_088 = V2 INTERACT (OR M2_NET_vol_gt_pos_088 M3_NET_vol_gt_pos_088)
V3_NET_vol_gt_pos_088 = V3 INTERACT (OR M3_NET_vol_gt_pos_088 M4_NET_vol_gt_pos_088)
V4_NET_vol_gt_pos_088 = V4 INTERACT (OR M4_NET_vol_gt_pos_088 M5_NET_vol_gt_pos_088)
V5_NET_vol_gt_pos_088 = V5 INTERACT (OR M5_NET_vol_gt_pos_088 M6_NET_vol_gt_pos_088)
V6_NET_vol_gt_pos_088 = V6 INTERACT (OR M6_NET_vol_gt_pos_088 M7_NET_vol_gt_pos_088)
V7_NET_vol_gt_pos_088 = V7 INTERACT (OR M7_NET_vol_gt_pos_088 M8_NET_vol_gt_pos_088)
// 
// < 5.599 positive voltage NETID
// 
AA_NETID_vol_gt_pos_560 = DFM PROPERTY AA_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 5.599
GT_NETID_vol_gt_pos_560 = DFM PROPERTY GT_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 5.599
M0_NETID_vol_gt_pos_560 = DFM PROPERTY M0_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 5.599
MG_NETID_vol_gt_pos_560 = DFM PROPERTY MG_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 5.599
PW_NETID_vol_gt_pos_560 = DFM PROPERTY PW_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 5.599
AA_NET_vol_gt_pos_560 = NET AREA RATIO AA_c AA_NETID_vol_gt_pos_560 > 0
GT_NET_vol_gt_pos_560 = NET AREA RATIO GT_0 GT_NETID_vol_gt_pos_560 > 0
MG_NET_vol_gt_pos_560 = NET AREA RATIO M0G MG_NETID_vol_gt_pos_560 > 0
M0_NET_vol_gt_pos_560 = NET AREA RATIO M0_NOT_M0C M0_NETID_vol_gt_pos_560 > 0
V0_NET_vol_gt_pos_560 = V0 INTERACT (OR M0_NET_vol_gt_pos_560 MG_NET_vol_gt_pos_560)
// 
// < 5.5 positive voltage NETID
// 
AA_NETID_vol_gt_pos_550 = DFM PROPERTY AA_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 5.5
GT_NETID_vol_gt_pos_550 = DFM PROPERTY GT_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 5.5
M0_NETID_vol_gt_pos_550 = DFM PROPERTY M0_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 5.5
MG_NETID_vol_gt_pos_550 = DFM PROPERTY MG_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 5.5
PW_NETID_vol_gt_pos_550 = DFM PROPERTY PW_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 5.5
AA_NET_vol_gt_pos_550 = NET AREA RATIO AA_c AA_NETID_vol_gt_pos_550 > 0
GT_NET_vol_gt_pos_550 = NET AREA RATIO GT_0 GT_NETID_vol_gt_pos_550 > 0
MG_NET_vol_gt_pos_550 = NET AREA RATIO M0G MG_NETID_vol_gt_pos_550 > 0
M0_NET_vol_gt_pos_550 = NET AREA RATIO M0_NOT_M0C M0_NETID_vol_gt_pos_550 > 0
V0_NET_vol_gt_pos_550 = V0 INTERACT (OR M0_NET_vol_gt_pos_550 MG_NET_vol_gt_pos_550)
// 
// < 3.63 positive voltage NETID
// 
AA_NETID_vol_gt_pos_363 = DFM PROPERTY AA_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 3.63
GT_NETID_vol_gt_pos_363 = DFM PROPERTY GT_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 3.63
M0_NETID_vol_gt_pos_363 = DFM PROPERTY M0_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 3.63
MG_NETID_vol_gt_pos_363 = DFM PROPERTY MG_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 3.63
PW_NETID_vol_gt_pos_363 = DFM PROPERTY PW_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 3.63
AA_NET_vol_gt_pos_363 = NET AREA RATIO AA_c AA_NETID_vol_gt_pos_363 > 0
GT_NET_vol_gt_pos_363 = NET AREA RATIO GT_0 GT_NETID_vol_gt_pos_363 > 0
MG_NET_vol_gt_pos_363 = NET AREA RATIO M0G MG_NETID_vol_gt_pos_363 > 0
M0_NET_vol_gt_pos_363 = NET AREA RATIO M0_NOT_M0C M0_NETID_vol_gt_pos_363 > 0
V0_NET_vol_gt_pos_363 = V0 INTERACT (OR M0_NET_vol_gt_pos_363 MG_NET_vol_gt_pos_363)
// 
// < 2.75 positive voltage NETID
// 
AA_NETID_vol_gt_pos_275 = DFM PROPERTY AA_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 2.75
GT_NETID_vol_gt_pos_275 = DFM PROPERTY GT_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 2.75
M0_NETID_vol_gt_pos_275 = DFM PROPERTY M0_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 2.75
MG_NETID_vol_gt_pos_275 = DFM PROPERTY MG_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 2.75
PW_NETID_vol_gt_pos_275 = DFM PROPERTY PW_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 2.75
AA_NET_vol_gt_pos_275 = NET AREA RATIO AA_c AA_NETID_vol_gt_pos_275 > 0
GT_NET_vol_gt_pos_275 = NET AREA RATIO GT_0 GT_NETID_vol_gt_pos_275 > 0
MG_NET_vol_gt_pos_275 = NET AREA RATIO M0G MG_NETID_vol_gt_pos_275 > 0
M0_NET_vol_gt_pos_275 = NET AREA RATIO M0_NOT_M0C M0_NETID_vol_gt_pos_275 > 0
V0_NET_vol_gt_pos_275 = V0 INTERACT (OR M0_NET_vol_gt_pos_275 MG_NET_vol_gt_pos_275)
// 
// < 1.98 positive voltage NETID
// 
AA_NETID_vol_gt_pos_198 = DFM PROPERTY AA_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 1.98
GT_NETID_vol_gt_pos_198 = DFM PROPERTY GT_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 1.98
M0_NETID_vol_gt_pos_198 = DFM PROPERTY M0_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 1.98
MG_NETID_vol_gt_pos_198 = DFM PROPERTY MG_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 1.98
PW_NETID_vol_gt_pos_198 = DFM PROPERTY PW_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 1.98
AA_NET_vol_gt_pos_198 = NET AREA RATIO AA_c AA_NETID_vol_gt_pos_198 > 0
GT_NET_vol_gt_pos_198 = NET AREA RATIO GT_0 GT_NETID_vol_gt_pos_198 > 0
MG_NET_vol_gt_pos_198 = NET AREA RATIO M0G MG_NETID_vol_gt_pos_198 > 0
M0_NET_vol_gt_pos_198 = NET AREA RATIO M0_NOT_M0C M0_NETID_vol_gt_pos_198 > 0
V0_NET_vol_gt_pos_198 = V0 INTERACT (OR M0_NET_vol_gt_pos_198 MG_NET_vol_gt_pos_198)
// 
// < 1.65 positive voltage NETID
// 
AA_NETID_vol_gt_pos_165 = DFM PROPERTY AA_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 1.65
GT_NETID_vol_gt_pos_165 = DFM PROPERTY GT_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 1.65
M0_NETID_vol_gt_pos_165 = DFM PROPERTY M0_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 1.65
MG_NETID_vol_gt_pos_165 = DFM PROPERTY MG_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 1.65
PW_NETID_vol_gt_pos_165 = DFM PROPERTY PW_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 1.65
AA_NET_vol_gt_pos_165 = NET AREA RATIO AA_c AA_NETID_vol_gt_pos_165 > 0
GT_NET_vol_gt_pos_165 = NET AREA RATIO GT_0 GT_NETID_vol_gt_pos_165 > 0
MG_NET_vol_gt_pos_165 = NET AREA RATIO M0G MG_NETID_vol_gt_pos_165 > 0
M0_NET_vol_gt_pos_165 = NET AREA RATIO M0_NOT_M0C M0_NETID_vol_gt_pos_165 > 0
V0_NET_vol_gt_pos_165 = V0 INTERACT (OR M0_NET_vol_gt_pos_165 MG_NET_vol_gt_pos_165)
// 
// < 1.32 positive voltage NETID
// 
AA_NETID_vol_gt_pos_132 = DFM PROPERTY AA_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 1.32
GT_NETID_vol_gt_pos_132 = DFM PROPERTY GT_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 1.32
M0_NETID_vol_gt_pos_132 = DFM PROPERTY M0_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 1.32
MG_NETID_vol_gt_pos_132 = DFM PROPERTY MG_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 1.32
PW_NETID_vol_gt_pos_132 = DFM PROPERTY PW_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 1.32
AA_NET_vol_gt_pos_132 = NET AREA RATIO AA_c AA_NETID_vol_gt_pos_132 > 0
GT_NET_vol_gt_pos_132 = NET AREA RATIO GT_0 GT_NETID_vol_gt_pos_132 > 0
MG_NET_vol_gt_pos_132 = NET AREA RATIO M0G MG_NETID_vol_gt_pos_132 > 0
M0_NET_vol_gt_pos_132 = NET AREA RATIO M0_NOT_M0C M0_NETID_vol_gt_pos_132 > 0
V0_NET_vol_gt_pos_132 = V0 INTERACT (OR M0_NET_vol_gt_pos_132 MG_NET_vol_gt_pos_132)
// 
// < 1.155 positive voltage NETID
// 
AA_NETID_vol_gt_pos_1155 = DFM PROPERTY AA_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 1.155
GT_NETID_vol_gt_pos_1155 = DFM PROPERTY GT_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 1.155
M0_NETID_vol_gt_pos_1155 = DFM PROPERTY M0_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 1.155
MG_NETID_vol_gt_pos_1155 = DFM PROPERTY MG_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 1.155
PW_NETID_vol_gt_pos_1155 = DFM PROPERTY PW_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 1.155
AA_NET_vol_gt_pos_1155 = NET AREA RATIO AA_c AA_NETID_vol_gt_pos_1155 > 0
GT_NET_vol_gt_pos_1155 = NET AREA RATIO GT_0 GT_NETID_vol_gt_pos_1155 > 0
MG_NET_vol_gt_pos_1155 = NET AREA RATIO M0G MG_NETID_vol_gt_pos_1155 > 0
M0_NET_vol_gt_pos_1155 = NET AREA RATIO M0_NOT_M0C M0_NETID_vol_gt_pos_1155 > 0
V0_NET_vol_gt_pos_1155 = V0 INTERACT (OR M0_NET_vol_gt_pos_1155 MG_NET_vol_gt_pos_1155)
// 
// < 1.1 positive voltage NETID
// 
AA_NETID_vol_gt_pos_110 = DFM PROPERTY AA_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 1.1
GT_NETID_vol_gt_pos_110 = DFM PROPERTY GT_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 1.1
M0_NETID_vol_gt_pos_110 = DFM PROPERTY M0_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 1.1
MG_NETID_vol_gt_pos_110 = DFM PROPERTY MG_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 1.1
PW_NETID_vol_gt_pos_110 = DFM PROPERTY PW_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 1.1
AA_NET_vol_gt_pos_110 = NET AREA RATIO AA_c AA_NETID_vol_gt_pos_110 > 0
GT_NET_vol_gt_pos_110 = NET AREA RATIO GT_0 GT_NETID_vol_gt_pos_110 > 0
MG_NET_vol_gt_pos_110 = NET AREA RATIO M0G MG_NETID_vol_gt_pos_110 > 0
M0_NET_vol_gt_pos_110 = NET AREA RATIO M0_NOT_M0C M0_NETID_vol_gt_pos_110 > 0
V0_NET_vol_gt_pos_110 = V0 INTERACT (OR M0_NET_vol_gt_pos_110 MG_NET_vol_gt_pos_110)
// 
// < 1.05 positive voltage NETID
// 
AA_NETID_vol_gt_pos_105 = DFM PROPERTY AA_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 1.05
GT_NETID_vol_gt_pos_105 = DFM PROPERTY GT_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 1.05
M0_NETID_vol_gt_pos_105 = DFM PROPERTY M0_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 1.05
MG_NETID_vol_gt_pos_105 = DFM PROPERTY MG_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 1.05
PW_NETID_vol_gt_pos_105 = DFM PROPERTY PW_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 1.05
AA_NET_vol_gt_pos_105 = NET AREA RATIO AA_c AA_NETID_vol_gt_pos_105 > 0
GT_NET_vol_gt_pos_105 = NET AREA RATIO GT_0 GT_NETID_vol_gt_pos_105 > 0
MG_NET_vol_gt_pos_105 = NET AREA RATIO M0G MG_NETID_vol_gt_pos_105 > 0
M0_NET_vol_gt_pos_105 = NET AREA RATIO M0_NOT_M0C M0_NETID_vol_gt_pos_105 > 0
V0_NET_vol_gt_pos_105 = V0 INTERACT (OR M0_NET_vol_gt_pos_105 MG_NET_vol_gt_pos_105)
// 
// < 1.0 positive voltage NETID
// 
AA_NETID_vol_gt_pos_100 = DFM PROPERTY AA_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 1.0
GT_NETID_vol_gt_pos_100 = DFM PROPERTY GT_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 1.0
M0_NETID_vol_gt_pos_100 = DFM PROPERTY M0_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 1.0
MG_NETID_vol_gt_pos_100 = DFM PROPERTY MG_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 1.0
PW_NETID_vol_gt_pos_100 = DFM PROPERTY PW_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 1.0
AA_NET_vol_gt_pos_100 = NET AREA RATIO AA_c AA_NETID_vol_gt_pos_100 > 0
GT_NET_vol_gt_pos_100 = NET AREA RATIO GT_0 GT_NETID_vol_gt_pos_100 > 0
MG_NET_vol_gt_pos_100 = NET AREA RATIO M0G MG_NETID_vol_gt_pos_100 > 0
M0_NET_vol_gt_pos_100 = NET AREA RATIO M0_NOT_M0C M0_NETID_vol_gt_pos_100 > 0
V0_NET_vol_gt_pos_100 = V0 INTERACT (OR M0_NET_vol_gt_pos_100 MG_NET_vol_gt_pos_100)
// 
// < 0.935 positive voltage NETID
// 
AA_NETID_vol_gt_pos_0935 = DFM PROPERTY AA_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 0.935
GT_NETID_vol_gt_pos_0935 = DFM PROPERTY GT_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 0.935
M0_NETID_vol_gt_pos_0935 = DFM PROPERTY M0_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 0.935
MG_NETID_vol_gt_pos_0935 = DFM PROPERTY MG_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 0.935
PW_NETID_vol_gt_pos_0935 = DFM PROPERTY PW_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 0.935
AA_NET_vol_gt_pos_0935 = NET AREA RATIO AA_c AA_NETID_vol_gt_pos_0935 > 0
GT_NET_vol_gt_pos_0935 = NET AREA RATIO GT_0 GT_NETID_vol_gt_pos_0935 > 0
MG_NET_vol_gt_pos_0935 = NET AREA RATIO M0G MG_NETID_vol_gt_pos_0935 > 0
M0_NET_vol_gt_pos_0935 = NET AREA RATIO M0_NOT_M0C M0_NETID_vol_gt_pos_0935 > 0
V0_NET_vol_gt_pos_0935 = V0 INTERACT (OR M0_NET_vol_gt_pos_0935 MG_NET_vol_gt_pos_0935)
// 
// < 0.88 positive voltage NETID
// 
AA_NETID_vol_gt_pos_088 = DFM PROPERTY AA_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 0.88
GT_NETID_vol_gt_pos_088 = DFM PROPERTY GT_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 0.88
M0_NETID_vol_gt_pos_088 = DFM PROPERTY M0_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 0.88
MG_NETID_vol_gt_pos_088 = DFM PROPERTY MG_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 0.88
PW_NETID_vol_gt_pos_088 = DFM PROPERTY PW_NETID_rdm net_vol_assign NODAL MULTI [pos = property(net_vol_assign, max_vol)] > 0.88
AA_NET_vol_gt_pos_088 = NET AREA RATIO AA_c AA_NETID_vol_gt_pos_088 > 0
GT_NET_vol_gt_pos_088 = NET AREA RATIO GT_0 GT_NETID_vol_gt_pos_088 > 0
MG_NET_vol_gt_pos_088 = NET AREA RATIO M0G MG_NETID_vol_gt_pos_088 > 0
M0_NET_vol_gt_pos_088 = NET AREA RATIO M0_NOT_M0C M0_NETID_vol_gt_pos_088 > 0
V0_NET_vol_gt_pos_088 = V0 INTERACT (OR M0_NET_vol_gt_pos_088 MG_NET_vol_gt_pos_088)

//;--------------------------------------------------------------------------------------------------------------
//; use metal sync mark layer
//;--------------------------------------------------------------------------------------------------------------
LAYER MAP  9998  DATATYPE  2234  54322
LAYER EMPTY_syc  54322

EMPTYi = EMPTY_syc NOT DRC:1
SYNCED_NET = DRC:1 INTERACT Mn_NET_SYNCH

GT_SYC = EMPTY_syc OR (GT_0 INTERACT SYNCED_NET)
HR_SYC = EMPTY_syc OR (HR_c INTERACT SYNCED_NET)
V0_SYC = EMPTY_syc OR (V0 INTERACT SYNCED_NET)
M0_SYC = EMPTY_syc OR (M0_NOT_M0C INTERACT SYNCED_NET)
M0G_SYC = EMPTY_syc OR (M0G INTERACT SYNCED_NET)
M0_0_SYC = EMPTY_syc OR (M0_0 INTERACT SYNCED_NET)

NWRT_SYC = EMPTY_syc OR (NWRT INTERACT SYNCED_NET)
NTAP_SYC = EMPTY_syc OR (NTAP INTERACT SYNCED_NET)
PTAP_SYC = EMPTY_syc OR (PTAP INTERACT SYNCED_NET)
NSD_SYC = EMPTY_syc OR (NSD INTERACT SYNCED_NET)
PSD_SYC = EMPTY_syc OR (PSD INTERACT SYNCED_NET)
real_NSD_SYC = EMPTY_syc OR (real_NSD INTERACT SYNCED_NET)
real_PSD_SYC = EMPTY_syc OR (real_PSD INTERACT SYNCED_NET)
N_inject_SYC = EMPTY_syc OR (N_inject INTERACT SYNCED_NET)
P_inject_SYC = EMPTY_syc OR (P_inject INTERACT SYNCED_NET)

DNW_SYC = EMPTY_syc OR (DNW INTERACT SYNCED_NET)
AA_SYC = EMPTY_syc OR (AA_c INTERACT SYNCED_NET)
NW_SYC = EMPTY_syc OR (NW INTERACT SYNCED_NET)
PW_SYC = EMPTY_syc OR (PW_0 INTERACT SYNCED_NET)
RW_SYC = EMPTY_syc OR (RW INTERACT SYNCED_NET)
PA_SYC = EMPTY_syc OR (PA INTERACT SYNCED_NET)
MD_SYC = EMPTY_syc OR (MD INTERACT SYNCED_NET)
ALPA_SYC = EMPTY_syc OR (ALPA INTERACT SYNCED_NET)

TV_SYC = EMPTY_syc OR (TV INTERACT SYNCED_NET)
TM_SYC = EMPTY_syc OR (TM INTERACT SYNCED_NET)
TM_1_SYC = EMPTY_syc OR (TM_1 INTERACT SYNCED_NET)
UTV_SYC = EMPTY_syc OR (UTV INTERACT SYNCED_NET)
UTM_SYC = EMPTY_syc OR (UTM INTERACT SYNCED_NET)

TV_AND_MIM_mapping_SYC = EMPTY_syc OR (TV_AND_MIM_mapping INTERACT SYNCED_NET)
TV_AND_CTOP_mapping_SYC = EMPTY_syc OR (TV_AND_CTOP_mapping INTERACT SYNCED_NET)
TV_NOT_MIM_CTOP_mapping_SYC = EMPTY_syc OR (TV_NOT_MIM_CTOP_mapping INTERACT SYNCED_NET)

CTOP_NOT_MIM_final_SYC = EMPTY_syc OR (CTOP_NOT_MIM_final INTERACT SYNCED_NET)
CTOP_final_SYC = EMPTY_syc OR (CTOP_final INTERACT SYNCED_NET)
MIM_final_SYC = EMPTY_syc OR (MIM_final INTERACT SYNCED_NET)

M1_SYC = EMPTY_syc OR (M1 INTERACT SYNCED_NET)
M2_SYC = EMPTY_syc OR (M2 INTERACT SYNCED_NET)
M3_SYC = EMPTY_syc OR (M3 INTERACT SYNCED_NET)
M4_SYC = EMPTY_syc OR (M4 INTERACT SYNCED_NET)
M5_SYC = EMPTY_syc OR (M5 INTERACT SYNCED_NET)
M6_SYC = EMPTY_syc OR (M6 INTERACT SYNCED_NET)
M7_SYC = EMPTY_syc OR (M7 INTERACT SYNCED_NET)
M8_SYC = EMPTY_syc OR (M8 INTERACT SYNCED_NET)
V1_SYC = EMPTY_syc OR (V1 INTERACT SYNCED_NET)
V2_SYC = EMPTY_syc OR (V2 INTERACT SYNCED_NET)
V3_SYC = EMPTY_syc OR (V3 INTERACT SYNCED_NET)
V4_SYC = EMPTY_syc OR (V4 INTERACT SYNCED_NET)
V5_SYC = EMPTY_syc OR (V5 INTERACT SYNCED_NET)
V6_SYC = EMPTY_syc OR (V6 INTERACT SYNCED_NET)
V7_SYC = EMPTY_syc OR (V7 INTERACT SYNCED_NET)
TV2_SYC = EMPTY_syc OR (TV2 INTERACT SYNCED_NET)
TM2_SYC = EMPTY_syc OR (TM2 INTERACT SYNCED_NET)

// --------------------------------------------------------------
// Beginning of the connection for delta voltage DRC check
// --------------------------------------------------------------
CONNECT M0_0_SYC M1_SYC BY V0_SYC
CONNECT M0_SYC M1_SYC BY V0_SYC
CONNECT M0G_SYC M1_SYC BY V0_SYC

CONNECT M0_0_SYC NTAP_SYC
CONNECT M0_0_SYC PTAP_SYC
CONNECT M0_0_SYC real_PSD_SYC
CONNECT M0_0_SYC real_NSD_SYC
CONNECT M0_0_SYC P_inject_SYC
CONNECT M0_0_SYC N_inject_SYC
CONNECT M0_0_SYC PSD_SYC
CONNECT M0_0_SYC NSD_SYC
CONNECT M0_0_SYC GT_SYC
CONNECT M0_0_SYC M0_SYC
CONNECT M0_0_SYC M0G_SYC

CONNECT M0_SYC M0G_SYC
CONNECT M0_SYC NTAP_SYC
CONNECT M0_SYC PTAP_SYC
CONNECT M0_SYC real_PSD_SYC
CONNECT M0_SYC real_NSD_SYC
CONNECT M0_SYC P_inject_SYC
CONNECT M0_SYC N_inject_SYC
CONNECT M0_SYC PSD_SYC
CONNECT M0_SYC NSD_SYC
CONNECT M0_SYC GT_SYC
CONNECT M0_SYC NWRT_SYC

CONNECT M0G_SYC NTAP_SYC
CONNECT M0G_SYC PTAP_SYC
CONNECT M0G_SYC real_PSD_SYC
CONNECT M0G_SYC real_NSD_SYC
CONNECT M0G_SYC P_inject_SYC
CONNECT M0G_SYC N_inject_SYC
CONNECT M0G_SYC PSD_SYC
CONNECT M0G_SYC NSD_SYC
CONNECT M0G_SYC GT_SYC
CONNECT M0G_SYC HR_SYC
CONNECT M0G_SYC NWRT_SYC

CONNECT AA_SYC NTAP_SYC
CONNECT AA_SYC PTAP_SYC
CONNECT AA_SYC PSD_SYC
CONNECT AA_SYC NSD_SYC
CONNECT AA_SYC NWRT_SYC
CONNECT real_PSD_SYC PSD_SYC
CONNECT real_NSD_SYC NSD_SYC
CONNECT P_inject_SYC PSD_SYC
CONNECT N_inject_SYC NSD_SYC

CONNECT DNW_SYC NW_SYC
CONNECT NTAP_SYC NW_SYC
CONNECT PTAP_SYC RW_SYC
CONNECT PTAP_SYC PW_SYC

//; For BEOL mapping layers connection 
CONNECT M1V_SYNCH M1_SYC
CONNECT M2V_SYNCH M2_SYC
CONNECT M3V_SYNCH M3_SYC
CONNECT M4V_SYNCH M4_SYC
CONNECT M5V_SYNCH M5_SYC
CONNECT M6V_SYNCH M6_SYC
CONNECT M7V_SYNCH M7_SYC
CONNECT M8V_SYNCH M8_SYC
CONNECT ALPAV_SYNCH ALPA_SYC
CONNECT M1_SYC M2_SYC BY V1_SYC
CONNECT M2_SYC M3_SYC BY V2_SYC
CONNECT M3_SYC M4_SYC BY V3_SYC
CONNECT M4_SYC M5_SYC BY V4_SYC
CONNECT M5_SYC M6_SYC BY V5_SYC
CONNECT M6_SYC M7_SYC BY V6_SYC
CONNECT M7_SYC M8_SYC BY TV_NOT_MIM_CTOP_mapping_SYC
CONNECT M8_SYC MIM_final_SYC BY TV_AND_MIM_mapping_SYC
CONNECT M8_SYC CTOP_final_SYC BY TV_AND_CTOP_mapping_SYC
CONNECT M8_SYC ALPA_SYC BY PA_SYC
CONNECT TM_1_SYC TM_SYC BY TV_NOT_MIM_CTOP_mapping_SYC
CONNECT TM_SYC MIM_final_SYC BY TV_AND_MIM_mapping_SYC
CONNECT TM_SYC CTOP_final_SYC BY TV_AND_CTOP_mapping_SYC
CONNECT TM_SYC ALPA_SYC BY PA_SYC
CONNECT TM_SYC PA_SYC
CONNECT ALPA_SYC MD_SYC

//; For top via/metal self-connection
CONNECT TV_SYC UTV_SYC
CONNECT TM_SYC UTM_SYC
CONNECT TV_SYC TV_AND_MIM_mapping_SYC
CONNECT TV_SYC TV_AND_CTOP_mapping_SYC
CONNECT TV_SYC TV_NOT_MIM_CTOP_mapping_SYC
CONNECT TV_SYC V7_SYC
CONNECT TM_1_SYC M7_SYC
CONNECT TM_SYC M8_SYC
CONNECT CTOP_NOT_MIM_final_SYC CTOP_final_SYC

//; For all via/metal self-connection
CONNECT TM2_SYC M8_SYC
CONNECT TV2_SYC V7_SYC
// -------------------------------------------------------------
// End of the connection for delta voltage DRC check
// -------------------------------------------------------------

//;----------------------------------------------------------
//;------------ NW delta voltage rule------------------------

#IFDEF Delta_Voltage_Rules_Check YES
VOLTAGE_ABNORMAL {
@ The highest voltage value is less than the lowest voltage value in a net
@ DRC hightlight M0/M0G of the specified net
@ The abnormal voltage will affect the delta voltage judgemnent
 err1 = DFM PROPERTY M0_0 net_vol_assign NODAL MULTI
 [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 [max_minus_min = property(net_vol_assign, max_vol) - property(net_vol_assign, min_vol)] < 0
 err1 NOT INSIDE SealR_NOT_BULK

 DFM RDB err1 "./SMIC_14SFPLUS_DRC_logFile/VOLTAGE_ABNORMAL.RDB"
}
#ENDIF


//;------------ AA delta voltage rule------------------------
AA_c_v_edges = ANGLE AA_c == 90
AA_c_h_edges = ANGLE AA_c == 0

DOP_AA_dv = COPY edge_gate_dopAA_all
DOP_AA_dv_v_edges = ANGLE DOP_AA_dv == 90

AR_in_AA = (AA AND AR) WITH EDGE AR_v_edges == 2
pkup_all = edge_gate_AA_tap NOT AR_in_AA

AA_c_all = (OR AA_c pkup_all edge_gate_AA_uGT edge_gate_AA_uAA) NOT AR_in_AA
AA_c_all_v_edges = ANGLE AA_c_all == 90
AA_SYC_all = EMPTY_syc OR (AA_c_all INTERACT SYNCED_NET)
NSD_SYC_all = EMPTY_syc OR ((AA_c_all interact NSD) INTERACT SYNCED_NET)
PSD_SYC_all = EMPTY_syc OR ((AA_c_all interact PSD) INTERACT SYNCED_NET)
NTAP_SYC_all = EMPTY_syc OR ((AA_c_all interact NTAP) INTERACT SYNCED_NET)
PTAP_SYC_all = EMPTY_syc OR ((AA_c_all interact PTAP) INTERACT SYNCED_NET)

CONNECT AA_c pkup_all
CONNECT AA_c AA_c_all
CONNECT AA_c_all pkup_all
CONNECT AA_SYC AA_SYC_all
CONNECT NSD_SYC NSD_SYC_all
CONNECT PSD_SYC PSD_SYC_all
CONNECT PTAP_SYC AA_SYC_all
CONNECT NTAP_SYC AA_SYC_all

//AA_NET_vol_neg_all = AA_c_all INTERACT AA_NET_vol_neg
//AA_NET_vol_gt_pos_0935_all = AA_c_all INTERACT AA_NET_vol_gt_pos_0935
//AA_NET_vol_lt_neg_0935_all = AA_c_all INTERACT AA_NET_vol_lt_neg_0935
//AA_NET_vol_gt_pos_105_all = AA_c_all INTERACT AA_NET_vol_gt_pos_105
//AA_NET_vol_lt_neg_105_all = AA_c_all INTERACT AA_NET_vol_lt_neg_105
//AA_NET_vol_gt_pos_132_all = AA_c_all INTERACT AA_NET_vol_gt_pos_132
//AA_NET_vol_lt_neg_132_all = AA_c_all INTERACT AA_NET_vol_lt_neg_132
//AA_NET_vol_gt_pos_198_all = AA_c_all INTERACT AA_NET_vol_gt_pos_198
//AA_NET_vol_lt_neg_198_all = AA_c_all INTERACT AA_NET_vol_lt_neg_198
//AA_NET_vol_gt_pos_275_all = AA_c_all INTERACT AA_NET_vol_gt_pos_275
//AA_NET_vol_lt_neg_275_all = AA_c_all INTERACT AA_NET_vol_lt_neg_275
//AA_NET_vol_gt_pos_363_all = AA_c_all INTERACT AA_NET_vol_gt_pos_363
//AA_NET_vol_lt_neg_363_all = AA_c_all INTERACT AA_NET_vol_lt_neg_363

#IFDEF Delta_Voltage_Rules_Check YES
VARIABLE AA_S_11a_val 0.117
VARIABLE AA_S_11b_val 0.096
VARIABLE AA_S_11c_val 0.148
VARIABLE AA_S_11d_val 0.144
VARIABLE AA_S_11e_val 0.248
VARIABLE AA_S_11f_val 0.240
VARIABLE AA_S_12a_val 0.144
VARIABLE AA_S_12b_val 0.162

AA_S_11a {
@ Space between AOP_AA (AA vertical edge extend 1/2 GT width) in S/D direction (maximum delta V >= 1.32V) (1.2V + 10%) >= 0.117um
@ DRC waive violation between S/D sharing one GATE
 err1_TMP = DFM DV AA_c_all_v_edges AA_c_all < AA_S_11a_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 1.32 ANNOTATE NOT CONNECTED OPPOSITE EXTENDED 0.0001
 err1 = (DFM COPY err1_TMP REGION) NOT INSIDE GATE_raw
 err1 NOT INSIDE SealR_NOT_BULK

 err2 = DFM DV AA_c_all_v_edges DOP_AA_dv < AA_S_11a_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 1.32 ANNOTATE NOT CONNECTED OPPOSITE EXTENDED 0.0001
 DFM COPY err2

/*
 err2 = EXT AA_NET_vol_lt_neg_132_all DOP_AA_dv_v_edges < AA_S_11a_val REGION PROJ>=0
 err3 = EXT AA_NET_vol_gt_pos_132_all DOP_AA_dv_v_edges < AA_S_11a_val REGION PROJ>=0
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
*/
}

AA_S_11b {
@ Space between AOP_AA (maximum delta V >= 1.32V, 1.2V + 10%) >= 0.096um
@ DRC waive violation between S/D sharing one GATE
 err1_TMP = DFM DV AA_c < AA_S_11b_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 1.32 ANNOTATE NOT CONNECTED SINGULAR
 err1 = (DFM COPY err1_TMP REGION) NOT INSIDE GATE_raw
 err1 NOT INSIDE SealR_NOT_BULK

 err2 = DFM DV AA_c DOP_AA < AA_S_11b_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 1.32 ANNOTATE NOT CONNECTED SINGULAR
 DFM COPY err2

/*
 err2 = EXT AA_NET_vol_lt_neg_132 DOP_AA < AA_S_11b_val SINGULAR REGION
 err3 = EXT AA_NET_vol_gt_pos_132 DOP_AA < AA_S_11b_val SINGULAR REGION
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
*/
}

AA_S_11c {
@ Space between AOP_AA in S/D direction (AA vertical edge extend 1/2 GT width) (maximum delta V >= 1.98V, 1.8V + 10%) >= 0.148um
@ DRC waive violation between S/D sharing one GATE
 err1_TMP = DFM DV AA_c_all_v_edges AA_c_all < AA_S_11c_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 1.98 ANNOTATE NOT CONNECTED OPPOSITE EXTENDED 0.0001
 err1 = (DFM COPY err1_TMP REGION) NOT INSIDE GATE_raw
 err1 NOT INSIDE SealR_NOT_BULK

 err2 = DFM DV AA_c_all_v_edges DOP_AA_dv < AA_S_11c_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 1.98 ANNOTATE NOT CONNECTED OPPOSITE EXTENDED 0.0001
 DFM COPY err2

/*
 err2 = EXT AA_NET_vol_lt_neg_198_all DOP_AA_dv_v_edges < AA_S_11c_val REGION PROJ>=0
 err3 = EXT AA_NET_vol_gt_pos_198_all DOP_AA_dv_v_edges < AA_S_11c_val REGION PROJ>=0
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
*/
}

AA_S_11d {
@ Space between AOP_AA (maximum delta V >= 1.98V, 1.8V + 10%) >= 0.144um
@ DRC waive violation between S/D sharing one GATE
 err1_TMP = DFM DV AA_c < AA_S_11d_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 1.98 ANNOTATE NOT CONNECTED SINGULAR
 err1 = (DFM COPY err1_TMP REGION) NOT INSIDE GATE_raw
 err1 NOT INSIDE SealR_NOT_BULK

 err2 = DFM DV AA_c DOP_AA < AA_S_11d_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 1.98 ANNOTATE NOT CONNECTED SINGULAR
 DFM COPY err2

/*
 err2 = EXT AA_NET_vol_lt_neg_198 DOP_AA < AA_S_11d_val SINGULAR REGION
 err3 = EXT AA_NET_vol_gt_pos_198 DOP_AA < AA_S_11d_val SINGULAR REGION
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
*/
}

AA_S_11e {
@ Space between AOP_AA (AA vertical edge extend 1/2 GT width) in S/D direction (maximum delta V >= 3.63V, 3.3V + 10%) >= 0.248um
@ DRC waive violation between S/D sharing one GATE
 err1_TMP = DFM DV AA_c_all_v_edges AA_c_all < AA_S_11e_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 3.63 ANNOTATE NOT CONNECTED OPPOSITE EXTENDED 0.0001
 err1 = (DFM COPY err1_TMP REGION) NOT INSIDE GATE_raw
 err1 NOT INSIDE SealR_NOT_BULK

 err2 = DFM DV AA_c_all_v_edges DOP_AA_dv < AA_S_11e_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 3.63 ANNOTATE NOT CONNECTED OPPOSITE EXTENDED 0.0001
 DFM COPY err2

/*
 err2 = EXT AA_NET_vol_lt_neg_363_all DOP_AA_dv_v_edges < AA_S_11e_val REGION PROJ>=0
 err3 = EXT AA_NET_vol_gt_pos_363_all DOP_AA_dv_v_edges < AA_S_11e_val REGION PROJ>=0
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
*/
}

AA_S_11f {
@ Space between AOP_AA (maximum delta V >= 3.63V, 3.3V + 10%) >= 0.24um
@ DRC waive violation between source/drain in one GATE
 err1_TMP = DFM DV AA_c < AA_S_11f_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 3.63 ANNOTATE NOT CONNECTED SINGULAR
 err1 = (DFM COPY err1_TMP REGION) NOT INSIDE GATE_raw
 err1 NOT INSIDE SealR_NOT_BULK

 err2 = DFM DV AA_c DOP_AA < AA_S_11f_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 3.63 ANNOTATE NOT CONNECTED SINGULAR
 DFM COPY err2

/*
 err2 = EXT AA_NET_vol_lt_neg_363 DOP_AA < AA_S_11f_val SINGULAR REGION
 err3 = EXT AA_NET_vol_gt_pos_363 DOP_AA < AA_S_11f_val SINGULAR REGION
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
*/
}

AA_S_12a {
@ Space between NW and N+ ACTIVE (Maximum delta V > 3.63V, 3.3V+10%) >= 0.144um
 err1 = DFM DV NSD NW < AA_S_12a_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 3.63 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err1
}

AA_S_12b {
@ Space between NW and N+ ACTIVE (AA vertical edge extend 1/2 GT width) in S/D direction (Maximum delta V > 3.63V, 3.3V+10%) >= 0.162um
 NSD_c_all = AA_c_all TOUCH EDGE (ANGLE (AA_c_all INTERACT NSD) == 90)
 err1 = DFM DV NSD_c_all NW < AA_S_12b_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 3.63 ANNOTATE NOT CONNECTED OPPOSITE MEASURE ALL
 DFM COPY err1
}


//;------------ GT delta voltage rule------------------------
VARIABLE GT_S_11_val 0.108
VARIABLE GT_S_12_val 0.117
VARIABLE GT_R_19_val 0.77

GT_S_11 {
@ Space between field (AOP_GT NOT P2) and AOP_AA (maximum delta V > 3.63V) (3.3V+10%) >= 0.108um
 err1 = DFM DV AA_c GT_0 < GT_S_11_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 3.63 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err1

 err2 = DFM DV GT_0 DOP_AA < GT_S_11_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 3.63 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err2

 err3 = DFM DV AA_c DOP_GT_NOT_P2 < GT_S_11_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 3.63 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err3

/*
 err5 = EXT GT_NET_vol_lt_neg_363 DOP_AA < GT_S_11_val REGION
 err6 = EXT GT_NET_vol_gt_pos_363 DOP_AA < GT_S_11_val REGION
 err7 = EXT AA_NET_vol_lt_neg_363 DOP_GT_NOT_P2 < GT_S_11_val REGION
 err8 = EXT AA_NET_vol_gt_pos_363 DOP_GT_NOT_P2 < GT_S_11_val REGION
 err5 NOT INSIDE SealR_NOT_BULK
 err6 NOT INSIDE SealR_NOT_BULK
 err7 NOT INSIDE SealR_NOT_BULK
 err8 NOT INSIDE SealR_NOT_BULK
*/
}

GT_S_12 {
@ Space between field (AOP_GT NOT P2) and AOP_AA (AA vertical edge extend 1/2 GT width) (maximum delta V > 3.63V) (3.3V+10%) in S/D direction >= 0.117um
 err1 = DFM DV AA_c_all GT_0_v_edges < GT_S_12_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 3.63 ANNOTATE NOT CONNECTED OPPOSITE EXTENDED 0.0001 MEASURE ALL
 DFM COPY err1

 err2 = DFM DV GT_0_v_edges DOP_AA_dv < GT_S_12_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 3.63 ANNOTATE NOT CONNECTED OPPOSITE EXTENDED 0.0001 MEASURE ALL
 DFM COPY err2

 err3 = DFM DV AA_c_all_v_edges DOP_GT_NOT_P2 < GT_S_12_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 3.63 ANNOTATE NOT CONNECTED OPPOSITE EXTENDED 0.0001 MEASURE ALL
 DFM COPY err3

/*
 err5 = EXT GT_NET_vol_lt_neg_363 DOP_AA_dv_v_edges < GT_S_12_val REGION PROJ>=0
 err6 = EXT GT_NET_vol_gt_pos_363 DOP_AA_dv_v_edges < GT_S_12_val REGION PROJ>=0
 err7 = EXT AA_NET_vol_lt_neg_363_all DOP_GT_NOT_P2 < GT_S_12_val REGION PROJ>=0
 err8 = EXT AA_NET_vol_gt_pos_363_all DOP_GT_NOT_P2 < GT_S_12_val REGION PROJ>=0
 err5 NOT INSIDE SealR_NOT_BULK
 err6 NOT INSIDE SealR_NOT_BULK
 err7 NOT INSIDE SealR_NOT_BULK
 err8 NOT INSIDE SealR_NOT_BULK
*/
}

GT_R_19 {
@ Maximum delta V >= 5.6V is not allowed, when space between (AOP_GT NOT P2) < 0.770um
 err1 = DFM DV GT_0 < GT_R_19_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" >= 5.6 ANNOTATE NOT CONNECTED SINGULAR
 DFM COPY err1

 err2 = DFM DV GT_0 DOP_GT_NOT_P2 < GT_R_19_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" >= 5.6 ANNOTATE NOT CONNECTED SINGULAR
 DFM COPY err2

/*
 err5 = EXT GT_NET_vol_lt_neg_560 DOP_GT_NOT_P2 < GT_R_19_val SINGULAR REGION EXCLUDE SHIELDED
 err6 = EXT GT_NET_vol_gt_pos_560 DOP_GT_NOT_P2 < GT_R_19_val SINGULAR REGION EXCLUDE SHIELDED
 err5 NOT INSIDE SealR_NOT_BULK
 err6 NOT INSIDE SealR_NOT_BULK
*/
}
#ENDIF


//;------------ M0 delta voltage rule------------------------
GT_0_v_edges = ANGLE GT_0 == 90

VARIABLE M0_S_15_val 0.032
VARIABLE M0_S_16_val 0.043
VARIABLE M0_S_17_val 0.061
VARIABLE M0_S_18_val 0.056
VARIABLE M0_S_19_val 0.074
VARIABLE M0_S_20a_val 0.032
VARIABLE M0_S_20b_val 0.047
VARIABLE M0_S_20c_val 0.053
VARIABLE M0_S_20d_val 0.069
VARIABLE M0_S_21_val 0.069

VARIABLE M0_R_5_M0_2_M0_val 0.700
VARIABLE M0_R_5_M0_2_AA_val 0.770
VARIABLE M0_R_5_M0_2_GT_val 0.720

#IFDEF Delta_Voltage_Rules_Check YES
M0_S_15 {
@ Space between (AOP_M0 NOT (M0C OR M0CDMP)) and AOP_AA (AA vertical edge extend 1/2 GT width) (maximum delta V > 1.05V, 0.95V+10%) in S/D direction >= 0.032um
 err1 = DFM DV M0_NOT_M0C_v_edges AA_c_all < M0_S_15_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 1.05 ANNOTATE NOT CONNECTED OPPOSITE EXTENDED 0.0001 MEASURE ALL
 DFM COPY err1

 err2 = DFM DV AA_c_all_v_edges delta_DOP_M0 < M0_S_15_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 1.05 ANNOTATE NOT CONNECTED OPPOSITE EXTENDED 0.0001 MEASURE ALL
 DFM COPY err2

 err3 = DFM DV M0_NOT_M0C_v_edges DOP_AA_dv < M0_S_15_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 1.05 ANNOTATE NOT CONNECTED OPPOSITE EXTENDED 0.0001 MEASURE ALL
 DFM COPY err3

/*
 err5 = EXT AA_NET_vol_lt_neg_105_all (delta_DOP_M0 COIN EDGE DOP_M0_v_edges) < M0_S_15_val REGION PROJ>=0
 err6 = EXT AA_NET_vol_gt_pos_105_all (delta_DOP_M0 COIN EDGE DOP_M0_v_edges) < M0_S_15_val REGION PROJ>=0
 err7 = EXT M0_NET_vol_lt_neg_105 DOP_AA_dv_v_edges < M0_S_15_val REGION PROJ>=0
 err8 = EXT M0_NET_vol_gt_pos_105 DOP_AA_dv_v_edges < M0_S_15_val REGION PROJ>=0
 err5 NOT INSIDE SealR_NOT_BULK
 err6 NOT INSIDE SealR_NOT_BULK
 err7 NOT INSIDE SealR_NOT_BULK
 err8 NOT INSIDE SealR_NOT_BULK
*/
}

M0_S_16 {
@ Space between (AOP_M0 NOT (M0C OR M0CDMP)) and AOP_AA (maximum delta V > 1.98V, 1.8V+10%) >= 0.043um
 err1 = DFM DV M0_NOT_M0C AA_c < M0_S_16_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 1.98 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err1

 err2 = DFM DV AA_c delta_DOP_M0 < M0_S_16_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 1.98 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err2

 err3 = DFM DV M0_NOT_M0C DOP_AA < M0_S_16_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 1.98 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err3

/*
 err5 = EXT AA_NET_vol_lt_neg_198 delta_DOP_M0 < M0_S_16_val SINGULAR REGION
 err6 = EXT AA_NET_vol_gt_pos_198 delta_DOP_M0 < M0_S_16_val SINGULAR REGION
 err7 = EXT M0_NET_vol_lt_neg_198 DOP_AA < M0_S_16_val SINGULAR REGION
 err8 = EXT M0_NET_vol_gt_pos_198 DOP_AA < M0_S_16_val SINGULAR REGION
 err5 NOT INSIDE SealR_NOT_BULK
 err6 NOT INSIDE SealR_NOT_BULK
 err7 NOT INSIDE SealR_NOT_BULK
 err8 NOT INSIDE SealR_NOT_BULK
*/
}

M0_S_17 {
@ Space between (AOP_M0 NOT (M0C OR M0CDMP)) and AOP_AA (AA vertical edge extend 1/2 GT width) (maximum delta V > 1.98V, 1.8V+10%) in S/D direction >= 0.061um
 err1 = DFM DV M0_NOT_M0C_v_edges AA_c_all < M0_S_17_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 1.98 ANNOTATE NOT CONNECTED OPPOSITE EXTENDED 0.0001 MEASURE ALL
 DFM COPY err1

 err2 = DFM DV AA_c_all_v_edges delta_DOP_M0 < M0_S_17_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 1.98 ANNOTATE NOT CONNECTED OPPOSITE EXTENDED 0.0001 MEASURE ALL
 DFM COPY err2

 err3 = DFM DV M0_NOT_M0C_v_edges DOP_AA_dv < M0_S_17_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 1.98 ANNOTATE NOT CONNECTED OPPOSITE EXTENDED 0.0001 MEASURE ALL
 DFM COPY err3

/*
 err5 = EXT AA_NET_vol_lt_neg_198_all (delta_DOP_M0 COIN EDGE DOP_M0_v_edges) < M0_S_17_val REGION PROJ>=0
 err6 = EXT AA_NET_vol_gt_pos_198_all (delta_DOP_M0 COIN EDGE DOP_M0_v_edges) < M0_S_17_val REGION PROJ>=0
 err7 = EXT M0_NET_vol_lt_neg_198 DOP_AA_dv_v_edges < M0_S_17_val REGION PROJ>=0
 err8 = EXT M0_NET_vol_gt_pos_198 DOP_AA_dv_v_edges < M0_S_17_val REGION PROJ>=0
 err5 NOT INSIDE SealR_NOT_BULK
 err6 NOT INSIDE SealR_NOT_BULK
 err7 NOT INSIDE SealR_NOT_BULK
 err8 NOT INSIDE SealR_NOT_BULK
*/
}

M0_S_18 {
@ Space between (AOP_M0 NOT (M0C OR M0CDMP)) and AOP_AA (maximum delta V > 3.63V, 3.3V+10%) >= 0.056um
 err1 = DFM DV M0_NOT_M0C AA_c < M0_S_18_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 3.63 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err1

 err2 = DFM DV AA_c delta_DOP_M0 < M0_S_18_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 3.63 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err2

 err3 = DFM DV M0_NOT_M0C DOP_AA < M0_S_18_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 3.63 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err3

/*
 err5 = EXT AA_NET_vol_lt_neg_363 delta_DOP_M0 < M0_S_18_val SINGULAR REGION
 err6 = EXT AA_NET_vol_gt_pos_363 delta_DOP_M0 < M0_S_18_val SINGULAR REGION
 err7 = EXT M0_NET_vol_lt_neg_363 DOP_AA < M0_S_18_val SINGULAR REGION
 err8 = EXT M0_NET_vol_gt_pos_363 DOP_AA < M0_S_18_val SINGULAR REGION
 err5 NOT INSIDE SealR_NOT_BULK
 err6 NOT INSIDE SealR_NOT_BULK
 err7 NOT INSIDE SealR_NOT_BULK
 err8 NOT INSIDE SealR_NOT_BULK
*/
}

M0_S_19 {
@ Space between (AOP_M0 NOT (M0C OR M0CDMP)) and AOP_AA (AA vertical edge extend 1/2 GT width) (maximum delta V > 3.63V, 3.3V+10%) in S/D direction >= 0.074um
 err1 = DFM DV M0_NOT_M0C_v_edges AA_c_all < M0_S_19_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 3.63 ANNOTATE NOT CONNECTED OPPOSITE EXTENDED 0.0001 MEASURE ALL
 DFM COPY err1

 err2 = DFM DV AA_c_all_v_edges delta_DOP_M0 < M0_S_19_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 3.63 ANNOTATE NOT CONNECTED OPPOSITE EXTENDED 0.0001 MEASURE ALL
 DFM COPY err2

 err3 = DFM DV M0_NOT_M0C_v_edges DOP_AA_dv < M0_S_19_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 3.63 ANNOTATE NOT CONNECTED OPPOSITE EXTENDED 0.0001 MEASURE ALL
 DFM COPY err3

/*
 err5 = EXT AA_NET_vol_lt_neg_363_all (delta_DOP_M0 COIN EDGE DOP_M0_v_edges) < M0_S_19_val REGION PROJ>=0
 err6 = EXT AA_NET_vol_gt_pos_363_all (delta_DOP_M0 COIN EDGE DOP_M0_v_edges) < M0_S_19_val REGION PROJ>=0
 err7 = EXT M0_NET_vol_lt_neg_363 DOP_AA_dv_v_edges < M0_S_19_val REGION PROJ>=0
 err8 = EXT M0_NET_vol_gt_pos_363 DOP_AA_dv_v_edges < M0_S_19_val REGION PROJ>=0
 err5 NOT INSIDE SealR_NOT_BULK
 err6 NOT INSIDE SealR_NOT_BULK
 err7 NOT INSIDE SealR_NOT_BULK
 err8 NOT INSIDE SealR_NOT_BULK
*/
}

M0_S_20a {
@ Space between (AOP_M0 NOT (M0C OR M0CDMP)) and ((AOP_GT NOT P2) INTERACT (AA OR M0G)) (maximum delta V > 1.05V, 0.95V+10%) >= 0.032um
@ Except (GTDMP INSIDE DG) case
 chk_AOP_GT = AOP_GT_NOT_P2 INTERACT (AA OR M0G)
 err1 = DFM DV M0_NOT_M0C (GT_0 INTERACT (AA OR M0G)) < M0_S_20a_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 1.05 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err1

 err2 = DFM DV (GT_0 AND chk_AOP_GT) delta_DOP_M0 < M0_S_20a_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 1.05 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err2

 err3 = DFM DV M0_NOT_M0C ((DOP_GT AND chk_AOP_GT) NOT INSIDE DG) < M0_S_20a_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 1.05 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err3

/*
 err5 = EXT (GT_NET_vol_lt_neg_105 AND chk_AOP_GT) delta_DOP_M0 < M0_S_20a_val SINGULAR REGION
 err6 = EXT (GT_NET_vol_gt_pos_105 AND chk_AOP_GT) delta_DOP_M0 < M0_S_20a_val SINGULAR REGION
 err7 = EXT M0_NET_vol_lt_neg_105 ((DOP_GT AND chk_AOP_GT) NOT INSIDE DG) < M0_S_20a_val SINGULAR REGION
 err8 = EXT M0_NET_vol_gt_pos_105 ((DOP_GT AND chk_AOP_GT) NOT INSIDE DG) < M0_S_20a_val SINGULAR REGION
 err5 NOT INSIDE SealR_NOT_BULK
 err6 NOT INSIDE SealR_NOT_BULK
 err7 NOT INSIDE SealR_NOT_BULK
 err8 NOT INSIDE SealR_NOT_BULK
*/
}

M0_S_20b {
@ Space between (AOP_M0 NOT (M0C OR M0CDMP)) and (AOP_GT NOT P2) (maximum delta V > 1.98V, 1.8V+10%) >= 0.047um
 err1 = DFM DV M0_NOT_M0C GT_0 < M0_S_20b_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 1.98 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err1

 err2 = DFM DV GT_0 delta_DOP_M0 < M0_S_20b_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 1.98 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err2

 err3 = DFM DV M0_NOT_M0C (DOP_GT_NOT_P2 NOT INTERACT (EMOS AND DBESD2)) < M0_S_20b_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 1.98 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err3

/*
 err5 = EXT GT_NET_vol_lt_neg_198 delta_DOP_M0 < M0_S_20b_val SINGULAR REGION
 err6 = EXT GT_NET_vol_gt_pos_198 delta_DOP_M0 < M0_S_20b_val SINGULAR REGION
 err7 = EXT M0_NET_vol_lt_neg_198 (DOP_GT_NOT_P2 NOT INTERACT (EMOS AND DBESD2)) < M0_S_20b_val SINGULAR REGION
 err8 = EXT M0_NET_vol_gt_pos_198 (DOP_GT_NOT_P2 NOT INTERACT (EMOS AND DBESD2)) < M0_S_20b_val SINGULAR REGION
 err5 NOT INSIDE SealR_NOT_BULK
 err6 NOT INSIDE SealR_NOT_BULK
 err7 NOT INSIDE SealR_NOT_BULK
 err8 NOT INSIDE SealR_NOT_BULK
*/
}

M0_S_20c {
@ Space between (AOP_M0 NOT (M0C OR M0CDMP)) and (AOP_GT NOT P2) (maximum delta V > 2.75V, 2.5V+10%) >= 0.053um
 err1 = DFM DV M0_NOT_M0C GT_0 < M0_S_20c_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 2.75 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err1

 err2 = DFM DV GT_0 delta_DOP_M0 < M0_S_20c_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 2.75 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err2

 err3 = DFM DV M0_NOT_M0C (DOP_GT_NOT_P2 NOT INTERACT (EMOS AND DBESD2)) < M0_S_20c_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 2.75 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err3

/*
 err5 = EXT GT_NET_vol_lt_neg_275 delta_DOP_M0 < M0_S_20c_val SINGULAR REGION
 err6 = EXT GT_NET_vol_gt_pos_275 delta_DOP_M0 < M0_S_20c_val SINGULAR REGION
 err7 = EXT M0_NET_vol_lt_neg_275 (DOP_GT_NOT_P2 NOT INTERACT (EMOS AND DBESD2)) < M0_S_20c_val SINGULAR REGION
 err8 = EXT M0_NET_vol_gt_pos_275 (DOP_GT_NOT_P2 NOT INTERACT (EMOS AND DBESD2)) < M0_S_20c_val SINGULAR REGION
 err5 NOT INSIDE SealR_NOT_BULK
 err6 NOT INSIDE SealR_NOT_BULK
 err7 NOT INSIDE SealR_NOT_BULK
 err8 NOT INSIDE SealR_NOT_BULK
*/
}

M0_S_20d {
@ Space between (AOP_M0 NOT (M0C OR M0CDMP)) and (AOP_GT NOT P2) (maximum delta V > 3.63V, 3.3V+10%) >= 0.069um
 err1 = DFM DV M0_NOT_M0C GT_0 < M0_S_20d_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 3.63 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err1

 err2 = DFM DV GT_0 delta_DOP_M0 < M0_S_20d_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 3.63 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err2

 err3 = DFM DV M0_NOT_M0C (DOP_GT NOT INTERACT (EMOS AND DBESD2)) < M0_S_20d_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 3.63 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err3

/*
 err5 = EXT GT_NET_vol_lt_neg_363 delta_DOP_M0 < M0_S_20d_val SINGULAR REGION
 err6 = EXT GT_NET_vol_gt_pos_363 delta_DOP_M0 < M0_S_20d_val SINGULAR REGION
 err7 = EXT M0_NET_vol_lt_neg_363 (DOP_GT NOT INTERACT (EMOS AND DBESD2)) < M0_S_20d_val SINGULAR REGION
 err8 = EXT M0_NET_vol_gt_pos_363 (DOP_GT NOT INTERACT (EMOS AND DBESD2)) < M0_S_20d_val SINGULAR REGION
 err5 NOT INSIDE SealR_NOT_BULK
 err6 NOT INSIDE SealR_NOT_BULK
 err7 NOT INSIDE SealR_NOT_BULK
 err8 NOT INSIDE SealR_NOT_BULK
*/
}

M0_S_21 {
@ Space between (M0 NOT M0C) (maximum delta V > 3.63V, 3.3V+10%) >= 0.069um
 err1 = DFM DV M0_NOT_M0C < M0_S_21_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 3.63 ANNOTATE NOT CONNECTED SINGULAR
 DFM COPY err1
}

M0_R_5_M0_2_M0 {
@ Maximum delta V >= 5.6V is not allowed, when:
@ 1. Space between (AOP_M0 NOT AOP_M0C) is < 0.7um
@ 2. Space between (AOP_M0 NOT AOP_M0C) and AOP_AA is < 0.77um
@ 3. Space between (AOP_M0 NOT AOP_M0C) and (AOP_GT NOT P2) is < 0.72um
 err1 = DFM DV M0_NOT_M0C < M0_R_5_M0_2_M0_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" >= 5.6 ANNOTATE NOT CONNECTED SINGULAR
 DFM COPY err1

 err2 = DFM DV M0_NOT_M0C delta_DOP_M0 < M0_R_5_M0_2_M0_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" >= 5.6 ANNOTATE NOT CONNECTED SINGULAR
 DFM COPY err2

/*
 err5 = EXT M0_NET_vol_gt_pos_560 delta_DOP_M0 < M0_R_5_M0_2_M0_val SINGULAR REGION EXCLUDE SHIELDED
 err6 = EXT M0_NET_vol_Lt_neg_560 delta_DOP_M0 < M0_R_5_M0_2_M0_val SINGULAR REGION EXCLUDE SHIELDED
 err5 NOT INSIDE SealR_NOT_BULK
 err6 NOT INSIDE SealR_NOT_BULK
*/
}

M0_R_5_M0_2_AA {
@ Maximum delta V >= 5.6V is not allowed, when:
@ 1. Space between (AOP_M0 NOT AOP_M0C) is < 0.7um
@ 2. Space between (AOP_M0 NOT AOP_M0C) and AOP_AA is < 0.77um
@ 3. Space between (AOP_M0 NOT AOP_M0C) and (AOP_GT NOT P2) is < 0.72um
 err1 = DFM DV M0_NOT_M0C AA_c < M0_R_5_M0_2_AA_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" >= 5.6 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err1

 err2 = DFM DV AA_c delta_DOP_M0 < M0_R_5_M0_2_AA_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" >= 5.6 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err2

 err3 = DFM DV M0_NOT_M0C DOP_AA < M0_R_5_M0_2_AA_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" >= 5.6 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err3

/*
 err5 = EXT AA_NET_vol_lt_neg_560 delta_DOP_M0 < M0_R_5_M0_2_AA_val SINGULAR REGION
 err6 = EXT AA_NET_vol_gt_pos_560 delta_DOP_M0 < M0_R_5_M0_2_AA_val SINGULAR REGION
 err7 = EXT M0_NET_vol_lt_neg_560 DOP_AA < M0_R_5_M0_2_AA_val SINGULAR REGION
 err8 = EXT M0_NET_vol_gt_pos_560 DOP_AA < M0_R_5_M0_2_AA_val SINGULAR REGION
 err5 NOT INSIDE SealR_NOT_BULK
 err6 NOT INSIDE SealR_NOT_BULK
 err7 NOT INSIDE SealR_NOT_BULK
 err8 NOT INSIDE SealR_NOT_BULK
*/
}

M0_R_5_M0_2_GT {
@ Maximum delta V >= 5.6V is not allowed, when:
@ 1. Space between (AOP_M0 NOT AOP_M0C) is < 0.7um
@ 2. Space between (AOP_M0 NOT AOP_M0C) and AOP_AA is < 0.77um
@ 3. Space between (AOP_M0 NOT AOP_M0C) and (AOP_GT NOT P2) is < 0.72um
 err1 = DFM DV M0_NOT_M0C GT_0 < M0_R_5_M0_2_GT_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" >= 5.6 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err1

 err2 = DFM DV GT_0 delta_DOP_M0 < M0_R_5_M0_2_GT_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" >= 5.6 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err2

 err3 = DFM DV M0_NOT_M0C DOP_GT_NOT_P2 < M0_R_5_M0_2_GT_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" >= 5.6 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err3

/*
 err5 = EXT GT_NET_vol_lt_neg_560 delta_DOP_M0 < M0_R_5_M0_2_GT_val SINGULAR REGION
 err6 = EXT GT_NET_vol_gt_pos_560 delta_DOP_M0 < M0_R_5_M0_2_GT_val SINGULAR REGION
 err7 = EXT M0_NET_vol_lt_neg_560 DOP_GT_NOT_P2 < M0_R_5_M0_2_GT_val SINGULAR REGION
 err8 = EXT M0_NET_vol_gt_pos_560 DOP_GT_NOT_P2 < M0_R_5_M0_2_GT_val SINGULAR REGION
 err5 NOT INSIDE SealR_NOT_BULK
 err6 NOT INSIDE SealR_NOT_BULK
 err7 NOT INSIDE SealR_NOT_BULK
 err8 NOT INSIDE SealR_NOT_BULK
*/
}
#ENDIF


//;------------ M0G delta voltage rule------------------------
VARIABLE M0G_S_32a_val 0.028
VARIABLE M0G_S_32b_val 0.030
VARIABLE M0G_S_32c_val 0.033
VARIABLE M0G_S_32d_val 0.043
VARIABLE M0G_S_32e_val 0.055

VARIABLE M0G_S_33a_val 0.031
VARIABLE M0G_S_33b_val 0.035
VARIABLE M0G_S_33c_val 0.037
VARIABLE M0G_S_33d_val 0.040
VARIABLE M0G_S_33e_val 0.050
VARIABLE M0G_S_33f_val 0.063

VARIABLE M0G_S_34a_val 0.030
VARIABLE M0G_S_34b_val 0.035
VARIABLE M0G_S_34c_val 0.037
VARIABLE M0G_S_34d_val 0.042
VARIABLE M0G_S_34e_val 0.050
VARIABLE M0G_S_34f_val 0.069
VARIABLE M0G_S_35_val 0.067

VARIABLE M0G_R_16_M0G_2_AA_val 0.770
VARIABLE M0G_R_16_M0G_2_GT_val 0.680
VARIABLE M0G_R_16_M0G_2_M0_val 0.720
VARIABLE M0G_R_16_M0G_val 0.700

#IFDEF Delta_Voltage_Rules_Check YES
M0G_S_32a {
@ Space between AOP_M0G and AOP_AA (maximum delta V > 1.32V, 1.2V+10%) in GATE poly direction >= 0.028um
 err1 = DFM DV M0G_h_edges AA_c < M0G_S_32a_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 1.32 ANNOTATE NOT CONNECTED OPPOSITE MEASURE ALL
 DFM COPY err1

 err2 = DFM DV AA_c DOP_M0G_h_edges < M0G_S_32a_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 1.32 ANNOTATE NOT CONNECTED OPPOSITE MEASURE ALL
 DFM COPY err2

 err3 = DFM DV M0G DOP_AA_h_edges < M0G_S_32a_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 1.32 ANNOTATE NOT CONNECTED OPPOSITE MEASURE ALL
 DFM COPY err3

/*
 err5 = EXT AA_NET_vol_lt_neg_132 DOP_M0G_h_edges < M0G_S_32a_val REGION
 err6 = EXT AA_NET_vol_gt_pos_132 DOP_M0G_h_edges < M0G_S_32a_val REGION
 err7 = EXT MG_NET_vol_lt_neg_132 DOP_AA_h_edges < M0G_S_32a_val REGION
 err8 = EXT MG_NET_vol_gt_pos_132 DOP_AA_h_edges < M0G_S_32a_val REGION
 err5 NOT INSIDE SealR_NOT_BULK
 err6 NOT INSIDE SealR_NOT_BULK
 err7 NOT INSIDE SealR_NOT_BULK
 err8 NOT INSIDE SealR_NOT_BULK
*/
}

M0G_S_32b {
@ Space between AOP_M0G and AOP_AA (maximum delta V > 1.65V, 1.5V+10%) in GATE poly direction >= 0.030um
 err1 = DFM DV M0G_h_edges AA_c < M0G_S_32b_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 1.65 ANNOTATE NOT CONNECTED OPPOSITE MEASURE ALL
 DFM COPY err1

 err2 = DFM DV AA_c DOP_M0G_h_edges < M0G_S_32b_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 1.65 ANNOTATE NOT CONNECTED OPPOSITE MEASURE ALL
 DFM COPY err2

 err3 = DFM DV M0G DOP_AA_h_edges < M0G_S_32b_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 1.65 ANNOTATE NOT CONNECTED OPPOSITE MEASURE ALL
 DFM COPY err3

/*
 err5 = EXT AA_NET_vol_lt_neg_165 DOP_M0G_h_edges < M0G_S_32b_val REGION
 err6 = EXT AA_NET_vol_gt_pos_165 DOP_M0G_h_edges < M0G_S_32b_val REGION
 err7 = EXT MG_NET_vol_lt_neg_165 DOP_AA_h_edges < M0G_S_32b_val REGION
 err8 = EXT MG_NET_vol_gt_pos_165 DOP_AA_h_edges < M0G_S_32b_val REGION
 err5 NOT INSIDE SealR_NOT_BULK
 err6 NOT INSIDE SealR_NOT_BULK
 err7 NOT INSIDE SealR_NOT_BULK
 err8 NOT INSIDE SealR_NOT_BULK
*/
}

M0G_S_32c {
@ Space between AOP_M0G and AOP_AA (maximum delta V > 1.98V, 1.8V+10%) in GATE poly direction >= 0.033um
 err1 = DFM DV M0G_h_edges AA_c < M0G_S_32c_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 1.98 ANNOTATE NOT CONNECTED OPPOSITE MEASURE ALL
 DFM COPY err1

 err2 = DFM DV AA_c DOP_M0G_h_edges < M0G_S_32c_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 1.98 ANNOTATE NOT CONNECTED OPPOSITE MEASURE ALL
 DFM COPY err2

 err3 = DFM DV M0G DOP_AA_h_edges < M0G_S_32c_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 1.98 ANNOTATE NOT CONNECTED OPPOSITE MEASURE ALL
 DFM COPY err3

/*
 err5 = EXT AA_NET_vol_lt_neg_198 DOP_M0G_h_edges < M0G_S_32c_val REGION
 err6 = EXT AA_NET_vol_gt_pos_198 DOP_M0G_h_edges < M0G_S_32c_val REGION
 err7 = EXT MG_NET_vol_lt_neg_198 DOP_AA_h_edges < M0G_S_32c_val REGION
 err8 = EXT MG_NET_vol_gt_pos_198 DOP_AA_h_edges < M0G_S_32c_val REGION
 err5 NOT INSIDE SealR_NOT_BULK
 err6 NOT INSIDE SealR_NOT_BULK
 err7 NOT INSIDE SealR_NOT_BULK
 err8 NOT INSIDE SealR_NOT_BULK
*/
}

M0G_S_32d {
@ Space between AOP_M0G and AOP_AA (maximum delta V > 2.75V, 2.5V+10%) in GATE poly direction >= 0.043um
 err1 = DFM DV M0G_h_edges AA_c < M0G_S_32d_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 2.75 ANNOTATE NOT CONNECTED OPPOSITE MEASURE ALL
 DFM COPY err1

 err2 = DFM DV AA_c DOP_M0G_h_edges < M0G_S_32d_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 2.75 ANNOTATE NOT CONNECTED OPPOSITE MEASURE ALL
 DFM COPY err2

 err3 = DFM DV M0G DOP_AA_h_edges < M0G_S_32d_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 2.75 ANNOTATE NOT CONNECTED OPPOSITE MEASURE ALL
 DFM COPY err3

/*
 err5 = EXT AA_NET_vol_lt_neg_275 DOP_M0G_h_edges < M0G_S_32d_val REGION
 err6 = EXT AA_NET_vol_gt_pos_275 DOP_M0G_h_edges < M0G_S_32d_val REGION
 err7 = EXT MG_NET_vol_lt_neg_275 DOP_AA_h_edges < M0G_S_32d_val REGION
 err8 = EXT MG_NET_vol_gt_pos_275 DOP_AA_h_edges < M0G_S_32d_val REGION
 err5 NOT INSIDE SealR_NOT_BULK
 err6 NOT INSIDE SealR_NOT_BULK
 err7 NOT INSIDE SealR_NOT_BULK
 err8 NOT INSIDE SealR_NOT_BULK
*/
}

M0G_S_32e {
@ Space between AOP_M0G and AOP_AA (maximum delta V > 3.63V, 3.3V+10%) in GATE poly direction >= 0.055um
 err1 = DFM DV M0G_h_edges AA_c < M0G_S_32e_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 3.63 ANNOTATE NOT CONNECTED OPPOSITE MEASURE ALL
 DFM COPY err1

 err2 = DFM DV AA_c DOP_M0G_h_edges < M0G_S_32e_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 3.63 ANNOTATE NOT CONNECTED OPPOSITE MEASURE ALL
 DFM COPY err2

 err3 = DFM DV M0G DOP_AA_h_edges < M0G_S_32e_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 3.63 ANNOTATE NOT CONNECTED OPPOSITE MEASURE ALL
 DFM COPY err3

/*
 err5 = EXT AA_NET_vol_lt_neg_363 DOP_M0G_h_edges < M0G_S_32e_val REGION
 err6 = EXT AA_NET_vol_gt_pos_363 DOP_M0G_h_edges < M0G_S_32e_val REGION
 err7 = EXT MG_NET_vol_lt_neg_363 DOP_AA_h_edges < M0G_S_32e_val REGION
 err8 = EXT MG_NET_vol_gt_pos_363 DOP_AA_h_edges < M0G_S_32e_val REGION
 err5 NOT INSIDE SealR_NOT_BULK
 err6 NOT INSIDE SealR_NOT_BULK
 err7 NOT INSIDE SealR_NOT_BULK
 err8 NOT INSIDE SealR_NOT_BULK
*/
}

M0G_S_33a {
@ Space between AOP_M0G and ((AOP_GT NOT P2) INTERACT (AA OR M0G)) (maximum delta V > 0.935V) >= 0.031um
 chk_AOP_GT = AOP_GT_NOT_P2 INTERACT (AA OR M0G)
 err1 = DFM DV M0G (GT_0 INTERACT (AA OR M0G)) < M0G_S_33a_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 0.935 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err1

 err2 = DFM DV (GT_0 INTERACT (AA OR M0G)) DOP_M0G < M0G_S_33a_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 0.935 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err2

 err3 = DFM DV M0G (DOP_GT AND chk_AOP_GT) < M0G_S_33a_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 0.935 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err3

/*
 err5 = EXT (GT_NET_vol_lt_neg_0935 AND chk_AOP_GT) DOP_M0G < M0G_S_33a_val SINGULAR REGION
 err6 = EXT (GT_NET_vol_gt_pos_0935 AND chk_AOP_GT) DOP_M0G < M0G_S_33a_val SINGULAR REGION
 err7 = EXT MG_NET_vol_lt_neg_0935 (DOP_GT AND chk_AOP_GT) < M0G_S_33a_val SINGULAR REGION
 err8 = EXT MG_NET_vol_gt_pos_0935 (DOP_GT AND chk_AOP_GT) < M0G_S_33a_val SINGULAR REGION
 err5 NOT INSIDE SealR_NOT_BULK
 err6 NOT INSIDE SealR_NOT_BULK
 err7 NOT INSIDE SealR_NOT_BULK
 err8 NOT INSIDE SealR_NOT_BULK
*/
}

M0G_S_33b {
@ Space between AOP_M0G and (AOP_GT NOT P2) (maximum delta V > 1.32V, 1.2V+10%) >= 0.035um
 err1 = DFM DV M0G GT_0 < M0G_S_33b_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 1.32 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err1

 err2 = DFM DV GT_0 DOP_M0G < M0G_S_33b_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 1.32 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err2

 err3 = DFM DV M0G (DOP_GT_NOT_P2 NOT INTERACT (EMOS AND DBESD2)) < M0G_S_33b_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 1.32 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err3

/*
 err5 = EXT GT_NET_vol_lt_neg_132 DOP_M0G < M0G_S_33b_val SINGULAR REGION
 err6 = EXT GT_NET_vol_gt_pos_132 DOP_M0G < M0G_S_33b_val SINGULAR REGION
 err7 = EXT MG_NET_vol_lt_neg_132 (DOP_GT_NOT_P2 NOT INTERACT (EMOS AND DBESD2)) < M0G_S_33b_val SINGULAR REGION
 err8 = EXT MG_NET_vol_gt_pos_132 (DOP_GT_NOT_P2 NOT INTERACT (EMOS AND DBESD2)) < M0G_S_33b_val SINGULAR REGION
 err5 NOT INSIDE SealR_NOT_BULK
 err6 NOT INSIDE SealR_NOT_BULK
 err7 NOT INSIDE SealR_NOT_BULK
 err8 NOT INSIDE SealR_NOT_BULK
*/
}

M0G_S_33c {
@ Space between AOP_M0G and (AOP_GT NOT P2) (maximum delta V > 1.65V, 1.5V+10%) >= 0.037um
 err1 = DFM DV M0G GT_0 < M0G_S_33c_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 1.65 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err1

 err2 = DFM DV GT_0 DOP_M0G < M0G_S_33c_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 1.65 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err2

 err3 = DFM DV M0G (DOP_GT_NOT_P2 NOT INTERACT (EMOS AND DBESD2)) < M0G_S_33c_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 1.65 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err3

/*
 err5 = EXT GT_NET_vol_lt_neg_165 DOP_M0G < M0G_S_33c_val SINGULAR REGION
 err6 = EXT GT_NET_vol_gt_pos_165 DOP_M0G < M0G_S_33c_val SINGULAR REGION
 err7 = EXT MG_NET_vol_lt_neg_165 (DOP_GT_NOT_P2 NOT INTERACT (EMOS AND DBESD2)) < M0G_S_33c_val SINGULAR REGION
 err8 = EXT MG_NET_vol_gt_pos_165 (DOP_GT_NOT_P2 NOT INTERACT (EMOS AND DBESD2)) < M0G_S_33c_val SINGULAR REGION
 err5 NOT INSIDE SealR_NOT_BULK
 err6 NOT INSIDE SealR_NOT_BULK
 err7 NOT INSIDE SealR_NOT_BULK
 err8 NOT INSIDE SealR_NOT_BULK
*/
}

M0G_S_33d {
@ Space between AOP_M0G and (AOP_GT NOT P2) (maximum delta V > 1.98V, 1.8V+10%) >= 0.04um
 err1 = DFM DV M0G GT_0 < M0G_S_33d_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 1.98 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err1

 err2 = DFM DV GT_0 DOP_M0G < M0G_S_33d_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 1.98 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err2

 err3 = DFM DV M0G (DOP_GT_NOT_P2 NOT INTERACT (EMOS AND DBESD2)) < M0G_S_33d_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 1.98 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err3

/*
 err5 = EXT GT_NET_vol_lt_neg_198 DOP_M0G < M0G_S_33d_val SINGULAR REGION
 err6 = EXT GT_NET_vol_gt_pos_198 DOP_M0G < M0G_S_33d_val SINGULAR REGION
 err7 = EXT MG_NET_vol_lt_neg_198 (DOP_GT_NOT_P2 NOT INTERACT (EMOS AND DBESD2)) < M0G_S_33d_val SINGULAR REGION
 err8 = EXT MG_NET_vol_gt_pos_198 (DOP_GT_NOT_P2 NOT INTERACT (EMOS AND DBESD2)) < M0G_S_33d_val SINGULAR REGION
 err5 NOT INSIDE SealR_NOT_BULK
 err6 NOT INSIDE SealR_NOT_BULK
 err7 NOT INSIDE SealR_NOT_BULK
 err8 NOT INSIDE SealR_NOT_BULK
*/
}

M0G_S_33e {
@ Space between AOP_M0G and (AOP_GT NOT P2) (maximum delta V > 2.75V, 2.5V+10%) >= 0.05um
 err1 = DFM DV M0G GT_0 < M0G_S_33e_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 2.75 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err1

 err2 = DFM DV GT_0 DOP_M0G < M0G_S_33e_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 2.75 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err2

 err3 = DFM DV M0G (DOP_GT_NOT_P2 NOT INTERACT (EMOS AND DBESD2)) < M0G_S_33e_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 2.75 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err3

/*
 err5 = EXT GT_NET_vol_lt_neg_275 DOP_M0G < M0G_S_33e_val SINGULAR REGION
 err6 = EXT GT_NET_vol_gt_pos_275 DOP_M0G < M0G_S_33e_val SINGULAR REGION
 err7 = EXT MG_NET_vol_lt_neg_275 (DOP_GT_NOT_P2 NOT INTERACT (EMOS AND DBESD2)) < M0G_S_33e_val SINGULAR REGION
 err8 = EXT MG_NET_vol_gt_pos_275 (DOP_GT_NOT_P2 NOT INTERACT (EMOS AND DBESD2)) < M0G_S_33e_val SINGULAR REGION
 err5 NOT INSIDE SealR_NOT_BULK
 err6 NOT INSIDE SealR_NOT_BULK
 err7 NOT INSIDE SealR_NOT_BULK
 err8 NOT INSIDE SealR_NOT_BULK
*/
}

M0G_S_33f {
@ Space between AOP_M0G and (AOP_GT NOT P2) (maximum delta V > 3.63V, 3.3V+10%) >= 0.063um
 err1 = DFM DV M0G GT_0 < M0G_S_33f_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 3.63 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err1

 err2 = DFM DV GT_0 DOP_M0G < M0G_S_33f_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 3.63 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err2

 err3 = DFM DV M0G (DOP_GT_NOT_P2 NOT INTERACT (EMOS AND DBESD2)) < M0G_S_33f_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 3.63 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err3

/*
 err5 = EXT GT_NET_vol_lt_neg_363 DOP_M0G < M0G_S_33f_val SINGULAR REGION
 err6 = EXT GT_NET_vol_gt_pos_363 DOP_M0G < M0G_S_33f_val SINGULAR REGION
 err7 = EXT MG_NET_vol_lt_neg_363 (DOP_GT_NOT_P2 NOT INTERACT (EMOS AND DBESD2)) < M0G_S_33f_val SINGULAR REGION
 err8 = EXT MG_NET_vol_gt_pos_363 (DOP_GT_NOT_P2 NOT INTERACT (EMOS AND DBESD2)) < M0G_S_33f_val SINGULAR REGION
 err5 NOT INSIDE SealR_NOT_BULK
 err6 NOT INSIDE SealR_NOT_BULK
 err7 NOT INSIDE SealR_NOT_BULK
 err8 NOT INSIDE SealR_NOT_BULK
*/
}

M0G_S_34a {
@ Space between AOP_M0G and (AOP_M0 NOT AOP_M0C) (maximum delta V > 1.05V, 0.95V+10%) >= 0.03um
 err1 = DFM DV M0G M0_NOT_M0C < M0G_S_34a_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 1.05 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err1

 err2 = DFM DV M0_NOT_M0C DOP_M0G < M0G_S_34a_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 1.05 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err2

 err3 = DFM DV M0G (DOP_M0 NOT AOP_M0C) < M0G_S_34a_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 1.05 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err3

/*
 err5 = EXT M0_NET_vol_lt_neg_105 DOP_M0G < M0G_S_34a_val SINGULAR REGION
 err6 = EXT M0_NET_vol_gt_pos_105 DOP_M0G < M0G_S_34a_val SINGULAR REGION
 err7 = EXT MG_NET_vol_lt_neg_105 (DOP_M0 NOT AOP_M0C) < M0G_S_34a_val SINGULAR REGION
 err8 = EXT MG_NET_vol_gt_pos_105 (DOP_M0 NOT AOP_M0C) < M0G_S_34a_val SINGULAR REGION
 err5 NOT INSIDE SealR_NOT_BULK
 err6 NOT INSIDE SealR_NOT_BULK
 err7 NOT INSIDE SealR_NOT_BULK
 err8 NOT INSIDE SealR_NOT_BULK
*/
}

M0G_S_34b {
@ Space between AOP_M0G and (AOP_M0 NOT AOP_M0C) (maximum delta V > 1.32V, 1.2V+10%) >= 0.035um
 err1 = DFM DV M0G M0_NOT_M0C < M0G_S_34b_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 1.32 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err1

 err2 = DFM DV M0_NOT_M0C DOP_M0G < M0G_S_34b_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 1.32 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err2

 err3 = DFM DV M0G (DOP_M0 NOT AOP_M0C) < M0G_S_34b_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 1.32 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err3

/*
 err5 = EXT M0_NET_vol_lt_neg_132 DOP_M0G < M0G_S_34b_val SINGULAR REGION
 err6 = EXT M0_NET_vol_gt_pos_132 DOP_M0G < M0G_S_34b_val SINGULAR REGION
 err7 = EXT MG_NET_vol_lt_neg_132 (DOP_M0 NOT AOP_M0C) < M0G_S_34b_val SINGULAR REGION
 err8 = EXT MG_NET_vol_gt_pos_132 (DOP_M0 NOT AOP_M0C) < M0G_S_34b_val SINGULAR REGION
 err5 NOT INSIDE SealR_NOT_BULK
 err6 NOT INSIDE SealR_NOT_BULK
 err7 NOT INSIDE SealR_NOT_BULK
 err8 NOT INSIDE SealR_NOT_BULK
*/
}

M0G_S_34c {
@ Space between AOP_M0G and (AOP_M0 NOT AOP_M0C) (maximum delta V > 1.65V, 1.5V+10%) >= 0.037um
 err1 = DFM DV M0G M0_NOT_M0C < M0G_S_34c_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 1.65 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err1

 err2 = DFM DV M0_NOT_M0C DOP_M0G < M0G_S_34c_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 1.65 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err2

 err3 = DFM DV M0G (DOP_M0 NOT AOP_M0C) < M0G_S_34c_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 1.65 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err3

/*
 err5 = EXT M0_NET_vol_lt_neg_165 DOP_M0G < M0G_S_34c_val SINGULAR REGION
 err6 = EXT M0_NET_vol_gt_pos_165 DOP_M0G < M0G_S_34c_val SINGULAR REGION
 err7 = EXT MG_NET_vol_lt_neg_165 (DOP_M0 NOT AOP_M0C) < M0G_S_34c_val SINGULAR REGION
 err8 = EXT MG_NET_vol_gt_pos_165 (DOP_M0 NOT AOP_M0C) < M0G_S_34c_val SINGULAR REGION
 err5 NOT INSIDE SealR_NOT_BULK
 err6 NOT INSIDE SealR_NOT_BULK
 err7 NOT INSIDE SealR_NOT_BULK
 err8 NOT INSIDE SealR_NOT_BULK
*/
}

M0G_S_34d {
@ Space between AOP_M0G and (AOP_M0 NOT AOP_M0C) (maximum delta V > 1.98V, 1.8V+10%) >= 0.042um
 err1 = DFM DV M0G M0_NOT_M0C < M0G_S_34d_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 1.98 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err1

 err2 = DFM DV M0_NOT_M0C DOP_M0G < M0G_S_34d_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 1.98 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err2

 err3 = DFM DV M0G (DOP_M0 NOT AOP_M0C) < M0G_S_34d_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 1.98 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err3

/*
 err5 = EXT M0_NET_vol_lt_neg_198 DOP_M0G < M0G_S_34d_val SINGULAR REGION
 err6 = EXT M0_NET_vol_gt_pos_198 DOP_M0G < M0G_S_34d_val SINGULAR REGION
 err7 = EXT MG_NET_vol_lt_neg_198 (DOP_M0 NOT AOP_M0C) < M0G_S_34d_val SINGULAR REGION
 err8 = EXT MG_NET_vol_gt_pos_198 (DOP_M0 NOT AOP_M0C) < M0G_S_34d_val SINGULAR REGION
 err5 NOT INSIDE SealR_NOT_BULK
 err6 NOT INSIDE SealR_NOT_BULK
 err7 NOT INSIDE SealR_NOT_BULK
 err8 NOT INSIDE SealR_NOT_BULK
*/
}

M0G_S_34e {
@ Space between AOP_M0G and (AOP_M0 NOT AOP_M0C) (maximum delta V > 2.75V, 2.5V+10%) >= 0.05um
 err1 = DFM DV M0G M0_NOT_M0C < M0G_S_34e_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 2.75 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err1

 err2 = DFM DV M0_NOT_M0C DOP_M0G < M0G_S_34e_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 2.75 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err2

 err3 = DFM DV M0G (DOP_M0 NOT AOP_M0C) < M0G_S_34e_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 2.75 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err3

/*
 err5 = EXT M0_NET_vol_lt_neg_275 DOP_M0G < M0G_S_34e_val SINGULAR REGION
 err6 = EXT M0_NET_vol_gt_pos_275 DOP_M0G < M0G_S_34e_val SINGULAR REGION
 err7 = EXT MG_NET_vol_lt_neg_275 (DOP_M0 NOT AOP_M0C) < M0G_S_34e_val SINGULAR REGION
 err8 = EXT MG_NET_vol_gt_pos_275 (DOP_M0 NOT AOP_M0C) < M0G_S_34e_val SINGULAR REGION
 err5 NOT INSIDE SealR_NOT_BULK
 err6 NOT INSIDE SealR_NOT_BULK
 err7 NOT INSIDE SealR_NOT_BULK
 err8 NOT INSIDE SealR_NOT_BULK
*/
}

M0G_S_34f {
@ Space between AOP_M0G and (AOP_M0 NOT AOP_M0C) (maximum delta V > 3.63V, 3.3V+10%) >= 0.069um
 err1 = DFM DV M0G M0_NOT_M0C < M0G_S_34f_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 3.63 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err1

 err2 = DFM DV M0_NOT_M0C DOP_M0G < M0G_S_34f_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 3.63 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err2

 err3 = DFM DV M0G (DOP_M0 NOT AOP_M0C) < M0G_S_34f_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 3.63 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err3

/*
 err5 = EXT M0_NET_vol_lt_neg_363 DOP_M0G < M0G_S_34f_val SINGULAR REGION
 err6 = EXT M0_NET_vol_gt_pos_363 DOP_M0G < M0G_S_34f_val SINGULAR REGION
 err7 = EXT MG_NET_vol_lt_neg_363 (DOP_M0 NOT AOP_M0C) < M0G_S_34f_val SINGULAR REGION
 err8 = EXT MG_NET_vol_gt_pos_363 (DOP_M0 NOT AOP_M0C) < M0G_S_34f_val SINGULAR REGION
 err5 NOT INSIDE SealR_NOT_BULK
 err6 NOT INSIDE SealR_NOT_BULK
 err7 NOT INSIDE SealR_NOT_BULK
 err8 NOT INSIDE SealR_NOT_BULK
*/
}

M0G_S_35 {
@ Space between M0G and AOP_M0G (maximum delta V > 3.63V, 3.3V+10%) >= 0.067um
 err1 = DFM DV M0G < M0G_S_35_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 3.63 ANNOTATE NOT CONNECTED SINGULAR
 DFM COPY err1

 err2 = DFM DV M0G DOP_M0G < M0G_S_35_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 3.63 ANNOTATE NOT CONNECTED SINGULAR
 DFM COPY err2

/*
 err5 = EXT MG_NET_vol_lt_neg_363 DOP_M0G < M0G_S_35_val SINGULAR REGION
 err6 = EXT MG_NET_vol_gt_pos_363 DOP_M0G < M0G_S_35_val SINGULAR REGION
 err5 NOT INSIDE SealR_NOT_BULK
 err6 NOT INSIDE SealR_NOT_BULK
*/
}

M0G_R_16_M0G {
@ It is not allowed maximum delta V >= 5.6V, when:
@ 1. Space between AOP_M0G is < 0.7um
@ 2. Space between AOP_M0G and AOP_AA is < 0.77um
@ 3. Space between AOP_M0G and (AOP_GT NOT P2) is < 0.68um
@ 4. Space between AOP_M0G and (AOP_M0 NOT AOP_M0C) is < 0.72um
 err1 = DFM DV M0G < M0G_R_16_M0G_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" >= 5.6 ANNOTATE NOT CONNECTED SINGULAR
 DFM COPY err1

 err2 = DFM DV M0G DOP_M0G < M0G_R_16_M0G_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" >= 5.6 ANNOTATE NOT CONNECTED SINGULAR
 DFM COPY err2

/*
 err5 = EXT MG_NET_vol_gt_pos_560 DOP_M0G < M0G_R_16_M0G_val SINGULAR REGION
 err6 = EXT MG_NET_vol_lt_neg_560 DOP_M0G < M0G_R_16_M0G_val SINGULAR REGION
 err5 NOT INSIDE SealR_NOT_BULK
 err6 NOT INSIDE SealR_NOT_BULK
*/
}

M0G_R_16_M0G_2_AA {
@ It is not allowed maximum delta V >= 5.6V, when:
@ 1. Space between AOP_M0G is < 0.7um
@ 2. Space between AOP_M0G and AOP_AA is < 0.77um
@ 3. Space between AOP_M0G and (AOP_GT NOT P2) is < 0.68um
@ 4. Space between AOP_M0G and (AOP_M0 NOT AOP_M0C) is < 0.72um
 err1 = DFM DV M0G AA_c < M0G_R_16_M0G_2_AA_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" >= 5.6 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err1

 err2 = DFM DV M0G DOP_AA < M0G_R_16_M0G_2_AA_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" >= 5.6 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err2

 err3 = DFM DV AA_c DOP_M0G < M0G_R_16_M0G_2_AA_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" >= 5.6 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err3

/*
 err5 = EXT MG_NET_vol_gt_pos_560 DOP_AA < M0G_R_16_M0G_2_AA_val SINGULAR REGION
 err6 = EXT MG_NET_vol_lt_neg_560 DOP_AA < M0G_R_16_M0G_2_AA_val SINGULAR REGION
 err7 = EXT AA_NET_vol_gt_pos_560 DOP_M0G < M0G_R_16_M0G_2_AA_val SINGULAR REGION
 err8 = EXT AA_NET_vol_lt_neg_560 DOP_M0G < M0G_R_16_M0G_2_AA_val SINGULAR REGION
 err5 NOT INSIDE SealR_NOT_BULK
 err6 NOT INSIDE SealR_NOT_BULK
 err7 NOT INSIDE SealR_NOT_BULK
 err8 NOT INSIDE SealR_NOT_BULK
*/
}

M0G_R_16_M0G_2_GT {
@ It is not allowed maximum delta V >= 5.6V, when:
@ 1. Space between AOP_M0G is < 0.7um
@ 2. Space between AOP_M0G and AOP_AA is < 0.77um
@ 3. Space between AOP_M0G and (AOP_GT NOT P2) is < 0.68um
@ 4. Space between AOP_M0G and (AOP_M0 NOT AOP_M0C) is < 0.72um
 err1 = DFM DV M0G GT_0 < M0G_R_16_M0G_2_GT_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" >= 5.6 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err1

 err2 = DFM DV M0G DOP_GT_NOT_P2 < M0G_R_16_M0G_2_GT_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" >= 5.6 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err2

 err3 = DFM DV GT_0 DOP_M0G < M0G_R_16_M0G_2_GT_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" >= 5.6 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err3

/*
 err5 = EXT MG_NET_vol_gt_pos_560 DOP_GT_NOT_P2 < M0G_R_16_M0G_2_GT_val SINGULAR REGION
 err6 = EXT MG_NET_vol_lt_neg_560 DOP_GT_NOT_P2 < M0G_R_16_M0G_2_GT_val SINGULAR REGION
 err7 = EXT GT_NET_vol_gt_pos_560 DOP_M0G < M0G_R_16_M0G_2_GT_val SINGULAR REGION
 err8 = EXT GT_NET_vol_lt_neg_560 DOP_M0G < M0G_R_16_M0G_2_GT_val SINGULAR REGION
 err5 NOT INSIDE SealR_NOT_BULK
 err6 NOT INSIDE SealR_NOT_BULK
 err7 NOT INSIDE SealR_NOT_BULK
 err8 NOT INSIDE SealR_NOT_BULK
*/
}

M0G_R_16_M0G_2_M0 {
@ It is not allowed maximum delta V >= 5.6V, when:
@ 1. Space between AOP_M0G is < 0.7um
@ 2. Space between AOP_M0G and AOP_AA is < 0.77um
@ 3. Space between AOP_M0G and (AOP_GT NOT P2) is < 0.68um
@ 4. Space between AOP_M0G and (AOP_M0 NOT AOP_M0C) is < 0.72um
 err1 = DFM DV M0G M0_NOT_M0C < M0G_R_16_M0G_2_M0_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" >= 5.6 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err1

 err2 = DFM DV M0G delta_DOP_M0 < M0G_R_16_M0G_2_M0_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" >= 5.6 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err2

 err3 = DFM DV M0_NOT_M0C DOP_M0G < M0G_R_16_M0G_2_M0_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" >= 5.6 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err3

/*
 err5 = EXT MG_NET_vol_gt_pos_560 delta_DOP_M0 < M0G_R_16_M0G_2_M0_val SINGULAR REGION
 err6 = EXT MG_NET_vol_lt_neg_560 delta_DOP_M0 < M0G_R_16_M0G_2_M0_val SINGULAR REGION
 err7 = EXT M0_NET_vol_gt_pos_560 DOP_M0G < M0G_R_16_M0G_2_M0_val SINGULAR REGION
 err8 = EXT M0_NET_vol_lt_neg_560 DOP_M0G < M0G_R_16_M0G_2_M0_val SINGULAR REGION
 err5 NOT INSIDE SealR_NOT_BULK
 err6 NOT INSIDE SealR_NOT_BULK
 err7 NOT INSIDE SealR_NOT_BULK
 err8 NOT INSIDE SealR_NOT_BULK
*/
}


//;------------ V0 delta voltage rule------------------------
VARIABLE V0_S_13_M0_val 0.035
VARIABLE V0_S_13_M0G_val 0.035
VARIABLE V0_S_14_M0_val 0.04
VARIABLE V0_S_14_M0G_val 0.040
VARIABLE V0_S_15_M0_val 0.05
VARIABLE V0_S_15_M0G_val 0.05
VARIABLE V0_S_16_M0_val 0.069
VARIABLE V0_S_16_M0G_val 0.069

VARIABLE V0_S_17_val 0.051
VARIABLE V0_S_18_val 0.053
VARIABLE V0_S_19_val 0.059
VARIABLE V0_S_20_val 0.071
VARIABLE V0_S_21_val 0.077
VARIABLE V0_S_22_val 0.158

VARIABLE V0_R_4_val 0.410
VARIABLE RV0_R_7_val 0.410

V0_S_13_M0 {
@ Space between (V0 OR RV0) and (M0G OR (M0 NOT M0C)) (maximum delta V > 0.935V) (0.85V+10%) >= 0.035um
 err1 = DFM DV (V0 INTERACT DVK_V0_SR) M0_NOT_M0C < V0_S_13_M0_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 0.935 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err1
}

V0_S_13_M0G {
@ Space between (V0 OR RV0) and (M0G OR (M0 NOT M0C)) (maximum delta V > 0.935V) (0.85V+10%) >= 0.035um
 err1 = DFM DV (V0 INTERACT DVK_V0_SR) M0G < V0_S_13_M0G_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 0.935 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err1
}

V0_S_14_M0 {
@ Space between (V0 OR RV0) and (M0G OR (M0 NOT M0C)) (maximum delta V > 1.65V) (1.5V+10%) >= 0.04um
 err1 = DFM DV (V0 INTERACT DVK_V0_SR) M0_NOT_M0C < V0_S_14_M0_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 1.65 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err1
}

V0_S_14_M0G {
@ Space between (V0 OR RV0) and (M0G OR (M0 NOT M0C)) (maximum delta V > 1.65V) (1.5V+10%) >= 0.04um
 err1 = DFM DV (V0 INTERACT DVK_V0_SR) M0G < V0_S_14_M0G_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 1.65 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err1
}

V0_S_15_M0 {
@ Space between (V0 OR RV0) and (M0G OR (M0 NOT M0C)) (maximum delta V > 2.75V) (2.5V+10%) >= 0.05um
 err1 = DFM DV (V0 INTERACT DVK_V0_SR) M0_NOT_M0C < V0_S_15_M0_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 2.75 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err1
}

V0_S_15_M0G {
@ Space between (V0 OR RV0) and (M0G OR (M0 NOT M0C)) (maximum delta V > 2.75V) (2.5V+10%) >= 0.05um
 err1 = DFM DV (V0 INTERACT DVK_V0_SR) M0G < V0_S_15_M0G_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 2.75 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err1
}

V0_S_16_M0 {
@ Space between (V0 OR RV0) and (M0G OR (M0 NOT M0C)) (maximum delta V > 3.63V) (3.3V+10%) >= 0.069um
 err1 = DFM DV (V0 INTERACT DVK_V0_SR) M0_NOT_M0C < V0_S_16_M0_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 3.63 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err1
}

V0_S_16_M0G {
@ Space between (V0 OR RV0) and (M0G OR (M0 NOT M0C)) (maximum delta V > 3.63V) (3.3V+10%) >= 0.069um
 err1 = DFM DV (V0 INTERACT DVK_V0_SR) M0G < V0_S_16_M0G_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 3.63 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err1
}

V0_S_17 {
@ Space between (V0 OR RV0) (maximum delta V > 1.05V) (0.95V+10%) >= 0.051um
 err1 = DFM DV (V0 INTERACT DVK_V0_SR) < V0_S_17_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 1.05 ANNOTATE NOT CONNECTED SINGULAR
 DFM COPY err1
}

V0_S_18 {
@ Space between (V0 OR RV0) (maximum delta V > 1.32V) (1.2V+10%) >= 0.053um
 err1 = DFM DV (V0 INTERACT DVK_V0_SR) < V0_S_18_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 1.32 ANNOTATE NOT CONNECTED SINGULAR
 DFM COPY err1
}

V0_S_19 {
@ Space between (V0 OR RV0) (maximum delta V > 1.65V) (1.5V+10%) >= 0.059um
 err1 = DFM DV (V0 INTERACT DVK_V0_SR) < V0_S_19_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 1.65 ANNOTATE NOT CONNECTED SINGULAR
 DFM COPY err1
}

V0_S_20 {
@ Space between (V0 OR RV0) (maximum delta V > 1.98V) (1.8V+10%) >= 0.071um
 err1 = DFM DV (V0 INTERACT DVK_V0_SR) < V0_S_20_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 1.98 ANNOTATE NOT CONNECTED SINGULAR
 DFM COPY err1
}

V0_S_21 {
@ Space between (V0 OR RV0) (maximum delta V > 2.75V) (2.5V+10%) >= 0.077um
 err1 = DFM DV (V0 INTERACT DVK_V0_SR) < V0_S_21_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 2.75 ANNOTATE NOT CONNECTED SINGULAR
 DFM COPY err1
}

V0_S_22 {
@ Space between (V0 OR RV0) (maximum delta V > 3.63V) (3.3V+10%) >= 0.158um
 err1 = DFM DV (V0 INTERACT DVK_V0_SR) < V0_S_22_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 3.63 ANNOTATE NOT CONNECTED SINGULAR
 DFM COPY err1
}

V0_R_4 {
@ Maximum delta V >= 5.6V is not allowed, when space between V0 is < 0.410um
 err1 = DFM DV (V0 INTERACT DVK_V0_SQ) (V0 INTERACT DVK_V0_SR) < V0_R_4_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" >= 5.6 ANNOTATE NOT CONNECTED SINGULAR
 DFM COPY err1
}

RV0_R_7 {
@ Maximum delta V >= 5.6V of (V0 OR RV0) is not allowed, when space between (V0 OR RV0) is < 0.410um
 err1 = DFM DV (V0 INTERACT DVK_V0_SR) < RV0_R_7_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" >= 5.6 ANNOTATE NOT CONNECTED SINGULAR
 DFM COPY err1
}
#ENDIF


VARIABLE M1_S_21_V0_val 0.042
VARIABLE M1_S_21_V1_val 0.042
VARIABLE M1_S_22_V0_val 0.045
VARIABLE M1_S_22_V1_val 0.045
VARIABLE M1_S_23_V0_val 0.053
VARIABLE M1_S_23_V1_val 0.053
VARIABLE M1_S_24_V0_val 0.059
VARIABLE M1_S_24_V1_val 0.059
VARIABLE M1_S_25_V0_val 0.071
VARIABLE M1_S_25_V1_val 0.071
VARIABLE M1_S_26_V0_val 0.076
VARIABLE M1_S_26_V1_val 0.076
VARIABLE M1_S_27_V0_val 0.159
VARIABLE M1_S_27_V1_val 0.159

#IFDEF Delta_Voltage_Rules_Check YES
//;------------ M1 delta voltage rule------------------------
M1_S_21_V0 {
@ Space between M1 and V0, RV0, V1, RV1 (maximum delta V > 1.05V, 0.95V+10%) >= 0.042um
 err1 = DFM DV M1 (V0 INTERACT DVK_V0_SR) < M1_S_21_V0_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 1.05 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err1
}

M1_S_21_V1 {
@ Space between M1 and V0, RV0, V1, RV1 (maximum delta V > 1.05V, 0.95V+10%) >= 0.042um
 err1 = DFM DV M1 (V1 INTERACT DVK_V1_SR) < M1_S_21_V1_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 1.05 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err1
}

M1_S_22_V0 {
@ Space between M1 and V0, RV0, V1, RV1 (maximum delta V > 1.155V, 1.05V+10%) >= 0.045um
 err1 = DFM DV M1 (V0 INTERACT DVK_V0_SR) < M1_S_22_V0_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 1.155 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err1
}

M1_S_22_V1 {
@ Space between M1 and V0, RV0, V1, RV1 (maximum delta V > 1.155V, 1.05V+10%) >= 0.045um
 err1 = DFM DV M1 (V1 INTERACT DVK_V1_SR) < M1_S_22_V1_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 1.155 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err1
}

M1_S_23_V0 {
@ Space between M1 and V0, RV0, V1, RV1 (maximum delta V > 1.32V, 1.2V+10%) >= 0.053um
 err1 = DFM DV M1 (V0 INTERACT DVK_V0_SR) < M1_S_23_V0_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 1.32 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err1
}

M1_S_23_V1 {
@ Space between M1 and V0, RV0, V1, RV1 (maximum delta V > 1.32V, 1.2V+10%) >= 0.053um
 err1 = DFM DV M1 (V1 INTERACT DVK_V1_SR) < M1_S_23_V1_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 1.32 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err1
}

M1_S_24_V0 {
@ Space between M1 and V0, RV0, V1, RV1 (maximum delta V > 1.65V, 1.5V+10%) >= 0.059um
 err1 = DFM DV M1 (V0 INTERACT DVK_V0_SR) < M1_S_24_V0_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 1.65 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err1
}

M1_S_24_V1 {
@ Space between M1 and V0, RV0, V1, RV1 (maximum delta V > 1.65V, 1.5V+10%) >= 0.059um
 err1 = DFM DV M1 (V1 INTERACT DVK_V1_SR) < M1_S_24_V1_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 1.65 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err1
}

M1_S_25_V0 {
@ Space between M1 and V0, RV0, V1, RV1 (maximum delta V > 1.98V, 1.8V+10%) >= 0.071um
 err1 = DFM DV M1 (V0 INTERACT DVK_V0_SR) < M1_S_25_V0_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 1.98 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err1
}

M1_S_25_V1 {
@ Space between M1 and V0, RV0, V1, RV1 (maximum delta V > 1.98V, 1.8V+10%) >= 0.071um
 err1 = DFM DV M1 (V1 INTERACT DVK_V1_SR) < M1_S_25_V1_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 1.98 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err1
}

M1_S_26_V0 {
@ Space between M1 and V0, RV0, V1, RV1 (maximum delta V > 2.75V, 2.5V+10%) >= 0.076um
 err1 = DFM DV M1 (V0 INTERACT DVK_V0_SR) < M1_S_26_V0_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 2.75 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err1
}

M1_S_26_V1 {
@ Space between M1 and V0, RV0, V1, RV1 (maximum delta V > 2.75V, 2.5V+10%) >= 0.076um
 err1 = DFM DV M1 (V1 INTERACT DVK_V1_SR) < M1_S_26_V1_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 2.75 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err1
}

M1_S_27_V0 {
@ Space between M1 and V0, RV0, V1, RV1 (maximum delta V > 3.63V, 3.3V+10%) >= 0.159um
 err1 = DFM DV M1 (V0 INTERACT DVK_V0_SR) < M1_S_27_V0_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 3.63 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err1
}

M1_S_27_V1 {
@ Space between M1 and V0, RV0, V1, RV1 (maximum delta V > 3.63V, 3.3V+10%) >= 0.159um
 err1 = DFM DV M1 (V1 INTERACT DVK_V1_SR) < M1_S_27_V1_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 3.63 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err1
}

VARIABLE M1_S_28_val 0.04
VARIABLE M1_S_29_val 0.042
VARIABLE M1_S_30_val 0.045
VARIABLE M1_S_31_val 0.05
VARIABLE M1_S_32_val 0.068
VARIABLE M1_S_33_val 0.104
VARIABLE M1_S_34_val 0.134

M1_S_28 {
@ Space between M1 (maximum delta V > 1.05V, 0.95V+10%) >= 0.04um
 err1 = DFM DV M1 < M1_S_28_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 1.05 ANNOTATE NOT CONNECTED SINGULAR
 DFM COPY err1
}

M1_S_29 {
@ Space between M1 (maximum delta V > 1.155V, 1.05V+10%) >= 0.042um
 err1 = DFM DV M1 < M1_S_29_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 1.155 ANNOTATE NOT CONNECTED SINGULAR
 DFM COPY err1
}

M1_S_30 {
@ Space between M1 (maximum delta V > 1.32V, 1.2V+10%) >= 0.045um
 err1 = DFM DV M1 < M1_S_30_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 1.32 ANNOTATE NOT CONNECTED SINGULAR
 DFM COPY err1
}

M1_S_31 {
@ Space between M1 (maximum delta V > 1.65V, 1.5V+10%) >= 0.05um
 err1 = DFM DV M1 < M1_S_31_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 1.65 ANNOTATE NOT CONNECTED SINGULAR
 DFM COPY err1
}

M1_S_32 {
@ Space between M1 (maximum delta V > 2.75V, 2.5V+10%) >= 0.068um
 err1 = DFM DV M1 < M1_S_32_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 2.75 ANNOTATE NOT CONNECTED SINGULAR
 DFM COPY err1
}

M1_S_33 {
@ Space between M1 (maximum delta V > 3.63V, 3.3V+10%) >= 0.104um
 err1 = DFM DV M1 < M1_S_33_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 3.63 ANNOTATE NOT CONNECTED SINGULAR
 DFM COPY err1
}

M1_S_34 {
@ Space between M1 line end and M1 when PRL >= 0um (maximum delta V > 3.63V) (3.3V+10%)
@ Definition of \"M1 line end\" M1edge with length < 0.046um (W) between two convex corners >= 0.134um
 err1 = DFM DV M1 (M1 TOUCH EDGE M1_end_0.046) < M1_S_34_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 3.63 ANNOTATE NOT CONNECTED OPPOSITE EXTENDED 0.0001
 DFM COPY err1
}

VARIABLE M1_R_2_M1_val 0.360
VARIABLE M1_R_2_V0_val 0.360
VARIABLE M1_R_2_V1_val 0.360

M1_R_2_M1 {
@ Maximum delta V >= 5.6V is not allowed, when space between M1 and M1/V0/V1 is < 0.360um
 err1 = DFM DV M1 < M1_R_2_M1_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" >= 5.6 ANNOTATE NOT CONNECTED SINGULAR
 DFM COPY err1
}

M1_R_2_V0 {
@ Maximum delta V >= 5.6V is not allowed, when space between M1 and M1/V0/V1 is < 0.360um
 err1 = DFM DV M1 (V0 INTERACT DVK_V0_SR) < M1_R_2_V0_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" >= 5.6 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err1
}

M1_R_2_V1 {
@ Maximum delta V >= 5.6V is not allowed, when space between M1 and M1/V0/V1 is < 0.360um
 err1 = DFM DV M1 (V1 INTERACT DVK_V1_SR) < M1_R_2_V1_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" >= 5.6 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err1
}
#ENDIF


VARIABLE MXY_S_20_val 0.042
VARIABLE MXY_S_21_val 0.045
VARIABLE MXY_S_22_val 0.053
VARIABLE MXY_S_23_val 0.059
VARIABLE MXY_S_24_val 0.071
VARIABLE MXY_S_25_val 0.077
VARIABLE MXY_S_26_val 0.159
VARIABLE MXY_S_27_val 0.040
VARIABLE MXY_S_28_val 0.042
VARIABLE MXY_S_29_val 0.045
VARIABLE MXY_S_30_val 0.050
VARIABLE MXY_S_31_val 0.068
VARIABLE MXY_S_32_val 0.135


#IFDEF Delta_Voltage_Rules_Check YES

 
 //;------------ M${j} delta voltage rule------------------------ 
 
M2_S_20_V1 {
@ Space between Mxy and Vy-1 or Vy where Mxy is the metal layer directly above Vy-1 and underneath Vy (Maximum delta V > 1.05V, 0.95V+10%) >= 0.042um
 chk_VIA = RECTANGLE V1 ORTHOGONAL ONLY
 err1 = DFM DV chk_VIA M2 < MXY_S_20_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 1.05 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err1
}
 
M2_S_20_V2 {
@ Space between Mxy and Vy-1 or Vy where Mxy is the metal layer directly above Vy-1 and underneath Vy (Maximum delta V > 1.05V, 0.95V+10%) >= 0.042um
 chk_VIA = RECTANGLE V2 ORTHOGONAL ONLY
 err1 = DFM DV chk_VIA M2 < MXY_S_20_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 1.05 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err1
}
 
M2_S_21_V1 {
@ Space between Mxy and Vy-1 or Vy where Mxy is the metal layer directly above Vy-1 and underneath Vy (Maximum delta V > 1.155V, 1.05V+10%) >= 0.045um
 chk_VIA = RECTANGLE V1 ORTHOGONAL ONLY
 err1 = DFM DV chk_VIA M2 < MXY_S_21_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 1.155 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err1
}
 
M2_S_21_V2 {
@ Space between Mxy and Vy-1 or Vy where Mxy is the metal layer directly above Vy-1 and underneath Vy (Maximum delta V > 1.155V, 1.05V+10%) >= 0.045um
 chk_VIA = RECTANGLE V2 ORTHOGONAL ONLY
 err1 = DFM DV chk_VIA M2 < MXY_S_21_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 1.155 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err1
}
 
M2_S_22_V1 {
@ Space between Mxy and Vy-1 or Vy where Mxy is the metal layer directly above Vy-1 and underneath Vy (Maximum delta V > 1.32V, 1.2V+10%) >= 0.053um
 chk_VIA = RECTANGLE V1 ORTHOGONAL ONLY
 err1 = DFM DV chk_VIA M2 < MXY_S_22_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 1.32 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err1
}
 
M2_S_22_V2 {
@ Space between Mxy and Vy-1 or Vy where Mxy is the metal layer directly above Vy-1 and underneath Vy (Maximum delta V > 1.32V, 1.2V+10%) >= 0.053um
 chk_VIA = RECTANGLE V2 ORTHOGONAL ONLY
 err1 = DFM DV chk_VIA M2 < MXY_S_22_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 1.32 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err1
}
 
M2_S_23_V1 {
@ Space between Mxy and Vy-1 or Vy where Mxy is the metal layer directly above Vy-1 and underneath Vy (Maximum delta V > 1.65V, 1.5V+10%) >= 0.059um
 chk_VIA = RECTANGLE V1 ORTHOGONAL ONLY
 err1 = DFM DV chk_VIA M2 < MXY_S_23_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 1.65 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err1
}
 
M2_S_23_V2 {
@ Space between Mxy and Vy-1 or Vy where Mxy is the metal layer directly above Vy-1 and underneath Vy (Maximum delta V > 1.65V, 1.5V+10%) >= 0.059um
 chk_VIA = RECTANGLE V2 ORTHOGONAL ONLY
 err1 = DFM DV chk_VIA M2 < MXY_S_23_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 1.65 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err1
}
 
M2_S_24_V1 {
@ Space between Mxy and Vy-1 or Vy where Mxy is the metal layer directly above Vy-1 and underneath Vy (Maximum delta V > 1.98V, 1.8V+10%) >= 0.071um
 chk_VIA = RECTANGLE V1 ORTHOGONAL ONLY
 err1 = DFM DV chk_VIA M2 < MXY_S_24_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 1.98 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err1
}
 
M2_S_24_V2 {
@ Space between Mxy and Vy-1 or Vy where Mxy is the metal layer directly above Vy-1 and underneath Vy (Maximum delta V > 1.98V, 1.8V+10%) >= 0.071um
 chk_VIA = RECTANGLE V2 ORTHOGONAL ONLY
 err1 = DFM DV chk_VIA M2 < MXY_S_24_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 1.98 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err1
}
 
M2_S_25_V1 {
@ Space between Mxy and Vy-1 or Vy where Mxy is the metal layer directly above Vy-1 and underneath Vy (Maximum delta V > 2.75V, 2.5V+10%) >= 0.077um
 chk_VIA = RECTANGLE V1 ORTHOGONAL ONLY
 err1 = DFM DV chk_VIA M2 < MXY_S_25_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 2.75 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err1
}
 
M2_S_25_V2 {
@ Space between Mxy and Vy-1 or Vy where Mxy is the metal layer directly above Vy-1 and underneath Vy (Maximum delta V > 2.75V, 2.5V+10%) >= 0.077um
 chk_VIA = RECTANGLE V2 ORTHOGONAL ONLY
 err1 = DFM DV chk_VIA M2 < MXY_S_25_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 2.75 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err1
}
 
M2_S_26_V1 {
@ Space between Mxy and Vy-1 or Vy where Mxy is the metal layer directly above Vy-1 and underneath Vy (Maximum delta V > 3.63V, 3.3V+10%) >= 0.159um
 chk_VIA = RECTANGLE V1 ORTHOGONAL ONLY
 err1 = DFM DV chk_VIA M2 < MXY_S_26_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 3.63 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err1
}
 
M2_S_26_V2 {
@ Space between Mxy and Vy-1 or Vy where Mxy is the metal layer directly above Vy-1 and underneath Vy (Maximum delta V > 3.63V, 3.3V+10%) >= 0.159um
 chk_VIA = RECTANGLE V2 ORTHOGONAL ONLY
 err1 = DFM DV chk_VIA M2 < MXY_S_26_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 3.63 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err1
}
 
M2_S_27 {
@ Space between Mxy (maximum delta V > 1.05V, 0.95V+10%), except M2 interact MTFUSE >= 0.04um
 err1_TMP = DFM DV M2 < MXY_S_27_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 1.05 ANNOTATE NOT CONNECTED SINGULAR
 err1 = (DFM COPY err1_TMP REGION) OUTSIDE MTFUSE
 err1 NOT INSIDE SealR_NOT_BULK
}
 
M2_S_28 {
@ Space between Mxy (maximum delta V > 1.155V, 1.05V+10%), except M2 interact MTFUSE >= 0.042um
 err1_TMP = DFM DV M2 < MXY_S_28_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 1.155 ANNOTATE NOT CONNECTED SINGULAR
 err1 = (DFM COPY err1_TMP REGION) OUTSIDE MTFUSE
 err1 NOT INSIDE SealR_NOT_BULK
}
 
M2_S_29 {
@ Space between Mxy (maximum delta V > 1.32V, 1.2V+10%), except M2 interact MTFUSE >= 0.045um
 err1_TMP = DFM DV M2 < MXY_S_29_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 1.32 ANNOTATE NOT CONNECTED SINGULAR
 err1 = (DFM COPY err1_TMP REGION) OUTSIDE MTFUSE
 err1 NOT INSIDE SealR_NOT_BULK
}
 
M2_S_30 {
@ Space between Mxy (maximum delta V > 1.65V, 1.5V+10%), except M2 interact MTFUSE >= 0.05um
 err1_TMP = DFM DV M2 < MXY_S_30_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 1.65 ANNOTATE NOT CONNECTED SINGULAR
 err1 = (DFM COPY err1_TMP REGION) OUTSIDE MTFUSE
 err1 NOT INSIDE SealR_NOT_BULK
}
 
M2_S_31 {
@ Space between Mxy (maximum delta V > 2.75V, 2.5V+10%) >= 0.068um
 err1 = DFM DV M2 < MXY_S_31_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 2.75 ANNOTATE NOT CONNECTED SINGULAR
 DFM COPY err1
}
 
M2_S_32 {
@ Space between Mxy (maximum delta V > 3.63V, 3.3V+10%) >= 0.135um
 err1 = DFM DV M2 < MXY_S_32_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 3.63 ANNOTATE NOT CONNECTED SINGULAR
 DFM COPY err1
}
 
M2_R_5_M2 {
@ Maximum delta V >= 5.6V is not allowed, when space between Mxy and Mxy/above via/bottom via < 0.360um
 err1 = DFM DV M2 < 0.360 DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" >= 5.6 ANNOTATE NOT CONNECTED SINGULAR
 DFM COPY err1
}
 
M2_R_5_V1 {
@ Maximum delta V >= 5.6V is not allowed, when space between Mxy and Mxy/above via/bottom via < 0.360um
 err1 = DFM DV M2 V1 < 0.360 DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" >= 5.6 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err1
}
 
M2_R_5_V2 {
@ Maximum delta V >= 5.6V is not allowed, when space between Mxy and Mxy/above via/bottom via < 0.360um
 err1 = DFM DV M2 V2 < 0.360 DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" >= 5.6 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err1
}
 
 //;------------ M${j} delta voltage rule------------------------ 
 
M3_S_20_V2 {
@ Space between Mxy and Vy-1 or Vy where Mxy is the metal layer directly above Vy-1 and underneath Vy (Maximum delta V > 1.05V, 0.95V+10%) >= 0.042um
 chk_VIA = RECTANGLE V2 ORTHOGONAL ONLY
 err1 = DFM DV chk_VIA M3 < MXY_S_20_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 1.05 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err1
}
 
M3_S_20_V3 {
@ Space between Mxy and Vy-1 or Vy where Mxy is the metal layer directly above Vy-1 and underneath Vy (Maximum delta V > 1.05V, 0.95V+10%) >= 0.042um
 chk_VIA = RECTANGLE V3 ORTHOGONAL ONLY
 err1 = DFM DV chk_VIA M3 < MXY_S_20_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 1.05 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err1
}
 
M3_S_21_V2 {
@ Space between Mxy and Vy-1 or Vy where Mxy is the metal layer directly above Vy-1 and underneath Vy (Maximum delta V > 1.155V, 1.05V+10%) >= 0.045um
 chk_VIA = RECTANGLE V2 ORTHOGONAL ONLY
 err1 = DFM DV chk_VIA M3 < MXY_S_21_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 1.155 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err1
}
 
M3_S_21_V3 {
@ Space between Mxy and Vy-1 or Vy where Mxy is the metal layer directly above Vy-1 and underneath Vy (Maximum delta V > 1.155V, 1.05V+10%) >= 0.045um
 chk_VIA = RECTANGLE V3 ORTHOGONAL ONLY
 err1 = DFM DV chk_VIA M3 < MXY_S_21_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 1.155 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err1
}
 
M3_S_22_V2 {
@ Space between Mxy and Vy-1 or Vy where Mxy is the metal layer directly above Vy-1 and underneath Vy (Maximum delta V > 1.32V, 1.2V+10%) >= 0.053um
 chk_VIA = RECTANGLE V2 ORTHOGONAL ONLY
 err1 = DFM DV chk_VIA M3 < MXY_S_22_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 1.32 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err1
}
 
M3_S_22_V3 {
@ Space between Mxy and Vy-1 or Vy where Mxy is the metal layer directly above Vy-1 and underneath Vy (Maximum delta V > 1.32V, 1.2V+10%) >= 0.053um
 chk_VIA = RECTANGLE V3 ORTHOGONAL ONLY
 err1 = DFM DV chk_VIA M3 < MXY_S_22_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 1.32 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err1
}
 
M3_S_23_V2 {
@ Space between Mxy and Vy-1 or Vy where Mxy is the metal layer directly above Vy-1 and underneath Vy (Maximum delta V > 1.65V, 1.5V+10%) >= 0.059um
 chk_VIA = RECTANGLE V2 ORTHOGONAL ONLY
 err1 = DFM DV chk_VIA M3 < MXY_S_23_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 1.65 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err1
}
 
M3_S_23_V3 {
@ Space between Mxy and Vy-1 or Vy where Mxy is the metal layer directly above Vy-1 and underneath Vy (Maximum delta V > 1.65V, 1.5V+10%) >= 0.059um
 chk_VIA = RECTANGLE V3 ORTHOGONAL ONLY
 err1 = DFM DV chk_VIA M3 < MXY_S_23_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 1.65 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err1
}
 
M3_S_24_V2 {
@ Space between Mxy and Vy-1 or Vy where Mxy is the metal layer directly above Vy-1 and underneath Vy (Maximum delta V > 1.98V, 1.8V+10%) >= 0.071um
 chk_VIA = RECTANGLE V2 ORTHOGONAL ONLY
 err1 = DFM DV chk_VIA M3 < MXY_S_24_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 1.98 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err1
}
 
M3_S_24_V3 {
@ Space between Mxy and Vy-1 or Vy where Mxy is the metal layer directly above Vy-1 and underneath Vy (Maximum delta V > 1.98V, 1.8V+10%) >= 0.071um
 chk_VIA = RECTANGLE V3 ORTHOGONAL ONLY
 err1 = DFM DV chk_VIA M3 < MXY_S_24_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 1.98 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err1
}
 
M3_S_25_V2 {
@ Space between Mxy and Vy-1 or Vy where Mxy is the metal layer directly above Vy-1 and underneath Vy (Maximum delta V > 2.75V, 2.5V+10%) >= 0.077um
 chk_VIA = RECTANGLE V2 ORTHOGONAL ONLY
 err1 = DFM DV chk_VIA M3 < MXY_S_25_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 2.75 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err1
}
 
M3_S_25_V3 {
@ Space between Mxy and Vy-1 or Vy where Mxy is the metal layer directly above Vy-1 and underneath Vy (Maximum delta V > 2.75V, 2.5V+10%) >= 0.077um
 chk_VIA = RECTANGLE V3 ORTHOGONAL ONLY
 err1 = DFM DV chk_VIA M3 < MXY_S_25_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 2.75 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err1
}
 
M3_S_26_V2 {
@ Space between Mxy and Vy-1 or Vy where Mxy is the metal layer directly above Vy-1 and underneath Vy (Maximum delta V > 3.63V, 3.3V+10%) >= 0.159um
 chk_VIA = RECTANGLE V2 ORTHOGONAL ONLY
 err1 = DFM DV chk_VIA M3 < MXY_S_26_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 3.63 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err1
}
 
M3_S_26_V3 {
@ Space between Mxy and Vy-1 or Vy where Mxy is the metal layer directly above Vy-1 and underneath Vy (Maximum delta V > 3.63V, 3.3V+10%) >= 0.159um
 chk_VIA = RECTANGLE V3 ORTHOGONAL ONLY
 err1 = DFM DV chk_VIA M3 < MXY_S_26_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 3.63 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err1
}
 
M3_S_27 {
@ Space between Mxy (maximum delta V > 1.05V, 0.95V+10%), except M2 interact MTFUSE >= 0.04um
 err1 = DFM DV M3 < MXY_S_27_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 1.05 ANNOTATE NOT CONNECTED SINGULAR
 DFM COPY err1
}
 
M3_S_28 {
@ Space between Mxy (maximum delta V > 1.155V, 1.05V+10%), except M2 interact MTFUSE >= 0.042um
 err1 = DFM DV M3 < MXY_S_28_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 1.155 ANNOTATE NOT CONNECTED SINGULAR
 DFM COPY err1
}
 
M3_S_29 {
@ Space between Mxy (maximum delta V > 1.32V, 1.2V+10%), except M2 interact MTFUSE >= 0.045um
 err1 = DFM DV M3 < MXY_S_29_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 1.32 ANNOTATE NOT CONNECTED SINGULAR
 DFM COPY err1
}
 
M3_S_30 {
@ Space between Mxy (maximum delta V > 1.65V, 1.5V+10%), except M2 interact MTFUSE >= 0.05um
 err1 = DFM DV M3 < MXY_S_30_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 1.65 ANNOTATE NOT CONNECTED SINGULAR
 DFM COPY err1
}
 
M3_S_31 {
@ Space between Mxy (maximum delta V > 2.75V, 2.5V+10%) >= 0.068um
 err1 = DFM DV M3 < MXY_S_31_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 2.75 ANNOTATE NOT CONNECTED SINGULAR
 DFM COPY err1
}
 
M3_S_32 {
@ Space between Mxy (maximum delta V > 3.63V, 3.3V+10%) >= 0.135um
 err1 = DFM DV M3 < MXY_S_32_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 3.63 ANNOTATE NOT CONNECTED SINGULAR
 DFM COPY err1
}
 
M3_R_5_M3 {
@ Maximum delta V >= 5.6V is not allowed, when space between Mxy and Mxy/above via/bottom via < 0.360um
 err1 = DFM DV M3 < 0.360 DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" >= 5.6 ANNOTATE NOT CONNECTED SINGULAR
 DFM COPY err1
}
 
M3_R_5_V2 {
@ Maximum delta V >= 5.6V is not allowed, when space between Mxy and Mxy/above via/bottom via < 0.360um
 err1 = DFM DV M3 V2 < 0.360 DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" >= 5.6 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err1
}
 
M3_R_5_V3 {
@ Maximum delta V >= 5.6V is not allowed, when space between Mxy and Mxy/above via/bottom via < 0.360um
 err1 = DFM DV M3 V3 < 0.360 DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" >= 5.6 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err1
}
 
 //;------------ M${j} delta voltage rule------------------------ 
 
 //;------------ M${j} delta voltage rule------------------------ 
 
 //;------------ M${j} delta voltage rule------------------------ 
 
 //;------------ M${j} delta voltage rule------------------------ 
 
 //;------------ M${j} delta voltage rule------------------------ 
 
 //;------------ M${j} delta voltage rule------------------------ 
 
 //;------------ Vy${j} delta voltage rule------------------------ 
Vy1_R_5 {
@ Maximum delta V >= 5.6V is not allowed, when space between Vy is < 0.410um
 chk_VIA = V1 INTERACT DVK_V1_SQ
 err1 = DFM DV chk_VIA V1 < 0.410 DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" >= 5.6 ANNOTATE NOT CONNECTED SINGULAR
 DFM COPY err1
}
 
RVy1_R_8 {
@ Maximum delta V >= 5.6V is not allowed, when space between Vy and RVy is < 0.410um
 err1 = DFM DV (V1 INTERACT DVK_V1_SR) < 0.410 DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" >= 5.6 ANNOTATE NOT CONNECTED SINGULAR
 DFM COPY err1
}
 
 //;------------ Vy${j} delta voltage rule------------------------ 
Vy2_R_5 {
@ Maximum delta V >= 5.6V is not allowed, when space between Vy is < 0.410um
 chk_VIA = V2 INTERACT DVK_V2_SQ
 err1 = DFM DV chk_VIA V2 < 0.410 DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" >= 5.6 ANNOTATE NOT CONNECTED SINGULAR
 DFM COPY err1
}
 
RVy2_R_8 {
@ Maximum delta V >= 5.6V is not allowed, when space between Vy and RVy is < 0.410um
 err1 = DFM DV (V2 INTERACT DVK_V2_SR) < 0.410 DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" >= 5.6 ANNOTATE NOT CONNECTED SINGULAR
 DFM COPY err1
}
 
 //;------------ Vy${j} delta voltage rule------------------------ 
Vy3_R_5 {
@ Maximum delta V >= 5.6V is not allowed, when space between Vy is < 0.410um
 chk_VIA = V3 INTERACT DVK_V3_SQ
 err1 = DFM DV chk_VIA V3 < 0.410 DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" >= 5.6 ANNOTATE NOT CONNECTED SINGULAR
 DFM COPY err1
}
 
RVy3_R_8 {
@ Maximum delta V >= 5.6V is not allowed, when space between Vy and RVy is < 0.410um
 err1 = DFM DV (V3 INTERACT DVK_V3_SR) < 0.410 DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" >= 5.6 ANNOTATE NOT CONNECTED SINGULAR
 DFM COPY err1
}
 
 //;------------ Vy${j} delta voltage rule------------------------ 
 
 //;------------ Vy${j} delta voltage rule------------------------ 
 
 //;------------ Vy${j} delta voltage rule------------------------ 
 
 //;------------ Vy${j} delta voltage rule------------------------ 
 
 //;------------ Vy${j} delta voltage rule------------------------ 
VARIABLE 125xmy_S_31_val 0.046
VARIABLE 125xmy_S_32_val 0.059
VARIABLE 125xmy_S_33_val 0.079
VARIABLE 125xmy_S_34_val 0.159
VARIABLE 125xmy_S_35_val 0.046
VARIABLE 125xmy_S_36_val 0.079
VARIABLE 125xmy_S_37_val 0.104
VARIABLE 125xmy_S_37a_val 0.135
 
 //;------------ 1.25My${j} delta voltage rule------------------------ 
 
 //;------------ 1.25My${j} delta voltage rule------------------------ 
 
 //;------------ 1.25My${j} delta voltage rule------------------------ 
 
 //;------------ 1.25My${j} delta voltage rule------------------------ 
125xmy4_S_31_V3 {
@ Space between 1.25xMy and Vy or 1.25xVn (maximum delta V > 1.155V) (1.05V + 10%) >= 0.046um
@ ("V3_40" is mapped to "V3" in the rule name of this check)
 chk_VIA = RECTANGLE V3 ORTHOGONAL ONLY
 err1 = DFM DV M4 chk_VIA < 125xmy_S_31_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 1.155 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err1
}
 
125xmy4_S_31_V4 {
@ Space between 1.25xMy and Vy or 1.25xVn (maximum delta V > 1.155V) (1.05V + 10%) >= 0.046um
@ ("V4_50" is mapped to "V4" in the rule name of this check)
 chk_VIA = RECTANGLE V4 ORTHOGONAL ONLY
 err1 = DFM DV M4 chk_VIA < 125xmy_S_31_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 1.155 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err1
}
 
125xmy4_S_32_V3 {
@ Space between 1.25xMy and Vy or 1.25xVn (maximum delta V > 1.32V) (1.2V + 10%) >= 0.059um
@ ("V3_40" is mapped to "V3" in the rule name of this check)
 chk_VIA = RECTANGLE V3 ORTHOGONAL ONLY
 err1 = DFM DV M4 chk_VIA < 125xmy_S_32_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 1.32 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err1
}
 
125xmy4_S_32_V4 {
@ Space between 1.25xMy and Vy or 1.25xVn (maximum delta V > 1.32V) (1.2V + 10%) >= 0.059um
@ ("V4_50" is mapped to "V4" in the rule name of this check)
 chk_VIA = RECTANGLE V4 ORTHOGONAL ONLY
 err1 = DFM DV M4 chk_VIA < 125xmy_S_32_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 1.32 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err1
}
 
125xmy4_S_33_V3 {
@ Space between 1.25xMy and Vy or 1.25xVn (maximum delta V > 1.98V) (1.8V + 10%) >= 0.079um
@ ("V3_40" is mapped to "V3" in the rule name of this check)
 chk_VIA = RECTANGLE V3 ORTHOGONAL ONLY
 err1 = DFM DV M4 chk_VIA < 125xmy_S_33_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 1.98 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err1
}
 
125xmy4_S_33_V4 {
@ Space between 1.25xMy and Vy or 1.25xVn (maximum delta V > 1.98V) (1.8V + 10%) >= 0.079um
@ ("V4_50" is mapped to "V4" in the rule name of this check)
 chk_VIA = RECTANGLE V4 ORTHOGONAL ONLY
 err1 = DFM DV M4 chk_VIA < 125xmy_S_33_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 1.98 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err1
}
 
125xmy4_S_34_V3 {
@ Space between 1.25xMy and Vy or 1.25xVn (maximum delta V > 3.63V) (3.3V + 10%) >= 0.159um
@ ("V3_40" is mapped to "V3" in the rule name of this check)
 chk_VIA = RECTANGLE V3 ORTHOGONAL ONLY
 err1 = DFM DV M4 chk_VIA < 125xmy_S_34_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 3.63 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err1
}
 
125xmy4_S_34_V4 {
@ Space between 1.25xMy and Vy or 1.25xVn (maximum delta V > 3.63V) (3.3V + 10%) >= 0.159um
@ ("V4_50" is mapped to "V4" in the rule name of this check)
 chk_VIA = RECTANGLE V4 ORTHOGONAL ONLY
 err1 = DFM DV M4 chk_VIA < 125xmy_S_34_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 3.63 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err1
}
 
125xmy4_S_35 {
@ Space between two 1.25xMy (maximum delta V > 1.98V) (1.8V + 10%) >= 0.046um
 err1 = DFM DV M4 < 125xmy_S_35_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 1.98 ANNOTATE NOT CONNECTED SINGULAR
 DFM COPY err1
}
 
125xmy4_S_36 {
@ Space between two 1.25xMy (maximum delta V > 2.75V) (2.5V + 10%) >= 0.079um
 err1 = DFM DV M4 < 125xmy_S_36_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 2.75 ANNOTATE NOT CONNECTED SINGULAR
 DFM COPY err1
}
 
125xmy4_S_37 {
@ Space between two 1.25xMy (maximum delta V > 3.63V) (3.3V + 10%) >= 0.104um
 err1 = DFM DV M4 < 125xmy_S_37_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 3.63 ANNOTATE NOT CONNECTED SINGULAR
 DFM COPY err1
}
 
125xmy4_S_37a {
@ Space between 1.25xMy line-end (width < 0.08um) and 1.25xMy (Maximum delta V > 3.63V) (3.3V + 10%) when PRL >= 0um. >= 0.135um
@ Definition of "1.25xMy line-end": 1.25xMy edge length < 0.08um between two convex corners
 err1 = DFM DV M4 (M4 TOUCH EDGE M4_end_080) < 125xmy_S_37a_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 3.63 ANNOTATE NOT CONNECTED OPPOSITE EXTENDED 0.0001
 DFM COPY err1
}
 
125xmy4_R_4_M4 {
@ It is not allowed for maximum delta V >= 5.6V, when pace between 1.25xMy and 1.25xMy/above via/bottom via is < 0.36um
 err1 = DFM DV M4 < 0.360 DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" >= 5.6 ANNOTATE NOT CONNECTED SINGULAR
 DFM COPY err1
}
 
125xmy4_R_4_V3 {
@ It is not allowed for maximum delta V >= 5.6V, when pace between 1.25xMy and 1.25xMy/above via/bottom via is < 0.36um
@ ("V3_40" is mapped to "V3" in the rule name of this check)
 err1 = DFM DV M4 V3 < 0.360 DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" >= 5.6 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err1
}
 
125xmy4_R_4_V4 {
@ It is not allowed for maximum delta V >= 5.6V, when pace between 1.25xMy and 1.25xMy/above via/bottom via is < 0.36um
@ ("V4_50" is mapped to "V4" in the rule name of this check)
 err1 = DFM DV M4 V4 < 0.360 DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" >= 5.6 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err1
}
 
 //;------------ 1.25My${j} delta voltage rule------------------------ 
 
 //;------------ 1.25My${j} delta voltage rule------------------------ 
 
 //;------------ 1.25My${j} delta voltage rule------------------------ 
 
 //;------------ 1.25My${j} delta voltage rule------------------------ 
 
 //;------------ 1.25My${j} delta voltage rule------------------------ 

VARIABLE 125xMn_S_31_val 0.046
VARIABLE 125xMn_S_32_val 0.059
VARIABLE 125xMn_S_33_val 0.079
VARIABLE 125xMn_S_34_val 0.159
VARIABLE 125xMn_S_35_val 0.046
VARIABLE 125xMn_S_36_val 0.079
VARIABLE 125xMn_S_37_val 0.104
VARIABLE 125xMn_S_37a_val 0.135

 
 //;------------ 1.25Mn${j} delta voltage rule------------------------ 
 
 //;------------ 1.25Mn${j} delta voltage rule------------------------ 
 
 //;------------ 1.25Mn${j} delta voltage rule------------------------ 
 
 //;------------ 1.25Mn${j} delta voltage rule------------------------ 
 
 //;------------ 1.25Mn${j} delta voltage rule------------------------ 
125xm5_S_31_V4 {
@ Space between 1.25xMn and 1.25xVn-1 or 1.25xVn/10xTVn (maximum delta V > 1.155V) (1.05V + 10%) >= 0.046um
@ ("V4_50" is mapped to "V4" in the rule name of this check)
 chk_VIA = RECTANGLE V4 ORTHOGONAL ONLY
 err1 = DFM DV M5 chk_VIA < 125xMn_S_31_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 1.155 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err1
}
 
125xm5_S_31_V5 {
@ Space between 1.25xMn and 1.25xVn-1 or 1.25xVn/10xTVn (maximum delta V > 1.155V) (1.05V + 10%) >= 0.046um
@ ("V5_50" is mapped to "V5" in the rule name of this check)
 chk_VIA = RECTANGLE V5 ORTHOGONAL ONLY
 err1 = DFM DV M5 chk_VIA < 125xMn_S_31_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 1.155 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err1
}
 
125xm5_S_32_V4 {
@ Space between 1.25xMn and 1.25xVn-1 or 1.25xVn/10xTVn (maximum delta V > 1.32V) (1.2V + 10%) >= 0.059um
@ ("V4_50" is mapped to "V4" in the rule name of this check)
 chk_VIA = RECTANGLE V4 ORTHOGONAL ONLY
 err1 = DFM DV M5 chk_VIA < 125xMn_S_32_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 1.32 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err1
}
 
125xm5_S_32_V5 {
@ Space between 1.25xMn and 1.25xVn-1 or 1.25xVn/10xTVn (maximum delta V > 1.32V) (1.2V + 10%) >= 0.059um
@ ("V5_50" is mapped to "V5" in the rule name of this check)
 chk_VIA = RECTANGLE V5 ORTHOGONAL ONLY
 err1 = DFM DV M5 chk_VIA < 125xMn_S_32_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 1.32 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err1
}
 
125xm5_S_33_V4 {
@ Space between 1.25xMn and 1.25xVn-1 or 1.25xVn/10xTVn (maximum delta V > 1.98V) (1.8V + 10%) >= 0.079um
@ ("V4_50" is mapped to "V4" in the rule name of this check)
 chk_VIA = RECTANGLE V4 ORTHOGONAL ONLY
 err1 = DFM DV M5 chk_VIA < 125xMn_S_33_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 1.98 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err1
}
 
125xm5_S_33_V5 {
@ Space between 1.25xMn and 1.25xVn-1 or 1.25xVn/10xTVn (maximum delta V > 1.98V) (1.8V + 10%) >= 0.079um
@ ("V5_50" is mapped to "V5" in the rule name of this check)
 chk_VIA = RECTANGLE V5 ORTHOGONAL ONLY
 err1 = DFM DV M5 chk_VIA < 125xMn_S_33_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 1.98 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err1
}
 
125xm5_S_34_V4 {
@ Space between 1.25xMn and 1.25xVn-1 or 1.25xVn/10xTVn (maximum delta V > 3.63V) (3.3V + 10%) >= 0.159um
@ ("V4_50" is mapped to "V4" in the rule name of this check)
 chk_VIA = RECTANGLE V4 ORTHOGONAL ONLY
 err1 = DFM DV M5 chk_VIA < 125xMn_S_34_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 3.63 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err1
}
 
125xm5_S_34_V5 {
@ Space between 1.25xMn and 1.25xVn-1 or 1.25xVn/10xTVn (maximum delta V > 3.63V) (3.3V + 10%) >= 0.159um
@ ("V5_50" is mapped to "V5" in the rule name of this check)
 chk_VIA = RECTANGLE V5 ORTHOGONAL ONLY
 err1 = DFM DV M5 chk_VIA < 125xMn_S_34_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 3.63 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err1
}
 
125xm5_S_35 {
@ Space between two 1.25xMn (maximum delta V > 1.98V) (1.8V + 10%) >= 0.046um
 err1 = DFM DV M5 < 125xMn_S_35_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 1.98 ANNOTATE NOT CONNECTED SINGULAR
 DFM COPY err1
}
 
125xm5_S_36 {
@ Space between two 1.25xMn (maximum delta V > 2.75V) (2.5V + 10%) >= 0.079um
 err1 = DFM DV M5 < 125xMn_S_36_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 2.75 ANNOTATE NOT CONNECTED SINGULAR
 DFM COPY err1
}
 
125xm5_S_37 {
@ Space between two 1.25xMn (maximum delta V > 3.63V) (3.3V + 10%) >= 0.104um
 err1 = DFM DV M5 < 125xMn_S_37_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 3.63 ANNOTATE NOT CONNECTED SINGULAR
 DFM COPY err1
}
 
125xm5_S_37a {
@ Space between 1.25xMn line-end (width < 0.08um) and 1.25xMn (Maximum delta V > 3.63V) (3.3V + 10%) when PRL >= 0um. >= 0.135um
 err1 = DFM DV M5 (M5 TOUCH EDGE M5_end_080) < 125xMn_S_37a_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 3.63 ANNOTATE NOT CONNECTED OPPOSITE EXTENDED 0.0001
 DFM COPY err1
}
 
125xm5_R_4_M5 {
@ It is not allowed for maximum delta V >= 5.6V, when space between 1.25xMn and 1.25xMn/1.25xVn-1/1.25xVn is < 0.36um
@ ("M5_55" is mapped to "M5" in the rule name of this check)
 err1 = DFM DV M5 < 0.360 DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" >= 5.6 ANNOTATE NOT CONNECTED SINGULAR
 DFM COPY err1
}
 
125xm5_R_4_V4 {
@ It is not allowed for maximum delta V >= 5.6V, when space between 1.25xMn and 1.25xMn/1.25xVn-1/1.25xVn is < 0.36um
@ ("V4_50" is mapped to "V4" in the rule name of this check)
 err1 = DFM DV M5 V4 < 0.360 DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" >= 5.6 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err1
}
 
125xm5_R_4_V5 {
@ It is not allowed for maximum delta V >= 5.6V, when space between 1.25xMn and 1.25xMn/1.25xVn-1/1.25xVn is < 0.36um
@ ("V5_50" is mapped to "V5" in the rule name of this check)
 err1 = DFM DV M5 V5 < 0.360 DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" >= 5.6 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err1
}
 
 //;------------ 1.25Mn${j} delta voltage rule------------------------ 
125xm6_S_31_V5 {
@ Space between 1.25xMn and 1.25xVn-1 or 1.25xVn/10xTVn (maximum delta V > 1.155V) (1.05V + 10%) >= 0.046um
@ ("V5_50" is mapped to "V5" in the rule name of this check)
 chk_VIA = RECTANGLE V5 ORTHOGONAL ONLY
 err1 = DFM DV M6 chk_VIA < 125xMn_S_31_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 1.155 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err1
}
 
125xm6_S_31_V6 {
@ Space between 1.25xMn and 1.25xVn-1 or 1.25xVn/10xTVn (maximum delta V > 1.155V) (1.05V + 10%) >= 0.046um
@ ("V6_50" is mapped to "V6" in the rule name of this check)
 chk_VIA = RECTANGLE V6 ORTHOGONAL ONLY
 err1 = DFM DV M6 chk_VIA < 125xMn_S_31_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 1.155 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err1
}
 
125xm6_S_32_V5 {
@ Space between 1.25xMn and 1.25xVn-1 or 1.25xVn/10xTVn (maximum delta V > 1.32V) (1.2V + 10%) >= 0.059um
@ ("V5_50" is mapped to "V5" in the rule name of this check)
 chk_VIA = RECTANGLE V5 ORTHOGONAL ONLY
 err1 = DFM DV M6 chk_VIA < 125xMn_S_32_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 1.32 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err1
}
 
125xm6_S_32_V6 {
@ Space between 1.25xMn and 1.25xVn-1 or 1.25xVn/10xTVn (maximum delta V > 1.32V) (1.2V + 10%) >= 0.059um
@ ("V6_50" is mapped to "V6" in the rule name of this check)
 chk_VIA = RECTANGLE V6 ORTHOGONAL ONLY
 err1 = DFM DV M6 chk_VIA < 125xMn_S_32_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 1.32 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err1
}
 
125xm6_S_33_V5 {
@ Space between 1.25xMn and 1.25xVn-1 or 1.25xVn/10xTVn (maximum delta V > 1.98V) (1.8V + 10%) >= 0.079um
@ ("V5_50" is mapped to "V5" in the rule name of this check)
 chk_VIA = RECTANGLE V5 ORTHOGONAL ONLY
 err1 = DFM DV M6 chk_VIA < 125xMn_S_33_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 1.98 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err1
}
 
125xm6_S_33_V6 {
@ Space between 1.25xMn and 1.25xVn-1 or 1.25xVn/10xTVn (maximum delta V > 1.98V) (1.8V + 10%) >= 0.079um
@ ("V6_50" is mapped to "V6" in the rule name of this check)
 chk_VIA = RECTANGLE V6 ORTHOGONAL ONLY
 err1 = DFM DV M6 chk_VIA < 125xMn_S_33_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 1.98 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err1
}
 
125xm6_S_34_V5 {
@ Space between 1.25xMn and 1.25xVn-1 or 1.25xVn/10xTVn (maximum delta V > 3.63V) (3.3V + 10%) >= 0.159um
@ ("V5_50" is mapped to "V5" in the rule name of this check)
 chk_VIA = RECTANGLE V5 ORTHOGONAL ONLY
 err1 = DFM DV M6 chk_VIA < 125xMn_S_34_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 3.63 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err1
}
 
125xm6_S_34_V6 {
@ Space between 1.25xMn and 1.25xVn-1 or 1.25xVn/10xTVn (maximum delta V > 3.63V) (3.3V + 10%) >= 0.159um
@ ("V6_50" is mapped to "V6" in the rule name of this check)
 chk_VIA = RECTANGLE V6 ORTHOGONAL ONLY
 err1 = DFM DV M6 chk_VIA < 125xMn_S_34_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 3.63 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err1
}
 
125xm6_S_35 {
@ Space between two 1.25xMn (maximum delta V > 1.98V) (1.8V + 10%) >= 0.046um
 err1 = DFM DV M6 < 125xMn_S_35_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 1.98 ANNOTATE NOT CONNECTED SINGULAR
 DFM COPY err1
}
 
125xm6_S_36 {
@ Space between two 1.25xMn (maximum delta V > 2.75V) (2.5V + 10%) >= 0.079um
 err1 = DFM DV M6 < 125xMn_S_36_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 2.75 ANNOTATE NOT CONNECTED SINGULAR
 DFM COPY err1
}
 
125xm6_S_37 {
@ Space between two 1.25xMn (maximum delta V > 3.63V) (3.3V + 10%) >= 0.104um
 err1 = DFM DV M6 < 125xMn_S_37_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 3.63 ANNOTATE NOT CONNECTED SINGULAR
 DFM COPY err1
}
 
125xm6_S_37a {
@ Space between 1.25xMn line-end (width < 0.08um) and 1.25xMn (Maximum delta V > 3.63V) (3.3V + 10%) when PRL >= 0um. >= 0.135um
 err1 = DFM DV M6 (M6 TOUCH EDGE M6_end_080) < 125xMn_S_37a_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 3.63 ANNOTATE NOT CONNECTED OPPOSITE EXTENDED 0.0001
 DFM COPY err1
}
 
125xm6_R_4_M6 {
@ It is not allowed for maximum delta V >= 5.6V, when space between 1.25xMn and 1.25xMn/1.25xVn-1/1.25xVn is < 0.36um
@ ("M6_50" is mapped to "M6" in the rule name of this check)
 err1 = DFM DV M6 < 0.360 DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" >= 5.6 ANNOTATE NOT CONNECTED SINGULAR
 DFM COPY err1
}
 
125xm6_R_4_V5 {
@ It is not allowed for maximum delta V >= 5.6V, when space between 1.25xMn and 1.25xMn/1.25xVn-1/1.25xVn is < 0.36um
@ ("V5_50" is mapped to "V5" in the rule name of this check)
 err1 = DFM DV M6 V5 < 0.360 DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" >= 5.6 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err1
}
 
125xm6_R_4_V6 {
@ It is not allowed for maximum delta V >= 5.6V, when space between 1.25xMn and 1.25xMn/1.25xVn-1/1.25xVn is < 0.36um
@ ("V6_50" is mapped to "V6" in the rule name of this check)
 err1 = DFM DV M6 V6 < 0.360 DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" >= 5.6 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err1
}
 
 //;------------ 1.25Mn${j} delta voltage rule------------------------ 
125xm7_S_31_V6 {
@ Space between 1.25xMn and 1.25xVn-1 or 1.25xVn/10xTVn (maximum delta V > 1.155V) (1.05V + 10%) >= 0.046um
@ ("V6_50" is mapped to "V6" in the rule name of this check)
 chk_VIA = RECTANGLE V6 ORTHOGONAL ONLY
 err1 = DFM DV M7 chk_VIA < 125xMn_S_31_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 1.155 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err1
}
 
125xm7_S_31_V7 {
@ Space between 1.25xMn and 1.25xVn-1 or 1.25xVn/10xTVn (maximum delta V > 1.155V) (1.05V + 10%) >= 0.046um
@ ("TV2" is mapped to "V7" in the rule name of this check)
 chk_VIA = RECTANGLE V7 ORTHOGONAL ONLY
 err1 = DFM DV M7 chk_VIA < 125xMn_S_31_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 1.155 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err1
}
 
125xm7_S_32_V6 {
@ Space between 1.25xMn and 1.25xVn-1 or 1.25xVn/10xTVn (maximum delta V > 1.32V) (1.2V + 10%) >= 0.059um
@ ("V6_50" is mapped to "V6" in the rule name of this check)
 chk_VIA = RECTANGLE V6 ORTHOGONAL ONLY
 err1 = DFM DV M7 chk_VIA < 125xMn_S_32_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 1.32 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err1
}
 
125xm7_S_32_V7 {
@ Space between 1.25xMn and 1.25xVn-1 or 1.25xVn/10xTVn (maximum delta V > 1.32V) (1.2V + 10%) >= 0.059um
@ ("TV2" is mapped to "V7" in the rule name of this check)
 chk_VIA = RECTANGLE V7 ORTHOGONAL ONLY
 err1 = DFM DV M7 chk_VIA < 125xMn_S_32_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 1.32 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err1
}
 
125xm7_S_33_V6 {
@ Space between 1.25xMn and 1.25xVn-1 or 1.25xVn/10xTVn (maximum delta V > 1.98V) (1.8V + 10%) >= 0.079um
@ ("V6_50" is mapped to "V6" in the rule name of this check)
 chk_VIA = RECTANGLE V6 ORTHOGONAL ONLY
 err1 = DFM DV M7 chk_VIA < 125xMn_S_33_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 1.98 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err1
}
 
125xm7_S_33_V7 {
@ Space between 1.25xMn and 1.25xVn-1 or 1.25xVn/10xTVn (maximum delta V > 1.98V) (1.8V + 10%) >= 0.079um
@ ("TV2" is mapped to "V7" in the rule name of this check)
 chk_VIA = RECTANGLE V7 ORTHOGONAL ONLY
 err1 = DFM DV M7 chk_VIA < 125xMn_S_33_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 1.98 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err1
}
 
125xm7_S_34_V6 {
@ Space between 1.25xMn and 1.25xVn-1 or 1.25xVn/10xTVn (maximum delta V > 3.63V) (3.3V + 10%) >= 0.159um
@ ("V6_50" is mapped to "V6" in the rule name of this check)
 chk_VIA = RECTANGLE V6 ORTHOGONAL ONLY
 err1 = DFM DV M7 chk_VIA < 125xMn_S_34_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 3.63 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err1
}
 
125xm7_S_34_V7 {
@ Space between 1.25xMn and 1.25xVn-1 or 1.25xVn/10xTVn (maximum delta V > 3.63V) (3.3V + 10%) >= 0.159um
@ ("TV2" is mapped to "V7" in the rule name of this check)
 chk_VIA = RECTANGLE V7 ORTHOGONAL ONLY
 err1 = DFM DV M7 chk_VIA < 125xMn_S_34_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 3.63 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err1
}
 
125xm7_S_35 {
@ Space between two 1.25xMn (maximum delta V > 1.98V) (1.8V + 10%) >= 0.046um
 err1 = DFM DV M7 < 125xMn_S_35_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 1.98 ANNOTATE NOT CONNECTED SINGULAR
 DFM COPY err1
}
 
125xm7_S_36 {
@ Space between two 1.25xMn (maximum delta V > 2.75V) (2.5V + 10%) >= 0.079um
 err1 = DFM DV M7 < 125xMn_S_36_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 2.75 ANNOTATE NOT CONNECTED SINGULAR
 DFM COPY err1
}
 
125xm7_S_37 {
@ Space between two 1.25xMn (maximum delta V > 3.63V) (3.3V + 10%) >= 0.104um
 err1 = DFM DV M7 < 125xMn_S_37_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 3.63 ANNOTATE NOT CONNECTED SINGULAR
 DFM COPY err1
}
 
125xm7_S_37a {
@ Space between 1.25xMn line-end (width < 0.08um) and 1.25xMn (Maximum delta V > 3.63V) (3.3V + 10%) when PRL >= 0um. >= 0.135um
 err1 = DFM DV M7 (M7 TOUCH EDGE M7_end_080) < 125xMn_S_37a_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 3.63 ANNOTATE NOT CONNECTED OPPOSITE EXTENDED 0.0001
 DFM COPY err1
}
 
125xm7_R_4_M7 {
@ It is not allowed for maximum delta V >= 5.6V, when space between 1.25xMn and 1.25xMn/1.25xVn-1/1.25xVn is < 0.36um
@ ("M7_55" is mapped to "M7" in the rule name of this check)
 err1 = DFM DV M7 < 0.360 DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" >= 5.6 ANNOTATE NOT CONNECTED SINGULAR
 DFM COPY err1
}
 
125xm7_R_4_V6 {
@ It is not allowed for maximum delta V >= 5.6V, when space between 1.25xMn and 1.25xMn/1.25xVn-1/1.25xVn is < 0.36um
@ ("V6_50" is mapped to "V6" in the rule name of this check)
 err1 = DFM DV M7 V6 < 0.360 DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" >= 5.6 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err1
}
 
 //;------------ 1.25Mn${j} delta voltage rule------------------------ 
 
 //;------------ 1.25Mn${j} delta voltage rule------------------------ 

//;------------ 2xVn (BV1/BV2) delta voltage rule------------------------ 
VARIABLE 2xVn_S_2_val 0.178
VARIABLE 2xVn_R_8_val 0.410


//;------------ 2xMn (B1) delta voltage rule------------------------ 
VARIABLE 2xMn_S_2_val 0.08
VARIABLE 2xMn_S_11_val 0.071
VARIABLE 2xMn_S_12_val 0.089
VARIABLE 2xMn_S_13_val 0.161


//;------------ 2xMn (B2) delta voltage rule------------------------ 

#ENDIF

all_metal_layer = OR  M1 M2 M3 M4 M5 M6 M7 M8 
all_metal_layer_solid = (((((((M1 INTERACT MARKS) AND M2) AND M3) AND M4) AND M5) AND M6) AND M7) AND M8

//#IFDEF SEAL_RING_RULES_CHECK YES
// =======================================================
// Seal ring DRC checking rule
// =======================================================
//;Note: DRC need check AR_H layer ((18:0) OR 131:30)) and AR_V layer ((22:0) OR 131:31))

GROUP GSRC SRC_?

VARIABLE skew_grid 0.001

M0_Seal_Ring_all = M0 AND MARKS
M0_Seal_Ring_orth = RECTANGLE M0_Seal_Ring_all
M0_Seal_Ring_real = NOT RECTANGLE M0_Seal_Ring_all
M0_Seal_Ring_joint = CONVEX EDGE M0_Seal_Ring_all ANGLE1>269<271 ANGLE2>224<226

V0_Seal_Ring_all = V0 AND MARKS
V0_Seal_Ring_orth = RECTANGLE V0_Seal_Ring_all
V0_Seal_Ring_real = NOT RECTANGLE V0_Seal_Ring_all
V0_Seal_Ring_joint = CONVEX EDGE V0_Seal_Ring_all ANGLE1>269<271 ANGLE2>224<226

PPAA_Seal_Ring_all = PPAA AND MARKS
PPAA_Seal_Ring_orth = RECTANGLE PPAA_Seal_Ring_all
PPAA_Seal_Ring_real = NOT RECTANGLE PPAA_Seal_Ring_all
PPAA_Seal_Ring_joint = CONVEX EDGE PPAA_Seal_Ring_all ANGLE1>269<271 ANGLE2>224<226
PPAA_Seal_Ring_real_v = PPAA_Seal_Ring_real COIN EDGE PPAA_v_edges
PPAA_Seal_Ring_real_h = PPAA_Seal_Ring_real COIN EDGE PPAA_h_edges
PPAA_Seal_Ring_inner = HOLES PPAA_Seal_Ring_real INNER
PPAA_Seal_Ring_outer = (HOLES PPAA_Seal_Ring_real) OR (PPAA_Seal_Ring_real TOUCH (HOLES PPAA_Seal_Ring_real))
PPAA_line_end = CONVEX EDGE PPAA_Seal_Ring_all ANGLE1==90 ANGLE2==90 WITH LENGTH == 0.134

SRC_1a {
@ Fixed width of orthogonal PPAA = 0.134um
 orth_v_edges_CHK = PPAA_Seal_Ring_real COIN EDGE PPAA_v_edges
 orth_h_edges_CHK = PPAA_Seal_Ring_real COIN EDGE PPAA_h_edges
 orth_v_edges_good = INT [orth_v_edges_CHK] == 0.134 ABUT<90 OPPOSITE
 orth_h_edges_good = INT [orth_h_edges_CHK] == 0.134 ABUT<90 OPPOSITE
 err1 = (orth_v_edges_CHK NOT TOUCH EDGE orth_v_edges_good) NOT COIN EDGE PPAA_Seal_Ring_joint
 err2 = (orth_h_edges_CHK NOT TOUCH EDGE orth_h_edges_good) NOT COIN EDGE PPAA_Seal_Ring_joint
 err1 NOT INSIDE EDGE SealR_NOT_BULK
 err2 NOT INSIDE EDGE SealR_NOT_BULK
}

SRC_1b {
@ Fixed width of PPAA at 45 degree angle area = 0.132~0.136um
 skew_edge_CHK = ANGLE PPAA_Seal_Ring_real > 44 < 46
 good_edge_all = INT [PPAA_Seal_Ring_real] >= 0.132-skew_grid <= 0.136+skew_grid ABUT<90 OPPOSITE ANGLED==2
 err1 = LENGTH (skew_edge_CHK NOT TOUCH EDGE good_edge_all) > 0.136+skew_grid
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

SRC_2a {
@ Space between orthogonal PPAA = 0.154um
 good_ring_v = EXT [PPAA_Seal_Ring_real_v] == 0.154 ABUT<90 OPPOSITE
 good_ring_h = EXT [PPAA_Seal_Ring_real_h] == 0.154 ABUT<90 OPPOSITE
 err1_TMP = ((PPAA_Seal_Ring_real_v NOT TOUCH EDGE good_ring_v) NOT COIN EDGE PPAA_Seal_Ring_inner) NOT COIN EDGE PPAA_Seal_Ring_outer
 err2_TMP = ((PPAA_Seal_Ring_real_h NOT TOUCH EDGE good_ring_h) NOT COIN EDGE PPAA_Seal_Ring_inner) NOT COIN EDGE PPAA_Seal_Ring_outer
 err1 = EXPAND EDGE (err1_TMP NOT COIN EDGE PPAA_line_end) OUTSIDE BY 0.001
 err2 = EXPAND EDGE (err2_TMP NOT COIN EDGE PPAA_line_end) OUTSIDE BY 0.001
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

SRC_2b {
@ Space between PPAA at 45 degree angle area = 0.214~0.274um
 chk_skew = ANGLE PPAA_Seal_Ring_real > 44 < 46
 err1 = EXT chk_skew PPAA_Seal_Ring_real < 0.214-skew_grid ABUT<90 OPPOSITE1 REGION
 err1 NOT INSIDE SealR_NOT_BULK

 PPAA_rvs = DRC:1 NOT PPAA_Seal_Ring_all
 PPAA_rvs_ring = (PPAA_rvs INTERACT PPAA_Seal_Ring_all == 2) INTERACT (DONUT PPAA_Seal_Ring_all) == 2
 PPAA_rvs_ring_SKEW = ANGLE PPAA_rvs_ring > 44 < 46
 err2_TMP1 = PPAA_rvs_ring_SKEW NOT TOUCH EDGE (INT [PPAA_rvs_ring_SKEW] <= 0.274+skew_grid OPPOSITE)

 PPAA_corner = PPAA_Seal_Ring_all NOT INTERACT (DONUT PPAA_Seal_Ring_all)
 PPAA_corner_MERGED = SIZE PPAA_corner BY (0.274/2 + 0.0005) OVERUNDER
 err2_TMP2 = PPAA_corner_MERGED INTERACT (DRC:1 INTERACT PPAA_corner_MERGED > 4)
 err2 = OR err2_TMP2 (EXPAND EDGE err2_TMP1 BY 0.001)
 err2 NOT INSIDE SealR_NOT_BULK
}

SRC_3a_M0 {
@ Fixed width of M0/V0 slot at orthogonal direction = 0.1um
 orth_v_edges_CHK = M0_Seal_Ring_real COIN EDGE M0_v_edges
 orth_h_edges_CHK = M0_Seal_Ring_real COIN EDGE M0_h_edges
 orth_v_edges_good = INT [orth_v_edges_CHK] == 0.1 ABUT<90 OPPOSITE
 orth_h_edges_good = INT [orth_h_edges_CHK] == 0.1 ABUT<90 OPPOSITE
 err1 = (orth_v_edges_CHK NOT TOUCH EDGE orth_v_edges_good) NOT COIN EDGE M0_Seal_Ring_joint
 err2 = (orth_h_edges_CHK NOT TOUCH EDGE orth_h_edges_good) NOT COIN EDGE M0_Seal_Ring_joint
 err1 NOT INSIDE EDGE SealR_NOT_BULK
 err2 NOT INSIDE EDGE SealR_NOT_BULK
}

SRC_3a_V0 {
@ Fixed width of M0/V0 slot at orthogonal direction = 0.1um
 orth_v_edges_CHK = V0_Seal_Ring_real COIN EDGE V0_v_edges
 orth_h_edges_CHK = V0_Seal_Ring_real COIN EDGE V0_h_edges
 orth_v_edges_good = INT [orth_v_edges_CHK] == 0.1 ABUT<90 OPPOSITE
 orth_h_edges_good = INT [orth_h_edges_CHK] == 0.1 ABUT<90 OPPOSITE
 err1 = (orth_v_edges_CHK NOT TOUCH EDGE orth_v_edges_good) NOT COIN EDGE V0_Seal_Ring_joint
 err2 = (orth_h_edges_CHK NOT TOUCH EDGE orth_h_edges_good) NOT COIN EDGE V0_Seal_Ring_joint
 err1 NOT INSIDE EDGE SealR_NOT_BULK
 err2 NOT INSIDE EDGE SealR_NOT_BULK
}

SRC_3b_M0 {
@ Fixed width of M0/V0 slot at 45 degree angle area = 0.098~0.102um
 skew_edge_CHK = ANGLE M0_Seal_Ring_real > 44 < 46
 good_edge_all = INT [M0_Seal_Ring_real] >= 0.098-skew_grid <= 0.102+skew_grid ABUT<90 OPPOSITE ANGLED==2
 err1 = LENGTH (skew_edge_CHK NOT TOUCH EDGE good_edge_all) > 0.102+skew_grid
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

SRC_3b_V0 {
@ Fixed width of M0/V0 slot at 45 degree angle area = 0.098~0.102um
 skew_edge_CHK = ANGLE V0_Seal_Ring_real > 44 < 46
 good_edge_all = INT [V0_Seal_Ring_real] >= 0.098-skew_grid <= 0.102+skew_grid ABUT<90 OPPOSITE ANGLED==2
 err1 = LENGTH (skew_edge_CHK NOT TOUCH EDGE good_edge_all) > 0.102+skew_grid
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
V1_Seal_Ring_all = V1 AND MARKS
V1_Seal_Ring_orth = RECTANGLE V1_Seal_Ring_all
V1_Seal_Ring_real = NOT RECTANGLE V1_Seal_Ring_all
V1_Seal_Ring_joint = LENGTH (CONVEX EDGE V1_Seal_Ring_all ANGLE1>269<271 ANGLE2>224<226) < 0.05
V1_Seal_Ring_real_v = V1_Seal_Ring_real COIN EDGE (ANGLE V1 == 90)
V1_Seal_Ring_real_h = V1_Seal_Ring_real COIN EDGE (ANGLE V1 == 0)
V1_Seal_Ring_inner = HOLES V1_Seal_Ring_real INNER
V1_Seal_Ring_outer = (HOLES V1_Seal_Ring_real) OR (V1_Seal_Ring_real TOUCH (HOLES V1_Seal_Ring_real))
V1_line_end = OR EDGE (CONVEX EDGE V1_Seal_Ring_all ANGLE1==90 ANGLE2==90 WITH LENGTH == 0.45) (CONVEX EDGE V1_Seal_Ring_all ANGLE1==90 ANGLE2==90 WITH LENGTH == 0.100)
 
SRC_4a_V1 {
@ Fixed width of Vy/1.25xVn/2xVn slot at orthogonal direction, except the edge length < 0.05um between 270-225 corners = 0.45 or 0.1um
 good_ring_v1 = INT [V1_Seal_Ring_real_v] == 0.45 ABUT<90 OPPOSITE
 good_ring_h1 = INT [V1_Seal_Ring_real_h] == 0.45 ABUT<90 OPPOSITE
 good_ring_v2 = INT [V1_Seal_Ring_real_v] == 0.10 ABUT<90 OPPOSITE
 good_ring_h2 = INT [V1_Seal_Ring_real_h] == 0.10 ABUT<90 OPPOSITE
 err1 = V1_Seal_Ring_real_v NOT TOUCH EDGE (OR EDGE (OR EDGE (OR EDGE good_ring_v1 good_ring_v2) V1_line_end) V1_Seal_Ring_joint)
 err2 = V1_Seal_Ring_real_h NOT TOUCH EDGE (OR EDGE (OR EDGE (OR EDGE good_ring_h1 good_ring_h2) V1_line_end) V1_Seal_Ring_joint)
 err1 NOT INSIDE EDGE SealR_NOT_BULK
 err2 NOT INSIDE EDGE SealR_NOT_BULK
}
 
SRC_4b_V1 {
@ Fixed width of Vy/1.25xVn/2xVn slot at 45 degree angle area = 0.5~0.504 or 0.12~0.16um
 skew_edge_CHK = ANGLE V1_Seal_Ring_real > 44 < 46
 good_edge_a = INT [V1_Seal_Ring_real] >= 0.500-skew_grid <= 0.504+skew_grid ABUT<90 OPPOSITE ANGLED==2 EXCLUDE SHIELDED
 good_edge_b = INT [V1_Seal_Ring_real] >= 0.120-skew_grid <= 0.160+skew_grid ABUT<90 OPPOSITE ANGLED==2 EXCLUDE SHIELDED
 err1 = skew_edge_CHK NOT TOUCH EDGE (OR EDGE good_edge_a good_edge_b)
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
V2_Seal_Ring_all = V2 AND MARKS
V2_Seal_Ring_orth = RECTANGLE V2_Seal_Ring_all
V2_Seal_Ring_real = NOT RECTANGLE V2_Seal_Ring_all
V2_Seal_Ring_joint = LENGTH (CONVEX EDGE V2_Seal_Ring_all ANGLE1>269<271 ANGLE2>224<226) < 0.05
V2_Seal_Ring_real_v = V2_Seal_Ring_real COIN EDGE (ANGLE V2 == 90)
V2_Seal_Ring_real_h = V2_Seal_Ring_real COIN EDGE (ANGLE V2 == 0)
V2_Seal_Ring_inner = HOLES V2_Seal_Ring_real INNER
V2_Seal_Ring_outer = (HOLES V2_Seal_Ring_real) OR (V2_Seal_Ring_real TOUCH (HOLES V2_Seal_Ring_real))
V2_line_end = OR EDGE (CONVEX EDGE V2_Seal_Ring_all ANGLE1==90 ANGLE2==90 WITH LENGTH == 0.45) (CONVEX EDGE V2_Seal_Ring_all ANGLE1==90 ANGLE2==90 WITH LENGTH == 0.100)
 
SRC_4a_V2 {
@ Fixed width of Vy/1.25xVn/2xVn slot at orthogonal direction, except the edge length < 0.05um between 270-225 corners = 0.45 or 0.1um
 good_ring_v1 = INT [V2_Seal_Ring_real_v] == 0.45 ABUT<90 OPPOSITE
 good_ring_h1 = INT [V2_Seal_Ring_real_h] == 0.45 ABUT<90 OPPOSITE
 good_ring_v2 = INT [V2_Seal_Ring_real_v] == 0.10 ABUT<90 OPPOSITE
 good_ring_h2 = INT [V2_Seal_Ring_real_h] == 0.10 ABUT<90 OPPOSITE
 err1 = V2_Seal_Ring_real_v NOT TOUCH EDGE (OR EDGE (OR EDGE (OR EDGE good_ring_v1 good_ring_v2) V2_line_end) V2_Seal_Ring_joint)
 err2 = V2_Seal_Ring_real_h NOT TOUCH EDGE (OR EDGE (OR EDGE (OR EDGE good_ring_h1 good_ring_h2) V2_line_end) V2_Seal_Ring_joint)
 err1 NOT INSIDE EDGE SealR_NOT_BULK
 err2 NOT INSIDE EDGE SealR_NOT_BULK
}
 
SRC_4b_V2 {
@ Fixed width of Vy/1.25xVn/2xVn slot at 45 degree angle area = 0.5~0.504 or 0.12~0.16um
 skew_edge_CHK = ANGLE V2_Seal_Ring_real > 44 < 46
 good_edge_a = INT [V2_Seal_Ring_real] >= 0.500-skew_grid <= 0.504+skew_grid ABUT<90 OPPOSITE ANGLED==2 EXCLUDE SHIELDED
 good_edge_b = INT [V2_Seal_Ring_real] >= 0.120-skew_grid <= 0.160+skew_grid ABUT<90 OPPOSITE ANGLED==2 EXCLUDE SHIELDED
 err1 = skew_edge_CHK NOT TOUCH EDGE (OR EDGE good_edge_a good_edge_b)
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
V3_Seal_Ring_all = V3 AND MARKS
V3_Seal_Ring_orth = RECTANGLE V3_Seal_Ring_all
V3_Seal_Ring_real = NOT RECTANGLE V3_Seal_Ring_all
V3_Seal_Ring_joint = LENGTH (CONVEX EDGE V3_Seal_Ring_all ANGLE1>269<271 ANGLE2>224<226) < 0.05
V3_Seal_Ring_real_v = V3_Seal_Ring_real COIN EDGE (ANGLE V3 == 90)
V3_Seal_Ring_real_h = V3_Seal_Ring_real COIN EDGE (ANGLE V3 == 0)
V3_Seal_Ring_inner = HOLES V3_Seal_Ring_real INNER
V3_Seal_Ring_outer = (HOLES V3_Seal_Ring_real) OR (V3_Seal_Ring_real TOUCH (HOLES V3_Seal_Ring_real))
V3_line_end = OR EDGE (CONVEX EDGE V3_Seal_Ring_all ANGLE1==90 ANGLE2==90 WITH LENGTH == 0.45) (CONVEX EDGE V3_Seal_Ring_all ANGLE1==90 ANGLE2==90 WITH LENGTH == 0.100)
 
SRC_4a_V3 {
@ Fixed width of Vy/1.25xVn/2xVn slot at orthogonal direction, except the edge length < 0.05um between 270-225 corners = 0.45 or 0.1um
 good_ring_v1 = INT [V3_Seal_Ring_real_v] == 0.45 ABUT<90 OPPOSITE
 good_ring_h1 = INT [V3_Seal_Ring_real_h] == 0.45 ABUT<90 OPPOSITE
 good_ring_v2 = INT [V3_Seal_Ring_real_v] == 0.10 ABUT<90 OPPOSITE
 good_ring_h2 = INT [V3_Seal_Ring_real_h] == 0.10 ABUT<90 OPPOSITE
 err1 = V3_Seal_Ring_real_v NOT TOUCH EDGE (OR EDGE (OR EDGE (OR EDGE good_ring_v1 good_ring_v2) V3_line_end) V3_Seal_Ring_joint)
 err2 = V3_Seal_Ring_real_h NOT TOUCH EDGE (OR EDGE (OR EDGE (OR EDGE good_ring_h1 good_ring_h2) V3_line_end) V3_Seal_Ring_joint)
 err1 NOT INSIDE EDGE SealR_NOT_BULK
 err2 NOT INSIDE EDGE SealR_NOT_BULK
}
 
SRC_4b_V3 {
@ Fixed width of Vy/1.25xVn/2xVn slot at 45 degree angle area = 0.5~0.504 or 0.12~0.16um
 skew_edge_CHK = ANGLE V3_Seal_Ring_real > 44 < 46
 good_edge_a = INT [V3_Seal_Ring_real] >= 0.500-skew_grid <= 0.504+skew_grid ABUT<90 OPPOSITE ANGLED==2 EXCLUDE SHIELDED
 good_edge_b = INT [V3_Seal_Ring_real] >= 0.120-skew_grid <= 0.160+skew_grid ABUT<90 OPPOSITE ANGLED==2 EXCLUDE SHIELDED
 err1 = skew_edge_CHK NOT TOUCH EDGE (OR EDGE good_edge_a good_edge_b)
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
V4_Seal_Ring_all = V4 AND MARKS
V4_Seal_Ring_orth = RECTANGLE V4_Seal_Ring_all
V4_Seal_Ring_real = NOT RECTANGLE V4_Seal_Ring_all
V4_Seal_Ring_joint = LENGTH (CONVEX EDGE V4_Seal_Ring_all ANGLE1>269<271 ANGLE2>224<226) < 0.05
V4_Seal_Ring_real_v = V4_Seal_Ring_real COIN EDGE (ANGLE V4 == 90)
V4_Seal_Ring_real_h = V4_Seal_Ring_real COIN EDGE (ANGLE V4 == 0)
V4_Seal_Ring_inner = HOLES V4_Seal_Ring_real INNER
V4_Seal_Ring_outer = (HOLES V4_Seal_Ring_real) OR (V4_Seal_Ring_real TOUCH (HOLES V4_Seal_Ring_real))
V4_line_end = OR EDGE (CONVEX EDGE V4_Seal_Ring_all ANGLE1==90 ANGLE2==90 WITH LENGTH == 0.45) (CONVEX EDGE V4_Seal_Ring_all ANGLE1==90 ANGLE2==90 WITH LENGTH == 0.100)
 
SRC_4a_V4 {
@ Fixed width of Vy/1.25xVn/2xVn slot at orthogonal direction, except the edge length < 0.05um between 270-225 corners = 0.45 or 0.1um
 good_ring_v1 = INT [V4_Seal_Ring_real_v] == 0.45 ABUT<90 OPPOSITE
 good_ring_h1 = INT [V4_Seal_Ring_real_h] == 0.45 ABUT<90 OPPOSITE
 good_ring_v2 = INT [V4_Seal_Ring_real_v] == 0.10 ABUT<90 OPPOSITE
 good_ring_h2 = INT [V4_Seal_Ring_real_h] == 0.10 ABUT<90 OPPOSITE
 err1 = V4_Seal_Ring_real_v NOT TOUCH EDGE (OR EDGE (OR EDGE (OR EDGE good_ring_v1 good_ring_v2) V4_line_end) V4_Seal_Ring_joint)
 err2 = V4_Seal_Ring_real_h NOT TOUCH EDGE (OR EDGE (OR EDGE (OR EDGE good_ring_h1 good_ring_h2) V4_line_end) V4_Seal_Ring_joint)
 err1 NOT INSIDE EDGE SealR_NOT_BULK
 err2 NOT INSIDE EDGE SealR_NOT_BULK
}
 
SRC_4b_V4 {
@ Fixed width of Vy/1.25xVn/2xVn slot at 45 degree angle area = 0.5~0.504 or 0.12~0.16um
 skew_edge_CHK = ANGLE V4_Seal_Ring_real > 44 < 46
 good_edge_a = INT [V4_Seal_Ring_real] >= 0.500-skew_grid <= 0.504+skew_grid ABUT<90 OPPOSITE ANGLED==2 EXCLUDE SHIELDED
 good_edge_b = INT [V4_Seal_Ring_real] >= 0.120-skew_grid <= 0.160+skew_grid ABUT<90 OPPOSITE ANGLED==2 EXCLUDE SHIELDED
 err1 = skew_edge_CHK NOT TOUCH EDGE (OR EDGE good_edge_a good_edge_b)
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
V5_Seal_Ring_all = V5 AND MARKS
V5_Seal_Ring_orth = RECTANGLE V5_Seal_Ring_all
V5_Seal_Ring_real = NOT RECTANGLE V5_Seal_Ring_all
V5_Seal_Ring_joint = LENGTH (CONVEX EDGE V5_Seal_Ring_all ANGLE1>269<271 ANGLE2>224<226) < 0.05
V5_Seal_Ring_real_v = V5_Seal_Ring_real COIN EDGE (ANGLE V5 == 90)
V5_Seal_Ring_real_h = V5_Seal_Ring_real COIN EDGE (ANGLE V5 == 0)
V5_Seal_Ring_inner = HOLES V5_Seal_Ring_real INNER
V5_Seal_Ring_outer = (HOLES V5_Seal_Ring_real) OR (V5_Seal_Ring_real TOUCH (HOLES V5_Seal_Ring_real))
V5_line_end = OR EDGE (CONVEX EDGE V5_Seal_Ring_all ANGLE1==90 ANGLE2==90 WITH LENGTH == 0.45) (CONVEX EDGE V5_Seal_Ring_all ANGLE1==90 ANGLE2==90 WITH LENGTH == 0.100)
 
SRC_4a_V5 {
@ Fixed width of Vy/1.25xVn/2xVn slot at orthogonal direction, except the edge length < 0.05um between 270-225 corners = 0.45 or 0.1um
 good_ring_v1 = INT [V5_Seal_Ring_real_v] == 0.45 ABUT<90 OPPOSITE
 good_ring_h1 = INT [V5_Seal_Ring_real_h] == 0.45 ABUT<90 OPPOSITE
 good_ring_v2 = INT [V5_Seal_Ring_real_v] == 0.10 ABUT<90 OPPOSITE
 good_ring_h2 = INT [V5_Seal_Ring_real_h] == 0.10 ABUT<90 OPPOSITE
 err1 = V5_Seal_Ring_real_v NOT TOUCH EDGE (OR EDGE (OR EDGE (OR EDGE good_ring_v1 good_ring_v2) V5_line_end) V5_Seal_Ring_joint)
 err2 = V5_Seal_Ring_real_h NOT TOUCH EDGE (OR EDGE (OR EDGE (OR EDGE good_ring_h1 good_ring_h2) V5_line_end) V5_Seal_Ring_joint)
 err1 NOT INSIDE EDGE SealR_NOT_BULK
 err2 NOT INSIDE EDGE SealR_NOT_BULK
}
 
SRC_4b_V5 {
@ Fixed width of Vy/1.25xVn/2xVn slot at 45 degree angle area = 0.5~0.504 or 0.12~0.16um
 skew_edge_CHK = ANGLE V5_Seal_Ring_real > 44 < 46
 good_edge_a = INT [V5_Seal_Ring_real] >= 0.500-skew_grid <= 0.504+skew_grid ABUT<90 OPPOSITE ANGLED==2 EXCLUDE SHIELDED
 good_edge_b = INT [V5_Seal_Ring_real] >= 0.120-skew_grid <= 0.160+skew_grid ABUT<90 OPPOSITE ANGLED==2 EXCLUDE SHIELDED
 err1 = skew_edge_CHK NOT TOUCH EDGE (OR EDGE good_edge_a good_edge_b)
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
V6_Seal_Ring_all = V6 AND MARKS
V6_Seal_Ring_orth = RECTANGLE V6_Seal_Ring_all
V6_Seal_Ring_real = NOT RECTANGLE V6_Seal_Ring_all
V6_Seal_Ring_joint = LENGTH (CONVEX EDGE V6_Seal_Ring_all ANGLE1>269<271 ANGLE2>224<226) < 0.05
V6_Seal_Ring_real_v = V6_Seal_Ring_real COIN EDGE (ANGLE V6 == 90)
V6_Seal_Ring_real_h = V6_Seal_Ring_real COIN EDGE (ANGLE V6 == 0)
V6_Seal_Ring_inner = HOLES V6_Seal_Ring_real INNER
V6_Seal_Ring_outer = (HOLES V6_Seal_Ring_real) OR (V6_Seal_Ring_real TOUCH (HOLES V6_Seal_Ring_real))
V6_line_end = OR EDGE (CONVEX EDGE V6_Seal_Ring_all ANGLE1==90 ANGLE2==90 WITH LENGTH == 0.45) (CONVEX EDGE V6_Seal_Ring_all ANGLE1==90 ANGLE2==90 WITH LENGTH == 0.100)
 
SRC_4a_V6 {
@ Fixed width of Vy/1.25xVn/2xVn slot at orthogonal direction, except the edge length < 0.05um between 270-225 corners = 0.45 or 0.1um
 good_ring_v1 = INT [V6_Seal_Ring_real_v] == 0.45 ABUT<90 OPPOSITE
 good_ring_h1 = INT [V6_Seal_Ring_real_h] == 0.45 ABUT<90 OPPOSITE
 good_ring_v2 = INT [V6_Seal_Ring_real_v] == 0.10 ABUT<90 OPPOSITE
 good_ring_h2 = INT [V6_Seal_Ring_real_h] == 0.10 ABUT<90 OPPOSITE
 err1 = V6_Seal_Ring_real_v NOT TOUCH EDGE (OR EDGE (OR EDGE (OR EDGE good_ring_v1 good_ring_v2) V6_line_end) V6_Seal_Ring_joint)
 err2 = V6_Seal_Ring_real_h NOT TOUCH EDGE (OR EDGE (OR EDGE (OR EDGE good_ring_h1 good_ring_h2) V6_line_end) V6_Seal_Ring_joint)
 err1 NOT INSIDE EDGE SealR_NOT_BULK
 err2 NOT INSIDE EDGE SealR_NOT_BULK
}
 
SRC_4b_V6 {
@ Fixed width of Vy/1.25xVn/2xVn slot at 45 degree angle area = 0.5~0.504 or 0.12~0.16um
 skew_edge_CHK = ANGLE V6_Seal_Ring_real > 44 < 46
 good_edge_a = INT [V6_Seal_Ring_real] >= 0.500-skew_grid <= 0.504+skew_grid ABUT<90 OPPOSITE ANGLED==2 EXCLUDE SHIELDED
 good_edge_b = INT [V6_Seal_Ring_real] >= 0.120-skew_grid <= 0.160+skew_grid ABUT<90 OPPOSITE ANGLED==2 EXCLUDE SHIELDED
 err1 = skew_edge_CHK NOT TOUCH EDGE (OR EDGE good_edge_a good_edge_b)
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
TV2_Seal_Ring_all = TV2 AND MARKS
TV2_Seal_Ring_orth = RECTANGLE TV2_Seal_Ring_all
TV2_Seal_Ring_real = NOT RECTANGLE TV2_Seal_Ring_all
TV2_Seal_Ring_joint = CONVEX EDGE TV2_Seal_Ring_all ANGLE1>269<271 ANGLE2>224<226
TV2_Seal_Ring_real_v = TV2_Seal_Ring_real COIN EDGE (ANGLE TV2 == 90)
TV2_Seal_Ring_real_h = TV2_Seal_Ring_real COIN EDGE (ANGLE TV2 == 0)
TV2_Seal_Ring_inner = HOLES TV2_Seal_Ring_real INNER
TV2_Seal_Ring_outer = (HOLES TV2_Seal_Ring_real) OR (TV2_Seal_Ring_real TOUCH (HOLES TV2_Seal_Ring_real))
TV2_line_end = CONVEX EDGE TV2_Seal_Ring_all ANGLE1==90 ANGLE2==90 WITH LENGTH == 0.414
 
SRC_5a_TV2 {
@ Fixed width of 10xTVn/14xTVn/UTV slot at orthogonal direction = 0.414um
 good_ring_v = INT [TV2_Seal_Ring_real_v] == 0.414 ABUT<90 OPPOSITE
 good_ring_h = INT [TV2_Seal_Ring_real_h] == 0.414 ABUT<90 OPPOSITE
 err1 = TV2_Seal_Ring_real_v NOT TOUCH EDGE (OR EDGE (OR EDGE good_ring_v TV2_line_end) TV2_Seal_Ring_joint)
 err2 = TV2_Seal_Ring_real_h NOT TOUCH EDGE (OR EDGE (OR EDGE good_ring_h TV2_line_end) TV2_Seal_Ring_joint)
 err1 NOT INSIDE EDGE SealR_NOT_BULK
 err2 NOT INSIDE EDGE SealR_NOT_BULK
}
 
SRC_5b_TV2 {
@ Fixed width of 10xTVn/14xTVn/UTV slot at 45 degree angle area = 0.460~0.470um
 skew_edge_CHK = ANGLE TV2_Seal_Ring_real > 44 < 46
 good_edge_a = INT [TV2_Seal_Ring_real] >= 0.46-skew_grid <= 0.47+skew_grid ABUT<90 OPPOSITE ANGLED==2 EXCLUDE SHIELDED
 err1 = skew_edge_CHK NOT TOUCH EDGE good_edge_a
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

SRC_6_V0 {
@ Square V0 and Vy size, rectangular V0 or Vy is not allowed = 0.032um
 err1 = V0_Seal_Ring_orth NOT RECTANGLE == 0.032 BY == 0.032 ORTHOGONAL ONLY
 err1 NOT INSIDE SealR_NOT_BULK
}
 
SRC_6_V1 {
@ Square V0 and Vy size, rectangular V0 or Vy is not allowed = 0.032um
 err1 = V1_Seal_Ring_orth NOT RECTANGLE == 0.032 BY == 0.032 ORTHOGONAL ONLY
 err1 NOT INSIDE SealR_NOT_BULK
}
 
SRC_6_V2 {
@ Square V0 and Vy size, rectangular V0 or Vy is not allowed = 0.032um
 err1 = V2_Seal_Ring_orth NOT RECTANGLE == 0.032 BY == 0.032 ORTHOGONAL ONLY
 err1 NOT INSIDE SealR_NOT_BULK
}
 
SRC_6_V3 {
@ Square V0 and Vy size, rectangular V0 or Vy is not allowed = 0.032um
 err1 = V3_Seal_Ring_orth NOT RECTANGLE == 0.032 BY == 0.032 ORTHOGONAL ONLY
 err1 NOT INSIDE SealR_NOT_BULK
}
 
SRC_7_V4 {
@ Square 1.25xVn size, rectangular 1.25xVn is not allowed = 0.04um
 err1 = V4_Seal_Ring_orth NOT RECTANGLE == 0.04 BY == 0.04 ORTHOGONAL ONLY
 err1 NOT INSIDE SealR_NOT_BULK
}
 
SRC_7_V5 {
@ Square 1.25xVn size, rectangular 1.25xVn is not allowed = 0.04um
 err1 = V5_Seal_Ring_orth NOT RECTANGLE == 0.04 BY == 0.04 ORTHOGONAL ONLY
 err1 NOT INSIDE SealR_NOT_BULK
}
 
SRC_7_V6 {
@ Square 1.25xVn size, rectangular 1.25xVn is not allowed = 0.04um
 err1 = V6_Seal_Ring_orth NOT RECTANGLE == 0.04 BY == 0.04 ORTHOGONAL ONLY
 err1 NOT INSIDE SealR_NOT_BULK
}
 
 

SRC_9_TV2 {
@ Square 10xTVn/UTV size = 0.324um
 err1 = TV2_Seal_Ring_orth NOT RECTANGLE == 0.324 BY == 0.324 ORTHOGONAL ONLY
 err1 NOT INSIDE SealR_NOT_BULK
}
 
SRC_11_M0 {
@ M0 slot, V0 slot, Vy slot, 1.25xVn slot, 2xVn slot and 10xTVn/14xTVn/UTV/PA slot and PPAA/M1/Mxy/1.25xMy/1.25xMn/2xMn/10xTMn (or 14xTMn)/UTM/ALPA slot must be drawn in seal ring region
 err1 = MARKS NOT INTERACT (DONUT M0)
 err1 NOT INSIDE SealR_NOT_BULK
}
 
SRC_11_V0 {
@ M0 slot, V0 slot, Vy slot, 1.25xVn slot, 2xVn slot and 10xTVn/14xTVn/UTV/PA slot and PPAA/M1/Mxy/1.25xMy/1.25xMn/2xMn/10xTMn (or 14xTMn)/UTM/ALPA slot must be drawn in seal ring region
 err1 = MARKS NOT INTERACT (DONUT V0)
 err1 NOT INSIDE SealR_NOT_BULK
}
 
SRC_11_PA {
@ M0 slot, V0 slot, Vy slot, 1.25xVn slot, 2xVn slot and 10xTVn/14xTVn/UTV/PA slot and PPAA/M1/Mxy/1.25xMy/1.25xMn/2xMn/10xTMn (or 14xTMn)/UTM/ALPA slot must be drawn in seal ring region
 err1 = MARKS NOT INTERACT (DONUT PA)
 err1 NOT INSIDE SealR_NOT_BULK
}
 
SRC_11_PPAA {
@ M0 slot, V0 slot, Vy slot, 1.25xVn slot, 2xVn slot and 10xTVn/14xTVn/UTV/PA slot and PPAA/M1/Mxy/1.25xMy/1.25xMn/2xMn/10xTMn (or 14xTMn)/UTM/ALPA slot must be drawn in seal ring region
 err1 = MARKS NOT INTERACT (DONUT PPAA)
 err1 NOT INSIDE SealR_NOT_BULK
}
 
SRC_11_ALPA {
@ M0 slot, V0 slot, Vy slot, 1.25xVn slot, 2xVn slot and 10xTVn/14xTVn/UTV/PA slot and PPAA/M1/Mxy/1.25xMy/1.25xMn/2xMn/10xTMn (or 14xTMn)/UTM/ALPA slot must be drawn in seal ring region
 err1 = MARKS NOT INTERACT (DONUT ALPA)
 err1 NOT INSIDE SealR_NOT_BULK
}
 
SRC_11_V1 {
@ M0 slot, V0 slot, Vy slot, 1.25xVn slot, 2xVn slot and 10xTVn/14xTVn/UTV/PA slot and PPAA/M1/Mxy/1.25xMy/1.25xMn/2xMn/10xTMn (or 14xTMn)/UTM/ALPA slot must be drawn in seal ring region
 err1 = MARKS NOT INTERACT (DONUT V1)
 err1 NOT INSIDE SealR_NOT_BULK
}
 
SRC_11_V2 {
@ M0 slot, V0 slot, Vy slot, 1.25xVn slot, 2xVn slot and 10xTVn/14xTVn/UTV/PA slot and PPAA/M1/Mxy/1.25xMy/1.25xMn/2xMn/10xTMn (or 14xTMn)/UTM/ALPA slot must be drawn in seal ring region
 err1 = MARKS NOT INTERACT (DONUT V2)
 err1 NOT INSIDE SealR_NOT_BULK
}
 
SRC_11_V3 {
@ M0 slot, V0 slot, Vy slot, 1.25xVn slot, 2xVn slot and 10xTVn/14xTVn/UTV/PA slot and PPAA/M1/Mxy/1.25xMy/1.25xMn/2xMn/10xTMn (or 14xTMn)/UTM/ALPA slot must be drawn in seal ring region
 err1 = MARKS NOT INTERACT (DONUT V3)
 err1 NOT INSIDE SealR_NOT_BULK
}
 
SRC_11_V4 {
@ M0 slot, V0 slot, Vy slot, 1.25xVn slot, 2xVn slot and 10xTVn/14xTVn/UTV/PA slot and PPAA/M1/Mxy/1.25xMy/1.25xMn/2xMn/10xTMn (or 14xTMn)/UTM/ALPA slot must be drawn in seal ring region
 err1 = MARKS NOT INTERACT (DONUT V4)
 err1 NOT INSIDE SealR_NOT_BULK
}
 
SRC_11_V5 {
@ M0 slot, V0 slot, Vy slot, 1.25xVn slot, 2xVn slot and 10xTVn/14xTVn/UTV/PA slot and PPAA/M1/Mxy/1.25xMy/1.25xMn/2xMn/10xTMn (or 14xTMn)/UTM/ALPA slot must be drawn in seal ring region
 err1 = MARKS NOT INTERACT (DONUT V5)
 err1 NOT INSIDE SealR_NOT_BULK
}
 
SRC_11_V6 {
@ M0 slot, V0 slot, Vy slot, 1.25xVn slot, 2xVn slot and 10xTVn/14xTVn/UTV/PA slot and PPAA/M1/Mxy/1.25xMy/1.25xMn/2xMn/10xTMn (or 14xTMn)/UTM/ALPA slot must be drawn in seal ring region
 err1 = MARKS NOT INTERACT (DONUT V6)
 err1 NOT INSIDE SealR_NOT_BULK
}
 
SRC_11_TV2 {
@ M0 slot, V0 slot, Vy slot, 1.25xVn slot, 2xVn slot and 10xTVn/14xTVn/UTV/PA slot and PPAA/M1/Mxy/1.25xMy/1.25xMn/2xMn/10xTMn (or 14xTMn)/UTM/ALPA slot must be drawn in seal ring region
 err1 = MARKS NOT INTERACT (DONUT TV2)
 err1 NOT INSIDE SealR_NOT_BULK
}
 
SRC_11_M1 {
@ M0 slot, V0 slot, Vy slot, 1.25xVn slot, 2xVn slot and 10xTVn/14xTVn/UTV/PA slot and PPAA/M1/Mxy/1.25xMy/1.25xMn/2xMn/10xTMn (or 14xTMn)/UTM/ALPA slot must be drawn in seal ring region
 err1 = MARKS NOT INTERACT (DONUT M1)
 err1 NOT INSIDE SealR_NOT_BULK
}
 
SRC_11_M2 {
@ M0 slot, V0 slot, Vy slot, 1.25xVn slot, 2xVn slot and 10xTVn/14xTVn/UTV/PA slot and PPAA/M1/Mxy/1.25xMy/1.25xMn/2xMn/10xTMn (or 14xTMn)/UTM/ALPA slot must be drawn in seal ring region
 err1 = MARKS NOT INTERACT (DONUT M2)
 err1 NOT INSIDE SealR_NOT_BULK
}
 
SRC_11_M3 {
@ M0 slot, V0 slot, Vy slot, 1.25xVn slot, 2xVn slot and 10xTVn/14xTVn/UTV/PA slot and PPAA/M1/Mxy/1.25xMy/1.25xMn/2xMn/10xTMn (or 14xTMn)/UTM/ALPA slot must be drawn in seal ring region
 err1 = MARKS NOT INTERACT (DONUT M3)
 err1 NOT INSIDE SealR_NOT_BULK
}
 
SRC_11_M4 {
@ M0 slot, V0 slot, Vy slot, 1.25xVn slot, 2xVn slot and 10xTVn/14xTVn/UTV/PA slot and PPAA/M1/Mxy/1.25xMy/1.25xMn/2xMn/10xTMn (or 14xTMn)/UTM/ALPA slot must be drawn in seal ring region
 err1 = MARKS NOT INTERACT (DONUT M4)
 err1 NOT INSIDE SealR_NOT_BULK
}
 
SRC_11_M5 {
@ M0 slot, V0 slot, Vy slot, 1.25xVn slot, 2xVn slot and 10xTVn/14xTVn/UTV/PA slot and PPAA/M1/Mxy/1.25xMy/1.25xMn/2xMn/10xTMn (or 14xTMn)/UTM/ALPA slot must be drawn in seal ring region
 err1 = MARKS NOT INTERACT (DONUT M5)
 err1 NOT INSIDE SealR_NOT_BULK
}
 
SRC_11_M6 {
@ M0 slot, V0 slot, Vy slot, 1.25xVn slot, 2xVn slot and 10xTVn/14xTVn/UTV/PA slot and PPAA/M1/Mxy/1.25xMy/1.25xMn/2xMn/10xTMn (or 14xTMn)/UTM/ALPA slot must be drawn in seal ring region
 err1 = MARKS NOT INTERACT (DONUT M6)
 err1 NOT INSIDE SealR_NOT_BULK
}
 
SRC_11_M7 {
@ M0 slot, V0 slot, Vy slot, 1.25xVn slot, 2xVn slot and 10xTVn/14xTVn/UTV/PA slot and PPAA/M1/Mxy/1.25xMy/1.25xMn/2xMn/10xTMn (or 14xTMn)/UTM/ALPA slot must be drawn in seal ring region
 err1 = MARKS NOT INTERACT (DONUT M7)
 err1 NOT INSIDE SealR_NOT_BULK
}
 
SRC_11_TM2 {
@ M0 slot, V0 slot, Vy slot, 1.25xVn slot, 2xVn slot and 10xTVn/14xTVn/UTV/PA slot and PPAA/M1/Mxy/1.25xMy/1.25xMn/2xMn/10xTMn (or 14xTMn)/UTM/ALPA slot must be drawn in seal ring region
 err1 = MARKS NOT INTERACT (DONUT TM2)
 err1 NOT INSIDE SealR_NOT_BULK
}
 
SRC_12_V0_M1 {
@ M0 and Via slot enclosure by metal >= 0.11um
 Seal_Ring_all = V0 AND MARKS
 Seal_Ring_real = NOT RECTANGLE Seal_Ring_all
 err1 = ENC Seal_Ring_real M1 < 0.11 ABUT<90 SINGULAR REGION OUTSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
 
SRC_12_V1_M1 {
@ Via slot enclosure by metal, except UTV >= 0.11um
 Seal_Ring_all = V1 AND MARKS
 Seal_Ring_real = NOT RECTANGLE Seal_Ring_all
 err1 = ENC Seal_Ring_real M1 < 0.11 ABUT<90 SINGULAR REGION OUTSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
SRC_12_V1_M2 {
@ Via slot enclosure by metal, except UTV >= 0.11um
 Seal_Ring_all = V1 AND MARKS
 Seal_Ring_real = NOT RECTANGLE Seal_Ring_all
 err1 = ENC Seal_Ring_real M2 < 0.11 ABUT<90 SINGULAR REGION OUTSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
 
SRC_12_V2_M2 {
@ Via slot enclosure by metal, except UTV >= 0.11um
 Seal_Ring_all = V2 AND MARKS
 Seal_Ring_real = NOT RECTANGLE Seal_Ring_all
 err1 = ENC Seal_Ring_real M2 < 0.11 ABUT<90 SINGULAR REGION OUTSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
SRC_12_V2_M3 {
@ Via slot enclosure by metal, except UTV >= 0.11um
 Seal_Ring_all = V2 AND MARKS
 Seal_Ring_real = NOT RECTANGLE Seal_Ring_all
 err1 = ENC Seal_Ring_real M3 < 0.11 ABUT<90 SINGULAR REGION OUTSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
 
SRC_12_V3_M3 {
@ Via slot enclosure by metal, except UTV >= 0.11um
 Seal_Ring_all = V3 AND MARKS
 Seal_Ring_real = NOT RECTANGLE Seal_Ring_all
 err1 = ENC Seal_Ring_real M3 < 0.11 ABUT<90 SINGULAR REGION OUTSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
SRC_12_V3_M4 {
@ Via slot enclosure by metal, except UTV >= 0.11um
 Seal_Ring_all = V3 AND MARKS
 Seal_Ring_real = NOT RECTANGLE Seal_Ring_all
 err1 = ENC Seal_Ring_real M4 < 0.11 ABUT<90 SINGULAR REGION OUTSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
 
SRC_12_V4_M4 {
@ Via slot enclosure by metal, except UTV >= 0.11um
 Seal_Ring_all = V4 AND MARKS
 Seal_Ring_real = NOT RECTANGLE Seal_Ring_all
 err1 = ENC Seal_Ring_real M4 < 0.11 ABUT<90 SINGULAR REGION OUTSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
SRC_12_V4_M5 {
@ Via slot enclosure by metal, except UTV >= 0.11um
 Seal_Ring_all = V4 AND MARKS
 Seal_Ring_real = NOT RECTANGLE Seal_Ring_all
 err1 = ENC Seal_Ring_real M5 < 0.11 ABUT<90 SINGULAR REGION OUTSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
 
SRC_12_V5_M5 {
@ Via slot enclosure by metal, except UTV >= 0.11um
 Seal_Ring_all = V5 AND MARKS
 Seal_Ring_real = NOT RECTANGLE Seal_Ring_all
 err1 = ENC Seal_Ring_real M5 < 0.11 ABUT<90 SINGULAR REGION OUTSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
SRC_12_V5_M6 {
@ Via slot enclosure by metal, except UTV >= 0.11um
 Seal_Ring_all = V5 AND MARKS
 Seal_Ring_real = NOT RECTANGLE Seal_Ring_all
 err1 = ENC Seal_Ring_real M6 < 0.11 ABUT<90 SINGULAR REGION OUTSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
 
SRC_12_V6_M6 {
@ Via slot enclosure by metal, except UTV >= 0.11um
 Seal_Ring_all = V6 AND MARKS
 Seal_Ring_real = NOT RECTANGLE Seal_Ring_all
 err1 = ENC Seal_Ring_real M6 < 0.11 ABUT<90 SINGULAR REGION OUTSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
SRC_12_V6_M7 {
@ Via slot enclosure by metal, except UTV >= 0.11um
 Seal_Ring_all = V6 AND MARKS
 Seal_Ring_real = NOT RECTANGLE Seal_Ring_all
 err1 = ENC Seal_Ring_real M7 < 0.11 ABUT<90 SINGULAR REGION OUTSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
 
SRC_12_TV2_M7 {
@ Via slot enclosure by metal, except UTV >= 0.11um
 Seal_Ring_all = TV2 AND MARKS
 Seal_Ring_real = NOT RECTANGLE Seal_Ring_all
 err1 = ENC Seal_Ring_real M7 < 0.11 ABUT<90 SINGULAR REGION OUTSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
SRC_12_TV2_TM2 {
@ Via slot enclosure by metal, except UTV >= 0.11um
 Seal_Ring_all = TV2 AND MARKS
 Seal_Ring_real = NOT RECTANGLE Seal_Ring_all
 err1 = ENC Seal_Ring_real TM2 < 0.11 ABUT<90 SINGULAR REGION OUTSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
 
SRC_13 {
@ Seal ring must be a close ring excluding RF device (RFDEV region)
 exclude_small_holes_V0 = VERTEX (HOLES (V0 AND MARKS) INNER) == 8
 err_V0 = ((MARKS INTERACT V0) NOT INTERACT exclude_small_holes_V0) NOT RFDEV
 exclude_small_holes_M0 = VERTEX (HOLES (M0 AND MARKS) INNER) == 8
 err_M0 = ((MARKS INTERACT M0) NOT INTERACT exclude_small_holes_M0) NOT RFDEV
 exclude_small_holes_M1 = VERTEX (HOLES (M1 AND MARKS) INNER) == 8
 err_M1 = ((MARKS INTERACT M1) NOT INTERACT exclude_small_holes_M1) NOT RFDEV
 exclude_small_holes_V1 = VERTEX (HOLES (V1 AND MARKS) INNER) == 8
 err_V1 = ((MARKS INTERACT V1) NOT INTERACT exclude_small_holes_V1) NOT RFDEV
 exclude_small_holes_M2 = VERTEX (HOLES (M2 AND MARKS) INNER) == 8
 err_M2 = ((MARKS INTERACT M2) NOT INTERACT exclude_small_holes_M2) NOT RFDEV
 exclude_small_holes_V2 = VERTEX (HOLES (V2 AND MARKS) INNER) == 8
 err_V2 = ((MARKS INTERACT V2) NOT INTERACT exclude_small_holes_V2) NOT RFDEV
 exclude_small_holes_M3 = VERTEX (HOLES (M3 AND MARKS) INNER) == 8
 err_M3 = ((MARKS INTERACT M3) NOT INTERACT exclude_small_holes_M3) NOT RFDEV
 exclude_small_holes_V3 = VERTEX (HOLES (V3 AND MARKS) INNER) == 8
 err_V3 = ((MARKS INTERACT V3) NOT INTERACT exclude_small_holes_V3) NOT RFDEV
 exclude_small_holes_M4 = VERTEX (HOLES (M4 AND MARKS) INNER) == 8
 err_M4 = ((MARKS INTERACT M4) NOT INTERACT exclude_small_holes_M4) NOT RFDEV
 exclude_small_holes_V4 = VERTEX (HOLES (V4 AND MARKS) INNER) == 8
 err_V4 = ((MARKS INTERACT V4) NOT INTERACT exclude_small_holes_V4) NOT RFDEV
 exclude_small_holes_M5 = VERTEX (HOLES (M5 AND MARKS) INNER) == 8
 err_M5 = ((MARKS INTERACT M5) NOT INTERACT exclude_small_holes_M5) NOT RFDEV
 exclude_small_holes_V5 = VERTEX (HOLES (V5 AND MARKS) INNER) == 8
 err_V5 = ((MARKS INTERACT V5) NOT INTERACT exclude_small_holes_V5) NOT RFDEV
 exclude_small_holes_M6 = VERTEX (HOLES (M6 AND MARKS) INNER) == 8
 err_M6 = ((MARKS INTERACT M6) NOT INTERACT exclude_small_holes_M6) NOT RFDEV
 exclude_small_holes_V6 = VERTEX (HOLES (V6 AND MARKS) INNER) == 8
 err_V6 = ((MARKS INTERACT V6) NOT INTERACT exclude_small_holes_V6) NOT RFDEV
 exclude_small_holes_M7 = VERTEX (HOLES (M7 AND MARKS) INNER) == 8
 err_M7 = ((MARKS INTERACT M7) NOT INTERACT exclude_small_holes_M7) NOT RFDEV
 exclude_small_holes_TV2 = VERTEX (HOLES (TV2 AND MARKS) INNER) == 8
 err_TV2 = ((MARKS INTERACT TV2) NOT INTERACT exclude_small_holes_TV2) NOT RFDEV
 exclude_small_holes_TM2 = VERTEX (HOLES (TM2 AND MARKS) INNER) == 8
 err_TM2 = ((MARKS INTERACT TM2) NOT INTERACT exclude_small_holes_TM2) NOT RFDEV
 err1 = OR err_V0 err_M0 err_M1 err_V1 err_M2 err_V2 err_M3 err_V3 err_M4 err_V4 err_M5 err_V5 err_M6 err_V6 err_M7 err_TV2 err_TM2
 err2 = MARKS NOT INTERACT (OR V0 M0 M1 V1 M2 V2 M3 V3 M4 V4 M5 V5 M6 V6 M7 TV2 TM2)
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

SRC_12b {
@ UTV slot enclosure by UTM >= 0.45um
 Seal_Ring_all = UTV AND MARKS
 Seal_Ring_real = NOT RECTANGLE Seal_Ring_all
 err1 = ENC Seal_Ring_real UTM < 0.45 ABUT<90 SINGULAR REGION OUTSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

SRC_12c {
@ PA slot enclosure by ALPA >= 0.9um
 Seal_Ring_all = PA AND MARKS
 Seal_Ring_real = NOT RECTANGLE Seal_Ring_all
 err1 = ENC Seal_Ring_real ALPA < 0.9 ABUT<90 SINGULAR REGION OUTSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

SRC_12d {
@ V0 slot must be coincidence with M0 slot
 Seal_Ring_all = V0 AND MARKS
 Seal_Ring_real = NOT RECTANGLE Seal_Ring_all
 err1 = Seal_Ring_real NOT COIN INSIDE EDGE M0
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

SRC_14 {
@ Total seal ring MARKS width in orthogonal direction = 21.6um
 CHK_MAKRS_EXTENTS = MARKS NOT (EXTENTS (HOLES MARKS INNER))
 err1 = CHK_MAKRS_EXTENTS NOT (CHK_MAKRS_EXTENTS WITH WIDTH == 21.6)
 err2 = INT MARKS < 21.6 ABUT<90 SINGULAR REGION
 err3 = (NOT ANGLE MARKS > 0 < 90) NOT TOUCH EDGE (INT [MARKS] == 21.6 OPPOSITE PARA ONLY EXCLUDE SHIELDED)
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE EDGE SealR_NOT_BULK
}
 
SRC_15_V0 {
@ Space between two square V0/Vy/1.25xVns/2xVns >= 0.438um
 err1 = EXT (RECTANGLE (V0 NOT OUTSIDE MARKS) ASPECT == 1) < 0.438 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
SRC_15_V1 {
@ Space between two square V0/Vy/1.25xVns/2xVns >= 0.438um
 err1 = EXT (RECTANGLE (V1 NOT OUTSIDE MARKS) ASPECT == 1) < 0.438 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
SRC_15_V2 {
@ Space between two square V0/Vy/1.25xVns/2xVns >= 0.438um
 err1 = EXT (RECTANGLE (V2 NOT OUTSIDE MARKS) ASPECT == 1) < 0.438 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
SRC_15_V3 {
@ Space between two square V0/Vy/1.25xVns/2xVns >= 0.438um
 err1 = EXT (RECTANGLE (V3 NOT OUTSIDE MARKS) ASPECT == 1) < 0.438 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
SRC_15_V4 {
@ Space between two square V0/Vy/1.25xVns/2xVns >= 0.438um
 err1 = EXT (RECTANGLE (V4 NOT OUTSIDE MARKS) ASPECT == 1) < 0.438 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
SRC_15_V5 {
@ Space between two square V0/Vy/1.25xVns/2xVns >= 0.438um
 err1 = EXT (RECTANGLE (V5 NOT OUTSIDE MARKS) ASPECT == 1) < 0.438 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
SRC_15_V6 {
@ Space between two square V0/Vy/1.25xVns/2xVns >= 0.438um
 err1 = EXT (RECTANGLE (V6 NOT OUTSIDE MARKS) ASPECT == 1) < 0.438 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
SRC_16_TV2 {
@ Space between two square 10xTVns/14xTVns/UTV >= 0.5um
 err1 = EXT (RECTANGLE (TV2 NOT OUTSIDE MARKS) ASPECT == 1) < 0.5 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
M1_Seal_Ring_all = M1 AND MARKS
M1_Seal_Ring_all_orth_edges = (ANGLE M1_Seal_Ring_all == 0) OR EDGE (ANGLE M1_Seal_Ring_all == 90)
M1_Seal_Ring_orth = RECTANGLE M1_Seal_Ring_all
M1_Seal_Ring_real = NOT RECTANGLE M1_Seal_Ring_all
M1_Seal_Ring_joint_a = CONVEX EDGE M1_Seal_Ring_all ANGLE1>269<271 ANGLE2>224<226
M1_Seal_Ring_joint_b = CONVEX EDGE M1_Seal_Ring_all ANGLE1>224<226 ANGLE2>224<226
M1_Seal_Ring_joint = OR EDGE M1_Seal_Ring_joint_a M1_Seal_Ring_joint_b
 
SRC_17a_M1 {
@ Width of M1/Mxy/1.25xMy/1.25xMn/2xMn/10xTMn/14xTMn/UTM/ALPA in orthogonal direction >= 0.5um <= 5um
 GOOD_BLOCK = M1_Seal_Ring_all WITH WIDTH >= 0.5 <= 5
 err1 = INT M1_Seal_Ring_all < 0.5 ABUT<90 SINGULAR REGION ANGLED==0
 err2 = (M1_Seal_Ring_all_orth_edges NOT TOUCH EDGE (INT [M1_Seal_Ring_all] <= 5 ABUT<90 OPPOSITE EXCLUDE SHIELDED)) NOT COIN EDGE GOOD_BLOCK
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE EDGE SealR_NOT_BULK
}
 
SRC_17b_M1 {
@ Width of M1/Mxy/1.25xMy/1.25xMn/2xMn/10xTMn/14xTMn/UTM/ALPA at 45 degree angle area, DRC check parallel edge for ALPA >= 0.5um <= 7.08um
 err1 = INT M1_Seal_Ring_real < 0.500-skew_grid ABUT<90 OPPOSITE REGION ANGLED==2
 err1 NOT INSIDE SealR_NOT_BULK
 // 
 skew_edge_CHK = ANGLE M1_Seal_Ring_real > 44 < 46
 good_edge = INT [M1_Seal_Ring_real] >= 0.500-skew_grid <= 7.08+skew_grid ABUT<90 OPPOSITE ANGLED==2 EXCLUDE SHIELDED
 err2 = skew_edge_CHK NOT TOUCH EDGE good_edge
 err2 NOT INSIDE EDGE SealR_NOT_BULK
}
 
M2_Seal_Ring_all = M2 AND MARKS
M2_Seal_Ring_all_orth_edges = (ANGLE M2_Seal_Ring_all == 0) OR EDGE (ANGLE M2_Seal_Ring_all == 90)
M2_Seal_Ring_orth = RECTANGLE M2_Seal_Ring_all
M2_Seal_Ring_real = NOT RECTANGLE M2_Seal_Ring_all
M2_Seal_Ring_joint_a = CONVEX EDGE M2_Seal_Ring_all ANGLE1>269<271 ANGLE2>224<226
M2_Seal_Ring_joint_b = CONVEX EDGE M2_Seal_Ring_all ANGLE1>224<226 ANGLE2>224<226
M2_Seal_Ring_joint = OR EDGE M2_Seal_Ring_joint_a M2_Seal_Ring_joint_b
 
SRC_17a_M2 {
@ Width of M1/Mxy/1.25xMy/1.25xMn/2xMn/10xTMn/14xTMn/UTM/ALPA in orthogonal direction >= 0.5um <= 5um
 GOOD_BLOCK = M2_Seal_Ring_all WITH WIDTH >= 0.5 <= 5
 err1 = INT M2_Seal_Ring_all < 0.5 ABUT<90 SINGULAR REGION ANGLED==0
 err2 = (M2_Seal_Ring_all_orth_edges NOT TOUCH EDGE (INT [M2_Seal_Ring_all] <= 5 ABUT<90 OPPOSITE EXCLUDE SHIELDED)) NOT COIN EDGE GOOD_BLOCK
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE EDGE SealR_NOT_BULK
}
 
SRC_17b_M2 {
@ Width of M1/Mxy/1.25xMy/1.25xMn/2xMn/10xTMn/14xTMn/UTM/ALPA at 45 degree angle area, DRC check parallel edge for ALPA >= 0.5um <= 7.08um
 err1 = INT M2_Seal_Ring_real < 0.500-skew_grid ABUT<90 OPPOSITE REGION ANGLED==2
 err1 NOT INSIDE SealR_NOT_BULK
 // 
 skew_edge_CHK = ANGLE M2_Seal_Ring_real > 44 < 46
 good_edge = INT [M2_Seal_Ring_real] >= 0.500-skew_grid <= 7.08+skew_grid ABUT<90 OPPOSITE ANGLED==2 EXCLUDE SHIELDED
 err2 = skew_edge_CHK NOT TOUCH EDGE good_edge
 err2 NOT INSIDE EDGE SealR_NOT_BULK
}
 
M3_Seal_Ring_all = M3 AND MARKS
M3_Seal_Ring_all_orth_edges = (ANGLE M3_Seal_Ring_all == 0) OR EDGE (ANGLE M3_Seal_Ring_all == 90)
M3_Seal_Ring_orth = RECTANGLE M3_Seal_Ring_all
M3_Seal_Ring_real = NOT RECTANGLE M3_Seal_Ring_all
M3_Seal_Ring_joint_a = CONVEX EDGE M3_Seal_Ring_all ANGLE1>269<271 ANGLE2>224<226
M3_Seal_Ring_joint_b = CONVEX EDGE M3_Seal_Ring_all ANGLE1>224<226 ANGLE2>224<226
M3_Seal_Ring_joint = OR EDGE M3_Seal_Ring_joint_a M3_Seal_Ring_joint_b
 
SRC_17a_M3 {
@ Width of M1/Mxy/1.25xMy/1.25xMn/2xMn/10xTMn/14xTMn/UTM/ALPA in orthogonal direction >= 0.5um <= 5um
 GOOD_BLOCK = M3_Seal_Ring_all WITH WIDTH >= 0.5 <= 5
 err1 = INT M3_Seal_Ring_all < 0.5 ABUT<90 SINGULAR REGION ANGLED==0
 err2 = (M3_Seal_Ring_all_orth_edges NOT TOUCH EDGE (INT [M3_Seal_Ring_all] <= 5 ABUT<90 OPPOSITE EXCLUDE SHIELDED)) NOT COIN EDGE GOOD_BLOCK
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE EDGE SealR_NOT_BULK
}
 
SRC_17b_M3 {
@ Width of M1/Mxy/1.25xMy/1.25xMn/2xMn/10xTMn/14xTMn/UTM/ALPA at 45 degree angle area, DRC check parallel edge for ALPA >= 0.5um <= 7.08um
 err1 = INT M3_Seal_Ring_real < 0.500-skew_grid ABUT<90 OPPOSITE REGION ANGLED==2
 err1 NOT INSIDE SealR_NOT_BULK
 // 
 skew_edge_CHK = ANGLE M3_Seal_Ring_real > 44 < 46
 good_edge = INT [M3_Seal_Ring_real] >= 0.500-skew_grid <= 7.08+skew_grid ABUT<90 OPPOSITE ANGLED==2 EXCLUDE SHIELDED
 err2 = skew_edge_CHK NOT TOUCH EDGE good_edge
 err2 NOT INSIDE EDGE SealR_NOT_BULK
}
 
M4_Seal_Ring_all = M4 AND MARKS
M4_Seal_Ring_all_orth_edges = (ANGLE M4_Seal_Ring_all == 0) OR EDGE (ANGLE M4_Seal_Ring_all == 90)
M4_Seal_Ring_orth = RECTANGLE M4_Seal_Ring_all
M4_Seal_Ring_real = NOT RECTANGLE M4_Seal_Ring_all
M4_Seal_Ring_joint_a = CONVEX EDGE M4_Seal_Ring_all ANGLE1>269<271 ANGLE2>224<226
M4_Seal_Ring_joint_b = CONVEX EDGE M4_Seal_Ring_all ANGLE1>224<226 ANGLE2>224<226
M4_Seal_Ring_joint = OR EDGE M4_Seal_Ring_joint_a M4_Seal_Ring_joint_b
 
SRC_17a_M4 {
@ Width of M1/Mxy/1.25xMy/1.25xMn/2xMn/10xTMn/14xTMn/UTM/ALPA in orthogonal direction >= 0.5um <= 5um
 GOOD_BLOCK = M4_Seal_Ring_all WITH WIDTH >= 0.5 <= 5
 err1 = INT M4_Seal_Ring_all < 0.5 ABUT<90 SINGULAR REGION ANGLED==0
 err2 = (M4_Seal_Ring_all_orth_edges NOT TOUCH EDGE (INT [M4_Seal_Ring_all] <= 5 ABUT<90 OPPOSITE EXCLUDE SHIELDED)) NOT COIN EDGE GOOD_BLOCK
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE EDGE SealR_NOT_BULK
}
 
SRC_17b_M4 {
@ Width of M1/Mxy/1.25xMy/1.25xMn/2xMn/10xTMn/14xTMn/UTM/ALPA at 45 degree angle area, DRC check parallel edge for ALPA >= 0.5um <= 7.08um
 err1 = INT M4_Seal_Ring_real < 0.500-skew_grid ABUT<90 OPPOSITE REGION ANGLED==2
 err1 NOT INSIDE SealR_NOT_BULK
 // 
 skew_edge_CHK = ANGLE M4_Seal_Ring_real > 44 < 46
 good_edge = INT [M4_Seal_Ring_real] >= 0.500-skew_grid <= 7.08+skew_grid ABUT<90 OPPOSITE ANGLED==2 EXCLUDE SHIELDED
 err2 = skew_edge_CHK NOT TOUCH EDGE good_edge
 err2 NOT INSIDE EDGE SealR_NOT_BULK
}
 
M5_Seal_Ring_all = M5 AND MARKS
M5_Seal_Ring_all_orth_edges = (ANGLE M5_Seal_Ring_all == 0) OR EDGE (ANGLE M5_Seal_Ring_all == 90)
M5_Seal_Ring_orth = RECTANGLE M5_Seal_Ring_all
M5_Seal_Ring_real = NOT RECTANGLE M5_Seal_Ring_all
M5_Seal_Ring_joint_a = CONVEX EDGE M5_Seal_Ring_all ANGLE1>269<271 ANGLE2>224<226
M5_Seal_Ring_joint_b = CONVEX EDGE M5_Seal_Ring_all ANGLE1>224<226 ANGLE2>224<226
M5_Seal_Ring_joint = OR EDGE M5_Seal_Ring_joint_a M5_Seal_Ring_joint_b
 
SRC_17a_M5 {
@ Width of M1/Mxy/1.25xMy/1.25xMn/2xMn/10xTMn/14xTMn/UTM/ALPA in orthogonal direction >= 0.5um <= 5um
 GOOD_BLOCK = M5_Seal_Ring_all WITH WIDTH >= 0.5 <= 5
 err1 = INT M5_Seal_Ring_all < 0.5 ABUT<90 SINGULAR REGION ANGLED==0
 err2 = (M5_Seal_Ring_all_orth_edges NOT TOUCH EDGE (INT [M5_Seal_Ring_all] <= 5 ABUT<90 OPPOSITE EXCLUDE SHIELDED)) NOT COIN EDGE GOOD_BLOCK
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE EDGE SealR_NOT_BULK
}
 
SRC_17b_M5 {
@ Width of M1/Mxy/1.25xMy/1.25xMn/2xMn/10xTMn/14xTMn/UTM/ALPA at 45 degree angle area, DRC check parallel edge for ALPA >= 0.5um <= 7.08um
 err1 = INT M5_Seal_Ring_real < 0.500-skew_grid ABUT<90 OPPOSITE REGION ANGLED==2
 err1 NOT INSIDE SealR_NOT_BULK
 // 
 skew_edge_CHK = ANGLE M5_Seal_Ring_real > 44 < 46
 good_edge = INT [M5_Seal_Ring_real] >= 0.500-skew_grid <= 7.08+skew_grid ABUT<90 OPPOSITE ANGLED==2 EXCLUDE SHIELDED
 err2 = skew_edge_CHK NOT TOUCH EDGE good_edge
 err2 NOT INSIDE EDGE SealR_NOT_BULK
}
 
M6_Seal_Ring_all = M6 AND MARKS
M6_Seal_Ring_all_orth_edges = (ANGLE M6_Seal_Ring_all == 0) OR EDGE (ANGLE M6_Seal_Ring_all == 90)
M6_Seal_Ring_orth = RECTANGLE M6_Seal_Ring_all
M6_Seal_Ring_real = NOT RECTANGLE M6_Seal_Ring_all
M6_Seal_Ring_joint_a = CONVEX EDGE M6_Seal_Ring_all ANGLE1>269<271 ANGLE2>224<226
M6_Seal_Ring_joint_b = CONVEX EDGE M6_Seal_Ring_all ANGLE1>224<226 ANGLE2>224<226
M6_Seal_Ring_joint = OR EDGE M6_Seal_Ring_joint_a M6_Seal_Ring_joint_b
 
SRC_17a_M6 {
@ Width of M1/Mxy/1.25xMy/1.25xMn/2xMn/10xTMn/14xTMn/UTM/ALPA in orthogonal direction >= 0.5um <= 5um
 GOOD_BLOCK = M6_Seal_Ring_all WITH WIDTH >= 0.5 <= 5
 err1 = INT M6_Seal_Ring_all < 0.5 ABUT<90 SINGULAR REGION ANGLED==0
 err2 = (M6_Seal_Ring_all_orth_edges NOT TOUCH EDGE (INT [M6_Seal_Ring_all] <= 5 ABUT<90 OPPOSITE EXCLUDE SHIELDED)) NOT COIN EDGE GOOD_BLOCK
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE EDGE SealR_NOT_BULK
}
 
SRC_17b_M6 {
@ Width of M1/Mxy/1.25xMy/1.25xMn/2xMn/10xTMn/14xTMn/UTM/ALPA at 45 degree angle area, DRC check parallel edge for ALPA >= 0.5um <= 7.08um
 err1 = INT M6_Seal_Ring_real < 0.500-skew_grid ABUT<90 OPPOSITE REGION ANGLED==2
 err1 NOT INSIDE SealR_NOT_BULK
 // 
 skew_edge_CHK = ANGLE M6_Seal_Ring_real > 44 < 46
 good_edge = INT [M6_Seal_Ring_real] >= 0.500-skew_grid <= 7.08+skew_grid ABUT<90 OPPOSITE ANGLED==2 EXCLUDE SHIELDED
 err2 = skew_edge_CHK NOT TOUCH EDGE good_edge
 err2 NOT INSIDE EDGE SealR_NOT_BULK
}
 
M7_Seal_Ring_all = M7 AND MARKS
M7_Seal_Ring_all_orth_edges = (ANGLE M7_Seal_Ring_all == 0) OR EDGE (ANGLE M7_Seal_Ring_all == 90)
M7_Seal_Ring_orth = RECTANGLE M7_Seal_Ring_all
M7_Seal_Ring_real = NOT RECTANGLE M7_Seal_Ring_all
M7_Seal_Ring_joint_a = CONVEX EDGE M7_Seal_Ring_all ANGLE1>269<271 ANGLE2>224<226
M7_Seal_Ring_joint_b = CONVEX EDGE M7_Seal_Ring_all ANGLE1>224<226 ANGLE2>224<226
M7_Seal_Ring_joint = OR EDGE M7_Seal_Ring_joint_a M7_Seal_Ring_joint_b
 
SRC_17a_M7 {
@ Width of M1/Mxy/1.25xMy/1.25xMn/2xMn/10xTMn/14xTMn/UTM/ALPA in orthogonal direction >= 0.5um <= 5um
 GOOD_BLOCK = M7_Seal_Ring_all WITH WIDTH >= 0.5 <= 5
 err1 = INT M7_Seal_Ring_all < 0.5 ABUT<90 SINGULAR REGION ANGLED==0
 err2 = (M7_Seal_Ring_all_orth_edges NOT TOUCH EDGE (INT [M7_Seal_Ring_all] <= 5 ABUT<90 OPPOSITE EXCLUDE SHIELDED)) NOT COIN EDGE GOOD_BLOCK
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE EDGE SealR_NOT_BULK
}
 
SRC_17b_M7 {
@ Width of M1/Mxy/1.25xMy/1.25xMn/2xMn/10xTMn/14xTMn/UTM/ALPA at 45 degree angle area, DRC check parallel edge for ALPA >= 0.5um <= 7.08um
 err1 = INT M7_Seal_Ring_real < 0.500-skew_grid ABUT<90 OPPOSITE REGION ANGLED==2
 err1 NOT INSIDE SealR_NOT_BULK
 // 
 skew_edge_CHK = ANGLE M7_Seal_Ring_real > 44 < 46
 good_edge = INT [M7_Seal_Ring_real] >= 0.500-skew_grid <= 7.08+skew_grid ABUT<90 OPPOSITE ANGLED==2 EXCLUDE SHIELDED
 err2 = skew_edge_CHK NOT TOUCH EDGE good_edge
 err2 NOT INSIDE EDGE SealR_NOT_BULK
}
 
TM2_Seal_Ring_all = TM2 AND MARKS
TM2_Seal_Ring_all_orth_edges = (ANGLE TM2_Seal_Ring_all == 0) OR EDGE (ANGLE TM2_Seal_Ring_all == 90)
TM2_Seal_Ring_orth = RECTANGLE TM2_Seal_Ring_all
TM2_Seal_Ring_real = NOT RECTANGLE TM2_Seal_Ring_all
TM2_Seal_Ring_joint_a = CONVEX EDGE TM2_Seal_Ring_all ANGLE1>269<271 ANGLE2>224<226
TM2_Seal_Ring_joint_b = CONVEX EDGE TM2_Seal_Ring_all ANGLE1>224<226 ANGLE2>224<226
TM2_Seal_Ring_joint = OR EDGE TM2_Seal_Ring_joint_a TM2_Seal_Ring_joint_b
 
SRC_17a_TM2 {
@ Width of M1/Mxy/1.25xMy/1.25xMn/2xMn/10xTMn/14xTMn/UTM/ALPA in orthogonal direction >= 0.5um <= 5um
 GOOD_BLOCK = TM2_Seal_Ring_all WITH WIDTH >= 0.5 <= 5
 err1 = INT TM2_Seal_Ring_all < 0.5 ABUT<90 SINGULAR REGION ANGLED==0
 err2 = (TM2_Seal_Ring_all_orth_edges NOT TOUCH EDGE (INT [TM2_Seal_Ring_all] <= 5 ABUT<90 OPPOSITE EXCLUDE SHIELDED)) NOT COIN EDGE GOOD_BLOCK
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE EDGE SealR_NOT_BULK
}
 
SRC_17b_TM2 {
@ Width of M1/Mxy/1.25xMy/1.25xMn/2xMn/10xTMn/14xTMn/UTM/ALPA at 45 degree angle area, DRC check parallel edge for ALPA >= 0.5um <= 7.08um
 err1 = INT TM2_Seal_Ring_real < 0.500-skew_grid ABUT<90 OPPOSITE REGION ANGLED==2
 err1 NOT INSIDE SealR_NOT_BULK
 // 
 skew_edge_CHK = ANGLE TM2_Seal_Ring_real > 44 < 46
 good_edge = INT [TM2_Seal_Ring_real] >= 0.500-skew_grid <= 7.08+skew_grid ABUT<90 OPPOSITE ANGLED==2 EXCLUDE SHIELDED
 err2 = skew_edge_CHK NOT TOUCH EDGE good_edge
 err2 NOT INSIDE EDGE SealR_NOT_BULK
}
 
ALPA_Seal_Ring_all = ALPA AND MARKS
ALPA_Seal_Ring_all_orth_edges = (ANGLE ALPA_Seal_Ring_all == 0) OR EDGE (ANGLE ALPA_Seal_Ring_all == 90)
ALPA_Seal_Ring_orth = RECTANGLE ALPA_Seal_Ring_all
ALPA_Seal_Ring_real = NOT RECTANGLE ALPA_Seal_Ring_all
ALPA_Seal_Ring_joint_a = CONVEX EDGE ALPA_Seal_Ring_all ANGLE1>269<271 ANGLE2>224<226
ALPA_Seal_Ring_joint_b = CONVEX EDGE ALPA_Seal_Ring_all ANGLE1>224<226 ANGLE2>224<226
ALPA_Seal_Ring_joint = OR EDGE ALPA_Seal_Ring_joint_a ALPA_Seal_Ring_joint_b
 
SRC_17a_ALPA {
@ Width of M1/Mxy/1.25xMy/1.25xMn/2xMn/10xTMn/14xTMn/UTM/ALPA in orthogonal direction >= 0.5um <= 5um
 GOOD_BLOCK = ALPA_Seal_Ring_all WITH WIDTH >= 0.5 <= 5
 err1 = INT ALPA_Seal_Ring_all < 0.5 ABUT<90 SINGULAR REGION ANGLED==0
 err2 = (ALPA_Seal_Ring_all_orth_edges NOT TOUCH EDGE (INT [ALPA_Seal_Ring_all] <= 5 ABUT<90 OPPOSITE EXCLUDE SHIELDED)) NOT COIN EDGE GOOD_BLOCK
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE EDGE SealR_NOT_BULK
}
 
SRC_17b_ALPA {
@ Width of M1/Mxy/1.25xMy/1.25xMn/2xMn/10xTMn/14xTMn/UTM/ALPA at 45 degree angle area, DRC check parallel edge for ALPA >= 0.5um <= 7.08um
 err1 = INT ALPA_Seal_Ring_real < 0.500-skew_grid ABUT<90 OPPOSITE REGION ANGLED==2
 err1 NOT INSIDE SealR_NOT_BULK
 // 
 skew_edge_CHK = ANGLE ALPA_Seal_Ring_real > 44 < 46
 good_edge = INT [ALPA_Seal_Ring_real] >= 0.500-skew_grid <= 7.08+skew_grid ABUT<90 OPPOSITE ANGLED==2 EXCLUDE SHIELDED
 err2 = ((DONUT ALPA) TOUCH EDGE skew_edge_CHK) NOT TOUCH EDGE good_edge
 err2 NOT INSIDE EDGE SealR_NOT_BULK
}
 
SRC_18_M1 {
@ Space between two M1/Mxys or two 1.25xMys/1.25xMns or two 2xMns >= 0.45um
 err1 = EXT M1_Seal_Ring_all < 0.45 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
SRC_18_M2 {
@ Space between two M1/Mxys or two 1.25xMys/1.25xMns or two 2xMns >= 0.45um
 err1 = EXT M2_Seal_Ring_all < 0.45 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
SRC_18_M3 {
@ Space between two M1/Mxys or two 1.25xMys/1.25xMns or two 2xMns >= 0.45um
 err1 = EXT M3_Seal_Ring_all < 0.45 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
SRC_18_M4 {
@ Space between two M1/Mxys or two 1.25xMys/1.25xMns or two 2xMns >= 0.45um
 err1 = EXT M4_Seal_Ring_all < 0.45 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
SRC_18_M5 {
@ Space between two M1/Mxys or two 1.25xMys/1.25xMns or two 2xMns >= 0.45um
 err1 = EXT M5_Seal_Ring_all < 0.45 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
SRC_18_M6 {
@ Space between two M1/Mxys or two 1.25xMys/1.25xMns or two 2xMns >= 0.45um
 err1 = EXT M6_Seal_Ring_all < 0.45 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
SRC_18_M7 {
@ Space between two M1/Mxys or two 1.25xMys/1.25xMns or two 2xMns >= 0.45um
 err1 = EXT M7_Seal_Ring_all < 0.45 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

SRC_18b_M0 {
@ Space between two M0s >= 0.9um
 err1 = EXT M0_Seal_Ring_all < 0.9 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

SRC_18c_TM1 {
@ Space between two 10xTMns or two 14xTMns >= 1.5um
@ // for 10xTMns (TM1)
 err1 = EXT (TM1i AND MARKS) < 1.5 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

SRC_18c_TM2 {
@ Space between two 10xTMns or two 14xTMns >= 1.5um
@ // for 10xTMns (TM2)
 err1 = EXT (TM2i AND MARKS) < 1.5 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

SRC_18c_TM1_40 {
@ Space between two 10xTMns or two 14xTMns >= 1.5um
@ // for 14xTMns (TM1_40)
 err1 = EXT (TM1_40 AND MARKS) < 1.5 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

SRC_18c_TM2_40 {
@ Space between two 10xTMns or two 14xTMns >= 1.5um
@ // for 14xTMns (TM2_40)
 err1 = EXT (TM2_40 AND MARKS) < 1.5 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

SRC_18d {
@ Space between two UTMs >= 1.35um
 err1 = EXT (UTM AND MARKS) < 1.35 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

SRC_19_PPAA {
@ It is not allowed PPAA/GT/M0/M1/Mxy/1.25xMy/1.25xMn/2xMn/10xTMn/14xTMn/UTM/V0/Vy/1.25xVn/2xVn/10xTVn/14xTVn/UTV/ALPA/V0/Vy/1.25xVn/2xVn/10xTVn/14xTVn/UTV/PA CUT MARKS
@ This rule also checks PPAA, GT, M0, metal, via dummy pattern (data type 1,7,8). V0/Vy/1.25xVn/2xVn/10xTVn/14xTVn/UTV definition is following main rule
 err1 = MARKS INSIDE EDGE (PPAA INTERACT MARKS)
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

SRC_19_GT {
@ It is not allowed PPAA/GT/M0/M1/Mxy/1.25xMy/1.25xMn/2xMn/10xTMn/14xTMn/UTM/V0/Vy/1.25xVn/2xVn/10xTVn/14xTVn/UTV/ALPA/V0/Vy/1.25xVn/2xVn/10xTVn/14xTVn/UTV/PA CUT MARKS
@ This rule also checks PPAA, GT, M0, metal, via dummy pattern (data type 1,7,8). V0/Vy/1.25xVn/2xVn/10xTVn/14xTVn/UTV definition is following main rule
 err1 = MARKS INSIDE EDGE (ALL_GT INTERACT MARKS)
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

SRC_19_M0 {
@ It is not allowed PPAA/GT/M0/M1/Mxy/1.25xMy/1.25xMn/2xMn/10xTMn/14xTMn/UTM/V0/Vy/1.25xVn/2xVn/10xTVn/14xTVn/UTV/ALPA/V0/Vy/1.25xVn/2xVn/10xTVn/14xTVn/UTV/PA CUT MARKS
@ This rule also checks PPAA, GT, M0, metal, via dummy pattern (data type 1,7,8). V0/Vy/1.25xVn/2xVn/10xTVn/14xTVn/UTV definition is following main rule
 err1 = MARKS INSIDE EDGE (M0 INTERACT MARKS)
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

SRC_19_V0 {
@ It is not allowed PPAA/GT/M0/M1/Mxy/1.25xMy/1.25xMn/2xMn/10xTMn/14xTMn/UTM/V0/Vy/1.25xVn/2xVn/10xTVn/14xTVn/UTV/ALPA/V0/Vy/1.25xVn/2xVn/10xTVn/14xTVn/UTV/PA CUT MARKS
@ This rule also checks PPAA, GT, M0, metal, via dummy pattern (data type 1,7,8). V0/Vy/1.25xVn/2xVn/10xTVn/14xTVn/UTV definition is following main rule
  err1 = MARKS INSIDE EDGE ((OR V0 DUM_V0) INTERACT MARKS)
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

SRC_19_ALPA {
@ It is not allowed PPAA/GT/M0/M1/Mxy/1.25xMy/1.25xMn/2xMn/10xTMn/14xTMn/UTM/V0/Vy/1.25xVn/2xVn/10xTVn/14xTVn/UTV/ALPA/V0/Vy/1.25xVn/2xVn/10xTVn/14xTVn/UTV/PA CUT MARKS
@ This rule also checks PPAA, GT, M0, metal, via dummy pattern (data type 1,7,8). V0/Vy/1.25xVn/2xVn/10xTVn/14xTVn/UTV definition is following main rule
 err1 = MARKS INSIDE EDGE (ALPA INTERACT MARKS)
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

SRC_19_PA {
@ It is not allowed PPAA/GT/M0/M1/Mxy/1.25xMy/1.25xMn/2xMn/10xTMn/14xTMn/UTM/V0/Vy/1.25xVn/2xVn/10xTVn/14xTVn/UTV/ALPA/V0/Vy/1.25xVn/2xVn/10xTVn/14xTVn/UTV/PA CUT MARKS
@ This rule also checks PPAA, GT, M0, metal, via dummy pattern (data type 1,7,8). V0/Vy/1.25xVn/2xVn/10xTVn/14xTVn/UTV definition is following main rule
 err1 = MARKS INSIDE EDGE (PA INTERACT MARKS)
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
SRC_19_M1 {
@ It is not allowed PPAA/GT/M0/M1/Mxy/1.25xMy/1.25xMn/2xMn/10xTMn/14xTMn/UTM/V0/Vy/1.25xVn/2xVn/10xTVn/14xTVn/UTV/ALPA/V0/Vy/1.25xVn/2xVn/10xTVn/14xTVn/UTV/PA CUT MARKS
@ This rule also checks PPAA, GT, M0, metal, via dummy pattern (data type 1,7,8). V0/Vy/1.25xVn/2xVn/10xTVn/14xTVn/UTV definition is following main rule
 err1 = MARKS INSIDE EDGE (M1_all INTERACT MARKS)
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
SRC_19_M2 {
@ It is not allowed PPAA/GT/M0/M1/Mxy/1.25xMy/1.25xMn/2xMn/10xTMn/14xTMn/UTM/V0/Vy/1.25xVn/2xVn/10xTVn/14xTVn/UTV/ALPA/V0/Vy/1.25xVn/2xVn/10xTVn/14xTVn/UTV/PA CUT MARKS
@ This rule also checks PPAA, GT, M0, metal, via dummy pattern (data type 1,7,8). V0/Vy/1.25xVn/2xVn/10xTVn/14xTVn/UTV definition is following main rule
 err1 = MARKS INSIDE EDGE (M2_all INTERACT MARKS)
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
SRC_19_M3 {
@ It is not allowed PPAA/GT/M0/M1/Mxy/1.25xMy/1.25xMn/2xMn/10xTMn/14xTMn/UTM/V0/Vy/1.25xVn/2xVn/10xTVn/14xTVn/UTV/ALPA/V0/Vy/1.25xVn/2xVn/10xTVn/14xTVn/UTV/PA CUT MARKS
@ This rule also checks PPAA, GT, M0, metal, via dummy pattern (data type 1,7,8). V0/Vy/1.25xVn/2xVn/10xTVn/14xTVn/UTV definition is following main rule
 err1 = MARKS INSIDE EDGE (M3_all INTERACT MARKS)
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
SRC_19_M4 {
@ It is not allowed PPAA/GT/M0/M1/Mxy/1.25xMy/1.25xMn/2xMn/10xTMn/14xTMn/UTM/V0/Vy/1.25xVn/2xVn/10xTVn/14xTVn/UTV/ALPA/V0/Vy/1.25xVn/2xVn/10xTVn/14xTVn/UTV/PA CUT MARKS
@ This rule also checks PPAA, GT, M0, metal, via dummy pattern (data type 1,7,8). V0/Vy/1.25xVn/2xVn/10xTVn/14xTVn/UTV definition is following main rule
 err1 = MARKS INSIDE EDGE (M4_all INTERACT MARKS)
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
SRC_19_M5 {
@ It is not allowed PPAA/GT/M0/M1/Mxy/1.25xMy/1.25xMn/2xMn/10xTMn/14xTMn/UTM/V0/Vy/1.25xVn/2xVn/10xTVn/14xTVn/UTV/ALPA/V0/Vy/1.25xVn/2xVn/10xTVn/14xTVn/UTV/PA CUT MARKS
@ This rule also checks PPAA, GT, M0, metal, via dummy pattern (data type 1,7,8). V0/Vy/1.25xVn/2xVn/10xTVn/14xTVn/UTV definition is following main rule
 err1 = MARKS INSIDE EDGE (M5_all INTERACT MARKS)
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
SRC_19_M6 {
@ It is not allowed PPAA/GT/M0/M1/Mxy/1.25xMy/1.25xMn/2xMn/10xTMn/14xTMn/UTM/V0/Vy/1.25xVn/2xVn/10xTVn/14xTVn/UTV/ALPA/V0/Vy/1.25xVn/2xVn/10xTVn/14xTVn/UTV/PA CUT MARKS
@ This rule also checks PPAA, GT, M0, metal, via dummy pattern (data type 1,7,8). V0/Vy/1.25xVn/2xVn/10xTVn/14xTVn/UTV definition is following main rule
 err1 = MARKS INSIDE EDGE (M6_all INTERACT MARKS)
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
SRC_19_M7 {
@ It is not allowed PPAA/GT/M0/M1/Mxy/1.25xMy/1.25xMn/2xMn/10xTMn/14xTMn/UTM/V0/Vy/1.25xVn/2xVn/10xTVn/14xTVn/UTV/ALPA/V0/Vy/1.25xVn/2xVn/10xTVn/14xTVn/UTV/PA CUT MARKS
@ This rule also checks PPAA, GT, M0, metal, via dummy pattern (data type 1,7,8). V0/Vy/1.25xVn/2xVn/10xTVn/14xTVn/UTV definition is following main rule
 err1 = MARKS INSIDE EDGE (M7_all INTERACT MARKS)
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
SRC_19_TM2 {
@ It is not allowed PPAA/GT/M0/M1/Mxy/1.25xMy/1.25xMn/2xMn/10xTMn/14xTMn/UTM/V0/Vy/1.25xVn/2xVn/10xTVn/14xTVn/UTV/ALPA/V0/Vy/1.25xVn/2xVn/10xTVn/14xTVn/UTV/PA CUT MARKS
@ This rule also checks PPAA, GT, M0, metal, via dummy pattern (data type 1,7,8). V0/Vy/1.25xVn/2xVn/10xTVn/14xTVn/UTV definition is following main rule
 err1 = MARKS INSIDE EDGE (TM2_all INTERACT MARKS)
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
SRC_19_V1 {
@ It is not allowed PPAA/GT/M0/M1/Mxy/1.25xMy/1.25xMn/2xMn/10xTMn/14xTMn/UTM/V0/Vy/1.25xVn/2xVn/10xTVn/14xTVn/UTV/ALPA/V0/Vy/1.25xVn/2xVn/10xTVn/14xTVn/UTV/PA CUT MARKS
@ This rule also checks PPAA, GT, M0, metal, via dummy pattern (data type 1,7,8). V0/Vy/1.25xVn/2xVn/10xTVn/14xTVn/UTV definition is following main rule
 err1 = MARKS INSIDE EDGE (V1_all INTERACT MARKS)
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
SRC_19_V2 {
@ It is not allowed PPAA/GT/M0/M1/Mxy/1.25xMy/1.25xMn/2xMn/10xTMn/14xTMn/UTM/V0/Vy/1.25xVn/2xVn/10xTVn/14xTVn/UTV/ALPA/V0/Vy/1.25xVn/2xVn/10xTVn/14xTVn/UTV/PA CUT MARKS
@ This rule also checks PPAA, GT, M0, metal, via dummy pattern (data type 1,7,8). V0/Vy/1.25xVn/2xVn/10xTVn/14xTVn/UTV definition is following main rule
 err1 = MARKS INSIDE EDGE (V2_all INTERACT MARKS)
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
SRC_19_V3 {
@ It is not allowed PPAA/GT/M0/M1/Mxy/1.25xMy/1.25xMn/2xMn/10xTMn/14xTMn/UTM/V0/Vy/1.25xVn/2xVn/10xTVn/14xTVn/UTV/ALPA/V0/Vy/1.25xVn/2xVn/10xTVn/14xTVn/UTV/PA CUT MARKS
@ This rule also checks PPAA, GT, M0, metal, via dummy pattern (data type 1,7,8). V0/Vy/1.25xVn/2xVn/10xTVn/14xTVn/UTV definition is following main rule
 err1 = MARKS INSIDE EDGE (V3_all INTERACT MARKS)
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
SRC_19_V4 {
@ It is not allowed PPAA/GT/M0/M1/Mxy/1.25xMy/1.25xMn/2xMn/10xTMn/14xTMn/UTM/V0/Vy/1.25xVn/2xVn/10xTVn/14xTVn/UTV/ALPA/V0/Vy/1.25xVn/2xVn/10xTVn/14xTVn/UTV/PA CUT MARKS
@ This rule also checks PPAA, GT, M0, metal, via dummy pattern (data type 1,7,8). V0/Vy/1.25xVn/2xVn/10xTVn/14xTVn/UTV definition is following main rule
 err1 = MARKS INSIDE EDGE (V4_all INTERACT MARKS)
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
SRC_19_V5 {
@ It is not allowed PPAA/GT/M0/M1/Mxy/1.25xMy/1.25xMn/2xMn/10xTMn/14xTMn/UTM/V0/Vy/1.25xVn/2xVn/10xTVn/14xTVn/UTV/ALPA/V0/Vy/1.25xVn/2xVn/10xTVn/14xTVn/UTV/PA CUT MARKS
@ This rule also checks PPAA, GT, M0, metal, via dummy pattern (data type 1,7,8). V0/Vy/1.25xVn/2xVn/10xTVn/14xTVn/UTV definition is following main rule
 err1 = MARKS INSIDE EDGE (V5_all INTERACT MARKS)
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
SRC_19_V6 {
@ It is not allowed PPAA/GT/M0/M1/Mxy/1.25xMy/1.25xMn/2xMn/10xTMn/14xTMn/UTM/V0/Vy/1.25xVn/2xVn/10xTVn/14xTVn/UTV/ALPA/V0/Vy/1.25xVn/2xVn/10xTVn/14xTVn/UTV/PA CUT MARKS
@ This rule also checks PPAA, GT, M0, metal, via dummy pattern (data type 1,7,8). V0/Vy/1.25xVn/2xVn/10xTVn/14xTVn/UTV definition is following main rule
 err1 = MARKS INSIDE EDGE (V6_all INTERACT MARKS)
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
SRC_19_TV2 {
@ It is not allowed PPAA/GT/M0/M1/Mxy/1.25xMy/1.25xMn/2xMn/10xTMn/14xTMn/UTM/V0/Vy/1.25xVn/2xVn/10xTVn/14xTVn/UTV/ALPA/V0/Vy/1.25xVn/2xVn/10xTVn/14xTVn/UTV/PA CUT MARKS
@ This rule also checks PPAA, GT, M0, metal, via dummy pattern (data type 1,7,8). V0/Vy/1.25xVn/2xVn/10xTVn/14xTVn/UTV definition is following main rule
 err1 = MARKS INSIDE EDGE (TV2_all INTERACT MARKS)
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

PA_SealRing = PA NOT OUTSIDE MARKS
ALPA_SealRing = ALPA NOT OUTSIDE MARKS
PPAA_SealRing = PPAA NOT OUTSIDE MARKS

SRC_20 {
@ Width of ((PPAA su 0.077) sd 0.077) in seal ring in orthogonal direction = 15.11um
 CHK_EXTENTS = SIZE PPAA_SealRing BY 0.077 OVERUNDER
 CHK_PPAA_inner_ring = (HOLES PPAA_SealRing INNER) TOUCH EDGE PPAA
 CHK_PPAA_outer_ring = ((DONUT PPAA_SealRing) TOUCH (HOLES PPAA_SealRing)) NOT TOUCH EDGE (HOLES PPAA_SealRing)
 err1 = INT (LENGTH CHK_EXTENTS > 1) < 15.11 ABUT<90 OPPOSITE REGION ANGLED==0
 err2 = (NOT ANGLE (OR EDGE CHK_PPAA_inner_ring CHK_PPAA_outer_ring) > 0 < 90) NOT TOUCH EDGE (INT [CHK_EXTENTS] == 15.11 OPPOSITE PARA ONLY EXCLUDE SHIELDED)
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE EDGE SealR_NOT_BULK
}

SRC_21 {
@ Metal solid ring (all metal overlap region) enclosure by MARKS (DRC only check orthoganal direction) = 2.7um
 MS_all = (M1 AND TM) AND MARKS
 MS_v_edges = ANGLE MS_all == 90
 MS_h_edges = ANGLE MS_all == 0
 MS_bd_d = EXTENTS (SIZE MARKS BY -2.7)
 err1 = MS_BD_d NOT TOUCH EDGE (OR EDGE MS_v_edges MS_h_edges)
 err1 NOT INSIDE EDGE SealR_NOT_BULK

 err2 = ENC MS_v_edges MARKS < 2.7 ABUT<90 OPPOSITE REGION
 err3 = ENC MS_h_edges MARKS < 2.7 ABUT<90 OPPOSITE REGION
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
}

SRC_22 {
@ MARKS inner edge enclosure of seal ring inner metal ring in orthogonal direction >= 5.4um
 MS_all = all_metal_layer AND MARKS
 MS_out = CONVEX EDGE (MS_all TOUCH EDGE (HOLES MS_all inner)) ANGLE1 != 270 ANGLE2 != 270 WITH LENGTH > 1  //;inner concave edge
 MS_out_v_edges = ANGLE MS_out == 90
 MS_out_h_edges = ANGLE MS_out == 0
 err1 = ENC [MS_out_v_edges] MARKS < 5.4 ABUT<90 OPPOSITE
 err2 = ENC [MS_out_h_edges] MARKS < 5.4 ABUT<90 OPPOSITE
 err1 NOT OUTSIDE EDGE MARKS
 err2 NOT OUTSIDE EDGE MARKS
}

SRC_23 {
@ PA slot width in orthogonal direction = 1.966um
 err1 = INT PA_SealRing < 1.966-GLOBAL_TOLERANCE ABUT<90 SINGULAR REGION
 err2 = (NOT ANGLE PA_SealRing > 0 < 90) NOT TOUCH EDGE (INT [PA_SealRing] == 1.966 OPPOSITE PARA ONLY EXCLUDE SHIELDED)
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE EDGE SealR_NOT_BULK
}

SRC_24 {
@ ALPA ring width in orthogonal direction = 4.0/5.0um
 CHK_ALPA_ring = DONUT ALPA_SealRing
 err1 = INT CHK_ALPA_ring < 4-0.0005 ABUT<90 SINGULAR REGION
 err2 = (NOT ANGLE CHK_ALPA_ring > 0 < 90) NOT TOUCH EDGE (OR EDGE (INT [ALPA_SealRing] == 4 OPPOSITE PARA ONLY EXCLUDE SHIELDED) (INT [ALPA_SealRing] == 5 OPPOSITE PARA ONLY EXCLUDE SHIELDED))
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE EDGE SealR_NOT_BULK
}

SRC_25 {
@ Space between ALPA ring1 and ALPA ring2 in orthogonal direction = 4.5um
 inner_ALPA_ring = (HOLES ALPA_SealRing INNER) OR (ALPA_SealRing INTERACT (HOLES ALPA_SealRing INNER))
 err1 = (NOT ANGLE inner_ALPA_ring > 0 < 90) NOT TOUCH EDGE (EXT [inner_ALPA_ring] ALPA_SealRing == 4.5 OPPOSITE EXCLUDE SHIELDED)
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

SRC_26 {
@ Maximum one MARKS is allowed in one chip
 err1 = MARKS INTERACT (BULK INTERACT MARKS > 1)
 err1 NOT INSIDE SealR_NOT_BULK
}

SRC_27 {
@ MARKS outside edge must be coincidence with CHIPB
 err1 = (MARKS NOT TOUCH EDGE (HOLES MARKS INNER)) NOT COIN INSIDE EDGE CHIPB
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

SRC_28 {
@ M0 must overlap ((PPAA su 0.01um) NOT PPAA)
 err1 = (M0 and MARKS) OUTSIDE (EXPAND EDGE PPAA OUTSIDE BY 0.01)
 err2 = NOT DONUT (((DONUT M0) and MARKS) AND (EXPAND EDGE PPAA OUTSIDE BY 0.01 EXTEND BY 0.005))
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

SRC_29 {
@ ALL_GT density in MARKS region >= 18%
 check_pattern = ALL_GT AND MARKS
 check_region = COPY MARKS
 err1 = DFM PROPERTY check_region check_pattern OVERLAP ABUT ALSO MULTI [-= !AREA(check_region) + !!AREA(check_region)*AREA(check_pattern)/AREA(check_region)] < 0.18
 err1 NOT INSIDE SealR_NOT_BULK
}
//#ENDIF

all_metal_layers_exclude_the_most_topmetal = OR M1 M2 M3 M4_40 M5_55 M6_50 M7_55

// =======================================================
// MIM: Capacitor Top Metal(MIM) Layout Rules
// =======================================================
//;MIMDMY1.[G] [NC]MIMDMY is the DRC marking layer for active MIM, which must not include dummy MIM
//;Active MIM can not do DRC checking if customers don’t draw MIMDMY layer

GROUP GMIM MIM_?

ACT_MIM = OR (MIM INTERACT MIMDMY) (MIM INTERACT TV)
DMY_MIM = MIM NOT ACT_MIM

#IFDEF RECOMMENDED_CHECK YES
MIMDMY_2_G {
@ MIMDMY must fully cover active MIM region. Active MIM is enclosed by MIMDMY = 0.2um
 CHK_ALL = EXTENTS MIM INSIDE OF LAYER MIMDMY
 SHR_DMY = SIZE (MIMDMY INTERACT MIM) BY - 0.2
 err1 = CHK_ALL NOT TOUCH EDGE SHR_DMY
 err2 = SHR_DMY NOT TOUCH INSIDE EDGE MIM
 err1 NOT INSIDE EDGE SealR_NOT_BULK
 err2 NOT INSIDE EDGE SealR_NOT_BULK
}
#ENDIF

MIM_W_1 {
@ MIM width and length as capacitor top plate >= 2um <= 50um
 err1 = INT ACT_MIM < 2 ABUT<90 SINGULAR REGION
 err2 = ACT_MIM ENCLOSE RECTANGLE 0.001 50+GLOBAL_TOLERANCE ORTHOGONAL ONLY
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

MIM_S_2 {
@ Space between two MIMs as top plate >= 1.2um
 err1 = EXT ACT_MIM < 1.2 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

MIM_EN_3 {
@ MIM enclosure of Via which connect to this MIM >= 0.24um
 err1 = ENC (TV AND MIM) MIM < 0.24 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

MIM_S_4 {
@ Space between Via which connect with bottom plate (plate-2) and MIM region >= 0.4um
 err1 = EXT (TV AND CTOP) MIM < 0.4 ABUT<90 SINGULAR REGION MEASURE ALL
 err1 NOT INSIDE SealR_NOT_BULK
}

MIM_S_5 {
@ Space between two Vias on MIM >= 0.484um
 err1 = EXT (TV AND MIM) < 0.484 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

#IFDEF RECOMMENDED_CHECK YES
MIM_S_6_R {
@ To avoid strong coupling, Mn is not recommended to put beneath MIM, minimum space for Mn to MIM >= 1um
 err1 = EXT MIM all_metal_layers_exclude_the_most_topmetal < 1 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

#IFDEF MINIMUM_DENSITY_CHECK YES
MIM_D_7_R {
@ MIM density, except LOGO region  >= 3%
@ Dummy MIM pattern is required if MIM density is less than 3%. Note that if dummy MIM is added, dummy CTOP need be added correspondingly
 chk_MIM = (OR MIM MIMDUM) NOT LOGO
 chk_ALL = CHIP_NOT_MARKS NOT LOGO
 DENSITY chk_MIM chk_ALL [!AREA(chk_MIM) + !!AREA(chk_MIM)*AREA(chk_MIM)/AREA(chk_ALL)] < 0.03 PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_MIM_D_7_R.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_MIM_D_7_R.rdb"
}
#ENDIF
#ENDIF

MIM_W_8 {
@ Dummy MIM width >= 0.78um
 err1 = INT DMY_MIM < 0.78 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

MIM_S_9 {
@ Space between dummy MIM and MIM region >= 0.8um
 err1 = EXT DMY_MIM MIM < 0.8 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

MIM_S_10 {
@ Space between dummy MIM and Plate-2 >= 0.8um
 err1 = EXT DMY_MIM CTOP < 0.8 ABUT<90 SINGULAR REGION MEASURE ALL
 err1 NOT INSIDE SealR_NOT_BULK
}

MIM_R_11 {
@ MIM must be inside CTOP
 err1 = MIM NOT CTOP
 err1 NOT INSIDE SealR_NOT_BULK
}

MIM_12_R {
@ It's not recommended to put sensitivity devices under MIM. The sensitivity devices include RF, Analog, etc
 err1 = MIM AND (OR GATE INDMY DSTR DMPNP VARMOS DIOMK1 DIOMK2 MOMDMY RESNW RESP1 RESP2 DIR EFUSE LDBK BIPOLA MTFUSE FUSEMK1 RFDEV ESDIO1 ESDIO2 FUSE M1R M2R M3R M4R M5R M6R M7R M8R M9R TM1R TM2R UTMR B1R B2R ESD1 PLRES FUSEAD RESP3T AA_NWR RFMK1)
 err1 NOT INSIDE SealR_NOT_BULK
}

MIM_13 {
@ For two top metal process, two-mask MIM structure is required to be placed between TM1 (first top metal) and TM2 (second top metal)
//; mim only supported/used in 2-10XTMn design
 err1 = COPY MIM_final
 err2 = COPY CTOP_final
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

// =======================================================
// CTOP: Capacitor Bottom Metal(CTOP) Layout Rules
// =======================================================

GROUP GCTOP CTOP_?

CTOP_W_1 {
@ CTOP width and length >= 2.8um <= 55um
 err1 = INT CTOP < 2.8 ABUT<90 SINGULAR REGION
 err2 = CTOP ENCLOSE RECTANGLE 0.001 55+GLOBAL_TOLERANCE ORTHOGONAL ONLY
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

CTOP_S_2 {
@ Space between CTOP >= 1.2um
 err1 = EXT CTOP < 1.2 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

CTOP_S_3 {
@ Space between two Vias on CTOP >= 0.484um
 err1 = EXT (TV AND CTOP) < 0.484 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

CTOP_EN_4 {
@ CTOP enclosure of MIM >= 0.4um
 err1 = ENC (MIM AND CTOP) CTOP < 0.4 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

CTOP_EN_5 {
@ CTOP enclosure of Vias which connect to this CTOP >= 0.2um
 err1 = ENC (TV AND CTOP) CTOP < 0.2 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

// =======================================================
// MOM design rules
// =======================================================

GROUP GMOM MOM_?
 
MOMMKn_all = OR MOMMK1 MOMMK2 MOMMK3 MOMMK4 MOMMK5 MOMMK6 MOMMK7
 
MOM_S_1_M1_V1 {
@ Space between (Mn AND MOMMKn AND MOMDMY) and Vn/Vn-1 (n = 1~6) outside of MOMDMY
@ Vn-1 is the via underneath 1xMn, and Vn is the via above 1xMn. Vn can be inter-via or top via (TV1 or TV2) >= 0.08um
 chk_mn = (M1 AND MOMMK1) AND MOMDMY
 err1 = EXT chk_mn (V1 OUTSIDE MOMDMY) < 0.08 NOT CONNECTED SINGULAR REGION MEASURE ALL
 err1 NOT INSIDE SealR_NOT_BULK
}
 
MOM_S_1_M2_V2 {
@ Space between (Mn AND MOMMKn AND MOMDMY) and Vn/Vn-1 (n = 1~6) outside of MOMDMY
@ Vn-1 is the via underneath 1xMn, and Vn is the via above 1xMn. Vn can be inter-via or top via (TV1 or TV2) >= 0.08um
 chk_mn = (M2 AND MOMMK2) AND MOMDMY
 err1 = EXT chk_mn (V2 OUTSIDE MOMDMY) < 0.08 NOT CONNECTED SINGULAR REGION MEASURE ALL
 err1 NOT INSIDE SealR_NOT_BULK
}
 
MOM_S_1_M3_V3 {
@ Space between (Mn AND MOMMKn AND MOMDMY) and Vn/Vn-1 (n = 1~6) outside of MOMDMY
@ Vn-1 is the via underneath 1xMn, and Vn is the via above 1xMn. Vn can be inter-via or top via (TV1 or TV2) >= 0.08um
 chk_mn = (M3 AND MOMMK3) AND MOMDMY
 err1 = EXT chk_mn (V3 OUTSIDE MOMDMY) < 0.08 NOT CONNECTED SINGULAR REGION MEASURE ALL
 err1 NOT INSIDE SealR_NOT_BULK
}
 
MOM_S_1_M4_V4 {
@ Space between (Mn AND MOMMKn AND MOMDMY) and Vn/Vn-1 (n = 1~6) outside of MOMDMY
@ Vn-1 is the via underneath 1xMn, and Vn is the via above 1xMn. Vn can be inter-via or top via (TV1 or TV2) >= 0.08um
 chk_mn = (M4 AND MOMMK4) AND MOMDMY
 err1 = EXT chk_mn (V4 OUTSIDE MOMDMY) < 0.08 NOT CONNECTED SINGULAR REGION MEASURE ALL
 err1 NOT INSIDE SealR_NOT_BULK
}
 
MOM_S_1_M5_V5 {
@ Space between (Mn AND MOMMKn AND MOMDMY) and Vn/Vn-1 (n = 1~6) outside of MOMDMY
@ Vn-1 is the via underneath 1xMn, and Vn is the via above 1xMn. Vn can be inter-via or top via (TV1 or TV2) >= 0.08um
 chk_mn = (M5 AND MOMMK5) AND MOMDMY
 err1 = EXT chk_mn (V5 OUTSIDE MOMDMY) < 0.08 NOT CONNECTED SINGULAR REGION MEASURE ALL
 err1 NOT INSIDE SealR_NOT_BULK
}
 
MOM_S_1_M6_V6 {
@ Space between (Mn AND MOMMKn AND MOMDMY) and Vn/Vn-1 (n = 1~6) outside of MOMDMY
@ Vn-1 is the via underneath 1xMn, and Vn is the via above 1xMn. Vn can be inter-via or top via (TV1 or TV2) >= 0.08um
 chk_mn = (M6 AND MOMMK6) AND MOMDMY
 err1 = EXT chk_mn (V6 OUTSIDE MOMDMY) < 0.08 NOT CONNECTED SINGULAR REGION MEASURE ALL
 err1 NOT INSIDE SealR_NOT_BULK
}
 
MOM_S_1_M7_V7 {
@ Space between (Mn AND MOMMKn AND MOMDMY) and Vn/Vn-1 (n = 1~6) outside of MOMDMY
@ Vn-1 is the via underneath 1xMn, and Vn is the via above 1xMn. Vn can be inter-via or top via (TV1 or TV2) >= 0.08um
 chk_mn = (M7 AND MOMMK7) AND MOMDMY
 err1 = EXT chk_mn (V7 OUTSIDE MOMDMY) < 0.08 NOT CONNECTED SINGULAR REGION MEASURE ALL
 err1 NOT INSIDE SealR_NOT_BULK
}
 
MOM_S_1_M2_V1 {
@ Space between (Mn AND MOMMKn AND MOMDMY) and Vn/Vn-1 (n = 1~6) outside of MOMDMY
@ Vn-1 is the via underneath 1xMn, and Vn is the via above 1xMn. Vn can be inter-via or top via (TV1 or TV2) >= 0.08um
 chk_mn = (M2 AND MOMMK2) AND MOMDMY
 err1 = EXT chk_mn (V1 OUTSIDE MOMDMY) < 0.08 NOT CONNECTED SINGULAR REGION MEASURE ALL
 err1 NOT INSIDE SealR_NOT_BULK
}
 
MOM_S_1_M3_V2 {
@ Space between (Mn AND MOMMKn AND MOMDMY) and Vn/Vn-1 (n = 1~6) outside of MOMDMY
@ Vn-1 is the via underneath 1xMn, and Vn is the via above 1xMn. Vn can be inter-via or top via (TV1 or TV2) >= 0.08um
 chk_mn = (M3 AND MOMMK3) AND MOMDMY
 err1 = EXT chk_mn (V2 OUTSIDE MOMDMY) < 0.08 NOT CONNECTED SINGULAR REGION MEASURE ALL
 err1 NOT INSIDE SealR_NOT_BULK
}
 
MOM_S_1_M4_V3 {
@ Space between (Mn AND MOMMKn AND MOMDMY) and Vn/Vn-1 (n = 1~6) outside of MOMDMY
@ Vn-1 is the via underneath 1xMn, and Vn is the via above 1xMn. Vn can be inter-via or top via (TV1 or TV2) >= 0.08um
 chk_mn = (M4 AND MOMMK4) AND MOMDMY
 err1 = EXT chk_mn (V3 OUTSIDE MOMDMY) < 0.08 NOT CONNECTED SINGULAR REGION MEASURE ALL
 err1 NOT INSIDE SealR_NOT_BULK
}
 
MOM_S_1_M5_V4 {
@ Space between (Mn AND MOMMKn AND MOMDMY) and Vn/Vn-1 (n = 1~6) outside of MOMDMY
@ Vn-1 is the via underneath 1xMn, and Vn is the via above 1xMn. Vn can be inter-via or top via (TV1 or TV2) >= 0.08um
 chk_mn = (M5 AND MOMMK5) AND MOMDMY
 err1 = EXT chk_mn (V4 OUTSIDE MOMDMY) < 0.08 NOT CONNECTED SINGULAR REGION MEASURE ALL
 err1 NOT INSIDE SealR_NOT_BULK
}
 
MOM_S_1_M6_V5 {
@ Space between (Mn AND MOMMKn AND MOMDMY) and Vn/Vn-1 (n = 1~6) outside of MOMDMY
@ Vn-1 is the via underneath 1xMn, and Vn is the via above 1xMn. Vn can be inter-via or top via (TV1 or TV2) >= 0.08um
 chk_mn = (M6 AND MOMMK6) AND MOMDMY
 err1 = EXT chk_mn (V5 OUTSIDE MOMDMY) < 0.08 NOT CONNECTED SINGULAR REGION MEASURE ALL
 err1 NOT INSIDE SealR_NOT_BULK
}
 
MOM_S_1_M7_V6 {
@ Space between (Mn AND MOMMKn AND MOMDMY) and Vn/Vn-1 (n = 1~6) outside of MOMDMY
@ Vn-1 is the via underneath 1xMn, and Vn is the via above 1xMn. Vn can be inter-via or top via (TV1 or TV2) >= 0.08um
 chk_mn = (M7 AND MOMMK7) AND MOMDMY
 err1 = EXT chk_mn (V6 OUTSIDE MOMDMY) < 0.08 NOT CONNECTED SINGULAR REGION MEASURE ALL
 err1 NOT INSIDE SealR_NOT_BULK
}
 
MOM_S_2_M1 {
@ Space between metal (M1/Mxy) and line-end in MOMMKn >= 0.09um
 err1_c = (LENGTH M1_convex_90_90_edges < 0.12) NOT OUTSIDE EDGE MOMMK1
 err1 = EXT err1_c M1 < 0.09 ABUT<90 REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
MOM_S_2_M2 {
@ Space between metal (M1/Mxy) and line-end in MOMMKn >= 0.09um
 err1_c = (LENGTH M2_convex_90_90_edges < 0.12) NOT OUTSIDE EDGE MOMMK2
 err1 = EXT err1_c M2 < 0.09 ABUT<90 REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
MOM_S_2_M3 {
@ Space between metal (M1/Mxy) and line-end in MOMMKn >= 0.09um
 err1_c = (LENGTH M3_convex_90_90_edges < 0.12) NOT OUTSIDE EDGE MOMMK3
 err1 = EXT err1_c M3 < 0.09 ABUT<90 REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
MOM_L_1_M1 {
@ PRL of MOM fingers when M1/Mxy metal finger space < 0.035um. <= 35um
 err1_TMP = EXT (M1 AND MOMDMY) < 0.035 ABUT<90 OPPOSITE REGION
 err1 = err1_TMP ENCLOSE RECTANGLE 0.001 35+GLOBAL_TOLERANCE ORTHOGONAL ONLY
 err1 NOT INSIDE SealR_NOT_BULK
}
 
MOM_L_1_M2 {
@ PRL of MOM fingers when M1/Mxy metal finger space < 0.035um. <= 35um
 err1_TMP = EXT (M2 AND MOMDMY) < 0.035 ABUT<90 OPPOSITE REGION
 err1 = err1_TMP ENCLOSE RECTANGLE 0.001 35+GLOBAL_TOLERANCE ORTHOGONAL ONLY
 err1 NOT INSIDE SealR_NOT_BULK
}
 
MOM_L_1_M3 {
@ PRL of MOM fingers when M1/Mxy metal finger space < 0.035um. <= 35um
 err1_TMP = EXT (M3 AND MOMDMY) < 0.035 ABUT<90 OPPOSITE REGION
 err1 = err1_TMP ENCLOSE RECTANGLE 0.001 35+GLOBAL_TOLERANCE ORTHOGONAL ONLY
 err1 NOT INSIDE SealR_NOT_BULK
}
 

#IFDEF Delta_Voltage_Rules_Check YES
VARIABLE Mn_CAP_d 0.12
VARIABLE M1_thickness 600/10000
VARIABLE Mxy_thickness 620/10000
VARIABLE M2_thickness 610/10000
VARIABLE M3_thickness 610/10000
VARIABLE M4_thickness 700/10000
VARIABLE M5_thickness 830/10000

 
M1_MOM_FINGER = M1 AND MOMDMY
M1_MOM_LENDS = LENGTH M1_convex_90_90_edges < 0.12
M1_MOM_SIDES = (M1 COIN EDGE M1_MOM_FINGER) NOT COIN EDGE M1_MOM_LENDS
M1_NET_vol_neg_mom = M1_NET_vol_neg AND MOMDMY
 
MOM_A_1_1_M1 {
@ Maximum sidewall area of total M1/Mxy metals in MOM without Via (0V <= delta Vmax <= 1.155V) <= 7.2E+06
 err1_a = EXT M1_MOM_SIDES [M1] < Mn_CAP_d OPPOSITE NOT CONNECTED EXCLUDE SHIELDED
 err1_b = EXT [M1_MOM_SIDES] M1 < Mn_CAP_d OPPOSITE NOT CONNECTED EXCLUDE SHIELDED
 err1_c = EXT M1_MOM_SIDES M1 < Mn_CAP_d OPPOSITE NOT CONNECTED EXCLUDE SHIELDED
 err1_a_sync = M1_SYC COIN EDGE err1_a
 err1_b_sync = M1_SYC COIN EDGE err1_b
 err1_a_NETID = DFM PROPERTY err1_a net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_b_NETID = DFM PROPERTY err1_b net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_c_sync = EXT [err1_a_sync] err1_b_sync < Mn_CAP_d OPPOSITE CONNECTED EXCLUDE SHIELDED
 err1_d_sync = EXT err1_a_sync [err1_b_sync] < Mn_CAP_d OPPOSITE CONNECTED EXCLUDE SHIELDED
 // 
 err1 = DFM PROPERTY err1_c err1_a_sync err1_b_sync err1_a_NETID err1_b_NETID err1_c_sync err1_d_sync OVERLAP ABUT ALSO MULTI 
 [SYNC = (count(err1_c_sync) > 0 && count(err1_d_sync) > 0) ? 1 : 0] 
 [NET_a = count(err1_a_NETID)] 
 [NET_b = count(err1_b_NETID)] 
 [VH_1a = property(err1_a_NETID, "max_vol", 1)] 
 [VL_1a = property(err1_a_NETID, "min_vol", 1)] 
 [VH_1b = property(err1_b_NETID, "max_vol", 1)] 
 [VL_1b = property(err1_b_NETID, "min_vol", 1)] 
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_a_NETID, "max_vol", 2) : 0] 
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_a_NETID, "min_vol", 2) : 0] 
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_b_NETID, "max_vol", 2) : 0] 
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_b_NETID, "min_vol", 2) : 0] 
 [DT_v = (property_ref(SYNC) == 1) ? ( 
 (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VH_2a)), abs(property_ref(VL_2a) - property_ref(VL_1a))) : 
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VH_2b)), abs(property_ref(VL_2b) - property_ref(VL_1b))) : 
 fmax(abs(property_ref(VH_1a) - property_ref(VH_1b)), abs(property_ref(VL_1b) - property_ref(VL_1a)))) : ( 
 (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) : 
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) : 
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a))))] <= 1.155
 M1_FINGER_SIDE = M1 AND (EXPAND EDGE ((err1_a INSIDE EDGE MOMDMY) TOUCH EDGE (DFM COPY err1 EDGE)) INSIDE BY 0.001)
 NET AREA RATIO M1 M1_FINGER_SIDE [AREA(M1_FINGER_SIDE)*M1_thickness*2/0.001] > 7.20E+06 RDB "./SMIC_14SFPLUS_DRC_logFile/MOM_A_1_1_M1.RDB" M1_FINGER_SIDE
}
 
MOM_A_1_2_M1 {
@ Maximum sidewall area of total M1/Mxy metals in MOM without Via (delta Vmax > 1.155V) <= 1.2E+07
 err1_a = EXT M1_MOM_SIDES [M1] < Mn_CAP_d OPPOSITE NOT CONNECTED EXCLUDE SHIELDED
 err1_b = EXT [M1_MOM_SIDES] M1 < Mn_CAP_d OPPOSITE NOT CONNECTED EXCLUDE SHIELDED
 err1_c = EXT M1_MOM_SIDES M1 < Mn_CAP_d OPPOSITE NOT CONNECTED EXCLUDE SHIELDED
 err1_a_sync = M1_SYC COIN EDGE err1_a
 err1_b_sync = M1_SYC COIN EDGE err1_b
 err1_a_NETID = DFM PROPERTY err1_a net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_b_NETID = DFM PROPERTY err1_b net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_c_sync = EXT [err1_a_sync] err1_b_sync < Mn_CAP_d OPPOSITE CONNECTED EXCLUDE SHIELDED
 err1_d_sync = EXT err1_a_sync [err1_b_sync] < Mn_CAP_d OPPOSITE CONNECTED EXCLUDE SHIELDED
 // 
 err1 = DFM PROPERTY err1_c err1_a_sync err1_b_sync err1_a_NETID err1_b_NETID err1_c_sync err1_d_sync OVERLAP ABUT ALSO MULTI 
 [SYNC = (count(err1_c_sync) > 0 && count(err1_d_sync) > 0) ? 1 : 0] 
 [NET_a = count(err1_a_NETID)] 
 [NET_b = count(err1_b_NETID)] 
 [VH_1a = property(err1_a_NETID, "max_vol", 1)] 
 [VL_1a = property(err1_a_NETID, "min_vol", 1)] 
 [VH_1b = property(err1_b_NETID, "max_vol", 1)] 
 [VL_1b = property(err1_b_NETID, "min_vol", 1)] 
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_a_NETID, "max_vol", 2) : 0] 
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_a_NETID, "min_vol", 2) : 0] 
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_b_NETID, "max_vol", 2) : 0] 
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_b_NETID, "min_vol", 2) : 0] 
 [DT_v = (property_ref(SYNC) == 1) ? ( 
 (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VH_2a)), abs(property_ref(VL_2a) - property_ref(VL_1a))) : 
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VH_2b)), abs(property_ref(VL_2b) - property_ref(VL_1b))) : 
 fmax(abs(property_ref(VH_1a) - property_ref(VH_1b)), abs(property_ref(VL_1b) - property_ref(VL_1a)))) : ( 
 (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) : 
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) : 
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a))))] > 1.155
 M1_FINGER_SIDE = M1 AND (EXPAND EDGE ((err1_a INSIDE EDGE MOMDMY) TOUCH EDGE (DFM COPY err1 EDGE)) INSIDE BY 0.001)
 NET AREA RATIO M1 M1_FINGER_SIDE [AREA(M1_FINGER_SIDE)*M1_thickness*2/0.001] > 1.2E+07 RDB "./SMIC_14SFPLUS_DRC_logFile/MOM_A_1_2_M1.RDB" M1_FINGER_SIDE
}
 
M2_MOM_FINGER = M2 AND MOMDMY
M2_MOM_LENDS = LENGTH M2_convex_90_90_edges < 0.12
M2_MOM_SIDES = (M2 COIN EDGE M2_MOM_FINGER) NOT COIN EDGE M2_MOM_LENDS
M2_NET_vol_neg_mom = M2_NET_vol_neg AND MOMDMY
 
MOM_A_1_1_M2 {
@ Maximum sidewall area of total M1/Mxy metals in MOM without Via (0V <= delta Vmax <= 1.155V) <= 7.2E+06
 err1_a = EXT M2_MOM_SIDES [M2] < Mn_CAP_d OPPOSITE NOT CONNECTED EXCLUDE SHIELDED
 err1_b = EXT [M2_MOM_SIDES] M2 < Mn_CAP_d OPPOSITE NOT CONNECTED EXCLUDE SHIELDED
 err1_c = EXT M2_MOM_SIDES M2 < Mn_CAP_d OPPOSITE NOT CONNECTED EXCLUDE SHIELDED
 err1_a_sync = M2_SYC COIN EDGE err1_a
 err1_b_sync = M2_SYC COIN EDGE err1_b
 err1_a_NETID = DFM PROPERTY err1_a net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_b_NETID = DFM PROPERTY err1_b net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_c_sync = EXT [err1_a_sync] err1_b_sync < Mn_CAP_d OPPOSITE CONNECTED EXCLUDE SHIELDED
 err1_d_sync = EXT err1_a_sync [err1_b_sync] < Mn_CAP_d OPPOSITE CONNECTED EXCLUDE SHIELDED
 // 
 err1 = DFM PROPERTY err1_c err1_a_sync err1_b_sync err1_a_NETID err1_b_NETID err1_c_sync err1_d_sync OVERLAP ABUT ALSO MULTI 
 [SYNC = (count(err1_c_sync) > 0 && count(err1_d_sync) > 0) ? 1 : 0] 
 [NET_a = count(err1_a_NETID)] 
 [NET_b = count(err1_b_NETID)] 
 [VH_1a = property(err1_a_NETID, "max_vol", 1)] 
 [VL_1a = property(err1_a_NETID, "min_vol", 1)] 
 [VH_1b = property(err1_b_NETID, "max_vol", 1)] 
 [VL_1b = property(err1_b_NETID, "min_vol", 1)] 
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_a_NETID, "max_vol", 2) : 0] 
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_a_NETID, "min_vol", 2) : 0] 
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_b_NETID, "max_vol", 2) : 0] 
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_b_NETID, "min_vol", 2) : 0] 
 [DT_v = (property_ref(SYNC) == 1) ? ( 
 (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VH_2a)), abs(property_ref(VL_2a) - property_ref(VL_1a))) : 
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VH_2b)), abs(property_ref(VL_2b) - property_ref(VL_1b))) : 
 fmax(abs(property_ref(VH_1a) - property_ref(VH_1b)), abs(property_ref(VL_1b) - property_ref(VL_1a)))) : ( 
 (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) : 
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) : 
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a))))] <= 1.155
 M2_FINGER_SIDE = M2 AND (EXPAND EDGE ((err1_a INSIDE EDGE MOMDMY) TOUCH EDGE (DFM COPY err1 EDGE)) INSIDE BY 0.001)
 NET AREA RATIO M2 M2_FINGER_SIDE [AREA(M2_FINGER_SIDE)*Mxy_thickness*2/0.001] > 7.2E+06 RDB "./SMIC_14SFPLUS_DRC_logFile/MOM_A_1_1_M2.RDB" M2_FINGER_SIDE
}
 
MOM_A_1_2_M2 {
@ Maximum sidewall area of total M1/Mxy metals in MOM without Via (delta Vmax > 1.155V) <= 1.2E+07
 err1_a = EXT M2_MOM_SIDES [M2] < Mn_CAP_d OPPOSITE NOT CONNECTED EXCLUDE SHIELDED
 err1_b = EXT [M2_MOM_SIDES] M2 < Mn_CAP_d OPPOSITE NOT CONNECTED EXCLUDE SHIELDED
 err1_c = EXT M2_MOM_SIDES M2 < Mn_CAP_d OPPOSITE NOT CONNECTED EXCLUDE SHIELDED
 err1_a_sync = M2_SYC COIN EDGE err1_a
 err1_b_sync = M2_SYC COIN EDGE err1_b
 err1_a_NETID = DFM PROPERTY err1_a net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_b_NETID = DFM PROPERTY err1_b net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_c_sync = EXT [err1_a_sync] err1_b_sync < Mn_CAP_d OPPOSITE CONNECTED EXCLUDE SHIELDED
 err1_d_sync = EXT err1_a_sync [err1_b_sync] < Mn_CAP_d OPPOSITE CONNECTED EXCLUDE SHIELDED
 // 
 err1 = DFM PROPERTY err1_c err1_a_sync err1_b_sync err1_a_NETID err1_b_NETID err1_c_sync err1_d_sync OVERLAP ABUT ALSO MULTI 
 [SYNC = (count(err1_c_sync) > 0 && count(err1_d_sync) > 0) ? 1 : 0] 
 [NET_a = count(err1_a_NETID)] 
 [NET_b = count(err1_b_NETID)] 
 [VH_1a = property(err1_a_NETID, "max_vol", 1)] 
 [VL_1a = property(err1_a_NETID, "min_vol", 1)] 
 [VH_1b = property(err1_b_NETID, "max_vol", 1)] 
 [VL_1b = property(err1_b_NETID, "min_vol", 1)] 
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_a_NETID, "max_vol", 2) : 0] 
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_a_NETID, "min_vol", 2) : 0] 
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_b_NETID, "max_vol", 2) : 0] 
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_b_NETID, "min_vol", 2) : 0] 
 [DT_v = (property_ref(SYNC) == 1) ? ( 
 (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VH_2a)), abs(property_ref(VL_2a) - property_ref(VL_1a))) : 
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VH_2b)), abs(property_ref(VL_2b) - property_ref(VL_1b))) : 
 fmax(abs(property_ref(VH_1a) - property_ref(VH_1b)), abs(property_ref(VL_1b) - property_ref(VL_1a)))) : ( 
 (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) : 
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) : 
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a))))] > 1.155
 M2_FINGER_SIDE = M2 AND (EXPAND EDGE ((err1_a INSIDE EDGE MOMDMY) TOUCH EDGE (DFM COPY err1 EDGE)) INSIDE BY 0.001)
 NET AREA RATIO M2 M2_FINGER_SIDE [AREA(M2_FINGER_SIDE)*Mxy_thickness*2/0.001] > 1.2E+07 RDB "./SMIC_14SFPLUS_DRC_logFile/MOM_A_1_2_M2.RDB" M2_FINGER_SIDE
}
 
M3_MOM_FINGER = M3 AND MOMDMY
M3_MOM_LENDS = LENGTH M3_convex_90_90_edges < 0.12
M3_MOM_SIDES = (M3 COIN EDGE M3_MOM_FINGER) NOT COIN EDGE M3_MOM_LENDS
M3_NET_vol_neg_mom = M3_NET_vol_neg AND MOMDMY
 
MOM_A_1_1_M3 {
@ Maximum sidewall area of total M1/Mxy metals in MOM without Via (0V <= delta Vmax <= 1.155V) <= 7.2E+06
 err1_a = EXT M3_MOM_SIDES [M3] < Mn_CAP_d OPPOSITE NOT CONNECTED EXCLUDE SHIELDED
 err1_b = EXT [M3_MOM_SIDES] M3 < Mn_CAP_d OPPOSITE NOT CONNECTED EXCLUDE SHIELDED
 err1_c = EXT M3_MOM_SIDES M3 < Mn_CAP_d OPPOSITE NOT CONNECTED EXCLUDE SHIELDED
 err1_a_sync = M3_SYC COIN EDGE err1_a
 err1_b_sync = M3_SYC COIN EDGE err1_b
 err1_a_NETID = DFM PROPERTY err1_a net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_b_NETID = DFM PROPERTY err1_b net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_c_sync = EXT [err1_a_sync] err1_b_sync < Mn_CAP_d OPPOSITE CONNECTED EXCLUDE SHIELDED
 err1_d_sync = EXT err1_a_sync [err1_b_sync] < Mn_CAP_d OPPOSITE CONNECTED EXCLUDE SHIELDED
 // 
 err1 = DFM PROPERTY err1_c err1_a_sync err1_b_sync err1_a_NETID err1_b_NETID err1_c_sync err1_d_sync OVERLAP ABUT ALSO MULTI 
 [SYNC = (count(err1_c_sync) > 0 && count(err1_d_sync) > 0) ? 1 : 0] 
 [NET_a = count(err1_a_NETID)] 
 [NET_b = count(err1_b_NETID)] 
 [VH_1a = property(err1_a_NETID, "max_vol", 1)] 
 [VL_1a = property(err1_a_NETID, "min_vol", 1)] 
 [VH_1b = property(err1_b_NETID, "max_vol", 1)] 
 [VL_1b = property(err1_b_NETID, "min_vol", 1)] 
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_a_NETID, "max_vol", 2) : 0] 
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_a_NETID, "min_vol", 2) : 0] 
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_b_NETID, "max_vol", 2) : 0] 
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_b_NETID, "min_vol", 2) : 0] 
 [DT_v = (property_ref(SYNC) == 1) ? ( 
 (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VH_2a)), abs(property_ref(VL_2a) - property_ref(VL_1a))) : 
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VH_2b)), abs(property_ref(VL_2b) - property_ref(VL_1b))) : 
 fmax(abs(property_ref(VH_1a) - property_ref(VH_1b)), abs(property_ref(VL_1b) - property_ref(VL_1a)))) : ( 
 (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) : 
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) : 
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a))))] <= 1.155
 M3_FINGER_SIDE = M3 AND (EXPAND EDGE ((err1_a INSIDE EDGE MOMDMY) TOUCH EDGE (DFM COPY err1 EDGE)) INSIDE BY 0.001)
 NET AREA RATIO M3 M3_FINGER_SIDE [AREA(M3_FINGER_SIDE)*Mxy_thickness*2/0.001] > 7.2E+06 RDB "./SMIC_14SFPLUS_DRC_logFile/MOM_A_1_1_M3.RDB" M3_FINGER_SIDE
}
 
MOM_A_1_2_M3 {
@ Maximum sidewall area of total M1/Mxy metals in MOM without Via (delta Vmax > 1.155V) <= 1.2E+07
 err1_a = EXT M3_MOM_SIDES [M3] < Mn_CAP_d OPPOSITE NOT CONNECTED EXCLUDE SHIELDED
 err1_b = EXT [M3_MOM_SIDES] M3 < Mn_CAP_d OPPOSITE NOT CONNECTED EXCLUDE SHIELDED
 err1_c = EXT M3_MOM_SIDES M3 < Mn_CAP_d OPPOSITE NOT CONNECTED EXCLUDE SHIELDED
 err1_a_sync = M3_SYC COIN EDGE err1_a
 err1_b_sync = M3_SYC COIN EDGE err1_b
 err1_a_NETID = DFM PROPERTY err1_a net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_b_NETID = DFM PROPERTY err1_b net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_c_sync = EXT [err1_a_sync] err1_b_sync < Mn_CAP_d OPPOSITE CONNECTED EXCLUDE SHIELDED
 err1_d_sync = EXT err1_a_sync [err1_b_sync] < Mn_CAP_d OPPOSITE CONNECTED EXCLUDE SHIELDED
 // 
 err1 = DFM PROPERTY err1_c err1_a_sync err1_b_sync err1_a_NETID err1_b_NETID err1_c_sync err1_d_sync OVERLAP ABUT ALSO MULTI 
 [SYNC = (count(err1_c_sync) > 0 && count(err1_d_sync) > 0) ? 1 : 0] 
 [NET_a = count(err1_a_NETID)] 
 [NET_b = count(err1_b_NETID)] 
 [VH_1a = property(err1_a_NETID, "max_vol", 1)] 
 [VL_1a = property(err1_a_NETID, "min_vol", 1)] 
 [VH_1b = property(err1_b_NETID, "max_vol", 1)] 
 [VL_1b = property(err1_b_NETID, "min_vol", 1)] 
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_a_NETID, "max_vol", 2) : 0] 
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_a_NETID, "min_vol", 2) : 0] 
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_b_NETID, "max_vol", 2) : 0] 
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_b_NETID, "min_vol", 2) : 0] 
 [DT_v = (property_ref(SYNC) == 1) ? ( 
 (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VH_2a)), abs(property_ref(VL_2a) - property_ref(VL_1a))) : 
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VH_2b)), abs(property_ref(VL_2b) - property_ref(VL_1b))) : 
 fmax(abs(property_ref(VH_1a) - property_ref(VH_1b)), abs(property_ref(VL_1b) - property_ref(VL_1a)))) : ( 
 (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) : 
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) : 
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a))))] > 1.155
 M3_FINGER_SIDE = M3 AND (EXPAND EDGE ((err1_a INSIDE EDGE MOMDMY) TOUCH EDGE (DFM COPY err1 EDGE)) INSIDE BY 0.001)
 NET AREA RATIO M3 M3_FINGER_SIDE [AREA(M3_FINGER_SIDE)*Mxy_thickness*2/0.001] > 1.2E+07 RDB "./SMIC_14SFPLUS_DRC_logFile/MOM_A_1_2_M3.RDB" M3_FINGER_SIDE
}

#ENDIF

 
MOM_R_1_V1_MOMMK1 {
@ It is not allowed:
@ 1) V1 in MOMMK1
@ 2) Vn/Vn-1 in MOMMKn (n = 2~7), Vn-1 is the via underneath 1xMn, and Vn is the via above 1xMn. Vn can be inter-via or top via (TV1 or TV2 or UTV)
 err1 = V1 AND MOMMK1
 err1 NOT INSIDE SealR_NOT_BULK
}
 
MOM_R_1_V2_MOMMK2 {
@ It is not allowed:
@ 1) V1 in MOMMK1
@ 2) Vn/Vn-1 in MOMMKn (n = 2~7), Vn-1 is the via underneath 1xMn, and Vn is the via above 1xMn. Vn can be inter-via or top via (TV1 or TV2 or UTV)
 err1 = V2 AND MOMMK2
 err1 NOT INSIDE SealR_NOT_BULK
}
 
MOM_R_1_V3_MOMMK3 {
@ It is not allowed:
@ 1) V1 in MOMMK1
@ 2) Vn/Vn-1 in MOMMKn (n = 2~7), Vn-1 is the via underneath 1xMn, and Vn is the via above 1xMn. Vn can be inter-via or top via (TV1 or TV2 or UTV)
 err1 = V3 AND MOMMK3
 err1 NOT INSIDE SealR_NOT_BULK
}
 
MOM_R_1_V4_MOMMK4 {
@ It is not allowed:
@ 1) V1 in MOMMK1
@ 2) Vn/Vn-1 in MOMMKn (n = 2~7), Vn-1 is the via underneath 1xMn, and Vn is the via above 1xMn. Vn can be inter-via or top via (TV1 or TV2 or UTV)
 err1 = V4 AND MOMMK4
 err1 NOT INSIDE SealR_NOT_BULK
}
 
MOM_R_1_V5_MOMMK5 {
@ It is not allowed:
@ 1) V1 in MOMMK1
@ 2) Vn/Vn-1 in MOMMKn (n = 2~7), Vn-1 is the via underneath 1xMn, and Vn is the via above 1xMn. Vn can be inter-via or top via (TV1 or TV2 or UTV)
 err1 = V5 AND MOMMK5
 err1 NOT INSIDE SealR_NOT_BULK
}
 
MOM_R_1_V6_MOMMK6 {
@ It is not allowed:
@ 1) V1 in MOMMK1
@ 2) Vn/Vn-1 in MOMMKn (n = 2~7), Vn-1 is the via underneath 1xMn, and Vn is the via above 1xMn. Vn can be inter-via or top via (TV1 or TV2 or UTV)
 err1 = V6 AND MOMMK6
 err1 NOT INSIDE SealR_NOT_BULK
}
 
MOM_R_1_V1_MOMMK2 {
@ It is not allowed:
@ 1) V1 in MOMMK1
@ 2) Vn/Vn-1 in MOMMKn (n = 2~7), Vn-1 is the via underneath 1xMn, and Vn is the via above 1xMn. Vn can be inter-via or top via (TV1 or TV2 or UTV)
 err1 = V1 AND MOMMK2
 err1 NOT INSIDE SealR_NOT_BULK
}
 
MOM_R_1_V2_MOMMK3 {
@ It is not allowed:
@ 1) V1 in MOMMK1
@ 2) Vn/Vn-1 in MOMMKn (n = 2~7), Vn-1 is the via underneath 1xMn, and Vn is the via above 1xMn. Vn can be inter-via or top via (TV1 or TV2 or UTV)
 err1 = V2 AND MOMMK3
 err1 NOT INSIDE SealR_NOT_BULK
}
 
MOM_R_1_V3_MOMMK4 {
@ It is not allowed:
@ 1) V1 in MOMMK1
@ 2) Vn/Vn-1 in MOMMKn (n = 2~7), Vn-1 is the via underneath 1xMn, and Vn is the via above 1xMn. Vn can be inter-via or top via (TV1 or TV2 or UTV)
 err1 = V3 AND MOMMK4
 err1 NOT INSIDE SealR_NOT_BULK
}
 
MOM_R_1_V4_MOMMK5 {
@ It is not allowed:
@ 1) V1 in MOMMK1
@ 2) Vn/Vn-1 in MOMMKn (n = 2~7), Vn-1 is the via underneath 1xMn, and Vn is the via above 1xMn. Vn can be inter-via or top via (TV1 or TV2 or UTV)
 err1 = V4 AND MOMMK5
 err1 NOT INSIDE SealR_NOT_BULK
}
 
MOM_R_1_V5_MOMMK6 {
@ It is not allowed:
@ 1) V1 in MOMMK1
@ 2) Vn/Vn-1 in MOMMKn (n = 2~7), Vn-1 is the via underneath 1xMn, and Vn is the via above 1xMn. Vn can be inter-via or top via (TV1 or TV2 or UTV)
 err1 = V5 AND MOMMK6
 err1 NOT INSIDE SealR_NOT_BULK
}
 
MOMMK1_12 = MOMMK1 INTERACT (MOMDMY WITH TEXT "momcap12")
MOMMK2_12 = MOMMK2 INTERACT (MOMDMY WITH TEXT "momcap12")
MOMMK3_12 = MOMMK3 INTERACT (MOMDMY WITH TEXT "momcap12")
MOMMK4_12 = MOMMK4 INTERACT (MOMDMY WITH TEXT "momcap12")
MOMMK5_12 = MOMMK5 INTERACT (MOMDMY WITH TEXT "momcap12")
MOMMK6_12 = MOMMK6 INTERACT (MOMDMY WITH TEXT "momcap12")
MOMMK7_12 = MOMMK7 INTERACT (MOMDMY WITH TEXT "momcap12")
MOMMK1_13 = MOMMK1 INTERACT (MOMDMY WITH TEXT "momcap13")
MOMMK2_13 = MOMMK2 INTERACT (MOMDMY WITH TEXT "momcap13")
MOMMK3_13 = MOMMK3 INTERACT (MOMDMY WITH TEXT "momcap13")
MOMMK4_13 = MOMMK4 INTERACT (MOMDMY WITH TEXT "momcap13")
MOMMK5_13 = MOMMK5 INTERACT (MOMDMY WITH TEXT "momcap13")
MOMMK6_13 = MOMMK6 INTERACT (MOMDMY WITH TEXT "momcap13")
MOMMK7_13 = MOMMK7 INTERACT (MOMDMY WITH TEXT "momcap13")
MOMMK1_14 = MOMMK1 INTERACT (MOMDMY WITH TEXT "momcap14")
MOMMK2_14 = MOMMK2 INTERACT (MOMDMY WITH TEXT "momcap14")
MOMMK3_14 = MOMMK3 INTERACT (MOMDMY WITH TEXT "momcap14")
MOMMK4_14 = MOMMK4 INTERACT (MOMDMY WITH TEXT "momcap14")
MOMMK5_14 = MOMMK5 INTERACT (MOMDMY WITH TEXT "momcap14")
MOMMK6_14 = MOMMK6 INTERACT (MOMDMY WITH TEXT "momcap14")
MOMMK7_14 = MOMMK7 INTERACT (MOMDMY WITH TEXT "momcap14")
MOMMK1_15 = MOMMK1 INTERACT (MOMDMY WITH TEXT "momcap15")
MOMMK2_15 = MOMMK2 INTERACT (MOMDMY WITH TEXT "momcap15")
MOMMK3_15 = MOMMK3 INTERACT (MOMDMY WITH TEXT "momcap15")
MOMMK4_15 = MOMMK4 INTERACT (MOMDMY WITH TEXT "momcap15")
MOMMK5_15 = MOMMK5 INTERACT (MOMDMY WITH TEXT "momcap15")
MOMMK6_15 = MOMMK6 INTERACT (MOMDMY WITH TEXT "momcap15")
MOMMK7_15 = MOMMK7 INTERACT (MOMDMY WITH TEXT "momcap15")
MOMMK1_16 = MOMMK1 INTERACT (MOMDMY WITH TEXT "momcap16")
MOMMK2_16 = MOMMK2 INTERACT (MOMDMY WITH TEXT "momcap16")
MOMMK3_16 = MOMMK3 INTERACT (MOMDMY WITH TEXT "momcap16")
MOMMK4_16 = MOMMK4 INTERACT (MOMDMY WITH TEXT "momcap16")
MOMMK5_16 = MOMMK5 INTERACT (MOMDMY WITH TEXT "momcap16")
MOMMK6_16 = MOMMK6 INTERACT (MOMDMY WITH TEXT "momcap16")
MOMMK7_16 = MOMMK7 INTERACT (MOMDMY WITH TEXT "momcap16")
MOMMK1_17 = MOMMK1 INTERACT (MOMDMY WITH TEXT "momcap17")
MOMMK2_17 = MOMMK2 INTERACT (MOMDMY WITH TEXT "momcap17")
MOMMK3_17 = MOMMK3 INTERACT (MOMDMY WITH TEXT "momcap17")
MOMMK4_17 = MOMMK4 INTERACT (MOMDMY WITH TEXT "momcap17")
MOMMK5_17 = MOMMK5 INTERACT (MOMDMY WITH TEXT "momcap17")
MOMMK6_17 = MOMMK6 INTERACT (MOMDMY WITH TEXT "momcap17")
MOMMK7_17 = MOMMK7 INTERACT (MOMDMY WITH TEXT "momcap17")
MOMMK1_18 = MOMMK1 INTERACT (MOMDMY WITH TEXT "momcap18")
MOMMK2_18 = MOMMK2 INTERACT (MOMDMY WITH TEXT "momcap18")
MOMMK3_18 = MOMMK3 INTERACT (MOMDMY WITH TEXT "momcap18")
MOMMK4_18 = MOMMK4 INTERACT (MOMDMY WITH TEXT "momcap18")
MOMMK5_18 = MOMMK5 INTERACT (MOMDMY WITH TEXT "momcap18")
MOMMK6_18 = MOMMK6 INTERACT (MOMDMY WITH TEXT "momcap18")
MOMMK7_18 = MOMMK7 INTERACT (MOMDMY WITH TEXT "momcap18")
MOMMK1_19 = MOMMK1 INTERACT (MOMDMY WITH TEXT "momcap19")
MOMMK2_19 = MOMMK2 INTERACT (MOMDMY WITH TEXT "momcap19")
MOMMK3_19 = MOMMK3 INTERACT (MOMDMY WITH TEXT "momcap19")
MOMMK4_19 = MOMMK4 INTERACT (MOMDMY WITH TEXT "momcap19")
MOMMK5_19 = MOMMK5 INTERACT (MOMDMY WITH TEXT "momcap19")
MOMMK6_19 = MOMMK6 INTERACT (MOMDMY WITH TEXT "momcap19")
MOMMK7_19 = MOMMK7 INTERACT (MOMDMY WITH TEXT "momcap19")
MOMMK1_23 = MOMMK1 INTERACT (MOMDMY WITH TEXT "momcap23")
MOMMK2_23 = MOMMK2 INTERACT (MOMDMY WITH TEXT "momcap23")
MOMMK3_23 = MOMMK3 INTERACT (MOMDMY WITH TEXT "momcap23")
MOMMK4_23 = MOMMK4 INTERACT (MOMDMY WITH TEXT "momcap23")
MOMMK5_23 = MOMMK5 INTERACT (MOMDMY WITH TEXT "momcap23")
MOMMK6_23 = MOMMK6 INTERACT (MOMDMY WITH TEXT "momcap23")
MOMMK7_23 = MOMMK7 INTERACT (MOMDMY WITH TEXT "momcap23")
MOMMK1_24 = MOMMK1 INTERACT (MOMDMY WITH TEXT "momcap24")
MOMMK2_24 = MOMMK2 INTERACT (MOMDMY WITH TEXT "momcap24")
MOMMK3_24 = MOMMK3 INTERACT (MOMDMY WITH TEXT "momcap24")
MOMMK4_24 = MOMMK4 INTERACT (MOMDMY WITH TEXT "momcap24")
MOMMK5_24 = MOMMK5 INTERACT (MOMDMY WITH TEXT "momcap24")
MOMMK6_24 = MOMMK6 INTERACT (MOMDMY WITH TEXT "momcap24")
MOMMK7_24 = MOMMK7 INTERACT (MOMDMY WITH TEXT "momcap24")
MOMMK1_25 = MOMMK1 INTERACT (MOMDMY WITH TEXT "momcap25")
MOMMK2_25 = MOMMK2 INTERACT (MOMDMY WITH TEXT "momcap25")
MOMMK3_25 = MOMMK3 INTERACT (MOMDMY WITH TEXT "momcap25")
MOMMK4_25 = MOMMK4 INTERACT (MOMDMY WITH TEXT "momcap25")
MOMMK5_25 = MOMMK5 INTERACT (MOMDMY WITH TEXT "momcap25")
MOMMK6_25 = MOMMK6 INTERACT (MOMDMY WITH TEXT "momcap25")
MOMMK7_25 = MOMMK7 INTERACT (MOMDMY WITH TEXT "momcap25")
MOMMK1_26 = MOMMK1 INTERACT (MOMDMY WITH TEXT "momcap26")
MOMMK2_26 = MOMMK2 INTERACT (MOMDMY WITH TEXT "momcap26")
MOMMK3_26 = MOMMK3 INTERACT (MOMDMY WITH TEXT "momcap26")
MOMMK4_26 = MOMMK4 INTERACT (MOMDMY WITH TEXT "momcap26")
MOMMK5_26 = MOMMK5 INTERACT (MOMDMY WITH TEXT "momcap26")
MOMMK6_26 = MOMMK6 INTERACT (MOMDMY WITH TEXT "momcap26")
MOMMK7_26 = MOMMK7 INTERACT (MOMDMY WITH TEXT "momcap26")
MOMMK1_27 = MOMMK1 INTERACT (MOMDMY WITH TEXT "momcap27")
MOMMK2_27 = MOMMK2 INTERACT (MOMDMY WITH TEXT "momcap27")
MOMMK3_27 = MOMMK3 INTERACT (MOMDMY WITH TEXT "momcap27")
MOMMK4_27 = MOMMK4 INTERACT (MOMDMY WITH TEXT "momcap27")
MOMMK5_27 = MOMMK5 INTERACT (MOMDMY WITH TEXT "momcap27")
MOMMK6_27 = MOMMK6 INTERACT (MOMDMY WITH TEXT "momcap27")
MOMMK7_27 = MOMMK7 INTERACT (MOMDMY WITH TEXT "momcap27")
MOMMK1_28 = MOMMK1 INTERACT (MOMDMY WITH TEXT "momcap28")
MOMMK2_28 = MOMMK2 INTERACT (MOMDMY WITH TEXT "momcap28")
MOMMK3_28 = MOMMK3 INTERACT (MOMDMY WITH TEXT "momcap28")
MOMMK4_28 = MOMMK4 INTERACT (MOMDMY WITH TEXT "momcap28")
MOMMK5_28 = MOMMK5 INTERACT (MOMDMY WITH TEXT "momcap28")
MOMMK6_28 = MOMMK6 INTERACT (MOMDMY WITH TEXT "momcap28")
MOMMK7_28 = MOMMK7 INTERACT (MOMDMY WITH TEXT "momcap28")
MOMMK1_29 = MOMMK1 INTERACT (MOMDMY WITH TEXT "momcap29")
MOMMK2_29 = MOMMK2 INTERACT (MOMDMY WITH TEXT "momcap29")
MOMMK3_29 = MOMMK3 INTERACT (MOMDMY WITH TEXT "momcap29")
MOMMK4_29 = MOMMK4 INTERACT (MOMDMY WITH TEXT "momcap29")
MOMMK5_29 = MOMMK5 INTERACT (MOMDMY WITH TEXT "momcap29")
MOMMK6_29 = MOMMK6 INTERACT (MOMDMY WITH TEXT "momcap29")
MOMMK7_29 = MOMMK7 INTERACT (MOMDMY WITH TEXT "momcap29")
MOMMK1_34 = MOMMK1 INTERACT (MOMDMY WITH TEXT "momcap34")
MOMMK2_34 = MOMMK2 INTERACT (MOMDMY WITH TEXT "momcap34")
MOMMK3_34 = MOMMK3 INTERACT (MOMDMY WITH TEXT "momcap34")
MOMMK4_34 = MOMMK4 INTERACT (MOMDMY WITH TEXT "momcap34")
MOMMK5_34 = MOMMK5 INTERACT (MOMDMY WITH TEXT "momcap34")
MOMMK6_34 = MOMMK6 INTERACT (MOMDMY WITH TEXT "momcap34")
MOMMK7_34 = MOMMK7 INTERACT (MOMDMY WITH TEXT "momcap34")
MOMMK1_35 = MOMMK1 INTERACT (MOMDMY WITH TEXT "momcap35")
MOMMK2_35 = MOMMK2 INTERACT (MOMDMY WITH TEXT "momcap35")
MOMMK3_35 = MOMMK3 INTERACT (MOMDMY WITH TEXT "momcap35")
MOMMK4_35 = MOMMK4 INTERACT (MOMDMY WITH TEXT "momcap35")
MOMMK5_35 = MOMMK5 INTERACT (MOMDMY WITH TEXT "momcap35")
MOMMK6_35 = MOMMK6 INTERACT (MOMDMY WITH TEXT "momcap35")
MOMMK7_35 = MOMMK7 INTERACT (MOMDMY WITH TEXT "momcap35")
MOMMK1_36 = MOMMK1 INTERACT (MOMDMY WITH TEXT "momcap36")
MOMMK2_36 = MOMMK2 INTERACT (MOMDMY WITH TEXT "momcap36")
MOMMK3_36 = MOMMK3 INTERACT (MOMDMY WITH TEXT "momcap36")
MOMMK4_36 = MOMMK4 INTERACT (MOMDMY WITH TEXT "momcap36")
MOMMK5_36 = MOMMK5 INTERACT (MOMDMY WITH TEXT "momcap36")
MOMMK6_36 = MOMMK6 INTERACT (MOMDMY WITH TEXT "momcap36")
MOMMK7_36 = MOMMK7 INTERACT (MOMDMY WITH TEXT "momcap36")
MOMMK1_37 = MOMMK1 INTERACT (MOMDMY WITH TEXT "momcap37")
MOMMK2_37 = MOMMK2 INTERACT (MOMDMY WITH TEXT "momcap37")
MOMMK3_37 = MOMMK3 INTERACT (MOMDMY WITH TEXT "momcap37")
MOMMK4_37 = MOMMK4 INTERACT (MOMDMY WITH TEXT "momcap37")
MOMMK5_37 = MOMMK5 INTERACT (MOMDMY WITH TEXT "momcap37")
MOMMK6_37 = MOMMK6 INTERACT (MOMDMY WITH TEXT "momcap37")
MOMMK7_37 = MOMMK7 INTERACT (MOMDMY WITH TEXT "momcap37")
MOMMK1_38 = MOMMK1 INTERACT (MOMDMY WITH TEXT "momcap38")
MOMMK2_38 = MOMMK2 INTERACT (MOMDMY WITH TEXT "momcap38")
MOMMK3_38 = MOMMK3 INTERACT (MOMDMY WITH TEXT "momcap38")
MOMMK4_38 = MOMMK4 INTERACT (MOMDMY WITH TEXT "momcap38")
MOMMK5_38 = MOMMK5 INTERACT (MOMDMY WITH TEXT "momcap38")
MOMMK6_38 = MOMMK6 INTERACT (MOMDMY WITH TEXT "momcap38")
MOMMK7_38 = MOMMK7 INTERACT (MOMDMY WITH TEXT "momcap38")
MOMMK1_39 = MOMMK1 INTERACT (MOMDMY WITH TEXT "momcap39")
MOMMK2_39 = MOMMK2 INTERACT (MOMDMY WITH TEXT "momcap39")
MOMMK3_39 = MOMMK3 INTERACT (MOMDMY WITH TEXT "momcap39")
MOMMK4_39 = MOMMK4 INTERACT (MOMDMY WITH TEXT "momcap39")
MOMMK5_39 = MOMMK5 INTERACT (MOMDMY WITH TEXT "momcap39")
MOMMK6_39 = MOMMK6 INTERACT (MOMDMY WITH TEXT "momcap39")
MOMMK7_39 = MOMMK7 INTERACT (MOMDMY WITH TEXT "momcap39")
MOMMK1_45 = MOMMK1 INTERACT (MOMDMY WITH TEXT "momcap45")
MOMMK2_45 = MOMMK2 INTERACT (MOMDMY WITH TEXT "momcap45")
MOMMK3_45 = MOMMK3 INTERACT (MOMDMY WITH TEXT "momcap45")
MOMMK4_45 = MOMMK4 INTERACT (MOMDMY WITH TEXT "momcap45")
MOMMK5_45 = MOMMK5 INTERACT (MOMDMY WITH TEXT "momcap45")
MOMMK6_45 = MOMMK6 INTERACT (MOMDMY WITH TEXT "momcap45")
MOMMK7_45 = MOMMK7 INTERACT (MOMDMY WITH TEXT "momcap45")
MOMMK1_46 = MOMMK1 INTERACT (MOMDMY WITH TEXT "momcap46")
MOMMK2_46 = MOMMK2 INTERACT (MOMDMY WITH TEXT "momcap46")
MOMMK3_46 = MOMMK3 INTERACT (MOMDMY WITH TEXT "momcap46")
MOMMK4_46 = MOMMK4 INTERACT (MOMDMY WITH TEXT "momcap46")
MOMMK5_46 = MOMMK5 INTERACT (MOMDMY WITH TEXT "momcap46")
MOMMK6_46 = MOMMK6 INTERACT (MOMDMY WITH TEXT "momcap46")
MOMMK7_46 = MOMMK7 INTERACT (MOMDMY WITH TEXT "momcap46")
MOMMK1_47 = MOMMK1 INTERACT (MOMDMY WITH TEXT "momcap47")
MOMMK2_47 = MOMMK2 INTERACT (MOMDMY WITH TEXT "momcap47")
MOMMK3_47 = MOMMK3 INTERACT (MOMDMY WITH TEXT "momcap47")
MOMMK4_47 = MOMMK4 INTERACT (MOMDMY WITH TEXT "momcap47")
MOMMK5_47 = MOMMK5 INTERACT (MOMDMY WITH TEXT "momcap47")
MOMMK6_47 = MOMMK6 INTERACT (MOMDMY WITH TEXT "momcap47")
MOMMK7_47 = MOMMK7 INTERACT (MOMDMY WITH TEXT "momcap47")
MOMMK1_48 = MOMMK1 INTERACT (MOMDMY WITH TEXT "momcap48")
MOMMK2_48 = MOMMK2 INTERACT (MOMDMY WITH TEXT "momcap48")
MOMMK3_48 = MOMMK3 INTERACT (MOMDMY WITH TEXT "momcap48")
MOMMK4_48 = MOMMK4 INTERACT (MOMDMY WITH TEXT "momcap48")
MOMMK5_48 = MOMMK5 INTERACT (MOMDMY WITH TEXT "momcap48")
MOMMK6_48 = MOMMK6 INTERACT (MOMDMY WITH TEXT "momcap48")
MOMMK7_48 = MOMMK7 INTERACT (MOMDMY WITH TEXT "momcap48")
MOMMK1_49 = MOMMK1 INTERACT (MOMDMY WITH TEXT "momcap49")
MOMMK2_49 = MOMMK2 INTERACT (MOMDMY WITH TEXT "momcap49")
MOMMK3_49 = MOMMK3 INTERACT (MOMDMY WITH TEXT "momcap49")
MOMMK4_49 = MOMMK4 INTERACT (MOMDMY WITH TEXT "momcap49")
MOMMK5_49 = MOMMK5 INTERACT (MOMDMY WITH TEXT "momcap49")
MOMMK6_49 = MOMMK6 INTERACT (MOMDMY WITH TEXT "momcap49")
MOMMK7_49 = MOMMK7 INTERACT (MOMDMY WITH TEXT "momcap49")
MOMMK1_56 = MOMMK1 INTERACT (MOMDMY WITH TEXT "momcap56")
MOMMK2_56 = MOMMK2 INTERACT (MOMDMY WITH TEXT "momcap56")
MOMMK3_56 = MOMMK3 INTERACT (MOMDMY WITH TEXT "momcap56")
MOMMK4_56 = MOMMK4 INTERACT (MOMDMY WITH TEXT "momcap56")
MOMMK5_56 = MOMMK5 INTERACT (MOMDMY WITH TEXT "momcap56")
MOMMK6_56 = MOMMK6 INTERACT (MOMDMY WITH TEXT "momcap56")
MOMMK7_56 = MOMMK7 INTERACT (MOMDMY WITH TEXT "momcap56")
MOMMK1_57 = MOMMK1 INTERACT (MOMDMY WITH TEXT "momcap57")
MOMMK2_57 = MOMMK2 INTERACT (MOMDMY WITH TEXT "momcap57")
MOMMK3_57 = MOMMK3 INTERACT (MOMDMY WITH TEXT "momcap57")
MOMMK4_57 = MOMMK4 INTERACT (MOMDMY WITH TEXT "momcap57")
MOMMK5_57 = MOMMK5 INTERACT (MOMDMY WITH TEXT "momcap57")
MOMMK6_57 = MOMMK6 INTERACT (MOMDMY WITH TEXT "momcap57")
MOMMK7_57 = MOMMK7 INTERACT (MOMDMY WITH TEXT "momcap57")
MOMMK1_58 = MOMMK1 INTERACT (MOMDMY WITH TEXT "momcap58")
MOMMK2_58 = MOMMK2 INTERACT (MOMDMY WITH TEXT "momcap58")
MOMMK3_58 = MOMMK3 INTERACT (MOMDMY WITH TEXT "momcap58")
MOMMK4_58 = MOMMK4 INTERACT (MOMDMY WITH TEXT "momcap58")
MOMMK5_58 = MOMMK5 INTERACT (MOMDMY WITH TEXT "momcap58")
MOMMK6_58 = MOMMK6 INTERACT (MOMDMY WITH TEXT "momcap58")
MOMMK7_58 = MOMMK7 INTERACT (MOMDMY WITH TEXT "momcap58")
MOMMK1_59 = MOMMK1 INTERACT (MOMDMY WITH TEXT "momcap59")
MOMMK2_59 = MOMMK2 INTERACT (MOMDMY WITH TEXT "momcap59")
MOMMK3_59 = MOMMK3 INTERACT (MOMDMY WITH TEXT "momcap59")
MOMMK4_59 = MOMMK4 INTERACT (MOMDMY WITH TEXT "momcap59")
MOMMK5_59 = MOMMK5 INTERACT (MOMDMY WITH TEXT "momcap59")
MOMMK6_59 = MOMMK6 INTERACT (MOMDMY WITH TEXT "momcap59")
MOMMK7_59 = MOMMK7 INTERACT (MOMDMY WITH TEXT "momcap59")
MOMMK1_67 = MOMMK1 INTERACT (MOMDMY WITH TEXT "momcap67")
MOMMK2_67 = MOMMK2 INTERACT (MOMDMY WITH TEXT "momcap67")
MOMMK3_67 = MOMMK3 INTERACT (MOMDMY WITH TEXT "momcap67")
MOMMK4_67 = MOMMK4 INTERACT (MOMDMY WITH TEXT "momcap67")
MOMMK5_67 = MOMMK5 INTERACT (MOMDMY WITH TEXT "momcap67")
MOMMK6_67 = MOMMK6 INTERACT (MOMDMY WITH TEXT "momcap67")
MOMMK7_67 = MOMMK7 INTERACT (MOMDMY WITH TEXT "momcap67")
MOMMK1_68 = MOMMK1 INTERACT (MOMDMY WITH TEXT "momcap68")
MOMMK2_68 = MOMMK2 INTERACT (MOMDMY WITH TEXT "momcap68")
MOMMK3_68 = MOMMK3 INTERACT (MOMDMY WITH TEXT "momcap68")
MOMMK4_68 = MOMMK4 INTERACT (MOMDMY WITH TEXT "momcap68")
MOMMK5_68 = MOMMK5 INTERACT (MOMDMY WITH TEXT "momcap68")
MOMMK6_68 = MOMMK6 INTERACT (MOMDMY WITH TEXT "momcap68")
MOMMK7_68 = MOMMK7 INTERACT (MOMDMY WITH TEXT "momcap68")
MOMMK1_69 = MOMMK1 INTERACT (MOMDMY WITH TEXT "momcap69")
MOMMK2_69 = MOMMK2 INTERACT (MOMDMY WITH TEXT "momcap69")
MOMMK3_69 = MOMMK3 INTERACT (MOMDMY WITH TEXT "momcap69")
MOMMK4_69 = MOMMK4 INTERACT (MOMDMY WITH TEXT "momcap69")
MOMMK5_69 = MOMMK5 INTERACT (MOMDMY WITH TEXT "momcap69")
MOMMK6_69 = MOMMK6 INTERACT (MOMDMY WITH TEXT "momcap69")
MOMMK7_69 = MOMMK7 INTERACT (MOMDMY WITH TEXT "momcap69")
MOMMK1_78 = MOMMK1 INTERACT (MOMDMY WITH TEXT "momcap78")
MOMMK2_78 = MOMMK2 INTERACT (MOMDMY WITH TEXT "momcap78")
MOMMK3_78 = MOMMK3 INTERACT (MOMDMY WITH TEXT "momcap78")
MOMMK4_78 = MOMMK4 INTERACT (MOMDMY WITH TEXT "momcap78")
MOMMK5_78 = MOMMK5 INTERACT (MOMDMY WITH TEXT "momcap78")
MOMMK6_78 = MOMMK6 INTERACT (MOMDMY WITH TEXT "momcap78")
MOMMK7_78 = MOMMK7 INTERACT (MOMDMY WITH TEXT "momcap78")
MOMMK1_79 = MOMMK1 INTERACT (MOMDMY WITH TEXT "momcap79")
MOMMK2_79 = MOMMK2 INTERACT (MOMDMY WITH TEXT "momcap79")
MOMMK3_79 = MOMMK3 INTERACT (MOMDMY WITH TEXT "momcap79")
MOMMK4_79 = MOMMK4 INTERACT (MOMDMY WITH TEXT "momcap79")
MOMMK5_79 = MOMMK5 INTERACT (MOMDMY WITH TEXT "momcap79")
MOMMK6_79 = MOMMK6 INTERACT (MOMDMY WITH TEXT "momcap79")
MOMMK7_79 = MOMMK7 INTERACT (MOMDMY WITH TEXT "momcap79")
MOMMK1_89 = MOMMK1 INTERACT (MOMDMY WITH TEXT "momcap89")
MOMMK2_89 = MOMMK2 INTERACT (MOMDMY WITH TEXT "momcap89")
MOMMK3_89 = MOMMK3 INTERACT (MOMDMY WITH TEXT "momcap89")
MOMMK4_89 = MOMMK4 INTERACT (MOMDMY WITH TEXT "momcap89")
MOMMK5_89 = MOMMK5 INTERACT (MOMDMY WITH TEXT "momcap89")
MOMMK6_89 = MOMMK6 INTERACT (MOMDMY WITH TEXT "momcap89")
MOMMK7_89 = MOMMK7 INTERACT (MOMDMY WITH TEXT "momcap89")
 
MOMMK1_12_no = MOMMK1 INTERACT (MOMDMY NOT WITH TEXT "momcap12")
MOMMK2_12_no = MOMMK2 INTERACT (MOMDMY NOT WITH TEXT "momcap12")
MOMMK3_12_no = MOMMK3 INTERACT (MOMDMY NOT WITH TEXT "momcap12")
MOMMK4_12_no = MOMMK4 INTERACT (MOMDMY NOT WITH TEXT "momcap12")
MOMMK5_12_no = MOMMK5 INTERACT (MOMDMY NOT WITH TEXT "momcap12")
MOMMK6_12_no = MOMMK6 INTERACT (MOMDMY NOT WITH TEXT "momcap12")
MOMMK7_12_no = MOMMK7 INTERACT (MOMDMY NOT WITH TEXT "momcap12")
MOMMK1_13_no = MOMMK1 INTERACT (MOMDMY NOT WITH TEXT "momcap13")
MOMMK2_13_no = MOMMK2 INTERACT (MOMDMY NOT WITH TEXT "momcap13")
MOMMK3_13_no = MOMMK3 INTERACT (MOMDMY NOT WITH TEXT "momcap13")
MOMMK4_13_no = MOMMK4 INTERACT (MOMDMY NOT WITH TEXT "momcap13")
MOMMK5_13_no = MOMMK5 INTERACT (MOMDMY NOT WITH TEXT "momcap13")
MOMMK6_13_no = MOMMK6 INTERACT (MOMDMY NOT WITH TEXT "momcap13")
MOMMK7_13_no = MOMMK7 INTERACT (MOMDMY NOT WITH TEXT "momcap13")
MOMMK1_14_no = MOMMK1 INTERACT (MOMDMY NOT WITH TEXT "momcap14")
MOMMK2_14_no = MOMMK2 INTERACT (MOMDMY NOT WITH TEXT "momcap14")
MOMMK3_14_no = MOMMK3 INTERACT (MOMDMY NOT WITH TEXT "momcap14")
MOMMK4_14_no = MOMMK4 INTERACT (MOMDMY NOT WITH TEXT "momcap14")
MOMMK5_14_no = MOMMK5 INTERACT (MOMDMY NOT WITH TEXT "momcap14")
MOMMK6_14_no = MOMMK6 INTERACT (MOMDMY NOT WITH TEXT "momcap14")
MOMMK7_14_no = MOMMK7 INTERACT (MOMDMY NOT WITH TEXT "momcap14")
MOMMK1_15_no = MOMMK1 INTERACT (MOMDMY NOT WITH TEXT "momcap15")
MOMMK2_15_no = MOMMK2 INTERACT (MOMDMY NOT WITH TEXT "momcap15")
MOMMK3_15_no = MOMMK3 INTERACT (MOMDMY NOT WITH TEXT "momcap15")
MOMMK4_15_no = MOMMK4 INTERACT (MOMDMY NOT WITH TEXT "momcap15")
MOMMK5_15_no = MOMMK5 INTERACT (MOMDMY NOT WITH TEXT "momcap15")
MOMMK6_15_no = MOMMK6 INTERACT (MOMDMY NOT WITH TEXT "momcap15")
MOMMK7_15_no = MOMMK7 INTERACT (MOMDMY NOT WITH TEXT "momcap15")
MOMMK1_16_no = MOMMK1 INTERACT (MOMDMY NOT WITH TEXT "momcap16")
MOMMK2_16_no = MOMMK2 INTERACT (MOMDMY NOT WITH TEXT "momcap16")
MOMMK3_16_no = MOMMK3 INTERACT (MOMDMY NOT WITH TEXT "momcap16")
MOMMK4_16_no = MOMMK4 INTERACT (MOMDMY NOT WITH TEXT "momcap16")
MOMMK5_16_no = MOMMK5 INTERACT (MOMDMY NOT WITH TEXT "momcap16")
MOMMK6_16_no = MOMMK6 INTERACT (MOMDMY NOT WITH TEXT "momcap16")
MOMMK7_16_no = MOMMK7 INTERACT (MOMDMY NOT WITH TEXT "momcap16")
MOMMK1_17_no = MOMMK1 INTERACT (MOMDMY NOT WITH TEXT "momcap17")
MOMMK2_17_no = MOMMK2 INTERACT (MOMDMY NOT WITH TEXT "momcap17")
MOMMK3_17_no = MOMMK3 INTERACT (MOMDMY NOT WITH TEXT "momcap17")
MOMMK4_17_no = MOMMK4 INTERACT (MOMDMY NOT WITH TEXT "momcap17")
MOMMK5_17_no = MOMMK5 INTERACT (MOMDMY NOT WITH TEXT "momcap17")
MOMMK6_17_no = MOMMK6 INTERACT (MOMDMY NOT WITH TEXT "momcap17")
MOMMK7_17_no = MOMMK7 INTERACT (MOMDMY NOT WITH TEXT "momcap17")
MOMMK1_18_no = MOMMK1 INTERACT (MOMDMY NOT WITH TEXT "momcap18")
MOMMK2_18_no = MOMMK2 INTERACT (MOMDMY NOT WITH TEXT "momcap18")
MOMMK3_18_no = MOMMK3 INTERACT (MOMDMY NOT WITH TEXT "momcap18")
MOMMK4_18_no = MOMMK4 INTERACT (MOMDMY NOT WITH TEXT "momcap18")
MOMMK5_18_no = MOMMK5 INTERACT (MOMDMY NOT WITH TEXT "momcap18")
MOMMK6_18_no = MOMMK6 INTERACT (MOMDMY NOT WITH TEXT "momcap18")
MOMMK7_18_no = MOMMK7 INTERACT (MOMDMY NOT WITH TEXT "momcap18")
MOMMK1_19_no = MOMMK1 INTERACT (MOMDMY NOT WITH TEXT "momcap19")
MOMMK2_19_no = MOMMK2 INTERACT (MOMDMY NOT WITH TEXT "momcap19")
MOMMK3_19_no = MOMMK3 INTERACT (MOMDMY NOT WITH TEXT "momcap19")
MOMMK4_19_no = MOMMK4 INTERACT (MOMDMY NOT WITH TEXT "momcap19")
MOMMK5_19_no = MOMMK5 INTERACT (MOMDMY NOT WITH TEXT "momcap19")
MOMMK6_19_no = MOMMK6 INTERACT (MOMDMY NOT WITH TEXT "momcap19")
MOMMK7_19_no = MOMMK7 INTERACT (MOMDMY NOT WITH TEXT "momcap19")
MOMMK1_23_no = MOMMK1 INTERACT (MOMDMY NOT WITH TEXT "momcap23")
MOMMK2_23_no = MOMMK2 INTERACT (MOMDMY NOT WITH TEXT "momcap23")
MOMMK3_23_no = MOMMK3 INTERACT (MOMDMY NOT WITH TEXT "momcap23")
MOMMK4_23_no = MOMMK4 INTERACT (MOMDMY NOT WITH TEXT "momcap23")
MOMMK5_23_no = MOMMK5 INTERACT (MOMDMY NOT WITH TEXT "momcap23")
MOMMK6_23_no = MOMMK6 INTERACT (MOMDMY NOT WITH TEXT "momcap23")
MOMMK7_23_no = MOMMK7 INTERACT (MOMDMY NOT WITH TEXT "momcap23")
MOMMK1_24_no = MOMMK1 INTERACT (MOMDMY NOT WITH TEXT "momcap24")
MOMMK2_24_no = MOMMK2 INTERACT (MOMDMY NOT WITH TEXT "momcap24")
MOMMK3_24_no = MOMMK3 INTERACT (MOMDMY NOT WITH TEXT "momcap24")
MOMMK4_24_no = MOMMK4 INTERACT (MOMDMY NOT WITH TEXT "momcap24")
MOMMK5_24_no = MOMMK5 INTERACT (MOMDMY NOT WITH TEXT "momcap24")
MOMMK6_24_no = MOMMK6 INTERACT (MOMDMY NOT WITH TEXT "momcap24")
MOMMK7_24_no = MOMMK7 INTERACT (MOMDMY NOT WITH TEXT "momcap24")
MOMMK1_25_no = MOMMK1 INTERACT (MOMDMY NOT WITH TEXT "momcap25")
MOMMK2_25_no = MOMMK2 INTERACT (MOMDMY NOT WITH TEXT "momcap25")
MOMMK3_25_no = MOMMK3 INTERACT (MOMDMY NOT WITH TEXT "momcap25")
MOMMK4_25_no = MOMMK4 INTERACT (MOMDMY NOT WITH TEXT "momcap25")
MOMMK5_25_no = MOMMK5 INTERACT (MOMDMY NOT WITH TEXT "momcap25")
MOMMK6_25_no = MOMMK6 INTERACT (MOMDMY NOT WITH TEXT "momcap25")
MOMMK7_25_no = MOMMK7 INTERACT (MOMDMY NOT WITH TEXT "momcap25")
MOMMK1_26_no = MOMMK1 INTERACT (MOMDMY NOT WITH TEXT "momcap26")
MOMMK2_26_no = MOMMK2 INTERACT (MOMDMY NOT WITH TEXT "momcap26")
MOMMK3_26_no = MOMMK3 INTERACT (MOMDMY NOT WITH TEXT "momcap26")
MOMMK4_26_no = MOMMK4 INTERACT (MOMDMY NOT WITH TEXT "momcap26")
MOMMK5_26_no = MOMMK5 INTERACT (MOMDMY NOT WITH TEXT "momcap26")
MOMMK6_26_no = MOMMK6 INTERACT (MOMDMY NOT WITH TEXT "momcap26")
MOMMK7_26_no = MOMMK7 INTERACT (MOMDMY NOT WITH TEXT "momcap26")
MOMMK1_27_no = MOMMK1 INTERACT (MOMDMY NOT WITH TEXT "momcap27")
MOMMK2_27_no = MOMMK2 INTERACT (MOMDMY NOT WITH TEXT "momcap27")
MOMMK3_27_no = MOMMK3 INTERACT (MOMDMY NOT WITH TEXT "momcap27")
MOMMK4_27_no = MOMMK4 INTERACT (MOMDMY NOT WITH TEXT "momcap27")
MOMMK5_27_no = MOMMK5 INTERACT (MOMDMY NOT WITH TEXT "momcap27")
MOMMK6_27_no = MOMMK6 INTERACT (MOMDMY NOT WITH TEXT "momcap27")
MOMMK7_27_no = MOMMK7 INTERACT (MOMDMY NOT WITH TEXT "momcap27")
MOMMK1_28_no = MOMMK1 INTERACT (MOMDMY NOT WITH TEXT "momcap28")
MOMMK2_28_no = MOMMK2 INTERACT (MOMDMY NOT WITH TEXT "momcap28")
MOMMK3_28_no = MOMMK3 INTERACT (MOMDMY NOT WITH TEXT "momcap28")
MOMMK4_28_no = MOMMK4 INTERACT (MOMDMY NOT WITH TEXT "momcap28")
MOMMK5_28_no = MOMMK5 INTERACT (MOMDMY NOT WITH TEXT "momcap28")
MOMMK6_28_no = MOMMK6 INTERACT (MOMDMY NOT WITH TEXT "momcap28")
MOMMK7_28_no = MOMMK7 INTERACT (MOMDMY NOT WITH TEXT "momcap28")
MOMMK1_29_no = MOMMK1 INTERACT (MOMDMY NOT WITH TEXT "momcap29")
MOMMK2_29_no = MOMMK2 INTERACT (MOMDMY NOT WITH TEXT "momcap29")
MOMMK3_29_no = MOMMK3 INTERACT (MOMDMY NOT WITH TEXT "momcap29")
MOMMK4_29_no = MOMMK4 INTERACT (MOMDMY NOT WITH TEXT "momcap29")
MOMMK5_29_no = MOMMK5 INTERACT (MOMDMY NOT WITH TEXT "momcap29")
MOMMK6_29_no = MOMMK6 INTERACT (MOMDMY NOT WITH TEXT "momcap29")
MOMMK7_29_no = MOMMK7 INTERACT (MOMDMY NOT WITH TEXT "momcap29")
MOMMK1_34_no = MOMMK1 INTERACT (MOMDMY NOT WITH TEXT "momcap34")
MOMMK2_34_no = MOMMK2 INTERACT (MOMDMY NOT WITH TEXT "momcap34")
MOMMK3_34_no = MOMMK3 INTERACT (MOMDMY NOT WITH TEXT "momcap34")
MOMMK4_34_no = MOMMK4 INTERACT (MOMDMY NOT WITH TEXT "momcap34")
MOMMK5_34_no = MOMMK5 INTERACT (MOMDMY NOT WITH TEXT "momcap34")
MOMMK6_34_no = MOMMK6 INTERACT (MOMDMY NOT WITH TEXT "momcap34")
MOMMK7_34_no = MOMMK7 INTERACT (MOMDMY NOT WITH TEXT "momcap34")
MOMMK1_35_no = MOMMK1 INTERACT (MOMDMY NOT WITH TEXT "momcap35")
MOMMK2_35_no = MOMMK2 INTERACT (MOMDMY NOT WITH TEXT "momcap35")
MOMMK3_35_no = MOMMK3 INTERACT (MOMDMY NOT WITH TEXT "momcap35")
MOMMK4_35_no = MOMMK4 INTERACT (MOMDMY NOT WITH TEXT "momcap35")
MOMMK5_35_no = MOMMK5 INTERACT (MOMDMY NOT WITH TEXT "momcap35")
MOMMK6_35_no = MOMMK6 INTERACT (MOMDMY NOT WITH TEXT "momcap35")
MOMMK7_35_no = MOMMK7 INTERACT (MOMDMY NOT WITH TEXT "momcap35")
MOMMK1_36_no = MOMMK1 INTERACT (MOMDMY NOT WITH TEXT "momcap36")
MOMMK2_36_no = MOMMK2 INTERACT (MOMDMY NOT WITH TEXT "momcap36")
MOMMK3_36_no = MOMMK3 INTERACT (MOMDMY NOT WITH TEXT "momcap36")
MOMMK4_36_no = MOMMK4 INTERACT (MOMDMY NOT WITH TEXT "momcap36")
MOMMK5_36_no = MOMMK5 INTERACT (MOMDMY NOT WITH TEXT "momcap36")
MOMMK6_36_no = MOMMK6 INTERACT (MOMDMY NOT WITH TEXT "momcap36")
MOMMK7_36_no = MOMMK7 INTERACT (MOMDMY NOT WITH TEXT "momcap36")
MOMMK1_37_no = MOMMK1 INTERACT (MOMDMY NOT WITH TEXT "momcap37")
MOMMK2_37_no = MOMMK2 INTERACT (MOMDMY NOT WITH TEXT "momcap37")
MOMMK3_37_no = MOMMK3 INTERACT (MOMDMY NOT WITH TEXT "momcap37")
MOMMK4_37_no = MOMMK4 INTERACT (MOMDMY NOT WITH TEXT "momcap37")
MOMMK5_37_no = MOMMK5 INTERACT (MOMDMY NOT WITH TEXT "momcap37")
MOMMK6_37_no = MOMMK6 INTERACT (MOMDMY NOT WITH TEXT "momcap37")
MOMMK7_37_no = MOMMK7 INTERACT (MOMDMY NOT WITH TEXT "momcap37")
MOMMK1_38_no = MOMMK1 INTERACT (MOMDMY NOT WITH TEXT "momcap38")
MOMMK2_38_no = MOMMK2 INTERACT (MOMDMY NOT WITH TEXT "momcap38")
MOMMK3_38_no = MOMMK3 INTERACT (MOMDMY NOT WITH TEXT "momcap38")
MOMMK4_38_no = MOMMK4 INTERACT (MOMDMY NOT WITH TEXT "momcap38")
MOMMK5_38_no = MOMMK5 INTERACT (MOMDMY NOT WITH TEXT "momcap38")
MOMMK6_38_no = MOMMK6 INTERACT (MOMDMY NOT WITH TEXT "momcap38")
MOMMK7_38_no = MOMMK7 INTERACT (MOMDMY NOT WITH TEXT "momcap38")
MOMMK1_39_no = MOMMK1 INTERACT (MOMDMY NOT WITH TEXT "momcap39")
MOMMK2_39_no = MOMMK2 INTERACT (MOMDMY NOT WITH TEXT "momcap39")
MOMMK3_39_no = MOMMK3 INTERACT (MOMDMY NOT WITH TEXT "momcap39")
MOMMK4_39_no = MOMMK4 INTERACT (MOMDMY NOT WITH TEXT "momcap39")
MOMMK5_39_no = MOMMK5 INTERACT (MOMDMY NOT WITH TEXT "momcap39")
MOMMK6_39_no = MOMMK6 INTERACT (MOMDMY NOT WITH TEXT "momcap39")
MOMMK7_39_no = MOMMK7 INTERACT (MOMDMY NOT WITH TEXT "momcap39")
MOMMK1_45_no = MOMMK1 INTERACT (MOMDMY NOT WITH TEXT "momcap45")
MOMMK2_45_no = MOMMK2 INTERACT (MOMDMY NOT WITH TEXT "momcap45")
MOMMK3_45_no = MOMMK3 INTERACT (MOMDMY NOT WITH TEXT "momcap45")
MOMMK4_45_no = MOMMK4 INTERACT (MOMDMY NOT WITH TEXT "momcap45")
MOMMK5_45_no = MOMMK5 INTERACT (MOMDMY NOT WITH TEXT "momcap45")
MOMMK6_45_no = MOMMK6 INTERACT (MOMDMY NOT WITH TEXT "momcap45")
MOMMK7_45_no = MOMMK7 INTERACT (MOMDMY NOT WITH TEXT "momcap45")
MOMMK1_46_no = MOMMK1 INTERACT (MOMDMY NOT WITH TEXT "momcap46")
MOMMK2_46_no = MOMMK2 INTERACT (MOMDMY NOT WITH TEXT "momcap46")
MOMMK3_46_no = MOMMK3 INTERACT (MOMDMY NOT WITH TEXT "momcap46")
MOMMK4_46_no = MOMMK4 INTERACT (MOMDMY NOT WITH TEXT "momcap46")
MOMMK5_46_no = MOMMK5 INTERACT (MOMDMY NOT WITH TEXT "momcap46")
MOMMK6_46_no = MOMMK6 INTERACT (MOMDMY NOT WITH TEXT "momcap46")
MOMMK7_46_no = MOMMK7 INTERACT (MOMDMY NOT WITH TEXT "momcap46")
MOMMK1_47_no = MOMMK1 INTERACT (MOMDMY NOT WITH TEXT "momcap47")
MOMMK2_47_no = MOMMK2 INTERACT (MOMDMY NOT WITH TEXT "momcap47")
MOMMK3_47_no = MOMMK3 INTERACT (MOMDMY NOT WITH TEXT "momcap47")
MOMMK4_47_no = MOMMK4 INTERACT (MOMDMY NOT WITH TEXT "momcap47")
MOMMK5_47_no = MOMMK5 INTERACT (MOMDMY NOT WITH TEXT "momcap47")
MOMMK6_47_no = MOMMK6 INTERACT (MOMDMY NOT WITH TEXT "momcap47")
MOMMK7_47_no = MOMMK7 INTERACT (MOMDMY NOT WITH TEXT "momcap47")
MOMMK1_48_no = MOMMK1 INTERACT (MOMDMY NOT WITH TEXT "momcap48")
MOMMK2_48_no = MOMMK2 INTERACT (MOMDMY NOT WITH TEXT "momcap48")
MOMMK3_48_no = MOMMK3 INTERACT (MOMDMY NOT WITH TEXT "momcap48")
MOMMK4_48_no = MOMMK4 INTERACT (MOMDMY NOT WITH TEXT "momcap48")
MOMMK5_48_no = MOMMK5 INTERACT (MOMDMY NOT WITH TEXT "momcap48")
MOMMK6_48_no = MOMMK6 INTERACT (MOMDMY NOT WITH TEXT "momcap48")
MOMMK7_48_no = MOMMK7 INTERACT (MOMDMY NOT WITH TEXT "momcap48")
MOMMK1_49_no = MOMMK1 INTERACT (MOMDMY NOT WITH TEXT "momcap49")
MOMMK2_49_no = MOMMK2 INTERACT (MOMDMY NOT WITH TEXT "momcap49")
MOMMK3_49_no = MOMMK3 INTERACT (MOMDMY NOT WITH TEXT "momcap49")
MOMMK4_49_no = MOMMK4 INTERACT (MOMDMY NOT WITH TEXT "momcap49")
MOMMK5_49_no = MOMMK5 INTERACT (MOMDMY NOT WITH TEXT "momcap49")
MOMMK6_49_no = MOMMK6 INTERACT (MOMDMY NOT WITH TEXT "momcap49")
MOMMK7_49_no = MOMMK7 INTERACT (MOMDMY NOT WITH TEXT "momcap49")
MOMMK1_56_no = MOMMK1 INTERACT (MOMDMY NOT WITH TEXT "momcap56")
MOMMK2_56_no = MOMMK2 INTERACT (MOMDMY NOT WITH TEXT "momcap56")
MOMMK3_56_no = MOMMK3 INTERACT (MOMDMY NOT WITH TEXT "momcap56")
MOMMK4_56_no = MOMMK4 INTERACT (MOMDMY NOT WITH TEXT "momcap56")
MOMMK5_56_no = MOMMK5 INTERACT (MOMDMY NOT WITH TEXT "momcap56")
MOMMK6_56_no = MOMMK6 INTERACT (MOMDMY NOT WITH TEXT "momcap56")
MOMMK7_56_no = MOMMK7 INTERACT (MOMDMY NOT WITH TEXT "momcap56")
MOMMK1_57_no = MOMMK1 INTERACT (MOMDMY NOT WITH TEXT "momcap57")
MOMMK2_57_no = MOMMK2 INTERACT (MOMDMY NOT WITH TEXT "momcap57")
MOMMK3_57_no = MOMMK3 INTERACT (MOMDMY NOT WITH TEXT "momcap57")
MOMMK4_57_no = MOMMK4 INTERACT (MOMDMY NOT WITH TEXT "momcap57")
MOMMK5_57_no = MOMMK5 INTERACT (MOMDMY NOT WITH TEXT "momcap57")
MOMMK6_57_no = MOMMK6 INTERACT (MOMDMY NOT WITH TEXT "momcap57")
MOMMK7_57_no = MOMMK7 INTERACT (MOMDMY NOT WITH TEXT "momcap57")
MOMMK1_58_no = MOMMK1 INTERACT (MOMDMY NOT WITH TEXT "momcap58")
MOMMK2_58_no = MOMMK2 INTERACT (MOMDMY NOT WITH TEXT "momcap58")
MOMMK3_58_no = MOMMK3 INTERACT (MOMDMY NOT WITH TEXT "momcap58")
MOMMK4_58_no = MOMMK4 INTERACT (MOMDMY NOT WITH TEXT "momcap58")
MOMMK5_58_no = MOMMK5 INTERACT (MOMDMY NOT WITH TEXT "momcap58")
MOMMK6_58_no = MOMMK6 INTERACT (MOMDMY NOT WITH TEXT "momcap58")
MOMMK7_58_no = MOMMK7 INTERACT (MOMDMY NOT WITH TEXT "momcap58")
MOMMK1_59_no = MOMMK1 INTERACT (MOMDMY NOT WITH TEXT "momcap59")
MOMMK2_59_no = MOMMK2 INTERACT (MOMDMY NOT WITH TEXT "momcap59")
MOMMK3_59_no = MOMMK3 INTERACT (MOMDMY NOT WITH TEXT "momcap59")
MOMMK4_59_no = MOMMK4 INTERACT (MOMDMY NOT WITH TEXT "momcap59")
MOMMK5_59_no = MOMMK5 INTERACT (MOMDMY NOT WITH TEXT "momcap59")
MOMMK6_59_no = MOMMK6 INTERACT (MOMDMY NOT WITH TEXT "momcap59")
MOMMK7_59_no = MOMMK7 INTERACT (MOMDMY NOT WITH TEXT "momcap59")
MOMMK1_67_no = MOMMK1 INTERACT (MOMDMY NOT WITH TEXT "momcap67")
MOMMK2_67_no = MOMMK2 INTERACT (MOMDMY NOT WITH TEXT "momcap67")
MOMMK3_67_no = MOMMK3 INTERACT (MOMDMY NOT WITH TEXT "momcap67")
MOMMK4_67_no = MOMMK4 INTERACT (MOMDMY NOT WITH TEXT "momcap67")
MOMMK5_67_no = MOMMK5 INTERACT (MOMDMY NOT WITH TEXT "momcap67")
MOMMK6_67_no = MOMMK6 INTERACT (MOMDMY NOT WITH TEXT "momcap67")
MOMMK7_67_no = MOMMK7 INTERACT (MOMDMY NOT WITH TEXT "momcap67")
MOMMK1_68_no = MOMMK1 INTERACT (MOMDMY NOT WITH TEXT "momcap68")
MOMMK2_68_no = MOMMK2 INTERACT (MOMDMY NOT WITH TEXT "momcap68")
MOMMK3_68_no = MOMMK3 INTERACT (MOMDMY NOT WITH TEXT "momcap68")
MOMMK4_68_no = MOMMK4 INTERACT (MOMDMY NOT WITH TEXT "momcap68")
MOMMK5_68_no = MOMMK5 INTERACT (MOMDMY NOT WITH TEXT "momcap68")
MOMMK6_68_no = MOMMK6 INTERACT (MOMDMY NOT WITH TEXT "momcap68")
MOMMK7_68_no = MOMMK7 INTERACT (MOMDMY NOT WITH TEXT "momcap68")
MOMMK1_69_no = MOMMK1 INTERACT (MOMDMY NOT WITH TEXT "momcap69")
MOMMK2_69_no = MOMMK2 INTERACT (MOMDMY NOT WITH TEXT "momcap69")
MOMMK3_69_no = MOMMK3 INTERACT (MOMDMY NOT WITH TEXT "momcap69")
MOMMK4_69_no = MOMMK4 INTERACT (MOMDMY NOT WITH TEXT "momcap69")
MOMMK5_69_no = MOMMK5 INTERACT (MOMDMY NOT WITH TEXT "momcap69")
MOMMK6_69_no = MOMMK6 INTERACT (MOMDMY NOT WITH TEXT "momcap69")
MOMMK7_69_no = MOMMK7 INTERACT (MOMDMY NOT WITH TEXT "momcap69")
MOMMK1_78_no = MOMMK1 INTERACT (MOMDMY NOT WITH TEXT "momcap78")
MOMMK2_78_no = MOMMK2 INTERACT (MOMDMY NOT WITH TEXT "momcap78")
MOMMK3_78_no = MOMMK3 INTERACT (MOMDMY NOT WITH TEXT "momcap78")
MOMMK4_78_no = MOMMK4 INTERACT (MOMDMY NOT WITH TEXT "momcap78")
MOMMK5_78_no = MOMMK5 INTERACT (MOMDMY NOT WITH TEXT "momcap78")
MOMMK6_78_no = MOMMK6 INTERACT (MOMDMY NOT WITH TEXT "momcap78")
MOMMK7_78_no = MOMMK7 INTERACT (MOMDMY NOT WITH TEXT "momcap78")
MOMMK1_79_no = MOMMK1 INTERACT (MOMDMY NOT WITH TEXT "momcap79")
MOMMK2_79_no = MOMMK2 INTERACT (MOMDMY NOT WITH TEXT "momcap79")
MOMMK3_79_no = MOMMK3 INTERACT (MOMDMY NOT WITH TEXT "momcap79")
MOMMK4_79_no = MOMMK4 INTERACT (MOMDMY NOT WITH TEXT "momcap79")
MOMMK5_79_no = MOMMK5 INTERACT (MOMDMY NOT WITH TEXT "momcap79")
MOMMK6_79_no = MOMMK6 INTERACT (MOMDMY NOT WITH TEXT "momcap79")
MOMMK7_79_no = MOMMK7 INTERACT (MOMDMY NOT WITH TEXT "momcap79")
MOMMK1_89_no = MOMMK1 INTERACT (MOMDMY NOT WITH TEXT "momcap89")
MOMMK2_89_no = MOMMK2 INTERACT (MOMDMY NOT WITH TEXT "momcap89")
MOMMK3_89_no = MOMMK3 INTERACT (MOMDMY NOT WITH TEXT "momcap89")
MOMMK4_89_no = MOMMK4 INTERACT (MOMDMY NOT WITH TEXT "momcap89")
MOMMK5_89_no = MOMMK5 INTERACT (MOMDMY NOT WITH TEXT "momcap89")
MOMMK6_89_no = MOMMK6 INTERACT (MOMDMY NOT WITH TEXT "momcap89")
MOMMK7_89_no = MOMMK7 INTERACT (MOMDMY NOT WITH TEXT "momcap89")
 
MOMDMY_12 = MOMDMY WITH TEXT "momcap12"
MOMDMY_13 = MOMDMY WITH TEXT "momcap13"
MOMDMY_14 = MOMDMY WITH TEXT "momcap14"
MOMDMY_15 = MOMDMY WITH TEXT "momcap15"
MOMDMY_16 = MOMDMY WITH TEXT "momcap16"
MOMDMY_17 = MOMDMY WITH TEXT "momcap17"
MOMDMY_18 = MOMDMY WITH TEXT "momcap18"
MOMDMY_19 = MOMDMY WITH TEXT "momcap19"
MOMDMY_23 = MOMDMY WITH TEXT "momcap23"
MOMDMY_24 = MOMDMY WITH TEXT "momcap24"
MOMDMY_25 = MOMDMY WITH TEXT "momcap25"
MOMDMY_26 = MOMDMY WITH TEXT "momcap26"
MOMDMY_27 = MOMDMY WITH TEXT "momcap27"
MOMDMY_28 = MOMDMY WITH TEXT "momcap28"
MOMDMY_29 = MOMDMY WITH TEXT "momcap29"
MOMDMY_34 = MOMDMY WITH TEXT "momcap34"
MOMDMY_35 = MOMDMY WITH TEXT "momcap35"
MOMDMY_36 = MOMDMY WITH TEXT "momcap36"
MOMDMY_37 = MOMDMY WITH TEXT "momcap37"
MOMDMY_38 = MOMDMY WITH TEXT "momcap38"
MOMDMY_39 = MOMDMY WITH TEXT "momcap39"
MOMDMY_45 = MOMDMY WITH TEXT "momcap45"
MOMDMY_46 = MOMDMY WITH TEXT "momcap46"
MOMDMY_47 = MOMDMY WITH TEXT "momcap47"
MOMDMY_48 = MOMDMY WITH TEXT "momcap48"
MOMDMY_49 = MOMDMY WITH TEXT "momcap49"
MOMDMY_56 = MOMDMY WITH TEXT "momcap56"
MOMDMY_57 = MOMDMY WITH TEXT "momcap57"
MOMDMY_58 = MOMDMY WITH TEXT "momcap58"
MOMDMY_59 = MOMDMY WITH TEXT "momcap59"
MOMDMY_67 = MOMDMY WITH TEXT "momcap67"
MOMDMY_68 = MOMDMY WITH TEXT "momcap68"
MOMDMY_69 = MOMDMY WITH TEXT "momcap69"
MOMDMY_78 = MOMDMY WITH TEXT "momcap78"
MOMDMY_79 = MOMDMY WITH TEXT "momcap79"
MOMDMY_89 = MOMDMY WITH TEXT "momcap89"
 
MOM_R_2_no_momcap {
@ Flag: No momcap1n label on MOMDMY
@ MOMDMY and MOMMKn (n = 1~7) layers are must for MOM device
@ DRC checking is based on the label text by MOMDMY layer. Possible label texts and related MOMMKn follow the Table-1
 err1 = MOMDMY NOT WITH TEXT "momcap?"
 err1 NOT INSIDE SealR_NOT_BULK
}
 
MOM_R_2_momcap1n {
@ MOMDMY and MOMMKn (n = 1~7) layers are must for MOM device
@ DRC checking is based on the label text by MOMDMY layer. Possible label texts and related MOMMKn follow the Table-1
@ Flag: Miss MOMMKn marker layer for momcap1n
 err12 = MOMDMY_12 NOT ((MOMDMY_12 INTERACT MOMMK1) INTERACT MOMMK2)
 err13 = MOMDMY_13 NOT (((MOMDMY_13 INTERACT MOMMK1) INTERACT MOMMK2) INTERACT MOMMK3)
 err14 = MOMDMY_14 NOT ((((MOMDMY_14 INTERACT MOMMK1) INTERACT MOMMK2) INTERACT MOMMK3) INTERACT MOMMK4)
 err15 = MOMDMY_15 NOT (((((MOMDMY_15 INTERACT MOMMK1) INTERACT MOMMK2) INTERACT MOMMK3) INTERACT MOMMK4) INTERACT MOMMK5)
 err16 = MOMDMY_16 NOT ((((((MOMDMY_16 INTERACT MOMMK1) INTERACT MOMMK2) INTERACT MOMMK3) INTERACT MOMMK4) INTERACT MOMMK5) INTERACT MOMMK6)
 err17 = MOMDMY_17 NOT (((((((MOMDMY_17 INTERACT MOMMK1) INTERACT MOMMK2) INTERACT MOMMK3) INTERACT MOMMK4) INTERACT MOMMK5) INTERACT MOMMK6) INTERACT MOMMK7)
 err12 NOT SealR_NOT_BULK
 err13 NOT SealR_NOT_BULK
 err14 NOT SealR_NOT_BULK
 err15 NOT SealR_NOT_BULK
 err16 NOT SealR_NOT_BULK
 err17 NOT SealR_NOT_BULK
}
 
MOM_R_2_momcap2n {
@ MOMDMY and MOMMKn (n = 1~7) layers are must for MOM device
@ DRC checking is based on the label text by MOMDMY layer. Possible label texts and related MOMMKn follow the Table-1
@ Flag: Miss MOMMKn marker layer for momcap2n
 err23 = MOMDMY_23 NOT ((MOMDMY_23 INTERACT MOMMK2) INTERACT MOMMK3)
 err24 = MOMDMY_24 NOT (((MOMDMY_24 INTERACT MOMMK2) INTERACT MOMMK3) INTERACT MOMMK4)
 err25 = MOMDMY_25 NOT ((((MOMDMY_25 INTERACT MOMMK2) INTERACT MOMMK3) INTERACT MOMMK4) INTERACT MOMMK5)
 err26 = MOMDMY_26 NOT (((((MOMDMY_26 INTERACT MOMMK2) INTERACT MOMMK3) INTERACT MOMMK4) INTERACT MOMMK5) INTERACT MOMMK6)
 err27 = MOMDMY_27 NOT ((((((MOMDMY_27 INTERACT MOMMK2) INTERACT MOMMK3) INTERACT MOMMK4) INTERACT MOMMK5) INTERACT MOMMK6) INTERACT MOMMK7)
 err23 NOT SealR_NOT_BULK
 err24 NOT SealR_NOT_BULK
 err25 NOT SealR_NOT_BULK
 err26 NOT SealR_NOT_BULK
 err27 NOT SealR_NOT_BULK
}
 
MOM_R_2_momcap3n {
@ MOMDMY and MOMMKn (n = 1~7) layers are must for MOM device
@ DRC checking is based on the label text by MOMDMY layer. Possible label texts and related MOMMKn follow the Table-1
@ Flag: Miss MOMMKn marker layer for momcap3n
 err34 = MOMDMY_34 NOT ((MOMDMY_34 INTERACT MOMMK3) INTERACT MOMMK4)
 err35 = MOMDMY_35 NOT (((MOMDMY_35 INTERACT MOMMK3) INTERACT MOMMK4) INTERACT MOMMK5)
 err36 = MOMDMY_36 NOT ((((MOMDMY_36 INTERACT MOMMK3) INTERACT MOMMK4) INTERACT MOMMK5) INTERACT MOMMK6)
 err37 = MOMDMY_37 NOT (((((MOMDMY_37 INTERACT MOMMK3) INTERACT MOMMK4) INTERACT MOMMK5) INTERACT MOMMK6) INTERACT MOMMK7)
 err34 NOT SealR_NOT_BULK
 err35 NOT SealR_NOT_BULK
 err36 NOT SealR_NOT_BULK
 err37 NOT SealR_NOT_BULK
}
 
MOM_R_2_momcap4n {
@ MOMDMY and MOMMKn (n = 1~7) layers are must for MOM device
@ DRC checking is based on the label text by MOMDMY layer. Possible label texts and related MOMMKn follow the Table-1
@ Flag: Miss MOMMKn marker layer for momcap4n
 err45 = MOMDMY_45 NOT ((MOMDMY_45 INTERACT MOMMK4) INTERACT MOMMK5)
 err46 = MOMDMY_46 NOT (((MOMDMY_46 INTERACT MOMMK4) INTERACT MOMMK5) INTERACT MOMMK6)
 err47 = MOMDMY_47 NOT ((((MOMDMY_47 INTERACT MOMMK4) INTERACT MOMMK5) INTERACT MOMMK6) INTERACT MOMMK7)
 err45 NOT SealR_NOT_BULK
 err46 NOT SealR_NOT_BULK
 err47 NOT SealR_NOT_BULK
}
 
MOM_R_2_momcap5n {
@ MOMDMY and MOMMKn (n = 1~7) layers are must for MOM device
@ DRC checking is based on the label text by MOMDMY layer. Possible label texts and related MOMMKn follow the Table-1
@ Flag: Miss MOMMKn marker layer for momcap5n
 err56 = MOMDMY_56 NOT ((MOMDMY_56 INTERACT MOMMK5) INTERACT MOMMK6)
 err57 = MOMDMY_57 NOT (((MOMDMY_57 INTERACT MOMMK5) INTERACT MOMMK6) INTERACT MOMMK7)
 err56 NOT SealR_NOT_BULK
 err57 NOT SealR_NOT_BULK
}
 
MOM_R_2_momcap6n {
@ MOMDMY and MOMMKn (n = 1~7) layers are must for MOM device
@ DRC checking is based on the label text by MOMDMY layer. Possible label texts and related MOMMKn follow the Table-1
@ Flag: Miss MOMMKn marker layer for momcap6n
 err67 = MOMDMY_67 NOT ((MOMDMY_67 INTERACT MOMMK6) INTERACT MOMMK7)
 err67 NOT SealR_NOT_BULK
}
 
MOM_R_2_momcap1n_more {
@ MOMDMY and MOMMKn (n = 1~7) layers are must for MOM device
@ DRC checking is based on the label text by MOMDMY layer. Possible label texts and related MOMMKn follow the Table-1
@ Flag: More MOMMKn marker layer for momcap1n
 err12 = MOMDMY_12 AND (OR MOMMK3 MOMMK4 MOMMK5 MOMMK6 MOMMK7)
 err13 = MOMDMY_13 AND (OR MOMMK4 MOMMK5 MOMMK6 MOMMK7)
 err14 = MOMDMY_14 AND (OR MOMMK5 MOMMK6 MOMMK7)
 err15 = MOMDMY_15 AND (OR MOMMK6 MOMMK7)
 err16 = MOMDMY_16 AND (COPY MOMMK7)
 err12 NOT SealR_NOT_BULK
 err13 NOT SealR_NOT_BULK
 err14 NOT SealR_NOT_BULK
 err15 NOT SealR_NOT_BULK
 err16 NOT SealR_NOT_BULK
}
 
MOM_R_2_momcap2n_more {
@ MOMDMY and MOMMKn (n = 1~7) layers are must for MOM device
@ DRC checking is based on the label text by MOMDMY layer. Possible label texts and related MOMMKn follow the Table-1
@ Flag: More MOMMKn marker layer for momcap2n
 err23 = MOMDMY_23 AND (OR MOMMK1 MOMMK4 MOMMK5 MOMMK6 MOMMK7)
 err24 = MOMDMY_24 AND (OR MOMMK1 MOMMK5 MOMMK6 MOMMK7)
 err25 = MOMDMY_25 AND (OR MOMMK1 MOMMK6 MOMMK7)
 err26 = MOMDMY_26 AND (OR MOMMK1 MOMMK7)
 err27 = MOMDMY_27 AND (COPY MOMMK1)
 err23 NOT SealR_NOT_BULK
 err24 NOT SealR_NOT_BULK
 err25 NOT SealR_NOT_BULK
 err26 NOT SealR_NOT_BULK
 err27 NOT SealR_NOT_BULK
}
 
MOM_R_2_momcap3n_more {
@ MOMDMY and MOMMKn (n = 1~7) layers are must for MOM device
@ DRC checking is based on the label text by MOMDMY layer. Possible label texts and related MOMMKn follow the Table-1
@ Flag: More MOMMKn marker layer for momcap3n
 err34 = MOMDMY_34 AND (OR MOMMK1 MOMMK2 MOMMK5 MOMMK6 MOMMK7)
 err35 = MOMDMY_35 AND (OR MOMMK1 MOMMK2 MOMMK6 MOMMK7)
 err36 = MOMDMY_36 AND (OR MOMMK1 MOMMK2 MOMMK7)
 err37 = MOMDMY_37 AND (OR MOMMK1 MOMMK2)
 err34 NOT SealR_NOT_BULK
 err35 NOT SealR_NOT_BULK
 err36 NOT SealR_NOT_BULK
 err37 NOT SealR_NOT_BULK
}
 
MOM_R_2_momcap4n_more {
@ MOMDMY and MOMMKn (n = 1~7) layers are must for MOM device
@ DRC checking is based on the label text by MOMDMY layer. Possible label texts and related MOMMKn follow the Table-1
@ Flag: More MOMMKn marker layer for momcap4n
 err45 = MOMDMY_45 AND (OR MOMMK1 MOMMK2 MOMMK3 MOMMK6 MOMMK7)
 err46 = MOMDMY_46 AND (OR MOMMK1 MOMMK2 MOMMK3 MOMMK7)
 err47 = MOMDMY_47 AND (OR MOMMK1 MOMMK2 MOMMK3)
 err45 NOT SealR_NOT_BULK
 err46 NOT SealR_NOT_BULK
 err47 NOT SealR_NOT_BULK
}
 
MOM_R_2_momcap5n_more {
@ MOMDMY and MOMMKn (n = 1~7) layers are must for MOM device
@ DRC checking is based on the label text by MOMDMY layer. Possible label texts and related MOMMKn follow the Table-1
@ Flag: More MOMMKn marker layer for momcap5n
 err56 = MOMDMY_56 AND (OR MOMMK1 MOMMK2 MOMMK3 MOMMK4 MOMMK7)
 err57 = MOMDMY_57 AND (OR MOMMK1 MOMMK2 MOMMK3 MOMMK4)
 err56 NOT SealR_NOT_BULK
 err57 NOT SealR_NOT_BULK
}
 
MOM_R_2_momcap6n_more {
@ MOMDMY and MOMMKn (n = 1~7) layers are must for MOM device
@ DRC checking is based on the label text by MOMDMY layer. Possible label texts and related MOMMKn follow the Table-1
@ Flag: More MOMMKn marker layer for momcap6n
 err67 = MOMDMY_67 AND (OR MOMMK1 MOMMK2 MOMMK3 MOMMK4 MOMMK5)
 err67 NOT SealR_NOT_BULK
}
 //;MOM.R.3[NC] Use symmetrical dummy metal around the matched pairs of MOM cells instead of auto inserted dummy
 //;MOM.R.4[NC] Active device underneath or above MOM cell should be put into couple capacitance consideration in design

// =======================================================
// Restricted special pattern design rule
// =======================================================
// RSPMK1 (CAD layer 131:153) is to define restricted special pattern marker layer 1

GROUP GRSPMK1 RSPMK1_?

RSPMK1_S_1 {
@ RSPMK1 space >= 0.18um
 err1 = EXT RSPMK1 < 0.18 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

RSPMK1_S_2 {
@ RSPMK1 space in GATE poly direction = 0.486, 0.39, >= 0.582um
 err1 = EXT RSPMK1_h_edges RSPMK1 < 0.390 ABUT<90 OPPOSITE REGION
 err2 = EXT RSPMK1_h_edges RSPMK1 > 0.390 < 0.486 ABUT<90 OPPOSITE REGION
 err3 = EXT RSPMK1_h_edges RSPMK1 > 0.486 < 0.582 ABUT<90 OPPOSITE REGION EXCLUDE SHIELDED
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
}

RSPMK1_EX_1 {
@ M0C (width = 0.051um) extension on RSPMK1 in GATE poly direction = 0.013um
 err1_TMP = ENC RSPMK1_h_edges [M0C_051] == 0.013 ABUT<90 OPPOSITE  //M0C totally inside RSPMK1 is ok
 err1 = ((M0C_051 INTERACT RSPMK1) NOT INSIDE RSPMK1) NOT WITH EDGE err1_TMP
 err1 NOT INSIDE SealR_NOT_BULK

 err2_TMP = SIZE RSPMK1 BY 0.013
 err2 = (M0C_051 INTERACT RSPMK1) NOT err2_TMP  //M0C extension on RSPMK1 must be <= 0.013 in all direction
 err2 NOT INSIDE SealR_NOT_BULK
}

AOP_M0_M0_B1_B2 = AOP_M0 OR M0_B1_B2

RSPMK1_O_1 {
@ M0C (width = 0.051um) overlap (AOP_M0 OR (M0_B1 OR M0_B2)) in GATE poly direction. = 0.026/0.051um
@ Flag://;Overlap not equal to 0.026/0.051um
@ Flag://;RSPMK1 without (AOP_M0 OR (M0_B1 OR_M0_B2))
 y1 = AOP_M0 NOT INTERACT M0_B1_B2   //AOP_M0 not interact M0_B1/M0_B2
 y2 = AOP_M0_M0_B1_B2 NOT y1   //AOP_M0 interact M0_B1/M0_B2

 z1 = y1 INTERACT (M0C INTERACT RSPMK1)
 z2 = y2 INTERACT (M0C INTERACT RSPMK1)
 err1 = INT z1 M0C_h_edges < 0.026 ABUT<90 OPPOSITE REGION  //m0c overlap with Y0 < 0.026, space = 0 is covered by M0C.S.7
 err2 = INT z1 M0C_h_edges > 0.026 < 0.051 ABUT<90 OPPOSITE REGION
 err3 = INT z2 M0C_h_edges < 0.026 ABUT<90 OPPOSITE REGION  //Y2 overlap with Y0 < 0.026
 err4 = INT z2 M0C_h_edges > 0.026 < 0.051 ABUT<90 OPPOSITE REGION
 err1 INTERACT RSPMK1
 err2 INTERACT RSPMK1
 err3 INTERACT RSPMK1
 err4 INTERACT RSPMK1

//;RSPMK1 without (AOP_M0 OR (M0_B1 OR_M0_B2))
 err5 = RSPMK1 NOT INTERACT (OR AOP_M0 M0_B1_B2)  //interact one of them is ok
 err5 NOT INSIDE SealR_NOT_BULK
}

RSPMK1_R_1 {
@ RSPMK1 must be a rectangle with width = 0.09um in GATE poly direction
 err1 = NOT RECTANGLE RSPMK1 ORTHOGONAL ONLY
 err2 = RSPMK1 NOT (INT RSPMK1_h_edges == 0.090 OPPOSITE REGION)
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

RSPMK1_R_2 {
@ M0C (width = 0.051um) must interact RSPMK1
 err1 = M0C_051 NOT INTERACT RSPMK1
 err1 NOT INSIDE SealR_NOT_BULK
}

RSPMK1_R_3 {
@ RSPMK1 (length > 0.4um) must interact V0, and extension on either one side of V0 must be 0.005um in GATE poly direction
@ Flag://;Extension on either side of V0 != 0.005um
@ Flag://;RSPMK1 with length > 0.4um not interact V0
 err1_TMP = ENC [V0i] RSPMK1_h_edges == 0.005 ABUT<90 OPPOSITE
 err1 = (V0i INTERACT RSPMK1) NOT WITH EDGE err1_TMP
 err1 NOT INSIDE SealR_NOT_BULK

 err2 = (RSPMK1 WITH EDGE (LENGTH RSPMK1_h_edges > 0.4)) NOT INTERACT V0i
 err2 NOT INSIDE SealR_NOT_BULK
}

RSPMK1_R_4 {
@ RSPMK1 overlap AOP_M0C (width = 0.048, 0.052, 0.082, 0.108um) or (AA NOT GTMK1) is not allowed
 chk_AOP_M0C = OR AOP_M0C_048 AOP_M0C_052 AOP_M0C_082 AOP_M0C_108
 err1 = RSPMK1 AND chk_AOP_M0C
 err2 = RSPMK1 AND (AA NOT GTMK1)
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

RSPMK1_R_5 {
@ (RSPMK1 SIZING -0.004um) overlap M0G is not allowed
 err1 = (SIZE RSPMK1 BY -0.004) AND M0G
 err1 NOT INSIDE SealR_NOT_BULK
}

RSPMK1_horizontal_centerline = DFM COPY (DFM SPACE RSPMK1 <= 0.090 BY INT VERTICAL) CENTERLINE
RSPMK1_horizontal_M1_centerline = DFM COPY (DFM SPACE (M1 INTERACT RSPMK1) <= 0.090 BY INT VERTICAL) CENTERLINE

RSPMK1_R_7 {
@ RSPMK1 center line must align with any one of M1 center line in S/D direction
 err1 = RSPMK1_horizontal_centerline NOT TOUCH EDGE RSPMK1_horizontal_M1_centerline
 err2 = RSPMK1_h_edges NOT TOUCH EDGE (RSPMK1 COIN INSIDE EDGE M1)
 err1 NOT INSIDE EDGE SealR_NOT_BULK
 err2 NOT INSIDE EDGE SealR_NOT_BULK
}

// =======================================================
// Butted M0 design rule
// =======================================================
// M0_B1 (59:13), M0_B2 (59:14) are used to connect both M0 line-ends together (line-ends space = 0.022/0.064um) at cell boundary inside RSPMK1
// Two M0s butted same M0_B1 or M0_B2 become one M0 when mask making process
// M0_B1 and M0_B2 (with two butted M0s) will be treated as M0 and follow M0 rules in DRC

GROUP GBM0 BM0_?

M0_B1_B2 = OR M0_B1 M0_B2

M0_B1_SELECT = ((RECTANGLE M0_B1) WITH EDGE (LENGTH (ANGLE M0_B1 == 0) == 0.04)) WITH EDGE (LENGTH (ANGLE M0_B1 == 90) == 0.022)
M0_B2_SELECT = ((RECTANGLE M0_B2) WITH EDGE (LENGTH (ANGLE M0_B2 == 0) == 0.04)) WITH EDGE (LENGTH (ANGLE M0_B2 == 90) == 0.064)

BM0_W_1_L_1_L_2 {
@ BM0.W.1: M0_B1 or M0_B2 width in S/D direction = 0.04um
@ BM0.L.1: M0_B1 length in GATE poly direction = 0.022um
@ BM0.L.2: M0_B2 length in GATE poly direction = 0.064um
 err1 = M0_B2 NOT M0_B2_SELECT
 err2 = M0_B1 NOT M0_B1_SELECT
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

BM0_O_1 {
@ M0_B1 overlap M0 in GATE poly direction and S/D direction respectively = 0.022/0.040um
 err1 = INT M0_B1_h_edges M0i < 0.022 ABUT>0<90 OPPOSITE REGION //;exclude butted M0_B1 and M0
 err2 = INT M0_B1_v_edges M0i < 0.040 ABUT>0<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

BM0_R_1 {
@ M0_B1 or M0_B2 must be a rectangle and fully inside M0 or fully butted with M0 at either one horizontal side
 good_M0_B1 = (M0_B1 WITH EDGE (M0_B1 COIN EDGE (ANGLE M0i == 0))) TOUCH M0i
 good_M0_B2 = M0_B2 WITH EDGE (M0_B2 COIN EDGE (ANGLE M0i == 0))

 err1 = M0_B1 NOT RECTANGLE
 err2 = M0_B2 NOT RECTANGLE
 err3 = (M0_B1 NOT M0i) NOT good_M0_B1
 err4 = (M0_B2 NOT M0i) NOT good_M0_B2
 err5 = M0_B2 INSIDE M0i

 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
 err4 NOT INSIDE SealR_NOT_BULK
 err5 NOT INSIDE SealR_NOT_BULK
}

BM0_R_2 {
@ (M0_B2 (INTERACT M0_B1) NOT M0_B1) must be one rectangle (width/length = 0.04/0.042um) and fully inside M0
 chk_M0_B2 = (M0_B2 INTERACT M0_B1) NOT M0_B1
 good_M0_B2 = RECTANGLE chk_M0_B2 == 0.04 BY == 0.042

 err1 = chk_M0_B2 NOT good_M0_B2
 err2 = chk_M0_B2 NOT M0i
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

BM0_R_3 {
@ M0_B2 (NOT INTERACT M0_B1) overlap M0 is not allowed
 err1 = (M0_B2 NOT INTERACT M0_B1) AND M0i
 err1 NOT INSIDE SealR_NOT_BULK
}

BM0_R_4 {
@ M0_B1 and M0_B2 must be inside RSPMK1
 err1 = M0_B1 NOT INSIDE RSPMK1
 err2 = M0_B2 NOT INSIDE RSPMK1
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

BM0_R_5 {
@ Horizontal edge of M0_B1/M0_B2 (horizontal edge fully butted with M0 at both sides) must be inside M0C
 EDGE_M0_B1 = ANGLE (M0_B1 COIN EDGE M0i) == 0
 ERRS_M0_B1 = EDGE_M0_B1 COIN EDGE (M0_B1 WITH EDGE EDGE_M0_B1 == 2)
 err1 = ERRS_M0_B1 NOT INSIDE EDGE M0C
 err1 NOT INSIDE EDGE SealR_NOT_BULK

 EDGE_M0_B2 = ANGLE (M0_B2 COIN EDGE M0i) == 0
 ERRS_M0_B2 = EDGE_M0_B2 COIN EDGE (M0_B2 WITH EDGE EDGE_M0_B2 == 2)
 err2 = ERRS_M0_B2 NOT INSIDE EDGE M0C
 err2 NOT INSIDE EDGE SealR_NOT_BULK
}

BM0_R_6 {
@ M0_B1 or M0_B2 interact (M0 (width = 0.054um) OR DOP_M0) is not allowed
 err1 = M0_B1_B2 INTERACT (M0_054_raw OR DOP_M0)
 err1 NOT INSIDE SealR_NOT_BULK
}

BM0_R_7 {
@ M0_B2 interact two or three M0_B1 is not allowed
 err1 = M0_B2 INTERACT M0_B1 == 2
 err2 = M0_B2 INTERACT M0_B1 == 3
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

// =======================================================
// Butted V0 design rule
// =======================================================
// V0_B0 (245:2) is used to replace two square V0 (space = 0.016um) with one square V0 or RV0 at cell boundary
// Two square V0 touch same V0_B0 become one rectangular V0 during mask making process
// V0_B0 which covers two square V0s will be treated as rectangular V0 and follow V0 rules in DRC

GROUP GBV0 BV0_?

V0_B0_SELECT = ((RECTANGLE V0_B0) WITH EDGE (LENGTH (ANGLE V0_B0 == 0) == 0.032)) WITH EDGE (LENGTH (ANGLE V0_B0 == 90) == 0.08)

BV0_W_1_L_1_L_2 {
@ BV0_W_1: V0_B0 width in S/D direction = 0.032um
@ BV0.L.1: Length of V0_B0 = 0.08um
 err1 = V0_B0 NOT V0_B0_SELECT
 err1 NOT INSIDE SealR_NOT_BULK
}

BV0_EN_1 {
@ Square V0 enclosure by V0_B0 for three sides = 0um
 chk_via = V0N_raw COIN EDGE V0_B0
 err1 = (V0N_raw INTERACT V0_B0) NOT WITH EDGE chk_via == 3
 err1 NOT INSIDE SealR_NOT_BULK

 err2 = (V0N_raw INTERACT V0_B0) NOT V0_B0
 err2 NOT INSIDE SealR_NOT_BULK
}

BV0_R_1 {
@ V0_B0 must overlap one or two square V0
@ V0_B0 overlap with RV0 is not allowed
 chk_via = copy V0_B0
 err1 = chk_via NOT INTERACT V0N_raw
 err2 = chk_via INTERACT V0N_raw > 2
 err3 = chk_via INTERACT RV0_raw
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
}

// =======================================================
// SRAM Bitcell Strap Layout Rules
// =======================================================

D0194_SRAM = COPY DPSRAM
D0691_SRAM = COPY UDSRAM
D0734_SRAM = COPY STSRAM
D0864_SRAM = COPY U2SRAM
D0907_SRAM = COPY DNSRAM

// =======================================================
// INST marker layer design rule
// =======================================================

GROUP GINST INST_?

INST_S_1 {
@ Space between INST in S/D direction when PRL > -0.144um. >= 0.21um
 err1 = EXT INST_v_edges < 0.21 ABUT<90 REGION OPPOSITE EXTENDED 0.144
 err1 NOT INSIDE SealR_NOT_BULK
}

INST_S_2 {
@ Space between INST in GATE poly direction when PRL > -0.21um. >= 0.144um
 err1 = EXT INST_h_edges < 0.144 ABUT<90 REGION OPPOSITE EXTENDED 0.210
 err1 NOT INSIDE SealR_NOT_BULK
}

// INST.S.3 (purposely blank)
// INST.S.4 (purposely blank)

/*
INST_S_3 {
@ Space between (INST AND NW) and CELLB in S/D direction when (Projection-Length-Difference < 0um) >= 0.5um
 err1 = EXT (INST AND NW) CELLB_v_edges < 0.5 ABUT<90 MEASURE ALL REGION NOT PROJ
 err2 = INST INTERACT CELLB SINGULAR ALSO
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

INST_S_4 {
@ Space between INST and CELLB in GATE poly direction when PRL > -0.14um (Overlap is not allowed) >= 0.144um
 err1 = EXT INST_h_edges CELLB_h_edges < 0.144 ABUT<90 REGION OPPOSITE EXTENDED 0.140
 err2 = COPY (INST INTERACT CELLB SINGULAR ALSO)
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}
*/

INST_S_5 {
@ Space between ALL_AA and INST in S/D direction when PRL > -0.24um (ALL_AA CUT INST is not allowed) >= 0.25um
 err1 = EXT ALL_AA_v_edges INST < 0.25 ABUT<90 OPPOSITE EXTENDED 0.24 REGION MEASURE ALL
 err1 NOT INSIDE SealR_NOT_BULK

 err2 = INST INSIDE EDGE ALL_AA
 err2 NOT INSIDE EDGE SealR_NOT_BULK
}

INST_S_5_1 {
@ Space between ALL_AA and INST in GATE poly direction when PRL > -0.25um (ALL_AA CUT INST is not allowed) >= 0.24um
 err1 = EXT ALL_AA_h_edges INST < 0.24 ABUT<90 OPPOSITE EXTENDED 0.25 REGION MEASURE ALL
 err2 = COPY (INST INSIDE EDGE ALL_AA)
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE EDGE SealR_NOT_BULK
}

INST_S_6 {
@ Space between NW and INST (NW cut INST is not allowed) >= 0.365um
 err1 = EXT NW INST < 0.365 ABUT<90 SINGULAR REGION EXCLUDE SHIELDED
 err2 = INST INSIDE EDGE NW
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE EDGE SealR_NOT_BULK
}

INST_S_7 {
@ Space between SVT_N and INST (space = 0um is allowed) >= 0.210um
 err1 = EXT SVT_N INST < 0.210 ABUT>0<90 SINGULAR REGION EXCLUDE SHIELDED  //;based on INST_S_1
 err1 NOT INSIDE SealR_NOT_BULK
}

INST_S_8 {
@ Space between SVT_P and INST (space = 0um is allowed) >= 0.210um
 err1 = EXT SVT_P INST < 0.210 ABUT>0<90 SINGULAR REGION EXCLUDE SHIELDED  //;based on INST_S_1
 err1 NOT INSIDE SealR_NOT_BULK
}

INST_S_9 {
@ Space between LVT_N and INST (space = 0um is allowed) >= 0.210um
 err1 = EXT LVT_N INST < 0.210 ABUT>0<90 SINGULAR REGION EXCLUDE SHIELDED  //;based on INST_S_1
 err1 NOT INSIDE SealR_NOT_BULK
}

INST_S_10 {
@ Space between LVT_P and INST (space = 0um is allowed) >= 0.210um
 err1 = EXT LVT_P INST < 0.210 ABUT>0<90 SINGULAR REGION EXCLUDE SHIELDED  //;based on INST_S_1
 err1 NOT INSIDE SealR_NOT_BULK
}

INST_S_11 {
@ Space between ULVT_N and INST (space = 0um is allowed) >= 0.210um
 err1 = EXT ULVT_N INST < 0.210 ABUT>0<90 SINGULAR REGION EXCLUDE SHIELDED  //;based on INST_S_1
 err1 NOT INSIDE SealR_NOT_BULK
}

INST_S_12 {
@ Space between ULVT_P and INST (space = 0um is allowed) >= 0.210um
 err1 = EXT ULVT_P INST < 0.210 ABUT>0<90 SINGULAR REGION EXCLUDE SHIELDED  //;based on INST_S_1
 err1 NOT INSIDE SealR_NOT_BULK
}

INST_S_13a {
@ Space between HVT_N and INST (space = 0um is allowed) >= 0.21um
 err1 = EXT HVT_N INST < 0.210 ABUT>0<90 SINGULAR REGION EXCLUDE SHIELDED  //;based on INST_S_1
 err1 NOT INSIDE SealR_NOT_BULK
}

INST_S_13b {
@ Space between HVT_P and INST (space = 0um is allowed) >= 0.21um
 err1 = EXT HVT_P INST < 0.210 ABUT>0<90 SINGULAR REGION EXCLUDE SHIELDED  //;based on INST_S_1
 err1 NOT INSIDE SealR_NOT_BULK
}

INST_S_14a {
@ Space between LFN_N and INST (space = 0um is allowed) >= 0.21um
 err1 = EXT LFN_N INST < 0.210 ABUT>0<90 SINGULAR REGION EXCLUDE SHIELDED  //;based on INST_S_1
 err1 NOT INSIDE SealR_NOT_BULK
}

INST_S_14b {
@ Space between LFN_P and INST (space = 0um is allowed) >= 0.21um
 err1 = EXT LFN_P INST < 0.210 ABUT>0<90 SINGULAR REGION EXCLUDE SHIELDED  //;based on INST_S_1
 err1 NOT INSIDE SealR_NOT_BULK
}

INST_S_15 {
@ Space between ALL_GT and INST (ALL_GT cut INST is not allowed) >= 0.118um
 err1 = EXT ALL_GT INST < 0.118 ABUT<90 SINGULAR REGION EXCLUDE SHIELDED  //;based on INST_S_1
 err2 = ALL_GT CUT INST
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

INST_S_16 {
@ Space between ALL_P2 and INST (ALL_P2 cut INST is not allowed) in S/D direction >= 0.09um
 err1 = EXT ALL_P2 INST_v_edges < 0.09 ABUT<90 OPPOSITE REGION MEASURE ALL
 err2 = ALL_P2 INTERACT INST SINGULAR ONLY
 err3 = ALL_P2 CUT INST
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
}

INST_S_16a {
@ Space between ALL_P2 and INST (ALL_P2 cut INST is not allowed) in GATE poly direction >= 0.15um
 err1 = EXT ALL_P2 INST_h_edges < 0.15 ABUT<90 OPPOSITE REGION MEASURE ALL
 err2 = COPY (ALL_P2 INTERACT INST SINGULAR ONLY)
 err3 = COPY (ALL_P2 CUT INST)
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
}

INST_S_17 {
@ Space between SN and INST (space = 0um is allowed). DRC flag opposite region >= 0.21um
 err1 = EXT SN INST < 0.21 ABUT>0<90 OPPOSITE REGION EXCLUDE SHIELDED  //;based on INST_S_1
 err1 NOT INSIDE SealR_NOT_BULK
}

INST_S_17a {
@ Space between SN edge (inside INST) and SN edge (outside INST) >= 0.25um
 check_OUTER = SN OUTSIDE EDGE INST
 check_INNER = SN NOT OUTSIDE EDGE INST
 waive_CORSS = EXT [SN] INST < 0.002 ABUT==90 INTERSECTING ONLY
 err1 = EXT (check_OUTER NOT TOUCH EDGE waive_CORSS) check_INNER < 0.25 ABUT>0<90 REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

INST_S_18 {
@ Space between SP and INST (space = 0um is allowed). DRC flag opposite region >= 0.21um
 err1 = EXT SP INST < 0.21 ABUT>0<90 OPPOSITE REGION EXCLUDE SHIELDED  //;based on INST_S_1
 err1 NOT INSIDE SealR_NOT_BULK
}

INST_S_18a {
@ Space between SP edge (inside INST) and SP edge (outside INST) >= 0.25um
 check_OUTER = SP OUTSIDE EDGE INST
 check_INNER = SP NOT OUTSIDE EDGE INST
 waive_CORSS = EXT [SP] INST < 0.002 ABUT==90 INTERSECTING ONLY
 err1 = EXT (check_OUTER NOT TOUCH EDGE waive_CORSS) check_INNER < 0.25 ABUT>0<90 REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

INST_S_20 {
@ Space between ALL_M0 and INST (ALL_M0 cut INST is not allowed) >= 0.136um
 err1 = EXT ALL_M0 INST < 0.136 ABUT<90 SINGULAR REGION MEASURE ALL
 err2 = ALL_M0 CUT INST
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

INST_S_22 {
@ Space between ALL_M0C and INST (ALL_M0C cut INST is not allowed) >= 0.18um
 err1 = EXT ALL_M0C INST < 0.18 ABUT<90 SINGULAR REGION MEASURE ALL
 err2 = ALL_M0C CUT INST
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

INST_S_23 {
@ Space between ALL_M0G and INST (ALL_M0G cut INST is not allowed) >= 0.085um
 err1 = EXT ALL_M0G INST < 0.085 ABUT<90 SINGULAR REGION MEASURE ALL
 err2 = ALL_M0G CUT INST
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

INST_S_26 {
@ Space between V0 and INST (V0 cut INST is not allowed) >= 0.084um
 err1 = EXT V0N INST < 0.084 ABUT<90 SINGULAR REGION MEASURE ALL
 err2 = COPY (V0N CUT INST)
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

INST_S_27 {
@ Space between RV0 and INST (RV0 CUT INST is not allowed) >= 0.084um
 err1 = EXT RV0 INST < 0.084 ABUT<90 SINGULAR REGION MEASURE ALL
 err2 = COPY (RV0 CUT INST)
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

INST_S_28 {
@ Space between ALL_M1 and INST >= 0.081um
 err1 = EXT M1_all INST < 0.081 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

#IFDEF CHIPB_RULES_CHECK YES
INST_EN_1 {
@ INST enclosure by CHIPB (INST cut CHIPB is not allowed) >= 0.5um
 err1 = CHIPB INSIDE EDGE INST
 err2 = ENC INST CHIPB < 0.5 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE EDGE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}
#ENDIF

INST_R_1 {
@ INST overlap (SVT_N or SVT_P or HVT_N or HVT_P or LVT_N or LVT_P or ULVT_N or ULVT_P or LFN_N or LFN_P) is not allowed
 err1 = INST AND ALL_VT_IMP
 err1 NOT INSIDE SealR_NOT_BULK
}

// =======================================================
// Latch-Up prevention layout guidelines
// =======================================================
//;Below definitions is for latch up rules DRC check
//;Recognize Power PAD with the label of top level text of all metal and metal text layers

M1_vdd_net_a = M1 WITH TEXT POWER_NAME M1i PRIMARY ONLY
M1_vss_net_a = M1 WITH TEXT POWER_NAME M1i PRIMARY ONLY
M2_vdd_net_a = M2 WITH TEXT POWER_NAME M2i PRIMARY ONLY
M2_vss_net_a = M2 WITH TEXT POWER_NAME M2i PRIMARY ONLY
M3_vdd_net_a = M3 WITH TEXT POWER_NAME M3i PRIMARY ONLY
M3_vss_net_a = M3 WITH TEXT POWER_NAME M3i PRIMARY ONLY
M4_vdd_net_a = M4 WITH TEXT POWER_NAME M4_40 PRIMARY ONLY
M4_vss_net_a = M4 WITH TEXT POWER_NAME M4_40 PRIMARY ONLY
M5_vdd_net_a = M5 WITH TEXT POWER_NAME M5_55 PRIMARY ONLY
M5_vss_net_a = M5 WITH TEXT POWER_NAME M5_55 PRIMARY ONLY
M6_vdd_net_a = M6 WITH TEXT POWER_NAME M6_50 PRIMARY ONLY
M6_vss_net_a = M6 WITH TEXT POWER_NAME M6_50 PRIMARY ONLY
M7_vdd_net_a = M7 WITH TEXT POWER_NAME M7_55 PRIMARY ONLY
M7_vss_net_a = M7 WITH TEXT POWER_NAME M7_55 PRIMARY ONLY
M8_vdd_net_a = M8 WITH TEXT POWER_NAME TM2i PRIMARY ONLY
M8_vss_net_a = M8 WITH TEXT POWER_NAME TM2i PRIMARY ONLY
ALPA_vdd_net_a = ALPA WITH TEXT POWER_NAME ALPA PRIMARY ONLY
ALPA_vss_net_a = ALPA WITH TEXT POWER_NAME ALPA PRIMARY ONLY
 
M1_vdd_net_b = M1 WITH TEXT POWER_NAME M1TXTi PRIMARY ONLY
M1_vss_net_b = M1 WITH TEXT POWER_NAME M1TXTi PRIMARY ONLY
M2_vdd_net_b = M2 WITH TEXT POWER_NAME M2TXTi PRIMARY ONLY
M2_vss_net_b = M2 WITH TEXT POWER_NAME M2TXTi PRIMARY ONLY
M3_vdd_net_b = M3 WITH TEXT POWER_NAME M3TXTi PRIMARY ONLY
M3_vss_net_b = M3 WITH TEXT POWER_NAME M3TXTi PRIMARY ONLY
M4_vdd_net_b = M4 WITH TEXT POWER_NAME M4TXTi PRIMARY ONLY
M4_vss_net_b = M4 WITH TEXT POWER_NAME M4TXTi PRIMARY ONLY
M5_vdd_net_b = M5 WITH TEXT POWER_NAME M5TXTi PRIMARY ONLY
M5_vss_net_b = M5 WITH TEXT POWER_NAME M5TXTi PRIMARY ONLY
M6_vdd_net_b = M6 WITH TEXT POWER_NAME M6TXTi PRIMARY ONLY
M6_vss_net_b = M6 WITH TEXT POWER_NAME M6TXTi PRIMARY ONLY
M7_vdd_net_b = M7 WITH TEXT POWER_NAME M7TXTi PRIMARY ONLY
M7_vss_net_b = M7 WITH TEXT POWER_NAME M7TXTi PRIMARY ONLY
M8_vdd_net_b = M8 WITH TEXT POWER_NAME TM2TXTi PRIMARY ONLY
M8_vss_net_b = M8 WITH TEXT POWER_NAME TM2TXTi PRIMARY ONLY
ALPA_vdd_net_b = ALPA WITH TEXT POWER_NAME ALPATXTi PRIMARY ONLY
ALPA_vss_net_b = ALPA WITH TEXT POWER_NAME ALPATXTi PRIMARY ONLY
M1_gnd_net_a = M1 WITH TEXT GROUND_NAME M1i PRIMARY ONLY
M1_vcc_net_a = M1 WITH TEXT GROUND_NAME M1i PRIMARY ONLY
M2_gnd_net_a = M2 WITH TEXT GROUND_NAME M2i PRIMARY ONLY
M2_vcc_net_a = M2 WITH TEXT GROUND_NAME M2i PRIMARY ONLY
M3_gnd_net_a = M3 WITH TEXT GROUND_NAME M3i PRIMARY ONLY
M3_vcc_net_a = M3 WITH TEXT GROUND_NAME M3i PRIMARY ONLY
M4_gnd_net_a = M4 WITH TEXT GROUND_NAME M4_40 PRIMARY ONLY
M4_vcc_net_a = M4 WITH TEXT GROUND_NAME M4_40 PRIMARY ONLY
M5_gnd_net_a = M5 WITH TEXT GROUND_NAME M5_55 PRIMARY ONLY
M5_vcc_net_a = M5 WITH TEXT GROUND_NAME M5_55 PRIMARY ONLY
M6_gnd_net_a = M6 WITH TEXT GROUND_NAME M6_50 PRIMARY ONLY
M6_vcc_net_a = M6 WITH TEXT GROUND_NAME M6_50 PRIMARY ONLY
M7_gnd_net_a = M7 WITH TEXT GROUND_NAME M7_55 PRIMARY ONLY
M7_vcc_net_a = M7 WITH TEXT GROUND_NAME M7_55 PRIMARY ONLY
M8_gnd_net_a = M8 WITH TEXT GROUND_NAME TM2i PRIMARY ONLY
M8_vcc_net_a = M8 WITH TEXT GROUND_NAME TM2i PRIMARY ONLY
ALPA_gnd_net_a = ALPA WITH TEXT GROUND_NAME ALPA PRIMARY ONLY
ALPA_vcc_net_a = ALPA WITH TEXT GROUND_NAME ALPA PRIMARY ONLY
 
M1_gnd_net_b = M1 WITH TEXT GROUND_NAME M1TXTi PRIMARY ONLY
M1_vcc_net_b = M1 WITH TEXT GROUND_NAME M1TXTi PRIMARY ONLY
M2_gnd_net_b = M2 WITH TEXT GROUND_NAME M2TXTi PRIMARY ONLY
M2_vcc_net_b = M2 WITH TEXT GROUND_NAME M2TXTi PRIMARY ONLY
M3_gnd_net_b = M3 WITH TEXT GROUND_NAME M3TXTi PRIMARY ONLY
M3_vcc_net_b = M3 WITH TEXT GROUND_NAME M3TXTi PRIMARY ONLY
M4_gnd_net_b = M4 WITH TEXT GROUND_NAME M4TXTi PRIMARY ONLY
M4_vcc_net_b = M4 WITH TEXT GROUND_NAME M4TXTi PRIMARY ONLY
M5_gnd_net_b = M5 WITH TEXT GROUND_NAME M5TXTi PRIMARY ONLY
M5_vcc_net_b = M5 WITH TEXT GROUND_NAME M5TXTi PRIMARY ONLY
M6_gnd_net_b = M6 WITH TEXT GROUND_NAME M6TXTi PRIMARY ONLY
M6_vcc_net_b = M6 WITH TEXT GROUND_NAME M6TXTi PRIMARY ONLY
M7_gnd_net_b = M7 WITH TEXT GROUND_NAME M7TXTi PRIMARY ONLY
M7_vcc_net_b = M7 WITH TEXT GROUND_NAME M7TXTi PRIMARY ONLY
M8_gnd_net_b = M8 WITH TEXT GROUND_NAME TM2TXTi PRIMARY ONLY
M8_vcc_net_b = M8 WITH TEXT GROUND_NAME TM2TXTi PRIMARY ONLY
ALPA_gnd_net_b = ALPA WITH TEXT GROUND_NAME ALPATXTi PRIMARY ONLY
ALPA_vcc_net_b = ALPA WITH TEXT GROUND_NAME ALPATXTi PRIMARY ONLY
M1_io_net_a = M1 WITH TEXT IO_NAME M1i PRIMARY ONLY
M2_io_net_a = M2 WITH TEXT IO_NAME M2i PRIMARY ONLY
M3_io_net_a = M3 WITH TEXT IO_NAME M3i PRIMARY ONLY
M4_io_net_a = M4 WITH TEXT IO_NAME M4_40 PRIMARY ONLY
M5_io_net_a = M5 WITH TEXT IO_NAME M5_55 PRIMARY ONLY
M6_io_net_a = M6 WITH TEXT IO_NAME M6_50 PRIMARY ONLY
M7_io_net_a = M7 WITH TEXT IO_NAME M7_55 PRIMARY ONLY
M8_io_net_a = M8 WITH TEXT IO_NAME TM2i PRIMARY ONLY
ALPA_io_net_a = ALPA WITH TEXT IO_NAME ALPA PRIMARY ONLY
 
M1_io_net_b = M1 WITH TEXT IO_NAME M1TXTi PRIMARY ONLY
M2_io_net_b = M2 WITH TEXT IO_NAME M2TXTi PRIMARY ONLY
M3_io_net_b = M3 WITH TEXT IO_NAME M3TXTi PRIMARY ONLY
M4_io_net_b = M4 WITH TEXT IO_NAME M4TXTi PRIMARY ONLY
M5_io_net_b = M5 WITH TEXT IO_NAME M5TXTi PRIMARY ONLY
M6_io_net_b = M6 WITH TEXT IO_NAME M6TXTi PRIMARY ONLY
M7_io_net_b = M7 WITH TEXT IO_NAME M7TXTi PRIMARY ONLY
M8_io_net_b = M8 WITH TEXT IO_NAME TM2TXTi PRIMARY ONLY
ALPA_io_net_b = ALPA WITH TEXT IO_NAME ALPATXTi PRIMARY ONLY
 
 
m1_to_ground = DFM PROPERTY M1 
M1_gnd_net_a M1_gnd_net_b M1_vss_net_a M1_vss_net_b M2_gnd_net_a M2_gnd_net_b M2_vss_net_a M2_vss_net_b 
M3_gnd_net_a M3_gnd_net_b M3_vss_net_a M3_vss_net_b M4_gnd_net_a M4_gnd_net_b M4_vss_net_a M4_vss_net_b 
M5_gnd_net_a M5_gnd_net_b M5_vss_net_a M5_vss_net_b M6_gnd_net_a M6_gnd_net_b M6_vss_net_a M6_vss_net_b 
M7_gnd_net_a M7_gnd_net_b M7_vss_net_a M7_vss_net_b M8_gnd_net_a M8_gnd_net_b M8_vss_net_a M8_vss_net_b 
ALPA_gnd_net_a ALPA_gnd_net_b ALPA_vss_net_a ALPA_vss_net_b NODAL MULTI 
[count = ( 
count(M1_gnd_net_a) > 0 || count(M1_gnd_net_b) > 0 || count(M1_vss_net_a) > 0 || count(M1_vss_net_b) > 0 || 
count(M2_gnd_net_a) > 0 || count(M2_gnd_net_b) > 0 || count(M2_vss_net_a) > 0 || count(M2_vss_net_b) > 0 || 
count(M3_gnd_net_a) > 0 || count(M3_gnd_net_b) > 0 || count(M3_vss_net_a) > 0 || count(M3_vss_net_b) > 0 || 
count(M4_gnd_net_a) > 0 || count(M4_gnd_net_b) > 0 || count(M4_vss_net_a) > 0 || count(M4_vss_net_b) > 0 || 
count(M5_gnd_net_a) > 0 || count(M5_gnd_net_b) > 0 || count(M5_vss_net_a) > 0 || count(M5_vss_net_b) > 0 || 
count(M6_gnd_net_a) > 0 || count(M6_gnd_net_b) > 0 || count(M6_vss_net_a) > 0 || count(M6_vss_net_b) > 0 || 
count(M7_gnd_net_a) > 0 || count(M7_gnd_net_b) > 0 || count(M7_vss_net_a) > 0 || count(M7_vss_net_b) > 0 || 
count(M8_gnd_net_a) > 0 || count(M8_gnd_net_b) > 0 || count(M8_vss_net_a) > 0 || count(M8_vss_net_b) > 0 || 
count(ALPA_gnd_net_a) > 0 || count(ALPA_gnd_net_b) > 0 || count(ALPA_vss_net_a) > 0 || count(ALPA_vss_net_b) > 0) ? 1 : 0] > 0
 
m1_to_power = DFM PROPERTY M1 
M1_vdd_net_a M1_vdd_net_b M1_vcc_net_a M1_vcc_net_b M2_vdd_net_a M2_vdd_net_b M2_vcc_net_a M2_vcc_net_b 
M3_vdd_net_a M3_vdd_net_b M3_vcc_net_a M3_vcc_net_b M4_vdd_net_a M4_vdd_net_b M4_vcc_net_a M4_vcc_net_b 
M5_vdd_net_a M5_vdd_net_b M5_vcc_net_a M5_vcc_net_b M6_vdd_net_a M6_vdd_net_b M6_vcc_net_a M6_vcc_net_b 
M7_vdd_net_a M7_vdd_net_b M7_vcc_net_a M7_vcc_net_b M8_vdd_net_a M8_vdd_net_b M8_vcc_net_a M8_vcc_net_b 
ALPA_vdd_net_a ALPA_vdd_net_b ALPA_vcc_net_a ALPA_vcc_net_b NODAL MULTI 
[count = ( 
count(M1_vdd_net_a) > 0 || count(M1_vdd_net_b) > 0 || count(M1_vcc_net_a) > 0 || count(M1_vcc_net_b) > 0 || 
count(M2_vdd_net_a) > 0 || count(M2_vdd_net_b) > 0 || count(M2_vcc_net_a) > 0 || count(M2_vcc_net_b) > 0 || 
count(M3_vdd_net_a) > 0 || count(M3_vdd_net_b) > 0 || count(M3_vcc_net_a) > 0 || count(M3_vcc_net_b) > 0 || 
count(M4_vdd_net_a) > 0 || count(M4_vdd_net_b) > 0 || count(M4_vcc_net_a) > 0 || count(M4_vcc_net_b) > 0 || 
count(M5_vdd_net_a) > 0 || count(M5_vdd_net_b) > 0 || count(M5_vcc_net_a) > 0 || count(M5_vcc_net_b) > 0 || 
count(M6_vdd_net_a) > 0 || count(M6_vdd_net_b) > 0 || count(M6_vcc_net_a) > 0 || count(M6_vcc_net_b) > 0 || 
count(M7_vdd_net_a) > 0 || count(M7_vdd_net_b) > 0 || count(M7_vcc_net_a) > 0 || count(M7_vcc_net_b) > 0 || 
count(M8_vdd_net_a) > 0 || count(M8_vdd_net_b) > 0 || count(M8_vcc_net_a) > 0 || count(M8_vcc_net_b) > 0 || 
count(ALPA_vdd_net_a) > 0 || count(ALPA_vdd_net_b) > 0 || count(ALPA_vcc_net_a) > 0 || count(ALPA_vcc_net_b) > 0) ? 1 : 0] > 0
 
m1_to_io = DFM PROPERTY M1 
M1_io_net_a M1_io_net_b M2_io_net_a M2_io_net_b M3_io_net_a M3_io_net_b M4_io_net_a M4_io_net_b 
M5_io_net_a M5_io_net_b M6_io_net_a M6_io_net_b M7_io_net_a M7_io_net_b M8_io_net_a M8_io_net_b 
ALPA_io_net_a ALPA_io_net_b NODAL MULTI 
[count = ( 
count(M1_io_net_a) > 0 || count(M1_io_net_b) > 0 || 
count(M2_io_net_a) > 0 || count(M2_io_net_b) > 0 || 
count(M3_io_net_a) > 0 || count(M3_io_net_b) > 0 || 
count(M4_io_net_a) > 0 || count(M4_io_net_b) > 0 || 
count(M5_io_net_a) > 0 || count(M5_io_net_b) > 0 || 
count(M6_io_net_a) > 0 || count(M6_io_net_b) > 0 || 
count(M7_io_net_a) > 0 || count(M7_io_net_b) > 0 || 
count(M8_io_net_a) > 0 || count(M8_io_net_b) > 0 || 
count(ALPA_io_net_a) > 0 || count(ALPA_io_net_b) > 0) ? 1 : 0] > 0

//;for latch-up connection
//;=========================================================================================================================================================================
//;Connectivity Check:
//;RES2H (131:178) is a DRC marking layer to identify resistor with resistance larger than 200ohm. If the resistance of used resistors between PAD and AA injector is larger than 200ohm,
//;the marking layer RES2H (131:178) should be cover on the resistor. Latch up rule check connection will be broken by resistors with RES2H layer
//;
//;RESH(131:179) is a DRC marking layer to identify resistor with resistance below 200ohm, but customer consider it is safe to break connectivity for latch up check
//;
//;DRC use the following features to check the connectivity:
//;1) The connectivity is formed by metal, via, ALPA, PA.
//;2) If resistors with RES2H (131:178) and RESH(131:179) including AA resistor, Hi-R resistor, well resistor are between PAD and AA injector, the connection is broken
//;3) The DRC switch of #CONNECT_ALL_RESISTOR (to connect AA resistor, Hi-R resistor, well resistor between PAD and AA injector) can control the connectivity of resistor
//;If #CONNECT_ALL_RESISTOR is on, the RES2H/RESH layer will not break the connection. This switch is off by default
//;4)DRC runset provides the following options for designer’s control
//;=========================================================================================================================================================================

RES_Broken = OR RES2H RESH

#IFDEF CONNECT_ALL_RESISTOR NO
NW_la = NW NOT (NWR_BODY AND RES_Broken)
HR_la = HR_0 NOT (DIR_AND_RESP2 AND RES_Broken)
#ENDIF

#IFDEF CONNECT_ALL_RESISTOR YES
NW_la = COPY NW
HR_la = COPY HR_0
#ENDIF

//;EMPTY layer for connect
LAYER MAP  9998  DATATYPE  1234  54321
LAYER EMPTY_lci  54321
EMPTY_lc = EMPTY_lci NOT BULK

M0_lc = EMPTY_lc OR M0_NOT_M0C
M0G_lc = EMPTY_lc OR M0G
M0_0_lc = EMPTY_lc OR M0_0

PSD_lc = EMPTY_lc OR PSD
NSD_lc = EMPTY_lc OR NSD
NTAP_lc = EMPTY_lc OR NTAPi
PTAP_lc = EMPTY_lc OR PTAP
real_PSD_lc = EMPTY_lc OR real_PSD
real_NSD_lc = EMPTY_lc OR real_NSD
P_inject_lc = EMPTY_lc OR P_inject
N_inject_lc = EMPTY_lc OR N_inject

AA_lc = EMPTY_lc OR PSD_lc NSD_lc NTAP_lc PTAP_lc real_PSD_lc real_NSD_lc P_inject_lc N_inject_lc
GT_lc = EMPTY_lc OR GT_0
HR_lc = EMPTY_lc OR HR_la
NW_lc = EMPTY_lc OR NW_la
PW_lc = EMPTY_lc OR PW_0
RW_lc = EMPTY_lc OR RW
PA_lc = EMPTY_lc OR PA
MD_lc = EMPTY_lc OR MD
V0_lc = EMPTY_lc OR V0
//;DNW_lc = EMPTY_lc OR DNW
NWRT_lc = EMPTY_lc OR NWRT
ALPA_lc = EMPTY_lc OR ALPA

TM_lc = EMPTY_lc OR TM
TM_1_lc = EMPTY_lc OR TM_1
UTV_lc = EMPTY_lc OR UTV
UTM_lc = EMPTY_lc OR UTM

TV_lc = EMPTY_lc OR TV
TV_AND_MIM_mapping_lc = EMPTY_lc OR TV_AND_MIM_mapping
TV_AND_CTOP_mapping_lc = EMPTY_lc OR TV_AND_CTOP_mapping
TV_NOT_MIM_CTOP_mapping_lc = EMPTY_lc OR TV_NOT_MIM_CTOP_mapping

CTOP_NOT_MIM_final_lc = EMPTY_lc OR CTOP_NOT_MIM_final
CTOP_final_lc = EMPTY_lc OR CTOP_final
MIM_final_lc = EMPTY_lc OR MIM_final


//;Metal/via definition

M1_lc = EMPTY_lc OR M1
M2_lc = EMPTY_lc OR M2
M3_lc = EMPTY_lc OR M3
M4_lc = EMPTY_lc OR M4
M5_lc = EMPTY_lc OR M5
M6_lc = EMPTY_lc OR M6
M7_lc = EMPTY_lc OR M7
M8_lc = EMPTY_lc OR M8
V1_lc = EMPTY_lc OR V1
V2_lc = EMPTY_lc OR V2
V3_lc = EMPTY_lc OR V3
V4_lc = EMPTY_lc OR V4
V5_lc = EMPTY_lc OR V5
V6_lc = EMPTY_lc OR V6
V7_lc = EMPTY_lc OR V7
TV2_lc = EMPTY_lc OR TV2
TM2_lc = EMPTY_lc OR TM2

// ---------------------------------------------------------------
// Beginning of the connection for Latch-up rules DRC check
// ---------------------------------------------------------------
CONNECT M0_0_lc M1_lc BY V0_lc
CONNECT M0_lc M1_lc BY V0_lc
CONNECT M0G_lc M1_lc BY V0_lc

CONNECT M0_0_lc NTAP_lc
CONNECT M0_0_lc PTAP_lc
CONNECT M0_0_lc real_PSD_lc
CONNECT M0_0_lc real_NSD_lc
CONNECT M0_0_lc P_inject_lc
CONNECT M0_0_lc N_inject_lc
CONNECT M0_0_lc PSD_lc
CONNECT M0_0_lc NSD_lc
CONNECT M0_0_lc GT_lc
CONNECT M0_0_lc M0_lc
CONNECT M0_0_lc M0G_lc

CONNECT M0_lc M0G_lc
CONNECT M0_lc NTAP_lc
CONNECT M0_lc PTAP_lc
CONNECT M0_lc real_PSD_lc
CONNECT M0_lc real_NSD_lc
CONNECT M0_lc P_inject_lc
CONNECT M0_lc N_inject_lc
CONNECT M0_lc PSD_lc
CONNECT M0_lc NSD_lc
CONNECT M0_lc GT_lc
CONNECT M0_lc NWRT_lc
CONNECT M0G_lc NTAP_lc
CONNECT M0G_lc PTAP_lc
CONNECT M0G_lc real_PSD_lc
CONNECT M0G_lc real_NSD_lc
CONNECT M0G_lc P_inject_lc
CONNECT M0G_lc N_inject_lc
CONNECT M0G_lc PSD_lc
CONNECT M0G_lc NSD_lc
CONNECT M0G_lc GT_lc
CONNECT M0G_lc HR_lc
CONNECT M0G_lc NWRT_lc

CONNECT AA_lc NTAP_lc
CONNECT AA_lc PTAP_lc
CONNECT AA_lc PSD_lc
CONNECT AA_lc NSD_lc
CONNECT AA_lc NWRT_lc
CONNECT real_PSD_lc PSD_lc
CONNECT real_NSD_lc NSD_lc
CONNECT P_inject_lc PSD_lc
CONNECT N_inject_lc NSD_lc

//;CONNECT DNW_lc NW_lc
CONNECT NTAP_lc NW_lc
CONNECT PTAP_lc RW_lc
CONNECT PTAP_lc PW_lc

//; For BEOL mapping layers connection 
CONNECT M1_lc M2_lc BY V1_lc
CONNECT M2_lc M3_lc BY V2_lc
CONNECT M3_lc M4_lc BY V3_lc
CONNECT M4_lc M5_lc BY V4_lc
CONNECT M5_lc M6_lc BY V5_lc
CONNECT M6_lc M7_lc BY V6_lc
CONNECT M7_lc M8_lc BY TV_NOT_MIM_CTOP_mapping_lc
CONNECT M8_lc MIM_final_lc BY TV_AND_MIM_mapping_lc
CONNECT M8_lc CTOP_final_lc BY TV_AND_CTOP_mapping_lc
CONNECT M8_lc ALPA_lc BY PA_lc
CONNECT TM_1_lc TM_lc BY TV_NOT_MIM_CTOP_mapping_lc
CONNECT TM_lc MIM_final_lc BY TV_AND_MIM_mapping_lc
CONNECT TM_lc CTOP_final_lc BY TV_AND_CTOP_mapping_lc
CONNECT TM_lc ALPA_lc BY PA_lc
CONNECT TM_lc PA_lc
CONNECT ALPA_lc MD_lc

//; For top via/metal self-connection
CONNECT TV_lc UTV_lc
CONNECT TM_lc UTM_lc
CONNECT TV_lc TV_AND_MIM_mapping_lc
CONNECT TV_lc TV_AND_CTOP_mapping_lc
CONNECT TV_lc TV_NOT_MIM_CTOP_mapping_lc
CONNECT TV_lc V7_lc
CONNECT TM_1_lc M7_lc
CONNECT TM_lc M8_lc
CONNECT CTOP_NOT_MIM_final_lc CTOP_final_lc

//; For all via/metal self-connection
CONNECT TM2_lc M8_lc
CONNECT TV2_lc V7_lc
// ---------------------------------------------------------------
// End of the connection for Latch-up rules DRC check
// ---------------------------------------------------------------

//; Begin to Recognize IO/Power PAD
//; Connect to PTAP (except NWR VARMOS RWDIO)
//; Connect to NTAP (except NWR VARMOS NWDIO)
//; MD_power_net_PTAP = NET AREA RATIO MD PTAP_no_RWDIODE_VAR > 0
//; MD_power_net_NTAP = NET AREA RATIO MD NTAP_no_NWR_DIO_VAR > 0

M1_io_mark = M1 AND IOMK1
MD_power_mark = MD AND (OR VDDMK1 VSSMK1)

#IFDEF DEFINE_LU_BY_TEXT ON
M1_power_TEXT = M1 INTERACT (OR m1_to_power m1_to_ground)
M1_io_TEXT = m1_to_io NOT INTERACT M1_power_TEXT
#ENDIF
#IFDEF DEFINE_LU_BY_TEXT OFF
M1_power_TEXT = M1 NOT BULK  //;empty layer
M1_io_TEXT = m1_to_io NOT BULK  //;empty layer
#ENDIF

M1_io_IOMK1 = DFM PROPERTY M1 M1_io_mark M1_power_TEXT NODAL MULTI 
  [-= (count(M1_io_mark) > 0 && count(M1_power_TEXT) == 0) ? 1 : 0] > 0
M1_power_MARK = DFM PROPERTY M1 MD_power_mark M1_io_TEXT M1_io_IOMK1 NODAL MULTI
  [-= (count(MD_power_mark) > 0 && count(M1_io_TEXT) == 0 && count(M1_io_IOMK1) == 0) ? 1 : 0] > 0
M1_power_PICKUP = DFM PROPERTY M1 PTAP_no_RWDIODE_VAR NTAP_no_NWR_DIO_VAR M1_io_TEXT M1_io_IOMK1 NODAL MULTI
  [-= ((count(PTAP_no_RWDIODE_VAR) > 0 || count(NTAP_no_NWR_DIO_VAR) > 0) && count(M1_io_TEXT) == 0 && count(M1_io_IOMK1) == 0) ? 1 : 0] > 0
MD_io_TRUELY = DFM PROPERTY MD M1_power_TEXT M1_power_MARK M1_power_PICKUP NODAL MULTI
  [-= (count(MD) > 0 && count(M1_power_TEXT) == 0 && count(M1_power_MARK) == 0 && count(M1_power_PICKUP) == 0) ? 1 : 0] > 0
M1_io_TRUELY = DFM PROPERTY M1 MD_io_TRUELY NODAL MULTI
  [-= (count(MD_io_TRUELY) > 0) ? 1 : 0] > 0
MD_io_pad = DFM PROPERTY MD M1_io_TEXT M1_io_IOMK1 MD_io_TRUELY NODAL MULTI
  [-= (count(M1_io_TEXT) > 0 || count(M1_io_IOMK1) > 0 || count(MD_io_TRUELY) > 0) ? 1 : 0] > 0

M1_power = M1 INTERACT (OR M1_power_TEXT M1_power_MARK M1_power_PICKUP)
M1_io = M1 INTERACT (OR M1_io_TEXT M1_io_IOMK1 M1_io_TRUELY)
M1_io_pad_lc_without_TRUELY = M1_lc INTERACT (OR M1_io_TEXT M1_io_IOMK1)
MD_io_pad_lc = MD_lc INTERACT MD_io_pad
//; End to Recognize IO/Power PAD

Ntype_injector_gc = AA_c AND Ntype_injector
Ptype_injector_gc = AA_c AND Ptype_injector
Ntype_injector_lc = AA_lc AND Ntype_injector
Ptype_injector_lc = AA_lc AND Ptype_injector

//;connect to power net (global connect)
PSD_power_pad = NET AREA RATIO PSD M1_power > 0
NSD_power_pad = NET AREA RATIO NSD M1_power > 0
PTAP_power_pad = NET AREA RATIO PTAP M1_power > 0
NTAP_power_pad = NET AREA RATIO NTAP M1_power > 0
NWRT_power_pad = NET AREA RATIO NWRT M1_power > 0
Ptype_power_pad = NET AREA RATIO Ptype_injector_gc M1_power > 0
Ntype_power_pad = NET AREA RATIO Ntype_injector_gc M1_power > 0

//;connect to IO net (local connect)
PSD_io_pad_lc = NET AREA RATIO PSD_lc OVER M1_io_pad_lc_without_TRUELY MD_io_pad_lc > 0
NSD_io_pad_lc = NET AREA RATIO NSD_lc OVER M1_io_pad_lc_without_TRUELY MD_io_pad_lc > 0
PTAP_io_pad_lc = NET AREA RATIO PTAP_lc OVER M1_io_pad_lc_without_TRUELY MD_io_pad_lc > 0
NTAP_io_pad_lc = NET AREA RATIO NTAP_lc OVER M1_io_pad_lc_without_TRUELY MD_io_pad_lc > 0
NWRT_io_pad_lc = NET AREA RATIO NWRT_lc OVER M1_io_pad_lc_without_TRUELY MD_io_pad_lc > 0
Ptype_io_pad_lc = NET AREA RATIO Ptype_injector_lc OVER M1_io_pad_lc_without_TRUELY MD_io_pad_lc > 0
Ntype_io_pad_lc = NET AREA RATIO Ntype_injector_lc OVER M1_io_pad_lc_without_TRUELY MD_io_pad_lc > 0

//;connect to IO net (global connect)
PSD_io_pad = (PSD INTERACT PSD_io_pad_lc) NOT INTERACT PSD_power_pad
NSD_io_pad = (NSD INTERACT NSD_io_pad_lc) NOT INTERACT NSD_power_pad
PTAP_io_pad = (PTAP INTERACT PTAP_io_pad_lc) NOT INTERACT PTAP_power_pad
NTAP_io_pad = (NTAP INTERACT NTAP_io_pad_lc) NOT INTERACT NTAP_power_pad
NWRT_io_pad = (NWRT INTERACT NWRT_io_pad_lc) NOT INTERACT NWRT_power_pad
Ptype_io_pad = (Ptype_injector_gc INTERACT Ptype_io_pad_lc) NOT INTERACT Ptype_power_pad
Ntype_io_pad = (Ntype_injector_gc INTERACT Ntype_io_pad_lc) NOT INTERACT Ntype_power_pad

NMOS_NTAP_io_pad = OR NSD_io_pad NTAP_io_pad
ALL_MOSAA_io_pad = OR PSD_io_pad NSD_io_pad

//;diode/var for latch-up check
PTAP_io_pad_RWDIO_CHK = PTAP_in_RWDIO INTERACT PTAP_io_pad
NTAP_io_pad_NWDIO_CHK = NTAP_in_NWDIO INTERACT NTAP_io_pad
PTAP_io_pad_PVART_CHK = PTAP_in_PVART INTERACT PTAP_io_pad
NTAP_io_pad_NVART_CHK = NTAP_in_NVART INTERACT NTAP_io_pad

PTAP_power_pad_RWDIO_CHK = PTAP_in_RWDIO INTERACT PTAP_power_pad
NTAP_power_pad_NWDIO_CHK = NTAP_in_NWDIO INTERACT NTAP_power_pad
PTAP_power_pad_PVART_CHK = PTAP_in_PVART INTERACT PTAP_power_pad
NTAP_power_pad_NVART_CHK = NTAP_in_NVART INTERACT NTAP_power_pad

//;SD and nwr
PSD_io_pad_CHK = ALL_MOSAA_io_pad AND PSD
NSD_io_pad_CHK = OR (ALL_MOSAA_io_pad AND NSD) (NWRT_io_pad AND NAA)
Ptype_io_pad_CHK = Ptype_io_pad NOT INSIDE LUWMK1
Ntype_io_pad_CHK = Ntype_io_pad NOT INSIDE LUWMK1

#IFDEF LATCH_UP_RULES_CHECK 85
//;ACT
LUWMK1_OCCDFH = OR LUWMK1 OCCDFH
AACT_real_io_pad = OR (ALL_MOSAA_io_pad INTERACT ACT) NWRT_io_pad
AACT_io_pad_dev = (OR AACT_real_io_pad PTAP_io_pad_RWDIO_CHK NTAP_io_pad_NWDIO_CHK PTAP_io_pad_PVART_CHK NTAP_io_pad_NVART_CHK) NOT INSIDE LUWMK1_OCCDFH
#IFDEF LATCH_UP_CHECK_MODE ACCURATE
AACT_io_pad_dev_SWELL_14 = SIZE AACT_io_pad_dev BY 14.976 INSIDE OF DRC:1 STEP 4 BEVEL 3
#ENDIF
#IFDEF LATCH_UP_CHECK_MODE FAST
AACT_io_pad_dev_SWELL_14 = SIZE AACT_io_pad_dev BY 14.976 INSIDE OF DRC:1 STEP 5
#ENDIF

AACT_real_non_io_pad_within_io_pad_dev_SWELL_14 = ((ACT AND AA_c) INTERACT AACT_io_pad_dev_SWELL_14) NOT AACT_io_pad_dev
NACT_real_non_io_pad_within_io_pad_dev_SWELL_14 = (NACT NOT OUTSIDE AACT_real_non_io_pad_within_io_pad_dev_SWELL_14) NOT AACT_MOS_floating
PACT_real_non_io_pad_within_io_pad_dev_SWELL_14 = (PACT NOT OUTSIDE AACT_real_non_io_pad_within_io_pad_dev_SWELL_14) NOT AACT_MOS_floating  //;LU.2
NWELL_within_io_pad_dev_SWELL_14 = NW INTERACT AACT_io_pad_dev_SWELL_14

//;PSD/PTAP_in_RWDIO
PAA_io_pad_CHK = (AA_c AND (OR (PSD_io_pad INTERACT PSD_io_pad_CHK) (PTAP_io_pad INTERACT (OR PTAP_io_pad_PVART_CHK PTAP_io_pad_RWDIO_CHK)))) NOT INSIDE LUWMK1_OCCDFH  //;IO +
NAA_io_pad_CHK = (AA_c AND (OR (NSD_io_pad INTERACT NSD_io_pad_CHK) (NTAP_io_pad INTERACT (OR NTAP_io_pad_NVART_CHK NTAP_io_pad_NWDIO_CHK)))) NOT INSIDE LUWMK1_OCCDFH  //;IO -
PAA_io_pad_NETID = DFM PROPERTY PAA_io_pad_CHK net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
NAA_io_pad_NETID = DFM PROPERTY NAA_io_pad_CHK net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

PAA_io_pad_vol_pos_CHK = NET AREA RATIO PAA_io_pad_CHK AA_NETID_vol_pos > 0
NAA_io_pad_vol_neg_CHK = NET AREA RATIO NAA_io_pad_CHK AA_NETID_vol_neg > 0

//;NETID for lu.4.1~4
PSD_power_pad_CHK = AA_c AND (OR PSD_power_pad (PTAP_power_pad INTERACT (OR PTAP_power_pad_PVART_CHK PTAP_power_pad_RWDIO_CHK)))  //;Power +
NSD_power_pad_CHK = AA_c AND (OR NSD_power_pad (NTAP_power_pad INTERACT (OR NTAP_power_pad_NVART_CHK NTAP_power_pad_NWDIO_CHK)))  //;Power -
PSD_power_pad_NETID = DFM PROPERTY PSD_power_pad_CHK net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
NSD_power_pad_NETID = DFM PROPERTY NSD_power_pad_CHK net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

PSD_power_pad_vol_pos_CHK = NET AREA RATIO PSD_power_pad_CHK AA_NETID_vol_pos > 0
NSD_power_pad_vol_neg_CHK = NET AREA RATIO NSD_power_pad_CHK AA_NETID_vol_neg > 0

//;RW/NW connect to io pad
RW_io_pad_CHK = NET AREA RATIO RW PTAP_io_pad > 0  //;IO PW Cathode
NW_io_pad_CHK = NET AREA RATIO NW OVER NTAP_io_pad NWRT_io_pad > 0  //;IO NW Cathode

RW_io_pad_NETID = DFM PROPERTY RW_io_pad_CHK net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
NW_io_pad_NETID = DFM PROPERTY NW_io_pad_CHK net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

RW_io_pad_vol_pos_CHK = NET AREA RATIO RW_io_pad_CHK PW_NETID_vol_pos > 0
NW_io_pad_vol_neg_CHK = NET AREA RATIO NW_io_pad_CHK NW_NETID_vol_neg > 0

//;pick-up ring derivation
NTAP_device_terminal = NTAP INTERACT (OR NWRT NTAP_io_pad_NWDIO_CHK NTAP_io_pad_NVART_CHK)
PTAP_device_terminal = NTAP INTERACT (OR NWRT PTAP_io_pad_RWDIO_CHK PTAP_io_pad_PVART_CHK)
NTAP_union_merged = SIZE (NTAP NOT NTAP_device_terminal) BY 0.576/2 OVERUNDER
PTAP_union_merged = SIZE (PTAP NOT PTAP_device_terminal) BY 0.576/2 OVERUNDER
NTAP_union_ring = (NTAP_union_merged AND SN) AND NW
PTAP_union_ring = (PTAP_union_merged AND SP) NOT NW

NTAP_gR_en_PACT_RAW = HOLES NTAP_union_ring INNER
PTAP_gR_en_NACT_RAW = HOLES PTAP_union_ring INNER
NTAP_gR_en_PACT_rings = NTAP_union_ring TOUCH NTAP_gR_en_PACT_RAW
PTAP_gR_en_NACT_rings = PTAP_union_ring TOUCH PTAP_gR_en_NACT_RAW
NTAP_gR_en_PACT = OR (NTAP_gR_en_PACT_RAW INSIDE NW_0) ((NTAP_gR_en_PACT_RAW INTERACT GATED_DIODE_ESD_ACT) NOT INTERACT (ACT NOT INTERACT GATED_DIODE_ESD_ACT)) //;holes
PTAP_gR_en_NACT = OR (PTAP_gR_en_NACT_RAW INSIDE PW_0) ((PTAP_gR_en_NACT_RAW INTERACT GATED_DIODE_ESD_ACT) NOT INTERACT (ACT NOT INTERACT GATED_DIODE_ESD_ACT))

PWPU_gR_rings_ALL = (PW_0 NOT PTAP_union_ring) NOT WITH EDGE (PW_0 NOT COIN OUTSIDE EDGE NW)
PWPU_gR_rings_TMP = (HOLES PWPU_gR_rings_ALL INNER) NOT INTERACT PTAP
PWPU_gR_rings_TMP_a = PWPU_gR_rings_ALL INTERACT PWPU_gR_rings_TMP
PWPU_gR_rings_TMP_b = (PWPU_gR_rings_TMP_a NOT PTAP_gR_en_NACT) TOUCH PTAP_gR_en_NACT_rings
PWPU_gR_rings_PSV = ((PWPU_gR_rings_TMP_b OR (HOLES PWPU_gR_rings_TMP_b INNER)) INTERACT (OR NWRT GATED_DIODE_ESD_NSD NTAP_in_NWDIO NTAP_in_NVART)) NOT ENCLOSE PSD
PWPU_gR_rings_MOS = (PWPU_gR_rings_ALL NOT WITH EDGE (PWPU_gR_rings_ALL COIN OUTSIDE EDGE NW)) NOT ENCLOSE PSD
PWPU_gR_rings = OR PWPU_gR_rings_PSV PWPU_gR_rings_MOS

NWPU_gR_rings_ALL = (NW NOT NTAP_union_ring) NOT WITH EDGE (NW NOT COIN OUTSIDE EDGE PW_0)
NWPU_gR_rings_TMP = (HOLES NWPU_gR_rings_ALL INNER) NOT INTERACT NTAP
NWPU_gR_rings_TMP_a = NWPU_gR_rings_ALL INTERACT NWPU_gR_rings_TMP
NWPU_gR_rings_TMP_b = (NWPU_gR_rings_TMP_a NOT NTAP_gR_en_PACT) TOUCH NTAP_gR_en_PACT_rings
NWPU_gR_rings_PSV = ((NWPU_gR_rings_TMP_b OR (HOLES NWPU_gR_rings_TMP_b INNER)) INTERACT (OR NWRT GATED_DIODE_ESD_PSD PTAP_in_RWDIO PTAP_in_PVART)) NOT ENCLOSE NSD
NWPU_gR_rings_MOS = (NWPU_gR_rings_ALL NOT WITH EDGE (NWPU_gR_rings_ALL COIN OUTSIDE EDGE PW_0)) NOT ENCLOSE NSD
NWPU_gR_rings = OR NWPU_gR_rings_PSV NWPU_gR_rings_MOS

NTAP_gR_rings_all = OR NTAP_gR_en_PACT NWPU_gR_rings
PTAP_gR_rings_all = OR PTAP_gR_en_NACT PWPU_gR_rings

NTAP_gR_en_RWDIO = (NTAP_gR_en_PACT_RAW NOT ENCLOSE NSD) INTERACT PTAP_io_pad_RWDIO_CHK  //;NTAP hole of rwdio (injector connect to IO pad)
PTAP_gR_en_NWDIO = (PTAP_gR_en_NACT_RAW NOT ENCLOSE PSD) INTERACT NTAP_io_pad_NWDIO_CHK  //;PTAP hole of nwdio (injector connect to IO pad)
NTAP_gR_en_PVART = (NWPU_gR_rings NOT ENCLOSE NSD) INTERACT PTAP_io_pad_PVART_CHK
PTAP_gR_en_NVART = (PWPU_gR_rings NOT ENCLOSE PSD) INTERACT NTAP_io_pad_NVART_CHK


// =======================================================
// Latch-Up (85 C) prevention layout guidelines
// =======================================================
// Important notice from dorian: any new device added in DRM, please make sure DRC already covered it in latch-up check

GROUP GLU LU_?

LU_1_G {
@ Guard ring should be used to surround AA injector or a group of AA injectors which are connected to an I/O pad, except OCCDFH region
@ N+AA injector must be surrounded by a P+ guard-ring
@ P+AA injector must be surrounded by a N+ guard-ring
@ NW/PW pickups rings can be used as guard rings
 err1 = NSD_io_pad_CHK NOT PTAP_gR_rings_all
 err2 = PSD_io_pad_CHK NOT NTAP_gR_rings_all
 err3 = NTAP_io_pad_NWDIO_CHK NOT PTAP_gR_en_NWDIO
 err4 = PTAP_io_pad_RWDIO_CHK NOT NTAP_gR_en_RWDIO
 err5 = NTAP_io_pad_NVART_CHK NOT PTAP_gR_en_NVART
 err6 = PTAP_io_pad_PVART_CHK NOT NTAP_gR_en_PVART

 err1 NOT (OR MARKS LUWMK1_OCCDFH)
 err2 NOT (OR MARKS LUWMK1_OCCDFH)
 err3 NOT (OR MARKS LUWMK1_OCCDFH)
 err4 NOT (OR MARKS LUWMK1_OCCDFH)
 err5 NOT (OR MARKS LUWMK1_OCCDFH)
 err6 NOT (OR MARKS LUWMK1_OCCDFH)
}

P_injector_vol = DFM PROPERTY PAA_io_pad_NETID [-= (property(PAA_io_pad_NETID, max_vol) >= 2.5 || property(PAA_io_pad_NETID, min_vol) <= -2.5) ? 1 : 0] > 0
N_injector_vol = DFM PROPERTY NAA_io_pad_NETID [-= (property(NAA_io_pad_NETID, max_vol) >= 2.5 || property(NAA_io_pad_NETID, min_vol) <= -2.5) ? 1 : 0] > 0

N_intector_NMOS_vol = (NSD_io_pad_CHK INTERACT N_injector_vol) NOT LUWMK1_OCCDFH
N_intector_NMOS_vol_gR_inner = PTAP_gR_en_NACT_RAW INTERACT N_intector_NMOS_vol
N_intector_NMOS_vol_gR_outer = (NTAP_gR_en_PACT_RAW INTERACT N_intector_NMOS_vol) NOT ENCLOSE PSD

P_intector_PMOS_vol = (PSD_io_pad_CHK INTERACT P_injector_vol) NOT LUWMK1_OCCDFH
P_intector_PMOS_vol_gR_inner = NTAP_gR_en_PACT_RAW INTERACT P_intector_PMOS_vol
P_intector_PMOS_vol_gR_outer = (PTAP_gR_en_NACT_RAW INTERACT P_intector_PMOS_vol) NOT ENCLOSE NSD

P_intector_RWDIO_vol = (PTAP_io_pad_RWDIO_CHK INTERACT P_injector_vol) NOT LUWMK1_OCCDFH
P_intector_RWDIO_vol_gR_inner = NTAP_gR_en_RWDIO INTERACT P_intector_RWDIO_vol
P_intector_RWDIO_vol_gR_outer = ((PTAP_gR_en_NACT_RAW INTERACT P_intector_RWDIO_vol_gR_inner) INTERACT PTAP_io_pad_RWDIO_CHK) NOT ENCLOSE NSD

N_intector_NWDIO_vol = (NTAP_io_pad_NWDIO_CHK INTERACT N_injector_vol) NOT LUWMK1_OCCDFH
N_intector_NWDIO_vol_gR_inner = PTAP_gR_en_NWDIO INTERACT N_intector_NWDIO_vol
N_intector_NWDIO_vol_gR_outer = ((NTAP_gR_en_PACT_RAW INTERACT N_intector_NWDIO_vol_gR_inner) INTERACT NTAP_io_pad_NWDIO_CHK) NOT ENCLOSE PSD

P_intector_PVART_vol = (PTAP_io_pad_PVART_CHK INTERACT P_injector_vol) NOT LUWMK1_OCCDFH
P_intector_PVART_vol_gR_inner = NTAP_gR_en_PVART INTERACT P_intector_PVART_vol
P_intector_PVART_vol_gR_outer = ((PTAP_gR_en_NACT_RAW INTERACT P_intector_PVART_vol_gR_inner) INTERACT PTAP_io_pad_PVART_CHK) NOT ENCLOSE NSD

N_intector_NVART_vol = (NTAP_io_pad_NVART_CHK INTERACT N_injector_vol) NOT LUWMK1_OCCDFH
N_intector_NVART_vol_gR_inner = PTAP_gR_en_NVART INTERACT N_intector_NVART_vol
N_intector_NVART_vol_gR_outer = ((NTAP_gR_en_PACT_RAW INTERACT N_intector_NVART_vol_gR_inner) INTERACT NTAP_io_pad_NVART_CHK) NOT ENCLOSE PSD

LU_1_2_G {
@ If Delta V >= 2.5V, one additional P+ guard-ring and one additional N+ guard-ring are required to be inserted between the guard-ring of LU.1.1
 err1 = N_intector_NMOS_vol NOT N_intector_NMOS_vol_gR_outer
 err2 = P_intector_PMOS_vol NOT P_intector_PMOS_vol_gR_outer
 err3 = P_intector_RWDIO_vol NOT P_intector_RWDIO_vol_gR_outer
 err4 = N_intector_NWDIO_vol NOT N_intector_NWDIO_vol_gR_outer
 err5 = P_intector_PVART_vol NOT P_intector_PVART_vol_gR_outer
 err6 = N_intector_NVART_vol NOT N_intector_NVART_vol_gR_outer

 err1 NOT LUWMK1_OCCDFH
 err2 NOT LUWMK1_OCCDFH
 err3 NOT LUWMK1_OCCDFH
 err4 NOT LUWMK1_OCCDFH
 err5 NOT LUWMK1_OCCDFH
 err6 NOT LUWMK1_OCCDFH
}

LU_2_3_G {
@ LU.2:
@ Within 14.976um from AA injector, a NMOS group must be surrounded by a P+ guard-ring; a PMOS group must be surrounded by a N+ guard-ring
@ The following cases are excluded:
@ 1. The MOS AA is covered by LUWMK1
@ 2. The MOS AA is floating. (DRC recognize MOS AA without V0 connection as floating MOS AA)
@ 3. The NMOS is inside DNW, and this DNW does not physically interact with PMOS NW. At the same time, voltage of the DNW >= voltage of PMOS NW
@ 4. OCCDFH region
@ LU.3:
@ Within 14.976um from AA injector, if two NW are with different potential, a PW strap must be inserted between these NWs (DRC only check NWs space <= 29.952um), except OCCDFH region
 err1 = NACT_real_non_io_pad_within_io_pad_dev_SWELL_14 NOT PTAP_gR_rings_all
 err2 = PACT_real_non_io_pad_within_io_pad_dev_SWELL_14 NOT NTAP_gR_rings_all

 err1 NOT (OR LUWMK1_OCCDFH AACT_MOS_floating)
 err2 NOT (OR LUWMK1_OCCDFH AACT_MOS_floating)
}

LU_3_G {
@ Within 14.976um from AA injector, if two NW are with different potential, a PW strap must be inserted between these NWs, (DRC only check NWs space <= 29.952um), except OCCDFH region
 NWELL_net_VOL_ERR = EXT NWELL_within_io_pad_dev_SWELL_14 < 29.952 NOT CONNECTED EXCLUDE SHIELDED
 NWELL_net_VOL_EDG = NWELL_within_io_pad_dev_SWELL_14 COIN EDGE (DFM COPY NWELL_net_VOL_ERR EDGE)
 NWELL_net_VOL_NETID = DFM PROPERTY NWELL_net_VOL_EDG net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)]

 NWELL_net_VOL_CHK_TMP = DFM PROPERTY NWELL_net_VOL_ERR NWELL_net_VOL_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(NWELL_net_VOL_NETID)]
 [VH_a1 = property(NWELL_net_VOL_NETID, "max_vol", 1)]
 [VH_a2 = property(NWELL_net_VOL_NETID, "max_vol", 2)]
 [DT_vA = fmax(abs(property_ref(VH_a1) - property_ref(VH_a2)))] > 0

 NWELL_net_VOL_CHK = NWELL_net_VOL_EDG COIN EDGE (DFM COPY NWELL_net_VOL_CHK_TMP EDGE)
 NWELL_net_VOL = DFM DV NWELL_net_VOL_EDG < 29.952 DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "nosync" > 0 ANNOTATE NOT CONNECTED
 NWELL_net_VOL_SIDE = DFM COPY NWELL_net_VOL EDGE
 NWELL_net_VOL_BAD = NWELL_net_VOL_CHK COIN EDGE (EXT (NWELL_net_VOL_SIDE) PTAP_union_ring < 29.952 ABUT<90 OPPOSITE EXCLUDE SHIELDED)
 err1 = DFM DV NWELL_net_VOL_CHK NWELL_net_VOL_BAD < 29.952 DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "nosync" > 0 ANNOTATE NOT CONNECTED OPPOSITE
 DFM COPY err1
}

//;For lu.7~9/11
ACT_active_nmos = (AACT_MOS_area AND SN) INTERACT M0_0
ACT_active_nmos_sd = ACT_active_nmos NOT GATE_raw

ACT_active_pmos = (AACT_MOS_area AND SP) INTERACT M0_0
ACT_active_pmos_sd = ACT_active_pmos NOT GATE_raw

acti_PTAP = PTAP INTERACT M0_0
acti_NTAP = NTAP INTERACT M0_0

#IFDEF LATCH_UP_CHECK_MODE ACCURATE
VARIABLE LU_Well_STEP 0.15  //;based on minimum Well space and AA enclosure
#ENDIF
#IFDEF LATCH_UP_CHECK_MODE FAST
VARIABLE LU_Well_STEP 0.22  //;based on minimum Well space and AA enclosure
#ENDIF

//;For nmos check
pw_step_i = ACT_active_nmos_sd NOT INSIDE OCCDFH
pw_step_1 = SIZE acti_PTAP BY 5 INSIDE OF PW_0 STEP LU_Well_STEP TRUNCATE LU_Well_STEP
pw_nmos_1_bad = pw_step_i NOT INSIDE pw_step_1
pw_nmos_1 = pw_step_1 INTERACT (PW_0 INTERACT pw_nmos_1_bad)
pw_step_2 = SIZE pw_nmos_1 BY 5 INSIDE OF PW_0 STEP LU_Well_STEP TRUNCATE LU_Well_STEP
pw_nmos_2_bad = pw_step_i NOT INSIDE pw_step_2
pw_nmos_2 = pw_step_2 INTERACT (PW_0 INTERACT pw_nmos_2_bad)

pw_step_3 = SIZE pw_nmos_2 BY 5 INSIDE OF PW_0 STEP LU_Well_STEP TRUNCATE LU_Well_STEP
pw_nmos_3_bad = pw_step_i NOT INSIDE pw_step_3
pw_nmos_3 = pw_step_3 INTERACT (PW_0 INTERACT pw_nmos_3_bad)
pw_step_4 = SIZE pw_nmos_3 BY 5 INSIDE OF PW_0 STEP LU_Well_STEP TRUNCATE LU_Well_STEP
pw_nmos_4_bad = pw_step_i NOT INSIDE pw_step_4
pw_nmos_4 = pw_step_4 INTERACT (PW_0 INTERACT pw_nmos_4_bad)

pw_step_5 = SIZE pw_nmos_4 BY 5 INSIDE OF PW_0 STEP LU_Well_STEP TRUNCATE LU_Well_STEP
pw_nmos_5_bad = pw_step_i NOT INSIDE pw_step_5
pw_nmos_5 = pw_step_5 INTERACT (PW_0 INTERACT pw_nmos_5_bad)
pw_step_6 = SIZE pw_nmos_5 BY 5 INSIDE OF PW_0 STEP LU_Well_STEP TRUNCATE LU_Well_STEP
pw_nmos_6_bad = pw_step_i NOT INSIDE pw_step_6
pw_nmos_6 = pw_step_6 INTERACT (PW_0 INTERACT pw_nmos_6_bad)

pw_step_7 = SIZE pw_nmos_6 BY 5 INSIDE OF PW_0 STEP LU_Well_STEP TRUNCATE LU_Well_STEP
pw_nmos_7_bad = pw_step_i NOT INSIDE pw_step_7
pw_nmos_7 = pw_step_7 INTERACT (PW_0 INTERACT pw_nmos_7_bad)
pw_step_8 = SIZE pw_nmos_7 BY 5 INSIDE OF PW_0 STEP LU_Well_STEP TRUNCATE LU_Well_STEP
pw_nmos_8_bad = pw_step_i NOT INSIDE pw_step_8
pw_nmos_8 = pw_step_8 INTERACT (PW_0 INTERACT pw_nmos_8_bad)

pw_step_9 = SIZE pw_nmos_8 BY 5 INSIDE OF PW_0 STEP LU_Well_STEP TRUNCATE LU_Well_STEP
pw_nmos_9_bad = pw_step_i NOT INSIDE pw_step_9
pw_nmos_9 = pw_step_9 INTERACT (PW_0 INTERACT pw_nmos_9_bad)
pw_step_0 = SIZE pw_nmos_9 BY 5 INSIDE OF PW_0 STEP LU_Well_STEP TRUNCATE LU_Well_STEP

//;For pmos check
nw_step_i = ACT_active_pmos_sd NOT INSIDE OCCDFH
nw_step_1 = SIZE acti_NTAP BY 5 INSIDE OF NW STEP LU_Well_STEP TRUNCATE LU_Well_STEP
nw_pmos_1_bad = nw_step_i NOT INSIDE nw_step_1
nw_pmos_1 = nw_step_1 INTERACT (NW INTERACT nw_pmos_1_bad)
nw_step_2 = SIZE nw_pmos_1 BY 5 INSIDE OF NW STEP LU_Well_STEP TRUNCATE LU_Well_STEP
nw_pmos_2_bad = nw_step_i NOT INSIDE nw_step_2
nw_pmos_2 = nw_step_2 INTERACT (NW INTERACT nw_pmos_2_bad)

nw_step_3 = SIZE nw_pmos_2 BY 5 INSIDE OF NW STEP LU_Well_STEP TRUNCATE LU_Well_STEP
nw_pmos_3_bad = nw_step_i NOT INSIDE nw_step_3
nw_pmos_3 = nw_step_3 INTERACT (NW INTERACT nw_pmos_3_bad)
nw_step_4 = SIZE nw_pmos_3 BY 5 INSIDE OF NW STEP LU_Well_STEP TRUNCATE LU_Well_STEP
nw_pmos_4_bad = nw_step_i NOT INSIDE nw_step_4
nw_pmos_4 = nw_step_4 INTERACT (NW INTERACT nw_pmos_4_bad)

nw_step_5 = SIZE nw_pmos_4 BY 5 INSIDE OF NW STEP LU_Well_STEP TRUNCATE LU_Well_STEP
nw_pmos_5_bad = nw_step_i NOT INSIDE nw_step_5
nw_pmos_5 = nw_step_5 INTERACT (NW INTERACT nw_pmos_5_bad)
nw_step_6 = SIZE nw_pmos_5 BY 5 INSIDE OF NW STEP LU_Well_STEP TRUNCATE LU_Well_STEP
nw_pmos_6_bad = nw_step_i NOT INSIDE nw_step_6
nw_pmos_6 = nw_step_6 INTERACT (NW INTERACT nw_pmos_6_bad)

nw_step_7 = SIZE nw_pmos_6 BY 5 INSIDE OF NW STEP LU_Well_STEP TRUNCATE LU_Well_STEP
nw_pmos_7_bad = nw_step_i NOT INSIDE nw_step_7
nw_pmos_7 = nw_step_7 INTERACT (NW INTERACT nw_pmos_7_bad)
nw_step_8 = SIZE nw_pmos_7 BY 5 INSIDE OF NW STEP LU_Well_STEP TRUNCATE LU_Well_STEP
nw_pmos_8_bad = nw_step_i NOT INSIDE nw_step_8
nw_pmos_8 = nw_step_8 INTERACT (NW INTERACT nw_pmos_8_bad)

nw_step_9 = SIZE nw_pmos_8 BY 5 INSIDE OF NW STEP LU_Well_STEP TRUNCATE LU_Well_STEP
nw_pmos_9_bad = nw_step_i NOT INSIDE nw_step_9
nw_pmos_9 = nw_step_9 INTERACT (NW INTERACT nw_pmos_9_bad)
nw_step_0 = SIZE nw_pmos_9 BY 5 INSIDE OF NW STEP LU_Well_STEP TRUNCATE LU_Well_STEP

LU_5_G_NMOS {
@ Space from any point within the S/D region to the nearest pickup AA region inside the same well for I/O and internal circuits, except OCCDFH region <= 50um
 err1 = (pw_step_i NOT INSIDE OCCDFH) OUTSIDE EDGE (OR pw_step_1 pw_step_2 pw_step_3 pw_step_4 pw_step_5 pw_step_6 pw_step_7 pw_step_8 pw_step_9 pw_step_0)
 err1 NOT INSIDE EDGE OCCDFH
}

LU_5_G_PMOS {
@ Space from any point within the S/D region to the nearest pickup AA region inside the same well for I/O and internal circuits, except OCCDFH region <= 50um
 err1 = (nw_step_i NOT INSIDE OCCDFH) OUTSIDE EDGE (OR nw_step_1 nw_step_2 nw_step_3 nw_step_4 nw_step_5 nw_step_6 nw_step_7 nw_step_8 nw_step_9 nw_step_0)
 err1 NOT INSIDE EDGE OCCDFH
}

//;LU.6[NC] All the guard rings and pickups should be connected to VDD/VSS with low series resistance. Contacts and Vias should be used as many as possible
//;LU.6.2[NC] Additional NW and PW strap width of LU.1.1 >= 0.096um

//;lu.6.1 derivation:
pmos_io_pad_NTAP_gR = NTAP_gR_rings_all INTERACT PSD_io_pad_CHK
nmos_io_pad_PTAP_gR = PTAP_gR_rings_all INTERACT NSD_io_pad_CHK

LU_6_1_G {
@ Guard-ring width of LU.1 >= 0.192um
@ LU.6.5: DRC will recognize a complete guard-ring when AA space <= 0.576um and parallel run length >= 0.192um
 pmos_GR = NTAP_union_ring TOUCH pmos_io_pad_NTAP_gR
 nmos_GR = PTAP_union_ring TOUCH nmos_io_pad_PTAP_gR
 rdio_GR = NTAP_union_ring TOUCH NTAP_gR_en_RWDIO
 ndio_GR = PTAP_union_ring TOUCH PTAP_gR_en_NWDIO
 nvar_GR = PTAP_union_ring TOUCH PTAP_gR_en_NVART
 pvar_GR = NTAP_union_ring TOUCH NTAP_gR_en_PVART
 pmos_GR_inner_EDGE = NTAP_union_ring TOUCH EDGE pmos_io_pad_NTAP_gR
 nmos_GR_inner_EDGE = PTAP_union_ring TOUCH EDGE nmos_io_pad_PTAP_gR
 rdio_GR_inner_EDGE = NTAP_union_ring TOUCH EDGE NTAP_gR_en_RWDIO
 ndio_GR_inner_EDGE = PTAP_union_ring TOUCH EDGE PTAP_gR_en_NWDIO
 nvar_GR_inner_EDGE = PTAP_union_ring TOUCH EDGE PTAP_gR_en_NVART
 pvar_GR_inner_EDGE = NTAP_union_ring TOUCH EDGE NTAP_gR_en_PVART

 err1 = pmos_GR_inner_EDGE COIN EDGE (INT [pmos_GR] < 0.192 ABUT<90 SINGULAR)
 err2 = nmos_GR_inner_EDGE COIN EDGE (INT [nmos_GR] < 0.192 ABUT<90 SINGULAR)
 err3 = rdio_GR_inner_EDGE COIN EDGE (INT [rdio_GR] < 0.192 ABUT<90 SINGULAR)
 err4 = ndio_GR_inner_EDGE COIN EDGE (INT [ndio_GR] < 0.192 ABUT<90 SINGULAR)
 err5 = nvar_GR_inner_EDGE COIN EDGE (INT [nvar_GR] < 0.192 ABUT<90 SINGULAR)
 err6 = pvar_GR_inner_EDGE COIN EDGE (INT [pvar_GR] < 0.192 ABUT<90 SINGULAR)

 err1 NOT INSIDE EDGE LUWMK1_OCCDFH
 err2 NOT INSIDE EDGE LUWMK1_OCCDFH
 err3 NOT INSIDE EDGE LUWMK1_OCCDFH
 err4 NOT INSIDE EDGE LUWMK1_OCCDFH
 err5 NOT INSIDE EDGE LUWMK1_OCCDFH
 err6 NOT INSIDE EDGE LUWMK1_OCCDFH
}

//;lu.6.3 derivation: gR within 14um io pad
pmos_within_io_pad_NTAP_gR = NTAP_gR_rings_all INTERACT PACT_real_non_io_pad_within_io_pad_dev_SWELL_14
nmos_within_io_pad_PTAP_gR = PTAP_gR_rings_all INTERACT NACT_real_non_io_pad_within_io_pad_dev_SWELL_14

LU_6_3_G {
@ Guard-ring width of LU.2 >= 0.096um
@ LU.6.5: DRC will recognize a complete guard-ring when AA space <= 0.576um and parallel run length >= 0.192um
 pmos_GR = NTAP_union_ring TOUCH pmos_within_io_pad_NTAP_gR
 nmos_GR = PTAP_union_ring TOUCH nmos_within_io_pad_PTAP_gR
 pmos_GR_inner_EDGE = NTAP_union_ring TOUCH EDGE pmos_within_io_pad_NTAP_gR
 nmos_GR_inner_EDGE = PTAP_union_ring TOUCH EDGE nmos_within_io_pad_PTAP_gR

 err1 = pmos_GR_inner_EDGE COIN EDGE (INT [pmos_GR] < 0.096 ABUT<90 SINGULAR)
 err2 = nmos_GR_inner_EDGE COIN EDGE (INT [nmos_GR] < 0.096 ABUT<90 SINGULAR)

 err1 NOT INSIDE EDGE LUWMK1_OCCDFH
 err2 NOT INSIDE EDGE LUWMK1_OCCDFH
}

//;LU.6.4[NC] PW strap width of LU.3 >= 0.096um
//;LU.6.5 DRC will recognize a complete guard-ring when AA space <= 0.576um and parallel run length >= 0.192um

//;lu.8 derivation (based on LU.1/2/3)
N_intector_NMOS = (NSD_io_pad_CHK INTERACT LUAREA1) NOT LUWMK1_OCCDFH
N_intector_NMOS_gR_inner = PTAP_gR_en_NACT_RAW INTERACT N_intector_NMOS
N_intector_NMOS_gR_outer = (NTAP_gR_en_PACT_RAW INTERACT N_intector_NMOS) NOT ENCLOSE PSD

P_intector_PMOS = (PSD_io_pad_CHK INTERACT LUAREA1) NOT LUWMK1_OCCDFH
P_intector_PMOS_gR_inner = NTAP_gR_en_PACT_RAW INTERACT P_intector_PMOS
P_intector_PMOS_gR_outer = (PTAP_gR_en_NACT_RAW INTERACT P_intector_PMOS) NOT ENCLOSE NSD

P_intector_RWDIO = (PTAP_io_pad_RWDIO_CHK INTERACT LUAREA1) NOT LUWMK1_OCCDFH
P_intector_RWDIO_gR_inner = NTAP_gR_en_RWDIO INTERACT P_intector_RWDIO
P_intector_RWDIO_gR_outer = ((PTAP_gR_en_NACT_RAW INTERACT P_intector_RWDIO_gR_inner) INTERACT PTAP_io_pad_RWDIO_CHK) NOT ENCLOSE NSD

N_intector_NWDIO = (NTAP_io_pad_NWDIO_CHK INTERACT LUAREA1) NOT LUWMK1_OCCDFH
N_intector_NWDIO_gR_inner = PTAP_gR_en_NWDIO INTERACT N_intector_NWDIO
N_intector_NWDIO_gR_outer = ((NTAP_gR_en_PACT_RAW INTERACT N_intector_NWDIO_gR_inner) INTERACT NTAP_io_pad_NWDIO_CHK) NOT ENCLOSE PSD

P_intector_PVART = (PTAP_io_pad_PVART_CHK INTERACT LUAREA1) NOT LUWMK1_OCCDFH
P_intector_PVART_gR_inner = NTAP_gR_en_PVART INTERACT P_intector_PVART
P_intector_PVART_gR_outer = ((PTAP_gR_en_NACT_RAW INTERACT P_intector_PVART_gR_inner) INTERACT PTAP_io_pad_PVART_CHK) NOT ENCLOSE NSD

N_intector_NVART = (NTAP_io_pad_NVART_CHK INTERACT LUAREA1) NOT LUWMK1_OCCDFH
N_intector_NVART_gR_inner = PTAP_gR_en_NVART INTERACT N_intector_NVART
N_intector_NVART_gR_outer = ((NTAP_gR_en_PACT_RAW INTERACT N_intector_NVART_gR_inner) INTERACT NTAP_io_pad_NVART_CHK) NOT ENCLOSE PSD

LU_8_G_N_injector {
@ For Area I/O, AA injector must be surrounded by two guard rings with width >= 0.192um
@ That is:
@ N+ AA injector is surrounded by a P+ guard-ring, and this P+ guard-ring is surrounded by a N+ guard-ring
@ P+ AA injector is surrounded by a N+ guard-ring, and this N+ guard-ring is surrounded by a P+ guard-ring
 err1 = N_intector_NMOS NOT PTAP_gR_rings_all //;inner ring
 err2 = N_intector_NMOS NOT N_intector_NMOS_gR_outer //;outer ring
 err3 = N_intector_NWDIO NOT PTAP_gR_en_NWDIO
 err4 = N_intector_NWDIO NOT N_intector_NWDIO_gR_outer
 err5 = N_intector_NVART NOT PTAP_gR_en_NVART
 err6 = N_intector_NVART NOT N_intector_NVART_gR_outer

 err1 NOT INSIDE LUWMK1_OCCDFH
 err2 NOT INSIDE LUWMK1_OCCDFH
 err3 NOT INSIDE LUWMK1_OCCDFH
 err4 NOT INSIDE LUWMK1_OCCDFH
 err5 NOT INSIDE LUWMK1_OCCDFH
 err6 NOT INSIDE LUWMK1_OCCDFH
}

LU_8_G_N_injector_GuardRingMinWidth {
@ For Area I/O, AA injector must be surrounded by two guard rings with width >= 0.192um
@ That is:
@ N+ AA injector is surrounded by a P+ guard-ring, and this P+ guard-ring is surrounded by a N+ guard-ring
@ P+ AA injector is surrounded by a N+ guard-ring, and this N+ guard-ring is surrounded by a P+ guard-ring
@ //;DRC flag width < 0.192um
 nmos_GR_inner = PTAP_union_ring TOUCH N_intector_NMOS_gR_inner
 nmos_GR_outer = NTAP_union_ring TOUCH N_intector_NMOS_gR_outer
 ndio_GR_inner = PTAP_union_ring TOUCH N_intector_NWDIO_gR_inner
 ndio_GR_outer = NTAP_union_ring TOUCH N_intector_NWDIO_gR_outer
 nvar_GR_inner = PTAP_union_ring TOUCH N_intector_NVART_gR_inner
 nvar_GR_outer = NTAP_union_ring TOUCH N_intector_NVART_gR_outer
 nmos_GR_inner_inner_EDGE = PTAP_union_ring TOUCH EDGE N_intector_NMOS_gR_inner
 nmos_GR_outer_inner_EDGE = NTAP_union_ring TOUCH EDGE N_intector_NMOS_gR_outer
 ndio_GR_inner_inner_EDGE = PTAP_union_ring TOUCH EDGE N_intector_NWDIO_gR_inner
 ndio_GR_outer_inner_EDGE = NTAP_union_ring TOUCH EDGE N_intector_NWDIO_gR_outer
 nvar_GR_inner_inner_EDGE = PTAP_union_ring TOUCH EDGE N_intector_NVART_gR_inner
 nvar_GR_outer_inner_EDGE = NTAP_union_ring TOUCH EDGE N_intector_NVART_gR_outer

 err1 = nmos_GR_inner_inner_EDGE COIN EDGE (INT [nmos_GR_inner] < 0.192 ABUT<90 SINGULAR)
 err2 = nmos_GR_outer_inner_EDGE COIN EDGE (INT [nmos_GR_outer] < 0.192 ABUT<90 SINGULAR)
 err3 = ndio_GR_inner_inner_EDGE COIN EDGE (INT [ndio_GR_inner] < 0.192 ABUT<90 SINGULAR)
 err4 = ndio_GR_outer_inner_EDGE COIN EDGE (INT [ndio_GR_outer] < 0.192 ABUT<90 SINGULAR)
 err5 = nvar_GR_inner_inner_EDGE COIN EDGE (INT [nvar_GR_inner] < 0.192 ABUT<90 SINGULAR)
 err6 = nvar_GR_outer_inner_EDGE COIN EDGE (INT [nvar_GR_outer] < 0.192 ABUT<90 SINGULAR)

 err1 NOT INSIDE EDGE LUWMK1_OCCDFH
 err2 NOT INSIDE EDGE LUWMK1_OCCDFH
 err3 NOT INSIDE EDGE LUWMK1_OCCDFH
 err4 NOT INSIDE EDGE LUWMK1_OCCDFH
 err5 NOT INSIDE EDGE LUWMK1_OCCDFH
 err6 NOT INSIDE EDGE LUWMK1_OCCDFH
}

LU_8_G_P_injector {
@ For Area I/O, AA injector must be surrounded by two guard rings with width >= 0.192um
@ That is:
@ N+ AA injector is surrounded by a P+ guard-ring, and this P+ guard-ring is surrounded by a N+ guard-ring
@ P+ AA injector is surrounded by a N+ guard-ring, and this N+ guard-ring is surrounded by a P+ guard-ring
 err1 = P_intector_PMOS NOT NTAP_gR_rings_all
 err2 = P_intector_PMOS NOT P_intector_PMOS_gR_outer
 err3 = P_intector_RWDIO NOT NTAP_gR_en_RWDIO
 err4 = P_intector_RWDIO NOT P_intector_RWDIO_gR_outer
 err5 = P_intector_PVART NOT NTAP_gR_en_PVART
 err6 = P_intector_PVART NOT P_intector_PVART_gR_outer

 err1 NOT INSIDE LUWMK1_OCCDFH
 err2 NOT INSIDE LUWMK1_OCCDFH
 err3 NOT INSIDE LUWMK1_OCCDFH
 err4 NOT INSIDE LUWMK1_OCCDFH
 err5 NOT INSIDE LUWMK1_OCCDFH
 err6 NOT INSIDE LUWMK1_OCCDFH
}

LU_8_G_P_injector_GuardRingMinWidth {
@ For Area I/O, AA injector must be surrounded by two guard rings with width >= 0.192um
@ That is:
@ N+ AA injector is surrounded by a P+ guard-ring, and this P+ guard-ring is surrounded by a N+ guard-ring
@ P+ AA injector is surrounded by a N+ guard-ring, and this N+ guard-ring is surrounded by a P+ guard-ring
@ //;DRC flag width < 0.192um
 pmos_GR_inner = NTAP_union_ring TOUCH P_intector_PMOS_gR_inner
 pmos_GR_outer = PTAP_union_ring TOUCH P_intector_PMOS_gR_outer
 rdio_GR_inner = NTAP_union_ring TOUCH P_intector_RWDIO_gR_inner
 rdio_GR_outer = PTAP_union_ring TOUCH P_intector_RWDIO_gR_outer
 pvar_GR_inner = NTAP_union_ring TOUCH P_intector_PVART_gR_inner
 pvar_GR_outer = PTAP_union_ring TOUCH P_intector_PVART_gR_outer
 pmos_GR_inner_inner_EDGE = NTAP_union_ring TOUCH EDGE P_intector_PMOS_gR_inner
 pmos_GR_outer_inner_EDGE = PTAP_union_ring TOUCH EDGE P_intector_PMOS_gR_outer
 rdio_GR_inner_inner_EDGE = NTAP_union_ring TOUCH EDGE P_intector_RWDIO_gR_inner
 rdio_GR_outer_inner_EDGE = PTAP_union_ring TOUCH EDGE P_intector_RWDIO_gR_outer
 pvar_GR_inner_inner_EDGE = NTAP_union_ring TOUCH EDGE P_intector_PVART_gR_inner
 pvar_GR_outer_inner_EDGE = PTAP_union_ring TOUCH EDGE P_intector_PVART_gR_outer

 err1 = pmos_GR_inner_inner_EDGE COIN EDGE (INT [pmos_GR_inner] < 0.192 ABUT<90 SINGULAR)
 err2 = pmos_GR_outer_inner_EDGE COIN EDGE (INT [pmos_GR_outer] < 0.192 ABUT<90 SINGULAR)
 err3 = rdio_GR_inner_inner_EDGE COIN EDGE (INT [rdio_GR_inner] < 0.192 ABUT<90 SINGULAR)
 err4 = rdio_GR_outer_inner_EDGE COIN EDGE (INT [rdio_GR_outer] < 0.192 ABUT<90 SINGULAR)
 err5 = pvar_GR_inner_inner_EDGE COIN EDGE (INT [pvar_GR_inner] < 0.192 ABUT<90 SINGULAR)
 err6 = pvar_GR_outer_inner_EDGE COIN EDGE (INT [pvar_GR_outer] < 0.192 ABUT<90 SINGULAR)

 err1 NOT INSIDE EDGE LUWMK1_OCCDFH
 err2 NOT INSIDE EDGE LUWMK1_OCCDFH
 err3 NOT INSIDE EDGE LUWMK1_OCCDFH
 err4 NOT INSIDE EDGE LUWMK1_OCCDFH
 err5 NOT INSIDE EDGE LUWMK1_OCCDFH
 err6 NOT INSIDE EDGE LUWMK1_OCCDFH
}

//;lu.7~11 derivation
ACT_inject_io_pad_dev_waive = AREA (PNAA INTERACT AACT_io_pad_dev) < 5
ACT_inject_io_pad_dev = (AACT_io_pad_dev NOT ACT_inject_io_pad_dev_waive) INTERACT LUAREA1

#IFDEF LATCH_UP_CHECK_MODE ACCURATE
ACT_inject_io_pad_dev_58nm_SearchRange = SIZE ACT_inject_io_pad_dev BY 58 INSIDE OF DRC:1 STEP 12 BEVEL 3

ACT_nmos_Check = ACT_active_nmos_sd NOT ACT_inject_io_pad_dev
ACT_pmos_Check = ACT_active_pmos_sd NOT ACT_inject_io_pad_dev

ACT_nmos_within_io_pad_580 = ACT_nmos_Check INTERACT ACT_inject_io_pad_dev_58nm_SearchRange
ACT_pmos_within_io_pad_580 = ACT_pmos_Check INTERACT ACT_inject_io_pad_dev_58nm_SearchRange

ACT_nmos_within_2976_pmos_merged = SIZE ACT_nmos_within_io_pad_580 BY 2.976 OVERUNDER
ACT_pmos_within_2976_pmos_merged = SIZE ACT_pmos_within_io_pad_580 BY 2.976 OVERUNDER
ACT_nmos_within_2976_pmos_SearchRange = (SIZE ACT_nmos_within_2976_pmos_merged BY 2.976-0.001 BEVEL 4) NOT ACT_nmos_within_2976_pmos_merged
ACT_pmos_within_2976_nmos_SearchRange = (SIZE ACT_pmos_within_2976_pmos_merged BY 2.976-0.001 BEVEL 4) NOT ACT_pmos_within_2976_pmos_merged
#ENDIF

#IFDEF LATCH_UP_CHECK_MODE FAST
ACT_inject_io_pad_dev_58nm_SearchRange = SIZE ACT_inject_io_pad_dev BY 58 INSIDE OF DRC:1 STEP 12

ACT_nmos_Check = ACT_active_nmos_sd NOT ACT_inject_io_pad_dev
ACT_pmos_Check = ACT_active_pmos_sd NOT ACT_inject_io_pad_dev

ACT_nmos_within_io_pad_580 = ACT_nmos_Check INTERACT ACT_inject_io_pad_dev_58nm_SearchRange
ACT_pmos_within_io_pad_580 = ACT_pmos_Check INTERACT ACT_inject_io_pad_dev_58nm_SearchRange

ACT_nmos_within_2976_pmos_merged = SIZE ACT_nmos_within_io_pad_580 BY 2.976 OVERUNDER
ACT_pmos_within_2976_pmos_merged = SIZE ACT_pmos_within_io_pad_580 BY 2.976 OVERUNDER
ACT_nmos_within_2976_pmos_SearchRange = (SIZE ACT_nmos_within_2976_pmos_merged BY 2.976-0.001 BEVEL 3) NOT ACT_nmos_within_2976_pmos_merged
ACT_pmos_within_2976_nmos_SearchRange = (SIZE ACT_pmos_within_2976_pmos_merged BY 2.976-0.001 BEVEL 3) NOT ACT_pmos_within_2976_pmos_merged
#ENDIF

ACT_nact_within_io_pad_580 = ACT_nmos_within_io_pad_580 INTERACT ACT_pmos_within_2976_nmos_SearchRange
ACT_pact_within_io_pad_580 = ACT_pmos_within_io_pad_580 INTERACT ACT_nmos_within_2976_pmos_SearchRange

pw_step_5_lu_7_9 = OR pw_step_1 pw_step_2 pw_step_3 pw_step_4 (SIZE pw_nmos_4 BY 24.96-5*4 INSIDE OF PW_0 STEP LU_Well_STEP TRUNCATE LU_Well_STEP)
nw_step_5_lu_7_9 = OR nw_step_1 nw_step_2 nw_step_3 pw_step_4 (SIZE nw_pmos_4 BY 24.96-5*4 INSIDE OF NW STEP LU_Well_STEP TRUNCATE LU_Well_STEP)

LU_7_9_G_NMOS {
@ LU.7:
@ For Area I/O, within 58um of AA injector, LU.8~LU.11 should be followed except below conditions:
@ 1) AA injector area < 5um2
@ 2) For core circuits, space between N+ AA and P+ AA >= 2.976um
@ LU.9:
@ For Core devices:
@ Any point inside NMOS S/D space to the nearest PW strap in the same PW
@ Any point inside PMOS S/D space to the nearest NW strap in the same NW <= 24.96um
 err1 = (ACT_nmos_within_io_pad_580 AND DG) NOT pw_step_5_lu_7_9
 err2 = (ACT_nact_within_io_pad_580 NOT DG) NOT pw_step_5_lu_7_9

 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

LU_7_9_G_PMOS {
@ LU.7:
@ For Area I/O, within 58um of AA injector, LU.8~LU.11 should be followed except below conditions:
@ 1) AA injector area < 5um2
@ 2) For core circuits, space between N+ AA and P+ AA >= 2.976um
@ LU.9:
@ For Core devices:
@ Any point inside NMOS S/D space to the nearest PW strap in the same PW
@ Any point inside PMOS S/D space to the nearest NW strap in the same NW <= 24.96um
 err1 = (ACT_pmos_within_io_pad_580 AND DG) NOT nw_step_5_lu_7_9
 err2 = (ACT_pact_within_io_pad_580 NOT DG) NOT nw_step_5_lu_7_9

 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

nw_step_lu_10_11 = SIZE acti_NTAP BY 4.992 INSIDE OF NW STEP LU_Well_STEP TRUNCATE LU_Well_STEP
pw_step_lu_10_11 = SIZE acti_PTAP BY 4.992 INSIDE OF PW_0 STEP LU_Well_STEP TRUNCATE LU_Well_STEP

pmos_io = PSD AND DG
nmos_io = NSD AND DG
pmos_core = PSD NOT DG
nmos_core = NSD NOT DG
pmos_core_dv_105v = DFM PROPERTY pmos_core net_vol_assign NODAL MULTI [vol = (property(net_vol_assign, max_vol) > 1.05 || property(net_vol_assign, min_vol) < -1.05) ? 1 : 0] > 0

#IFDEF Delta_Voltage_Rules_Check YES
LU_10_G {
@ For Core devices with PMOS S/D voltage > 1.05V:
@ Any point inside NMOS S/D space to the nearest PW strap in the same PW
@ Any point inside PMOS S/D space to the nearest NW strap in the same NW <= 4.992um
//; Except condition:(1) AA injector area < 5um2; (2) For core circuits, space between N+ AA and P+ AA >= 2.976um
 psd_check = pmos_core INTERACT ACT_pact_within_io_pad_580
 nsd_check = nmos_core INTERACT ACT_nact_within_io_pad_580
 psd_check_105v = psd_check INTERACT pmos_core_dv_105v
#IFDEF LATCH_UP_CHECK_MODE ACCURATE
 nsd_check_105v = nsd_check INTERACT ((SIZE psd_check_105v BY 2.976 BEVEL 4) NOT psd_check_105v)
#ENDIF
#IFDEF LATCH_UP_CHECK_MODE FAST
 nsd_check_105v = nsd_check INTERACT ((SIZE psd_check_105v BY 2.976 BEVEL 3) NOT psd_check_105v)
#ENDIF
 err1 = psd_check_105v NOT nw_step_lu_10_11
 err2 = nsd_check_105v NOT pw_step_lu_10_11

 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}
#ENDIF

LU_11_G_NMOS {
@ For I/O devices:
@ Any point inside NMOS S/D space to the nearest PW strap in the same PW
@ Any point inside PMOS S/D space to the nearest NW strap in the same NW <= 4.992um
//;based on LU.7
 err1 = (ACT_nmos_within_io_pad_580 AND DG) NOT pw_step_lu_10_11
 err1 NOT INSIDE SealR_NOT_BULK
}

LU_11_G_PMOS {
@ For I/O devices:
@ Any point inside NMOS S/D space to the nearest PW strap in the same PW
@ Any point inside PMOS S/D space to the nearest NW strap in the same NW <= 4.992um
//;based on LU.7
 err1 = (ACT_pmos_within_io_pad_580 AND DG) NOT nw_step_lu_10_11
 err1 NOT INSIDE SealR_NOT_BULK
}

//;-------------------------------------------------------------#
//;Voltage Drop		Space between Anode and Cathode (um)	#
//;0V < Delta V <= 1V		0.96				#
//;1V < Delta V <= 1.32V		1.824			#
//;1.32V < Delta V <= 1.65V	2.112				#
//;1.65V < Delta V <= 1.98V	4.512				#
//;1.98V < Delta V <= 2.75V	7.968				#
//;2.75V < Delta V <= 3.63V	16.032				#
//;3.63V < Delta V <= 5.5V		35.952			#
//;-------------------------------------------------------------#

VARIABLE LU_0d0_To_1d0 0.96
VARIABLE LU_1d0_To_1d2 1.824
VARIABLE LU_1d2_To_1d5 2.112
VARIABLE LU_1d5_To_1d8 4.512
VARIABLE LU_1d8_To_2d5 7.968
VARIABLE LU_2d5_To_3d3 16.032
VARIABLE LU_3d3_To_5d0 35.952

PSD_power_pad_vol_gt_pos_115 = NET AREA RATIO PSD_power_pad_CHK AA_NETID_vol_gt_pos_1155 > 0
PSD_power_pad_vol_gt_pos_132 = NET AREA RATIO PSD_power_pad_CHK AA_NETID_vol_gt_pos_132 > 0
PSD_power_pad_vol_gt_pos_165 = NET AREA RATIO PSD_power_pad_CHK AA_NETID_vol_gt_pos_165 > 0
PSD_power_pad_vol_gt_pos_198 = NET AREA RATIO PSD_power_pad_CHK AA_NETID_vol_gt_pos_198 > 0
PSD_power_pad_vol_gt_pos_275 = NET AREA RATIO PSD_power_pad_CHK AA_NETID_vol_gt_pos_275 > 0
PSD_power_pad_vol_gt_pos_363 = NET AREA RATIO PSD_power_pad_CHK AA_NETID_vol_gt_pos_363 > 0

PAA_io_pad_vol_gt_pos_115 = NET AREA RATIO PAA_io_pad_CHK AA_NETID_vol_gt_pos_1155 > 0
PAA_io_pad_vol_gt_pos_132 = NET AREA RATIO PAA_io_pad_CHK AA_NETID_vol_gt_pos_132 > 0
PAA_io_pad_vol_gt_pos_165 = NET AREA RATIO PAA_io_pad_CHK AA_NETID_vol_gt_pos_165 > 0
PAA_io_pad_vol_gt_pos_198 = NET AREA RATIO PAA_io_pad_CHK AA_NETID_vol_gt_pos_198 > 0
PAA_io_pad_vol_gt_pos_275 = NET AREA RATIO PAA_io_pad_CHK AA_NETID_vol_gt_pos_275 > 0
PAA_io_pad_vol_gt_pos_363 = NET AREA RATIO PAA_io_pad_CHK AA_NETID_vol_gt_pos_363 > 0

PAA_io_pad_vol_pos_CHK_lc = AA_lc INTERACT PAA_io_pad_vol_pos_CHK
PAA_io_pad_vol_pos_115_CHK_lc = AA_lc INTERACT PAA_io_pad_vol_gt_pos_115
PAA_io_pad_vol_pos_132_CHK_lc = AA_lc INTERACT PAA_io_pad_vol_gt_pos_132
PAA_io_pad_vol_pos_165_CHK_lc = AA_lc INTERACT PAA_io_pad_vol_gt_pos_165
PAA_io_pad_vol_pos_198_CHK_lc = AA_lc INTERACT PAA_io_pad_vol_gt_pos_198
PAA_io_pad_vol_pos_275_CHK_lc = AA_lc INTERACT PAA_io_pad_vol_gt_pos_275
PAA_io_pad_vol_pos_363_CHK_lc = AA_lc INTERACT PAA_io_pad_vol_gt_pos_363

PAA_io_pad_CHK_lc = AA_lc INTERACT PAA_io_pad_CHK
NAA_io_pad_CHK_lc = AA_lc INTERACT NAA_io_pad_CHK
NAA_io_pad_vol_neg_CHK_lc = AA_lc INTERACT NAA_io_pad_vol_neg_CHK

NSD_power_pad_CHK_lc = AA_lc INTERACT NSD_power_pad_CHK
NSD_power_pad_vol_neg_CHK_lc = AA_lc INTERACT NSD_power_pad_vol_neg_CHK

VARIABLE LU_4_1_a_G_val LU_0d0_To_1d0
VARIABLE LU_4_1_b_G_val LU_1d0_To_1d2
VARIABLE LU_4_1_c_G_val LU_1d2_To_1d5
VARIABLE LU_4_1_d_G_val LU_1d5_To_1d8
VARIABLE LU_4_1_e_G_val LU_1d8_To_2d5
VARIABLE LU_4_1_f_G_val LU_2d5_To_3d3
VARIABLE LU_4_1_g_G_val LU_3d3_To_5d0
VARIABLE LU_4_2_a_G_val LU_0d0_To_1d0
VARIABLE LU_4_2_b_G_val LU_1d0_To_1d2
VARIABLE LU_4_2_c_G_val LU_1d2_To_1d5
VARIABLE LU_4_2_d_G_val LU_1d5_To_1d8
VARIABLE LU_4_2_e_G_val LU_1d8_To_2d5
VARIABLE LU_4_2_f_G_val LU_2d5_To_3d3
VARIABLE LU_4_2_g_G_val LU_3d3_To_5d0
VARIABLE LU_4_3_1a_G_val LU_0d0_To_1d0
VARIABLE LU_4_3_1b_G_val LU_0d0_To_1d0
VARIABLE LU_4_3_2a_G_val LU_1d0_To_1d2
VARIABLE LU_4_3_2b_G_val LU_1d0_To_1d2
VARIABLE LU_4_3_3a_G_val LU_1d2_To_1d5
VARIABLE LU_4_3_3b_G_val LU_1d2_To_1d5
VARIABLE LU_4_3_4a_G_val LU_1d5_To_1d8
VARIABLE LU_4_3_4b_G_val LU_1d5_To_1d8
VARIABLE LU_4_3_5a_G_val LU_1d8_To_2d5
VARIABLE LU_4_3_5b_G_val LU_1d8_To_2d5
VARIABLE LU_4_3_6a_G_val LU_2d5_To_3d3
VARIABLE LU_4_3_6b_G_val LU_2d5_To_3d3
VARIABLE LU_4_3_7a_G_val LU_3d3_To_5d0
VARIABLE LU_4_3_7b_G_val LU_3d3_To_5d0
VARIABLE LU_4_4_1a_G_val LU_0d0_To_1d0
VARIABLE LU_4_4_1b_G_val LU_0d0_To_1d0
VARIABLE LU_4_4_2a_G_val LU_1d0_To_1d2
VARIABLE LU_4_4_2b_G_val LU_1d0_To_1d2
VARIABLE LU_4_4_3a_G_val LU_1d2_To_1d5
VARIABLE LU_4_4_3b_G_val LU_1d2_To_1d5
VARIABLE LU_4_4_4a_G_val LU_1d5_To_1d8
VARIABLE LU_4_4_4b_G_val LU_1d5_To_1d8
VARIABLE LU_4_4_5a_G_val LU_1d8_To_2d5
VARIABLE LU_4_4_5b_G_val LU_1d8_To_2d5
VARIABLE LU_4_4_6a_G_val LU_2d5_To_3d3
VARIABLE LU_4_4_6b_G_val LU_2d5_To_3d3
VARIABLE LU_4_4_7a_G_val LU_3d3_To_5d0
VARIABLE LU_4_4_7b_G_val LU_3d3_To_5d0

#IFDEF Delta_Voltage_Rules_Check YES
LU_4_1_a_G {
@ LU.4.1: Space between IO Anode and IO Cathode when 0V < Delta V <= 1V. >= 0.96um
 err1_a = EXT PAA_io_pad_vol_pos_CHK_lc NAA_io_pad_CHK_lc < LU_4_1_a_G_val SINGULAR NOT CONNECTED
 err1_b = EXT NAA_io_pad_vol_neg_CHK_lc PAA_io_pad_CHK_lc < LU_4_1_a_G_val SINGULAR NOT CONNECTED
 err1_a_L = EXT [PAA_io_pad_vol_pos_CHK_lc] NAA_io_pad_CHK_lc < LU_4_1_a_G_val SINGULAR NOT CONNECTED
 err1_b_L = EXT [NAA_io_pad_vol_neg_CHK_lc] PAA_io_pad_CHK_lc < LU_4_1_a_G_val SINGULAR NOT CONNECTED
 err1_a_R = EXT PAA_io_pad_vol_pos_CHK_lc [NAA_io_pad_CHK_lc] < LU_4_1_a_G_val SINGULAR NOT CONNECTED
 err1_b_R = EXT NAA_io_pad_vol_neg_CHK_lc [PAA_io_pad_CHK_lc] < LU_4_1_a_G_val SINGULAR NOT CONNECTED
 err1_a_L_gC = AA_c COIN EDGE err1_a_L
 err1_b_L_gC = AA_c COIN EDGE err1_b_L
 err1_a_R_gC = AA_c COIN EDGE err1_a_R
 err1_b_R_gC = AA_c COIN EDGE err1_b_R

 err1_a_L_NETID = DFM PROPERTY err1_a_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_a_R_NETID = DFM PROPERTY err1_a_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1_b_L_NETID = DFM PROPERTY err1_b_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_b_R_NETID = DFM PROPERTY err1_b_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1 = DFM PROPERTY err1_a err1_a_L_NETID err1_a_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_a_L_NETID)]
 [NET_b = count(err1_a_R_NETID)]
 [VH_1a = property(err1_a_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_a_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_a_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_a_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 0 && property_ref(DT_vA) <= 1.155) || (property_ref(DT_vB) > 0 && property_ref(DT_vB) <= 1.155)) ? 1 : 0] > 0

 err2 = DFM PROPERTY err1_b err1_b_L_NETID err1_b_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_b_L_NETID)]
 [NET_b = count(err1_b_R_NETID)]
 [VH_1a = property(err1_b_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_b_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_b_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_b_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 0 && property_ref(DT_vA) <= 1.155) || (property_ref(DT_vB) > 0 && property_ref(DT_vB) <= 1.155)) ? 1 : 0] > 0

 DFM COPY err1 err2
}

LU_4_1_b_G {
@ LU.4.1: Space between IO Anode and IO Cathode when 1V < Delta V <= 1.32V. >= 1.824um
 err1_a = EXT PAA_io_pad_vol_pos_115_CHK_lc NAA_io_pad_CHK_lc < LU_4_1_b_G_val SINGULAR NOT CONNECTED
 err1_b = EXT NAA_io_pad_vol_neg_CHK_lc PAA_io_pad_CHK_lc < LU_4_1_b_G_val SINGULAR NOT CONNECTED
 err1_a_L = EXT [PAA_io_pad_vol_pos_115_CHK_lc] NAA_io_pad_CHK_lc < LU_4_1_b_G_val SINGULAR NOT CONNECTED
 err1_b_L = EXT [NAA_io_pad_vol_neg_CHK_lc] PAA_io_pad_CHK_lc < LU_4_1_b_G_val SINGULAR NOT CONNECTED
 err1_a_R = EXT PAA_io_pad_vol_pos_115_CHK_lc [NAA_io_pad_CHK_lc] < LU_4_1_b_G_val SINGULAR NOT CONNECTED
 err1_b_R = EXT NAA_io_pad_vol_neg_CHK_lc [PAA_io_pad_CHK_lc] < LU_4_1_b_G_val SINGULAR NOT CONNECTED
 err1_a_L_gC = AA_c COIN EDGE err1_a_L
 err1_b_L_gC = AA_c COIN EDGE err1_b_L
 err1_a_R_gC = AA_c COIN EDGE err1_a_R
 err1_b_R_gC = AA_c COIN EDGE err1_b_R

 err1_a_L_NETID = DFM PROPERTY err1_a_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_a_R_NETID = DFM PROPERTY err1_a_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1_b_L_NETID = DFM PROPERTY err1_b_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_b_R_NETID = DFM PROPERTY err1_b_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1 = DFM PROPERTY err1_a err1_a_L_NETID err1_a_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_a_L_NETID)]
 [NET_b = count(err1_a_R_NETID)]
 [VH_1a = property(err1_a_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_a_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_a_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_a_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 1.155 && property_ref(DT_vA) <= 1.32) || (property_ref(DT_vB) > 1.155 && property_ref(DT_vB) <= 1.32)) ? 1 : 0] > 0

 err2 = DFM PROPERTY err1_b err1_b_L_NETID err1_b_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_b_L_NETID)]
 [NET_b = count(err1_b_R_NETID)]
 [VH_1a = property(err1_b_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_b_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_b_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_b_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 1.155 && property_ref(DT_vA) <= 1.32) || (property_ref(DT_vB) > 1.155 && property_ref(DT_vB) <= 1.32)) ? 1 : 0] > 0

 DFM COPY err1 err2
}

LU_4_1_c_G {
@ LU.4.1: Space between IO Anode and IO Cathode when 1.32V < Delta V <= 1.65V. >= 2.112um
 err1_a = EXT PAA_io_pad_vol_pos_132_CHK_lc NAA_io_pad_CHK_lc < LU_4_1_c_G_val SINGULAR NOT CONNECTED
 err1_b = EXT NAA_io_pad_vol_neg_CHK_lc PAA_io_pad_CHK_lc < LU_4_1_c_G_val SINGULAR NOT CONNECTED
 err1_a_L = EXT [PAA_io_pad_vol_pos_132_CHK_lc] NAA_io_pad_CHK_lc < LU_4_1_c_G_val SINGULAR NOT CONNECTED
 err1_b_L = EXT [NAA_io_pad_vol_neg_CHK_lc] PAA_io_pad_CHK_lc < LU_4_1_c_G_val SINGULAR NOT CONNECTED
 err1_a_R = EXT PAA_io_pad_vol_pos_132_CHK_lc [NAA_io_pad_CHK_lc] < LU_4_1_c_G_val SINGULAR NOT CONNECTED
 err1_b_R = EXT NAA_io_pad_vol_neg_CHK_lc [PAA_io_pad_CHK_lc] < LU_4_1_c_G_val SINGULAR NOT CONNECTED
 err1_a_L_gC = AA_c COIN EDGE err1_a_L
 err1_b_L_gC = AA_c COIN EDGE err1_b_L
 err1_a_R_gC = AA_c COIN EDGE err1_a_R
 err1_b_R_gC = AA_c COIN EDGE err1_b_R

 err1_a_L_NETID = DFM PROPERTY err1_a_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_a_R_NETID = DFM PROPERTY err1_a_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1_b_L_NETID = DFM PROPERTY err1_b_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_b_R_NETID = DFM PROPERTY err1_b_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1 = DFM PROPERTY err1_a err1_a_L_NETID err1_a_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_a_L_NETID)]
 [NET_b = count(err1_a_R_NETID)]
 [VH_1a = property(err1_a_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_a_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_a_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_a_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 1.32 && property_ref(DT_vA) <= 1.65) || (property_ref(DT_vB) > 1.32 && property_ref(DT_vB) <= 1.65)) ? 1 : 0] > 0

 err2 = DFM PROPERTY err1_b err1_b_L_NETID err1_b_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_b_L_NETID)]
 [NET_b = count(err1_b_R_NETID)]
 [VH_1a = property(err1_b_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_b_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_b_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_b_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 1.32 && property_ref(DT_vA) <= 1.65) || (property_ref(DT_vB) > 1.32 && property_ref(DT_vB) <= 1.65)) ? 1 : 0] > 0

 DFM COPY err1 err2
}

LU_4_1_d_G {
@ LU.4.1: Space between IO Anode and IO Cathode when 1.65V < Delta V <= 1.98V. >= 4.512um
 err1_a = EXT PAA_io_pad_vol_pos_165_CHK_lc NAA_io_pad_CHK_lc < LU_4_1_d_G_val SINGULAR NOT CONNECTED
 err1_b = EXT NAA_io_pad_vol_neg_CHK_lc PAA_io_pad_CHK_lc < LU_4_1_d_G_val SINGULAR NOT CONNECTED
 err1_a_L = EXT [PAA_io_pad_vol_pos_165_CHK_lc] NAA_io_pad_CHK_lc < LU_4_1_d_G_val SINGULAR NOT CONNECTED
 err1_b_L = EXT [NAA_io_pad_vol_neg_CHK_lc] PAA_io_pad_CHK_lc < LU_4_1_d_G_val SINGULAR NOT CONNECTED
 err1_a_R = EXT PAA_io_pad_vol_pos_165_CHK_lc [NAA_io_pad_CHK_lc] < LU_4_1_d_G_val SINGULAR NOT CONNECTED
 err1_b_R = EXT NAA_io_pad_vol_neg_CHK_lc [PAA_io_pad_CHK_lc] < LU_4_1_d_G_val SINGULAR NOT CONNECTED
 err1_a_L_gC = AA_c COIN EDGE err1_a_L
 err1_b_L_gC = AA_c COIN EDGE err1_b_L
 err1_a_R_gC = AA_c COIN EDGE err1_a_R
 err1_b_R_gC = AA_c COIN EDGE err1_b_R

 err1_a_L_NETID = DFM PROPERTY err1_a_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_a_R_NETID = DFM PROPERTY err1_a_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1_b_L_NETID = DFM PROPERTY err1_b_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_b_R_NETID = DFM PROPERTY err1_b_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1 = DFM PROPERTY err1_a err1_a_L_NETID err1_a_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_a_L_NETID)]
 [NET_b = count(err1_a_R_NETID)]
 [VH_1a = property(err1_a_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_a_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_a_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_a_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 1.65 && property_ref(DT_vA) <= 1.98) || (property_ref(DT_vB) > 1.65 && property_ref(DT_vB) <= 1.98)) ? 1 : 0] > 0

 err2 = DFM PROPERTY err1_b err1_b_L_NETID err1_b_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_b_L_NETID)]
 [NET_b = count(err1_b_R_NETID)]
 [VH_1a = property(err1_b_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_b_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_b_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_b_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 1.65 && property_ref(DT_vA) <= 1.98) || (property_ref(DT_vB) > 1.65 && property_ref(DT_vB) <= 1.98)) ? 1 : 0] > 0

 DFM COPY err1 err2
}

LU_4_1_e_G {
@ LU.4.1: Space between IO Anode and IO Cathode when 1.98V < Delta V <= 2.75V. >= 7.968um
 err1_a = EXT PAA_io_pad_vol_pos_198_CHK_lc NAA_io_pad_CHK_lc < LU_4_1_e_G_val SINGULAR NOT CONNECTED
 err1_b = EXT NAA_io_pad_vol_neg_CHK_lc PAA_io_pad_CHK_lc < LU_4_1_e_G_val SINGULAR NOT CONNECTED
 err1_a_L = EXT [PAA_io_pad_vol_pos_198_CHK_lc] NAA_io_pad_CHK_lc < LU_4_1_e_G_val SINGULAR NOT CONNECTED
 err1_b_L = EXT [NAA_io_pad_vol_neg_CHK_lc] PAA_io_pad_CHK_lc < LU_4_1_e_G_val SINGULAR NOT CONNECTED
 err1_a_R = EXT PAA_io_pad_vol_pos_198_CHK_lc [NAA_io_pad_CHK_lc] < LU_4_1_e_G_val SINGULAR NOT CONNECTED
 err1_b_R = EXT NAA_io_pad_vol_neg_CHK_lc [PAA_io_pad_CHK_lc] < LU_4_1_e_G_val SINGULAR NOT CONNECTED
 err1_a_L_gC = AA_c COIN EDGE err1_a_L
 err1_b_L_gC = AA_c COIN EDGE err1_b_L
 err1_a_R_gC = AA_c COIN EDGE err1_a_R
 err1_b_R_gC = AA_c COIN EDGE err1_b_R

 err1_a_L_NETID = DFM PROPERTY err1_a_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_a_R_NETID = DFM PROPERTY err1_a_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1_b_L_NETID = DFM PROPERTY err1_b_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_b_R_NETID = DFM PROPERTY err1_b_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1 = DFM PROPERTY err1_a err1_a_L_NETID err1_a_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_a_L_NETID)]
 [NET_b = count(err1_a_R_NETID)]
 [VH_1a = property(err1_a_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_a_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_a_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_a_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 1.98 && property_ref(DT_vA) <= 2.75) || (property_ref(DT_vB) > 1.98 && property_ref(DT_vB) <= 2.75)) ? 1 : 0] > 0

 err2 = DFM PROPERTY err1_b err1_b_L_NETID err1_b_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_b_L_NETID)]
 [NET_b = count(err1_b_R_NETID)]
 [VH_1a = property(err1_b_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_b_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_b_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_b_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 1.98 && property_ref(DT_vA) <= 2.75) || (property_ref(DT_vB) > 1.98 && property_ref(DT_vB) <= 2.75)) ? 1 : 0] > 0

 DFM COPY err1 err2
}

LU_4_1_f_G {
@ LU.4.1: Space between IO Anode and IO Cathode when 2.75V < Delta V <= 3.63V. >= 16.032um
 err1_a = EXT PAA_io_pad_vol_pos_275_CHK_lc NAA_io_pad_CHK_lc < LU_4_1_f_G_val SINGULAR NOT CONNECTED
 err1_b = EXT NAA_io_pad_vol_neg_CHK_lc PAA_io_pad_CHK_lc < LU_4_1_f_G_val SINGULAR NOT CONNECTED
 err1_a_L = EXT [PAA_io_pad_vol_pos_275_CHK_lc] NAA_io_pad_CHK_lc < LU_4_1_f_G_val SINGULAR NOT CONNECTED
 err1_b_L = EXT [NAA_io_pad_vol_neg_CHK_lc] PAA_io_pad_CHK_lc < LU_4_1_f_G_val SINGULAR NOT CONNECTED
 err1_a_R = EXT PAA_io_pad_vol_pos_275_CHK_lc [NAA_io_pad_CHK_lc] < LU_4_1_f_G_val SINGULAR NOT CONNECTED
 err1_b_R = EXT NAA_io_pad_vol_neg_CHK_lc [PAA_io_pad_CHK_lc] < LU_4_1_f_G_val SINGULAR NOT CONNECTED
 err1_a_L_gC = AA_c COIN EDGE err1_a_L
 err1_b_L_gC = AA_c COIN EDGE err1_b_L
 err1_a_R_gC = AA_c COIN EDGE err1_a_R
 err1_b_R_gC = AA_c COIN EDGE err1_b_R

 err1_a_L_NETID = DFM PROPERTY err1_a_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_a_R_NETID = DFM PROPERTY err1_a_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1_b_L_NETID = DFM PROPERTY err1_b_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_b_R_NETID = DFM PROPERTY err1_b_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1 = DFM PROPERTY err1_a err1_a_L_NETID err1_a_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_a_L_NETID)]
 [NET_b = count(err1_a_R_NETID)]
 [VH_1a = property(err1_a_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_a_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_a_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_a_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 2.75 && property_ref(DT_vA) <= 3.63) || (property_ref(DT_vB) > 2.75 && property_ref(DT_vB) <= 3.63)) ? 1 : 0] > 0

 err2 = DFM PROPERTY err1_b err1_b_L_NETID err1_b_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_b_L_NETID)]
 [NET_b = count(err1_b_R_NETID)]
 [VH_1a = property(err1_b_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_b_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_b_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_b_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 2.75 && property_ref(DT_vA) <= 3.63) || (property_ref(DT_vB) > 2.75 && property_ref(DT_vB) <= 3.63)) ? 1 : 0] > 0

 DFM COPY err1 err2
}

LU_4_1_g_G {
@ LU.4.1: Space between IO Anode and IO Cathode when 3.63V < Delta V <= 5.5V. >= 35.952um
 err1_a = EXT PAA_io_pad_vol_pos_363_CHK_lc NAA_io_pad_CHK_lc < LU_4_1_g_G_val SINGULAR NOT CONNECTED
 err1_b = EXT NAA_io_pad_vol_neg_CHK_lc PAA_io_pad_CHK_lc < LU_4_1_g_G_val SINGULAR NOT CONNECTED
 err1_a_L = EXT [PAA_io_pad_vol_pos_363_CHK_lc] NAA_io_pad_CHK_lc < LU_4_1_g_G_val SINGULAR NOT CONNECTED
 err1_b_L = EXT [NAA_io_pad_vol_neg_CHK_lc] PAA_io_pad_CHK_lc < LU_4_1_g_G_val SINGULAR NOT CONNECTED
 err1_a_R = EXT PAA_io_pad_vol_pos_363_CHK_lc [NAA_io_pad_CHK_lc] < LU_4_1_g_G_val SINGULAR NOT CONNECTED
 err1_b_R = EXT NAA_io_pad_vol_neg_CHK_lc [PAA_io_pad_CHK_lc] < LU_4_1_g_G_val SINGULAR NOT CONNECTED
 err1_a_L_gC = AA_c COIN EDGE err1_a_L
 err1_b_L_gC = AA_c COIN EDGE err1_b_L
 err1_a_R_gC = AA_c COIN EDGE err1_a_R
 err1_b_R_gC = AA_c COIN EDGE err1_b_R

 err1_a_L_NETID = DFM PROPERTY err1_a_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_a_R_NETID = DFM PROPERTY err1_a_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1_b_L_NETID = DFM PROPERTY err1_b_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_b_R_NETID = DFM PROPERTY err1_b_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1 = DFM PROPERTY err1_a err1_a_L_NETID err1_a_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_a_L_NETID)]
 [NET_b = count(err1_a_R_NETID)]
 [VH_1a = property(err1_a_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_a_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_a_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_a_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 3.63 && property_ref(DT_vA) <= 5.5) || (property_ref(DT_vB) > 3.63 && property_ref(DT_vB) <= 5.5)) ? 1 : 0] > 0

 err2 = DFM PROPERTY err1_b err1_b_L_NETID err1_b_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_b_L_NETID)]
 [NET_b = count(err1_b_R_NETID)]
 [VH_1a = property(err1_b_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_b_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_b_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_b_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 3.63 && property_ref(DT_vA) <= 5.5) || (property_ref(DT_vB) > 3.63 && property_ref(DT_vB) <= 5.5)) ? 1 : 0] > 0

 DFM COPY err1 err2
}

LU_4_2_a_G {
@ LU.4.2: Space between IO Anode and Power Cathode when 0V < Delta V <= 1V. >= 0.96um
@ The following case can be excluded:
@ NMOS is inside DNW, and this DNW does not physically interact with PMOS NW. At the same time, voltage of the DNW >= voltage of PMOS NW
 err1_a = EXT PAA_io_pad_vol_pos_CHK_lc NSD_power_pad_CHK_lc < LU_4_2_a_G_val SINGULAR NOT CONNECTED  //;IO + and Power -
 err1_b = EXT PAA_io_pad_CHK_lc NSD_power_pad_vol_neg_CHK_lc < LU_4_2_a_G_val SINGULAR NOT CONNECTED  //;IO + and Power -
 err1_a_L = EXT [PAA_io_pad_vol_pos_CHK_lc] NSD_power_pad_CHK_lc < LU_4_2_a_G_val SINGULAR NOT CONNECTED
 err1_b_L = EXT [PAA_io_pad_CHK_lc] NSD_power_pad_vol_neg_CHK_lc < LU_4_2_a_G_val SINGULAR NOT CONNECTED
 err1_a_R = EXT PAA_io_pad_vol_pos_CHK_lc [NSD_power_pad_CHK_lc] < LU_4_2_a_G_val SINGULAR NOT CONNECTED
 err1_b_R = EXT PAA_io_pad_CHK_lc [NSD_power_pad_vol_neg_CHK_lc] < LU_4_2_a_G_val SINGULAR NOT CONNECTED
 err1_a_L_gC = AA_c COIN EDGE err1_a_L
 err1_b_L_gC = AA_c COIN EDGE err1_b_L
 err1_a_R_gC = AA_c COIN EDGE err1_a_R
 err1_b_R_gC = AA_c COIN EDGE err1_b_R

 err1_a_L_NETID = DFM PROPERTY err1_a_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_a_R_NETID = DFM PROPERTY err1_a_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1_b_L_NETID = DFM PROPERTY err1_b_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_b_R_NETID = DFM PROPERTY err1_b_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1 = DFM PROPERTY err1_a err1_a_L_NETID err1_a_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_a_L_NETID)]
 [NET_b = count(err1_a_R_NETID)]
 [VH_1a = property(err1_a_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_a_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_a_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_a_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 0 && property_ref(DT_vA) <= 1.155) || (property_ref(DT_vB) > 0 && property_ref(DT_vB) <= 1.155)) ? 1 : 0] > 0

 err2 = DFM PROPERTY err1_b err1_b_L_NETID err1_b_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_b_L_NETID)]
 [NET_b = count(err1_b_R_NETID)]
 [VH_1a = property(err1_b_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_b_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_b_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_b_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 0 && property_ref(DT_vA) <= 1.155) || (property_ref(DT_vB) > 0 && property_ref(DT_vB) <= 1.155)) ? 1 : 0] > 0

 DFM COPY err1 err2
}

LU_4_2_b_G {
@ LU.4.2: Space between IO Anode and Power Cathode when 1V < Delta V <= 1.32V. >= 1.824um
@ The following case can be excluded:
@ NMOS is inside DNW, and this DNW does not physically interact with PMOS NW. At the same time, voltage of the DNW >= voltage of PMOS NW
 err1_a = EXT PAA_io_pad_vol_pos_115_CHK_lc NSD_power_pad_CHK_lc < LU_4_2_b_G_val SINGULAR NOT CONNECTED
 err1_b = EXT PAA_io_pad_CHK_lc NSD_power_pad_vol_neg_CHK_lc < LU_4_2_b_G_val SINGULAR NOT CONNECTED
 err1_a_L = EXT [PAA_io_pad_vol_pos_115_CHK_lc] NSD_power_pad_CHK_lc < LU_4_2_b_G_val SINGULAR NOT CONNECTED
 err1_b_L = EXT [PAA_io_pad_CHK_lc] NSD_power_pad_vol_neg_CHK_lc < LU_4_2_b_G_val SINGULAR NOT CONNECTED
 err1_a_R = EXT PAA_io_pad_vol_pos_115_CHK_lc [NSD_power_pad_CHK_lc] < LU_4_2_b_G_val SINGULAR NOT CONNECTED
 err1_b_R = EXT PAA_io_pad_CHK_lc [NSD_power_pad_vol_neg_CHK_lc] < LU_4_2_b_G_val SINGULAR NOT CONNECTED
 err1_a_L_gC = AA_c COIN EDGE err1_a_L
 err1_b_L_gC = AA_c COIN EDGE err1_b_L
 err1_a_R_gC = AA_c COIN EDGE err1_a_R
 err1_b_R_gC = AA_c COIN EDGE err1_b_R

 err1_a_L_NETID = DFM PROPERTY err1_a_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_a_R_NETID = DFM PROPERTY err1_a_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1_b_L_NETID = DFM PROPERTY err1_b_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_b_R_NETID = DFM PROPERTY err1_b_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1 = DFM PROPERTY err1_a err1_a_L_NETID err1_a_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_a_L_NETID)]
 [NET_b = count(err1_a_R_NETID)]
 [VH_1a = property(err1_a_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_a_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_a_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_a_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 1.155 && property_ref(DT_vA) <= 1.32) || (property_ref(DT_vB) > 1.155 && property_ref(DT_vB) <= 1.32)) ? 1 : 0] > 0

 err2 = DFM PROPERTY err1_b err1_b_L_NETID err1_b_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_b_L_NETID)]
 [NET_b = count(err1_b_R_NETID)]
 [VH_1a = property(err1_b_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_b_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_b_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_b_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 1.155 && property_ref(DT_vA) <= 1.32) || (property_ref(DT_vB) > 1.155 && property_ref(DT_vB) <= 1.32)) ? 1 : 0] > 0

 DFM COPY err1 err2
}

LU_4_2_c_G {
@ LU.4.2: Space between IO Anode and Power Cathode when 1.32V < Delta V <= 1.65V. >= 2.112um
@ The following case can be excluded:
@ NMOS is inside DNW, and this DNW does not physically interact with PMOS NW. At the same time, voltage of the DNW >= voltage of PMOS NW
 err1_a = EXT PAA_io_pad_vol_pos_132_CHK_lc NSD_power_pad_CHK_lc < LU_4_2_c_G_val SINGULAR NOT CONNECTED
 err1_b = EXT PAA_io_pad_CHK_lc NSD_power_pad_vol_neg_CHK_lc < LU_4_2_c_G_val SINGULAR NOT CONNECTED
 err1_a_L = EXT [PAA_io_pad_vol_pos_132_CHK_lc] NSD_power_pad_CHK_lc < LU_4_2_c_G_val SINGULAR NOT CONNECTED
 err1_b_L = EXT [PAA_io_pad_CHK_lc] NSD_power_pad_vol_neg_CHK_lc < LU_4_2_c_G_val SINGULAR NOT CONNECTED
 err1_a_R = EXT PAA_io_pad_vol_pos_132_CHK_lc [NSD_power_pad_CHK_lc] < LU_4_2_c_G_val SINGULAR NOT CONNECTED
 err1_b_R = EXT PAA_io_pad_CHK_lc [NSD_power_pad_vol_neg_CHK_lc] < LU_4_2_c_G_val SINGULAR NOT CONNECTED
 err1_a_L_gC = AA_c COIN EDGE err1_a_L
 err1_b_L_gC = AA_c COIN EDGE err1_b_L
 err1_a_R_gC = AA_c COIN EDGE err1_a_R
 err1_b_R_gC = AA_c COIN EDGE err1_b_R

 err1_a_L_NETID = DFM PROPERTY err1_a_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_a_R_NETID = DFM PROPERTY err1_a_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1_b_L_NETID = DFM PROPERTY err1_b_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_b_R_NETID = DFM PROPERTY err1_b_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1 = DFM PROPERTY err1_a err1_a_L_NETID err1_a_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_a_L_NETID)]
 [NET_b = count(err1_a_R_NETID)]
 [VH_1a = property(err1_a_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_a_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_a_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_a_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 1.32 && property_ref(DT_vA) <= 1.65) || (property_ref(DT_vB) > 1.32 && property_ref(DT_vB) <= 1.65)) ? 1 : 0] > 0

 err2 = DFM PROPERTY err1_b err1_b_L_NETID err1_b_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_b_L_NETID)]
 [NET_b = count(err1_b_R_NETID)]
 [VH_1a = property(err1_b_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_b_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_b_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_b_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 1.32 && property_ref(DT_vA) <= 1.65) || (property_ref(DT_vB) > 1.32 && property_ref(DT_vB) <= 1.65)) ? 1 : 0] > 0

 DFM COPY err1 err2
}

LU_4_2_d_G {
@ LU.4.2: Space between IO Anode and Power Cathode when 1.65V < Delta V <= 1.98V. >= 4.512um
@ The following case can be excluded:
@ NMOS is inside DNW, and this DNW does not physically interact with PMOS NW. At the same time, voltage of the DNW >= voltage of PMOS NW
 err1_a = EXT PAA_io_pad_vol_pos_165_CHK_lc NSD_power_pad_CHK_lc < LU_4_2_d_G_val SINGULAR NOT CONNECTED
 err1_b = EXT PAA_io_pad_CHK_lc NSD_power_pad_vol_neg_CHK_lc < LU_4_2_d_G_val SINGULAR NOT CONNECTED
 err1_a_L = EXT [PAA_io_pad_vol_pos_165_CHK_lc] NSD_power_pad_CHK_lc < LU_4_2_d_G_val SINGULAR NOT CONNECTED
 err1_b_L = EXT [PAA_io_pad_CHK_lc] NSD_power_pad_vol_neg_CHK_lc < LU_4_2_d_G_val SINGULAR NOT CONNECTED
 err1_a_R = EXT PAA_io_pad_vol_pos_165_CHK_lc [NSD_power_pad_CHK_lc] < LU_4_2_d_G_val SINGULAR NOT CONNECTED
 err1_b_R = EXT PAA_io_pad_CHK_lc [NSD_power_pad_vol_neg_CHK_lc] < LU_4_2_d_G_val SINGULAR NOT CONNECTED
 err1_a_L_gC = AA_c COIN EDGE err1_a_L
 err1_b_L_gC = AA_c COIN EDGE err1_b_L
 err1_a_R_gC = AA_c COIN EDGE err1_a_R
 err1_b_R_gC = AA_c COIN EDGE err1_b_R

 err1_a_L_NETID = DFM PROPERTY err1_a_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_a_R_NETID = DFM PROPERTY err1_a_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1_b_L_NETID = DFM PROPERTY err1_b_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_b_R_NETID = DFM PROPERTY err1_b_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1 = DFM PROPERTY err1_a err1_a_L_NETID err1_a_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_a_L_NETID)]
 [NET_b = count(err1_a_R_NETID)]
 [VH_1a = property(err1_a_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_a_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_a_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_a_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 1.65 && property_ref(DT_vA) <= 1.98) || (property_ref(DT_vB) > 1.65 && property_ref(DT_vB) <= 1.98)) ? 1 : 0] > 0

 err2 = DFM PROPERTY err1_b err1_b_L_NETID err1_b_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_b_L_NETID)]
 [NET_b = count(err1_b_R_NETID)]
 [VH_1a = property(err1_b_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_b_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_b_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_b_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 1.65 && property_ref(DT_vA) <= 1.98) || (property_ref(DT_vB) > 1.65 && property_ref(DT_vB) <= 1.98)) ? 1 : 0] > 0

 DFM COPY err1 err2
}

LU_4_2_e_G {
@ LU.4.2: Space between IO Anode and Power Cathode when 1.98V < Delta V <= 2.75V. >= 7.968um
@ The following case can be excluded:
@ NMOS is inside DNW, and this DNW does not physically interact with PMOS NW. At the same time, voltage of the DNW >= voltage of PMOS NW
 err1_a = EXT PAA_io_pad_vol_pos_198_CHK_lc NSD_power_pad_CHK_lc < LU_4_2_e_G_val SINGULAR NOT CONNECTED
 err1_b = EXT PAA_io_pad_CHK_lc NSD_power_pad_vol_neg_CHK_lc < LU_4_2_e_G_val SINGULAR NOT CONNECTED
 err1_a_L = EXT [PAA_io_pad_vol_pos_198_CHK_lc] NSD_power_pad_CHK_lc < LU_4_2_e_G_val SINGULAR NOT CONNECTED
 err1_b_L = EXT [PAA_io_pad_CHK_lc] NSD_power_pad_vol_neg_CHK_lc < LU_4_2_e_G_val SINGULAR NOT CONNECTED
 err1_a_R = EXT PAA_io_pad_vol_pos_198_CHK_lc [NSD_power_pad_CHK_lc] < LU_4_2_e_G_val SINGULAR NOT CONNECTED
 err1_b_R = EXT PAA_io_pad_CHK_lc [NSD_power_pad_vol_neg_CHK_lc] < LU_4_2_e_G_val SINGULAR NOT CONNECTED
 err1_a_L_gC = AA_c COIN EDGE err1_a_L
 err1_b_L_gC = AA_c COIN EDGE err1_b_L
 err1_a_R_gC = AA_c COIN EDGE err1_a_R
 err1_b_R_gC = AA_c COIN EDGE err1_b_R

 err1_a_L_NETID = DFM PROPERTY err1_a_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_a_R_NETID = DFM PROPERTY err1_a_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1_b_L_NETID = DFM PROPERTY err1_b_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_b_R_NETID = DFM PROPERTY err1_b_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1 = DFM PROPERTY err1_a err1_a_L_NETID err1_a_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_a_L_NETID)]
 [NET_b = count(err1_a_R_NETID)]
 [VH_1a = property(err1_a_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_a_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_a_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_a_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 1.98 && property_ref(DT_vA) <= 2.75) || (property_ref(DT_vB) > 1.98 && property_ref(DT_vB) <= 2.75)) ? 1 : 0] > 0

 err2 = DFM PROPERTY err1_b err1_b_L_NETID err1_b_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_b_L_NETID)]
 [NET_b = count(err1_b_R_NETID)]
 [VH_1a = property(err1_b_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_b_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_b_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_b_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 1.98 && property_ref(DT_vA) <= 2.75) || (property_ref(DT_vB) > 1.98 && property_ref(DT_vB) <= 2.75)) ? 1 : 0] > 0

 DFM COPY err1 err2
}

LU_4_2_f_G {
@ LU.4.2: Space between IO Anode and Power Cathode when 2.75V < Delta V <= 3.63V. >= 16.032um
@ The following case can be excluded:
@ NMOS is inside DNW, and this DNW does not physically interact with PMOS NW. At the same time, voltage of the DNW >= voltage of PMOS NW
 err1_a = EXT PAA_io_pad_vol_pos_275_CHK_lc NSD_power_pad_CHK_lc < LU_4_2_f_G_val SINGULAR NOT CONNECTED
 err1_b = EXT PAA_io_pad_CHK_lc NSD_power_pad_vol_neg_CHK_lc < LU_4_2_f_G_val SINGULAR NOT CONNECTED
 err1_a_L = EXT [PAA_io_pad_vol_pos_275_CHK_lc] NSD_power_pad_CHK_lc < LU_4_2_f_G_val SINGULAR NOT CONNECTED
 err1_b_L = EXT [PAA_io_pad_CHK_lc] NSD_power_pad_vol_neg_CHK_lc < LU_4_2_f_G_val SINGULAR NOT CONNECTED
 err1_a_R = EXT PAA_io_pad_vol_pos_275_CHK_lc [NSD_power_pad_CHK_lc] < LU_4_2_f_G_val SINGULAR NOT CONNECTED
 err1_b_R = EXT PAA_io_pad_CHK_lc [NSD_power_pad_vol_neg_CHK_lc] < LU_4_2_f_G_val SINGULAR NOT CONNECTED
 err1_a_L_gC = AA_c COIN EDGE err1_a_L
 err1_b_L_gC = AA_c COIN EDGE err1_b_L
 err1_a_R_gC = AA_c COIN EDGE err1_a_R
 err1_b_R_gC = AA_c COIN EDGE err1_b_R

 err1_a_L_NETID = DFM PROPERTY err1_a_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_a_R_NETID = DFM PROPERTY err1_a_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1_b_L_NETID = DFM PROPERTY err1_b_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_b_R_NETID = DFM PROPERTY err1_b_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1 = DFM PROPERTY err1_a err1_a_L_NETID err1_a_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_a_L_NETID)]
 [NET_b = count(err1_a_R_NETID)]
 [VH_1a = property(err1_a_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_a_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_a_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_a_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 2.75 && property_ref(DT_vA) <= 3.63) || (property_ref(DT_vB) > 2.75 && property_ref(DT_vB) <= 3.63)) ? 1 : 0] > 0

 err2 = DFM PROPERTY err1_b err1_b_L_NETID err1_b_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_b_L_NETID)]
 [NET_b = count(err1_b_R_NETID)]
 [VH_1a = property(err1_b_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_b_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_b_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_b_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 2.75 && property_ref(DT_vA) <= 3.63) || (property_ref(DT_vB) > 2.75 && property_ref(DT_vB) <= 3.63)) ? 1 : 0] > 0

 DFM COPY err1 err2
}

LU_4_2_g_G {
@ LU.4.2: Space between IO Anode and Power Cathode when 3.63V < Delta V <= 5.5V. >= 35.952um
@ The following case can be excluded:
@ NMOS is inside DNW, and this DNW does not physically interact with PMOS NW. At the same time, voltage of the DNW >= voltage of PMOS NW
 err1_a = EXT PAA_io_pad_vol_pos_363_CHK_lc NSD_power_pad_CHK_lc < LU_4_2_g_G_val SINGULAR NOT CONNECTED
 err1_b = EXT PAA_io_pad_CHK_lc NSD_power_pad_vol_neg_CHK_lc < LU_4_2_g_G_val SINGULAR NOT CONNECTED
 err1_a_L = EXT [PAA_io_pad_vol_pos_363_CHK_lc] NSD_power_pad_CHK_lc < LU_4_2_g_G_val SINGULAR NOT CONNECTED
 err1_b_L = EXT [PAA_io_pad_CHK_lc] NSD_power_pad_vol_neg_CHK_lc < LU_4_2_g_G_val SINGULAR NOT CONNECTED
 err1_a_R = EXT PAA_io_pad_vol_pos_363_CHK_lc [NSD_power_pad_CHK_lc] < LU_4_2_g_G_val SINGULAR NOT CONNECTED
 err1_b_R = EXT PAA_io_pad_CHK_lc [NSD_power_pad_vol_neg_CHK_lc] < LU_4_2_g_G_val SINGULAR NOT CONNECTED
 err1_a_L_gC = AA_c COIN EDGE err1_a_L
 err1_b_L_gC = AA_c COIN EDGE err1_b_L
 err1_a_R_gC = AA_c COIN EDGE err1_a_R
 err1_b_R_gC = AA_c COIN EDGE err1_b_R

 err1_a_L_NETID = DFM PROPERTY err1_a_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_a_R_NETID = DFM PROPERTY err1_a_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1_b_L_NETID = DFM PROPERTY err1_b_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_b_R_NETID = DFM PROPERTY err1_b_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1 = DFM PROPERTY err1_a err1_a_L_NETID err1_a_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_a_L_NETID)]
 [NET_b = count(err1_a_R_NETID)]
 [VH_1a = property(err1_a_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_a_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_a_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_a_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 3.63 && property_ref(DT_vA) <= 5.5) || (property_ref(DT_vB) > 3.63 && property_ref(DT_vB) <= 5.5)) ? 1 : 0] > 0

 err2 = DFM PROPERTY err1_b err1_b_L_NETID err1_b_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_b_L_NETID)]
 [NET_b = count(err1_b_R_NETID)]
 [VH_1a = property(err1_b_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_b_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_b_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_b_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 3.63 && property_ref(DT_vA) <= 5.5) || (property_ref(DT_vB) > 3.63 && property_ref(DT_vB) <= 5.5)) ? 1 : 0] > 0

 DFM COPY err1 err2
}

//;For lu.4.3
RW_io_pad_vol_gt_pos_115_CHK = NET AREA RATIO RW_io_pad_CHK PW_NETID_vol_gt_pos_1155 > 0
RW_io_pad_vol_gt_pos_132_CHK = NET AREA RATIO RW_io_pad_CHK PW_NETID_vol_gt_pos_132 > 0
RW_io_pad_vol_gt_pos_165_CHK = NET AREA RATIO RW_io_pad_CHK PW_NETID_vol_gt_pos_165 > 0
RW_io_pad_vol_gt_pos_198_CHK = NET AREA RATIO RW_io_pad_CHK PW_NETID_vol_gt_pos_198 > 0
RW_io_pad_vol_gt_pos_275_CHK = NET AREA RATIO RW_io_pad_CHK PW_NETID_vol_gt_pos_275 > 0
RW_io_pad_vol_gt_pos_363_CHK = NET AREA RATIO RW_io_pad_CHK PW_NETID_vol_gt_pos_363 > 0

RW_io_pad_CHK_lc = RW_lc INTERACT RW_io_pad_CHK
RW_io_pad_vol_pos_CHK_lc = RW_lc INTERACT RW_io_pad_vol_pos_CHK
RW_io_pad_vol_gt_pos_115_CHK_lc = RW_lc INTERACT RW_io_pad_vol_gt_pos_115_CHK
RW_io_pad_vol_gt_pos_132_CHK_lc = RW_lc INTERACT RW_io_pad_vol_gt_pos_132_CHK
RW_io_pad_vol_gt_pos_165_CHK_lc = RW_lc INTERACT RW_io_pad_vol_gt_pos_165_CHK
RW_io_pad_vol_gt_pos_198_CHK_lc = RW_lc INTERACT RW_io_pad_vol_gt_pos_198_CHK
RW_io_pad_vol_gt_pos_275_CHK_lc = RW_lc INTERACT RW_io_pad_vol_gt_pos_275_CHK
RW_io_pad_vol_gt_pos_363_CHK_lc = RW_lc INTERACT RW_io_pad_vol_gt_pos_363_CHK

NW_io_pad_CHK_lc = NW_lc INTERACT NW_io_pad_CHK
NW_io_pad_vol_neg_CHK_lc = NW_lc INTERACT NW_io_pad_vol_neg_CHK

LU_4_3_1a_G {
@ LU.4.3: Space between IO Anode and IO NW Cathode, IO (PW in DNW) Anode and IO Cathode when 0V < Delta V <= 1V. >= 0.96um
@ Check between IO Anode and IO NW Cathode
 err1_a = EXT PAA_io_pad_vol_pos_CHK_lc NW_io_pad_CHK_lc < LU_4_3_1a_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b = EXT PAA_io_pad_CHK_lc NW_io_pad_vol_neg_CHK_lc < LU_4_3_1a_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_L = EXT [PAA_io_pad_vol_pos_CHK_lc] NW_io_pad_CHK_lc < LU_4_3_1a_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b_L = EXT [PAA_io_pad_CHK_lc] NW_io_pad_vol_neg_CHK_lc < LU_4_3_1a_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_R = EXT PAA_io_pad_vol_pos_CHK_lc [NW_io_pad_CHK_lc] < LU_4_3_1a_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b_R = EXT PAA_io_pad_CHK_lc [NW_io_pad_vol_neg_CHK_lc] < LU_4_3_1a_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_L_gC = AA_c COIN EDGE err1_a_L
 err1_b_L_gC = AA_c COIN EDGE err1_b_L
 err1_a_R_gC = NW COIN EDGE err1_a_R
 err1_b_R_gC = NW COIN EDGE err1_b_R

 err1_a_L_NETID = DFM PROPERTY err1_a_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_a_R_NETID = DFM PROPERTY err1_a_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1_b_L_NETID = DFM PROPERTY err1_b_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_b_R_NETID = DFM PROPERTY err1_b_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1 = DFM PROPERTY err1_a err1_a_L_NETID err1_a_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_a_L_NETID)]
 [NET_b = count(err1_a_R_NETID)]
 [VH_1a = property(err1_a_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_a_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_a_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_a_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 0 && property_ref(DT_vA) <= 1.155) || (property_ref(DT_vB) > 0 && property_ref(DT_vB) <= 1.155)) ? 1 : 0] > 0

 err2 = DFM PROPERTY err1_b err1_b_L_NETID err1_b_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_b_L_NETID)]
 [NET_b = count(err1_b_R_NETID)]
 [VH_1a = property(err1_b_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_b_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_b_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_b_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 0 && property_ref(DT_vA) <= 1.155) || (property_ref(DT_vB) > 0 && property_ref(DT_vB) <= 1.155)) ? 1 : 0] > 0

 DFM COPY err1 err2
}

LU_4_3_1b_G {
@ LU.4.3: Space between IO Anode and IO NW Cathode, IO (PW in DNW) Anode and IO Cathode when 0V < Delta V <= 1V. >= 0.96um
@ Check between PW Anode and IO Cathode
 err1_a = EXT NAA_io_pad_vol_neg_CHK_lc RW_io_pad_CHK_lc < LU_4_3_1b_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b = EXT NAA_io_pad_CHK_lc RW_io_pad_vol_pos_CHK_lc < LU_4_3_1b_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_L = EXT [NAA_io_pad_vol_neg_CHK_lc] RW_io_pad_CHK_lc < LU_4_3_1b_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b_L = EXT [NAA_io_pad_CHK_lc] RW_io_pad_vol_pos_CHK_lc < LU_4_3_1b_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_R = EXT NAA_io_pad_vol_neg_CHK_lc [RW_io_pad_CHK_lc] < LU_4_3_1b_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b_R = EXT NAA_io_pad_CHK_lc [RW_io_pad_vol_pos_CHK_lc] < LU_4_3_1b_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_L_gC = AA_c COIN EDGE err1_a_L
 err1_b_L_gC = AA_c COIN EDGE err1_b_L
 err1_a_R_gC = RW COIN EDGE err1_a_R
 err1_b_R_gC = RW COIN EDGE err1_b_R

 err1_a_L_NETID = DFM PROPERTY err1_a_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_a_R_NETID = DFM PROPERTY err1_a_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1_b_L_NETID = DFM PROPERTY err1_b_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_b_R_NETID = DFM PROPERTY err1_b_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1 = DFM PROPERTY err1_a err1_a_L_NETID err1_a_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_a_L_NETID)]
 [NET_b = count(err1_a_R_NETID)]
 [VH_1a = property(err1_a_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_a_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_a_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_a_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 0 && property_ref(DT_vA) <= 1.155) || (property_ref(DT_vB) > 0 && property_ref(DT_vB) <= 1.155)) ? 1 : 0] > 0

 err2 = DFM PROPERTY err1_b err1_b_L_NETID err1_b_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_b_L_NETID)]
 [NET_b = count(err1_b_R_NETID)]
 [VH_1a = property(err1_b_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_b_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_b_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_b_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 0 && property_ref(DT_vA) <= 1.155) || (property_ref(DT_vB) > 0 && property_ref(DT_vB) <= 1.155)) ? 1 : 0] > 0

 DFM COPY err1 err2
}

LU_4_3_2a_G {
@ LU.4.3: Space between IO Anode and IO NW Cathode, IO (PW in DNW) Anode and IO Cathode when 1V < Delta V <= 1.32V. >= 1.824um
@ Check between IO Anode and IO NW Cathode
 err1_a = EXT PAA_io_pad_vol_pos_115_CHK_lc NW_io_pad_CHK_lc < LU_4_3_2a_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b = EXT PAA_io_pad_CHK_lc NW_io_pad_vol_neg_CHK_lc < LU_4_3_2a_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_L = EXT [PAA_io_pad_vol_pos_115_CHK_lc] NW_io_pad_CHK_lc < LU_4_3_2a_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b_L = EXT [PAA_io_pad_CHK_lc] NW_io_pad_vol_neg_CHK_lc < LU_4_3_2a_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_R = EXT PAA_io_pad_vol_pos_115_CHK_lc [NW_io_pad_CHK_lc] < LU_4_3_2a_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b_R = EXT PAA_io_pad_CHK_lc [NW_io_pad_vol_neg_CHK_lc] < LU_4_3_2a_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_L_gC = AA_c COIN EDGE err1_a_L
 err1_b_L_gC = AA_c COIN EDGE err1_b_L
 err1_a_R_gC = NW COIN EDGE err1_a_R
 err1_b_R_gC = NW COIN EDGE err1_b_R

 err1_a_L_NETID = DFM PROPERTY err1_a_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_a_R_NETID = DFM PROPERTY err1_a_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1_b_L_NETID = DFM PROPERTY err1_b_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_b_R_NETID = DFM PROPERTY err1_b_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1 = DFM PROPERTY err1_a err1_a_L_NETID err1_a_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_a_L_NETID)]
 [NET_b = count(err1_a_R_NETID)]
 [VH_1a = property(err1_a_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_a_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_a_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_a_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 1.155 && property_ref(DT_vA) <= 1.32) || (property_ref(DT_vB) > 1.155 && property_ref(DT_vB) <= 1.32)) ? 1 : 0] > 0

 err2 = DFM PROPERTY err1_b err1_b_L_NETID err1_b_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_b_L_NETID)]
 [NET_b = count(err1_b_R_NETID)]
 [VH_1a = property(err1_b_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_b_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_b_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_b_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 1.155 && property_ref(DT_vA) <= 1.32) || (property_ref(DT_vB) > 1.155 && property_ref(DT_vB) <= 1.32)) ? 1 : 0] > 0

 DFM COPY err1 err2
}

LU_4_3_2b_G {
@ LU.4.3: Space between IO Anode and IO NW Cathode, IO (PW in DNW) Anode and IO Cathode when 1V < Delta V <= 1.32V. >= 1.824um
@ Check between PW Anode and IO Cathode
 err1_a = EXT NAA_io_pad_vol_neg_CHK_lc RW_io_pad_CHK_lc < LU_4_3_2b_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b = EXT NAA_io_pad_CHK_lc RW_io_pad_vol_gt_pos_115_CHK_lc < LU_4_3_2b_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_L = EXT [NAA_io_pad_vol_neg_CHK_lc] RW_io_pad_CHK_lc < LU_4_3_2b_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b_L = EXT [NAA_io_pad_CHK_lc] RW_io_pad_vol_gt_pos_115_CHK_lc < LU_4_3_2b_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_R = EXT NAA_io_pad_vol_neg_CHK_lc [RW_io_pad_CHK_lc] < LU_4_3_2b_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b_R = EXT NAA_io_pad_CHK_lc [RW_io_pad_vol_gt_pos_115_CHK_lc] < LU_4_3_2b_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_L_gC = AA_c COIN EDGE err1_a_L
 err1_b_L_gC = AA_c COIN EDGE err1_b_L
 err1_a_R_gC = RW COIN EDGE err1_a_R
 err1_b_R_gC = RW COIN EDGE err1_b_R

 err1_a_L_NETID = DFM PROPERTY err1_a_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_a_R_NETID = DFM PROPERTY err1_a_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1_b_L_NETID = DFM PROPERTY err1_b_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_b_R_NETID = DFM PROPERTY err1_b_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1 = DFM PROPERTY err1_a err1_a_L_NETID err1_a_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_a_L_NETID)]
 [NET_b = count(err1_a_R_NETID)]
 [VH_1a = property(err1_a_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_a_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_a_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_a_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 1.155 && property_ref(DT_vA) <= 1.32) || (property_ref(DT_vB) > 1.155 && property_ref(DT_vB) <= 1.32)) ? 1 : 0] > 0

 err2 = DFM PROPERTY err1_b err1_b_L_NETID err1_b_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_b_L_NETID)]
 [NET_b = count(err1_b_R_NETID)]
 [VH_1a = property(err1_b_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_b_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_b_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_b_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 1.155 && property_ref(DT_vA) <= 1.32) || (property_ref(DT_vB) > 1.155 && property_ref(DT_vB) <= 1.32)) ? 1 : 0] > 0

 DFM COPY err1 err2
}

LU_4_3_3a_G {
@ LU.4.3: Space between IO Anode and IO NW Cathode, IO (PW in DNW) Anode and IO Cathode when 1.32V < Delta V <= 1.65V. >= 2.112um
@ Check between IO Anode and IO NW Cathode
 err1_a = EXT PAA_io_pad_vol_pos_132_CHK_lc NW_io_pad_CHK_lc < LU_4_3_3a_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b = EXT PAA_io_pad_CHK_lc NW_io_pad_vol_neg_CHK_lc < LU_4_3_3a_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_L = EXT [PAA_io_pad_vol_pos_132_CHK_lc] NW_io_pad_CHK_lc < LU_4_3_3a_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b_L = EXT [PAA_io_pad_CHK_lc] NW_io_pad_vol_neg_CHK_lc < LU_4_3_3a_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_R = EXT PAA_io_pad_vol_pos_132_CHK_lc [NW_io_pad_CHK_lc] < LU_4_3_3a_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b_R = EXT PAA_io_pad_CHK_lc [NW_io_pad_vol_neg_CHK_lc] < LU_4_3_3a_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_L_gC = AA_c COIN EDGE err1_a_L
 err1_b_L_gC = AA_c COIN EDGE err1_b_L
 err1_a_R_gC = NW COIN EDGE err1_a_R
 err1_b_R_gC = NW COIN EDGE err1_b_R

 err1_a_L_NETID = DFM PROPERTY err1_a_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_a_R_NETID = DFM PROPERTY err1_a_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1_b_L_NETID = DFM PROPERTY err1_b_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_b_R_NETID = DFM PROPERTY err1_b_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1 = DFM PROPERTY err1_a err1_a_L_NETID err1_a_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_a_L_NETID)]
 [NET_b = count(err1_a_R_NETID)]
 [VH_1a = property(err1_a_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_a_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_a_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_a_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 1.32 && property_ref(DT_vA) <= 1.65) || (property_ref(DT_vB) > 1.32 && property_ref(DT_vB) <= 1.65)) ? 1 : 0] > 0

 err2 = DFM PROPERTY err1_b err1_b_L_NETID err1_b_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_b_L_NETID)]
 [NET_b = count(err1_b_R_NETID)]
 [VH_1a = property(err1_b_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_b_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_b_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_b_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 1.32 && property_ref(DT_vA) <= 1.65) || (property_ref(DT_vB) > 1.32 && property_ref(DT_vB) <= 1.65)) ? 1 : 0] > 0

 DFM COPY err1 err2
}

LU_4_3_3b_G {
@ LU.4.3: Space between IO Anode and IO NW Cathode, IO (PW in DNW) Anode and IO Cathode when 1.32V < Delta V <= 1.65V. >= 2.112um
@ Check between PW Anode and IO Cathode
 err1_a = EXT NAA_io_pad_vol_neg_CHK_lc RW_io_pad_CHK_lc < LU_4_3_3b_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b = EXT NAA_io_pad_CHK_lc RW_io_pad_vol_gt_pos_132_CHK_lc < LU_4_3_3b_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_L = EXT [NAA_io_pad_vol_neg_CHK_lc] RW_io_pad_CHK_lc < LU_4_3_3b_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b_L = EXT [NAA_io_pad_CHK_lc] RW_io_pad_vol_gt_pos_132_CHK_lc < LU_4_3_3b_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_R = EXT NAA_io_pad_vol_neg_CHK_lc [RW_io_pad_CHK_lc] < LU_4_3_3b_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b_R = EXT NAA_io_pad_CHK_lc [RW_io_pad_vol_gt_pos_132_CHK_lc] < LU_4_3_3b_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_L_gC = AA_c COIN EDGE err1_a_L
 err1_b_L_gC = AA_c COIN EDGE err1_b_L
 err1_a_R_gC = RW COIN EDGE err1_a_R
 err1_b_R_gC = RW COIN EDGE err1_b_R

 err1_a_L_NETID = DFM PROPERTY err1_a_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_a_R_NETID = DFM PROPERTY err1_a_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1_b_L_NETID = DFM PROPERTY err1_b_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_b_R_NETID = DFM PROPERTY err1_b_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1 = DFM PROPERTY err1_a err1_a_L_NETID err1_a_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_a_L_NETID)]
 [NET_b = count(err1_a_R_NETID)]
 [VH_1a = property(err1_a_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_a_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_a_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_a_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 1.32 && property_ref(DT_vA) <= 1.65) || (property_ref(DT_vB) > 1.32 && property_ref(DT_vB) <= 1.65)) ? 1 : 0] > 0

 err2 = DFM PROPERTY err1_b err1_b_L_NETID err1_b_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_b_L_NETID)]
 [NET_b = count(err1_b_R_NETID)]
 [VH_1a = property(err1_b_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_b_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_b_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_b_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 1.32 && property_ref(DT_vA) <= 1.65) || (property_ref(DT_vB) > 1.32 && property_ref(DT_vB) <= 1.65)) ? 1 : 0] > 0

 DFM COPY err1 err2
}

LU_4_3_4a_G {
@ LU.4.3: Space between IO Anode and IO NW Cathode, IO (PW in DNW) Anode and IO Cathode when 1.65V < Delta V <= 1.98V. >= 4.512um
@ Check between IO Anode and IO NW Cathode
 err1_a = EXT PAA_io_pad_vol_pos_165_CHK_lc NW_io_pad_CHK_lc < LU_4_3_4a_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b = EXT PAA_io_pad_CHK_lc NW_io_pad_vol_neg_CHK_lc < LU_4_3_4a_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_L = EXT [PAA_io_pad_vol_pos_165_CHK_lc] NW_io_pad_CHK_lc < LU_4_3_4a_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b_L = EXT [PAA_io_pad_CHK_lc] NW_io_pad_vol_neg_CHK_lc < LU_4_3_4a_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_R = EXT PAA_io_pad_vol_pos_165_CHK_lc [NW_io_pad_CHK_lc] < LU_4_3_4a_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b_R = EXT PAA_io_pad_CHK_lc [NW_io_pad_vol_neg_CHK_lc] < LU_4_3_4a_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_L_gC = AA_c COIN EDGE err1_a_L
 err1_b_L_gC = AA_c COIN EDGE err1_b_L
 err1_a_R_gC = NW COIN EDGE err1_a_R
 err1_b_R_gC = NW COIN EDGE err1_b_R

 err1_a_L_NETID = DFM PROPERTY err1_a_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_a_R_NETID = DFM PROPERTY err1_a_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1_b_L_NETID = DFM PROPERTY err1_b_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_b_R_NETID = DFM PROPERTY err1_b_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1 = DFM PROPERTY err1_a err1_a_L_NETID err1_a_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_a_L_NETID)]
 [NET_b = count(err1_a_R_NETID)]
 [VH_1a = property(err1_a_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_a_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_a_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_a_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 1.65 && property_ref(DT_vA) <= 1.98) || (property_ref(DT_vB) > 1.65 && property_ref(DT_vB) <= 1.98)) ? 1 : 0] > 0

 err2 = DFM PROPERTY err1_b err1_b_L_NETID err1_b_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_b_L_NETID)]
 [NET_b = count(err1_b_R_NETID)]
 [VH_1a = property(err1_b_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_b_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_b_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_b_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 1.65 && property_ref(DT_vA) <= 1.98) || (property_ref(DT_vB) > 1.65 && property_ref(DT_vB) <= 1.98)) ? 1 : 0] > 0

 DFM COPY err1 err2
}

LU_4_3_4b_G {
@ LU.4.3: Space between IO Anode and IO NW Cathode, IO (PW in DNW) Anode and IO Cathode when 1.65V < Delta V <= 1.98V. >= 4.512um
@ Check between PW Anode and IO Cathode
 err1_a = EXT NAA_io_pad_vol_neg_CHK_lc RW_io_pad_CHK_lc < LU_4_3_4b_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b = EXT NAA_io_pad_CHK_lc RW_io_pad_vol_gt_pos_165_CHK_lc < LU_4_3_4b_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_L = EXT [NAA_io_pad_vol_neg_CHK_lc] RW_io_pad_CHK_lc < LU_4_3_4b_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b_L = EXT [NAA_io_pad_CHK_lc] RW_io_pad_vol_gt_pos_165_CHK_lc < LU_4_3_4b_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_R = EXT NAA_io_pad_vol_neg_CHK_lc [RW_io_pad_CHK_lc] < LU_4_3_4b_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b_R = EXT NAA_io_pad_CHK_lc [RW_io_pad_vol_gt_pos_165_CHK_lc] < LU_4_3_4b_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_L_gC = AA_c COIN EDGE err1_a_L
 err1_b_L_gC = AA_c COIN EDGE err1_b_L
 err1_a_R_gC = RW COIN EDGE err1_a_R
 err1_b_R_gC = RW COIN EDGE err1_b_R

 err1_a_L_NETID = DFM PROPERTY err1_a_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_a_R_NETID = DFM PROPERTY err1_a_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1_b_L_NETID = DFM PROPERTY err1_b_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_b_R_NETID = DFM PROPERTY err1_b_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1 = DFM PROPERTY err1_a err1_a_L_NETID err1_a_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_a_L_NETID)]
 [NET_b = count(err1_a_R_NETID)]
 [VH_1a = property(err1_a_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_a_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_a_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_a_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 1.65 && property_ref(DT_vA) <= 1.98) || (property_ref(DT_vB) > 1.65 && property_ref(DT_vB) <= 1.98)) ? 1 : 0] > 0

 err2 = DFM PROPERTY err1_b err1_b_L_NETID err1_b_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_b_L_NETID)]
 [NET_b = count(err1_b_R_NETID)]
 [VH_1a = property(err1_b_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_b_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_b_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_b_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 1.65 && property_ref(DT_vA) <= 1.98) || (property_ref(DT_vB) > 1.65 && property_ref(DT_vB) <= 1.98)) ? 1 : 0] > 0

 DFM COPY err1 err2
}

LU_4_3_5a_G {
@ LU.4.3: Space between IO Anode and IO NW Cathode, IO (PW in DNW) Anode and IO Cathode when 1.98V < Delta V <= 2.75V. >= 7.968um
@ Check between IO Anode and IO NW Cathode
 err1_a = EXT PAA_io_pad_vol_pos_198_CHK_lc NW_io_pad_CHK_lc < LU_4_3_5a_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b = EXT PAA_io_pad_CHK_lc NW_io_pad_vol_neg_CHK_lc < LU_4_3_5a_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_L = EXT [PAA_io_pad_vol_pos_198_CHK_lc] NW_io_pad_CHK_lc < LU_4_3_5a_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b_L = EXT [PAA_io_pad_CHK_lc] NW_io_pad_vol_neg_CHK_lc < LU_4_3_5a_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_R = EXT PAA_io_pad_vol_pos_198_CHK_lc [NW_io_pad_CHK_lc] < LU_4_3_5a_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b_R = EXT PAA_io_pad_CHK_lc [NW_io_pad_vol_neg_CHK_lc] < LU_4_3_5a_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_L_gC = AA_c COIN EDGE err1_a_L
 err1_b_L_gC = AA_c COIN EDGE err1_b_L
 err1_a_R_gC = NW COIN EDGE err1_a_R
 err1_b_R_gC = NW COIN EDGE err1_b_R

 err1_a_L_NETID = DFM PROPERTY err1_a_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_a_R_NETID = DFM PROPERTY err1_a_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1_b_L_NETID = DFM PROPERTY err1_b_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_b_R_NETID = DFM PROPERTY err1_b_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1 = DFM PROPERTY err1_a err1_a_L_NETID err1_a_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_a_L_NETID)]
 [NET_b = count(err1_a_R_NETID)]
 [VH_1a = property(err1_a_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_a_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_a_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_a_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 1.98 && property_ref(DT_vA) <= 2.75) || (property_ref(DT_vB) > 1.98 && property_ref(DT_vB) <= 2.75)) ? 1 : 0] > 0

 err2 = DFM PROPERTY err1_b err1_b_L_NETID err1_b_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_b_L_NETID)]
 [NET_b = count(err1_b_R_NETID)]
 [VH_1a = property(err1_b_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_b_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_b_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_b_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 1.98 && property_ref(DT_vA) <= 2.75) || (property_ref(DT_vB) > 1.98 && property_ref(DT_vB) <= 2.75)) ? 1 : 0] > 0

 DFM COPY err1 err2
}

LU_4_3_5b_G {
@ LU.4.3: Space between IO Anode and IO NW Cathode, IO (PW in DNW) Anode and IO Cathode when 1.98V < Delta V <= 2.75V. >= 7.968um
@ Check between PW Anode and IO Cathode
 err1_a = EXT NAA_io_pad_vol_neg_CHK_lc RW_io_pad_CHK_lc < LU_4_3_5b_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b = EXT NAA_io_pad_CHK_lc RW_io_pad_vol_gt_pos_198_CHK_lc < LU_4_3_5b_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_L = EXT [NAA_io_pad_vol_neg_CHK_lc] RW_io_pad_CHK_lc < LU_4_3_5b_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b_L = EXT [NAA_io_pad_CHK_lc] RW_io_pad_vol_gt_pos_198_CHK_lc < LU_4_3_5b_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_R = EXT NAA_io_pad_vol_neg_CHK_lc [RW_io_pad_CHK_lc] < LU_4_3_5b_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b_R = EXT NAA_io_pad_CHK_lc [RW_io_pad_vol_gt_pos_198_CHK_lc] < LU_4_3_5b_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_L_gC = AA_c COIN EDGE err1_a_L
 err1_b_L_gC = AA_c COIN EDGE err1_b_L
 err1_a_R_gC = RW COIN EDGE err1_a_R
 err1_b_R_gC = RW COIN EDGE err1_b_R

 err1_a_L_NETID = DFM PROPERTY err1_a_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_a_R_NETID = DFM PROPERTY err1_a_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1_b_L_NETID = DFM PROPERTY err1_b_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_b_R_NETID = DFM PROPERTY err1_b_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1 = DFM PROPERTY err1_a err1_a_L_NETID err1_a_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_a_L_NETID)]
 [NET_b = count(err1_a_R_NETID)]
 [VH_1a = property(err1_a_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_a_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_a_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_a_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 1.98 && property_ref(DT_vA) <= 2.75) || (property_ref(DT_vB) > 1.98 && property_ref(DT_vB) <= 2.75)) ? 1 : 0] > 0

 err2 = DFM PROPERTY err1_b err1_b_L_NETID err1_b_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_b_L_NETID)]
 [NET_b = count(err1_b_R_NETID)]
 [VH_1a = property(err1_b_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_b_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_b_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_b_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 1.98 && property_ref(DT_vA) <= 2.75) || (property_ref(DT_vB) > 1.98 && property_ref(DT_vB) <= 2.75)) ? 1 : 0] > 0

 DFM COPY err1 err2
}

LU_4_3_6a_G {
@ LU.4.3: Space between IO Anode and IO NW Cathode, IO (PW in DNW) Anode and IO Cathode when 2.75V < Delta V <= 3.63V. >= 16.032um
@ Check between IO Anode and IO NW Cathode
 err1_a = EXT PAA_io_pad_vol_pos_275_CHK_lc NW_io_pad_CHK_lc < LU_4_3_6a_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b = EXT PAA_io_pad_CHK_lc NW_io_pad_vol_neg_CHK_lc < LU_4_3_6a_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_L = EXT [PAA_io_pad_vol_pos_275_CHK_lc] NW_io_pad_CHK_lc < LU_4_3_6a_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b_L = EXT [PAA_io_pad_CHK_lc] NW_io_pad_vol_neg_CHK_lc < LU_4_3_6a_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_R = EXT PAA_io_pad_vol_pos_275_CHK_lc [NW_io_pad_CHK_lc] < LU_4_3_6a_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b_R = EXT PAA_io_pad_CHK_lc [NW_io_pad_vol_neg_CHK_lc] < LU_4_3_6a_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_L_gC = AA_c COIN EDGE err1_a_L
 err1_b_L_gC = AA_c COIN EDGE err1_b_L
 err1_a_R_gC = NW COIN EDGE err1_a_R
 err1_b_R_gC = NW COIN EDGE err1_b_R

 err1_a_L_NETID = DFM PROPERTY err1_a_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_a_R_NETID = DFM PROPERTY err1_a_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1_b_L_NETID = DFM PROPERTY err1_b_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_b_R_NETID = DFM PROPERTY err1_b_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1 = DFM PROPERTY err1_a err1_a_L_NETID err1_a_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_a_L_NETID)]
 [NET_b = count(err1_a_R_NETID)]
 [VH_1a = property(err1_a_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_a_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_a_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_a_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 2.75 && property_ref(DT_vA) <= 3.63) || (property_ref(DT_vB) > 2.75 && property_ref(DT_vB) <= 3.63)) ? 1 : 0] > 0

 err2 = DFM PROPERTY err1_b err1_b_L_NETID err1_b_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_b_L_NETID)]
 [NET_b = count(err1_b_R_NETID)]
 [VH_1a = property(err1_b_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_b_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_b_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_b_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 2.75 && property_ref(DT_vA) <= 3.63) || (property_ref(DT_vB) > 2.75 && property_ref(DT_vB) <= 3.63)) ? 1 : 0] > 0

 DFM COPY err1 err2
}

LU_4_3_6b_G {
@ LU.4.3: Space between IO Anode and IO NW Cathode, IO (PW in DNW) Anode and IO Cathode when 2.75V < Delta V <= 3.63V. >= 16.032um
@ Check between PW Anode and IO Cathode
 err1_a = EXT NAA_io_pad_vol_neg_CHK_lc RW_io_pad_CHK_lc < LU_4_3_6b_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b = EXT NAA_io_pad_CHK_lc RW_io_pad_vol_gt_pos_275_CHK_lc < LU_4_3_6b_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_L = EXT [NAA_io_pad_vol_neg_CHK_lc] RW_io_pad_CHK_lc < LU_4_3_6b_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b_L = EXT [NAA_io_pad_CHK_lc] RW_io_pad_vol_gt_pos_275_CHK_lc < LU_4_3_6b_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_R = EXT NAA_io_pad_vol_neg_CHK_lc [RW_io_pad_CHK_lc] < LU_4_3_6b_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b_R = EXT NAA_io_pad_CHK_lc [RW_io_pad_vol_gt_pos_275_CHK_lc] < LU_4_3_6b_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_L_gC = AA_c COIN EDGE err1_a_L
 err1_b_L_gC = AA_c COIN EDGE err1_b_L
 err1_a_R_gC = RW COIN EDGE err1_a_R
 err1_b_R_gC = RW COIN EDGE err1_b_R

 err1_a_L_NETID = DFM PROPERTY err1_a_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_a_R_NETID = DFM PROPERTY err1_a_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1_b_L_NETID = DFM PROPERTY err1_b_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_b_R_NETID = DFM PROPERTY err1_b_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1 = DFM PROPERTY err1_a err1_a_L_NETID err1_a_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_a_L_NETID)]
 [NET_b = count(err1_a_R_NETID)]
 [VH_1a = property(err1_a_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_a_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_a_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_a_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 2.75 && property_ref(DT_vA) <= 3.63) || (property_ref(DT_vB) > 2.75 && property_ref(DT_vB) <= 3.63)) ? 1 : 0] > 0

 err2 = DFM PROPERTY err1_b err1_b_L_NETID err1_b_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_b_L_NETID)]
 [NET_b = count(err1_b_R_NETID)]
 [VH_1a = property(err1_b_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_b_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_b_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_b_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 2.75 && property_ref(DT_vA) <= 3.63) || (property_ref(DT_vB) > 2.75 && property_ref(DT_vB) <= 3.63)) ? 1 : 0] > 0

 DFM COPY err1 err2
}

LU_4_3_7a_G {
@ LU.4.3: Space between IO Anode and IO NW Cathode, IO (PW in DNW) Anode and IO Cathode when 3.63V < Delta V <= 5.5V. >= 35.952um
@ Check between IO Anode and IO NW Cathode
 err1_a = EXT PAA_io_pad_vol_pos_363_CHK_lc NW_io_pad_CHK_lc < LU_4_3_7a_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b = EXT PAA_io_pad_CHK_lc NW_io_pad_vol_neg_CHK_lc < LU_4_3_7a_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_L = EXT [PAA_io_pad_vol_pos_363_CHK_lc] NW_io_pad_CHK_lc < LU_4_3_7a_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b_L = EXT [PAA_io_pad_CHK_lc] NW_io_pad_vol_neg_CHK_lc < LU_4_3_7a_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_R = EXT PAA_io_pad_vol_pos_363_CHK_lc [NW_io_pad_CHK_lc] < LU_4_3_7a_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b_R = EXT PAA_io_pad_CHK_lc [NW_io_pad_vol_neg_CHK_lc] < LU_4_3_7a_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_L_gC = AA_c COIN EDGE err1_a_L
 err1_b_L_gC = AA_c COIN EDGE err1_b_L
 err1_a_R_gC = NW COIN EDGE err1_a_R
 err1_b_R_gC = NW COIN EDGE err1_b_R

 err1_a_L_NETID = DFM PROPERTY err1_a_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_a_R_NETID = DFM PROPERTY err1_a_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1_b_L_NETID = DFM PROPERTY err1_b_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_b_R_NETID = DFM PROPERTY err1_b_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1 = DFM PROPERTY err1_a err1_a_L_NETID err1_a_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_a_L_NETID)]
 [NET_b = count(err1_a_R_NETID)]
 [VH_1a = property(err1_a_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_a_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_a_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_a_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 3.63 && property_ref(DT_vA) <= 5.5) || (property_ref(DT_vB) > 3.63 && property_ref(DT_vB) <= 5.5)) ? 1 : 0] > 0

 err2 = DFM PROPERTY err1_b err1_b_L_NETID err1_b_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_b_L_NETID)]
 [NET_b = count(err1_b_R_NETID)]
 [VH_1a = property(err1_b_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_b_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_b_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_b_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 3.63 && property_ref(DT_vA) <= 5.5) || (property_ref(DT_vB) > 3.63 && property_ref(DT_vB) <= 5.5)) ? 1 : 0] > 0

 DFM COPY err1 err2
}

LU_4_3_7b_G {
@ LU.4.3: Space between IO Anode and IO NW Cathode, IO (PW in DNW) Anode and IO Cathode when 3.63V < Delta V <= 5.5V. >= 35.952um
@ Check between PW Anode and IO Cathode
 err1_a = EXT NAA_io_pad_vol_neg_CHK_lc RW_io_pad_CHK_lc < LU_4_3_7b_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b = EXT NAA_io_pad_CHK_lc RW_io_pad_vol_gt_pos_363_CHK_lc < LU_4_3_7b_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_L = EXT [NAA_io_pad_vol_neg_CHK_lc] RW_io_pad_CHK_lc < LU_4_3_7b_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b_L = EXT [NAA_io_pad_CHK_lc] RW_io_pad_vol_gt_pos_363_CHK_lc < LU_4_3_7b_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_R = EXT NAA_io_pad_vol_neg_CHK_lc [RW_io_pad_CHK_lc] < LU_4_3_7b_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b_R = EXT NAA_io_pad_CHK_lc [RW_io_pad_vol_gt_pos_363_CHK_lc] < LU_4_3_7b_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_L_gC = AA_c COIN EDGE err1_a_L
 err1_b_L_gC = AA_c COIN EDGE err1_b_L
 err1_a_R_gC = RW COIN EDGE err1_a_R
 err1_b_R_gC = RW COIN EDGE err1_b_R

 err1_a_L_NETID = DFM PROPERTY err1_a_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_a_R_NETID = DFM PROPERTY err1_a_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1_b_L_NETID = DFM PROPERTY err1_b_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_b_R_NETID = DFM PROPERTY err1_b_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1 = DFM PROPERTY err1_a err1_a_L_NETID err1_a_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_a_L_NETID)]
 [NET_b = count(err1_a_R_NETID)]
 [VH_1a = property(err1_a_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_a_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_a_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_a_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 3.63 && property_ref(DT_vA) <= 5.5) || (property_ref(DT_vB) > 3.63 && property_ref(DT_vB) <= 5.5)) ? 1 : 0] > 0

 err2 = DFM PROPERTY err1_b err1_b_L_NETID err1_b_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_b_L_NETID)]
 [NET_b = count(err1_b_R_NETID)]
 [VH_1a = property(err1_b_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_b_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_b_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_b_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 3.63 && property_ref(DT_vA) <= 5.5) || (property_ref(DT_vB) > 3.63 && property_ref(DT_vB) <= 5.5)) ? 1 : 0] > 0

 DFM COPY err1 err2
}

//;For lu.4.4
PSD_power_pad_within_io_pad_140 = PSD_power_pad_CHK INTERACT AACT_io_pad_dev_SWELL_14
NSD_power_pad_within_io_pad_140 = NSD_power_pad_CHK INTERACT AACT_io_pad_dev_SWELL_14
NSD_power_pad_within_io_pad_140_neg = NSD_power_pad_vol_neg_CHK INTERACT AACT_io_pad_dev_SWELL_14

PSD_power_pad_within_io_pad_140_lc = AA_lc INTERACT PSD_power_pad_within_io_pad_140
NSD_power_pad_within_io_pad_140_lc = AA_lc INTERACT NSD_power_pad_within_io_pad_140
NSD_power_pad_within_io_pad_140_neg_lc = AA_lc INTERACT NSD_power_pad_within_io_pad_140_neg

PW_pad_io_within_io_pad_140 = RW_io_pad_CHK INTERACT AACT_io_pad_dev_SWELL_14
NW_pad_io_within_io_pad_140 = NW_io_pad_CHK INTERACT AACT_io_pad_dev_SWELL_14
NW_pad_io_within_io_pad_140_neg = NW_io_pad_vol_neg_CHK INTERACT AACT_io_pad_dev_SWELL_14
PW_pad_io_within_io_pad_140_lc = RW_lc INTERACT PW_pad_io_within_io_pad_140
NW_pad_io_within_io_pad_140_lc = NW_lc INTERACT NW_pad_io_within_io_pad_140
NW_pad_io_within_io_pad_140_neg_lc = NW_lc INTERACT NW_pad_io_within_io_pad_140_neg

PSD_power_anode_vol_pos = PSD_power_pad_vol_pos_CHK INTERACT AACT_io_pad_dev_SWELL_14
PSD_power_anode_vol_gt_pos_115 = PSD_power_pad_vol_gt_pos_115 INTERACT AACT_io_pad_dev_SWELL_14
PSD_power_anode_vol_gt_pos_132 = PSD_power_pad_vol_gt_pos_132 INTERACT AACT_io_pad_dev_SWELL_14
PSD_power_anode_vol_gt_pos_165 = PSD_power_pad_vol_gt_pos_165 INTERACT AACT_io_pad_dev_SWELL_14
PSD_power_anode_vol_gt_pos_198 = PSD_power_pad_vol_gt_pos_198 INTERACT AACT_io_pad_dev_SWELL_14
PSD_power_anode_vol_gt_pos_275 = PSD_power_pad_vol_gt_pos_275 INTERACT AACT_io_pad_dev_SWELL_14
PSD_power_anode_vol_gt_pos_363 = PSD_power_pad_vol_gt_pos_363 INTERACT AACT_io_pad_dev_SWELL_14

PSD_power_anode_vol_pos_lc = AA_lc INTERACT PSD_power_anode_vol_pos
PSD_power_anode_vol_gt_pos_115_lc = AA_lc INTERACT PSD_power_anode_vol_gt_pos_115
PSD_power_anode_vol_gt_pos_132_lc = AA_lc INTERACT PSD_power_anode_vol_gt_pos_132
PSD_power_anode_vol_gt_pos_165_lc = AA_lc INTERACT PSD_power_anode_vol_gt_pos_165
PSD_power_anode_vol_gt_pos_198_lc = AA_lc INTERACT PSD_power_anode_vol_gt_pos_198
PSD_power_anode_vol_gt_pos_275_lc = AA_lc INTERACT PSD_power_anode_vol_gt_pos_275
PSD_power_anode_vol_gt_pos_363_lc = AA_lc INTERACT PSD_power_anode_vol_gt_pos_363

PW_cathode_vol_pos_CHK = RW_io_pad_vol_pos_CHK INTERACT AACT_io_pad_dev_SWELL_14
PW_cathode_vol_gt_pos_115_CHK = RW_io_pad_vol_gt_pos_115_CHK INTERACT AACT_io_pad_dev_SWELL_14
PW_cathode_vol_gt_pos_132_CHK = RW_io_pad_vol_gt_pos_132_CHK INTERACT AACT_io_pad_dev_SWELL_14
PW_cathode_vol_gt_pos_165_CHK = RW_io_pad_vol_gt_pos_165_CHK INTERACT AACT_io_pad_dev_SWELL_14
PW_cathode_vol_gt_pos_198_CHK = RW_io_pad_vol_gt_pos_198_CHK INTERACT AACT_io_pad_dev_SWELL_14
PW_cathode_vol_gt_pos_275_CHK = RW_io_pad_vol_gt_pos_275_CHK INTERACT AACT_io_pad_dev_SWELL_14
PW_cathode_vol_gt_pos_363_CHK = RW_io_pad_vol_gt_pos_363_CHK INTERACT AACT_io_pad_dev_SWELL_14

PW_cathode_vol_pos_CHK_lc = RW_lc INTERACT PW_cathode_vol_pos_CHK
PW_cathode_vol_gt_pos_115_CHK_lc = RW_lc INTERACT PW_cathode_vol_gt_pos_115_CHK
PW_cathode_vol_gt_pos_132_CHK_lc = RW_lc INTERACT PW_cathode_vol_gt_pos_132_CHK
PW_cathode_vol_gt_pos_165_CHK_lc = RW_lc INTERACT PW_cathode_vol_gt_pos_165_CHK
PW_cathode_vol_gt_pos_198_CHK_lc = RW_lc INTERACT PW_cathode_vol_gt_pos_198_CHK
PW_cathode_vol_gt_pos_275_CHK_lc = RW_lc INTERACT PW_cathode_vol_gt_pos_275_CHK
PW_cathode_vol_gt_pos_363_CHK_lc = RW_lc INTERACT PW_cathode_vol_gt_pos_363_CHK

LU_4_4_1a_G {
@ LU.4.4: Within 14.976um from AA injector, space between Power Anode and IO NW Cathode and space between IO (PW in DNW) cathode and Power cathode when 0V < Delta V <= 1V. >= 0.96um
@ Check between IO Power Anode and IO NW Cathode
 err1_a = EXT PSD_power_anode_vol_pos_lc NW_pad_io_within_io_pad_140_lc < LU_4_4_1a_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b = EXT PSD_power_pad_within_io_pad_140_lc NW_pad_io_within_io_pad_140_neg_lc < LU_4_4_1a_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_L = EXT [PSD_power_anode_vol_pos_lc] NW_pad_io_within_io_pad_140_lc < LU_4_4_1a_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b_L = EXT [PSD_power_pad_within_io_pad_140_lc] NW_pad_io_within_io_pad_140_neg_lc < LU_4_4_1a_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_R = EXT PSD_power_anode_vol_pos_lc [NW_pad_io_within_io_pad_140_lc] < LU_4_4_1a_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b_R = EXT PSD_power_pad_within_io_pad_140_lc [NW_pad_io_within_io_pad_140_neg_lc] < LU_4_4_1a_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_L_gC = AA_c COIN EDGE err1_a_L
 err1_b_L_gC = AA_c COIN EDGE err1_b_L
 err1_a_R_gC = NW COIN EDGE err1_a_R
 err1_b_R_gC = NW COIN EDGE err1_b_R

 err1_a_L_NETID = DFM PROPERTY err1_a_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_a_R_NETID = DFM PROPERTY err1_a_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1_b_L_NETID = DFM PROPERTY err1_b_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_b_R_NETID = DFM PROPERTY err1_b_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1 = DFM PROPERTY err1_a err1_a_L_NETID err1_a_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_a_L_NETID)]
 [NET_b = count(err1_a_R_NETID)]
 [VH_1a = property(err1_a_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_a_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_a_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_a_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 0 && property_ref(DT_vA) <= 1.155) || (property_ref(DT_vB) > 0 && property_ref(DT_vB) <= 1.155)) ? 1 : 0] > 0

 err2 = DFM PROPERTY err1_b err1_b_L_NETID err1_b_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_b_L_NETID)]
 [NET_b = count(err1_b_R_NETID)]
 [VH_1a = property(err1_b_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_b_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_b_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_b_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 0 && property_ref(DT_vA) <= 1.155) || (property_ref(DT_vB) > 0 && property_ref(DT_vB) <= 1.155)) ? 1 : 0] > 0

 DFM COPY err1 err2
}

LU_4_4_1b_G {
@ LU.4.4: Within 14.976um from AA injector, space between Power Anode and IO NW Cathode and space between IO (PW in DNW) cathode and Power cathode when 0V < Delta V <= 1V. >= 0.96um
@ Check between IO (PW in DNW) cathode and Power cathode
 err1_a = EXT PW_cathode_vol_pos_CHK_lc NSD_power_pad_within_io_pad_140_lc < LU_4_4_1b_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b = EXT PW_pad_io_within_io_pad_140_lc NSD_power_pad_within_io_pad_140_neg_lc < LU_4_4_1b_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_L = EXT [PW_cathode_vol_pos_CHK_lc] NSD_power_pad_within_io_pad_140_lc < LU_4_4_1b_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b_L = EXT [PW_pad_io_within_io_pad_140_lc] NSD_power_pad_within_io_pad_140_neg_lc < LU_4_4_1b_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_R = EXT PW_cathode_vol_pos_CHK_lc [NSD_power_pad_within_io_pad_140_lc] < LU_4_4_1b_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b_R = EXT PW_pad_io_within_io_pad_140_lc [NSD_power_pad_within_io_pad_140_neg_lc] < LU_4_4_1b_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_L_gC = RW COIN EDGE err1_a_L
 err1_b_L_gC = RW COIN EDGE err1_b_L
 err1_a_R_gC = AA_c COIN EDGE err1_a_R
 err1_b_R_gC = AA_c COIN EDGE err1_b_R

 err1_a_L_NETID = DFM PROPERTY err1_a_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_a_R_NETID = DFM PROPERTY err1_a_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1_b_L_NETID = DFM PROPERTY err1_b_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_b_R_NETID = DFM PROPERTY err1_b_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1 = DFM PROPERTY err1_a err1_a_L_NETID err1_a_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_a_L_NETID)]
 [NET_b = count(err1_a_R_NETID)]
 [VH_1a = property(err1_a_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_a_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_a_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_a_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 0 && property_ref(DT_vA) <= 1.155) || (property_ref(DT_vB) > 0 && property_ref(DT_vB) <= 1.155)) ? 1 : 0] > 0

 err2 = DFM PROPERTY err1_b err1_b_L_NETID err1_b_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_b_L_NETID)]
 [NET_b = count(err1_b_R_NETID)]
 [VH_1a = property(err1_b_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_b_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_b_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_b_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 0 && property_ref(DT_vA) <= 1.155) || (property_ref(DT_vB) > 0 && property_ref(DT_vB) <= 1.155)) ? 1 : 0] > 0

 DFM COPY err1 err2
}

LU_4_4_2a_G {
@ LU.4.4: Within 14.976um from AA injector, space between Power Anode and IO NW Cathode and space between IO (PW in DNW) cathode and Power cathode when 1V < Delta V <= 1.32V. >= 1.824um
@ Check between IO Power Anode and IO NW Cathode
 err1_a = EXT PSD_power_anode_vol_gt_pos_115_lc NW_pad_io_within_io_pad_140_lc < LU_4_4_2a_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b = EXT PSD_power_pad_within_io_pad_140_lc NW_pad_io_within_io_pad_140_neg_lc < LU_4_4_2a_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_L = EXT [PSD_power_anode_vol_gt_pos_115_lc] NW_pad_io_within_io_pad_140_lc < LU_4_4_2a_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b_L = EXT [PSD_power_pad_within_io_pad_140_lc] NW_pad_io_within_io_pad_140_neg_lc < LU_4_4_2a_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_R = EXT PSD_power_anode_vol_gt_pos_115_lc [NW_pad_io_within_io_pad_140_lc] < LU_4_4_2a_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b_R = EXT PSD_power_pad_within_io_pad_140_lc [NW_pad_io_within_io_pad_140_neg_lc] < LU_4_4_2a_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_L_gC = AA_c COIN EDGE err1_a_L
 err1_b_L_gC = AA_c COIN EDGE err1_b_L
 err1_a_R_gC = NW COIN EDGE err1_a_R
 err1_b_R_gC = NW COIN EDGE err1_b_R

 err1_a_L_NETID = DFM PROPERTY err1_a_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_a_R_NETID = DFM PROPERTY err1_a_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1_b_L_NETID = DFM PROPERTY err1_b_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_b_R_NETID = DFM PROPERTY err1_b_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1 = DFM PROPERTY err1_a err1_a_L_NETID err1_a_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_a_L_NETID)]
 [NET_b = count(err1_a_R_NETID)]
 [VH_1a = property(err1_a_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_a_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_a_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_a_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 1.155 && property_ref(DT_vA) <= 1.32) || (property_ref(DT_vB) > 1.155 && property_ref(DT_vB) <= 1.32)) ? 1 : 0] > 0

 err2 = DFM PROPERTY err1_b err1_b_L_NETID err1_b_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_b_L_NETID)]
 [NET_b = count(err1_b_R_NETID)]
 [VH_1a = property(err1_b_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_b_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_b_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_b_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 1.155 && property_ref(DT_vA) <= 1.32) || (property_ref(DT_vB) > 1.155 && property_ref(DT_vB) <= 1.32)) ? 1 : 0] > 0

 DFM COPY err1 err2
}

LU_4_4_2b_G {
@ LU.4.4: Within 14.976um from AA injector, space between Power Anode and IO NW Cathode and space between IO (PW in DNW) cathode and Power cathode when 1V < Delta V <= 1.32V. >= 1.824um
@ Check between IO (PW in DNW) cathode and Power cathode
 err1_a = EXT PW_cathode_vol_gt_pos_115_CHK_lc NSD_power_pad_within_io_pad_140_lc < LU_4_4_2b_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b = EXT PW_pad_io_within_io_pad_140_lc NSD_power_pad_within_io_pad_140_neg_lc < LU_4_4_2b_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_L = EXT [PW_cathode_vol_gt_pos_115_CHK_lc] NSD_power_pad_within_io_pad_140_lc < LU_4_4_2b_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b_L = EXT [PW_pad_io_within_io_pad_140_lc] NSD_power_pad_within_io_pad_140_neg_lc < LU_4_4_2b_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_R = EXT PW_cathode_vol_gt_pos_115_CHK_lc [NSD_power_pad_within_io_pad_140_lc] < LU_4_4_2b_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b_R = EXT PW_pad_io_within_io_pad_140_lc [NSD_power_pad_within_io_pad_140_neg_lc] < LU_4_4_2b_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_L_gC = RW COIN EDGE err1_a_L
 err1_b_L_gC = RW COIN EDGE err1_b_L
 err1_a_R_gC = AA_c COIN EDGE err1_a_R
 err1_b_R_gC = AA_c COIN EDGE err1_b_R

 err1_a_L_NETID = DFM PROPERTY err1_a_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_a_R_NETID = DFM PROPERTY err1_a_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1_b_L_NETID = DFM PROPERTY err1_b_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_b_R_NETID = DFM PROPERTY err1_b_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1 = DFM PROPERTY err1_a err1_a_L_NETID err1_a_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_a_L_NETID)]
 [NET_b = count(err1_a_R_NETID)]
 [VH_1a = property(err1_a_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_a_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_a_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_a_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 1.155 && property_ref(DT_vA) <= 1.32) || (property_ref(DT_vB) > 1.155 && property_ref(DT_vB) <= 1.32)) ? 1 : 0] > 0

 err2 = DFM PROPERTY err1_b err1_b_L_NETID err1_b_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_b_L_NETID)]
 [NET_b = count(err1_b_R_NETID)]
 [VH_1a = property(err1_b_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_b_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_b_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_b_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 1.155 && property_ref(DT_vA) <= 1.32) || (property_ref(DT_vB) > 1.155 && property_ref(DT_vB) <= 1.32)) ? 1 : 0] > 0

 DFM COPY err1 err2
}

LU_4_4_3a_G {
@ LU.4.4: Within 14.976um from AA injector, space between Power Anode and IO NW Cathode and space between IO (PW in DNW) cathode and Power cathode when 1.32V < Delta V <= 1.65V. >= 2.112um
@ Check between IO Power Anode and IO NW Cathode
 err1_a = EXT PSD_power_anode_vol_gt_pos_132_lc NW_pad_io_within_io_pad_140_lc < LU_4_4_3a_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b = EXT PSD_power_pad_within_io_pad_140_lc NW_pad_io_within_io_pad_140_neg_lc < LU_4_4_3a_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_L = EXT [PSD_power_anode_vol_gt_pos_132_lc] NW_pad_io_within_io_pad_140_lc < LU_4_4_3a_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b_L = EXT [PSD_power_pad_within_io_pad_140_lc] NW_pad_io_within_io_pad_140_neg_lc < LU_4_4_3a_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_R = EXT PSD_power_anode_vol_gt_pos_132_lc [NW_pad_io_within_io_pad_140_lc] < LU_4_4_3a_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b_R = EXT PSD_power_pad_within_io_pad_140_lc [NW_pad_io_within_io_pad_140_neg_lc] < LU_4_4_3a_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_L_gC = AA_c COIN EDGE err1_a_L
 err1_b_L_gC = AA_c COIN EDGE err1_b_L
 err1_a_R_gC = NW COIN EDGE err1_a_R
 err1_b_R_gC = NW COIN EDGE err1_b_R

 err1_a_L_NETID = DFM PROPERTY err1_a_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_a_R_NETID = DFM PROPERTY err1_a_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1_b_L_NETID = DFM PROPERTY err1_b_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_b_R_NETID = DFM PROPERTY err1_b_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1 = DFM PROPERTY err1_a err1_a_L_NETID err1_a_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_a_L_NETID)]
 [NET_b = count(err1_a_R_NETID)]
 [VH_1a = property(err1_a_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_a_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_a_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_a_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 1.32 && property_ref(DT_vA) <= 1.65) || (property_ref(DT_vB) > 1.32 && property_ref(DT_vB) <= 1.65)) ? 1 : 0] > 0

 err2 = DFM PROPERTY err1_b err1_b_L_NETID err1_b_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_b_L_NETID)]
 [NET_b = count(err1_b_R_NETID)]
 [VH_1a = property(err1_b_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_b_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_b_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_b_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 1.32 && property_ref(DT_vA) <= 1.65) || (property_ref(DT_vB) > 1.32 && property_ref(DT_vB) <= 1.65)) ? 1 : 0] > 0

 DFM COPY err1 err2
}

LU_4_4_3b_G {
@ LU.4.4: Within 14.976um from AA injector, space between Power Anode and IO NW Cathode and space between IO (PW in DNW) cathode and Power cathode when 1.32V < Delta V <= 1.65V. >= 2.112um
@ Check between IO (PW in DNW) cathode and Power cathode
 err1_a = EXT PW_cathode_vol_gt_pos_132_CHK_lc NSD_power_pad_within_io_pad_140_lc < LU_4_4_3b_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b = EXT PW_pad_io_within_io_pad_140_lc NSD_power_pad_within_io_pad_140_neg_lc < LU_4_4_3b_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_L = EXT [PW_cathode_vol_gt_pos_132_CHK_lc] NSD_power_pad_within_io_pad_140_lc < LU_4_4_3b_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b_L = EXT [PW_pad_io_within_io_pad_140_lc] NSD_power_pad_within_io_pad_140_neg_lc < LU_4_4_3b_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_R = EXT PW_cathode_vol_gt_pos_132_CHK_lc [NSD_power_pad_within_io_pad_140_lc] < LU_4_4_3b_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b_R = EXT PW_pad_io_within_io_pad_140_lc [NSD_power_pad_within_io_pad_140_neg_lc] < LU_4_4_3b_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_L_gC = RW COIN EDGE err1_a_L
 err1_b_L_gC = RW COIN EDGE err1_b_L
 err1_a_R_gC = AA_c COIN EDGE err1_a_R
 err1_b_R_gC = AA_c COIN EDGE err1_b_R

 err1_a_L_NETID = DFM PROPERTY err1_a_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_a_R_NETID = DFM PROPERTY err1_a_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1_b_L_NETID = DFM PROPERTY err1_b_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_b_R_NETID = DFM PROPERTY err1_b_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1 = DFM PROPERTY err1_a err1_a_L_NETID err1_a_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_a_L_NETID)]
 [NET_b = count(err1_a_R_NETID)]
 [VH_1a = property(err1_a_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_a_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_a_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_a_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 1.32 && property_ref(DT_vA) <= 1.65) || (property_ref(DT_vB) > 1.32 && property_ref(DT_vB) <= 1.65)) ? 1 : 0] > 0

 err2 = DFM PROPERTY err1_b err1_b_L_NETID err1_b_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_b_L_NETID)]
 [NET_b = count(err1_b_R_NETID)]
 [VH_1a = property(err1_b_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_b_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_b_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_b_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 1.32 && property_ref(DT_vA) <= 1.65) || (property_ref(DT_vB) > 1.32 && property_ref(DT_vB) <= 1.65)) ? 1 : 0] > 0

 DFM COPY err1 err2
}

LU_4_4_4a_G {
@ LU.4.4: Within 14.976um from AA injector, space between Power Anode and IO NW Cathode and space between IO (PW in DNW) cathode and Power cathode when 1.65V < Delta V <= 1.98V. >= 4.512um
@ Check between IO Power Anode and IO NW Cathode
 err1_a = EXT PSD_power_anode_vol_gt_pos_165_lc NW_pad_io_within_io_pad_140_lc < LU_4_4_4a_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b = EXT PSD_power_pad_within_io_pad_140_lc NW_pad_io_within_io_pad_140_neg_lc < LU_4_4_4a_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_L = EXT [PSD_power_anode_vol_gt_pos_165_lc] NW_pad_io_within_io_pad_140_lc < LU_4_4_4a_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b_L = EXT [PSD_power_pad_within_io_pad_140_lc] NW_pad_io_within_io_pad_140_neg_lc < LU_4_4_4a_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_R = EXT PSD_power_anode_vol_gt_pos_165_lc [NW_pad_io_within_io_pad_140_lc] < LU_4_4_4a_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b_R = EXT PSD_power_pad_within_io_pad_140_lc [NW_pad_io_within_io_pad_140_neg_lc] < LU_4_4_4a_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_L_gC = AA_c COIN EDGE err1_a_L
 err1_b_L_gC = AA_c COIN EDGE err1_b_L
 err1_a_R_gC = NW COIN EDGE err1_a_R
 err1_b_R_gC = NW COIN EDGE err1_b_R

 err1_a_L_NETID = DFM PROPERTY err1_a_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_a_R_NETID = DFM PROPERTY err1_a_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1_b_L_NETID = DFM PROPERTY err1_b_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_b_R_NETID = DFM PROPERTY err1_b_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1 = DFM PROPERTY err1_a err1_a_L_NETID err1_a_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_a_L_NETID)]
 [NET_b = count(err1_a_R_NETID)]
 [VH_1a = property(err1_a_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_a_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_a_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_a_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 1.65 && property_ref(DT_vA) <= 1.98) || (property_ref(DT_vB) > 1.65 && property_ref(DT_vB) <= 1.98)) ? 1 : 0] > 0

 err2 = DFM PROPERTY err1_b err1_b_L_NETID err1_b_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_b_L_NETID)]
 [NET_b = count(err1_b_R_NETID)]
 [VH_1a = property(err1_b_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_b_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_b_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_b_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 1.65 && property_ref(DT_vA) <= 1.98) || (property_ref(DT_vB) > 1.65 && property_ref(DT_vB) <= 1.98)) ? 1 : 0] > 0

 DFM COPY err1 err2
}

LU_4_4_4b_G {
@ LU.4.4: Within 14.976um from AA injector, space between Power Anode and IO NW Cathode and space between IO (PW in DNW) cathode and Power cathode when 1.65V < Delta V <= 1.98V. >= 4.512um
@ Check between IO (PW in DNW) cathode and Power cathode
 err1_a = EXT PW_cathode_vol_gt_pos_165_CHK_lc NSD_power_pad_within_io_pad_140_lc < LU_4_4_4b_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b = EXT PW_pad_io_within_io_pad_140_lc NSD_power_pad_within_io_pad_140_neg_lc < LU_4_4_4b_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_L = EXT [PW_cathode_vol_gt_pos_165_CHK_lc] NSD_power_pad_within_io_pad_140_lc < LU_4_4_4b_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b_L = EXT [PW_pad_io_within_io_pad_140_lc] NSD_power_pad_within_io_pad_140_neg_lc < LU_4_4_4b_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_R = EXT PW_cathode_vol_gt_pos_165_CHK_lc [NSD_power_pad_within_io_pad_140_lc] < LU_4_4_4b_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b_R = EXT PW_pad_io_within_io_pad_140_lc [NSD_power_pad_within_io_pad_140_neg_lc] < LU_4_4_4b_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_L_gC = RW COIN EDGE err1_a_L
 err1_b_L_gC = RW COIN EDGE err1_b_L
 err1_a_R_gC = AA_c COIN EDGE err1_a_R
 err1_b_R_gC = AA_c COIN EDGE err1_b_R

 err1_a_L_NETID = DFM PROPERTY err1_a_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_a_R_NETID = DFM PROPERTY err1_a_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1_b_L_NETID = DFM PROPERTY err1_b_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_b_R_NETID = DFM PROPERTY err1_b_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1 = DFM PROPERTY err1_a err1_a_L_NETID err1_a_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_a_L_NETID)]
 [NET_b = count(err1_a_R_NETID)]
 [VH_1a = property(err1_a_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_a_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_a_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_a_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 1.65 && property_ref(DT_vA) <= 1.98) || (property_ref(DT_vB) > 1.65 && property_ref(DT_vB) <= 1.98)) ? 1 : 0] > 0

 err2 = DFM PROPERTY err1_b err1_b_L_NETID err1_b_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_b_L_NETID)]
 [NET_b = count(err1_b_R_NETID)]
 [VH_1a = property(err1_b_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_b_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_b_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_b_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 1.65 && property_ref(DT_vA) <= 1.98) || (property_ref(DT_vB) > 1.65 && property_ref(DT_vB) <= 1.98)) ? 1 : 0] > 0

 DFM COPY err1 err2
}

LU_4_4_5a_G {
@ LU.4.4: Within 14.976um from AA injector, space between Power Anode and IO NW Cathode and space between IO (PW in DNW) cathode and Power cathode when 1.98V < Delta V <= 2.75V. >= 7.968um
@ Check between IO Power Anode and IO NW Cathode
 err1_a = EXT PSD_power_anode_vol_gt_pos_198_lc NW_pad_io_within_io_pad_140_lc < LU_4_4_5a_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b = EXT PSD_power_pad_within_io_pad_140_lc NW_pad_io_within_io_pad_140_neg_lc < LU_4_4_5a_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_L = EXT [PSD_power_anode_vol_gt_pos_198_lc] NW_pad_io_within_io_pad_140_lc < LU_4_4_5a_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b_L = EXT [PSD_power_pad_within_io_pad_140_lc] NW_pad_io_within_io_pad_140_neg_lc < LU_4_4_5a_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_R = EXT PSD_power_anode_vol_gt_pos_198_lc [NW_pad_io_within_io_pad_140_lc] < LU_4_4_5a_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b_R = EXT PSD_power_pad_within_io_pad_140_lc [NW_pad_io_within_io_pad_140_neg_lc] < LU_4_4_5a_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_L_gC = AA_c COIN EDGE err1_a_L
 err1_b_L_gC = AA_c COIN EDGE err1_b_L
 err1_a_R_gC = NW COIN EDGE err1_a_R
 err1_b_R_gC = NW COIN EDGE err1_b_R

 err1_a_L_NETID = DFM PROPERTY err1_a_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_a_R_NETID = DFM PROPERTY err1_a_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1_b_L_NETID = DFM PROPERTY err1_b_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_b_R_NETID = DFM PROPERTY err1_b_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1 = DFM PROPERTY err1_a err1_a_L_NETID err1_a_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_a_L_NETID)]
 [NET_b = count(err1_a_R_NETID)]
 [VH_1a = property(err1_a_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_a_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_a_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_a_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 1.98 && property_ref(DT_vA) <= 2.75) || (property_ref(DT_vB) > 1.98 && property_ref(DT_vB) <= 2.75)) ? 1 : 0] > 0

 err2 = DFM PROPERTY err1_b err1_b_L_NETID err1_b_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_b_L_NETID)]
 [NET_b = count(err1_b_R_NETID)]
 [VH_1a = property(err1_b_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_b_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_b_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_b_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 1.98 && property_ref(DT_vA) <= 2.75) || (property_ref(DT_vB) > 1.98 && property_ref(DT_vB) <= 2.75)) ? 1 : 0] > 0

 DFM COPY err1 err2
}

LU_4_4_5b_G {
@ LU.4.4: Within 14.976um from AA injector, space between Power Anode and IO NW Cathode and space between IO (PW in DNW) cathode and Power cathode when 1.98V < Delta V <= 2.75V. >= 7.968um
@ Check between IO (PW in DNW) cathode and Power cathode
 err1_a = EXT PW_cathode_vol_gt_pos_198_CHK_lc NSD_power_pad_within_io_pad_140_lc < LU_4_4_5b_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b = EXT PW_pad_io_within_io_pad_140_lc NSD_power_pad_within_io_pad_140_neg_lc < LU_4_4_5b_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_L = EXT [PW_cathode_vol_gt_pos_198_CHK_lc] NSD_power_pad_within_io_pad_140_lc < LU_4_4_5b_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b_L = EXT [PW_pad_io_within_io_pad_140_lc] NSD_power_pad_within_io_pad_140_neg_lc < LU_4_4_5b_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_R = EXT PW_cathode_vol_gt_pos_198_CHK_lc [NSD_power_pad_within_io_pad_140_lc] < LU_4_4_5b_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b_R = EXT PW_pad_io_within_io_pad_140_lc [NSD_power_pad_within_io_pad_140_neg_lc] < LU_4_4_5b_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_L_gC = RW COIN EDGE err1_a_L
 err1_b_L_gC = RW COIN EDGE err1_b_L
 err1_a_R_gC = AA_c COIN EDGE err1_a_R
 err1_b_R_gC = AA_c COIN EDGE err1_b_R

 err1_a_L_NETID = DFM PROPERTY err1_a_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_a_R_NETID = DFM PROPERTY err1_a_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1_b_L_NETID = DFM PROPERTY err1_b_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_b_R_NETID = DFM PROPERTY err1_b_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1 = DFM PROPERTY err1_a err1_a_L_NETID err1_a_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_a_L_NETID)]
 [NET_b = count(err1_a_R_NETID)]
 [VH_1a = property(err1_a_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_a_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_a_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_a_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 1.98 && property_ref(DT_vA) <= 2.75) || (property_ref(DT_vB) > 1.98 && property_ref(DT_vB) <= 2.75)) ? 1 : 0] > 0

 err2 = DFM PROPERTY err1_b err1_b_L_NETID err1_b_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_b_L_NETID)]
 [NET_b = count(err1_b_R_NETID)]
 [VH_1a = property(err1_b_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_b_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_b_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_b_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 1.98 && property_ref(DT_vA) <= 2.75) || (property_ref(DT_vB) > 1.98 && property_ref(DT_vB) <= 2.75)) ? 1 : 0] > 0

 DFM COPY err1 err2
}

LU_4_4_6a_G {
@ LU.4.4: Within 14.976um from AA injector, space between Power Anode and IO NW Cathode and space between IO (PW in DNW) cathode and Power cathode when 2.75V < Delta V <= 3.63V. >= 16.032um
@ Check between IO Power Anode and IO NW Cathode
 err1_a = EXT PSD_power_anode_vol_gt_pos_275_lc NW_pad_io_within_io_pad_140_lc < LU_4_4_6a_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b = EXT PSD_power_pad_within_io_pad_140_lc NW_pad_io_within_io_pad_140_neg_lc < LU_4_4_6a_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_L = EXT [PSD_power_anode_vol_gt_pos_275_lc] NW_pad_io_within_io_pad_140_lc < LU_4_4_6a_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b_L = EXT [PSD_power_pad_within_io_pad_140_lc] NW_pad_io_within_io_pad_140_neg_lc < LU_4_4_6a_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_R = EXT PSD_power_anode_vol_gt_pos_275_lc [NW_pad_io_within_io_pad_140_lc] < LU_4_4_6a_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b_R = EXT PSD_power_pad_within_io_pad_140_lc [NW_pad_io_within_io_pad_140_neg_lc] < LU_4_4_6a_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_L_gC = AA_c COIN EDGE err1_a_L
 err1_b_L_gC = AA_c COIN EDGE err1_b_L
 err1_a_R_gC = NW COIN EDGE err1_a_R
 err1_b_R_gC = NW COIN EDGE err1_b_R

 err1_a_L_NETID = DFM PROPERTY err1_a_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_a_R_NETID = DFM PROPERTY err1_a_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1_b_L_NETID = DFM PROPERTY err1_b_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_b_R_NETID = DFM PROPERTY err1_b_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1 = DFM PROPERTY err1_a err1_a_L_NETID err1_a_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_a_L_NETID)]
 [NET_b = count(err1_a_R_NETID)]
 [VH_1a = property(err1_a_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_a_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_a_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_a_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 2.75 && property_ref(DT_vA) <= 3.63) || (property_ref(DT_vB) > 2.75 && property_ref(DT_vB) <= 3.63)) ? 1 : 0] > 0

 err2 = DFM PROPERTY err1_b err1_b_L_NETID err1_b_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_b_L_NETID)]
 [NET_b = count(err1_b_R_NETID)]
 [VH_1a = property(err1_b_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_b_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_b_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_b_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 2.75 && property_ref(DT_vA) <= 3.63) || (property_ref(DT_vB) > 2.75 && property_ref(DT_vB) <= 3.63)) ? 1 : 0] > 0

 DFM COPY err1 err2
}

LU_4_4_6b_G {
@ LU.4.4: Within 14.976um from AA injector, space between Power Anode and IO NW Cathode and space between IO (PW in DNW) cathode and Power cathode when 2.75V < Delta V <= 3.63V. >= 16.032um
@ Check between IO (PW in DNW) cathode and Power cathode
 err1_a = EXT PW_cathode_vol_gt_pos_275_CHK_lc NSD_power_pad_within_io_pad_140_lc < LU_4_4_6b_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b = EXT PW_pad_io_within_io_pad_140_lc NSD_power_pad_within_io_pad_140_neg_lc < LU_4_4_6b_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_L = EXT [PW_cathode_vol_gt_pos_275_CHK_lc] NSD_power_pad_within_io_pad_140_lc < LU_4_4_6b_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b_L = EXT [PW_pad_io_within_io_pad_140_lc] NSD_power_pad_within_io_pad_140_neg_lc < LU_4_4_6b_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_R = EXT PW_cathode_vol_gt_pos_275_CHK_lc [NSD_power_pad_within_io_pad_140_lc] < LU_4_4_6b_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b_R = EXT PW_pad_io_within_io_pad_140_lc [NSD_power_pad_within_io_pad_140_neg_lc] < LU_4_4_6b_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_L_gC = RW COIN EDGE err1_a_L
 err1_b_L_gC = RW COIN EDGE err1_b_L
 err1_a_R_gC = AA_c COIN EDGE err1_a_R
 err1_b_R_gC = AA_c COIN EDGE err1_b_R

 err1_a_L_NETID = DFM PROPERTY err1_a_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_a_R_NETID = DFM PROPERTY err1_a_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1_b_L_NETID = DFM PROPERTY err1_b_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_b_R_NETID = DFM PROPERTY err1_b_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1 = DFM PROPERTY err1_a err1_a_L_NETID err1_a_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_a_L_NETID)]
 [NET_b = count(err1_a_R_NETID)]
 [VH_1a = property(err1_a_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_a_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_a_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_a_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 2.75 && property_ref(DT_vA) <= 3.63) || (property_ref(DT_vB) > 2.75 && property_ref(DT_vB) <= 3.63)) ? 1 : 0] > 0

 err2 = DFM PROPERTY err1_b err1_b_L_NETID err1_b_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_b_L_NETID)]
 [NET_b = count(err1_b_R_NETID)]
 [VH_1a = property(err1_b_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_b_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_b_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_b_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 2.75 && property_ref(DT_vA) <= 3.63) || (property_ref(DT_vB) > 2.75 && property_ref(DT_vB) <= 3.63)) ? 1 : 0] > 0

 DFM COPY err1 err2
}

LU_4_4_7a_G {
@ LU.4.4: Within 14.976um from AA injector, space between Power Anode and IO NW Cathode and space between IO (PW in DNW) cathode and Power cathode when 3.63V < Delta V <= 5.5V. >= 35.952um
@ Check between IO Power Anode and IO NW Cathode
 err1_a = EXT PSD_power_anode_vol_gt_pos_363_lc NW_pad_io_within_io_pad_140_lc < LU_4_4_7a_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b = EXT PSD_power_pad_within_io_pad_140_lc NW_pad_io_within_io_pad_140_neg_lc < LU_4_4_7a_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_L = EXT [PSD_power_anode_vol_gt_pos_363_lc] NW_pad_io_within_io_pad_140_lc < LU_4_4_7a_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b_L = EXT [PSD_power_pad_within_io_pad_140_lc] NW_pad_io_within_io_pad_140_neg_lc < LU_4_4_7a_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_R = EXT PSD_power_anode_vol_gt_pos_363_lc [NW_pad_io_within_io_pad_140_lc] < LU_4_4_7a_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b_R = EXT PSD_power_pad_within_io_pad_140_lc [NW_pad_io_within_io_pad_140_neg_lc] < LU_4_4_7a_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_L_gC = AA_c COIN EDGE err1_a_L
 err1_b_L_gC = AA_c COIN EDGE err1_b_L
 err1_a_R_gC = NW COIN EDGE err1_a_R
 err1_b_R_gC = NW COIN EDGE err1_b_R

 err1_a_L_NETID = DFM PROPERTY err1_a_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_a_R_NETID = DFM PROPERTY err1_a_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1_b_L_NETID = DFM PROPERTY err1_b_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_b_R_NETID = DFM PROPERTY err1_b_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1 = DFM PROPERTY err1_a err1_a_L_NETID err1_a_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_a_L_NETID)]
 [NET_b = count(err1_a_R_NETID)]
 [VH_1a = property(err1_a_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_a_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_a_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_a_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 3.63 && property_ref(DT_vA) <= 5.5) || (property_ref(DT_vB) > 3.63 && property_ref(DT_vB) <= 5.5)) ? 1 : 0] > 0

 err2 = DFM PROPERTY err1_b err1_b_L_NETID err1_b_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_b_L_NETID)]
 [NET_b = count(err1_b_R_NETID)]
 [VH_1a = property(err1_b_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_b_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_b_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_b_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 3.63 && property_ref(DT_vA) <= 5.5) || (property_ref(DT_vB) > 3.63 && property_ref(DT_vB) <= 5.5)) ? 1 : 0] > 0

 DFM COPY err1 err2
}

LU_4_4_7b_G {
@ LU.4.4: Within 14.976um from AA injector, space between Power Anode and IO NW Cathode and space between IO (PW in DNW) cathode and Power cathode when 3.63V < Delta V <= 5.5V. >= 35.952um
@ Check between IO (PW in DNW) cathode and Power cathode
 err1_a = EXT PW_cathode_vol_gt_pos_363_CHK_lc NSD_power_pad_within_io_pad_140_lc < LU_4_4_7b_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b = EXT PW_pad_io_within_io_pad_140_lc NSD_power_pad_within_io_pad_140_neg_lc < LU_4_4_7b_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_L = EXT [PW_cathode_vol_gt_pos_363_CHK_lc] NSD_power_pad_within_io_pad_140_lc < LU_4_4_7b_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b_L = EXT [PW_pad_io_within_io_pad_140_lc] NSD_power_pad_within_io_pad_140_neg_lc < LU_4_4_7b_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_R = EXT PW_cathode_vol_gt_pos_363_CHK_lc [NSD_power_pad_within_io_pad_140_lc] < LU_4_4_7b_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b_R = EXT PW_pad_io_within_io_pad_140_lc [NSD_power_pad_within_io_pad_140_neg_lc] < LU_4_4_7b_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_L_gC = RW COIN EDGE err1_a_L
 err1_b_L_gC = RW COIN EDGE err1_b_L
 err1_a_R_gC = AA_c COIN EDGE err1_a_R
 err1_b_R_gC = AA_c COIN EDGE err1_b_R

 err1_a_L_NETID = DFM PROPERTY err1_a_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_a_R_NETID = DFM PROPERTY err1_a_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1_b_L_NETID = DFM PROPERTY err1_b_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_b_R_NETID = DFM PROPERTY err1_b_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1 = DFM PROPERTY err1_a err1_a_L_NETID err1_a_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_a_L_NETID)]
 [NET_b = count(err1_a_R_NETID)]
 [VH_1a = property(err1_a_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_a_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_a_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_a_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 3.63 && property_ref(DT_vA) <= 5.5) || (property_ref(DT_vB) > 3.63 && property_ref(DT_vB) <= 5.5)) ? 1 : 0] > 0

 err2 = DFM PROPERTY err1_b err1_b_L_NETID err1_b_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_b_L_NETID)]
 [NET_b = count(err1_b_R_NETID)]
 [VH_1a = property(err1_b_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_b_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_b_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_b_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 3.63 && property_ref(DT_vA) <= 5.5) || (property_ref(DT_vB) > 3.63 && property_ref(DT_vB) <= 5.5)) ? 1 : 0] > 0

 DFM COPY err1 err2
}
#ENDIF
#ENDIF

#IFDEF LATCH_UP_RULES_CHECK 125
//;ACT
LUWMK1_OCCDFH = OR LUWMK1 OCCDFH
AACT_io_pad_dev = (OR Ptype_io_pad_CHK Ntype_io_pad_CHK) NOT INSIDE LUWMK1_OCCDFH
#IFDEF LATCH_UP_CHECK_MODE ACCURATE
AACT_io_pad_dev_SWELL_14 = SIZE AACT_io_pad_dev BY 14.976 INSIDE OF DRC:1 STEP 4 BEVEL 3
AACT_io_pad_dev_SWELL_30 = SIZE AACT_io_pad_dev BY 30 INSIDE OF DRC:1 STEP 5 BEVEL 3
#ENDIF
#IFDEF LATCH_UP_CHECK_MODE FAST
AACT_io_pad_dev_SWELL_14 = SIZE AACT_io_pad_dev BY 14.976 INSIDE OF DRC:1 STEP 5
AACT_io_pad_dev_SWELL_30 = SIZE AACT_io_pad_dev BY 30 INSIDE OF DRC:1 STEP 5
#ENDIF
AACT_real_non_io_pad_within_io_pad_dev_SWELL_14 = ((ACT AND AA_c) INTERACT AACT_io_pad_dev_SWELL_14) NOT AACT_io_pad_dev
NACT_real_non_io_pad_within_io_pad_dev_SWELL_14 = (NACT NOT OUTSIDE AACT_real_non_io_pad_within_io_pad_dev_SWELL_14) NOT AACT_MOS_floating
PACT_real_non_io_pad_within_io_pad_dev_SWELL_14 = (PACT NOT OUTSIDE AACT_real_non_io_pad_within_io_pad_dev_SWELL_14) NOT AACT_MOS_floating  //;LU.2
NWELL_within_io_pad_dev_SWELL_14 = NW INTERACT AACT_io_pad_dev_SWELL_14

AACT_real_non_io_pad_within_io_pad_dev_SWELL_30 = ((ACT AND AA_c) INTERACT AACT_io_pad_dev_SWELL_30) NOT AACT_io_pad_dev
NACT_real_non_io_pad_within_io_pad_dev_SWELL_30 = (NACT NOT OUTSIDE AACT_real_non_io_pad_within_io_pad_dev_SWELL_30) NOT AACT_MOS_floating
PACT_real_non_io_pad_within_io_pad_dev_SWELL_30 = (PACT NOT OUTSIDE AACT_real_non_io_pad_within_io_pad_dev_SWELL_30) NOT AACT_MOS_floating  //;LU.2
NWELL_within_io_pad_dev_SWELL_30 = NW INTERACT AACT_io_pad_dev_SWELL_30

//;PSD/PTAP_in_RWDIO
Ptype_io_pad_vol_pos_CHK = NET AREA RATIO Ptype_io_pad_CHK AA_NETID_vol_pos > 0
Ntype_io_pad_vol_neg_CHK = NET AREA RATIO Ntype_io_pad_CHK AA_NETID_vol_neg > 0

//;NETID for lu.4.1~4
Ptype_power_pad_CHK = AA_c AND Ptype_power_pad  //;Power +
Ntype_power_pad_CHK = AA_c AND Ntype_power_pad  //;Power -
Ptype_power_pad_NETID = DFM PROPERTY Ptype_power_pad_CHK net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
Ntype_power_pad_NETID = DFM PROPERTY Ntype_power_pad_CHK net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

Ptype_power_pad_vol_pos_CHK = NET AREA RATIO Ptype_power_pad_CHK AA_NETID_vol_pos > 0
Ntype_power_pad_vol_neg_CHK = NET AREA RATIO Ntype_power_pad_CHK AA_NETID_vol_neg > 0

//;RW/NW connect to io pad
RW_anode_CHK = NET AREA RATIO RW M1_power > 0  //; PW anode
NW_cathode_CHK = NET AREA RATIO NW M1_power > 0  //; NW Cathode

RW_anode_NETID = DFM PROPERTY RW_anode_CHK net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
NW_cathode_NETID = DFM PROPERTY NW_cathode_CHK net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

RW_anode_vol_pos_CHK = NET AREA RATIO RW_anode_CHK PW_NETID_vol_pos > 0
NW_cathode_vol_neg_CHK = NET AREA RATIO NW_cathode_CHK NW_NETID_vol_neg > 0

//;pick-up ring derivation
NTAP_device_terminal = NTAP INTERACT (OR NWRT NTAP_io_pad_NWDIO_CHK NTAP_io_pad_NVART_CHK GATED_SOURCE_SIDE)
PTAP_device_terminal = PTAP INTERACT (OR NWRT PTAP_io_pad_RWDIO_CHK PTAP_io_pad_PVART_CHK GATED_SOURCE_SIDE)
NTAP_union_merged = SIZE (NTAP NOT INTERACT NTAP_device_terminal) BY 0.576/2 OVERUNDER
PTAP_union_merged = SIZE (PTAP NOT INTERACT PTAP_device_terminal) BY 0.576/2 OVERUNDER
NTAP_union_RAW = (NTAP_union_merged AND SN) AND NW
PTAP_union_RAW = (PTAP_union_merged AND SP) NOT NW
NTAP_union_ring = DONUT NTAP_union_RAW
PTAP_union_ring = DONUT PTAP_union_RAW

NTAP_gR_en_PACT_RAW = HOLES NTAP_union_ring INNER
PTAP_gR_en_NACT_RAW = HOLES PTAP_union_ring INNER
NTAP_gR_en_PACT_rings = NTAP_union_ring TOUCH NTAP_gR_en_PACT_RAW
PTAP_gR_en_NACT_rings = PTAP_union_ring TOUCH PTAP_gR_en_NACT_RAW
NTAP_gR_en_PACT = OR (NTAP_gR_en_PACT_RAW INSIDE NW_0) ((NTAP_gR_en_PACT_RAW INTERACT GATED_DIODE_ESD_ACT) NOT INTERACT (ACT NOT INTERACT GATED_DIODE_ESD_ACT)) //;holes
PTAP_gR_en_NACT = OR (PTAP_gR_en_NACT_RAW INSIDE PW_0) ((PTAP_gR_en_NACT_RAW INTERACT GATED_DIODE_ESD_ACT) NOT INTERACT (ACT NOT INTERACT GATED_DIODE_ESD_ACT))

PWPU_gR_rings_ALL = (PW_0 NOT PTAP_union_ring) NOT WITH EDGE (PW_0 NOT COIN OUTSIDE EDGE NW)
PWPU_gR_rings_TMP = (HOLES PWPU_gR_rings_ALL INNER) NOT INTERACT PTAP
PWPU_gR_rings_TMP_a = PWPU_gR_rings_ALL INTERACT PWPU_gR_rings_TMP
PWPU_gR_rings_TMP_b = (PWPU_gR_rings_TMP_a NOT PTAP_gR_en_NACT) TOUCH PTAP_gR_en_NACT_rings
PWPU_gR_rings_PSV = ((PWPU_gR_rings_TMP_b OR (HOLES PWPU_gR_rings_TMP_b INNER)) INTERACT (OR NWRT GATED_DIODE_ESD_NSD NTAP_in_NWDIO NTAP_in_NVART)) NOT ENCLOSE PSD
PWPU_gR_rings_MOS = (PWPU_gR_rings_ALL NOT WITH EDGE (PWPU_gR_rings_ALL COIN OUTSIDE EDGE NW)) NOT ENCLOSE PSD
PWPU_gR_rings = OR PWPU_gR_rings_PSV PWPU_gR_rings_MOS

NWPU_gR_rings_ALL = (NW NOT NTAP_union_ring) NOT WITH EDGE (NW NOT COIN OUTSIDE EDGE PW_0)
NWPU_gR_rings_TMP = (HOLES NWPU_gR_rings_ALL INNER) NOT INTERACT NTAP
NWPU_gR_rings_TMP_a = NWPU_gR_rings_ALL INTERACT NWPU_gR_rings_TMP
NWPU_gR_rings_TMP_b = (NWPU_gR_rings_TMP_a NOT NTAP_gR_en_PACT) TOUCH NTAP_gR_en_PACT_rings
NWPU_gR_rings_PSV = ((NWPU_gR_rings_TMP_b OR (HOLES NWPU_gR_rings_TMP_b INNER)) INTERACT (OR NWRT GATED_DIODE_ESD_PSD PTAP_in_RWDIO PTAP_in_PVART)) NOT ENCLOSE NSD
NWPU_gR_rings_MOS = (NWPU_gR_rings_ALL NOT WITH EDGE (NWPU_gR_rings_ALL COIN OUTSIDE EDGE PW_0)) NOT ENCLOSE NSD
NWPU_gR_rings = OR NWPU_gR_rings_PSV NWPU_gR_rings_MOS

NTAP_gR_rings_all = OR NTAP_gR_en_PACT NWPU_gR_rings
PTAP_gR_rings_all = OR PTAP_gR_en_NACT PWPU_gR_rings

//;For automotive
NTAP_union_merged_auto = SIZE (NTAP NOT INTERACT (OR NTAP_device_terminal Ntype_io_pad)) BY 0.576/2 OVERUNDER
PTAP_union_merged_auto = SIZE (PTAP NOT INTERACT (OR PTAP_device_terminal Ptype_io_pad)) BY 0.576/2 OVERUNDER
NTAP_union_ring_auto = DONUT ((NTAP_union_merged_auto AND SN) AND NW)
PTAP_union_ring_auto = DONUT ((PTAP_union_merged_auto AND SP) NOT NW)
NTAP_gR_innerHole_auto = HOLES NTAP_union_ring_auto INNER
PTAP_gR_innerHole_auto = HOLES PTAP_union_ring_auto INNER
NTAP_gR_innerRing_auto = NTAP_union_ring_auto TOUCH NTAP_gR_innerHole_auto
PTAP_gR_innerRing_auto = PTAP_union_ring_auto TOUCH PTAP_gR_innerHole_auto

PWPU_gR_innerRing_ALL_auto = (PW_0 NOT PTAP_union_ring_auto) NOT WITH EDGE (PW_0 NOT COIN OUTSIDE EDGE NW)
PWPU_gR_innerRing_TMP_auto = PWPU_gR_innerRing_ALL_auto INTERACT (HOLES PWPU_gR_innerRing_ALL_auto INNER)
PWPU_gR_innerRing_hole_auto = (PWPU_gR_innerRing_ALL_auto NOT WITH EDGE (PWPU_gR_innerRing_ALL_auto COIN OUTSIDE EDGE NW)) NOT ENCLOSE PSD

NWPU_gR_innerRing_ALL_auto = (NW NOT NTAP_union_ring_auto) NOT WITH EDGE (NW NOT COIN OUTSIDE EDGE PW_0)
NWPU_gR_innerRing_TMP_auto = NWPU_gR_innerRing_ALL_auto INTERACT (HOLES NWPU_gR_innerRing_ALL_auto INNER)
NWPU_gR_innerRing_hole_auto = (NWPU_gR_innerRing_ALL_auto NOT WITH EDGE (NWPU_gR_innerRing_ALL_auto COIN OUTSIDE EDGE PW_0)) NOT ENCLOSE NSD

NTAP_gR_innerHole_all_auto = OR NTAP_gR_innerHole_auto NWPU_gR_innerRing_hole_auto
PTAP_gR_innerHole_all_auto = OR PTAP_gR_innerHole_auto PWPU_gR_innerRing_hole_auto
NTAP_gR_innerRing_all_auto = OR NTAP_gR_innerRing_auto NWPU_gR_innerRing_hole_auto
PTAP_gR_innerRing_all_auto = OR PTAP_gR_innerRing_auto PWPU_gR_innerRing_hole_auto

NTAP_union_outer_merged_auto = SIZE (NTAP NOT INTERACT (OR NTAP_device_terminal Ntype_io_pad NTAP_gR_innerHole_auto)) BY 0.576/2 OVERUNDER
PTAP_union_outer_merged_auto = SIZE (PTAP NOT INTERACT (OR PTAP_device_terminal Ptype_io_pad PTAP_gR_innerHole_auto)) BY 0.576/2 OVERUNDER
NTAP_union_outer_ring_auto = DONUT ((NTAP_union_outer_merged_auto AND SN) AND NW)
PTAP_union_outer_ring_auto = DONUT ((PTAP_union_outer_merged_auto AND SP) NOT NW)
NTAP_gR_outerHole_auto = HOLES NTAP_union_outer_ring_auto INNER
PTAP_gR_outerHole_auto = HOLES PTAP_union_outer_ring_auto INNER
NTAP_gR_outerRing_auto = NTAP_union_outer_ring_auto TOUCH NTAP_gR_outerHole_auto
PTAP_gR_outerRing_auto = PTAP_union_outer_ring_auto TOUCH PTAP_gR_outerHole_auto

PWPU_gR_outerRing_ALL_auto = (PW_0 NOT PTAP_union_ring_auto) NOT WITH EDGE (PW_0 NOT COIN OUTSIDE EDGE NW)
PWPU_gR_outerRing_TMP_auto = PWPU_gR_outerRing_ALL_auto INTERACT (HOLES PWPU_gR_outerRing_ALL_auto INNER)
PWPU_gR_outerRing_hole_auto = (PWPU_gR_outerRing_ALL_auto NOT WITH EDGE (PWPU_gR_outerRing_ALL_auto COIN OUTSIDE EDGE NW)) NOT ENCLOSE PSD

NWPU_gR_outerRing_ALL_auto = (NW NOT NTAP_union_ring_auto) NOT WITH EDGE (NW NOT COIN OUTSIDE EDGE PW_0)
NWPU_gR_outerRing_TMP_auto = NWPU_gR_outerRing_ALL_auto INTERACT (HOLES NWPU_gR_outerRing_ALL_auto INNER)
NWPU_gR_outerRing_hole_auto = (NWPU_gR_outerRing_ALL_auto NOT WITH EDGE (NWPU_gR_outerRing_ALL_auto COIN OUTSIDE EDGE PW_0)) NOT ENCLOSE NSD

NTAP_gR_outerHole_all_auto = OR NTAP_gR_outerHole_auto NWPU_gR_outerRing_hole_auto
PTAP_gR_outerHole_all_auto = OR PTAP_gR_outerHole_auto PWPU_gR_outerRing_hole_auto
NTAP_gR_outerRing_all_auto = OR NTAP_gR_outerRing_auto NWPU_gR_outerRing_hole_auto
PTAP_gR_outerRing_all_auto = OR PTAP_gR_outerRing_auto PWPU_gR_outerRing_hole_auto

NTAP_gR_en_RWDIO = (NTAP_gR_en_PACT_RAW NOT ENCLOSE NSD) INTERACT PTAP_io_pad_RWDIO_CHK  //;NTAP hole of rwdio (injector connect to IO pad)
PTAP_gR_en_NWDIO = (PTAP_gR_en_NACT_RAW NOT ENCLOSE PSD) INTERACT NTAP_io_pad_NWDIO_CHK  //;PTAP hole of nwdio (injector connect to IO pad)
NTAP_gR_en_PVART = (NWPU_gR_rings NOT ENCLOSE NSD) INTERACT PTAP_io_pad_PVART_CHK
PTAP_gR_en_NVART = (PWPU_gR_rings NOT ENCLOSE PSD) INTERACT NTAP_io_pad_NVART_CHK


// =======================================================
// Latch-Up (85~125 C) prevention layout guidelines
// =======================================================
// Important notice from dorian: any new device added in DRM, please make sure DRC already covered it in latch-up check
// IO Anode => ((SP AND AA) NOT GT) directly connected to I/O pad
// IO Cathode => ((SN AND AA) NOT GT) directly connected to I/O pad
// Power Anode => ((SP AND AA) NOT GT) directly connected to Vdd/Vss pad
// Power Cathode => ((SN AND AA) NOT GT) directly connected to Vdd/Vss pad
// PW Anode => PW in DNW directly connected to Vdd/Vss pad
// NW Cathode => NW directly connected to Vdd/Vss pad

PSD_PURELY = real_PSD NOT DIOMK2  //; SN/SP abutting on gated diode device
NSD_PURELY = real_NSD NOT DIOMK2

GROUP GLU LU_?

LU_1_G {
@ Every AA injector must be surrounded by two guard-dings.
@ That is:
@ N+ AA injector is surrounded by a P+ guard-ring, and this P+ guard-ring is surrounded by a N+ guard-ring
@ P+ AA injector is surrounded by a N+ guard-ring, and this N+ guard-ring is surrounded by a P+ guard-ring
@ NW/PW pickups rings can be used as guard rings
@ DRC doesn't check OCCDFH region
 err1_append_inner = Ntype_io_pad_CHK NOT (PTAP_gR_innerHole_all_auto NOT ENCLOSE PSD_PURELY)
 err2_append_inner = Ptype_io_pad_CHK NOT (NTAP_gR_innerHole_all_auto NOT ENCLOSE NSD_PURELY)
 err3_append_outer = Ntype_io_pad_CHK NOT (NTAP_gR_innerHole_all_auto NOT ENCLOSE PSD_PURELY)
 err4_append_outer = Ptype_io_pad_CHK NOT (PTAP_gR_innerHole_all_auto NOT ENCLOSE NSD_PURELY)

 err1_append_inner NOT LUWMK1_OCCDFH
 err2_append_inner NOT LUWMK1_OCCDFH
 err3_append_outer NOT LUWMK1_OCCDFH
 err4_append_outer NOT LUWMK1_OCCDFH
}

P_injector_vol = DFM PROPERTY Ptype_io_pad_CHK net_vol_assign NODAL MULTI [-= (property(net_vol_assign, max_vol) >= 2.5 || property(net_vol_assign, min_vol) <= -2.5) ? 1 : 0] > 0
N_injector_vol = DFM PROPERTY Ntype_io_pad_CHK net_vol_assign NODAL MULTI [-= (property(net_vol_assign, max_vol) >= 2.5 || property(net_vol_assign, min_vol) <= -2.5) ? 1 : 0] > 0

N_intector_vol_gR_3rd_outer = PTAP_gR_outerHole_all_auto ENCLOSE NTAP_gR_innerHole_all_auto
P_intector_vol_gR_3rd_outer = NTAP_gR_outerHole_all_auto ENCLOSE PTAP_gR_innerHole_all_auto

LU_1_2_G {
@ If Delta V >= 2.5V, one additional P+ strap and one additional N+ strap are required to be inserted between the straps of LU.1.1
 err1_append = N_injector_vol NOT N_intector_vol_gR_3rd_outer
 err2_append = P_injector_vol NOT P_intector_vol_gR_3rd_outer
 err1_append NOT LUWMK1_OCCDFH
 err2_append NOT LUWMK1_OCCDFH
}

LU_1_3_G {
@ DNW interact with IO Anode must be surrounded by P+ guard-ring. Internal Circuit placed between DNW and this guard-ring is not allowed
 chk_DNW = DNW INTERACT Ptype_io_pad_CHK
 chk_DNW_RING_bwtween = ((PTAP_gR_innerHole_all_auto NOT DNW) TOUCH chk_DNW) TOUCH PTAP_gR_innerRing_all_auto
 err1 = chk_DNW NOT (PTAP_gR_innerHole_all_auto NOT ENCLOSE NSD_PURELY)
 err2 = chk_DNW_RING_bwtween INTERACT SD
 err3 = SD AND chk_DNW_RING_bwtween
 err1 NOT LUWMK1_OCCDFH
 err2 NOT LUWMK1_OCCDFH
 err3 NOT LUWMK1_OCCDFH
}

LU_2_G {
@ Within 30um from AA injector, a NMOS group must be surrounded by a P+ guard-ring; a PMOS group must be surrounded by a N+ guard-ring
@ The following cases are excluded:
@ 1. The MOS AA is covered by LUWMK1
@ 2. The MOS AA is floating. (DRC recognize MOS AA without V0 connection as floating MOS AA)
@ 3. The NMOS is inside DNW, and this DNW does not physically interact with PMOS NW. At the same time, voltage of the DNW >= voltage of PMOS NW
@ 4. OCCDFH region
 err1 = NACT_real_non_io_pad_within_io_pad_dev_SWELL_30 NOT PTAP_gR_rings_all
 err2 = PACT_real_non_io_pad_within_io_pad_dev_SWELL_30 NOT NTAP_gR_rings_all

 err1 NOT (OR LUWMK1_OCCDFH AACT_MOS_floating)
 err2 NOT (OR LUWMK1_OCCDFH AACT_MOS_floating)
}

LU_3_G {
@ Within 14.976um from AA injector, if two NW are with different potential, a PW strap must be inserted between these NWs, (DRC only check NWs space <= 29.952um), except OCCDFH region
 NWELL_net_VOL_ERR = EXT NWELL_within_io_pad_dev_SWELL_14 < 29.952 NOT CONNECTED EXCLUDE SHIELDED
 NWELL_net_VOL_EDG = NWELL_within_io_pad_dev_SWELL_14 COIN EDGE (DFM COPY NWELL_net_VOL_ERR EDGE)
 NWELL_net_VOL_NETID = DFM PROPERTY NWELL_net_VOL_EDG net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)]

 NWELL_net_VOL_CHK_TMP = DFM PROPERTY NWELL_net_VOL_ERR NWELL_net_VOL_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(NWELL_net_VOL_NETID)]
 [VH_a1 = property(NWELL_net_VOL_NETID, "max_vol", 1)]
 [VH_a2 = property(NWELL_net_VOL_NETID, "max_vol", 2)]
 [DT_vA = fmax(abs(property_ref(VH_a1) - property_ref(VH_a2)))] > 0

 NWELL_net_VOL_CHK = NWELL_net_VOL_EDG COIN EDGE (DFM COPY NWELL_net_VOL_CHK_TMP EDGE)
 NWELL_net_VOL = DFM DV NWELL_net_VOL_EDG < 29.952 DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "nosync" > 0 ANNOTATE NOT CONNECTED
 NWELL_net_VOL_SIDE = DFM COPY NWELL_net_VOL EDGE
 NWELL_net_VOL_BAD = NWELL_net_VOL_CHK COIN EDGE (EXT (NWELL_net_VOL_SIDE) PTAP_union_RAW < 29.952 ABUT<90 OPPOSITE EXCLUDE SHIELDED)
 err1 = DFM DV NWELL_net_VOL_CHK NWELL_net_VOL_BAD < 29.952 DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "nosync" > 0 ANNOTATE NOT CONNECTED OPPOSITE
 DFM COPY err1
}

//;For lu.7~9/11
ACT_active_nmos = (AACT_MOS_area AND SN) INTERACT M0_0
ACT_active_nmos_sd = ACT_active_nmos NOT GATE_raw

ACT_active_pmos = (AACT_MOS_area AND SP) INTERACT M0_0
ACT_active_pmos_sd = ACT_active_pmos NOT GATE_raw

acti_PTAP = PTAP INTERACT M0_0
acti_NTAP = NTAP INTERACT M0_0

#IFDEF LATCH_UP_CHECK_MODE ACCURATE
VARIABLE LU_Well_STEP 0.15  //;based on minimum Well space and AA enclosure
#ENDIF
#IFDEF LATCH_UP_CHECK_MODE FAST
VARIABLE LU_Well_STEP 0.22  //;based on minimum Well space and AA enclosure
#ENDIF

//;For nmos check
pw_step_i = ACT_active_nmos_sd NOT INSIDE OCCDFH
pw_step_1 = SIZE acti_PTAP BY 5 INSIDE OF PW_0 STEP LU_Well_STEP TRUNCATE LU_Well_STEP
pw_nmos_1_bad = pw_step_i NOT INSIDE pw_step_1
pw_nmos_1 = pw_step_1 INTERACT (PW_0 INTERACT pw_nmos_1_bad)
pw_step_2 = SIZE pw_nmos_1 BY 5 INSIDE OF PW_0 STEP LU_Well_STEP TRUNCATE LU_Well_STEP
pw_nmos_2_bad = pw_step_i NOT INSIDE pw_step_2
pw_nmos_2 = pw_step_2 INTERACT (PW_0 INTERACT pw_nmos_2_bad)

pw_step_3 = SIZE pw_nmos_2 BY 5 INSIDE OF PW_0 STEP LU_Well_STEP TRUNCATE LU_Well_STEP
pw_nmos_3_bad = pw_step_i NOT INSIDE pw_step_3
pw_nmos_3 = pw_step_3 INTERACT (PW_0 INTERACT pw_nmos_3_bad)
pw_step_4 = SIZE pw_nmos_3 BY 5 INSIDE OF PW_0 STEP LU_Well_STEP TRUNCATE LU_Well_STEP
pw_nmos_4_bad = pw_step_i NOT INSIDE pw_step_4
pw_nmos_4 = pw_step_4 INTERACT (PW_0 INTERACT pw_nmos_4_bad)

pw_step_5 = SIZE pw_nmos_4 BY 5 INSIDE OF PW_0 STEP LU_Well_STEP TRUNCATE LU_Well_STEP
pw_nmos_5_bad = pw_step_i NOT INSIDE pw_step_5
pw_nmos_5 = pw_step_5 INTERACT (PW_0 INTERACT pw_nmos_5_bad)
pw_step_6 = SIZE pw_nmos_5 BY 5 INSIDE OF PW_0 STEP LU_Well_STEP TRUNCATE LU_Well_STEP
pw_nmos_6_bad = pw_step_i NOT INSIDE pw_step_6
pw_nmos_6 = pw_step_6 INTERACT (PW_0 INTERACT pw_nmos_6_bad)

pw_step_7 = SIZE pw_nmos_6 BY 5 INSIDE OF PW_0 STEP LU_Well_STEP TRUNCATE LU_Well_STEP
pw_nmos_7_bad = pw_step_i NOT INSIDE pw_step_7
pw_nmos_7 = pw_step_7 INTERACT (PW_0 INTERACT pw_nmos_7_bad)
pw_step_8 = SIZE pw_nmos_7 BY 5 INSIDE OF PW_0 STEP LU_Well_STEP TRUNCATE LU_Well_STEP
pw_nmos_8_bad = pw_step_i NOT INSIDE pw_step_8
pw_nmos_8 = pw_step_8 INTERACT (PW_0 INTERACT pw_nmos_8_bad)

pw_step_9 = SIZE pw_nmos_8 BY 5 INSIDE OF PW_0 STEP LU_Well_STEP TRUNCATE LU_Well_STEP
pw_nmos_9_bad = pw_step_i NOT INSIDE pw_step_9
pw_nmos_9 = pw_step_9 INTERACT (PW_0 INTERACT pw_nmos_9_bad)
pw_step_0 = SIZE pw_nmos_9 BY 5 INSIDE OF PW_0 STEP LU_Well_STEP TRUNCATE LU_Well_STEP

//;For pmos check
nw_step_i = ACT_active_pmos_sd NOT INSIDE OCCDFH
nw_step_1 = SIZE acti_NTAP BY 5 INSIDE OF NW STEP LU_Well_STEP TRUNCATE LU_Well_STEP
nw_pmos_1_bad = nw_step_i NOT INSIDE nw_step_1
nw_pmos_1 = nw_step_1 INTERACT (NW INTERACT nw_pmos_1_bad)
nw_step_2 = SIZE nw_pmos_1 BY 5 INSIDE OF NW STEP LU_Well_STEP TRUNCATE LU_Well_STEP
nw_pmos_2_bad = nw_step_i NOT INSIDE nw_step_2
nw_pmos_2 = nw_step_2 INTERACT (NW INTERACT nw_pmos_2_bad)

nw_step_3 = SIZE nw_pmos_2 BY 5 INSIDE OF NW STEP LU_Well_STEP TRUNCATE LU_Well_STEP
nw_pmos_3_bad = nw_step_i NOT INSIDE nw_step_3
nw_pmos_3 = nw_step_3 INTERACT (NW INTERACT nw_pmos_3_bad)
nw_step_4 = SIZE nw_pmos_3 BY 5 INSIDE OF NW STEP LU_Well_STEP TRUNCATE LU_Well_STEP
nw_pmos_4_bad = nw_step_i NOT INSIDE nw_step_4
nw_pmos_4 = nw_step_4 INTERACT (NW INTERACT nw_pmos_4_bad)

nw_step_5 = SIZE nw_pmos_4 BY 5 INSIDE OF NW STEP LU_Well_STEP TRUNCATE LU_Well_STEP
nw_pmos_5_bad = nw_step_i NOT INSIDE nw_step_5
nw_pmos_5 = nw_step_5 INTERACT (NW INTERACT nw_pmos_5_bad)
nw_step_6 = SIZE nw_pmos_5 BY 5 INSIDE OF NW STEP LU_Well_STEP TRUNCATE LU_Well_STEP
nw_pmos_6_bad = nw_step_i NOT INSIDE nw_step_6
nw_pmos_6 = nw_step_6 INTERACT (NW INTERACT nw_pmos_6_bad)

nw_step_7 = SIZE nw_pmos_6 BY 5 INSIDE OF NW STEP LU_Well_STEP TRUNCATE LU_Well_STEP
nw_pmos_7_bad = nw_step_i NOT INSIDE nw_step_7
nw_pmos_7 = nw_step_7 INTERACT (NW INTERACT nw_pmos_7_bad)
nw_step_8 = SIZE nw_pmos_7 BY 5 INSIDE OF NW STEP LU_Well_STEP TRUNCATE LU_Well_STEP
nw_pmos_8_bad = nw_step_i NOT INSIDE nw_step_8
nw_pmos_8 = nw_step_8 INTERACT (NW INTERACT nw_pmos_8_bad)

nw_step_9 = SIZE nw_pmos_8 BY 5 INSIDE OF NW STEP LU_Well_STEP TRUNCATE LU_Well_STEP
nw_pmos_9_bad = nw_step_i NOT INSIDE nw_step_9
nw_pmos_9 = nw_step_9 INTERACT (NW INTERACT nw_pmos_9_bad)
nw_step_0 = SIZE nw_pmos_9 BY 5 INSIDE OF NW STEP LU_Well_STEP TRUNCATE LU_Well_STEP

LU_5_G_NMOS {
@ Space from any point within the S/D region to the nearest pickup AA region inside the same well for I/O and internal circuits, except OCCDFH region <= 25um
 err1 = (pw_step_i NOT INSIDE OCCDFH) OUTSIDE EDGE (OR pw_step_1 pw_step_2 pw_step_3 pw_step_4 pw_step_5)
 err1 NOT INSIDE EDGE OCCDFH
}

LU_5_G_PMOS {
@ Space from any point within the S/D region to the nearest pickup AA region inside the same well for I/O and internal circuits, except OCCDFH region <= 25um
 err1 = (nw_step_i NOT INSIDE OCCDFH) OUTSIDE EDGE (OR nw_step_1 nw_step_2 nw_step_3 nw_step_4 nw_step_5)
 err1 NOT INSIDE EDGE OCCDFH
}

//;LU.6[NC] All the guard rings and pickups should be connected to VDD/VSS with low series resistance. Contacts and Vias should be used as many as possible
//;LU.6.2[NC] Additional NW and PW strap width of LU.1.1 > 0.096um
//;LU.6.4[NC] PW strap width of LU.3 > 0.096um
//;LU.6.5 DRC will recognize a complete guard-ring when AA space <= 0.576um and parallel run length >= 0.192um

pmos_io_pad_NTAP_gR = NTAP_gR_rings_all INTERACT PSD_io_pad_CHK
nmos_io_pad_PTAP_gR = PTAP_gR_rings_all INTERACT NSD_io_pad_CHK

LU_6_1_LU_1_G {
@ Guard-ring width of LU.1, LU.1.2 and LU.1.3 > 0.192um
@ ths rule check is for LU.1
@ LU.6.5: DRC will recognize a complete guard-ring when AA space <= 0.576um and parallel run length >= 0.192um
 Ntype_1st_ring = PTAP_gR_innerHole_all_auto ENCLOSE Ntype_io_pad_CHK
 Ptype_1st_ring = NTAP_gR_innerHole_all_auto ENCLOSE Ptype_io_pad_CHK
 Ntype_2nd_ring = NTAP_gR_innerHole_all_auto ENCLOSE Ntype_io_pad_CHK
 Ptype_2nd_ring = PTAP_gR_innerHole_all_auto ENCLOSE Ptype_io_pad_CHK

 Ntype_1st_inner_GR = PTAP_gR_innerRing_auto TOUCH Ntype_1st_ring
 Ptype_1st_inner_GR = NTAP_gR_innerRing_auto TOUCH Ptype_1st_ring
 Ntype_2nd_inner_GR = NTAP_gR_innerRing_auto TOUCH Ntype_2nd_ring
 Ptype_2nd_inner_GR = PTAP_gR_innerRing_auto TOUCH Ptype_2nd_ring

 Ntype_1st_inner_EDGE = PTAP_gR_innerRing_auto TOUCH EDGE Ntype_1st_ring
 Ptype_1st_inner_EDGE = NTAP_gR_innerRing_auto TOUCH EDGE Ptype_1st_ring
 Ntype_2nd_inner_EDGE = NTAP_gR_innerRing_auto TOUCH EDGE Ntype_2nd_ring
 Ptype_2nd_inner_EDGE = PTAP_gR_innerRing_auto TOUCH EDGE Ptype_2nd_ring

 err1 = Ntype_1st_inner_EDGE COIN EDGE (INT [Ntype_1st_inner_GR] <= 0.192 ABUT<90 SINGULAR)
 err2 = Ptype_1st_inner_EDGE COIN EDGE (INT [Ptype_1st_inner_GR] <= 0.192 ABUT<90 SINGULAR)
 err3 = Ntype_2nd_inner_EDGE COIN EDGE (INT [Ntype_2nd_inner_GR] <= 0.192 ABUT<90 SINGULAR)
 err4 = Ptype_2nd_inner_EDGE COIN EDGE (INT [Ptype_2nd_inner_GR] <= 0.192 ABUT<90 SINGULAR)

 err1 NOT INSIDE EDGE LUWMK1_OCCDFH
 err2 NOT INSIDE EDGE LUWMK1_OCCDFH
 err3 NOT INSIDE EDGE LUWMK1_OCCDFH
 err4 NOT INSIDE EDGE LUWMK1_OCCDFH
}

LU_6_1_LU_2_G {
@ Guard-ring width of LU.1, LU.1.2 and LU.1.3 > 0.192um
@ ths rule check is for LU.2
@ LU.6.5: DRC will recognize a complete guard-ring when AA space <= 0.576um and parallel run length >= 0.192um
 Ntype_3rd_ring = N_intector_vol_gR_3rd_outer ENCLOSE (N_injector_vol NOT LUWMK1_OCCDFH)
 Ptype_3rd_ring = P_intector_vol_gR_3rd_outer ENCLOSE (P_injector_vol NOT LUWMK1_OCCDFH)

 Ntype_3rd_inner_GR = PTAP_gR_outerRing_all_auto TOUCH Ntype_3rd_ring
 Ptype_3rd_inner_GR = NTAP_gR_outerRing_all_auto TOUCH Ptype_3rd_ring
 Ntype_3rd_inner_EDGE = PTAP_gR_outerRing_all_auto TOUCH EDGE Ntype_3rd_ring
 Ptype_3rd_inner_EDGE = NTAP_gR_outerRing_all_auto TOUCH EDGE Ptype_3rd_ring

 err1 = Ntype_3rd_inner_EDGE COIN EDGE (INT [Ntype_3rd_inner_GR] <= 0.192 ABUT<90 SINGULAR)
 err2 = Ptype_3rd_inner_EDGE COIN EDGE (INT [Ptype_3rd_inner_GR] <= 0.192 ABUT<90 SINGULAR)
 err1 NOT INSIDE EDGE LUWMK1_OCCDFH
 err2 NOT INSIDE EDGE LUWMK1_OCCDFH
}

LU_6_1_LU_3_G {
@ Guard-ring width of LU.1, LU.1.2 and LU.1.3 > 0.192um
@ ths rule check is for LU.3
@ LU.6.5: DRC will recognize a complete guard-ring when AA space <= 0.576um and parallel run length >= 0.192um
 Ptype_2nd_ring = (PTAP_gR_innerHole_all_auto ENCLOSE Ptype_io_pad_CHK) ENCLOSE DNW
 Ptype_2nd_inner_GR = PTAP_gR_innerRing_auto TOUCH Ptype_2nd_ring
 Ptype_2nd_inner_EDGE = PTAP_gR_innerRing_auto TOUCH EDGE Ptype_2nd_ring
 err1 = Ptype_2nd_inner_EDGE COIN EDGE (INT [Ptype_2nd_inner_GR] <= 0.192 ABUT<90 SINGULAR)
 err1 NOT INSIDE EDGE LUWMK1_OCCDFH
}

pmos_within_io_pad_NTAP_gR = NTAP_gR_rings_all INTERACT PACT_real_non_io_pad_within_io_pad_dev_SWELL_30
nmos_within_io_pad_PTAP_gR = PTAP_gR_rings_all INTERACT NACT_real_non_io_pad_within_io_pad_dev_SWELL_30

LU_6_3_G {
@ Guard-ring width of LU.2 > 0.096um
@ LU.6.5: DRC will recognize a complete guard-ring when AA space <= 0.576um and parallel run length >= 0.192um
 pmos_GR = NTAP_union_ring TOUCH pmos_within_io_pad_NTAP_gR
 nmos_GR = PTAP_union_ring TOUCH nmos_within_io_pad_PTAP_gR
 pmos_GR_inner_EDGE = NTAP_union_ring TOUCH EDGE pmos_within_io_pad_NTAP_gR
 nmos_GR_inner_EDGE = PTAP_union_ring TOUCH EDGE nmos_within_io_pad_PTAP_gR

 err1 = pmos_GR_inner_EDGE COIN EDGE (INT [pmos_GR] <= 0.096 ABUT<90 SINGULAR)
 err2 = nmos_GR_inner_EDGE COIN EDGE (INT [nmos_GR] <= 0.096 ABUT<90 SINGULAR)

 err1 NOT INSIDE EDGE LUWMK1_OCCDFH
 err2 NOT INSIDE EDGE LUWMK1_OCCDFH
}

//;lu.8 derivation (based on LU.1/2/3)
N_intector_NMOS = (NSD_io_pad_CHK INTERACT LUAREA1) NOT LUWMK1_OCCDFH
N_intector_NMOS_gR_inner = PTAP_gR_en_NACT_RAW INTERACT N_intector_NMOS
N_intector_NMOS_gR_outer = (NTAP_gR_en_PACT_RAW INTERACT N_intector_NMOS) NOT ENCLOSE PSD

P_intector_PMOS = (PSD_io_pad_CHK INTERACT LUAREA1) NOT LUWMK1_OCCDFH
P_intector_PMOS_gR_inner = NTAP_gR_en_PACT_RAW INTERACT P_intector_PMOS
P_intector_PMOS_gR_outer = (PTAP_gR_en_NACT_RAW INTERACT P_intector_PMOS) NOT ENCLOSE NSD

P_intector_RWDIO = (PTAP_io_pad_RWDIO_CHK INTERACT LUAREA1) NOT LUWMK1_OCCDFH
P_intector_RWDIO_gR_inner = NTAP_gR_en_RWDIO INTERACT P_intector_RWDIO
P_intector_RWDIO_gR_outer = ((PTAP_gR_en_NACT_RAW INTERACT P_intector_RWDIO_gR_inner) INTERACT PTAP_io_pad_RWDIO_CHK) NOT ENCLOSE NSD

N_intector_NWDIO = (NTAP_io_pad_NWDIO_CHK INTERACT LUAREA1) NOT LUWMK1_OCCDFH
N_intector_NWDIO_gR_inner = PTAP_gR_en_NWDIO INTERACT N_intector_NWDIO
N_intector_NWDIO_gR_outer = ((NTAP_gR_en_PACT_RAW INTERACT N_intector_NWDIO_gR_inner) INTERACT NTAP_io_pad_NWDIO_CHK) NOT ENCLOSE PSD

P_intector_PVART = (PTAP_io_pad_PVART_CHK INTERACT LUAREA1) NOT LUWMK1_OCCDFH
P_intector_PVART_gR_inner = NTAP_gR_en_PVART INTERACT P_intector_PVART
P_intector_PVART_gR_outer = ((PTAP_gR_en_NACT_RAW INTERACT P_intector_PVART_gR_inner) INTERACT PTAP_io_pad_PVART_CHK) NOT ENCLOSE NSD

N_intector_NVART = (NTAP_io_pad_NVART_CHK INTERACT LUAREA1) NOT LUWMK1_OCCDFH
N_intector_NVART_gR_inner = PTAP_gR_en_NVART INTERACT N_intector_NVART
N_intector_NVART_gR_outer = ((NTAP_gR_en_PACT_RAW INTERACT N_intector_NVART_gR_inner) INTERACT NTAP_io_pad_NVART_CHK) NOT ENCLOSE PSD

LU_8_G_N_injector {
@ For Area I/O, AA injector must be surrounded by two guard rings with width > 0.192um
@ That is:
@ N+ AA injector is surrounded by a P+ guard-ring, and this P+ guard-ring is surrounded by a N+ guard-ring
@ P+ AA injector is surrounded by a N+ guard-ring, and this N+ guard-ring is surrounded by a P+ guard-ring
 err1 = N_intector_NMOS NOT PTAP_gR_rings_all //;inner ring
 err2 = N_intector_NMOS NOT N_intector_NMOS_gR_outer //;outer ring
 err3 = N_intector_NWDIO NOT PTAP_gR_en_NWDIO
 err4 = N_intector_NWDIO NOT N_intector_NWDIO_gR_outer
 err5 = N_intector_NVART NOT PTAP_gR_en_NVART
 err6 = N_intector_NVART NOT N_intector_NVART_gR_outer

 err1 NOT INSIDE LUWMK1_OCCDFH
 err2 NOT INSIDE LUWMK1_OCCDFH
 err3 NOT INSIDE LUWMK1_OCCDFH
 err4 NOT INSIDE LUWMK1_OCCDFH
 err5 NOT INSIDE LUWMK1_OCCDFH
 err6 NOT INSIDE LUWMK1_OCCDFH
}

LU_8_G_N_injector_GuardRingMinWidth {
@ For Area I/O, AA injector must be surrounded by two guard rings with width > 0.192um
@ That is:
@ N+ AA injector is surrounded by a P+ guard-ring, and this P+ guard-ring is surrounded by a N+ guard-ring
@ P+ AA injector is surrounded by a N+ guard-ring, and this N+ guard-ring is surrounded by a P+ guard-ring
 nmos_GR_inner = PTAP_union_ring TOUCH N_intector_NMOS_gR_inner
 nmos_GR_outer = NTAP_union_ring TOUCH N_intector_NMOS_gR_outer
 ndio_GR_inner = PTAP_union_ring TOUCH N_intector_NWDIO_gR_inner
 ndio_GR_outer = NTAP_union_ring TOUCH N_intector_NWDIO_gR_outer
 nvar_GR_inner = PTAP_union_ring TOUCH N_intector_NVART_gR_inner
 nvar_GR_outer = NTAP_union_ring TOUCH N_intector_NVART_gR_outer
 nmos_GR_inner_inner_EDGE = PTAP_union_ring TOUCH EDGE N_intector_NMOS_gR_inner
 nmos_GR_outer_inner_EDGE = NTAP_union_ring TOUCH EDGE N_intector_NMOS_gR_outer
 ndio_GR_inner_inner_EDGE = PTAP_union_ring TOUCH EDGE N_intector_NWDIO_gR_inner
 ndio_GR_outer_inner_EDGE = NTAP_union_ring TOUCH EDGE N_intector_NWDIO_gR_outer
 nvar_GR_inner_inner_EDGE = PTAP_union_ring TOUCH EDGE N_intector_NVART_gR_inner
 nvar_GR_outer_inner_EDGE = NTAP_union_ring TOUCH EDGE N_intector_NVART_gR_outer

 err1 = nmos_GR_inner_inner_EDGE COIN EDGE (INT [nmos_GR_inner] <= 0.192 ABUT<90 SINGULAR)
 err2 = nmos_GR_outer_inner_EDGE COIN EDGE (INT [nmos_GR_outer] <= 0.192 ABUT<90 SINGULAR)
 err3 = ndio_GR_inner_inner_EDGE COIN EDGE (INT [ndio_GR_inner] <= 0.192 ABUT<90 SINGULAR)
 err4 = ndio_GR_outer_inner_EDGE COIN EDGE (INT [ndio_GR_outer] <= 0.192 ABUT<90 SINGULAR)
 err5 = nvar_GR_inner_inner_EDGE COIN EDGE (INT [nvar_GR_inner] <= 0.192 ABUT<90 SINGULAR)
 err6 = nvar_GR_outer_inner_EDGE COIN EDGE (INT [nvar_GR_outer] <= 0.192 ABUT<90 SINGULAR)

 err1 NOT INSIDE EDGE LUWMK1_OCCDFH
 err2 NOT INSIDE EDGE LUWMK1_OCCDFH
 err3 NOT INSIDE EDGE LUWMK1_OCCDFH
 err4 NOT INSIDE EDGE LUWMK1_OCCDFH
 err5 NOT INSIDE EDGE LUWMK1_OCCDFH
 err6 NOT INSIDE EDGE LUWMK1_OCCDFH
}

LU_8_G_P_injector {
@ For Area I/O, AA injector must be surrounded by two guard rings with width > 0.192um
@ That is:
@ N+ AA injector is surrounded by a P+ guard-ring, and this P+ guard-ring is surrounded by a N+ guard-ring
@ P+ AA injector is surrounded by a N+ guard-ring, and this N+ guard-ring is surrounded by a P+ guard-ring
 err1 = P_intector_PMOS NOT NTAP_gR_rings_all
 err2 = P_intector_PMOS NOT P_intector_PMOS_gR_outer
 err3 = P_intector_RWDIO NOT NTAP_gR_en_RWDIO
 err4 = P_intector_RWDIO NOT P_intector_RWDIO_gR_outer
 err5 = P_intector_PVART NOT NTAP_gR_en_PVART
 err6 = P_intector_PVART NOT P_intector_PVART_gR_outer

 err1 NOT INSIDE LUWMK1_OCCDFH
 err2 NOT INSIDE LUWMK1_OCCDFH
 err3 NOT INSIDE LUWMK1_OCCDFH
 err4 NOT INSIDE LUWMK1_OCCDFH
 err5 NOT INSIDE LUWMK1_OCCDFH
 err6 NOT INSIDE LUWMK1_OCCDFH
}

LU_8_G_P_injector_GuardRingMinWidth {
@ For Area I/O, AA injector must be surrounded by two guard rings with width > 0.192um
@ That is:
@ N+ AA injector is surrounded by a P+ guard-ring, and this P+ guard-ring is surrounded by a N+ guard-ring
@ P+ AA injector is surrounded by a N+ guard-ring, and this N+ guard-ring is surrounded by a P+ guard-ring
 pmos_GR_inner = NTAP_union_ring TOUCH P_intector_PMOS_gR_inner
 pmos_GR_outer = PTAP_union_ring TOUCH P_intector_PMOS_gR_outer
 rdio_GR_inner = NTAP_union_ring TOUCH P_intector_RWDIO_gR_inner
 rdio_GR_outer = PTAP_union_ring TOUCH P_intector_RWDIO_gR_outer
 pvar_GR_inner = NTAP_union_ring TOUCH P_intector_PVART_gR_inner
 pvar_GR_outer = PTAP_union_ring TOUCH P_intector_PVART_gR_outer
 pmos_GR_inner_inner_EDGE = NTAP_union_ring TOUCH EDGE P_intector_PMOS_gR_inner
 pmos_GR_outer_inner_EDGE = PTAP_union_ring TOUCH EDGE P_intector_PMOS_gR_outer
 rdio_GR_inner_inner_EDGE = NTAP_union_ring TOUCH EDGE P_intector_RWDIO_gR_inner
 rdio_GR_outer_inner_EDGE = PTAP_union_ring TOUCH EDGE P_intector_RWDIO_gR_outer
 pvar_GR_inner_inner_EDGE = NTAP_union_ring TOUCH EDGE P_intector_PVART_gR_inner
 pvar_GR_outer_inner_EDGE = PTAP_union_ring TOUCH EDGE P_intector_PVART_gR_outer

 err1 = pmos_GR_inner_inner_EDGE COIN EDGE (INT [pmos_GR_inner] <= 0.192 ABUT<90 SINGULAR)
 err2 = pmos_GR_outer_inner_EDGE COIN EDGE (INT [pmos_GR_outer] <= 0.192 ABUT<90 SINGULAR)
 err3 = rdio_GR_inner_inner_EDGE COIN EDGE (INT [rdio_GR_inner] <= 0.192 ABUT<90 SINGULAR)
 err4 = rdio_GR_outer_inner_EDGE COIN EDGE (INT [rdio_GR_outer] <= 0.192 ABUT<90 SINGULAR)
 err5 = pvar_GR_inner_inner_EDGE COIN EDGE (INT [pvar_GR_inner] <= 0.192 ABUT<90 SINGULAR)
 err6 = pvar_GR_outer_inner_EDGE COIN EDGE (INT [pvar_GR_outer] <= 0.192 ABUT<90 SINGULAR)

 err1 NOT INSIDE EDGE LUWMK1_OCCDFH
 err2 NOT INSIDE EDGE LUWMK1_OCCDFH
 err3 NOT INSIDE EDGE LUWMK1_OCCDFH
 err4 NOT INSIDE EDGE LUWMK1_OCCDFH
 err5 NOT INSIDE EDGE LUWMK1_OCCDFH
 err6 NOT INSIDE EDGE LUWMK1_OCCDFH
}

//;lu.7~11 derivation
ACT_inject_io_pad_dev_waive = AREA (PNAA INTERACT AACT_io_pad_dev) < 5
ACT_inject_io_pad_dev = (AACT_io_pad_dev NOT ACT_inject_io_pad_dev_waive) INTERACT LUAREA1

#IFDEF LATCH_UP_CHECK_MODE ACCURATE
ACT_inject_io_pad_dev_58nm_SearchRange = SIZE ACT_inject_io_pad_dev BY 58 INSIDE OF DRC:1 STEP 12 BEVEL 3

ACT_nmos_Check = ACT_active_nmos_sd NOT ACT_inject_io_pad_dev
ACT_pmos_Check = ACT_active_pmos_sd NOT ACT_inject_io_pad_dev

ACT_nmos_within_io_pad_580 = ACT_nmos_Check INTERACT ACT_inject_io_pad_dev_58nm_SearchRange
ACT_pmos_within_io_pad_580 = ACT_pmos_Check INTERACT ACT_inject_io_pad_dev_58nm_SearchRange

ACT_nmos_within_2976_pmos_merged = SIZE ACT_nmos_within_io_pad_580 BY 2.976 OVERUNDER
ACT_pmos_within_2976_pmos_merged = SIZE ACT_pmos_within_io_pad_580 BY 2.976 OVERUNDER
ACT_nmos_within_2976_pmos_SearchRange = (SIZE ACT_nmos_within_2976_pmos_merged BY 2.976-0.001 BEVEL 4) NOT ACT_nmos_within_2976_pmos_merged
ACT_pmos_within_2976_nmos_SearchRange = (SIZE ACT_pmos_within_2976_pmos_merged BY 2.976-0.001 BEVEL 4) NOT ACT_pmos_within_2976_pmos_merged
#ENDIF

#IFDEF LATCH_UP_CHECK_MODE FAST
ACT_inject_io_pad_dev_58nm_SearchRange = SIZE ACT_inject_io_pad_dev BY 58 INSIDE OF DRC:1 STEP 12

ACT_nmos_Check = ACT_active_nmos_sd NOT ACT_inject_io_pad_dev
ACT_pmos_Check = ACT_active_pmos_sd NOT ACT_inject_io_pad_dev

ACT_nmos_within_io_pad_580 = ACT_nmos_Check INTERACT ACT_inject_io_pad_dev_58nm_SearchRange
ACT_pmos_within_io_pad_580 = ACT_pmos_Check INTERACT ACT_inject_io_pad_dev_58nm_SearchRange

ACT_nmos_within_2976_pmos_merged = SIZE ACT_nmos_within_io_pad_580 BY 2.976 OVERUNDER
ACT_pmos_within_2976_pmos_merged = SIZE ACT_pmos_within_io_pad_580 BY 2.976 OVERUNDER
ACT_nmos_within_2976_pmos_SearchRange = (SIZE ACT_nmos_within_2976_pmos_merged BY 2.976-0.001 BEVEL 3) NOT ACT_nmos_within_2976_pmos_merged
ACT_pmos_within_2976_nmos_SearchRange = (SIZE ACT_pmos_within_2976_pmos_merged BY 2.976-0.001 BEVEL 3) NOT ACT_pmos_within_2976_pmos_merged
#ENDIF

ACT_nact_within_io_pad_580 = ACT_nmos_within_io_pad_580 INTERACT ACT_pmos_within_2976_nmos_SearchRange
ACT_pact_within_io_pad_580 = ACT_pmos_within_io_pad_580 INTERACT ACT_nmos_within_2976_pmos_SearchRange

pw_step_5_lu_7_9 = SIZE acti_PTAP BY 4.992 INSIDE OF PW_0 STEP LU_Well_STEP TRUNCATE LU_Well_STEP
nw_step_5_lu_7_9 = SIZE acti_NTAP BY 4.992 INSIDE OF NW STEP LU_Well_STEP TRUNCATE LU_Well_STEP

LU_7_9_G_NMOS {
@ LU.7:
@ For Area I/O, within 58um of AA injector, LU.8~LU.11 should be followed except below conditions:
@ 1) AA injector area < 5um2
@ 2) For core circuits, space between N+ AA and P+ AA >= 2.976um
@ LU.9:
@ For Core devices:
@ Any point inside NMOS S/D space to the nearest PW strap in the same PW
@ Any point inside PMOS S/D space to the nearest NW strap in the same NW <= 4.992um
 err1 = (ACT_nmos_within_io_pad_580 AND DG) NOT pw_step_5_lu_7_9
 err2 = (ACT_nact_within_io_pad_580 NOT DG) NOT pw_step_5_lu_7_9

 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

LU_7_9_G_PMOS {
@ LU.7:
@ For Area I/O, within 58um of AA injector, LU.8~LU.11 should be followed except below conditions:
@ 1) AA injector area < 5um2
@ 2) For core circuits, space between N+ AA and P+ AA >= 2.976um
@ LU.9:
@ For Core devices:
@ Any point inside NMOS S/D space to the nearest PW strap in the same PW
@ Any point inside PMOS S/D space to the nearest NW strap in the same NW <= 4.992um
 err1 = (ACT_pmos_within_io_pad_580 AND DG) NOT nw_step_5_lu_7_9
 err2 = (ACT_pact_within_io_pad_580 NOT DG) NOT nw_step_5_lu_7_9

 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

nw_step_lu_10_11 = SIZE acti_NTAP BY 4.992 INSIDE OF NW STEP LU_Well_STEP TRUNCATE LU_Well_STEP
pw_step_lu_10_11 = SIZE acti_PTAP BY 4.992 INSIDE OF PW_0 STEP LU_Well_STEP TRUNCATE LU_Well_STEP

pmos_io = PSD AND DG
nmos_io = NSD AND DG
pmos_core = PSD NOT DG
nmos_core = NSD NOT DG
pmos_core_dv_105v = DFM PROPERTY pmos_core net_vol_assign NODAL MULTI [vol = (property(net_vol_assign, max_vol) > 1.05 || property(net_vol_assign, min_vol) < -1.05) ? 1 : 0] > 0

#IFDEF Delta_Voltage_Rules_Check YES
LU_10_G {
@ For Core devices with PMOS S/D voltage > 1.05V:
@ Any point inside NMOS S/D space to the nearest PW strap in the same PW
@ Any point inside PMOS S/D space to the nearest NW strap in the same NW <= 4.992um
//; Except condition:(1) AA injector area < 5um2; (2) For core circuits, space between N+ AA and P+ AA >= 2.976um
 psd_check = pmos_core INTERACT ACT_pact_within_io_pad_580
 nsd_check = nmos_core INTERACT ACT_nact_within_io_pad_580
 psd_check_105v = psd_check INTERACT pmos_core_dv_105v
#IFDEF LATCH_UP_CHECK_MODE ACCURATE
 nsd_check_105v = nsd_check INTERACT ((SIZE psd_check_105v BY 2.976 BEVEL 4) NOT psd_check_105v)
#ENDIF
#IFDEF LATCH_UP_CHECK_MODE FAST
 nsd_check_105v = nsd_check INTERACT ((SIZE psd_check_105v BY 2.976 BEVEL 3) NOT psd_check_105v)
#ENDIF
 err1 = psd_check_105v NOT nw_step_lu_10_11
 err2 = nsd_check_105v NOT pw_step_lu_10_11

 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}
#ENDIF

LU_11_G_NMOS {
@ For I/O devices:
@ Any point inside NMOS S/D space to the nearest PW strap in the same PW
@ Any point inside PMOS S/D space to the nearest NW strap in the same NW <= 4.992um
//;based on LU.7
 err1 = (ACT_nmos_within_io_pad_580 AND DG) NOT pw_step_lu_10_11
 err1 NOT INSIDE SealR_NOT_BULK
}

LU_11_G_PMOS {
@ For I/O devices:
@ Any point inside NMOS S/D space to the nearest PW strap in the same PW
@ Any point inside PMOS S/D space to the nearest NW strap in the same NW <= 4.992um
//;based on LU.7
 err1 = (ACT_pmos_within_io_pad_580 AND DG) NOT nw_step_lu_10_11
 err1 NOT INSIDE SealR_NOT_BULK
}

//;-------------------------------------------------------------#
//;Voltage Drop     For LU4.1/4.2(um)       For LU4.3/4.4(um)
//;0V < ΔV <= 1V	0.96			0.96
//;1V < ΔV <= 1.32V	1.824			1.824
//;1.32V < ΔV <= 1.65V	2.112			2.12
//;1.65V < ΔV <= 1.98V	3			4.464
//;1.98V < ΔV <= 2.75V	5			7.968
//;2.75V < ΔV <= 3.63V	15			16.032
//;3.63V < ΔV <= 5.5V	35			36
//;-------------------------------------------------------------#

Ptype_io_pad_CHK_lc = AA_lc INTERACT Ptype_io_pad_CHK
Ntype_io_pad_CHK_lc = AA_lc INTERACT Ntype_io_pad_CHK
Ptype_power_pad_CHK_lc = AA_lc INTERACT Ptype_power_pad_CHK
Ntype_power_pad_CHK_lc = AA_lc INTERACT Ntype_power_pad_CHK

Ptype_io_pad_vol_gt_pos_100 = NET AREA RATIO Ptype_io_pad_CHK AA_NETID_vol_gt_pos_100 > 0
Ptype_io_pad_vol_gt_pos_132 = NET AREA RATIO Ptype_io_pad_CHK AA_NETID_vol_gt_pos_132 > 0
Ptype_io_pad_vol_gt_pos_165 = NET AREA RATIO Ptype_io_pad_CHK AA_NETID_vol_gt_pos_165 > 0
Ptype_io_pad_vol_gt_pos_198 = NET AREA RATIO Ptype_io_pad_CHK AA_NETID_vol_gt_pos_198 > 0
Ptype_io_pad_vol_gt_pos_275 = NET AREA RATIO Ptype_io_pad_CHK AA_NETID_vol_gt_pos_275 > 0
Ptype_io_pad_vol_gt_pos_363 = NET AREA RATIO Ptype_io_pad_CHK AA_NETID_vol_gt_pos_363 > 0

Ptype_io_pad_vol_pos_CHK_lc = AA_lc INTERACT Ptype_io_pad_vol_pos_CHK
Ptype_io_pad_vol_pos_100_CHK_lc = AA_lc INTERACT Ptype_io_pad_vol_gt_pos_100
Ptype_io_pad_vol_pos_132_CHK_lc = AA_lc INTERACT Ptype_io_pad_vol_gt_pos_132
Ptype_io_pad_vol_pos_165_CHK_lc = AA_lc INTERACT Ptype_io_pad_vol_gt_pos_165
Ptype_io_pad_vol_pos_198_CHK_lc = AA_lc INTERACT Ptype_io_pad_vol_gt_pos_198
Ptype_io_pad_vol_pos_275_CHK_lc = AA_lc INTERACT Ptype_io_pad_vol_gt_pos_275
Ptype_io_pad_vol_pos_363_CHK_lc = AA_lc INTERACT Ptype_io_pad_vol_gt_pos_363

Ptype_power_pad_vol_gt_pos_100 = NET AREA RATIO Ptype_power_pad_CHK AA_NETID_vol_gt_pos_100 > 0
Ptype_power_pad_vol_gt_pos_132 = NET AREA RATIO Ptype_power_pad_CHK AA_NETID_vol_gt_pos_132 > 0
Ptype_power_pad_vol_gt_pos_165 = NET AREA RATIO Ptype_power_pad_CHK AA_NETID_vol_gt_pos_165 > 0
Ptype_power_pad_vol_gt_pos_198 = NET AREA RATIO Ptype_power_pad_CHK AA_NETID_vol_gt_pos_198 > 0
Ptype_power_pad_vol_gt_pos_275 = NET AREA RATIO Ptype_power_pad_CHK AA_NETID_vol_gt_pos_275 > 0
Ptype_power_pad_vol_gt_pos_363 = NET AREA RATIO Ptype_power_pad_CHK AA_NETID_vol_gt_pos_363 > 0

Ptype_power_pad_vol_pos_CHK_lc = AA_lc INTERACT Ptype_power_pad_vol_pos_CHK
Ptype_power_pad_vol_pos_100_CHK_lc = AA_lc INTERACT Ptype_power_pad_vol_gt_pos_100
Ptype_power_pad_vol_pos_132_CHK_lc = AA_lc INTERACT Ptype_power_pad_vol_gt_pos_132
Ptype_power_pad_vol_pos_165_CHK_lc = AA_lc INTERACT Ptype_power_pad_vol_gt_pos_165
Ptype_power_pad_vol_pos_198_CHK_lc = AA_lc INTERACT Ptype_power_pad_vol_gt_pos_198
Ptype_power_pad_vol_pos_275_CHK_lc = AA_lc INTERACT Ptype_power_pad_vol_gt_pos_275
Ptype_power_pad_vol_pos_363_CHK_lc = AA_lc INTERACT Ptype_power_pad_vol_gt_pos_363

Ntype_io_pad_vol_neg_CHK_lc = AA_lc INTERACT Ntype_io_pad_vol_neg_CHK
Ntype_power_pad_vol_neg_CHK_lc = AA_lc INTERACT Ntype_power_pad_vol_neg_CHK

VARIABLE LU_0d0_To_1d0_1N2 0.96
VARIABLE LU_1d0_To_1d2_1N2 1.824
VARIABLE LU_1d2_To_1d5_1N2 2.112
VARIABLE LU_1d5_To_1d8_1N2 3
VARIABLE LU_1d8_To_2d5_1N2 5
VARIABLE LU_2d5_To_3d3_1N2 15
VARIABLE LU_3d3_To_5d0_1N2 35

VARIABLE LU_0d0_To_1d0_3N4 0.96
VARIABLE LU_1d0_To_1d2_3N4 1.824
VARIABLE LU_1d2_To_1d5_3N4 2.12
VARIABLE LU_1d5_To_1d8_3N4 4.464
VARIABLE LU_1d8_To_2d5_3N4 7.968
VARIABLE LU_2d5_To_3d3_3N4 16.032
VARIABLE LU_3d3_To_5d0_3N4 36

VARIABLE LU_4_1_1_G_val LU_0d0_To_1d0_1N2
VARIABLE LU_4_1_2_G_val LU_1d0_To_1d2_1N2
VARIABLE LU_4_1_3_G_val LU_1d2_To_1d5_1N2
VARIABLE LU_4_1_4_G_val LU_1d5_To_1d8_1N2
VARIABLE LU_4_1_5_G_val LU_1d8_To_2d5_1N2
VARIABLE LU_4_1_6_G_val LU_2d5_To_3d3_1N2
VARIABLE LU_4_1_7_G_val LU_3d3_To_5d0_1N2
VARIABLE LU_4_2_1_G_val LU_0d0_To_1d0_1N2
VARIABLE LU_4_2_2_G_val LU_1d0_To_1d2_1N2
VARIABLE LU_4_2_3_G_val LU_1d2_To_1d5_1N2
VARIABLE LU_4_2_4_G_val LU_1d5_To_1d8_1N2
VARIABLE LU_4_2_5_G_val LU_1d8_To_2d5_1N2
VARIABLE LU_4_2_6_G_val LU_2d5_To_3d3_1N2
VARIABLE LU_4_2_7_G_val LU_3d3_To_5d0_1N2
VARIABLE LU_4_3_1_G_val LU_0d0_To_1d0_3N4
VARIABLE LU_4_3_2_G_val LU_1d0_To_1d2_3N4
VARIABLE LU_4_3_3_G_val LU_1d2_To_1d5_3N4
VARIABLE LU_4_3_4_G_val LU_1d5_To_1d8_3N4
VARIABLE LU_4_3_5_G_val LU_1d8_To_2d5_3N4
VARIABLE LU_4_3_6_G_val LU_2d5_To_3d3_3N4
VARIABLE LU_4_3_7_G_val LU_3d3_To_5d0_3N4
VARIABLE LU_4_4_1_G_val LU_0d0_To_1d0_3N4
VARIABLE LU_4_4_2_G_val LU_1d0_To_1d2_3N4
VARIABLE LU_4_4_3_G_val LU_1d2_To_1d5_3N4
VARIABLE LU_4_4_4_G_val LU_1d5_To_1d8_3N4
VARIABLE LU_4_4_5_G_val LU_1d8_To_2d5_3N4
VARIABLE LU_4_4_6_G_val LU_2d5_To_3d3_3N4
VARIABLE LU_4_4_7_G_val LU_3d3_To_5d0_3N4

#IFDEF Delta_Voltage_Rules_Check YES
LU_4_1_1a_G {
@ LU.4.1: Space between IO Anode and IO Cathode, or between Power Anode and IO Cathode when 0V < Delta V <= 1V. >= 0.96um
@ between IO Anode and IO Cathode
 err1_a = EXT Ptype_io_pad_vol_pos_CHK_lc Ntype_io_pad_CHK_lc < LU_4_1_1_G_val SINGULAR NOT CONNECTED
 err1_b = EXT Ntype_io_pad_vol_neg_CHK_lc Ptype_io_pad_CHK_lc < LU_4_1_1_G_val SINGULAR NOT CONNECTED
 err1_a_L = EXT [Ptype_io_pad_vol_pos_CHK_lc] Ntype_io_pad_CHK_lc < LU_4_1_1_G_val SINGULAR NOT CONNECTED
 err1_b_L = EXT [Ntype_io_pad_vol_neg_CHK_lc] Ptype_io_pad_CHK_lc < LU_4_1_1_G_val SINGULAR NOT CONNECTED
 err1_a_R = EXT Ptype_io_pad_vol_pos_CHK_lc [Ntype_io_pad_CHK_lc] < LU_4_1_1_G_val SINGULAR NOT CONNECTED
 err1_b_R = EXT Ntype_io_pad_vol_neg_CHK_lc [Ptype_io_pad_CHK_lc] < LU_4_1_1_G_val SINGULAR NOT CONNECTED
 err1_a_L_gC = AA_c COIN EDGE err1_a_L
 err1_b_L_gC = AA_c COIN EDGE err1_b_L
 err1_a_R_gC = AA_c COIN EDGE err1_a_R
 err1_b_R_gC = AA_c COIN EDGE err1_b_R

 err1_a_L_NETID = DFM PROPERTY err1_a_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_a_R_NETID = DFM PROPERTY err1_a_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1_b_L_NETID = DFM PROPERTY err1_b_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_b_R_NETID = DFM PROPERTY err1_b_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1 = DFM PROPERTY err1_a err1_a_L_NETID err1_a_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_a_L_NETID)]
 [NET_b = count(err1_a_R_NETID)]
 [VH_1a = property(err1_a_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_a_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_a_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_a_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 0 && property_ref(DT_vA) <= 1.000) || (property_ref(DT_vB) > 0 && property_ref(DT_vB) <= 1.000)) ? 1 : 0] > 0

 err2 = DFM PROPERTY err1_b err1_b_L_NETID err1_b_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_b_L_NETID)]
 [NET_b = count(err1_b_R_NETID)]
 [VH_1a = property(err1_b_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_b_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_b_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_b_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 0 && property_ref(DT_vA) <= 1.000) || (property_ref(DT_vB) > 0 && property_ref(DT_vB) <= 1.000)) ? 1 : 0] > 0

 DFM COPY err1 err2
}

LU_4_1_1b_G {
@ LU.4.1: Space between IO Anode and IO Cathode, or between Power Anode and IO Cathode when 0V < Delta V <= 1V. >= 0.96um
@ between Power Anode and IO Cathode
 err3_a = EXT Ptype_power_pad_vol_pos_CHK_lc Ntype_io_pad_CHK_lc < LU_4_1_1_G_val SINGULAR NOT CONNECTED
 err3_b = EXT Ntype_io_pad_vol_neg_CHK_lc Ptype_power_pad_CHK_lc < LU_4_1_1_G_val SINGULAR NOT CONNECTED
 err3_a_L = EXT [Ptype_power_pad_vol_pos_CHK_lc] Ntype_io_pad_CHK_lc < LU_4_1_1_G_val SINGULAR NOT CONNECTED
 err3_b_L = EXT [Ntype_io_pad_vol_neg_CHK_lc] Ptype_power_pad_CHK_lc < LU_4_1_1_G_val SINGULAR NOT CONNECTED
 err3_a_R = EXT Ptype_power_pad_vol_pos_CHK_lc [Ntype_io_pad_CHK_lc] < LU_4_1_1_G_val SINGULAR NOT CONNECTED
 err3_b_R = EXT Ntype_io_pad_vol_neg_CHK_lc [Ptype_power_pad_CHK_lc] < LU_4_1_1_G_val SINGULAR NOT CONNECTED
 err3_a_L_gC = AA_c COIN EDGE err3_a_L
 err3_b_L_gC = AA_c COIN EDGE err3_b_L
 err3_a_R_gC = AA_c COIN EDGE err3_a_R
 err3_b_R_gC = AA_c COIN EDGE err3_b_R

 err3_a_L_NETID = DFM PROPERTY err3_a_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err3_a_R_NETID = DFM PROPERTY err3_a_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err3_b_L_NETID = DFM PROPERTY err3_b_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err3_b_R_NETID = DFM PROPERTY err3_b_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err3 = DFM PROPERTY err3_a err3_a_L_NETID err3_a_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err3_a_L_NETID)]
 [NET_b = count(err3_a_R_NETID)]
 [VH_1a = property(err3_a_L_NETID, "max_vol", 1)]
 [VL_1a = property(err3_a_L_NETID, "min_vol", 1)]
 [VH_1b = property(err3_a_R_NETID, "max_vol", 1)]
 [VL_1b = property(err3_a_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err3_a_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err3_a_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err3_a_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err3_a_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 0 && property_ref(DT_vA) <= 1.000) || (property_ref(DT_vB) > 0 && property_ref(DT_vB) <= 1.000)) ? 1 : 0] > 0

 err4 = DFM PROPERTY err3_b err3_b_L_NETID err3_b_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err3_b_L_NETID)]
 [NET_b = count(err3_b_R_NETID)]
 [VH_1a = property(err3_b_L_NETID, "max_vol", 1)]
 [VL_1a = property(err3_b_L_NETID, "min_vol", 1)]
 [VH_1b = property(err3_b_R_NETID, "max_vol", 1)]
 [VL_1b = property(err3_b_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err3_b_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err3_b_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err3_b_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err3_b_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 0 && property_ref(DT_vA) <= 1.000) || (property_ref(DT_vB) > 0 && property_ref(DT_vB) <= 1.000)) ? 1 : 0] > 0

 DFM COPY err3 err4
}

LU_4_1_2a_G {
@ LU.4.1: Space between IO Anode and IO Cathode, or between Power Anode and IO Cathode when 1V < Delta V <= 1.32V. >= 1.824um
@ between IO Anode and IO Cathode
 err1_a = EXT Ptype_io_pad_vol_pos_100_CHK_lc Ntype_io_pad_CHK_lc < LU_4_1_2_G_val SINGULAR NOT CONNECTED
 err1_b = EXT Ntype_io_pad_vol_neg_CHK_lc Ptype_io_pad_CHK_lc < LU_4_1_2_G_val SINGULAR NOT CONNECTED
 err1_a_L = EXT [Ptype_io_pad_vol_pos_100_CHK_lc] Ntype_io_pad_CHK_lc < LU_4_1_2_G_val SINGULAR NOT CONNECTED
 err1_b_L = EXT [Ntype_io_pad_vol_neg_CHK_lc] Ptype_io_pad_CHK_lc < LU_4_1_2_G_val SINGULAR NOT CONNECTED
 err1_a_R = EXT Ptype_io_pad_vol_pos_100_CHK_lc [Ntype_io_pad_CHK_lc] < LU_4_1_2_G_val SINGULAR NOT CONNECTED
 err1_b_R = EXT Ntype_io_pad_vol_neg_CHK_lc [Ptype_io_pad_CHK_lc] < LU_4_1_2_G_val SINGULAR NOT CONNECTED
 err1_a_L_gC = AA_c COIN EDGE err1_a_L
 err1_b_L_gC = AA_c COIN EDGE err1_b_L
 err1_a_R_gC = AA_c COIN EDGE err1_a_R
 err1_b_R_gC = AA_c COIN EDGE err1_b_R

 err1_a_L_NETID = DFM PROPERTY err1_a_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_a_R_NETID = DFM PROPERTY err1_a_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1_b_L_NETID = DFM PROPERTY err1_b_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_b_R_NETID = DFM PROPERTY err1_b_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1 = DFM PROPERTY err1_a err1_a_L_NETID err1_a_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_a_L_NETID)]
 [NET_b = count(err1_a_R_NETID)]
 [VH_1a = property(err1_a_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_a_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_a_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_a_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 1.000 && property_ref(DT_vA) <= 1.32) || (property_ref(DT_vB) > 1.000 && property_ref(DT_vB) <= 1.32)) ? 1 : 0] > 0

 err2 = DFM PROPERTY err1_b err1_b_L_NETID err1_b_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_b_L_NETID)]
 [NET_b = count(err1_b_R_NETID)]
 [VH_1a = property(err1_b_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_b_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_b_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_b_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 1.000 && property_ref(DT_vA) <= 1.32) || (property_ref(DT_vB) > 1.000 && property_ref(DT_vB) <= 1.32)) ? 1 : 0] > 0

 DFM COPY err1 err2
}

LU_4_1_2b_G {
@ LU.4.1: Space between IO Anode and IO Cathode, or between Power Anode and IO Cathode when 1V < Delta V <= 1.32V. >= 1.824um
@ between Power Anode and IO Cathode
 err3_a = EXT Ptype_power_pad_vol_pos_100_CHK_lc Ntype_io_pad_CHK_lc < LU_4_1_2_G_val SINGULAR NOT CONNECTED
 err3_b = EXT Ntype_io_pad_vol_neg_CHK_lc Ptype_power_pad_CHK_lc < LU_4_1_2_G_val SINGULAR NOT CONNECTED
 err3_a_L = EXT [Ptype_power_pad_vol_pos_100_CHK_lc] Ntype_io_pad_CHK_lc < LU_4_1_2_G_val SINGULAR NOT CONNECTED
 err3_b_L = EXT [Ntype_io_pad_vol_neg_CHK_lc] Ptype_power_pad_CHK_lc < LU_4_1_2_G_val SINGULAR NOT CONNECTED
 err3_a_R = EXT Ptype_power_pad_vol_pos_100_CHK_lc [Ntype_io_pad_CHK_lc] < LU_4_1_2_G_val SINGULAR NOT CONNECTED
 err3_b_R = EXT Ntype_io_pad_vol_neg_CHK_lc [Ptype_power_pad_CHK_lc] < LU_4_1_2_G_val SINGULAR NOT CONNECTED
 err3_a_L_gC = AA_c COIN EDGE err3_a_L
 err3_b_L_gC = AA_c COIN EDGE err3_b_L
 err3_a_R_gC = AA_c COIN EDGE err3_a_R
 err3_b_R_gC = AA_c COIN EDGE err3_b_R

 err3_a_L_NETID = DFM PROPERTY err3_a_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err3_a_R_NETID = DFM PROPERTY err3_a_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err3_b_L_NETID = DFM PROPERTY err3_b_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err3_b_R_NETID = DFM PROPERTY err3_b_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err3 = DFM PROPERTY err3_a err3_a_L_NETID err3_a_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err3_a_L_NETID)]
 [NET_b = count(err3_a_R_NETID)]
 [VH_1a = property(err3_a_L_NETID, "max_vol", 1)]
 [VL_1a = property(err3_a_L_NETID, "min_vol", 1)]
 [VH_1b = property(err3_a_R_NETID, "max_vol", 1)]
 [VL_1b = property(err3_a_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err3_a_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err3_a_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err3_a_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err3_a_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 1.000 && property_ref(DT_vA) <= 1.32) || (property_ref(DT_vB) > 1.000 && property_ref(DT_vB) <= 1.32)) ? 1 : 0] > 0

 err4 = DFM PROPERTY err3_b err3_b_L_NETID err3_b_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err3_b_L_NETID)]
 [NET_b = count(err3_b_R_NETID)]
 [VH_1a = property(err3_b_L_NETID, "max_vol", 1)]
 [VL_1a = property(err3_b_L_NETID, "min_vol", 1)]
 [VH_1b = property(err3_b_R_NETID, "max_vol", 1)]
 [VL_1b = property(err3_b_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err3_b_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err3_b_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err3_b_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err3_b_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 1.000 && property_ref(DT_vA) <= 1.32) || (property_ref(DT_vB) > 1.000 && property_ref(DT_vB) <= 1.32)) ? 1 : 0] > 0

 DFM COPY err3 err4
}

LU_4_1_3a_G {
@ LU.4.1: Space between IO Anode and IO Cathode, or between Power Anode and IO Cathode when 1.32V < Delta V <= 1.65V. >= 2.112um
@ between IO Anode and IO Cathode
 err1_a = EXT Ptype_io_pad_vol_pos_132_CHK_lc Ntype_io_pad_CHK_lc < LU_4_1_3_G_val SINGULAR NOT CONNECTED
 err1_b = EXT Ntype_io_pad_vol_neg_CHK_lc Ptype_io_pad_CHK_lc < LU_4_1_3_G_val SINGULAR NOT CONNECTED
 err1_a_L = EXT [Ptype_io_pad_vol_pos_132_CHK_lc] Ntype_io_pad_CHK_lc < LU_4_1_3_G_val SINGULAR NOT CONNECTED
 err1_b_L = EXT [Ntype_io_pad_vol_neg_CHK_lc] Ptype_io_pad_CHK_lc < LU_4_1_3_G_val SINGULAR NOT CONNECTED
 err1_a_R = EXT Ptype_io_pad_vol_pos_132_CHK_lc [Ntype_io_pad_CHK_lc] < LU_4_1_3_G_val SINGULAR NOT CONNECTED
 err1_b_R = EXT Ntype_io_pad_vol_neg_CHK_lc [Ptype_io_pad_CHK_lc] < LU_4_1_3_G_val SINGULAR NOT CONNECTED
 err1_a_L_gC = AA_c COIN EDGE err1_a_L
 err1_b_L_gC = AA_c COIN EDGE err1_b_L
 err1_a_R_gC = AA_c COIN EDGE err1_a_R
 err1_b_R_gC = AA_c COIN EDGE err1_b_R

 err1_a_L_NETID = DFM PROPERTY err1_a_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_a_R_NETID = DFM PROPERTY err1_a_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1_b_L_NETID = DFM PROPERTY err1_b_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_b_R_NETID = DFM PROPERTY err1_b_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1 = DFM PROPERTY err1_a err1_a_L_NETID err1_a_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_a_L_NETID)]
 [NET_b = count(err1_a_R_NETID)]
 [VH_1a = property(err1_a_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_a_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_a_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_a_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 1.32 && property_ref(DT_vA) <= 1.65) || (property_ref(DT_vB) > 1.32 && property_ref(DT_vB) <= 1.65)) ? 1 : 0] > 0

 err2 = DFM PROPERTY err1_b err1_b_L_NETID err1_b_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_b_L_NETID)]
 [NET_b = count(err1_b_R_NETID)]
 [VH_1a = property(err1_b_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_b_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_b_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_b_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 1.32 && property_ref(DT_vA) <= 1.65) || (property_ref(DT_vB) > 1.32 && property_ref(DT_vB) <= 1.65)) ? 1 : 0] > 0

 DFM COPY err1 err2
}

LU_4_1_3b_G {
@ LU.4.1: Space between IO Anode and IO Cathode, or between Power Anode and IO Cathode when 1.32V < Delta V <= 1.65V. >= 2.112um
@ between Power Anode and IO Cathode
 err3_a = EXT Ptype_power_pad_vol_pos_132_CHK_lc Ntype_io_pad_CHK_lc < LU_4_1_3_G_val SINGULAR NOT CONNECTED
 err3_b = EXT Ntype_io_pad_vol_neg_CHK_lc Ptype_power_pad_CHK_lc < LU_4_1_3_G_val SINGULAR NOT CONNECTED
 err3_a_L = EXT [Ptype_power_pad_vol_pos_132_CHK_lc] Ntype_io_pad_CHK_lc < LU_4_1_3_G_val SINGULAR NOT CONNECTED
 err3_b_L = EXT [Ntype_io_pad_vol_neg_CHK_lc] Ptype_power_pad_CHK_lc < LU_4_1_3_G_val SINGULAR NOT CONNECTED
 err3_a_R = EXT Ptype_power_pad_vol_pos_132_CHK_lc [Ntype_io_pad_CHK_lc] < LU_4_1_3_G_val SINGULAR NOT CONNECTED
 err3_b_R = EXT Ntype_io_pad_vol_neg_CHK_lc [Ptype_power_pad_CHK_lc] < LU_4_1_3_G_val SINGULAR NOT CONNECTED
 err3_a_L_gC = AA_c COIN EDGE err3_a_L
 err3_b_L_gC = AA_c COIN EDGE err3_b_L
 err3_a_R_gC = AA_c COIN EDGE err3_a_R
 err3_b_R_gC = AA_c COIN EDGE err3_b_R

 err3_a_L_NETID = DFM PROPERTY err3_a_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err3_a_R_NETID = DFM PROPERTY err3_a_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err3_b_L_NETID = DFM PROPERTY err3_b_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err3_b_R_NETID = DFM PROPERTY err3_b_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err3 = DFM PROPERTY err3_a err3_a_L_NETID err3_a_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err3_a_L_NETID)]
 [NET_b = count(err3_a_R_NETID)]
 [VH_1a = property(err3_a_L_NETID, "max_vol", 1)]
 [VL_1a = property(err3_a_L_NETID, "min_vol", 1)]
 [VH_1b = property(err3_a_R_NETID, "max_vol", 1)]
 [VL_1b = property(err3_a_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err3_a_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err3_a_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err3_a_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err3_a_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 1.32 && property_ref(DT_vA) <= 1.65) || (property_ref(DT_vB) > 1.32 && property_ref(DT_vB) <= 1.65)) ? 1 : 0] > 0

 err4 = DFM PROPERTY err3_b err3_b_L_NETID err3_b_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err3_b_L_NETID)]
 [NET_b = count(err3_b_R_NETID)]
 [VH_1a = property(err3_b_L_NETID, "max_vol", 1)]
 [VL_1a = property(err3_b_L_NETID, "min_vol", 1)]
 [VH_1b = property(err3_b_R_NETID, "max_vol", 1)]
 [VL_1b = property(err3_b_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err3_b_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err3_b_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err3_b_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err3_b_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 1.32 && property_ref(DT_vA) <= 1.65) || (property_ref(DT_vB) > 1.32 && property_ref(DT_vB) <= 1.65)) ? 1 : 0] > 0

 DFM COPY err3 err4
}

LU_4_1_4a_G {
@ LU.4.1: Space between IO Anode and IO Cathode, or between Power Anode and IO Cathode when 1.65V < Delta V <= 1.98V. >= 3um
@ between IO Anode and IO Cathode
 err1_a = EXT Ptype_io_pad_vol_pos_165_CHK_lc Ntype_io_pad_CHK_lc < LU_4_1_4_G_val SINGULAR NOT CONNECTED
 err1_b = EXT Ntype_io_pad_vol_neg_CHK_lc Ptype_io_pad_CHK_lc < LU_4_1_4_G_val SINGULAR NOT CONNECTED
 err1_a_L = EXT [Ptype_io_pad_vol_pos_165_CHK_lc] Ntype_io_pad_CHK_lc < LU_4_1_4_G_val SINGULAR NOT CONNECTED
 err1_b_L = EXT [Ntype_io_pad_vol_neg_CHK_lc] Ptype_io_pad_CHK_lc < LU_4_1_4_G_val SINGULAR NOT CONNECTED
 err1_a_R = EXT Ptype_io_pad_vol_pos_165_CHK_lc [Ntype_io_pad_CHK_lc] < LU_4_1_4_G_val SINGULAR NOT CONNECTED
 err1_b_R = EXT Ntype_io_pad_vol_neg_CHK_lc [Ptype_io_pad_CHK_lc] < LU_4_1_4_G_val SINGULAR NOT CONNECTED
 err1_a_L_gC = AA_c COIN EDGE err1_a_L
 err1_b_L_gC = AA_c COIN EDGE err1_b_L
 err1_a_R_gC = AA_c COIN EDGE err1_a_R
 err1_b_R_gC = AA_c COIN EDGE err1_b_R

 err1_a_L_NETID = DFM PROPERTY err1_a_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_a_R_NETID = DFM PROPERTY err1_a_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1_b_L_NETID = DFM PROPERTY err1_b_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_b_R_NETID = DFM PROPERTY err1_b_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1 = DFM PROPERTY err1_a err1_a_L_NETID err1_a_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_a_L_NETID)]
 [NET_b = count(err1_a_R_NETID)]
 [VH_1a = property(err1_a_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_a_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_a_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_a_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 1.65 && property_ref(DT_vA) <= 1.98) || (property_ref(DT_vB) > 1.65 && property_ref(DT_vB) <= 1.98)) ? 1 : 0] > 0

 err2 = DFM PROPERTY err1_b err1_b_L_NETID err1_b_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_b_L_NETID)]
 [NET_b = count(err1_b_R_NETID)]
 [VH_1a = property(err1_b_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_b_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_b_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_b_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 1.65 && property_ref(DT_vA) <= 1.98) || (property_ref(DT_vB) > 1.65 && property_ref(DT_vB) <= 1.98)) ? 1 : 0] > 0

 DFM COPY err1 err2
}

LU_4_1_4b_G {
@ LU.4.1: Space between IO Anode and IO Cathode, or between Power Anode and IO Cathode when 1.65V < Delta V <= 1.98V. >= 3um
@ between Power Anode and IO Cathode
 err3_a = EXT Ptype_power_pad_vol_pos_165_CHK_lc Ntype_io_pad_CHK_lc < LU_4_1_4_G_val SINGULAR NOT CONNECTED
 err3_b = EXT Ntype_io_pad_vol_neg_CHK_lc Ptype_power_pad_CHK_lc < LU_4_1_4_G_val SINGULAR NOT CONNECTED
 err3_a_L = EXT [Ptype_power_pad_vol_pos_165_CHK_lc] Ntype_io_pad_CHK_lc < LU_4_1_4_G_val SINGULAR NOT CONNECTED
 err3_b_L = EXT [Ntype_io_pad_vol_neg_CHK_lc] Ptype_power_pad_CHK_lc < LU_4_1_4_G_val SINGULAR NOT CONNECTED
 err3_a_R = EXT Ptype_power_pad_vol_pos_165_CHK_lc [Ntype_io_pad_CHK_lc] < LU_4_1_4_G_val SINGULAR NOT CONNECTED
 err3_b_R = EXT Ntype_io_pad_vol_neg_CHK_lc [Ptype_power_pad_CHK_lc] < LU_4_1_4_G_val SINGULAR NOT CONNECTED
 err3_a_L_gC = AA_c COIN EDGE err3_a_L
 err3_b_L_gC = AA_c COIN EDGE err3_b_L
 err3_a_R_gC = AA_c COIN EDGE err3_a_R
 err3_b_R_gC = AA_c COIN EDGE err3_b_R

 err3_a_L_NETID = DFM PROPERTY err3_a_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err3_a_R_NETID = DFM PROPERTY err3_a_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err3_b_L_NETID = DFM PROPERTY err3_b_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err3_b_R_NETID = DFM PROPERTY err3_b_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err3 = DFM PROPERTY err3_a err3_a_L_NETID err3_a_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err3_a_L_NETID)]
 [NET_b = count(err3_a_R_NETID)]
 [VH_1a = property(err3_a_L_NETID, "max_vol", 1)]
 [VL_1a = property(err3_a_L_NETID, "min_vol", 1)]
 [VH_1b = property(err3_a_R_NETID, "max_vol", 1)]
 [VL_1b = property(err3_a_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err3_a_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err3_a_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err3_a_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err3_a_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 1.65 && property_ref(DT_vA) <= 1.98) || (property_ref(DT_vB) > 1.65 && property_ref(DT_vB) <= 1.98)) ? 1 : 0] > 0

 err4 = DFM PROPERTY err3_b err3_b_L_NETID err3_b_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err3_b_L_NETID)]
 [NET_b = count(err3_b_R_NETID)]
 [VH_1a = property(err3_b_L_NETID, "max_vol", 1)]
 [VL_1a = property(err3_b_L_NETID, "min_vol", 1)]
 [VH_1b = property(err3_b_R_NETID, "max_vol", 1)]
 [VL_1b = property(err3_b_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err3_b_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err3_b_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err3_b_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err3_b_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 1.65 && property_ref(DT_vA) <= 1.98) || (property_ref(DT_vB) > 1.65 && property_ref(DT_vB) <= 1.98)) ? 1 : 0] > 0

 DFM COPY err3 err4
}

LU_4_1_5a_G {
@ LU.4.1: Space between IO Anode and IO Cathode, or between Power Anode and IO Cathode when 1.98V < Delta V <= 2.75V. >= 5um
@ between IO Anode and IO Cathode
 err1_a = EXT Ptype_io_pad_vol_pos_198_CHK_lc Ntype_io_pad_CHK_lc < LU_4_1_5_G_val SINGULAR NOT CONNECTED
 err1_b = EXT Ntype_io_pad_vol_neg_CHK_lc Ptype_io_pad_CHK_lc < LU_4_1_5_G_val SINGULAR NOT CONNECTED
 err1_a_L = EXT [Ptype_io_pad_vol_pos_198_CHK_lc] Ntype_io_pad_CHK_lc < LU_4_1_5_G_val SINGULAR NOT CONNECTED
 err1_b_L = EXT [Ntype_io_pad_vol_neg_CHK_lc] Ptype_io_pad_CHK_lc < LU_4_1_5_G_val SINGULAR NOT CONNECTED
 err1_a_R = EXT Ptype_io_pad_vol_pos_198_CHK_lc [Ntype_io_pad_CHK_lc] < LU_4_1_5_G_val SINGULAR NOT CONNECTED
 err1_b_R = EXT Ntype_io_pad_vol_neg_CHK_lc [Ptype_io_pad_CHK_lc] < LU_4_1_5_G_val SINGULAR NOT CONNECTED
 err1_a_L_gC = AA_c COIN EDGE err1_a_L
 err1_b_L_gC = AA_c COIN EDGE err1_b_L
 err1_a_R_gC = AA_c COIN EDGE err1_a_R
 err1_b_R_gC = AA_c COIN EDGE err1_b_R

 err1_a_L_NETID = DFM PROPERTY err1_a_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_a_R_NETID = DFM PROPERTY err1_a_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1_b_L_NETID = DFM PROPERTY err1_b_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_b_R_NETID = DFM PROPERTY err1_b_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1 = DFM PROPERTY err1_a err1_a_L_NETID err1_a_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_a_L_NETID)]
 [NET_b = count(err1_a_R_NETID)]
 [VH_1a = property(err1_a_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_a_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_a_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_a_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 1.98 && property_ref(DT_vA) <= 2.75) || (property_ref(DT_vB) > 1.98 && property_ref(DT_vB) <= 2.75)) ? 1 : 0] > 0

 err2 = DFM PROPERTY err1_b err1_b_L_NETID err1_b_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_b_L_NETID)]
 [NET_b = count(err1_b_R_NETID)]
 [VH_1a = property(err1_b_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_b_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_b_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_b_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 1.98 && property_ref(DT_vA) <= 2.75) || (property_ref(DT_vB) > 1.98 && property_ref(DT_vB) <= 2.75)) ? 1 : 0] > 0

 DFM COPY err1 err2
}

LU_4_1_5b_G {
@ LU.4.1: Space between IO Anode and IO Cathode, or between Power Anode and IO Cathode when 1.98V < Delta V <= 2.75V. >= 5um
@ between Power Anode and IO Cathode
 err3_a = EXT Ptype_power_pad_vol_pos_198_CHK_lc Ntype_io_pad_CHK_lc < LU_4_1_5_G_val SINGULAR NOT CONNECTED
 err3_b = EXT Ntype_io_pad_vol_neg_CHK_lc Ptype_power_pad_CHK_lc < LU_4_1_5_G_val SINGULAR NOT CONNECTED
 err3_a_L = EXT [Ptype_power_pad_vol_pos_198_CHK_lc] Ntype_io_pad_CHK_lc < LU_4_1_5_G_val SINGULAR NOT CONNECTED
 err3_b_L = EXT [Ntype_io_pad_vol_neg_CHK_lc] Ptype_power_pad_CHK_lc < LU_4_1_5_G_val SINGULAR NOT CONNECTED
 err3_a_R = EXT Ptype_power_pad_vol_pos_198_CHK_lc [Ntype_io_pad_CHK_lc] < LU_4_1_5_G_val SINGULAR NOT CONNECTED
 err3_b_R = EXT Ntype_io_pad_vol_neg_CHK_lc [Ptype_power_pad_CHK_lc] < LU_4_1_5_G_val SINGULAR NOT CONNECTED
 err3_a_L_gC = AA_c COIN EDGE err3_a_L
 err3_b_L_gC = AA_c COIN EDGE err3_b_L
 err3_a_R_gC = AA_c COIN EDGE err3_a_R
 err3_b_R_gC = AA_c COIN EDGE err3_b_R

 err3_a_L_NETID = DFM PROPERTY err3_a_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err3_a_R_NETID = DFM PROPERTY err3_a_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err3_b_L_NETID = DFM PROPERTY err3_b_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err3_b_R_NETID = DFM PROPERTY err3_b_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err3 = DFM PROPERTY err3_a err3_a_L_NETID err3_a_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err3_a_L_NETID)]
 [NET_b = count(err3_a_R_NETID)]
 [VH_1a = property(err3_a_L_NETID, "max_vol", 1)]
 [VL_1a = property(err3_a_L_NETID, "min_vol", 1)]
 [VH_1b = property(err3_a_R_NETID, "max_vol", 1)]
 [VL_1b = property(err3_a_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err3_a_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err3_a_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err3_a_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err3_a_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 1.98 && property_ref(DT_vA) <= 2.75) || (property_ref(DT_vB) > 1.98 && property_ref(DT_vB) <= 2.75)) ? 1 : 0] > 0

 err4 = DFM PROPERTY err3_b err3_b_L_NETID err3_b_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err3_b_L_NETID)]
 [NET_b = count(err3_b_R_NETID)]
 [VH_1a = property(err3_b_L_NETID, "max_vol", 1)]
 [VL_1a = property(err3_b_L_NETID, "min_vol", 1)]
 [VH_1b = property(err3_b_R_NETID, "max_vol", 1)]
 [VL_1b = property(err3_b_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err3_b_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err3_b_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err3_b_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err3_b_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 1.98 && property_ref(DT_vA) <= 2.75) || (property_ref(DT_vB) > 1.98 && property_ref(DT_vB) <= 2.75)) ? 1 : 0] > 0

 DFM COPY err3 err4
}

LU_4_1_6a_G {
@ LU.4.1: Space between IO Anode and IO Cathode, or between Power Anode and IO Cathode when 2.75V < Delta V <= 3.63V. >= 15um
@ between IO Anode and IO Cathode
 err1_a = EXT Ptype_io_pad_vol_pos_275_CHK_lc Ntype_io_pad_CHK_lc < LU_4_1_6_G_val SINGULAR NOT CONNECTED
 err1_b = EXT Ntype_io_pad_vol_neg_CHK_lc Ptype_io_pad_CHK_lc < LU_4_1_6_G_val SINGULAR NOT CONNECTED
 err1_a_L = EXT [Ptype_io_pad_vol_pos_275_CHK_lc] Ntype_io_pad_CHK_lc < LU_4_1_6_G_val SINGULAR NOT CONNECTED
 err1_b_L = EXT [Ntype_io_pad_vol_neg_CHK_lc] Ptype_io_pad_CHK_lc < LU_4_1_6_G_val SINGULAR NOT CONNECTED
 err1_a_R = EXT Ptype_io_pad_vol_pos_275_CHK_lc [Ntype_io_pad_CHK_lc] < LU_4_1_6_G_val SINGULAR NOT CONNECTED
 err1_b_R = EXT Ntype_io_pad_vol_neg_CHK_lc [Ptype_io_pad_CHK_lc] < LU_4_1_6_G_val SINGULAR NOT CONNECTED
 err1_a_L_gC = AA_c COIN EDGE err1_a_L
 err1_b_L_gC = AA_c COIN EDGE err1_b_L
 err1_a_R_gC = AA_c COIN EDGE err1_a_R
 err1_b_R_gC = AA_c COIN EDGE err1_b_R

 err1_a_L_NETID = DFM PROPERTY err1_a_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_a_R_NETID = DFM PROPERTY err1_a_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1_b_L_NETID = DFM PROPERTY err1_b_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_b_R_NETID = DFM PROPERTY err1_b_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1 = DFM PROPERTY err1_a err1_a_L_NETID err1_a_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_a_L_NETID)]
 [NET_b = count(err1_a_R_NETID)]
 [VH_1a = property(err1_a_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_a_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_a_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_a_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 2.75 && property_ref(DT_vA) <= 3.63) || (property_ref(DT_vB) > 2.75 && property_ref(DT_vB) <= 3.63)) ? 1 : 0] > 0

 err2 = DFM PROPERTY err1_b err1_b_L_NETID err1_b_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_b_L_NETID)]
 [NET_b = count(err1_b_R_NETID)]
 [VH_1a = property(err1_b_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_b_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_b_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_b_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 2.75 && property_ref(DT_vA) <= 3.63) || (property_ref(DT_vB) > 2.75 && property_ref(DT_vB) <= 3.63)) ? 1 : 0] > 0

 DFM COPY err1 err2
}

LU_4_1_6b_G {
@ LU.4.1: Space between IO Anode and IO Cathode, or between Power Anode and IO Cathode when 2.75V < Delta V <= 3.63V. >= 15um
@ between Power Anode and IO Cathode 
 err3_a = EXT Ptype_power_pad_vol_pos_275_CHK_lc Ntype_io_pad_CHK_lc < LU_4_1_6_G_val SINGULAR NOT CONNECTED
 err3_b = EXT Ntype_io_pad_vol_neg_CHK_lc Ptype_power_pad_CHK_lc < LU_4_1_6_G_val SINGULAR NOT CONNECTED
 err3_a_L = EXT [Ptype_power_pad_vol_pos_275_CHK_lc] Ntype_io_pad_CHK_lc < LU_4_1_6_G_val SINGULAR NOT CONNECTED
 err3_b_L = EXT [Ntype_io_pad_vol_neg_CHK_lc] Ptype_power_pad_CHK_lc < LU_4_1_6_G_val SINGULAR NOT CONNECTED
 err3_a_R = EXT Ptype_power_pad_vol_pos_275_CHK_lc [Ntype_io_pad_CHK_lc] < LU_4_1_6_G_val SINGULAR NOT CONNECTED
 err3_b_R = EXT Ntype_io_pad_vol_neg_CHK_lc [Ptype_power_pad_CHK_lc] < LU_4_1_6_G_val SINGULAR NOT CONNECTED
 err3_a_L_gC = AA_c COIN EDGE err3_a_L
 err3_b_L_gC = AA_c COIN EDGE err3_b_L
 err3_a_R_gC = AA_c COIN EDGE err3_a_R
 err3_b_R_gC = AA_c COIN EDGE err3_b_R

 err3_a_L_NETID = DFM PROPERTY err3_a_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err3_a_R_NETID = DFM PROPERTY err3_a_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err3_b_L_NETID = DFM PROPERTY err3_b_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err3_b_R_NETID = DFM PROPERTY err3_b_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err3 = DFM PROPERTY err3_a err3_a_L_NETID err3_a_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err3_a_L_NETID)]
 [NET_b = count(err3_a_R_NETID)]
 [VH_1a = property(err3_a_L_NETID, "max_vol", 1)]
 [VL_1a = property(err3_a_L_NETID, "min_vol", 1)]
 [VH_1b = property(err3_a_R_NETID, "max_vol", 1)]
 [VL_1b = property(err3_a_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err3_a_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err3_a_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err3_a_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err3_a_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 2.75 && property_ref(DT_vA) <= 3.63) || (property_ref(DT_vB) > 2.75 && property_ref(DT_vB) <= 3.63)) ? 1 : 0] > 0

 err4 = DFM PROPERTY err3_b err3_b_L_NETID err3_b_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err3_b_L_NETID)]
 [NET_b = count(err3_b_R_NETID)]
 [VH_1a = property(err3_b_L_NETID, "max_vol", 1)]
 [VL_1a = property(err3_b_L_NETID, "min_vol", 1)]
 [VH_1b = property(err3_b_R_NETID, "max_vol", 1)]
 [VL_1b = property(err3_b_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err3_b_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err3_b_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err3_b_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err3_b_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 2.75 && property_ref(DT_vA) <= 3.63) || (property_ref(DT_vB) > 2.75 && property_ref(DT_vB) <= 3.63)) ? 1 : 0] > 0

 DFM COPY err3 err4
}

LU_4_1_7a_G {
@ LU.4.1: Space between IO Anode and IO Cathode, or between Power Anode and IO Cathode when 3.63V < Delta V <= 5.5V. >= 35um
@ between IO Anode and IO Cathode
 err1_a = EXT Ptype_io_pad_vol_pos_363_CHK_lc Ntype_io_pad_CHK_lc < LU_4_1_7_G_val SINGULAR NOT CONNECTED
 err1_b = EXT Ntype_io_pad_vol_neg_CHK_lc Ptype_io_pad_CHK_lc < LU_4_1_7_G_val SINGULAR NOT CONNECTED
 err1_a_L = EXT [Ptype_io_pad_vol_pos_363_CHK_lc] Ntype_io_pad_CHK_lc < LU_4_1_7_G_val SINGULAR NOT CONNECTED
 err1_b_L = EXT [Ntype_io_pad_vol_neg_CHK_lc] Ptype_io_pad_CHK_lc < LU_4_1_7_G_val SINGULAR NOT CONNECTED
 err1_a_R = EXT Ptype_io_pad_vol_pos_363_CHK_lc [Ntype_io_pad_CHK_lc] < LU_4_1_7_G_val SINGULAR NOT CONNECTED
 err1_b_R = EXT Ntype_io_pad_vol_neg_CHK_lc [Ptype_io_pad_CHK_lc] < LU_4_1_7_G_val SINGULAR NOT CONNECTED
 err1_a_L_gC = AA_c COIN EDGE err1_a_L
 err1_b_L_gC = AA_c COIN EDGE err1_b_L
 err1_a_R_gC = AA_c COIN EDGE err1_a_R
 err1_b_R_gC = AA_c COIN EDGE err1_b_R

 err1_a_L_NETID = DFM PROPERTY err1_a_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_a_R_NETID = DFM PROPERTY err1_a_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1_b_L_NETID = DFM PROPERTY err1_b_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_b_R_NETID = DFM PROPERTY err1_b_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1 = DFM PROPERTY err1_a err1_a_L_NETID err1_a_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_a_L_NETID)]
 [NET_b = count(err1_a_R_NETID)]
 [VH_1a = property(err1_a_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_a_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_a_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_a_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 3.63 && property_ref(DT_vA) <= 5.5) || (property_ref(DT_vB) > 3.63 && property_ref(DT_vB) <= 5.5)) ? 1 : 0] > 0

 err2 = DFM PROPERTY err1_b err1_b_L_NETID err1_b_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_b_L_NETID)]
 [NET_b = count(err1_b_R_NETID)]
 [VH_1a = property(err1_b_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_b_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_b_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_b_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 3.63 && property_ref(DT_vA) <= 5.5) || (property_ref(DT_vB) > 3.63 && property_ref(DT_vB) <= 5.5)) ? 1 : 0] > 0

 DFM COPY err1 err2
}

LU_4_1_7b_G {
@ LU.4.1: Space between IO Anode and IO Cathode, or between Power Anode and IO Cathode when 3.63V < Delta V <= 5.5V. >= 35um
@ between Power Anode and IO Cathode
 err3_a = EXT Ptype_power_pad_vol_pos_363_CHK_lc Ntype_io_pad_CHK_lc < LU_4_1_7_G_val SINGULAR NOT CONNECTED
 err3_b = EXT Ntype_io_pad_vol_neg_CHK_lc Ptype_power_pad_CHK_lc < LU_4_1_7_G_val SINGULAR NOT CONNECTED
 err3_a_L = EXT [Ptype_power_pad_vol_pos_363_CHK_lc] Ntype_io_pad_CHK_lc < LU_4_1_7_G_val SINGULAR NOT CONNECTED
 err3_b_L = EXT [Ntype_io_pad_vol_neg_CHK_lc] Ptype_power_pad_CHK_lc < LU_4_1_7_G_val SINGULAR NOT CONNECTED
 err3_a_R = EXT Ptype_power_pad_vol_pos_363_CHK_lc [Ntype_io_pad_CHK_lc] < LU_4_1_7_G_val SINGULAR NOT CONNECTED
 err3_b_R = EXT Ntype_io_pad_vol_neg_CHK_lc [Ptype_power_pad_CHK_lc] < LU_4_1_7_G_val SINGULAR NOT CONNECTED
 err3_a_L_gC = AA_c COIN EDGE err3_a_L
 err3_b_L_gC = AA_c COIN EDGE err3_b_L
 err3_a_R_gC = AA_c COIN EDGE err3_a_R
 err3_b_R_gC = AA_c COIN EDGE err3_b_R

 err3_a_L_NETID = DFM PROPERTY err3_a_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err3_a_R_NETID = DFM PROPERTY err3_a_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err3_b_L_NETID = DFM PROPERTY err3_b_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err3_b_R_NETID = DFM PROPERTY err3_b_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err3 = DFM PROPERTY err3_a err3_a_L_NETID err3_a_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err3_a_L_NETID)]
 [NET_b = count(err3_a_R_NETID)]
 [VH_1a = property(err3_a_L_NETID, "max_vol", 1)]
 [VL_1a = property(err3_a_L_NETID, "min_vol", 1)]
 [VH_1b = property(err3_a_R_NETID, "max_vol", 1)]
 [VL_1b = property(err3_a_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err3_a_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err3_a_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err3_a_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err3_a_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 3.63 && property_ref(DT_vA) <= 5.5) || (property_ref(DT_vB) > 3.63 && property_ref(DT_vB) <= 5.5)) ? 1 : 0] > 0

 err4 = DFM PROPERTY err3_b err3_b_L_NETID err3_b_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err3_b_L_NETID)]
 [NET_b = count(err3_b_R_NETID)]
 [VH_1a = property(err3_b_L_NETID, "max_vol", 1)]
 [VL_1a = property(err3_b_L_NETID, "min_vol", 1)]
 [VH_1b = property(err3_b_R_NETID, "max_vol", 1)]
 [VL_1b = property(err3_b_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err3_b_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err3_b_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err3_b_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err3_b_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 3.63 && property_ref(DT_vA) <= 5.5) || (property_ref(DT_vB) > 3.63 && property_ref(DT_vB) <= 5.5)) ? 1 : 0] > 0

 DFM COPY err3 err4
}

LU_4_2_1a_G {
@ LU.4.2: Space between IO Anode and Power Cathode when 0V < Delta V <= 1V. >= 0.96um
@ The following case can be excluded:
@ NMOS is inside DNW, and this DNW does not physically interact with PMOS NW. At the same time, voltage of the DNW >= voltage of PMOS NW
 err1_a = EXT Ptype_io_pad_vol_pos_CHK_lc Ntype_power_pad_CHK_lc < LU_4_2_1_G_val SINGULAR NOT CONNECTED  //;IO + and Power -
 err1_b = EXT Ptype_io_pad_CHK_lc Ntype_power_pad_vol_neg_CHK_lc < LU_4_2_1_G_val SINGULAR NOT CONNECTED  //;IO + and Power -
 err1_a_L = EXT [Ptype_io_pad_vol_pos_CHK_lc] Ntype_power_pad_CHK_lc < LU_4_2_1_G_val SINGULAR NOT CONNECTED
 err1_b_L = EXT [Ptype_io_pad_CHK_lc] Ntype_power_pad_vol_neg_CHK_lc < LU_4_2_1_G_val SINGULAR NOT CONNECTED
 err1_a_R = EXT Ptype_io_pad_vol_pos_CHK_lc [Ntype_power_pad_CHK_lc] < LU_4_2_1_G_val SINGULAR NOT CONNECTED
 err1_b_R = EXT Ptype_io_pad_CHK_lc [Ntype_power_pad_vol_neg_CHK_lc] < LU_4_2_1_G_val SINGULAR NOT CONNECTED
 err1_a_L_gC = AA_c COIN EDGE err1_a_L
 err1_b_L_gC = AA_c COIN EDGE err1_b_L
 err1_a_R_gC = AA_c COIN EDGE err1_a_R
 err1_b_R_gC = AA_c COIN EDGE err1_b_R

 err1_a_L_NETID = DFM PROPERTY err1_a_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_a_R_NETID = DFM PROPERTY err1_a_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1_b_L_NETID = DFM PROPERTY err1_b_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_b_R_NETID = DFM PROPERTY err1_b_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1 = DFM PROPERTY err1_a err1_a_L_NETID err1_a_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_a_L_NETID)]
 [NET_b = count(err1_a_R_NETID)]
 [VH_1a = property(err1_a_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_a_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_a_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_a_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 0 && property_ref(DT_vA) <= 1.000) || (property_ref(DT_vB) > 0 && property_ref(DT_vB) <= 1.000)) ? 1 : 0] > 0

 err2 = DFM PROPERTY err1_b err1_b_L_NETID err1_b_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_b_L_NETID)]
 [NET_b = count(err1_b_R_NETID)]
 [VH_1a = property(err1_b_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_b_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_b_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_b_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 0 && property_ref(DT_vA) <= 1.000) || (property_ref(DT_vB) > 0 && property_ref(DT_vB) <= 1.000)) ? 1 : 0] > 0

 DFM COPY err1 err2
}

LU_4_2_2a_G {
@ LU.4.2: Space between IO Anode and Power Cathode when 1V < Delta V <= 1.32V. >= 1.824um
@ The following case can be excluded:
@ NMOS is inside DNW, and this DNW does not physically interact with PMOS NW. At the same time, voltage of the DNW >= voltage of PMOS NW
 err1_a = EXT Ptype_io_pad_vol_pos_100_CHK_lc Ntype_power_pad_CHK_lc < LU_4_2_2_G_val SINGULAR NOT CONNECTED
 err1_b = EXT Ptype_io_pad_CHK_lc Ntype_power_pad_vol_neg_CHK_lc < LU_4_2_2_G_val SINGULAR NOT CONNECTED
 err1_a_L = EXT [Ptype_io_pad_vol_pos_100_CHK_lc] Ntype_power_pad_CHK_lc < LU_4_2_2_G_val SINGULAR NOT CONNECTED
 err1_b_L = EXT [Ptype_io_pad_CHK_lc] Ntype_power_pad_vol_neg_CHK_lc < LU_4_2_2_G_val SINGULAR NOT CONNECTED
 err1_a_R = EXT Ptype_io_pad_vol_pos_100_CHK_lc [Ntype_power_pad_CHK_lc] < LU_4_2_2_G_val SINGULAR NOT CONNECTED
 err1_b_R = EXT Ptype_io_pad_CHK_lc [Ntype_power_pad_vol_neg_CHK_lc] < LU_4_2_2_G_val SINGULAR NOT CONNECTED
 err1_a_L_gC = AA_c COIN EDGE err1_a_L
 err1_b_L_gC = AA_c COIN EDGE err1_b_L
 err1_a_R_gC = AA_c COIN EDGE err1_a_R
 err1_b_R_gC = AA_c COIN EDGE err1_b_R

 err1_a_L_NETID = DFM PROPERTY err1_a_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_a_R_NETID = DFM PROPERTY err1_a_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1_b_L_NETID = DFM PROPERTY err1_b_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_b_R_NETID = DFM PROPERTY err1_b_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1 = DFM PROPERTY err1_a err1_a_L_NETID err1_a_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_a_L_NETID)]
 [NET_b = count(err1_a_R_NETID)]
 [VH_1a = property(err1_a_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_a_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_a_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_a_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 1.000 && property_ref(DT_vA) <= 1.32) || (property_ref(DT_vB) > 1.000 && property_ref(DT_vB) <= 1.32)) ? 1 : 0] > 0

 err2 = DFM PROPERTY err1_b err1_b_L_NETID err1_b_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_b_L_NETID)]
 [NET_b = count(err1_b_R_NETID)]
 [VH_1a = property(err1_b_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_b_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_b_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_b_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 1.000 && property_ref(DT_vA) <= 1.32) || (property_ref(DT_vB) > 1.000 && property_ref(DT_vB) <= 1.32)) ? 1 : 0] > 0

 DFM COPY err1 err2
}

LU_4_2_3a_G {
@ LU.4.2: Space between IO Anode and Power Cathode when 1.32V < Delta V <= 1.65V. >= 2.112um
@ The following case can be excluded:
@ NMOS is inside DNW, and this DNW does not physically interact with PMOS NW. At the same time, voltage of the DNW >= voltage of PMOS NW
 err1_a = EXT Ptype_io_pad_vol_pos_132_CHK_lc Ntype_power_pad_CHK_lc < LU_4_2_3_G_val SINGULAR NOT CONNECTED
 err1_b = EXT Ptype_io_pad_CHK_lc Ntype_power_pad_vol_neg_CHK_lc < LU_4_2_3_G_val SINGULAR NOT CONNECTED
 err1_a_L = EXT [Ptype_io_pad_vol_pos_132_CHK_lc] Ntype_power_pad_CHK_lc < LU_4_2_3_G_val SINGULAR NOT CONNECTED
 err1_b_L = EXT [Ptype_io_pad_CHK_lc] Ntype_power_pad_vol_neg_CHK_lc < LU_4_2_3_G_val SINGULAR NOT CONNECTED
 err1_a_R = EXT Ptype_io_pad_vol_pos_132_CHK_lc [Ntype_power_pad_CHK_lc] < LU_4_2_3_G_val SINGULAR NOT CONNECTED
 err1_b_R = EXT Ptype_io_pad_CHK_lc [Ntype_power_pad_vol_neg_CHK_lc] < LU_4_2_3_G_val SINGULAR NOT CONNECTED
 err1_a_L_gC = AA_c COIN EDGE err1_a_L
 err1_b_L_gC = AA_c COIN EDGE err1_b_L
 err1_a_R_gC = AA_c COIN EDGE err1_a_R
 err1_b_R_gC = AA_c COIN EDGE err1_b_R

 err1_a_L_NETID = DFM PROPERTY err1_a_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_a_R_NETID = DFM PROPERTY err1_a_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1_b_L_NETID = DFM PROPERTY err1_b_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_b_R_NETID = DFM PROPERTY err1_b_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1 = DFM PROPERTY err1_a err1_a_L_NETID err1_a_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_a_L_NETID)]
 [NET_b = count(err1_a_R_NETID)]
 [VH_1a = property(err1_a_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_a_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_a_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_a_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 1.32 && property_ref(DT_vA) <= 1.65) || (property_ref(DT_vB) > 1.32 && property_ref(DT_vB) <= 1.65)) ? 1 : 0] > 0

 err2 = DFM PROPERTY err1_b err1_b_L_NETID err1_b_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_b_L_NETID)]
 [NET_b = count(err1_b_R_NETID)]
 [VH_1a = property(err1_b_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_b_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_b_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_b_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 1.32 && property_ref(DT_vA) <= 1.65) || (property_ref(DT_vB) > 1.32 && property_ref(DT_vB) <= 1.65)) ? 1 : 0] > 0

 DFM COPY err1 err2
}

LU_4_2_4a_G {
@ LU.4.2: Space between IO Anode and Power Cathode when 1.65V < Delta V <= 1.98V. >= 4.512um
@ The following case can be excluded:
@ NMOS is inside DNW, and this DNW does not physically interact with PMOS NW. At the same time, voltage of the DNW >= voltage of PMOS NW
 err1_a = EXT Ptype_io_pad_vol_pos_165_CHK_lc Ntype_power_pad_CHK_lc < LU_4_2_4_G_val SINGULAR NOT CONNECTED
 err1_b = EXT Ptype_io_pad_CHK_lc Ntype_power_pad_vol_neg_CHK_lc < LU_4_2_4_G_val SINGULAR NOT CONNECTED
 err1_a_L = EXT [Ptype_io_pad_vol_pos_165_CHK_lc] Ntype_power_pad_CHK_lc < LU_4_2_4_G_val SINGULAR NOT CONNECTED
 err1_b_L = EXT [Ptype_io_pad_CHK_lc] Ntype_power_pad_vol_neg_CHK_lc < LU_4_2_4_G_val SINGULAR NOT CONNECTED
 err1_a_R = EXT Ptype_io_pad_vol_pos_165_CHK_lc [Ntype_power_pad_CHK_lc] < LU_4_2_4_G_val SINGULAR NOT CONNECTED
 err1_b_R = EXT Ptype_io_pad_CHK_lc [Ntype_power_pad_vol_neg_CHK_lc] < LU_4_2_4_G_val SINGULAR NOT CONNECTED
 err1_a_L_gC = AA_c COIN EDGE err1_a_L
 err1_b_L_gC = AA_c COIN EDGE err1_b_L
 err1_a_R_gC = AA_c COIN EDGE err1_a_R
 err1_b_R_gC = AA_c COIN EDGE err1_b_R

 err1_a_L_NETID = DFM PROPERTY err1_a_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_a_R_NETID = DFM PROPERTY err1_a_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1_b_L_NETID = DFM PROPERTY err1_b_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_b_R_NETID = DFM PROPERTY err1_b_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1 = DFM PROPERTY err1_a err1_a_L_NETID err1_a_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_a_L_NETID)]
 [NET_b = count(err1_a_R_NETID)]
 [VH_1a = property(err1_a_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_a_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_a_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_a_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 1.65 && property_ref(DT_vA) <= 1.98) || (property_ref(DT_vB) > 1.65 && property_ref(DT_vB) <= 1.98)) ? 1 : 0] > 0

 err2 = DFM PROPERTY err1_b err1_b_L_NETID err1_b_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_b_L_NETID)]
 [NET_b = count(err1_b_R_NETID)]
 [VH_1a = property(err1_b_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_b_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_b_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_b_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 1.65 && property_ref(DT_vA) <= 1.98) || (property_ref(DT_vB) > 1.65 && property_ref(DT_vB) <= 1.98)) ? 1 : 0] > 0

 DFM COPY err1 err2
}

LU_4_2_5a_G {
@ LU.4.2: Space between IO Anode and Power Cathode when 1.98V < Delta V <= 2.75V. >= 7.968um
@ The following case can be excluded:
@ NMOS is inside DNW, and this DNW does not physically interact with PMOS NW. At the same time, voltage of the DNW >= voltage of PMOS NW
 err1_a = EXT Ptype_io_pad_vol_pos_198_CHK_lc Ntype_power_pad_CHK_lc < LU_4_2_5_G_val SINGULAR NOT CONNECTED
 err1_b = EXT Ptype_io_pad_CHK_lc Ntype_power_pad_vol_neg_CHK_lc < LU_4_2_5_G_val SINGULAR NOT CONNECTED
 err1_a_L = EXT [Ptype_io_pad_vol_pos_198_CHK_lc] Ntype_power_pad_CHK_lc < LU_4_2_5_G_val SINGULAR NOT CONNECTED
 err1_b_L = EXT [Ptype_io_pad_CHK_lc] Ntype_power_pad_vol_neg_CHK_lc < LU_4_2_5_G_val SINGULAR NOT CONNECTED
 err1_a_R = EXT Ptype_io_pad_vol_pos_198_CHK_lc [Ntype_power_pad_CHK_lc] < LU_4_2_5_G_val SINGULAR NOT CONNECTED
 err1_b_R = EXT Ptype_io_pad_CHK_lc [Ntype_power_pad_vol_neg_CHK_lc] < LU_4_2_5_G_val SINGULAR NOT CONNECTED
 err1_a_L_gC = AA_c COIN EDGE err1_a_L
 err1_b_L_gC = AA_c COIN EDGE err1_b_L
 err1_a_R_gC = AA_c COIN EDGE err1_a_R
 err1_b_R_gC = AA_c COIN EDGE err1_b_R

 err1_a_L_NETID = DFM PROPERTY err1_a_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_a_R_NETID = DFM PROPERTY err1_a_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1_b_L_NETID = DFM PROPERTY err1_b_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_b_R_NETID = DFM PROPERTY err1_b_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1 = DFM PROPERTY err1_a err1_a_L_NETID err1_a_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_a_L_NETID)]
 [NET_b = count(err1_a_R_NETID)]
 [VH_1a = property(err1_a_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_a_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_a_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_a_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 1.98 && property_ref(DT_vA) <= 2.75) || (property_ref(DT_vB) > 1.98 && property_ref(DT_vB) <= 2.75)) ? 1 : 0] > 0

 err2 = DFM PROPERTY err1_b err1_b_L_NETID err1_b_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_b_L_NETID)]
 [NET_b = count(err1_b_R_NETID)]
 [VH_1a = property(err1_b_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_b_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_b_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_b_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 1.98 && property_ref(DT_vA) <= 2.75) || (property_ref(DT_vB) > 1.98 && property_ref(DT_vB) <= 2.75)) ? 1 : 0] > 0

 DFM COPY err1 err2
}

LU_4_2_6a_G {
@ LU.4.2: Space between IO Anode and Power Cathode when 2.75V < Delta V <= 3.63V. >= 16.032um
@ The following case can be excluded:
@ NMOS is inside DNW, and this DNW does not physically interact with PMOS NW. At the same time, voltage of the DNW >= voltage of PMOS NW
 err1_a = EXT Ptype_io_pad_vol_pos_275_CHK_lc Ntype_power_pad_CHK_lc < LU_4_2_6_G_val SINGULAR NOT CONNECTED
 err1_b = EXT Ptype_io_pad_CHK_lc Ntype_power_pad_vol_neg_CHK_lc < LU_4_2_6_G_val SINGULAR NOT CONNECTED
 err1_a_L = EXT [Ptype_io_pad_vol_pos_275_CHK_lc] Ntype_power_pad_CHK_lc < LU_4_2_6_G_val SINGULAR NOT CONNECTED
 err1_b_L = EXT [Ptype_io_pad_CHK_lc] Ntype_power_pad_vol_neg_CHK_lc < LU_4_2_6_G_val SINGULAR NOT CONNECTED
 err1_a_R = EXT Ptype_io_pad_vol_pos_275_CHK_lc [Ntype_power_pad_CHK_lc] < LU_4_2_6_G_val SINGULAR NOT CONNECTED
 err1_b_R = EXT Ptype_io_pad_CHK_lc [Ntype_power_pad_vol_neg_CHK_lc] < LU_4_2_6_G_val SINGULAR NOT CONNECTED
 err1_a_L_gC = AA_c COIN EDGE err1_a_L
 err1_b_L_gC = AA_c COIN EDGE err1_b_L
 err1_a_R_gC = AA_c COIN EDGE err1_a_R
 err1_b_R_gC = AA_c COIN EDGE err1_b_R

 err1_a_L_NETID = DFM PROPERTY err1_a_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_a_R_NETID = DFM PROPERTY err1_a_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1_b_L_NETID = DFM PROPERTY err1_b_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_b_R_NETID = DFM PROPERTY err1_b_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1 = DFM PROPERTY err1_a err1_a_L_NETID err1_a_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_a_L_NETID)]
 [NET_b = count(err1_a_R_NETID)]
 [VH_1a = property(err1_a_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_a_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_a_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_a_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 2.75 && property_ref(DT_vA) <= 3.63) || (property_ref(DT_vB) > 2.75 && property_ref(DT_vB) <= 3.63)) ? 1 : 0] > 0

 err2 = DFM PROPERTY err1_b err1_b_L_NETID err1_b_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_b_L_NETID)]
 [NET_b = count(err1_b_R_NETID)]
 [VH_1a = property(err1_b_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_b_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_b_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_b_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 2.75 && property_ref(DT_vA) <= 3.63) || (property_ref(DT_vB) > 2.75 && property_ref(DT_vB) <= 3.63)) ? 1 : 0] > 0

 DFM COPY err1 err2
}

LU_4_2_7a_G {
@ LU.4.2: Space between IO Anode and Power Cathode when 3.63V < Delta V <= 5.5V. >= 35.952um
@ The following case can be excluded:
@ NMOS is inside DNW, and this DNW does not physically interact with PMOS NW. At the same time, voltage of the DNW >= voltage of PMOS NW
 err1_a = EXT Ptype_io_pad_vol_pos_363_CHK_lc Ntype_power_pad_CHK_lc < LU_4_2_7_G_val SINGULAR NOT CONNECTED
 err1_b = EXT Ptype_io_pad_CHK_lc Ntype_power_pad_vol_neg_CHK_lc < LU_4_2_7_G_val SINGULAR NOT CONNECTED
 err1_a_L = EXT [Ptype_io_pad_vol_pos_363_CHK_lc] Ntype_power_pad_CHK_lc < LU_4_2_7_G_val SINGULAR NOT CONNECTED
 err1_b_L = EXT [Ptype_io_pad_CHK_lc] Ntype_power_pad_vol_neg_CHK_lc < LU_4_2_7_G_val SINGULAR NOT CONNECTED
 err1_a_R = EXT Ptype_io_pad_vol_pos_363_CHK_lc [Ntype_power_pad_CHK_lc] < LU_4_2_7_G_val SINGULAR NOT CONNECTED
 err1_b_R = EXT Ptype_io_pad_CHK_lc [Ntype_power_pad_vol_neg_CHK_lc] < LU_4_2_7_G_val SINGULAR NOT CONNECTED
 err1_a_L_gC = AA_c COIN EDGE err1_a_L
 err1_b_L_gC = AA_c COIN EDGE err1_b_L
 err1_a_R_gC = AA_c COIN EDGE err1_a_R
 err1_b_R_gC = AA_c COIN EDGE err1_b_R

 err1_a_L_NETID = DFM PROPERTY err1_a_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_a_R_NETID = DFM PROPERTY err1_a_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1_b_L_NETID = DFM PROPERTY err1_b_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_b_R_NETID = DFM PROPERTY err1_b_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1 = DFM PROPERTY err1_a err1_a_L_NETID err1_a_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_a_L_NETID)]
 [NET_b = count(err1_a_R_NETID)]
 [VH_1a = property(err1_a_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_a_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_a_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_a_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 3.63 && property_ref(DT_vA) <= 5.5) || (property_ref(DT_vB) > 3.63 && property_ref(DT_vB) <= 5.5)) ? 1 : 0] > 0

 err2 = DFM PROPERTY err1_b err1_b_L_NETID err1_b_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_b_L_NETID)]
 [NET_b = count(err1_b_R_NETID)]
 [VH_1a = property(err1_b_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_b_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_b_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_b_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 3.63 && property_ref(DT_vA) <= 5.5) || (property_ref(DT_vB) > 3.63 && property_ref(DT_vB) <= 5.5)) ? 1 : 0] > 0

 DFM COPY err1 err2
}

//;For lu.4.3
RW_anode_vol_gt_pos_100_CHK = NET AREA RATIO RW_anode_CHK PW_NETID_vol_gt_pos_100 > 0
RW_anode_vol_gt_pos_132_CHK = NET AREA RATIO RW_anode_CHK PW_NETID_vol_gt_pos_132 > 0
RW_anode_vol_gt_pos_165_CHK = NET AREA RATIO RW_anode_CHK PW_NETID_vol_gt_pos_165 > 0
RW_anode_vol_gt_pos_198_CHK = NET AREA RATIO RW_anode_CHK PW_NETID_vol_gt_pos_198 > 0
RW_anode_vol_gt_pos_275_CHK = NET AREA RATIO RW_anode_CHK PW_NETID_vol_gt_pos_275 > 0
RW_anode_vol_gt_pos_363_CHK = NET AREA RATIO RW_anode_CHK PW_NETID_vol_gt_pos_363 > 0

RW_anode_vol_pos_CHK_lc = RW_lc INTERACT RW_anode_vol_pos_CHK
RW_anode_vol_gt_pos_100_CHK_lc = RW_lc INTERACT RW_anode_vol_gt_pos_100_CHK
RW_anode_vol_gt_pos_132_CHK_lc = RW_lc INTERACT RW_anode_vol_gt_pos_132_CHK
RW_anode_vol_gt_pos_165_CHK_lc = RW_lc INTERACT RW_anode_vol_gt_pos_165_CHK
RW_anode_vol_gt_pos_198_CHK_lc = RW_lc INTERACT RW_anode_vol_gt_pos_198_CHK
RW_anode_vol_gt_pos_275_CHK_lc = RW_lc INTERACT RW_anode_vol_gt_pos_275_CHK
RW_anode_vol_gt_pos_363_CHK_lc = RW_lc INTERACT RW_anode_vol_gt_pos_363_CHK

NW_cathode_CHK_lc = NW_lc INTERACT NW_cathode_CHK
NW_cathode_vol_neg_CHK_lc = NW_lc INTERACT NW_cathode_vol_neg_CHK

RW_anode_CHK_lc = RW_lc INTERACT RW_anode_CHK
RW_anode_vol_neg_CHK_lc = RW_lc INTERACT RW_anode_CHK_lc

LU_4_3_1a_G {
@ LU.4.3: Space between IO Anode and NW Cathode, or between PW Anode and IO Cathode when 0V < Delta V <= 1V. >= 0.96um
@ Check between IO Anode and NW Cathode
 err1_a = EXT Ptype_io_pad_vol_pos_CHK_lc NW_cathode_CHK_lc < LU_4_3_1_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b = EXT Ptype_io_pad_CHK_lc NW_cathode_vol_neg_CHK_lc < LU_4_3_1_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_L = EXT [Ptype_io_pad_vol_pos_CHK_lc] NW_cathode_CHK_lc < LU_4_3_1_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b_L = EXT [Ptype_io_pad_CHK_lc] NW_cathode_vol_neg_CHK_lc < LU_4_3_1_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_R = EXT Ptype_io_pad_vol_pos_CHK_lc [NW_cathode_CHK_lc] < LU_4_3_1_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b_R = EXT Ptype_io_pad_CHK_lc [NW_cathode_vol_neg_CHK_lc] < LU_4_3_1_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_L_gC = AA_c COIN EDGE err1_a_L
 err1_b_L_gC = AA_c COIN EDGE err1_b_L
 err1_a_R_gC = NW COIN EDGE err1_a_R
 err1_b_R_gC = NW COIN EDGE err1_b_R

 err1_a_L_NETID = DFM PROPERTY err1_a_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_a_R_NETID = DFM PROPERTY err1_a_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1_b_L_NETID = DFM PROPERTY err1_b_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_b_R_NETID = DFM PROPERTY err1_b_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1 = DFM PROPERTY err1_a err1_a_L_NETID err1_a_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_a_L_NETID)]
 [NET_b = count(err1_a_R_NETID)]
 [VH_1a = property(err1_a_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_a_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_a_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_a_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 0 && property_ref(DT_vA) <= 1.000) || (property_ref(DT_vB) > 0 && property_ref(DT_vB) <= 1.000)) ? 1 : 0] > 0

 err2 = DFM PROPERTY err1_b err1_b_L_NETID err1_b_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_b_L_NETID)]
 [NET_b = count(err1_b_R_NETID)]
 [VH_1a = property(err1_b_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_b_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_b_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_b_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 0 && property_ref(DT_vA) <= 1.000) || (property_ref(DT_vB) > 0 && property_ref(DT_vB) <= 1.000)) ? 1 : 0] > 0

 DFM COPY err1 err2
}

LU_4_3_1b_G {
@ LU.4.3: Space between IO Anode and NW Cathode, or between PW Anode and IO Cathode when 0V < Delta V <= 1V. >= 0.96um
@ Check between PW Anode and IO Cathode
 err1_a = EXT Ntype_io_pad_vol_neg_CHK_lc RW_anode_CHK_lc < LU_4_3_1_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b = EXT Ntype_io_pad_CHK_lc RW_anode_vol_pos_CHK_lc < LU_4_3_1_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_L = EXT [Ntype_io_pad_vol_neg_CHK_lc] RW_anode_CHK_lc < LU_4_3_1_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b_L = EXT [Ntype_io_pad_CHK_lc] RW_anode_vol_pos_CHK_lc < LU_4_3_1_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_R = EXT Ntype_io_pad_vol_neg_CHK_lc [RW_anode_CHK_lc] < LU_4_3_1_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b_R = EXT Ntype_io_pad_CHK_lc [RW_anode_vol_pos_CHK_lc] < LU_4_3_1_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_L_gC = AA_c COIN EDGE err1_a_L
 err1_b_L_gC = AA_c COIN EDGE err1_b_L
 err1_a_R_gC = RW COIN EDGE err1_a_R
 err1_b_R_gC = RW COIN EDGE err1_b_R

 err1_a_L_NETID = DFM PROPERTY err1_a_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_a_R_NETID = DFM PROPERTY err1_a_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1_b_L_NETID = DFM PROPERTY err1_b_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_b_R_NETID = DFM PROPERTY err1_b_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1 = DFM PROPERTY err1_a err1_a_L_NETID err1_a_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_a_L_NETID)]
 [NET_b = count(err1_a_R_NETID)]
 [VH_1a = property(err1_a_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_a_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_a_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_a_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 0 && property_ref(DT_vA) <= 1.000) || (property_ref(DT_vB) > 0 && property_ref(DT_vB) <= 1.000)) ? 1 : 0] > 0

 err2 = DFM PROPERTY err1_b err1_b_L_NETID err1_b_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_b_L_NETID)]
 [NET_b = count(err1_b_R_NETID)]
 [VH_1a = property(err1_b_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_b_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_b_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_b_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 0 && property_ref(DT_vA) <= 1.000) || (property_ref(DT_vB) > 0 && property_ref(DT_vB) <= 1.000)) ? 1 : 0] > 0

 DFM COPY err1 err2
}

LU_4_3_2a_G {
@ LU.4.3: Space between IO Anode and NW Cathode, or between PW Anode and IO Cathode when 1V < Delta V <= 1.32V. >= 1.824um
@ Check between IO Anode and NW Cathode
 err1_a = EXT Ptype_io_pad_vol_pos_100_CHK_lc NW_cathode_CHK_lc < LU_4_3_2_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b = EXT Ptype_io_pad_CHK_lc NW_cathode_vol_neg_CHK_lc < LU_4_3_2_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_L = EXT [Ptype_io_pad_vol_pos_100_CHK_lc] NW_cathode_CHK_lc < LU_4_3_2_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b_L = EXT [Ptype_io_pad_CHK_lc] NW_cathode_vol_neg_CHK_lc < LU_4_3_2_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_R = EXT Ptype_io_pad_vol_pos_100_CHK_lc [NW_cathode_CHK_lc] < LU_4_3_2_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b_R = EXT Ptype_io_pad_CHK_lc [NW_cathode_vol_neg_CHK_lc] < LU_4_3_2_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_L_gC = AA_c COIN EDGE err1_a_L
 err1_b_L_gC = AA_c COIN EDGE err1_b_L
 err1_a_R_gC = NW COIN EDGE err1_a_R
 err1_b_R_gC = NW COIN EDGE err1_b_R

 err1_a_L_NETID = DFM PROPERTY err1_a_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_a_R_NETID = DFM PROPERTY err1_a_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1_b_L_NETID = DFM PROPERTY err1_b_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_b_R_NETID = DFM PROPERTY err1_b_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1 = DFM PROPERTY err1_a err1_a_L_NETID err1_a_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_a_L_NETID)]
 [NET_b = count(err1_a_R_NETID)]
 [VH_1a = property(err1_a_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_a_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_a_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_a_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 1.000 && property_ref(DT_vA) <= 1.32) || (property_ref(DT_vB) > 1.000 && property_ref(DT_vB) <= 1.32)) ? 1 : 0] > 0

 err2 = DFM PROPERTY err1_b err1_b_L_NETID err1_b_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_b_L_NETID)]
 [NET_b = count(err1_b_R_NETID)]
 [VH_1a = property(err1_b_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_b_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_b_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_b_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 1.000 && property_ref(DT_vA) <= 1.32) || (property_ref(DT_vB) > 1.000 && property_ref(DT_vB) <= 1.32)) ? 1 : 0] > 0

 DFM COPY err1 err2
}

LU_4_3_2b_G {
@ LU.4.3: Space between IO Anode and NW Cathode, or between PW Anode and IO Cathode when 1V < Delta V <= 1.32V. >= 1.824um
@ Check between PW Anode and IO Cathode
 err1_a = EXT Ntype_io_pad_vol_neg_CHK_lc RW_anode_CHK_lc < LU_4_3_2_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b = EXT Ntype_io_pad_CHK_lc RW_anode_vol_gt_pos_100_CHK_lc < LU_4_3_2_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_L = EXT [Ntype_io_pad_vol_neg_CHK_lc] RW_anode_CHK_lc < LU_4_3_2_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b_L = EXT [Ntype_io_pad_CHK_lc] RW_anode_vol_gt_pos_100_CHK_lc < LU_4_3_2_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_R = EXT Ntype_io_pad_vol_neg_CHK_lc [RW_anode_CHK_lc] < LU_4_3_2_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b_R = EXT Ntype_io_pad_CHK_lc [RW_anode_vol_gt_pos_100_CHK_lc] < LU_4_3_2_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_L_gC = AA_c COIN EDGE err1_a_L
 err1_b_L_gC = AA_c COIN EDGE err1_b_L
 err1_a_R_gC = RW COIN EDGE err1_a_R
 err1_b_R_gC = RW COIN EDGE err1_b_R

 err1_a_L_NETID = DFM PROPERTY err1_a_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_a_R_NETID = DFM PROPERTY err1_a_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1_b_L_NETID = DFM PROPERTY err1_b_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_b_R_NETID = DFM PROPERTY err1_b_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1 = DFM PROPERTY err1_a err1_a_L_NETID err1_a_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_a_L_NETID)]
 [NET_b = count(err1_a_R_NETID)]
 [VH_1a = property(err1_a_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_a_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_a_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_a_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 1.000 && property_ref(DT_vA) <= 1.32) || (property_ref(DT_vB) > 1.000 && property_ref(DT_vB) <= 1.32)) ? 1 : 0] > 0

 err2 = DFM PROPERTY err1_b err1_b_L_NETID err1_b_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_b_L_NETID)]
 [NET_b = count(err1_b_R_NETID)]
 [VH_1a = property(err1_b_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_b_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_b_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_b_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 1.000 && property_ref(DT_vA) <= 1.32) || (property_ref(DT_vB) > 1.000 && property_ref(DT_vB) <= 1.32)) ? 1 : 0] > 0

 DFM COPY err1 err2
}

LU_4_3_3a_G {
@ LU.4.3: Space between IO Anode and NW Cathode, or between PW Anode and IO Cathode when 1.32V < Delta V <= 1.65V. >= 2.12um
@ Check between IO Anode and NW Cathode
 err1_a = EXT Ptype_io_pad_vol_pos_132_CHK_lc NW_cathode_CHK_lc < LU_4_3_3_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b = EXT Ptype_io_pad_CHK_lc NW_cathode_vol_neg_CHK_lc < LU_4_3_3_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_L = EXT [Ptype_io_pad_vol_pos_132_CHK_lc] NW_cathode_CHK_lc < LU_4_3_3_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b_L = EXT [Ptype_io_pad_CHK_lc] NW_cathode_vol_neg_CHK_lc < LU_4_3_3_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_R = EXT Ptype_io_pad_vol_pos_132_CHK_lc [NW_cathode_CHK_lc] < LU_4_3_3_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b_R = EXT Ptype_io_pad_CHK_lc [NW_cathode_vol_neg_CHK_lc] < LU_4_3_3_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_L_gC = AA_c COIN EDGE err1_a_L
 err1_b_L_gC = AA_c COIN EDGE err1_b_L
 err1_a_R_gC = NW COIN EDGE err1_a_R
 err1_b_R_gC = NW COIN EDGE err1_b_R

 err1_a_L_NETID = DFM PROPERTY err1_a_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_a_R_NETID = DFM PROPERTY err1_a_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1_b_L_NETID = DFM PROPERTY err1_b_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_b_R_NETID = DFM PROPERTY err1_b_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1 = DFM PROPERTY err1_a err1_a_L_NETID err1_a_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_a_L_NETID)]
 [NET_b = count(err1_a_R_NETID)]
 [VH_1a = property(err1_a_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_a_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_a_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_a_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 1.32 && property_ref(DT_vA) <= 1.65) || (property_ref(DT_vB) > 1.32 && property_ref(DT_vB) <= 1.65)) ? 1 : 0] > 0

 err2 = DFM PROPERTY err1_b err1_b_L_NETID err1_b_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_b_L_NETID)]
 [NET_b = count(err1_b_R_NETID)]
 [VH_1a = property(err1_b_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_b_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_b_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_b_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 1.32 && property_ref(DT_vA) <= 1.65) || (property_ref(DT_vB) > 1.32 && property_ref(DT_vB) <= 1.65)) ? 1 : 0] > 0

 DFM COPY err1 err2
}

LU_4_3_3b_G {
@ LU.4.3: Space between IO Anode and NW Cathode, or between PW Anode and IO Cathode when 1.32V < Delta V <= 1.65V. >= 2.12um
@ Check between PW Anode and IO Cathode
 err1_a = EXT Ntype_io_pad_vol_neg_CHK_lc RW_anode_CHK_lc < LU_4_3_3_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b = EXT Ntype_io_pad_CHK_lc RW_anode_vol_gt_pos_132_CHK_lc < LU_4_3_3_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_L = EXT [Ntype_io_pad_vol_neg_CHK_lc] RW_anode_CHK_lc < LU_4_3_3_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b_L = EXT [Ntype_io_pad_CHK_lc] RW_anode_vol_gt_pos_132_CHK_lc < LU_4_3_3_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_R = EXT Ntype_io_pad_vol_neg_CHK_lc [RW_anode_CHK_lc] < LU_4_3_3_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b_R = EXT Ntype_io_pad_CHK_lc [RW_anode_vol_gt_pos_132_CHK_lc] < LU_4_3_3_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_L_gC = AA_c COIN EDGE err1_a_L
 err1_b_L_gC = AA_c COIN EDGE err1_b_L
 err1_a_R_gC = RW COIN EDGE err1_a_R
 err1_b_R_gC = RW COIN EDGE err1_b_R

 err1_a_L_NETID = DFM PROPERTY err1_a_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_a_R_NETID = DFM PROPERTY err1_a_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1_b_L_NETID = DFM PROPERTY err1_b_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_b_R_NETID = DFM PROPERTY err1_b_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1 = DFM PROPERTY err1_a err1_a_L_NETID err1_a_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_a_L_NETID)]
 [NET_b = count(err1_a_R_NETID)]
 [VH_1a = property(err1_a_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_a_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_a_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_a_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 1.32 && property_ref(DT_vA) <= 1.65) || (property_ref(DT_vB) > 1.32 && property_ref(DT_vB) <= 1.65)) ? 1 : 0] > 0

 err2 = DFM PROPERTY err1_b err1_b_L_NETID err1_b_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_b_L_NETID)]
 [NET_b = count(err1_b_R_NETID)]
 [VH_1a = property(err1_b_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_b_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_b_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_b_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 1.32 && property_ref(DT_vA) <= 1.65) || (property_ref(DT_vB) > 1.32 && property_ref(DT_vB) <= 1.65)) ? 1 : 0] > 0

 DFM COPY err1 err2
}

LU_4_3_4a_G {
@ LU.4.3: Space between IO Anode and NW Cathode, or between PW Anode and IO Cathode when 1.65V < Delta V <= 1.98V. >= 4.464um
@ Check between IO Anode and NW Cathode
 err1_a = EXT Ptype_io_pad_vol_pos_165_CHK_lc NW_cathode_CHK_lc < LU_4_3_4_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b = EXT Ptype_io_pad_CHK_lc NW_cathode_vol_neg_CHK_lc < LU_4_3_4_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_L = EXT [Ptype_io_pad_vol_pos_165_CHK_lc] NW_cathode_CHK_lc < LU_4_3_4_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b_L = EXT [Ptype_io_pad_CHK_lc] NW_cathode_vol_neg_CHK_lc < LU_4_3_4_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_R = EXT Ptype_io_pad_vol_pos_165_CHK_lc [NW_cathode_CHK_lc] < LU_4_3_4_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b_R = EXT Ptype_io_pad_CHK_lc [NW_cathode_vol_neg_CHK_lc] < LU_4_3_4_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_L_gC = AA_c COIN EDGE err1_a_L
 err1_b_L_gC = AA_c COIN EDGE err1_b_L
 err1_a_R_gC = NW COIN EDGE err1_a_R
 err1_b_R_gC = NW COIN EDGE err1_b_R

 err1_a_L_NETID = DFM PROPERTY err1_a_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_a_R_NETID = DFM PROPERTY err1_a_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1_b_L_NETID = DFM PROPERTY err1_b_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_b_R_NETID = DFM PROPERTY err1_b_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1 = DFM PROPERTY err1_a err1_a_L_NETID err1_a_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_a_L_NETID)]
 [NET_b = count(err1_a_R_NETID)]
 [VH_1a = property(err1_a_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_a_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_a_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_a_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 1.65 && property_ref(DT_vA) <= 1.98) || (property_ref(DT_vB) > 1.65 && property_ref(DT_vB) <= 1.98)) ? 1 : 0] > 0

 err2 = DFM PROPERTY err1_b err1_b_L_NETID err1_b_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_b_L_NETID)]
 [NET_b = count(err1_b_R_NETID)]
 [VH_1a = property(err1_b_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_b_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_b_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_b_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 1.65 && property_ref(DT_vA) <= 1.98) || (property_ref(DT_vB) > 1.65 && property_ref(DT_vB) <= 1.98)) ? 1 : 0] > 0

 DFM COPY err1 err2
}

LU_4_3_4b_G {
@ LU.4.3: Space between IO Anode and NW Cathode, or between PW Anode and IO Cathode when 1.65V < Delta V <= 1.98V. >= 4.464um
@ Check between PW Anode and IO Cathode
 err1_a = EXT Ntype_io_pad_vol_neg_CHK_lc RW_anode_CHK_lc < LU_4_3_4_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b = EXT Ntype_io_pad_CHK_lc RW_anode_vol_gt_pos_165_CHK_lc < LU_4_3_4_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_L = EXT [Ntype_io_pad_vol_neg_CHK_lc] RW_anode_CHK_lc < LU_4_3_4_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b_L = EXT [Ntype_io_pad_CHK_lc] RW_anode_vol_gt_pos_165_CHK_lc < LU_4_3_4_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_R = EXT Ntype_io_pad_vol_neg_CHK_lc [RW_anode_CHK_lc] < LU_4_3_4_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b_R = EXT Ntype_io_pad_CHK_lc [RW_anode_vol_gt_pos_165_CHK_lc] < LU_4_3_4_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_L_gC = AA_c COIN EDGE err1_a_L
 err1_b_L_gC = AA_c COIN EDGE err1_b_L
 err1_a_R_gC = RW COIN EDGE err1_a_R
 err1_b_R_gC = RW COIN EDGE err1_b_R

 err1_a_L_NETID = DFM PROPERTY err1_a_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_a_R_NETID = DFM PROPERTY err1_a_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1_b_L_NETID = DFM PROPERTY err1_b_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_b_R_NETID = DFM PROPERTY err1_b_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1 = DFM PROPERTY err1_a err1_a_L_NETID err1_a_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_a_L_NETID)]
 [NET_b = count(err1_a_R_NETID)]
 [VH_1a = property(err1_a_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_a_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_a_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_a_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 1.65 && property_ref(DT_vA) <= 1.98) || (property_ref(DT_vB) > 1.65 && property_ref(DT_vB) <= 1.98)) ? 1 : 0] > 0

 err2 = DFM PROPERTY err1_b err1_b_L_NETID err1_b_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_b_L_NETID)]
 [NET_b = count(err1_b_R_NETID)]
 [VH_1a = property(err1_b_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_b_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_b_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_b_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 1.65 && property_ref(DT_vA) <= 1.98) || (property_ref(DT_vB) > 1.65 && property_ref(DT_vB) <= 1.98)) ? 1 : 0] > 0

 DFM COPY err1 err2
}

LU_4_3_5a_G {
@ LU.4.3: Space between IO Anode and NW Cathode, or between PW Anode and IO Cathode when 1.98V < Delta V <= 2.75V. >= 7.968um
@ Check between IO Anode and NW Cathode
 err1_a = EXT Ptype_io_pad_vol_pos_198_CHK_lc NW_cathode_CHK_lc < LU_4_3_5_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b = EXT Ptype_io_pad_CHK_lc NW_cathode_vol_neg_CHK_lc < LU_4_3_5_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_L = EXT [Ptype_io_pad_vol_pos_198_CHK_lc] NW_cathode_CHK_lc < LU_4_3_5_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b_L = EXT [Ptype_io_pad_CHK_lc] NW_cathode_vol_neg_CHK_lc < LU_4_3_5_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_R = EXT Ptype_io_pad_vol_pos_198_CHK_lc [NW_cathode_CHK_lc] < LU_4_3_5_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b_R = EXT Ptype_io_pad_CHK_lc [NW_cathode_vol_neg_CHK_lc] < LU_4_3_5_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_L_gC = AA_c COIN EDGE err1_a_L
 err1_b_L_gC = AA_c COIN EDGE err1_b_L
 err1_a_R_gC = NW COIN EDGE err1_a_R
 err1_b_R_gC = NW COIN EDGE err1_b_R

 err1_a_L_NETID = DFM PROPERTY err1_a_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_a_R_NETID = DFM PROPERTY err1_a_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1_b_L_NETID = DFM PROPERTY err1_b_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_b_R_NETID = DFM PROPERTY err1_b_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1 = DFM PROPERTY err1_a err1_a_L_NETID err1_a_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_a_L_NETID)]
 [NET_b = count(err1_a_R_NETID)]
 [VH_1a = property(err1_a_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_a_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_a_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_a_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 1.98 && property_ref(DT_vA) <= 2.75) || (property_ref(DT_vB) > 1.98 && property_ref(DT_vB) <= 2.75)) ? 1 : 0] > 0

 err2 = DFM PROPERTY err1_b err1_b_L_NETID err1_b_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_b_L_NETID)]
 [NET_b = count(err1_b_R_NETID)]
 [VH_1a = property(err1_b_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_b_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_b_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_b_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 1.98 && property_ref(DT_vA) <= 2.75) || (property_ref(DT_vB) > 1.98 && property_ref(DT_vB) <= 2.75)) ? 1 : 0] > 0

 DFM COPY err1 err2
}

LU_4_3_5b_G {
@ LU.4.3: Space between IO Anode and NW Cathode, or between PW Anode and IO Cathode when 1.98V < Delta V <= 2.75V. >= 7.968um
@ Check between PW Anode and IO Cathode
 err1_a = EXT Ntype_io_pad_vol_neg_CHK_lc RW_anode_CHK_lc < LU_4_3_5_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b = EXT Ntype_io_pad_CHK_lc RW_anode_vol_gt_pos_198_CHK_lc < LU_4_3_5_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_L = EXT [Ntype_io_pad_vol_neg_CHK_lc] RW_anode_CHK_lc < LU_4_3_5_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b_L = EXT [Ntype_io_pad_CHK_lc] RW_anode_vol_gt_pos_198_CHK_lc < LU_4_3_5_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_R = EXT Ntype_io_pad_vol_neg_CHK_lc [RW_anode_CHK_lc] < LU_4_3_5_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b_R = EXT Ntype_io_pad_CHK_lc [RW_anode_vol_gt_pos_198_CHK_lc] < LU_4_3_5_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_L_gC = AA_c COIN EDGE err1_a_L
 err1_b_L_gC = AA_c COIN EDGE err1_b_L
 err1_a_R_gC = RW COIN EDGE err1_a_R
 err1_b_R_gC = RW COIN EDGE err1_b_R

 err1_a_L_NETID = DFM PROPERTY err1_a_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_a_R_NETID = DFM PROPERTY err1_a_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1_b_L_NETID = DFM PROPERTY err1_b_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_b_R_NETID = DFM PROPERTY err1_b_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1 = DFM PROPERTY err1_a err1_a_L_NETID err1_a_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_a_L_NETID)]
 [NET_b = count(err1_a_R_NETID)]
 [VH_1a = property(err1_a_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_a_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_a_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_a_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 1.98 && property_ref(DT_vA) <= 2.75) || (property_ref(DT_vB) > 1.98 && property_ref(DT_vB) <= 2.75)) ? 1 : 0] > 0

 err2 = DFM PROPERTY err1_b err1_b_L_NETID err1_b_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_b_L_NETID)]
 [NET_b = count(err1_b_R_NETID)]
 [VH_1a = property(err1_b_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_b_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_b_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_b_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 1.98 && property_ref(DT_vA) <= 2.75) || (property_ref(DT_vB) > 1.98 && property_ref(DT_vB) <= 2.75)) ? 1 : 0] > 0

 DFM COPY err1 err2
}

LU_4_3_6a_G {
@ LU.4.3: Space between IO Anode and NW Cathode, or between PW Anode and IO Cathode when 2.75V < Delta V <= 3.63V. >= 16.032um
@ Check between IO Anode and NW Cathode
 err1_a = EXT Ptype_io_pad_vol_pos_275_CHK_lc NW_cathode_CHK_lc < LU_4_3_6_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b = EXT Ptype_io_pad_CHK_lc NW_cathode_vol_neg_CHK_lc < LU_4_3_6_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_L = EXT [Ptype_io_pad_vol_pos_275_CHK_lc] NW_cathode_CHK_lc < LU_4_3_6_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b_L = EXT [Ptype_io_pad_CHK_lc] NW_cathode_vol_neg_CHK_lc < LU_4_3_6_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_R = EXT Ptype_io_pad_vol_pos_275_CHK_lc [NW_cathode_CHK_lc] < LU_4_3_6_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b_R = EXT Ptype_io_pad_CHK_lc [NW_cathode_vol_neg_CHK_lc] < LU_4_3_6_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_L_gC = AA_c COIN EDGE err1_a_L
 err1_b_L_gC = AA_c COIN EDGE err1_b_L
 err1_a_R_gC = NW COIN EDGE err1_a_R
 err1_b_R_gC = NW COIN EDGE err1_b_R

 err1_a_L_NETID = DFM PROPERTY err1_a_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_a_R_NETID = DFM PROPERTY err1_a_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1_b_L_NETID = DFM PROPERTY err1_b_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_b_R_NETID = DFM PROPERTY err1_b_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1 = DFM PROPERTY err1_a err1_a_L_NETID err1_a_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_a_L_NETID)]
 [NET_b = count(err1_a_R_NETID)]
 [VH_1a = property(err1_a_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_a_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_a_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_a_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 2.75 && property_ref(DT_vA) <= 3.63) || (property_ref(DT_vB) > 2.75 && property_ref(DT_vB) <= 3.63)) ? 1 : 0] > 0

 err2 = DFM PROPERTY err1_b err1_b_L_NETID err1_b_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_b_L_NETID)]
 [NET_b = count(err1_b_R_NETID)]
 [VH_1a = property(err1_b_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_b_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_b_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_b_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 2.75 && property_ref(DT_vA) <= 3.63) || (property_ref(DT_vB) > 2.75 && property_ref(DT_vB) <= 3.63)) ? 1 : 0] > 0

 DFM COPY err1 err2
}

LU_4_3_6b_G {
@ LU.4.3: Space between IO Anode and NW Cathode, or between PW Anode and IO Cathode when 2.75V < Delta V <= 3.63V. >= 16.032um
@ Check between PW Anode and IO Cathode
 err1_a = EXT Ntype_io_pad_vol_neg_CHK_lc RW_anode_CHK_lc < LU_4_3_6_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b = EXT Ntype_io_pad_CHK_lc RW_anode_vol_gt_pos_275_CHK_lc < LU_4_3_6_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_L = EXT [Ntype_io_pad_vol_neg_CHK_lc] RW_anode_CHK_lc < LU_4_3_6_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b_L = EXT [Ntype_io_pad_CHK_lc] RW_anode_vol_gt_pos_275_CHK_lc < LU_4_3_6_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_R = EXT Ntype_io_pad_vol_neg_CHK_lc [RW_anode_CHK_lc] < LU_4_3_6_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b_R = EXT Ntype_io_pad_CHK_lc [RW_anode_vol_gt_pos_275_CHK_lc] < LU_4_3_6_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_L_gC = AA_c COIN EDGE err1_a_L
 err1_b_L_gC = AA_c COIN EDGE err1_b_L
 err1_a_R_gC = RW COIN EDGE err1_a_R
 err1_b_R_gC = RW COIN EDGE err1_b_R

 err1_a_L_NETID = DFM PROPERTY err1_a_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_a_R_NETID = DFM PROPERTY err1_a_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1_b_L_NETID = DFM PROPERTY err1_b_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_b_R_NETID = DFM PROPERTY err1_b_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1 = DFM PROPERTY err1_a err1_a_L_NETID err1_a_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_a_L_NETID)]
 [NET_b = count(err1_a_R_NETID)]
 [VH_1a = property(err1_a_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_a_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_a_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_a_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 2.75 && property_ref(DT_vA) <= 3.63) || (property_ref(DT_vB) > 2.75 && property_ref(DT_vB) <= 3.63)) ? 1 : 0] > 0

 err2 = DFM PROPERTY err1_b err1_b_L_NETID err1_b_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_b_L_NETID)]
 [NET_b = count(err1_b_R_NETID)]
 [VH_1a = property(err1_b_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_b_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_b_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_b_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 2.75 && property_ref(DT_vA) <= 3.63) || (property_ref(DT_vB) > 2.75 && property_ref(DT_vB) <= 3.63)) ? 1 : 0] > 0

 DFM COPY err1 err2
}

LU_4_3_7a_G {
@ LU.4.3: Space between IO Anode and NW Cathode, or between PW Anode and IO Cathode when 3.63V < Delta V <= 5.5V. >= 36um
@ Check between IO Anode and NW Cathode
 err1_a = EXT Ptype_io_pad_vol_pos_363_CHK_lc NW_cathode_CHK_lc < LU_4_3_7_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b = EXT Ptype_io_pad_CHK_lc NW_cathode_vol_neg_CHK_lc < LU_4_3_7_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_L = EXT [Ptype_io_pad_vol_pos_363_CHK_lc] NW_cathode_CHK_lc < LU_4_3_7_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b_L = EXT [Ptype_io_pad_CHK_lc] NW_cathode_vol_neg_CHK_lc < LU_4_3_7_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_R = EXT Ptype_io_pad_vol_pos_363_CHK_lc [NW_cathode_CHK_lc] < LU_4_3_7_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b_R = EXT Ptype_io_pad_CHK_lc [NW_cathode_vol_neg_CHK_lc] < LU_4_3_7_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_L_gC = AA_c COIN EDGE err1_a_L
 err1_b_L_gC = AA_c COIN EDGE err1_b_L
 err1_a_R_gC = NW COIN EDGE err1_a_R
 err1_b_R_gC = NW COIN EDGE err1_b_R

 err1_a_L_NETID = DFM PROPERTY err1_a_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_a_R_NETID = DFM PROPERTY err1_a_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1_b_L_NETID = DFM PROPERTY err1_b_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_b_R_NETID = DFM PROPERTY err1_b_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1 = DFM PROPERTY err1_a err1_a_L_NETID err1_a_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_a_L_NETID)]
 [NET_b = count(err1_a_R_NETID)]
 [VH_1a = property(err1_a_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_a_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_a_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_a_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 3.63 && property_ref(DT_vA) <= 5.5) || (property_ref(DT_vB) > 3.63 && property_ref(DT_vB) <= 5.5)) ? 1 : 0] > 0

 err2 = DFM PROPERTY err1_b err1_b_L_NETID err1_b_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_b_L_NETID)]
 [NET_b = count(err1_b_R_NETID)]
 [VH_1a = property(err1_b_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_b_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_b_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_b_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 3.63 && property_ref(DT_vA) <= 5.5) || (property_ref(DT_vB) > 3.63 && property_ref(DT_vB) <= 5.5)) ? 1 : 0] > 0

 DFM COPY err1 err2
}

LU_4_3_7b_G {
@ LU.4.3: Space between IO Anode and NW Cathode, or between PW Anode and IO Cathode when 3.63V < Delta V <= 5.5V. >= 36um
@ Check between PW Anode and IO Cathode
 err1_a = EXT Ntype_io_pad_vol_neg_CHK_lc RW_anode_CHK_lc < LU_4_3_7_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b = EXT Ntype_io_pad_CHK_lc RW_anode_vol_gt_pos_363_CHK_lc < LU_4_3_7_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_L = EXT [Ntype_io_pad_vol_neg_CHK_lc] RW_anode_CHK_lc < LU_4_3_7_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b_L = EXT [Ntype_io_pad_CHK_lc] RW_anode_vol_gt_pos_363_CHK_lc < LU_4_3_7_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_R = EXT Ntype_io_pad_vol_neg_CHK_lc [RW_anode_CHK_lc] < LU_4_3_7_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b_R = EXT Ntype_io_pad_CHK_lc [RW_anode_vol_gt_pos_363_CHK_lc] < LU_4_3_7_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_L_gC = AA_c COIN EDGE err1_a_L
 err1_b_L_gC = AA_c COIN EDGE err1_b_L
 err1_a_R_gC = RW COIN EDGE err1_a_R
 err1_b_R_gC = RW COIN EDGE err1_b_R

 err1_a_L_NETID = DFM PROPERTY err1_a_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_a_R_NETID = DFM PROPERTY err1_a_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1_b_L_NETID = DFM PROPERTY err1_b_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_b_R_NETID = DFM PROPERTY err1_b_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1 = DFM PROPERTY err1_a err1_a_L_NETID err1_a_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_a_L_NETID)]
 [NET_b = count(err1_a_R_NETID)]
 [VH_1a = property(err1_a_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_a_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_a_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_a_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 3.63 && property_ref(DT_vA) <= 5.5) || (property_ref(DT_vB) > 3.63 && property_ref(DT_vB) <= 5.5)) ? 1 : 0] > 0

 err2 = DFM PROPERTY err1_b err1_b_L_NETID err1_b_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_b_L_NETID)]
 [NET_b = count(err1_b_R_NETID)]
 [VH_1a = property(err1_b_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_b_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_b_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_b_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 3.63 && property_ref(DT_vA) <= 5.5) || (property_ref(DT_vB) > 3.63 && property_ref(DT_vB) <= 5.5)) ? 1 : 0] > 0

 DFM COPY err1 err2
}

//;For lu.4.4
Ptype_power_pad_within_io_pad_140 = Ptype_power_pad_CHK INTERACT AACT_io_pad_dev_SWELL_14
Ntype_power_pad_within_io_pad_140 = Ntype_power_pad_CHK INTERACT AACT_io_pad_dev_SWELL_14
Ntype_power_pad_within_io_pad_140_neg = Ntype_power_pad_vol_neg_CHK INTERACT AACT_io_pad_dev_SWELL_14

Ptype_power_pad_within_io_pad_140_lc = AA_lc INTERACT Ptype_power_pad_within_io_pad_140
Ntype_power_pad_within_io_pad_140_lc = AA_lc INTERACT Ntype_power_pad_within_io_pad_140
Ntype_power_pad_within_io_pad_140_neg_lc = AA_lc INTERACT Ntype_power_pad_within_io_pad_140_neg

Ptype_power_anode_vol_pos = Ptype_power_pad_vol_pos_CHK INTERACT AACT_io_pad_dev_SWELL_14
Ptype_power_anode_vol_gt_pos_100 = Ptype_power_pad_vol_gt_pos_100 INTERACT AACT_io_pad_dev_SWELL_14
Ptype_power_anode_vol_gt_pos_132 = Ptype_power_pad_vol_gt_pos_132 INTERACT AACT_io_pad_dev_SWELL_14
Ptype_power_anode_vol_gt_pos_165 = Ptype_power_pad_vol_gt_pos_165 INTERACT AACT_io_pad_dev_SWELL_14
Ptype_power_anode_vol_gt_pos_198 = Ptype_power_pad_vol_gt_pos_198 INTERACT AACT_io_pad_dev_SWELL_14
Ptype_power_anode_vol_gt_pos_275 = Ptype_power_pad_vol_gt_pos_275 INTERACT AACT_io_pad_dev_SWELL_14
Ptype_power_anode_vol_gt_pos_363 = Ptype_power_pad_vol_gt_pos_363 INTERACT AACT_io_pad_dev_SWELL_14

Ptype_power_anode_vol_pos_lc = AA_lc INTERACT Ptype_power_anode_vol_pos
Ptype_power_anode_vol_gt_pos_100_lc = AA_lc INTERACT Ptype_power_anode_vol_gt_pos_100
Ptype_power_anode_vol_gt_pos_132_lc = AA_lc INTERACT Ptype_power_anode_vol_gt_pos_132
Ptype_power_anode_vol_gt_pos_165_lc = AA_lc INTERACT Ptype_power_anode_vol_gt_pos_165
Ptype_power_anode_vol_gt_pos_198_lc = AA_lc INTERACT Ptype_power_anode_vol_gt_pos_198
Ptype_power_anode_vol_gt_pos_275_lc = AA_lc INTERACT Ptype_power_anode_vol_gt_pos_275
Ptype_power_anode_vol_gt_pos_363_lc = AA_lc INTERACT Ptype_power_anode_vol_gt_pos_363

PW_anode_within_io_pad_140 = RW_anode_CHK INTERACT AACT_io_pad_dev_SWELL_14
NW_cathode_within_io_pad_140 = NW_cathode_CHK INTERACT AACT_io_pad_dev_SWELL_14
NW_cathode_within_io_pad_140_neg = NW_cathode_vol_neg_CHK INTERACT AACT_io_pad_dev_SWELL_14

PW_anode_within_io_pad_140_lc = RW_lc INTERACT PW_anode_within_io_pad_140
NW_cathode_within_io_pad_140_lc = NW_lc INTERACT NW_cathode_within_io_pad_140
NW_cathode_within_io_pad_140_neg_lc = NW_lc INTERACT NW_cathode_within_io_pad_140_neg

PW_anode_vol_pos_CHK = RW_anode_vol_pos_CHK INTERACT AACT_io_pad_dev_SWELL_14
PW_anode_vol_gt_pos_100_CHK = RW_anode_vol_gt_pos_100_CHK INTERACT AACT_io_pad_dev_SWELL_14
PW_anode_vol_gt_pos_132_CHK = RW_anode_vol_gt_pos_132_CHK INTERACT AACT_io_pad_dev_SWELL_14
PW_anode_vol_gt_pos_165_CHK = RW_anode_vol_gt_pos_165_CHK INTERACT AACT_io_pad_dev_SWELL_14
PW_anode_vol_gt_pos_198_CHK = RW_anode_vol_gt_pos_198_CHK INTERACT AACT_io_pad_dev_SWELL_14
PW_anode_vol_gt_pos_275_CHK = RW_anode_vol_gt_pos_275_CHK INTERACT AACT_io_pad_dev_SWELL_14
PW_anode_vol_gt_pos_363_CHK = RW_anode_vol_gt_pos_363_CHK INTERACT AACT_io_pad_dev_SWELL_14

PW_anode_vol_pos_CHK_lc = RW_lc INTERACT PW_anode_vol_pos_CHK
PW_anode_vol_gt_pos_100_CHK_lc = RW_lc INTERACT PW_anode_vol_gt_pos_100_CHK
PW_anode_vol_gt_pos_132_CHK_lc = RW_lc INTERACT PW_anode_vol_gt_pos_132_CHK
PW_anode_vol_gt_pos_165_CHK_lc = RW_lc INTERACT PW_anode_vol_gt_pos_165_CHK
PW_anode_vol_gt_pos_198_CHK_lc = RW_lc INTERACT PW_anode_vol_gt_pos_198_CHK
PW_anode_vol_gt_pos_275_CHK_lc = RW_lc INTERACT PW_anode_vol_gt_pos_275_CHK
PW_anode_vol_gt_pos_363_CHK_lc = RW_lc INTERACT PW_anode_vol_gt_pos_363_CHK

LU_4_4_1a_G {
@ LU.4.4: Within 14.976um from AA injector, space between Power Anode and NW Cathode, between PW Anode and Power cathode, and between PW Anode and NW Cathode when 0V < Delta V <= 1V. >= 0.96um
@ Check between Power Anode and NW Cathode
 err1_a = EXT Ptype_power_anode_vol_pos_lc NW_cathode_within_io_pad_140_lc < LU_4_4_1_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b = EXT Ptype_power_pad_within_io_pad_140_lc NW_cathode_within_io_pad_140_neg_lc < LU_4_4_1_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_L = EXT [Ptype_power_anode_vol_pos_lc] NW_cathode_within_io_pad_140_lc < LU_4_4_1_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b_L = EXT [Ptype_power_pad_within_io_pad_140_lc] NW_cathode_within_io_pad_140_neg_lc < LU_4_4_1_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_R = EXT Ptype_power_anode_vol_pos_lc [NW_cathode_within_io_pad_140_lc] < LU_4_4_1_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b_R = EXT Ptype_power_pad_within_io_pad_140_lc [NW_cathode_within_io_pad_140_neg_lc] < LU_4_4_1_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_L_gC = AA_c COIN EDGE err1_a_L
 err1_b_L_gC = AA_c COIN EDGE err1_b_L
 err1_a_R_gC = NW COIN EDGE err1_a_R
 err1_b_R_gC = NW COIN EDGE err1_b_R

 err1_a_L_NETID = DFM PROPERTY err1_a_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_a_R_NETID = DFM PROPERTY err1_a_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1_b_L_NETID = DFM PROPERTY err1_b_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_b_R_NETID = DFM PROPERTY err1_b_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1 = DFM PROPERTY err1_a err1_a_L_NETID err1_a_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_a_L_NETID)]
 [NET_b = count(err1_a_R_NETID)]
 [VH_1a = property(err1_a_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_a_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_a_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_a_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 0 && property_ref(DT_vA) <= 1.000) || (property_ref(DT_vB) > 0 && property_ref(DT_vB) <= 1.000)) ? 1 : 0] > 0

 err2 = DFM PROPERTY err1_b err1_b_L_NETID err1_b_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_b_L_NETID)]
 [NET_b = count(err1_b_R_NETID)]
 [VH_1a = property(err1_b_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_b_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_b_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_b_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 0 && property_ref(DT_vA) <= 1.000) || (property_ref(DT_vB) > 0 && property_ref(DT_vB) <= 1.000)) ? 1 : 0] > 0

 DFM COPY err1 err2
}

LU_4_4_1b_G {
@ LU.4.4: Within 14.976um from AA injector, space between Power Anode and NW Cathode, between PW Anode and Power cathode, and between PW Anode and NW Cathode when 0V < Delta V <= 1V. >= 0.96um
@ Check between PW Anode and Power cathode
 err1_a = EXT PW_anode_vol_pos_CHK_lc Ntype_power_pad_within_io_pad_140_lc < LU_4_4_1_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b = EXT PW_anode_within_io_pad_140_lc Ntype_power_pad_within_io_pad_140_neg_lc < LU_4_4_1_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_L = EXT [PW_anode_vol_pos_CHK_lc] Ntype_power_pad_within_io_pad_140_lc < LU_4_4_1_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b_L = EXT [PW_anode_within_io_pad_140_lc] Ntype_power_pad_within_io_pad_140_neg_lc < LU_4_4_1_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_R = EXT PW_anode_vol_pos_CHK_lc [Ntype_power_pad_within_io_pad_140_lc] < LU_4_4_1_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b_R = EXT PW_anode_within_io_pad_140_lc [Ntype_power_pad_within_io_pad_140_neg_lc] < LU_4_4_1_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_L_gC = RW COIN EDGE err1_a_L
 err1_b_L_gC = RW COIN EDGE err1_b_L
 err1_a_R_gC = AA_c COIN EDGE err1_a_R
 err1_b_R_gC = AA_c COIN EDGE err1_b_R

 err1_a_L_NETID = DFM PROPERTY err1_a_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_a_R_NETID = DFM PROPERTY err1_a_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1_b_L_NETID = DFM PROPERTY err1_b_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_b_R_NETID = DFM PROPERTY err1_b_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1 = DFM PROPERTY err1_a err1_a_L_NETID err1_a_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_a_L_NETID)]
 [NET_b = count(err1_a_R_NETID)]
 [VH_1a = property(err1_a_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_a_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_a_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_a_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 0 && property_ref(DT_vA) <= 1.000) || (property_ref(DT_vB) > 0 && property_ref(DT_vB) <= 1.000)) ? 1 : 0] > 0

 err2 = DFM PROPERTY err1_b err1_b_L_NETID err1_b_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_b_L_NETID)]
 [NET_b = count(err1_b_R_NETID)]
 [VH_1a = property(err1_b_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_b_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_b_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_b_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 0 && property_ref(DT_vA) <= 1.000) || (property_ref(DT_vB) > 0 && property_ref(DT_vB) <= 1.000)) ? 1 : 0] > 0

 DFM COPY err1 err2
}

LU_4_4_1c_G {
@ LU.4.4: Within 14.976um from AA injector, space between Power Anode and NW Cathode, between PW Anode and Power cathode, and between PW Anode and NW Cathode when 0V < Delta V <= 1V. >= 0.96um
@ Check between PW Anode and NW cathode
 err1_a = EXT PW_anode_vol_pos_CHK_lc NW_cathode_within_io_pad_140_lc < LU_4_4_1_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b = EXT PW_anode_within_io_pad_140_lc NW_cathode_within_io_pad_140_neg_lc < LU_4_4_1_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_L = EXT [PW_anode_vol_pos_CHK_lc] NW_cathode_within_io_pad_140_lc < LU_4_4_1_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b_L = EXT [PW_anode_within_io_pad_140_lc] NW_cathode_within_io_pad_140_neg_lc < LU_4_4_1_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_R = EXT PW_anode_vol_pos_CHK_lc [NW_cathode_within_io_pad_140_lc] < LU_4_4_1_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b_R = EXT PW_anode_within_io_pad_140_lc [NW_cathode_within_io_pad_140_neg_lc] < LU_4_4_1_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_L_gC = RW COIN EDGE err1_a_L
 err1_b_L_gC = RW COIN EDGE err1_b_L
 err1_a_R_gC = NW COIN EDGE err1_a_R
 err1_b_R_gC = NW COIN EDGE err1_b_R

 err1_a_L_NETID = DFM PROPERTY err1_a_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_a_R_NETID = DFM PROPERTY err1_a_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1_b_L_NETID = DFM PROPERTY err1_b_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_b_R_NETID = DFM PROPERTY err1_b_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1 = DFM PROPERTY err1_a err1_a_L_NETID err1_a_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_a_L_NETID)]
 [NET_b = count(err1_a_R_NETID)]
 [VH_1a = property(err1_a_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_a_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_a_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_a_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 0 && property_ref(DT_vA) <= 1.000) || (property_ref(DT_vB) > 0 && property_ref(DT_vB) <= 1.000)) ? 1 : 0] > 0

 err2 = DFM PROPERTY err1_b err1_b_L_NETID err1_b_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_b_L_NETID)]
 [NET_b = count(err1_b_R_NETID)]
 [VH_1a = property(err1_b_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_b_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_b_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_b_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 0 && property_ref(DT_vA) <= 1.000) || (property_ref(DT_vB) > 0 && property_ref(DT_vB) <= 1.000)) ? 1 : 0] > 0

 DFM COPY err1 err2
}

LU_4_4_2a_G {
@ LU.4.4: Within 14.976um from AA injector, space between Power Anode and NW Cathode, between PW Anode and Power cathode, and between PW Anode and NW Cathode when 1V < Delta V <= 1.32V. >= 1.824um
@ Check between IO Power Anode and IO NW Cathode
 err1_a = EXT Ptype_power_anode_vol_gt_pos_100_lc NW_cathode_within_io_pad_140_lc < LU_4_4_2_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b = EXT Ptype_power_pad_within_io_pad_140_lc NW_cathode_within_io_pad_140_neg_lc < LU_4_4_2_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_L = EXT [Ptype_power_anode_vol_gt_pos_100_lc] NW_cathode_within_io_pad_140_lc < LU_4_4_2_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b_L = EXT [Ptype_power_pad_within_io_pad_140_lc] NW_cathode_within_io_pad_140_neg_lc < LU_4_4_2_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_R = EXT Ptype_power_anode_vol_gt_pos_100_lc [NW_cathode_within_io_pad_140_lc] < LU_4_4_2_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b_R = EXT Ptype_power_pad_within_io_pad_140_lc [NW_cathode_within_io_pad_140_neg_lc] < LU_4_4_2_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_L_gC = AA_c COIN EDGE err1_a_L
 err1_b_L_gC = AA_c COIN EDGE err1_b_L
 err1_a_R_gC = NW COIN EDGE err1_a_R
 err1_b_R_gC = NW COIN EDGE err1_b_R

 err1_a_L_NETID = DFM PROPERTY err1_a_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_a_R_NETID = DFM PROPERTY err1_a_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1_b_L_NETID = DFM PROPERTY err1_b_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_b_R_NETID = DFM PROPERTY err1_b_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1 = DFM PROPERTY err1_a err1_a_L_NETID err1_a_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_a_L_NETID)]
 [NET_b = count(err1_a_R_NETID)]
 [VH_1a = property(err1_a_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_a_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_a_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_a_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 1.000 && property_ref(DT_vA) <= 1.32) || (property_ref(DT_vB) > 1.000 && property_ref(DT_vB) <= 1.32)) ? 1 : 0] > 0

 err2 = DFM PROPERTY err1_b err1_b_L_NETID err1_b_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_b_L_NETID)]
 [NET_b = count(err1_b_R_NETID)]
 [VH_1a = property(err1_b_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_b_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_b_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_b_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 1.000 && property_ref(DT_vA) <= 1.32) || (property_ref(DT_vB) > 1.000 && property_ref(DT_vB) <= 1.32)) ? 1 : 0] > 0

 DFM COPY err1 err2
}

LU_4_4_2b_G {
@ LU.4.4: Within 14.976um from AA injector, space between Power Anode and NW Cathode, between PW Anode and Power cathode, and between PW Anode and NW Cathode when 1V < Delta V <= 1.32V. >= 1.824um
@ Check between PW Anode and Power cathode
 err1_a = EXT PW_anode_vol_gt_pos_100_CHK_lc Ntype_power_pad_within_io_pad_140_lc < LU_4_4_2_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b = EXT PW_anode_within_io_pad_140_lc Ntype_power_pad_within_io_pad_140_neg_lc < LU_4_4_2_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_L = EXT [PW_anode_vol_gt_pos_100_CHK_lc] Ntype_power_pad_within_io_pad_140_lc < LU_4_4_2_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b_L = EXT [PW_anode_within_io_pad_140_lc] Ntype_power_pad_within_io_pad_140_neg_lc < LU_4_4_2_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_R = EXT PW_anode_vol_gt_pos_100_CHK_lc [Ntype_power_pad_within_io_pad_140_lc] < LU_4_4_2_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b_R = EXT PW_anode_within_io_pad_140_lc [Ntype_power_pad_within_io_pad_140_neg_lc] < LU_4_4_2_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_L_gC = RW COIN EDGE err1_a_L
 err1_b_L_gC = RW COIN EDGE err1_b_L
 err1_a_R_gC = AA_c COIN EDGE err1_a_R
 err1_b_R_gC = AA_c COIN EDGE err1_b_R

 err1_a_L_NETID = DFM PROPERTY err1_a_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_a_R_NETID = DFM PROPERTY err1_a_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1_b_L_NETID = DFM PROPERTY err1_b_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_b_R_NETID = DFM PROPERTY err1_b_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1 = DFM PROPERTY err1_a err1_a_L_NETID err1_a_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_a_L_NETID)]
 [NET_b = count(err1_a_R_NETID)]
 [VH_1a = property(err1_a_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_a_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_a_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_a_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 1.000 && property_ref(DT_vA) <= 1.32) || (property_ref(DT_vB) > 1.000 && property_ref(DT_vB) <= 1.32)) ? 1 : 0] > 0

 err2 = DFM PROPERTY err1_b err1_b_L_NETID err1_b_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_b_L_NETID)]
 [NET_b = count(err1_b_R_NETID)]
 [VH_1a = property(err1_b_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_b_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_b_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_b_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 1.000 && property_ref(DT_vA) <= 1.32) || (property_ref(DT_vB) > 1.000 && property_ref(DT_vB) <= 1.32)) ? 1 : 0] > 0

 DFM COPY err1 err2
}

LU_4_4_2c_G {
@ LU.4.4: Within 14.976um from AA injector, space between Power Anode and NW Cathode, between PW Anode and Power cathode, and between PW Anode and NW Cathode when 1V < Delta V <= 1.32V. >= 1.824um
@ Check between PW Anode and NW cathode
 err1_a = EXT PW_anode_vol_gt_pos_100_CHK_lc NW_cathode_within_io_pad_140_lc < LU_4_4_2_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b = EXT PW_anode_within_io_pad_140_lc NW_cathode_within_io_pad_140_neg_lc < LU_4_4_2_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_L = EXT [PW_anode_vol_gt_pos_100_CHK_lc] NW_cathode_within_io_pad_140_lc < LU_4_4_2_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b_L = EXT [PW_anode_within_io_pad_140_lc] NW_cathode_within_io_pad_140_neg_lc < LU_4_4_2_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_R = EXT PW_anode_vol_gt_pos_100_CHK_lc [NW_cathode_within_io_pad_140_lc] < LU_4_4_2_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b_R = EXT PW_anode_within_io_pad_140_lc [NW_cathode_within_io_pad_140_neg_lc] < LU_4_4_2_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_L_gC = RW COIN EDGE err1_a_L
 err1_b_L_gC = RW COIN EDGE err1_b_L
 err1_a_R_gC = NW COIN EDGE err1_a_R
 err1_b_R_gC = NW COIN EDGE err1_b_R

 err1_a_L_NETID = DFM PROPERTY err1_a_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_a_R_NETID = DFM PROPERTY err1_a_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1_b_L_NETID = DFM PROPERTY err1_b_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_b_R_NETID = DFM PROPERTY err1_b_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1 = DFM PROPERTY err1_a err1_a_L_NETID err1_a_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_a_L_NETID)]
 [NET_b = count(err1_a_R_NETID)]
 [VH_1a = property(err1_a_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_a_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_a_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_a_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 1.000 && property_ref(DT_vA) <= 1.32) || (property_ref(DT_vB) > 1.000 && property_ref(DT_vB) <= 1.32)) ? 1 : 0] > 0

 err2 = DFM PROPERTY err1_b err1_b_L_NETID err1_b_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_b_L_NETID)]
 [NET_b = count(err1_b_R_NETID)]
 [VH_1a = property(err1_b_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_b_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_b_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_b_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 1.000 && property_ref(DT_vA) <= 1.32) || (property_ref(DT_vB) > 1.000 && property_ref(DT_vB) <= 1.32)) ? 1 : 0] > 0

 DFM COPY err1 err2
}

LU_4_4_3a_G {
@ LU.4.4: Within 14.976um from AA injector, space between Power Anode and NW Cathode, between PW Anode and Power cathode, and between PW Anode and NW Cathode when 1.32V < Delta V <= 1.65V. >= 2.112um
@ Check between IO Power Anode and IO NW Cathode
 err1_a = EXT Ptype_power_anode_vol_gt_pos_132_lc NW_cathode_within_io_pad_140_lc < LU_4_4_3_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b = EXT Ptype_power_pad_within_io_pad_140_lc NW_cathode_within_io_pad_140_neg_lc < LU_4_4_3_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_L = EXT [Ptype_power_anode_vol_gt_pos_132_lc] NW_cathode_within_io_pad_140_lc < LU_4_4_3_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b_L = EXT [Ptype_power_pad_within_io_pad_140_lc] NW_cathode_within_io_pad_140_neg_lc < LU_4_4_3_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_R = EXT Ptype_power_anode_vol_gt_pos_132_lc [NW_cathode_within_io_pad_140_lc] < LU_4_4_3_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b_R = EXT Ptype_power_pad_within_io_pad_140_lc [NW_cathode_within_io_pad_140_neg_lc] < LU_4_4_3_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_L_gC = AA_c COIN EDGE err1_a_L
 err1_b_L_gC = AA_c COIN EDGE err1_b_L
 err1_a_R_gC = NW COIN EDGE err1_a_R
 err1_b_R_gC = NW COIN EDGE err1_b_R

 err1_a_L_NETID = DFM PROPERTY err1_a_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_a_R_NETID = DFM PROPERTY err1_a_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1_b_L_NETID = DFM PROPERTY err1_b_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_b_R_NETID = DFM PROPERTY err1_b_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1 = DFM PROPERTY err1_a err1_a_L_NETID err1_a_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_a_L_NETID)]
 [NET_b = count(err1_a_R_NETID)]
 [VH_1a = property(err1_a_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_a_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_a_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_a_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 1.32 && property_ref(DT_vA) <= 1.65) || (property_ref(DT_vB) > 1.32 && property_ref(DT_vB) <= 1.65)) ? 1 : 0] > 0

 err2 = DFM PROPERTY err1_b err1_b_L_NETID err1_b_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_b_L_NETID)]
 [NET_b = count(err1_b_R_NETID)]
 [VH_1a = property(err1_b_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_b_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_b_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_b_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 1.32 && property_ref(DT_vA) <= 1.65) || (property_ref(DT_vB) > 1.32 && property_ref(DT_vB) <= 1.65)) ? 1 : 0] > 0

 DFM COPY err1 err2
}

LU_4_4_3b_G {
@ LU.4.4: Within 14.976um from AA injector, space between Power Anode and NW Cathode, between PW Anode and Power cathode, and between PW Anode and NW Cathode when 1.32V < Delta V <= 1.65V. >= 2.112um
@ Check between PW Anode and Power cathode
 err1_a = EXT PW_anode_vol_gt_pos_132_CHK_lc Ntype_power_pad_within_io_pad_140_lc < LU_4_4_3_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b = EXT PW_anode_within_io_pad_140_lc Ntype_power_pad_within_io_pad_140_neg_lc < LU_4_4_3_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_L = EXT [PW_anode_vol_gt_pos_132_CHK_lc] Ntype_power_pad_within_io_pad_140_lc < LU_4_4_3_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b_L = EXT [PW_anode_within_io_pad_140_lc] Ntype_power_pad_within_io_pad_140_neg_lc < LU_4_4_3_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_R = EXT PW_anode_vol_gt_pos_132_CHK_lc [Ntype_power_pad_within_io_pad_140_lc] < LU_4_4_3_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b_R = EXT PW_anode_within_io_pad_140_lc [Ntype_power_pad_within_io_pad_140_neg_lc] < LU_4_4_3_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_L_gC = RW COIN EDGE err1_a_L
 err1_b_L_gC = RW COIN EDGE err1_b_L
 err1_a_R_gC = AA_c COIN EDGE err1_a_R
 err1_b_R_gC = AA_c COIN EDGE err1_b_R

 err1_a_L_NETID = DFM PROPERTY err1_a_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_a_R_NETID = DFM PROPERTY err1_a_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1_b_L_NETID = DFM PROPERTY err1_b_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_b_R_NETID = DFM PROPERTY err1_b_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1 = DFM PROPERTY err1_a err1_a_L_NETID err1_a_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_a_L_NETID)]
 [NET_b = count(err1_a_R_NETID)]
 [VH_1a = property(err1_a_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_a_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_a_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_a_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 1.32 && property_ref(DT_vA) <= 1.65) || (property_ref(DT_vB) > 1.32 && property_ref(DT_vB) <= 1.65)) ? 1 : 0] > 0

 err2 = DFM PROPERTY err1_b err1_b_L_NETID err1_b_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_b_L_NETID)]
 [NET_b = count(err1_b_R_NETID)]
 [VH_1a = property(err1_b_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_b_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_b_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_b_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 1.32 && property_ref(DT_vA) <= 1.65) || (property_ref(DT_vB) > 1.32 && property_ref(DT_vB) <= 1.65)) ? 1 : 0] > 0

 DFM COPY err1 err2
}

LU_4_4_3c_G {
@ LU.4.4: Within 14.976um from AA injector, space between Power Anode and NW Cathode, between PW Anode and Power cathode, and between PW Anode and NW Cathode when 1.32V < Delta V <= 1.65V. >= 2.112um
@ Check between PW Anode and NW cathode
 err1_a = EXT PW_anode_vol_gt_pos_132_CHK_lc NW_cathode_within_io_pad_140_lc < LU_4_4_3_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b = EXT PW_anode_within_io_pad_140_lc NW_cathode_within_io_pad_140_neg_lc < LU_4_4_3_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_L = EXT [PW_anode_vol_gt_pos_132_CHK_lc] NW_cathode_within_io_pad_140_lc < LU_4_4_3_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b_L = EXT [PW_anode_within_io_pad_140_lc] NW_cathode_within_io_pad_140_neg_lc < LU_4_4_3_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_R = EXT PW_anode_vol_gt_pos_132_CHK_lc [NW_cathode_within_io_pad_140_lc] < LU_4_4_3_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b_R = EXT PW_anode_within_io_pad_140_lc [NW_cathode_within_io_pad_140_neg_lc] < LU_4_4_3_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_L_gC = RW COIN EDGE err1_a_L
 err1_b_L_gC = RW COIN EDGE err1_b_L
 err1_a_R_gC = NW COIN EDGE err1_a_R
 err1_b_R_gC = NW COIN EDGE err1_b_R

 err1_a_L_NETID = DFM PROPERTY err1_a_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_a_R_NETID = DFM PROPERTY err1_a_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1_b_L_NETID = DFM PROPERTY err1_b_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_b_R_NETID = DFM PROPERTY err1_b_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1 = DFM PROPERTY err1_a err1_a_L_NETID err1_a_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_a_L_NETID)]
 [NET_b = count(err1_a_R_NETID)]
 [VH_1a = property(err1_a_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_a_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_a_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_a_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 1.32 && property_ref(DT_vA) <= 1.65) || (property_ref(DT_vB) > 1.32 && property_ref(DT_vB) <= 1.65)) ? 1 : 0] > 0

 err2 = DFM PROPERTY err1_b err1_b_L_NETID err1_b_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_b_L_NETID)]
 [NET_b = count(err1_b_R_NETID)]
 [VH_1a = property(err1_b_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_b_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_b_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_b_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 1.32 && property_ref(DT_vA) <= 1.65) || (property_ref(DT_vB) > 1.32 && property_ref(DT_vB) <= 1.65)) ? 1 : 0] > 0

 DFM COPY err1 err2
}

LU_4_4_4a_G {
@ LU.4.4: Within 14.976um from AA injector, space between Power Anode and NW Cathode, between PW Anode and Power cathode, and between PW Anode and NW Cathode when 1.65V < Delta V <= 1.98V. >= 4.512um
@ Check between IO Power Anode and IO NW Cathode
 err1_a = EXT Ptype_power_anode_vol_gt_pos_165_lc NW_cathode_within_io_pad_140_lc < LU_4_4_4_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b = EXT Ptype_power_pad_within_io_pad_140_lc NW_cathode_within_io_pad_140_neg_lc < LU_4_4_4_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_L = EXT [Ptype_power_anode_vol_gt_pos_165_lc] NW_cathode_within_io_pad_140_lc < LU_4_4_4_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b_L = EXT [Ptype_power_pad_within_io_pad_140_lc] NW_cathode_within_io_pad_140_neg_lc < LU_4_4_4_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_R = EXT Ptype_power_anode_vol_gt_pos_165_lc [NW_cathode_within_io_pad_140_lc] < LU_4_4_4_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b_R = EXT Ptype_power_pad_within_io_pad_140_lc [NW_cathode_within_io_pad_140_neg_lc] < LU_4_4_4_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_L_gC = AA_c COIN EDGE err1_a_L
 err1_b_L_gC = AA_c COIN EDGE err1_b_L
 err1_a_R_gC = NW COIN EDGE err1_a_R
 err1_b_R_gC = NW COIN EDGE err1_b_R

 err1_a_L_NETID = DFM PROPERTY err1_a_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_a_R_NETID = DFM PROPERTY err1_a_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1_b_L_NETID = DFM PROPERTY err1_b_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_b_R_NETID = DFM PROPERTY err1_b_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1 = DFM PROPERTY err1_a err1_a_L_NETID err1_a_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_a_L_NETID)]
 [NET_b = count(err1_a_R_NETID)]
 [VH_1a = property(err1_a_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_a_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_a_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_a_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 1.65 && property_ref(DT_vA) <= 1.98) || (property_ref(DT_vB) > 1.65 && property_ref(DT_vB) <= 1.98)) ? 1 : 0] > 0

 err2 = DFM PROPERTY err1_b err1_b_L_NETID err1_b_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_b_L_NETID)]
 [NET_b = count(err1_b_R_NETID)]
 [VH_1a = property(err1_b_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_b_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_b_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_b_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 1.65 && property_ref(DT_vA) <= 1.98) || (property_ref(DT_vB) > 1.65 && property_ref(DT_vB) <= 1.98)) ? 1 : 0] > 0

 DFM COPY err1 err2
}

LU_4_4_4b_G {
@ LU.4.4: Within 14.976um from AA injector, space between Power Anode and NW Cathode, between PW Anode and Power cathode, and between PW Anode and NW Cathode when 1.65V < Delta V <= 1.98V. >= 4.512um
@ Check between PW Anode and Power cathode
 err1_a = EXT PW_anode_vol_gt_pos_165_CHK_lc Ntype_power_pad_within_io_pad_140_lc < LU_4_4_4_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b = EXT PW_anode_within_io_pad_140_lc Ntype_power_pad_within_io_pad_140_neg_lc < LU_4_4_4_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_L = EXT [PW_anode_vol_gt_pos_165_CHK_lc] Ntype_power_pad_within_io_pad_140_lc < LU_4_4_4_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b_L = EXT [PW_anode_within_io_pad_140_lc] Ntype_power_pad_within_io_pad_140_neg_lc < LU_4_4_4_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_R = EXT PW_anode_vol_gt_pos_165_CHK_lc [Ntype_power_pad_within_io_pad_140_lc] < LU_4_4_4_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b_R = EXT PW_anode_within_io_pad_140_lc [Ntype_power_pad_within_io_pad_140_neg_lc] < LU_4_4_4_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_L_gC = RW COIN EDGE err1_a_L
 err1_b_L_gC = RW COIN EDGE err1_b_L
 err1_a_R_gC = AA_c COIN EDGE err1_a_R
 err1_b_R_gC = AA_c COIN EDGE err1_b_R

 err1_a_L_NETID = DFM PROPERTY err1_a_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_a_R_NETID = DFM PROPERTY err1_a_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1_b_L_NETID = DFM PROPERTY err1_b_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_b_R_NETID = DFM PROPERTY err1_b_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1 = DFM PROPERTY err1_a err1_a_L_NETID err1_a_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_a_L_NETID)]
 [NET_b = count(err1_a_R_NETID)]
 [VH_1a = property(err1_a_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_a_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_a_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_a_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 1.65 && property_ref(DT_vA) <= 1.98) || (property_ref(DT_vB) > 1.65 && property_ref(DT_vB) <= 1.98)) ? 1 : 0] > 0

 err2 = DFM PROPERTY err1_b err1_b_L_NETID err1_b_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_b_L_NETID)]
 [NET_b = count(err1_b_R_NETID)]
 [VH_1a = property(err1_b_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_b_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_b_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_b_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 1.65 && property_ref(DT_vA) <= 1.98) || (property_ref(DT_vB) > 1.65 && property_ref(DT_vB) <= 1.98)) ? 1 : 0] > 0

 DFM COPY err1 err2
}

LU_4_4_4c_G {
@ LU.4.4: Within 14.976um from AA injector, space between Power Anode and NW Cathode, between PW Anode and Power cathode, and between PW Anode and NW Cathode when 1.65V < Delta V <= 1.98V. >= 4.512um
@ Check between PW Anode and NW cathode
 err1_a = EXT PW_anode_vol_gt_pos_165_CHK_lc NW_cathode_within_io_pad_140_lc < LU_4_4_4_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b = EXT PW_anode_within_io_pad_140_lc NW_cathode_within_io_pad_140_neg_lc < LU_4_4_4_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_L = EXT [PW_anode_vol_gt_pos_165_CHK_lc] NW_cathode_within_io_pad_140_lc < LU_4_4_4_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b_L = EXT [PW_anode_within_io_pad_140_lc] NW_cathode_within_io_pad_140_neg_lc < LU_4_4_4_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_R = EXT PW_anode_vol_gt_pos_165_CHK_lc [NW_cathode_within_io_pad_140_lc] < LU_4_4_4_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b_R = EXT PW_anode_within_io_pad_140_lc [NW_cathode_within_io_pad_140_neg_lc] < LU_4_4_4_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_L_gC = RW COIN EDGE err1_a_L
 err1_b_L_gC = RW COIN EDGE err1_b_L
 err1_a_R_gC = NW COIN EDGE err1_a_R
 err1_b_R_gC = NW COIN EDGE err1_b_R

 err1_a_L_NETID = DFM PROPERTY err1_a_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_a_R_NETID = DFM PROPERTY err1_a_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1_b_L_NETID = DFM PROPERTY err1_b_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_b_R_NETID = DFM PROPERTY err1_b_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1 = DFM PROPERTY err1_a err1_a_L_NETID err1_a_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_a_L_NETID)]
 [NET_b = count(err1_a_R_NETID)]
 [VH_1a = property(err1_a_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_a_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_a_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_a_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 1.65 && property_ref(DT_vA) <= 1.98) || (property_ref(DT_vB) > 1.65 && property_ref(DT_vB) <= 1.98)) ? 1 : 0] > 0

 err2 = DFM PROPERTY err1_b err1_b_L_NETID err1_b_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_b_L_NETID)]
 [NET_b = count(err1_b_R_NETID)]
 [VH_1a = property(err1_b_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_b_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_b_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_b_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 1.65 && property_ref(DT_vA) <= 1.98) || (property_ref(DT_vB) > 1.65 && property_ref(DT_vB) <= 1.98)) ? 1 : 0] > 0

 DFM COPY err1 err2
}

LU_4_4_5a_G {
@ LU.4.4: Within 14.976um from AA injector, space between Power Anode and NW Cathode, between PW Anode and Power cathode, and between PW Anode and NW Cathode when 1.98V < Delta V <= 2.75V. >= 7.968um
@ Check between IO Power Anode and IO NW Cathode
 err1_a = EXT Ptype_power_anode_vol_gt_pos_198_lc NW_cathode_within_io_pad_140_lc < LU_4_4_5_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b = EXT Ptype_power_pad_within_io_pad_140_lc NW_cathode_within_io_pad_140_neg_lc < LU_4_4_5_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_L = EXT [Ptype_power_anode_vol_gt_pos_198_lc] NW_cathode_within_io_pad_140_lc < LU_4_4_5_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b_L = EXT [Ptype_power_pad_within_io_pad_140_lc] NW_cathode_within_io_pad_140_neg_lc < LU_4_4_5_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_R = EXT Ptype_power_anode_vol_gt_pos_198_lc [NW_cathode_within_io_pad_140_lc] < LU_4_4_5_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b_R = EXT Ptype_power_pad_within_io_pad_140_lc [NW_cathode_within_io_pad_140_neg_lc] < LU_4_4_5_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_L_gC = AA_c COIN EDGE err1_a_L
 err1_b_L_gC = AA_c COIN EDGE err1_b_L
 err1_a_R_gC = NW COIN EDGE err1_a_R
 err1_b_R_gC = NW COIN EDGE err1_b_R

 err1_a_L_NETID = DFM PROPERTY err1_a_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_a_R_NETID = DFM PROPERTY err1_a_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1_b_L_NETID = DFM PROPERTY err1_b_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_b_R_NETID = DFM PROPERTY err1_b_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1 = DFM PROPERTY err1_a err1_a_L_NETID err1_a_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_a_L_NETID)]
 [NET_b = count(err1_a_R_NETID)]
 [VH_1a = property(err1_a_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_a_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_a_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_a_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 1.98 && property_ref(DT_vA) <= 2.75) || (property_ref(DT_vB) > 1.98 && property_ref(DT_vB) <= 2.75)) ? 1 : 0] > 0

 err2 = DFM PROPERTY err1_b err1_b_L_NETID err1_b_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_b_L_NETID)]
 [NET_b = count(err1_b_R_NETID)]
 [VH_1a = property(err1_b_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_b_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_b_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_b_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 1.98 && property_ref(DT_vA) <= 2.75) || (property_ref(DT_vB) > 1.98 && property_ref(DT_vB) <= 2.75)) ? 1 : 0] > 0

 DFM COPY err1 err2
}

LU_4_4_5b_G {
@ LU.4.4: Within 14.976um from AA injector, space between Power Anode and NW Cathode, between PW Anode and Power cathode, and between PW Anode and NW Cathode when 1.98V < Delta V <= 2.75V. >= 7.968um
@ Check between PW Anode and Power cathode
 err1_a = EXT PW_anode_vol_gt_pos_198_CHK_lc Ntype_power_pad_within_io_pad_140_lc < LU_4_4_5_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b = EXT PW_anode_within_io_pad_140_lc Ntype_power_pad_within_io_pad_140_neg_lc < LU_4_4_5_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_L = EXT [PW_anode_vol_gt_pos_198_CHK_lc] Ntype_power_pad_within_io_pad_140_lc < LU_4_4_5_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b_L = EXT [PW_anode_within_io_pad_140_lc] Ntype_power_pad_within_io_pad_140_neg_lc < LU_4_4_5_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_R = EXT PW_anode_vol_gt_pos_198_CHK_lc [Ntype_power_pad_within_io_pad_140_lc] < LU_4_4_5_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b_R = EXT PW_anode_within_io_pad_140_lc [Ntype_power_pad_within_io_pad_140_neg_lc] < LU_4_4_5_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_L_gC = RW COIN EDGE err1_a_L
 err1_b_L_gC = RW COIN EDGE err1_b_L
 err1_a_R_gC = AA_c COIN EDGE err1_a_R
 err1_b_R_gC = AA_c COIN EDGE err1_b_R

 err1_a_L_NETID = DFM PROPERTY err1_a_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_a_R_NETID = DFM PROPERTY err1_a_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1_b_L_NETID = DFM PROPERTY err1_b_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_b_R_NETID = DFM PROPERTY err1_b_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1 = DFM PROPERTY err1_a err1_a_L_NETID err1_a_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_a_L_NETID)]
 [NET_b = count(err1_a_R_NETID)]
 [VH_1a = property(err1_a_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_a_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_a_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_a_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 1.98 && property_ref(DT_vA) <= 2.75) || (property_ref(DT_vB) > 1.98 && property_ref(DT_vB) <= 2.75)) ? 1 : 0] > 0

 err2 = DFM PROPERTY err1_b err1_b_L_NETID err1_b_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_b_L_NETID)]
 [NET_b = count(err1_b_R_NETID)]
 [VH_1a = property(err1_b_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_b_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_b_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_b_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 1.98 && property_ref(DT_vA) <= 2.75) || (property_ref(DT_vB) > 1.98 && property_ref(DT_vB) <= 2.75)) ? 1 : 0] > 0

 DFM COPY err1 err2
}

LU_4_4_5c_G {
@ LU.4.4: Within 14.976um from AA injector, space between Power Anode and NW Cathode, between PW Anode and Power cathode, and between PW Anode and NW Cathode when 1.98V < Delta V <= 2.75V. >= 7.968um
@ Check between PW Anode and NW cathode
 err1_a = EXT PW_anode_vol_gt_pos_198_CHK_lc NW_cathode_within_io_pad_140_lc < LU_4_4_5_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b = EXT PW_anode_within_io_pad_140_lc NW_cathode_within_io_pad_140_neg_lc < LU_4_4_5_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_L = EXT [PW_anode_vol_gt_pos_198_CHK_lc] NW_cathode_within_io_pad_140_lc < LU_4_4_5_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b_L = EXT [PW_anode_within_io_pad_140_lc] NW_cathode_within_io_pad_140_neg_lc < LU_4_4_5_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_R = EXT PW_anode_vol_gt_pos_198_CHK_lc [NW_cathode_within_io_pad_140_lc] < LU_4_4_5_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b_R = EXT PW_anode_within_io_pad_140_lc [NW_cathode_within_io_pad_140_neg_lc] < LU_4_4_5_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_L_gC = RW COIN EDGE err1_a_L
 err1_b_L_gC = RW COIN EDGE err1_b_L
 err1_a_R_gC = NW COIN EDGE err1_a_R
 err1_b_R_gC = NW COIN EDGE err1_b_R

 err1_a_L_NETID = DFM PROPERTY err1_a_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_a_R_NETID = DFM PROPERTY err1_a_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1_b_L_NETID = DFM PROPERTY err1_b_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_b_R_NETID = DFM PROPERTY err1_b_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1 = DFM PROPERTY err1_a err1_a_L_NETID err1_a_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_a_L_NETID)]
 [NET_b = count(err1_a_R_NETID)]
 [VH_1a = property(err1_a_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_a_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_a_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_a_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 1.98 && property_ref(DT_vA) <= 2.75) || (property_ref(DT_vB) > 1.98 && property_ref(DT_vB) <= 2.75)) ? 1 : 0] > 0

 err2 = DFM PROPERTY err1_b err1_b_L_NETID err1_b_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_b_L_NETID)]
 [NET_b = count(err1_b_R_NETID)]
 [VH_1a = property(err1_b_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_b_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_b_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_b_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 1.98 && property_ref(DT_vA) <= 2.75) || (property_ref(DT_vB) > 1.98 && property_ref(DT_vB) <= 2.75)) ? 1 : 0] > 0

 DFM COPY err1 err2
}

LU_4_4_6a_G {
@ LU.4.4: Within 14.976um from AA injector, space between Power Anode and NW Cathode, between PW Anode and Power cathode, and between PW Anode and NW Cathode when 2.75V < Delta V <= 3.63V. >= 16.032um
@ Check between IO Power Anode and IO NW Cathode
 err1_a = EXT Ptype_power_anode_vol_gt_pos_275_lc NW_cathode_within_io_pad_140_lc < LU_4_4_6_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b = EXT Ptype_power_pad_within_io_pad_140_lc NW_cathode_within_io_pad_140_neg_lc < LU_4_4_6_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_L = EXT [Ptype_power_anode_vol_gt_pos_275_lc] NW_cathode_within_io_pad_140_lc < LU_4_4_6_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b_L = EXT [Ptype_power_pad_within_io_pad_140_lc] NW_cathode_within_io_pad_140_neg_lc < LU_4_4_6_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_R = EXT Ptype_power_anode_vol_gt_pos_275_lc [NW_cathode_within_io_pad_140_lc] < LU_4_4_6_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b_R = EXT Ptype_power_pad_within_io_pad_140_lc [NW_cathode_within_io_pad_140_neg_lc] < LU_4_4_6_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_L_gC = AA_c COIN EDGE err1_a_L
 err1_b_L_gC = AA_c COIN EDGE err1_b_L
 err1_a_R_gC = NW COIN EDGE err1_a_R
 err1_b_R_gC = NW COIN EDGE err1_b_R

 err1_a_L_NETID = DFM PROPERTY err1_a_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_a_R_NETID = DFM PROPERTY err1_a_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1_b_L_NETID = DFM PROPERTY err1_b_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_b_R_NETID = DFM PROPERTY err1_b_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1 = DFM PROPERTY err1_a err1_a_L_NETID err1_a_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_a_L_NETID)]
 [NET_b = count(err1_a_R_NETID)]
 [VH_1a = property(err1_a_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_a_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_a_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_a_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 2.75 && property_ref(DT_vA) <= 3.63) || (property_ref(DT_vB) > 2.75 && property_ref(DT_vB) <= 3.63)) ? 1 : 0] > 0

 err2 = DFM PROPERTY err1_b err1_b_L_NETID err1_b_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_b_L_NETID)]
 [NET_b = count(err1_b_R_NETID)]
 [VH_1a = property(err1_b_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_b_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_b_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_b_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 2.75 && property_ref(DT_vA) <= 3.63) || (property_ref(DT_vB) > 2.75 && property_ref(DT_vB) <= 3.63)) ? 1 : 0] > 0

 DFM COPY err1 err2
}

LU_4_4_6b_G {
@ LU.4.4: Within 14.976um from AA injector, space between Power Anode and NW Cathode, between PW Anode and Power cathode, and between PW Anode and NW Cathode when 2.75V < Delta V <= 3.63V. >= 16.032um
@ Check between PW Anode and Power cathode
 err1_a = EXT PW_anode_vol_gt_pos_275_CHK_lc Ntype_power_pad_within_io_pad_140_lc < LU_4_4_6_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b = EXT PW_anode_within_io_pad_140_lc Ntype_power_pad_within_io_pad_140_neg_lc < LU_4_4_6_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_L = EXT [PW_anode_vol_gt_pos_275_CHK_lc] Ntype_power_pad_within_io_pad_140_lc < LU_4_4_6_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b_L = EXT [PW_anode_within_io_pad_140_lc] Ntype_power_pad_within_io_pad_140_neg_lc < LU_4_4_6_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_R = EXT PW_anode_vol_gt_pos_275_CHK_lc [Ntype_power_pad_within_io_pad_140_lc] < LU_4_4_6_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b_R = EXT PW_anode_within_io_pad_140_lc [Ntype_power_pad_within_io_pad_140_neg_lc] < LU_4_4_6_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_L_gC = RW COIN EDGE err1_a_L
 err1_b_L_gC = RW COIN EDGE err1_b_L
 err1_a_R_gC = AA_c COIN EDGE err1_a_R
 err1_b_R_gC = AA_c COIN EDGE err1_b_R

 err1_a_L_NETID = DFM PROPERTY err1_a_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_a_R_NETID = DFM PROPERTY err1_a_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1_b_L_NETID = DFM PROPERTY err1_b_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_b_R_NETID = DFM PROPERTY err1_b_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1 = DFM PROPERTY err1_a err1_a_L_NETID err1_a_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_a_L_NETID)]
 [NET_b = count(err1_a_R_NETID)]
 [VH_1a = property(err1_a_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_a_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_a_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_a_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 2.75 && property_ref(DT_vA) <= 3.63) || (property_ref(DT_vB) > 2.75 && property_ref(DT_vB) <= 3.63)) ? 1 : 0] > 0

 err2 = DFM PROPERTY err1_b err1_b_L_NETID err1_b_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_b_L_NETID)]
 [NET_b = count(err1_b_R_NETID)]
 [VH_1a = property(err1_b_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_b_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_b_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_b_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 2.75 && property_ref(DT_vA) <= 3.63) || (property_ref(DT_vB) > 2.75 && property_ref(DT_vB) <= 3.63)) ? 1 : 0] > 0

 DFM COPY err1 err2
}

LU_4_4_6c_G {
@ LU.4.4: Within 14.976um from AA injector, space between Power Anode and NW Cathode, between PW Anode and Power cathode, and between PW Anode and NW Cathode when 2.75V < Delta V <= 3.63V. >= 16.032um
@ Check between PW Anode and NW cathode
 err1_a = EXT PW_anode_vol_gt_pos_275_CHK_lc NW_cathode_within_io_pad_140_lc < LU_4_4_6_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b = EXT PW_anode_within_io_pad_140_lc NW_cathode_within_io_pad_140_neg_lc < LU_4_4_6_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_L = EXT [PW_anode_vol_gt_pos_275_CHK_lc] NW_cathode_within_io_pad_140_lc < LU_4_4_6_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b_L = EXT [PW_anode_within_io_pad_140_lc] NW_cathode_within_io_pad_140_neg_lc < LU_4_4_6_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_R = EXT PW_anode_vol_gt_pos_275_CHK_lc [NW_cathode_within_io_pad_140_lc] < LU_4_4_6_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b_R = EXT PW_anode_within_io_pad_140_lc [NW_cathode_within_io_pad_140_neg_lc] < LU_4_4_6_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_L_gC = RW COIN EDGE err1_a_L
 err1_b_L_gC = RW COIN EDGE err1_b_L
 err1_a_R_gC = NW COIN EDGE err1_a_R
 err1_b_R_gC = NW COIN EDGE err1_b_R

 err1_a_L_NETID = DFM PROPERTY err1_a_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_a_R_NETID = DFM PROPERTY err1_a_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1_b_L_NETID = DFM PROPERTY err1_b_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_b_R_NETID = DFM PROPERTY err1_b_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1 = DFM PROPERTY err1_a err1_a_L_NETID err1_a_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_a_L_NETID)]
 [NET_b = count(err1_a_R_NETID)]
 [VH_1a = property(err1_a_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_a_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_a_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_a_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 2.75 && property_ref(DT_vA) <= 3.63) || (property_ref(DT_vB) > 2.75 && property_ref(DT_vB) <= 3.63)) ? 1 : 0] > 0

 err2 = DFM PROPERTY err1_b err1_b_L_NETID err1_b_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_b_L_NETID)]
 [NET_b = count(err1_b_R_NETID)]
 [VH_1a = property(err1_b_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_b_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_b_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_b_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 2.75 && property_ref(DT_vA) <= 3.63) || (property_ref(DT_vB) > 2.75 && property_ref(DT_vB) <= 3.63)) ? 1 : 0] > 0

 DFM COPY err1 err2
}

LU_4_4_7a_G {
@ LU.4.4: Within 14.976um from AA injector, space between Power Anode and NW Cathode, between PW Anode and Power cathode, and between PW Anode and NW Cathode when 3.63V < Delta V <= 5.5V. >= 35.952um
@ Check between IO Power Anode and IO NW Cathode
 err1_a = EXT Ptype_power_anode_vol_gt_pos_363_lc NW_cathode_within_io_pad_140_lc < LU_4_4_7_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b = EXT Ptype_power_pad_within_io_pad_140_lc NW_cathode_within_io_pad_140_neg_lc < LU_4_4_7_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_L = EXT [Ptype_power_anode_vol_gt_pos_363_lc] NW_cathode_within_io_pad_140_lc < LU_4_4_7_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b_L = EXT [Ptype_power_pad_within_io_pad_140_lc] NW_cathode_within_io_pad_140_neg_lc < LU_4_4_7_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_R = EXT Ptype_power_anode_vol_gt_pos_363_lc [NW_cathode_within_io_pad_140_lc] < LU_4_4_7_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b_R = EXT Ptype_power_pad_within_io_pad_140_lc [NW_cathode_within_io_pad_140_neg_lc] < LU_4_4_7_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_L_gC = AA_c COIN EDGE err1_a_L
 err1_b_L_gC = AA_c COIN EDGE err1_b_L
 err1_a_R_gC = NW COIN EDGE err1_a_R
 err1_b_R_gC = NW COIN EDGE err1_b_R

 err1_a_L_NETID = DFM PROPERTY err1_a_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_a_R_NETID = DFM PROPERTY err1_a_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1_b_L_NETID = DFM PROPERTY err1_b_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_b_R_NETID = DFM PROPERTY err1_b_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1 = DFM PROPERTY err1_a err1_a_L_NETID err1_a_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_a_L_NETID)]
 [NET_b = count(err1_a_R_NETID)]
 [VH_1a = property(err1_a_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_a_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_a_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_a_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 3.63 && property_ref(DT_vA) <= 5.5) || (property_ref(DT_vB) > 3.63 && property_ref(DT_vB) <= 5.5)) ? 1 : 0] > 0

 err2 = DFM PROPERTY err1_b err1_b_L_NETID err1_b_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_b_L_NETID)]
 [NET_b = count(err1_b_R_NETID)]
 [VH_1a = property(err1_b_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_b_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_b_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_b_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 3.63 && property_ref(DT_vA) <= 5.5) || (property_ref(DT_vB) > 3.63 && property_ref(DT_vB) <= 5.5)) ? 1 : 0] > 0

 DFM COPY err1 err2
}

LU_4_4_7b_G {
@ LU.4.4: Within 14.976um from AA injector, space between Power Anode and NW Cathode, between PW Anode and Power cathode, and between PW Anode and NW Cathode when 3.63V < Delta V <= 5.5V. >= 35.952um
@ Check between PW Anode and Power cathode
 err1_a = EXT PW_anode_vol_gt_pos_363_CHK_lc Ntype_power_pad_within_io_pad_140_lc < LU_4_4_7_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b = EXT PW_anode_within_io_pad_140_lc Ntype_power_pad_within_io_pad_140_neg_lc < LU_4_4_7_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_L = EXT [PW_anode_vol_gt_pos_363_CHK_lc] Ntype_power_pad_within_io_pad_140_lc < LU_4_4_7_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b_L = EXT [PW_anode_within_io_pad_140_lc] Ntype_power_pad_within_io_pad_140_neg_lc < LU_4_4_7_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_R = EXT PW_anode_vol_gt_pos_363_CHK_lc [Ntype_power_pad_within_io_pad_140_lc] < LU_4_4_7_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b_R = EXT PW_anode_within_io_pad_140_lc [Ntype_power_pad_within_io_pad_140_neg_lc] < LU_4_4_7_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_L_gC = RW COIN EDGE err1_a_L
 err1_b_L_gC = RW COIN EDGE err1_b_L
 err1_a_R_gC = AA_c COIN EDGE err1_a_R
 err1_b_R_gC = AA_c COIN EDGE err1_b_R

 err1_a_L_NETID = DFM PROPERTY err1_a_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_a_R_NETID = DFM PROPERTY err1_a_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1_b_L_NETID = DFM PROPERTY err1_b_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_b_R_NETID = DFM PROPERTY err1_b_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1 = DFM PROPERTY err1_a err1_a_L_NETID err1_a_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_a_L_NETID)]
 [NET_b = count(err1_a_R_NETID)]
 [VH_1a = property(err1_a_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_a_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_a_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_a_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 3.63 && property_ref(DT_vA) <= 5.5) || (property_ref(DT_vB) > 3.63 && property_ref(DT_vB) <= 5.5)) ? 1 : 0] > 0

 err2 = DFM PROPERTY err1_b err1_b_L_NETID err1_b_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_b_L_NETID)]
 [NET_b = count(err1_b_R_NETID)]
 [VH_1a = property(err1_b_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_b_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_b_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_b_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 3.63 && property_ref(DT_vA) <= 5.5) || (property_ref(DT_vB) > 3.63 && property_ref(DT_vB) <= 5.5)) ? 1 : 0] > 0

 DFM COPY err1 err2
}

LU_4_4_7c_G {
@ LU.4.4: Within 14.976um from AA injector, space between Power Anode and NW Cathode, between PW Anode and Power cathode, and between PW Anode and NW Cathode when 3.63V < Delta V <= 5.5V. >= 35.952um
@ Check between PW Anode and NW cathode
 err1_a = EXT PW_anode_vol_gt_pos_363_CHK_lc NW_cathode_within_io_pad_140_lc < LU_4_4_7_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b = EXT PW_anode_within_io_pad_140_lc NW_cathode_within_io_pad_140_neg_lc < LU_4_4_7_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_L = EXT [PW_anode_vol_gt_pos_363_CHK_lc] NW_cathode_within_io_pad_140_lc < LU_4_4_7_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b_L = EXT [PW_anode_within_io_pad_140_lc] NW_cathode_within_io_pad_140_neg_lc < LU_4_4_7_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_R = EXT PW_anode_vol_gt_pos_363_CHK_lc [NW_cathode_within_io_pad_140_lc] < LU_4_4_7_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_b_R = EXT PW_anode_within_io_pad_140_lc [NW_cathode_within_io_pad_140_neg_lc] < LU_4_4_7_G_val SINGULAR MEASURE ALL NOT CONNECTED
 err1_a_L_gC = RW COIN EDGE err1_a_L
 err1_b_L_gC = RW COIN EDGE err1_b_L
 err1_a_R_gC = NW COIN EDGE err1_a_R
 err1_b_R_gC = NW COIN EDGE err1_b_R

 err1_a_L_NETID = DFM PROPERTY err1_a_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_a_R_NETID = DFM PROPERTY err1_a_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1_b_L_NETID = DFM PROPERTY err1_b_L_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_b_R_NETID = DFM PROPERTY err1_b_R_gC net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]

 err1 = DFM PROPERTY err1_a err1_a_L_NETID err1_a_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_a_L_NETID)]
 [NET_b = count(err1_a_R_NETID)]
 [VH_1a = property(err1_a_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_a_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_a_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_a_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_a_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_a_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 3.63 && property_ref(DT_vA) <= 5.5) || (property_ref(DT_vB) > 3.63 && property_ref(DT_vB) <= 5.5)) ? 1 : 0] > 0

 err2 = DFM PROPERTY err1_b err1_b_L_NETID err1_b_R_NETID OVERLAP ABUT ALSO MULTI
 [NET_a = count(err1_b_L_NETID)]
 [NET_b = count(err1_b_R_NETID)]
 [VH_1a = property(err1_b_L_NETID, "max_vol", 1)]
 [VL_1a = property(err1_b_L_NETID, "min_vol", 1)]
 [VH_1b = property(err1_b_R_NETID, "max_vol", 1)]
 [VL_1b = property(err1_b_R_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_b_L_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_b_R_NETID, "min_vol", 2) : 0]
 [DT_vA = (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DT_vB = (property_ref(NET_a) >= 2) ? fmin(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmin(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmin(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a)))]
 [DV_v = ((property_ref(DT_vA) > 3.63 && property_ref(DT_vA) <= 5.5) || (property_ref(DT_vB) > 3.63 && property_ref(DT_vB) <= 5.5)) ? 1 : 0] > 0

 DFM COPY err1 err2
}
#ENDIF
#ENDIF


// =======================================================
// ESD design rules and guideline
// =======================================================

EDBESD2 = DBESD2 AND ESDIO2

ENACT = NACT AND ESDIO2
EPACT = PACT AND ESDIO2
EGATE = GATE AND ESDIO2
EGATE_W = EGATE COIN EDGE GATE_WE
EGATE_L = EGATE COIN EDGE GATE_LE

EM0 = M0 AND ESDIO2
EM0G = M0G AND ESDIO2

EPMOS = (EPACT ENCLOSE EGATE) INTERACT EM0
ENMOS = (ENACT ENCLOSE EGATE) INTERACT EM0
EMOS = OR ENMOS EPMOS
EMOS_SD = EMOS NOT GT

ENGATE = EGATE AND ENMOS
EPGATE = EGATE AND EPMOS

ENTAP = ENACT AND NW
EPTAP = EPACT NOT NW

EGATEHV = EGATE AND DG
EGATELV = EGATE NOT DG
ENGATEHV = ENGATE AND DG
EPGATEHV = EPGATE AND DG
ENGATELV = ENGATE NOT DG
EPGATELV = EPGATE NOT DG

PSD_io_pad_gen = NET AREA RATIO PSD M1_io > 0
NSD_io_pad_gen = NET AREA RATIO NSD M1_io > 0

//#IFDEF ESD_RULES_CHECK NO
//DRC UNSELECT CHECK GESD
//#ENDIF

// =======================================================
// Guidelines for 1.8V Drain-Ballasted ESD NMOS
// =======================================================
// The DBESD layer (133:10) is used only for 1.8V drain ballasted NMOS and 1.8V cascaded NMOS. With this layer covered, some AA/GT/M0 rules can be waived.
// The DBESD2 layer (133:11) is used for recognizing drain side of 1.8V drain ballasted NMOS and cascaded NMOS.

GROUP GESD ESD_?

BALLASTED_ESD_NMOS = ((ENMOS INTERACT DBESD) INTERACT ((DBESD2 CUT EGATE) NOT ENCLOSE EGATE)) NOT ESD5V
BALLASTED_ESD_NMOS_SD = BALLASTED_ESD_NMOS NOT ALL_GT
BALLASTED_ESD_GATE = EGATE AND BALLASTED_ESD_NMOS

ESD_1a_G {
@ ESD device must draw ESDIO2 (133;3) marker layer
@ Any one layer of ESDCLP (41;2), or DBESD2 (133;11), or ESD5V (133;1), or DIOMK1 (131;161), or DIOMK2 (131;162), or DBESD (133;10) must exist together with ESDIO2 (133;3)
 err1 = (OR ESDCLP DBESD2 ESD5V DIOMK1 DIOMK2 DBESD) NOT ESDIO2
 err1 NOT INSIDE SealR_NOT_BULK
}

ESD_19_G {
@ DBESD width >= 0.2um
 err1 = INT DBESD < 0.2 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

ESD_20_G {
@ DBESD space >= 0.2um
 err1 = EXT DBESD < 0.2 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

ESD_21_G {
@ DBESD extension outside of AA >= 0.046um
 err1 = ENC (AA AND DBESD) DBESD < 0.046 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

ESD_21a_G {
@ DBESD extension on (GT AND GTMK1) in S/D direction >= 0.064um
 err1_c = ANGLE GT_and_GTMK1 == 90
 err1 = ENC err1_c DBESD < 0.064 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

ESD_22_G {
@ Space between GTDMP and GT inside DBESD in S/D direction when GTDMP is inserted in drain = 0.246~0.248um
 sd_GTDMP_side = EGATE_W COIN EDGE (BALLASTED_ESD_NMOS_SD INTERACT GTDMP)
 sd_GTDMP_bulk = GTDMP INTERACT (BALLASTED_ESD_NMOS_SD INTERACT DBESD2)
 sd_GTDMP_good = EXT sd_GTDMP_bulk [EGATE_W] >= 0.246 <= 0.248 ABUT<90 OPPOSITE EXCLUDE SHIELDED
 sd_GTDMP_side_CHK = (sd_GTDMP_side COIN EDGE BALLASTED_ESD_GATE) COIN EDGE (EMOS_SD INTERACT DBESD2)
 err1 = sd_GTDMP_side_CHK NOT COIN EDGE sd_GTDMP_good
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

ESD_23_G {
@ Maximum AA length in DBESD region <= 61um
 err1 = LENGTH (AA NOT OUTSIDE EDGE DBESD) > 61
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

ESD_24_G {
@ Channel width (W) of NMOS for ESD protection device (Channel width = Finger width*Finger No.) >= 548um
 GATE_L_sides = BALLASTED_ESD_NMOS_SD COIN EDGE ALL_GT
 GATE_L_sides_EXP = EXPAND EDGE GATE_L_sides INSIDE BY 0.001
 GATE_L_check = NSD AND (GATE_L_sides_EXP INTERACT NSD_io_pad_gen)
 NET AREA RATIO GATE_L_check [AREA(GATE_L_check)/(0.001*2)] < 548 RDB "./SMIC_14SFPLUS_DRC_logFile/ESD_24_G.rdb" GATE_L_check
}

ESD_25_G {
@ Channel length of 1.8V NMOS for protection device >= 0.134um
 err1 = LENGTH ((BALLASTED_ESD_GATE AND ENGATEHV) COIN EDGE EGATE_L) < 0.134
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

ESD_26_G {
@ Space between M0 and GT at drain side of NMOS = 0.16~0.162um
 sd_GT_side = EGATE_W COIN EDGE (((EGATE INTERACT BALLASTED_ESD_NMOS) CUT DBESD2) INSIDE EDGE DBESD2)
 sd_M0_side = ((M0_NOT_M0C INTERACT ENMOS) INTERACT DBESD2) INSIDE EDGE ENMOS
 sd_GT_good = EXT sd_M0_side [sd_GT_side] >= 0.16 <= 0.162 ABUT<90 OPPOSITE EXCLUDE SHIELDED
 sd_GT_side_CHK = sd_GT_side COIN EDGE (EMOS_SD INTERACT DBESD2)
 err1 = sd_GT_side_CHK NOT TOUCH EDGE sd_GT_good  //; M0 line end can be inside AA
 err1 NOT INSIDE EDGE SealR_NOT_BULK

 err2 = EXT sd_M0_side [BALLASTED_ESD_GATE] < 0.16 ABUT<90 OPPOSITE
 err2 NOT INSIDE EDGE SealR_NOT_BULK
}

ESD_27_G {
@ Overlap of DBESD2 to GT at drain side = 0.05, 0.06um
 GATE_L_sides = EGATE_W COIN EDGE ((OR BALLASTED_ESD_NMOS_SD CASCODED_ESD_NMOS_SD) INTERACT (OR GTDMP DBESD2))
 GATE_L_check = GATE_L_sides INSIDE EDGE DBESD2
 err1 = GATE_L_sides NOT INSIDE EDGE DBESD2
 err1 NOT INSIDE EDGE SealR_NOT_BULK

 err2_TMP = INT (GATE_L_check) DBESD2 == 0.05 ABUT<90 OPPOSITE EXCLUDE SHIELDED
 err2 = INT (err2_TMP) DBESD2 == 0.06 ABUT<90 OPPOSITE EXCLUDE SHIELDED
 err2 NOT INSIDE EDGE SealR_NOT_BULK
}

ESD_28_G {
@ Space between GT at source side in DBESD = 0.118, 0.119, 0.246~0.248um
 GATE_L_sides = GT COIN EDGE ((OR BALLASTED_ESD_NMOS_SD CASCODED_ESD_NMOS_SD) NOT INTERACT DBESD2)
 GOOD_a = EXT [GATE_L_sides] GT >= 0.118 <= 0.119 ABUT<90 OPPOSITE EXCLUDE SHIELDED
 GOOD_b = EXT [GATE_L_sides] GT >= 0.246 <= 0.248 ABUT<90 OPPOSITE EXCLUDE SHIELDED
 err1 = GATE_L_sides NOT COIN EDGE (OR EDGE GOOD_a GOOD_b)
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}



// =======================================================
// Guidelines for Cascoded N/PMOS
// =======================================================
//;ESD5V (133:1) is the marking layer to recognize cascaded N/PMOS
CASCODED_ESD_NMOS = ((ENMOS AND ESD5V) INTERACT DBESD) INTERACT ((DBESD2 CUT EGATE) NOT ENCLOSE EGATE)
CASCODED_ESD_PMOS = ((EPMOS AND ESD5V) NOT INTERACT DBESD) NOT INTERACT ((DBESD2 CUT EGATE) NOT ENCLOSE EGATE)
CASCODED_ESD_NMOS_SD = CASCODED_ESD_NMOS NOT ALL_GT
CASCODED_ESD_MOS = CASCODED_ESD_NMOS OR CASCODED_ESD_PMOS

CASCODED_ESD_NGATE = EGATE AND CASCODED_ESD_NMOS
CASCODED_ESD_PGATE = EGATE AND CASCODED_ESD_PMOS
CASCODED_ESD_GATE = CASCODED_ESD_NGATE OR CASCODED_ESD_PGATE

PSD_in_DIOMK_DSTR = PSD AND (OR DIOMK1 DIOMK2 DSTR)

ESD_29_G {
@ Space between GTDMP and GT inside DBESD in S/D direction when GTDMP is inserted in drain = 0.246~0.248um
 sd_GTDMP_side = GTDMP INSIDE EDGE CASCODED_ESD_MOS
 sd_GTDMP_good = EXT [sd_GTDMP_side] EGATE_W >= 0.246 <= 0.248 ABUT<90 OPPOSITE EXCLUDE SHIELDED
 err1 = sd_GTDMP_side NOT COIN EDGE sd_GTDMP_good
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

ESD_30_G {
@ Channel width (W) of NMOS for ESD protection device (Channel width = Finger width*Finger No.) >= 548um
 GATE_L_sides = CASCODED_ESD_NMOS_SD COIN EDGE ALL_GT
 GATE_L_sides_EXP = EXPAND EDGE GATE_L_sides INSIDE BY 0.001
 GATE_L_check = (NSD INTERACT M0) AND (GATE_L_sides_EXP INTERACT NSD_io_pad_gen)
 NET AREA RATIO GATE_L_check [AREA(GATE_L_check)/(0.001*2)] < 548 RDB "./SMIC_14SFPLUS_DRC_logFile/ESD_30_G.rdb" GATE_L_check
}

ESD_31_G {
@ Channel length of cascaded NMOS for protection device >= 0.134um
 err1 = LENGTH (CASCODED_ESD_NGATE COIN EDGE EGATE_L) < 0.134
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

ESD_32_G {
@ Spacing between M0 and GT at drain side of cascaded NMOS = 0.16~0.162um
 sd_GT_side = EGATE_W COIN EDGE (((EGATE INTERACT CASCODED_ESD_NMOS) CUT DBESD2) INSIDE EDGE DBESD2)
 sd_M0_side = ((M0_NOT_M0C INTERACT ENMOS) INTERACT DBESD2) INSIDE EDGE ENMOS
 sd_GT_good = EXT sd_M0_side [sd_GT_side] >= 0.16 <= 0.162 ABUT<90 OPPOSITE EXCLUDE SHIELDED
 sd_GT_side_CHK = sd_GT_side COIN EDGE (EMOS_SD INTERACT DBESD2)
 err1 = sd_GT_side_CHK NOT TOUCH EDGE sd_GT_good  //; M0 line end can be inside AA
 err1 NOT INSIDE EDGE SealR_NOT_BULK

 err2 = EXT sd_M0_side [CASCODED_ESD_NGATE] < 0.16 ABUT<90 OPPOSITE
 err2 NOT INSIDE EDGE SealR_NOT_BULK
}

ESD_33_G {
@ When PMOS connected to IO pad, it must be cascaded PMOS to increase trigger voltage and avoid ESD current going through
@ This rule can be waived when dual diode based ESD protection is designed. (DRC will not check DIOMK1, DIOMK2, and PMOS after resistor)
 PMOS_oneSide_io_pad = NET AREA RATIO PSD_io_pad_gen PSD_in_DIOMK_DSTR [!AREA(PSD_in_DIOMK_DSTR)] > 0
 PMOS_oneSide_pw_pad = NET AREA RATIO (PSD INTERACT (AA INTERACT PMOS_oneSide_io_pad)) M1_power > 0  //;reduce runtime
 err1 = (GATE INTERACT PMOS_oneSide_io_pad) INTERACT PMOS_oneSide_pw_pad
 err1 NOT INSIDE SealR_NOT_BULK
}




// =======================================================
// Guidelines for Power Clamp guidelines
// =======================================================
//;ESDCLP (41:2) is the marking layer for ESD RC-triggered power clamp structures connected to a power supply pad
//;DRC uses (N+ AA and ESDCLP and ESDIO2) to recognize power clamp NMOS and ((P+ AA and ESDCLP and ESDIO2) NOT INTERACT DBESD2) to recognize power clamp PMOS

POWER_CLAMP_ESD_PMOS = (EPMOS NOT INTERACT DBESD) NOT INTERACT (OR DBESD2 DIOMK1 DIOMK2)  //) AND ESDCLP
POWER_CLAMP_ESD_NMOS = (ENMOS NOT INTERACT DBESD) NOT INTERACT (OR DBESD2 DIOMK1 DIOMK2)  //) AND ESDCLP
POWER_CLAMP_ESD_MOS = OR POWER_CLAMP_ESD_NMOS POWER_CLAMP_ESD_PMOS
POWER_CLAMP_ESD_PMOS_SD = POWER_CLAMP_ESD_PMOS NOT ALL_GT
POWER_CLAMP_ESD_NMOS_SD = POWER_CLAMP_ESD_NMOS NOT ALL_GT
POWER_CLAMP_ESD_MOS_SD = OR POWER_CLAMP_ESD_PMOS_SD POWER_CLAMP_ESD_NMOS_SD

POWER_CLAMP_ESD_PGATE_WE = EGATE_W INSIDE EDGE POWER_CLAMP_ESD_PMOS
POWER_CLAMP_ESD_NGATE_WE = EGATE_W INSIDE EDGE POWER_CLAMP_ESD_NMOS

POWER_CLAMP_ESD_NGATE_LV = POWER_CLAMP_ESD_NMOS AND EGATELV
POWER_CLAMP_ESD_PGATE_LV = POWER_CLAMP_ESD_PMOS AND EGATELV
POWER_CLAMP_ESD_NGATE_HV = POWER_CLAMP_ESD_NMOS AND EGATEHV
POWER_CLAMP_ESD_PGATE_HV = POWER_CLAMP_ESD_PMOS AND EGATEHV

POWER_CLAMP_ESD_GATE = EGATE AND POWER_CLAMP_ESD_MOS
POWER_CLAMP_ESD_GATE_LV = OR POWER_CLAMP_ESD_NGATE_LV POWER_CLAMP_ESD_PGATE_LV
POWER_CLAMP_ESD_GATE_HV = OR POWER_CLAMP_ESD_NGATE_HV POWER_CLAMP_ESD_PGATE_HV
POWER_CLAMP_ESD_PMOS_SD_LV = POWER_CLAMP_ESD_PMOS_SD NOT DG
POWER_CLAMP_ESD_PMOS_SD_HV = POWER_CLAMP_ESD_PMOS_SD AND DG
POWER_CLAMP_ESD_NMOS_SD_LV = POWER_CLAMP_ESD_NMOS_SD NOT DG
POWER_CLAMP_ESD_NMOS_SD_HV = POWER_CLAMP_ESD_NMOS_SD AND DG

ESD_34_34a_G {
@ ESD.34a, ESD.34b are defined for total channel width of of Power Clamp N/PMOS. The total channel width is calculated by the ESD MOS in the same Source or Drain connection. With either one of calculated total channel width with the same source or drain connection larger than the defined value, DRC does not flag the violation. The connectivity can be formed by all metal, via, ALPA, PA but not broken by resistors
@ Channel width (W) of 0.8V power clamp N/PMOS (Channel width = Finger width*Finger No.) >= 2798um
 EXP_sides_nmos = EXPAND EDGE (POWER_CLAMP_ESD_PMOS_SD_LV COIN EDGE ALL_GT) INSIDE BY 0.001
 EXP_sides_pmos = EXPAND EDGE (POWER_CLAMP_ESD_NMOS_SD_LV COIN EDGE ALL_GT) INSIDE BY 0.001
 EXP_sides_all = (AA_c INTERACT M0) AND (OR EXP_sides_nmos EXP_sides_pmos)
 NET AREA RATIO EXP_sides_all [AREA(EXP_sides_all)/(0.001*2)] < 2798 RDB "./SMIC_14SFPLUS_DRC_logFile/ESD_34_34a_G.rdb" EXP_sides_all
}

ESD_34_34b_G {
@ ESD.34a(G), ESD.34b(G) are defined for total channel width of of Power Clamp N/PMOS. The total channel width is calculated by the ESD MOS in the same Source or Drain connection. With either one of calculated total channel width with the same source or drain connection larger than the defined value, DRC does not flag the violation. The connectivity can be formed by all metal, via, ALPA, PA but not broken by resistors
@ Channel width (W) of 1.8V power clamp N/PMOS (Channel width = Finger width*Finger No.) >= 2498um
 EXP_sides_nmos = EXPAND EDGE (POWER_CLAMP_ESD_PMOS_SD_HV COIN EDGE ALL_GT) INSIDE BY 0.001
 EXP_sides_pmos = EXPAND EDGE (POWER_CLAMP_ESD_NMOS_SD_HV COIN EDGE ALL_GT) INSIDE BY 0.001
 EXP_sides_all = (AA_c INTERACT M0) AND (OR EXP_sides_nmos EXP_sides_pmos)
 NET AREA RATIO EXP_sides_all [AREA(EXP_sides_all)/(0.001*2)] < 2498 RDB "./SMIC_14SFPLUS_DRC_logFile/ESD_34_34b_G.rdb" EXP_sides_all
}

ESD_35a_G {
@ Channel length (L) of 0.8V power clamp N/PMOS = 0.07~0.13um
 err1_c = POWER_CLAMP_ESD_GATE_LV COIN EDGE EGATE_W
 err1 = INT (err1_c) >= 0.07 <= 0.13 ABUT<90 OPPOSITE EXCLUDE SHIELDED
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

ESD_35b_G {
@ Channel length (L) of 1.8V power clamp N/PMOS = 0.134~0.242um
 err1_c = POWER_CLAMP_ESD_GATE_HV COIN EDGE EGATE_W
 err1 = INT (err1_c) >= 0.134 <= 0.242 ABUT<90 OPPOSITE EXCLUDE SHIELDED
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}




// =======================================================
// Guidelines for ESD STI Diode guidelines
// =======================================================
//;DIOMK1 (131:161) is the marking layer for STI bounded diode
//;DRC uses (DIOMK1 AND ESDIO2) to recognize STI bounded diode for ESD protection
//;ALL GT is covered by GTMK1
//;ESDIO2 marker will be gated by ESD.1a

AACT_ESD_STI_DIODE = (NACT OR PACT) AND DIOMK1
PACT_ESD_STI_DIODE = AACT_ESD_STI_DIODE AND PACT
NACT_ESD_STI_DIODE = AACT_ESD_STI_DIODE AND NACT

PACT_ESD_STI_DIODE_io_pad = PACT_ESD_STI_DIODE INTERACT PSD_io_pad_gen
NACT_ESD_STI_DIODE_io_pad = NACT_ESD_STI_DIODE INTERACT NSD_io_pad_gen
AACT_ESD_STI_DIODE_io_pad = OR NACT_ESD_STI_DIODE_io_pad PACT_ESD_STI_DIODE_io_pad

STI_DIODE_ESD_NTAP = NTAP INTERACT DIOMK1
STI_DIODE_ESD_PTAP = PTAP INTERACT DIOMK1
STI_DIODE_ESD_PKUP = OR STI_DIODE_ESD_NTAP STI_DIODE_ESD_PTAP

STI_DIODE_ESD_NTAP_ov = NTAP INTERACT (SIZE DIOMK1 BY ESD_39_G_val-0.086/2) //;based on ESD_39_G/ESD_40_G
STI_DIODE_ESD_PTAP_ov = PTAP INTERACT (SIZE DIOMK1 BY ESD_39_G_val-0.086/2)

STI_DIODE_ESD_NTAP_MERGED = SIZE STI_DIODE_ESD_NTAP_ov BY 0.240/2 OVERUNDER
STI_DIODE_ESD_PTAP_MERGED = SIZE STI_DIODE_ESD_PTAP_ov BY 0.240/2 OVERUNDER

STI_DIODE_ESD_GATE = GATE_raw AND DIOMK1
STI_DIODE_ESD_GATE_WE = STI_DIODE_ESD_GATE COIN EDGE (AACT_ESD_STI_DIODE NOT GT) //;(AACT_ESD_STI_DIODE_io_pad NOT GATE_raw)

ESD_36_G {
@ N+AA or P+AA width inside ESD diode (W) >= 0.336um <= 0.576um
 err1 = NOT LENGTH STI_DIODE_ESD_GATE_WE >= 0.336 <= 0.576
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

ESD_37_G {
@ N+AA or P+AA length inside ESD diode (L) <= 42um
 err1 = ENCLOSE RECTANGLE AACT_ESD_STI_DIODE 0.001 42+GLOBAL_TOLERANCE ORTHOGONAL ONLY
 err1 NOT INSIDE SealR_NOT_BULK
}

STI_DIODE_ESD_NACT_io_pad = NACT_ESD_STI_DIODE_io_pad INTERACT M0_NOT_M0C
STI_DIODE_ESD_PACT_io_pad = PACT_ESD_STI_DIODE_io_pad INTERACT M0_NOT_M0C
STI_DIODE_ESD_NACT_io_pad_C = STAMP NACT_ESD_STI_DIODE_io_pad BY NSD
STI_DIODE_ESD_PACT_io_pad_C = STAMP PACT_ESD_STI_DIODE_io_pad BY PSD

ESD_38_Ndiode_G {
@ Total perimeter of STI ESD diode ((L+W)*2)*N in the same connection to I/O Pad >= 298um
 NET AREA RATIO STI_DIODE_ESD_NACT_io_pad_C [perimeter(STI_DIODE_ESD_NACT_io_pad_C)] < 298 RDB "./SMIC_14SFPLUS_DRC_logFile/ESD_38_Ndiode_G.rdb" STI_DIODE_ESD_NACT_io_pad_C
}

ESD_38_Pdiode_G {
@ Total perimeter of STI ESD diode ((L+W)*2)*N in the same connection to I/O Pad >= 298um
 NET AREA RATIO STI_DIODE_ESD_PACT_io_pad_C [perimeter(STI_DIODE_ESD_PACT_io_pad_C)] > 0 < 298 RDB "./SMIC_14SFPLUS_DRC_logFile/ESD_38_Pdiode_G.rdb" STI_DIODE_ESD_PACT_io_pad_C
}

VARIABLE ESD_39_G_val 0.81

ESD_39_G {
@ Spacing between N+AA and P+ pickup AA in N+/PW diode or P+ AA to N+ pickup AA in P+/NW diode (S) <= 0.81um
 err1 = EXT (NACT_ESD_STI_DIODE) STI_DIODE_ESD_PTAP_MERGED <= ESD_39_G_val ABUT<90
 err2 = EXT (PACT_ESD_STI_DIODE) STI_DIODE_ESD_NTAP_MERGED <= ESD_39_G_val ABUT<90
 err1 NOT INSIDE EDGE SealR_NOT_BULK
 err2 NOT INSIDE EDGE SealR_NOT_BULK
}

AOP_GT_on_ESD_STI = AOP_GT INTERACT (OR AACT_ESD_STI_DIODE STI_DIODE_ESD_PKUP)
AOP_GT_on_ESD_STI_edges = AOP_GT COIN EDGE ((OR AACT_ESD_STI_DIODE STI_DIODE_ESD_PKUP) NOT AOP_GT_on_ESD_STI)

ESD_40_G {
@ AOP_GT is must for ESD STI diode design, and AOP_GT width should be = 0.086um
//;include pick-up
 err1 = INT (AOP_GT_on_ESD_STI_edges) AOP_GT == 0.086 ABUT<90 OPPOSITE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

ESD_41_G {
@ Space between two AOP_GTs = 0.118, 0.119um
//;include pick-up
 err1 = EXT (AOP_GT_on_ESD_STI_edges) >= 0.118 <= 0.119 ABUT<90 OPPOSITE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

ESD_42_G {
@ All GT&GTDMP need to be connected to their associated AA by M0G
 err1_c = DMP_GT AND AACT_ESD_STI_DIODE
 err1 = err1_c NOT INTERACT (M0G INTERACT AACT_ESD_STI_DIODE)
 err1 NOT INSIDE SealR_NOT_BULK
}

ESD_43_G {
@ STI diode for ESD protection should be covered by DG
 err1 = AACT_ESD_STI_DIODE NOT DG
 err1 NOT INSIDE SealR_NOT_BULK
}




// =======================================================
// Guidelines for ESD Gated Diode guidelines
// =======================================================
//;DIOMK2 (131:162) is the marking layer for poly bounded (gated) diode
//;DRC uses (DIOMK2 AND ESDIO2) to recognize poly bounded diode for ESD protection
//;ESDIO2 will be gated by ESD.1a

GATED_DIODE_ESD_NAA = NAA AND DIOMK2 //;) AND ESDIO2
GATED_DIODE_ESD_PAA = PAA AND DIOMK2 //;) AND ESDIO2
GATED_DIODE_ESD_ACT = OR GATED_DIODE_ESD_NAA GATED_DIODE_ESD_PAA

GATED_DIODE_ESD_PSD = PSD INTERACT GATED_DIODE_ESD_ACT
GATED_DIODE_ESD_NSD = NSD INTERACT GATED_DIODE_ESD_ACT
GATED_DIODE_ESD_PSD_io_pad = PSD_io_pad_gen INTERACT GATED_DIODE_ESD_ACT
GATED_DIODE_ESD_NSD_io_pad = NSD_io_pad_gen INTERACT GATED_DIODE_ESD_ACT

GATED_DIODE_ESD_GATE = (GATE_DIOMK2 INTERACT GATED_DIODE_ESD_ACT) AND (AA INTERACT ACT)
GATED_DIODE_ESD_AA_c = AA_c INTERACT GATE_DIOMK2
GATED_DIODE_ESD_GT_c = GT_0 INTERACT GATED_DIODE_ESD_ACT

ESD_44_G {
@ Total perimeter of ESD Gated diode in the same connection to I/O pad (H*2*N) >= 248um
 ESD_GATED_DIODE_P = PSD AND (EXPAND EDGE (GATED_DIODE_ESD_PSD_io_pad COIN EDGE GT_0) INSIDE BY 0.002)
 NET AREA RATIO ESD_GATED_DIODE_P [AREA(ESD_GATED_DIODE_P)/0.002] < 248 RDB "./SMIC_14SFPLUS_DRC_logFile/ESD_44_G_Pdiode.rdb" ESD_GATED_DIODE_P

 ESD_GATED_DIODE_N = NSD AND (EXPAND EDGE (GATED_DIODE_ESD_NSD_io_pad COIN EDGE GT_0) INSIDE BY 0.002)
 NET AREA RATIO ESD_GATED_DIODE_N [AREA(ESD_GATED_DIODE_N)/0.002] < 248 RDB "./SMIC_14SFPLUS_DRC_logFile/ESD_44_G_Ndiode.rdb" ESD_GATED_DIODE_N
}

#IFDEF Delta_Voltage_Rules_Check YES
ESD_45_G {
@ Gated diode cannot be used for > 1.98V (1.8V+10%) application
//;0.155 based on GATED rule
 err1 = DFM DV GATED_DIODE_ESD_AA_c < 0.155 DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 1.98 ANNOTATE NOT CONNECTED OPPOSITE
 DFM COPY err1 REGION
/*
 err1_a_NETID = DFM PROPERTY GATED_DIODE_ESD_AA_c net_vol_assign NODAL MULTI [max_vol = property(net_vol_assign, max_vol)] [min_vol = property(net_vol_assign, min_vol)]
 err1_b_sync = AA_SYC COIN EDGE GATED_DIODE_ESD_AA_c
 err1_c_sync = EXT [err1_b_sync] < 0.086 OPPOSITE CONNECTED EXCLUDE SHIELDED //;based on GGATED rule

 err1 = DFM PROPERTY GATED_DIODE_ESD_GATE err1_a_NETID err1_c_sync GATED_DIODE_ESD_AA_c OVERLAP ABUT ALSO MULTI
 [CHEK = count(GATED_DIODE_ESD_AA_c)] == 2
 [SYNC = (count(err1_c_sync) > 0) ? 1 : 0]
 [NET_a = count(err1_a_NETID)]
 [NET_b = count(err1_a_NETID)]
 [VH_1a = property(err1_a_NETID, "max_vol", 1)]
 [VL_1a = property(err1_a_NETID, "min_vol", 1)]
 [VH_1b = property(err1_a_NETID, "max_vol", 1)]
 [VL_1b = property(err1_a_NETID, "min_vol", 1)]
 [VH_2a = (property_ref(NET_a) >= 2) ? property(err1_a_NETID, "max_vol", 2) : 0]
 [VL_2a = (property_ref(NET_a) >= 2) ? property(err1_a_NETID, "min_vol", 2) : 0]
 [VH_2b = (property_ref(NET_b) >= 2) ? property(err1_a_NETID, "max_vol", 2) : 0]
 [VL_2b = (property_ref(NET_b) >= 2) ? property(err1_a_NETID, "min_vol", 2) : 0]
 [DT_v = (property_ref(SYNC) == 1) ? (
 (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VH_2a)), abs(property_ref(VL_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VH_2b)), abs(property_ref(VL_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VH_1b)), abs(property_ref(VL_1b) - property_ref(VL_1a)))) : (
 (property_ref(NET_a) >= 2) ? fmax(abs(property_ref(VH_1a) - property_ref(VL_2a)), abs(property_ref(VH_2a) - property_ref(VL_1a))) :
 (property_ref(NET_b) >= 2) ? fmax(abs(property_ref(VH_1b) - property_ref(VL_2b)), abs(property_ref(VH_2b) - property_ref(VL_1b))) :
 fmax(abs(property_ref(VH_1a) - property_ref(VL_1b)), abs(property_ref(VH_1b) - property_ref(VL_1a))))] > 1.98

 err1 NOT INSIDE SealR_NOT_BULK
*/
}
#ENDIF

ESD_46_G {
@ GT of Gated diode should be floating
//;not allowed to connect to anything
 err1 = NET AREA RATIO GATED_DIODE_ESD_GT_c M0_0 [!!AREA(GATED_DIODE_ESD_GT_c)*!!AREA(M0_0)] > 0
 err1 NOT INSIDE SealR_NOT_BULK
}

ESD_47_G {
@ The number of GTs in one AA inside DIOMK2 <= 130
 err1 = GATED_DIODE_ESD_ACT INTERACT (GATE_DIOMK2 NOT INTERACT AA_v_edges_exp001) > 130
 err1 NOT INSIDE SealR_NOT_BULK
}
 
// =======================================================
// LOGO design rules
// =======================================================
GROUP GLOGO LOGO_?
 
LOGO_1_AA {
@ Space between LOGO and (AA/GT/M1/Mxy/1.25xMy/1.25xMn/10xTMn/14xTMn/UTM/ALPA OUTSIDE LOGO), except OCCD, OCOVL, WTPMK region >= 9.0um
 check_area = (SIZE LOGO BY 9 INSIDE OF DRC:1 STEP 2 BEVEL 4) NOT LOGO
 waive_area = OR OCCD OCOVL WTPMK
 err1 = check_area AND AA
 err1 NOT INSIDE waive_area
}
 
LOGO_1_GT {
@ Space between LOGO and (AA/GT/M1/Mxy/1.25xMy/1.25xMn/10xTMn/14xTMn/UTM/ALPA OUTSIDE LOGO), except OCCD, OCOVL, WTPMK region >= 9.0um
 check_area = (SIZE LOGO BY 9 INSIDE OF DRC:1 STEP 2 BEVEL 4) NOT LOGO
 waive_area = OR OCCD OCOVL WTPMK
 err1 = check_area AND GT
 err1 NOT INSIDE waive_area
}
 
LOGO_1_M1 {
@ Space between LOGO and (AA/GT/M1/Mxy/1.25xMy/1.25xMn/10xTMn/14xTMn/UTM/ALPA OUTSIDE LOGO), except OCCD, OCOVL, WTPMK region >= 9.0um
 check_area = (SIZE LOGO BY 9 INSIDE OF DRC:1 STEP 2 BEVEL 4) NOT LOGO
 waive_area = OR OCCD OCOVL WTPMK
 err1 = check_area AND M1
 err1 NOT INSIDE waive_area
}
 
LOGO_1_M2 {
@ Space between LOGO and (AA/GT/M1/Mxy/1.25xMy/1.25xMn/10xTMn/14xTMn/UTM/ALPA OUTSIDE LOGO), except OCCD, OCOVL, WTPMK region >= 9.0um
 check_area = (SIZE LOGO BY 9 INSIDE OF DRC:1 STEP 2 BEVEL 4) NOT LOGO
 waive_area = OR OCCD OCOVL WTPMK
 err1 = check_area AND M2
 err1 NOT INSIDE waive_area
}
 
LOGO_1_M3 {
@ Space between LOGO and (AA/GT/M1/Mxy/1.25xMy/1.25xMn/10xTMn/14xTMn/UTM/ALPA OUTSIDE LOGO), except OCCD, OCOVL, WTPMK region >= 9.0um
 check_area = (SIZE LOGO BY 9 INSIDE OF DRC:1 STEP 2 BEVEL 4) NOT LOGO
 waive_area = OR OCCD OCOVL WTPMK
 err1 = check_area AND M3
 err1 NOT INSIDE waive_area
}
 
LOGO_1_M4 {
@ Space between LOGO and (AA/GT/M1/Mxy/1.25xMy/1.25xMn/10xTMn/14xTMn/UTM/ALPA OUTSIDE LOGO), except OCCD, OCOVL, WTPMK region >= 9.0um
 check_area = (SIZE LOGO BY 9 INSIDE OF DRC:1 STEP 2 BEVEL 4) NOT LOGO
 waive_area = OR OCCD OCOVL WTPMK
 err1 = check_area AND M4
 err1 NOT INSIDE waive_area
}
 
LOGO_1_M5 {
@ Space between LOGO and (AA/GT/M1/Mxy/1.25xMy/1.25xMn/10xTMn/14xTMn/UTM/ALPA OUTSIDE LOGO), except OCCD, OCOVL, WTPMK region >= 9.0um
 check_area = (SIZE LOGO BY 9 INSIDE OF DRC:1 STEP 2 BEVEL 4) NOT LOGO
 waive_area = OR OCCD OCOVL WTPMK
 err1 = check_area AND M5
 err1 NOT INSIDE waive_area
}
 
LOGO_1_M6 {
@ Space between LOGO and (AA/GT/M1/Mxy/1.25xMy/1.25xMn/10xTMn/14xTMn/UTM/ALPA OUTSIDE LOGO), except OCCD, OCOVL, WTPMK region >= 9.0um
 check_area = (SIZE LOGO BY 9 INSIDE OF DRC:1 STEP 2 BEVEL 4) NOT LOGO
 waive_area = OR OCCD OCOVL WTPMK
 err1 = check_area AND M6
 err1 NOT INSIDE waive_area
}
 
LOGO_1_M7 {
@ Space between LOGO and (AA/GT/M1/Mxy/1.25xMy/1.25xMn/10xTMn/14xTMn/UTM/ALPA OUTSIDE LOGO), except OCCD, OCOVL, WTPMK region >= 9.0um
 check_area = (SIZE LOGO BY 9 INSIDE OF DRC:1 STEP 2 BEVEL 4) NOT LOGO
 waive_area = OR OCCD OCOVL WTPMK
 err1 = check_area AND M7
 err1 NOT INSIDE waive_area
}
 
LOGO_1_TM2 {
@ Space between LOGO and (AA/GT/M1/Mxy/1.25xMy/1.25xMn/10xTMn/14xTMn/UTM/ALPA OUTSIDE LOGO), except OCCD, OCOVL, WTPMK region >= 9.0um
 check_area = (SIZE LOGO BY 9 INSIDE OF DRC:1 STEP 2 BEVEL 4) NOT LOGO
 waive_area = OR OCCD OCOVL WTPMK
 err1 = check_area AND TM2
 err1 NOT INSIDE waive_area
}
 
LOGO_1_ALPA {
@ Space between LOGO and (AA/GT/M1/Mxy/1.25xMy/1.25xMn/10xTMn/14xTMn/UTM/ALPA OUTSIDE LOGO), except OCCD, OCOVL, WTPMK region >= 9.0um
 check_area = (SIZE LOGO BY 9 INSIDE OF DRC:1 STEP 2 BEVEL 4) NOT LOGO
 waive_area = OR OCCD OCOVL WTPMK
 err1 = check_area AND ALPA
 err1 NOT INSIDE waive_area
}
 
LOGO_2_M1 {
@ Metal width in LOGO region >= 0.106um
 err1 = INT (M1 NOT OUTSIDE LOGO) < 0.106 ABUT<90 SINGULAR REGION
 err1 NOT OUTSIDE LOGO
}
 
LOGO_3_M1 {
@ Space between two metals in LOGO region >= 0.106um
 err1 = EXT (M1 NOT OUTSIDE LOGO) M1 < 0.106 ABUT<89 SINGULAR REGION
 err1 NOT OUTSIDE LOGO
}
 
LOGO_2_M2 {
@ Metal width in LOGO region >= 0.106um
 err1 = INT (M2 NOT OUTSIDE LOGO) < 0.106 ABUT<90 SINGULAR REGION
 err1 NOT OUTSIDE LOGO
}
 
LOGO_3_M2 {
@ Space between two metals in LOGO region >= 0.106um
 err1 = EXT (M2 NOT OUTSIDE LOGO) M2 < 0.106 ABUT<89 SINGULAR REGION
 err1 NOT OUTSIDE LOGO
}
 
LOGO_2_M3 {
@ Metal width in LOGO region >= 0.106um
 err1 = INT (M3 NOT OUTSIDE LOGO) < 0.106 ABUT<90 SINGULAR REGION
 err1 NOT OUTSIDE LOGO
}
 
LOGO_3_M3 {
@ Space between two metals in LOGO region >= 0.106um
 err1 = EXT (M3 NOT OUTSIDE LOGO) M3 < 0.106 ABUT<89 SINGULAR REGION
 err1 NOT OUTSIDE LOGO
}
 
LOGO_2_M4 {
@ Metal width in LOGO region >= 0.106um
 err1 = INT (M4 NOT OUTSIDE LOGO) < 0.106 ABUT<90 SINGULAR REGION
 err1 NOT OUTSIDE LOGO
}
 
LOGO_3_M4 {
@ Space between two metals in LOGO region >= 0.106um
 err1 = EXT (M4 NOT OUTSIDE LOGO) M4 < 0.106 ABUT<89 SINGULAR REGION
 err1 NOT OUTSIDE LOGO
}
 
LOGO_2_M5 {
@ Metal width in LOGO region >= 0.106um
 err1 = INT (M5 NOT OUTSIDE LOGO) < 0.106 ABUT<90 SINGULAR REGION
 err1 NOT OUTSIDE LOGO
}
 
LOGO_3_M5 {
@ Space between two metals in LOGO region >= 0.106um
 err1 = EXT (M5 NOT OUTSIDE LOGO) M5 < 0.106 ABUT<89 SINGULAR REGION
 err1 NOT OUTSIDE LOGO
}
 
LOGO_2_M6 {
@ Metal width in LOGO region >= 0.106um
 err1 = INT (M6 NOT OUTSIDE LOGO) < 0.106 ABUT<90 SINGULAR REGION
 err1 NOT OUTSIDE LOGO
}
 
LOGO_3_M6 {
@ Space between two metals in LOGO region >= 0.106um
 err1 = EXT (M6 NOT OUTSIDE LOGO) M6 < 0.106 ABUT<89 SINGULAR REGION
 err1 NOT OUTSIDE LOGO
}
 
LOGO_2_M7 {
@ Metal width in LOGO region >= 0.106um
 err1 = INT (M7 NOT OUTSIDE LOGO) < 0.106 ABUT<90 SINGULAR REGION
 err1 NOT OUTSIDE LOGO
}
 
LOGO_3_M7 {
@ Space between two metals in LOGO region >= 0.106um
 err1 = EXT (M7 NOT OUTSIDE LOGO) M7 < 0.106 ABUT<89 SINGULAR REGION
 err1 NOT OUTSIDE LOGO
}
 
LOGO_2_TM2 {
@ Metal width in LOGO region >= 0.106um
 err1 = INT (TM2 NOT OUTSIDE LOGO) < 0.106 ABUT<90 SINGULAR REGION
 err1 NOT OUTSIDE LOGO
}
 
LOGO_3_TM2 {
@ Space between two metals in LOGO region >= 0.106um
 err1 = EXT (TM2 NOT OUTSIDE LOGO) TM2 < 0.106 ABUT<89 SINGULAR REGION
 err1 NOT OUTSIDE LOGO
}
 
LOGO_2_ALPA {
@ Metal width in LOGO region >= 0.106um
 err1 = INT (ALPA NOT OUTSIDE LOGO) < 0.106 ABUT<90 SINGULAR REGION
 err1 NOT OUTSIDE LOGO
}
 
LOGO_3_ALPA {
@ Space between two metals in LOGO region >= 0.106um
 err1 = EXT (ALPA NOT OUTSIDE LOGO) ALPA < 0.106 ABUT<89 SINGULAR REGION
 err1 NOT OUTSIDE LOGO
}
// LOGO_4[NC] A circuit in the LOGO region is not allowed

// =======================================================
// Analog design rule
// =======================================================

GROUP GAN AN_?

AN_CAP_4 {
@ Please use thick oxide (DG) MOS varactor and capacitor to reduce gate oxide leakage
@ DRC cannot check capacitor
 err1 = (((AA INTERACT GATE) AND VARMOS) INTERACT (OR ACMK1 ANMK0 ANMK1 ANMK2)) NOT DG
 err1 NOT INSIDE SealR_NOT_BULK
}

AN_MOS_M_3 {
@ ANMK0, ANMK1, ANMK2 cannot overlap each other
 err1 = ANMK0 AND ANMK1
 err2 = ANMK0 AND ANMK2
 err3 = ANMK1 AND ANMK2
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
}

AN_MOS_M_5 {
@ Recommended pickup width <= 0.96
 err1 = (WITH WIDTH (SIZE TAP_RAW BY 0.048 OVERUNDER) > 0.96) INSIDE (OR ANMK0 ANMK1 ANMK2)
 err1 NOT INSIDE SealR_NOT_BULK
}

AN_MOS_M_6 {
@ Recommended space between ANMK0/ANMK1/ANMK2 region and ALPA (CUT is not allowed) >= 3
 err1 = EXT ANMK0 ALPA < 3 ABUT<90 SINGULAR REGION
 err2 = EXT ANMK1 ALPA < 3 ABUT<90 SINGULAR REGION
 err3 = EXT ANMK2 ALPA < 3 ABUT<90 SINGULAR REGION
 err4 = ANMK0 INSIDE EDGE ALPA
 err5 = ANMK1 INSIDE EDGE ALPA
 err6 = ANMK2 INSIDE EDGE ALPA

 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
 err4 NOT INSIDE EDGE SealR_NOT_BULK
 err5 NOT INSIDE EDGE SealR_NOT_BULK
 err6 NOT INSIDE EDGE SealR_NOT_BULK
}

AN_MOS_M_7 {
@ Recommended ANMK0/ANMK1/ANMK2 enclosure ALPA >= 3
 err1 = ENC ALPA ANMK0 < 3 ABUT<90 SINGULAR REGION
 err2 = ENC ALPA ANMK1 < 3 ABUT<90 SINGULAR REGION
 err3 = ENC ALPA ANMK2 < 3 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
}
 
AN_MOM_M_2_M1 {
@ MOM finger space
@ This rule is for performing same coloring to get better matching performance >= 0.063um
 // based on MOM.S.2 (finger line end space already >= 0.091)
 check_met = M1_convex_270_90_edges COIN EDGE ((M1 AND MOMDMY) AND (OR ACMK1 ANMK0 ANMK1 ANMK2))
 err1 = EXT (M1 COIN EDGE check_met) < 0.063 ABUT<90 OPPOSITE REGION NOT CONNECTED
 err1 NOT INSIDE SealR_NOT_BULK
}
 
AN_MOM_M_2_M2 {
@ MOM finger space
@ This rule is for performing same coloring to get better matching performance >= 0.063um
 // based on MOM.S.2 (finger line end space already >= 0.091)
 check_met = M2_convex_270_90_edges COIN EDGE ((M2 AND MOMDMY) AND (OR ACMK1 ANMK0 ANMK1 ANMK2))
 err1 = EXT (M2 COIN EDGE check_met) < 0.063 ABUT<90 OPPOSITE REGION NOT CONNECTED
 err1 NOT INSIDE SealR_NOT_BULK
}
 
AN_MOM_M_2_M3 {
@ MOM finger space
@ This rule is for performing same coloring to get better matching performance >= 0.063um
 // based on MOM.S.2 (finger line end space already >= 0.091)
 check_met = M3_convex_270_90_edges COIN EDGE ((M3 AND MOMDMY) AND (OR ACMK1 ANMK0 ANMK1 ANMK2))
 err1 = EXT (M3 COIN EDGE check_met) < 0.063 ABUT<90 OPPOSITE REGION NOT CONNECTED
 err1 NOT INSIDE SealR_NOT_BULK
}
 
AN_MOM_M_2_M4 {
@ MOM finger space
@ This rule is for performing same coloring to get better matching performance >= 0.063um
 // based on MOM.S.2 (finger line end space already >= 0.091)
 check_met = M4_convex_270_90_edges COIN EDGE ((M4 AND MOMDMY) AND (OR ACMK1 ANMK0 ANMK1 ANMK2))
 err1 = EXT (M4 COIN EDGE check_met) < 0.063 ABUT<90 OPPOSITE REGION NOT CONNECTED
 err1 NOT INSIDE SealR_NOT_BULK
}
 
AN_MOM_M_2_M5 {
@ MOM finger space
@ This rule is for performing same coloring to get better matching performance >= 0.063um
 // based on MOM.S.2 (finger line end space already >= 0.091)
 check_met = M5_convex_270_90_edges COIN EDGE ((M5 AND MOMDMY) AND (OR ACMK1 ANMK0 ANMK1 ANMK2))
 err1 = EXT (M5 COIN EDGE check_met) < 0.063 ABUT<90 OPPOSITE REGION NOT CONNECTED
 err1 NOT INSIDE SealR_NOT_BULK
}
 
AN_MOM_M_2_M6 {
@ MOM finger space
@ This rule is for performing same coloring to get better matching performance >= 0.063um
 // based on MOM.S.2 (finger line end space already >= 0.091)
 check_met = M6_convex_270_90_edges COIN EDGE ((M6 AND MOMDMY) AND (OR ACMK1 ANMK0 ANMK1 ANMK2))
 err1 = EXT (M6 COIN EDGE check_met) < 0.063 ABUT<90 OPPOSITE REGION NOT CONNECTED
 err1 NOT INSIDE SealR_NOT_BULK
}
 
AN_MOM_M_2_M7 {
@ MOM finger space
@ This rule is for performing same coloring to get better matching performance >= 0.063um
 // based on MOM.S.2 (finger line end space already >= 0.091)
 check_met = M7_convex_270_90_edges COIN EDGE ((M7 AND MOMDMY) AND (OR ACMK1 ANMK0 ANMK1 ANMK2))
 err1 = EXT (M7 COIN EDGE check_met) < 0.063 ABUT<90 OPPOSITE REGION NOT CONNECTED
 err1 NOT INSIDE SealR_NOT_BULK
}

AN_PG_N_9 {
@ Place high R resistor on a NW for better noise immunity
 err1 = (DIR_AND_RESP2 NOT NW) INTERACT (OR ACMK1 ANMK0 ANMK1 ANMK2)
 err1 NOT INSIDE SealR_NOT_BULK
}

// =======================================================
// Unique Pattern Design Rules for Logic Standard cells
// =======================================================

GROUP GSTD ?_TBS

#IFDEF STANDARD_CELL_UNIQUE_PATTERN_RULES NO
DRC UNSELECT CHECK GSTD
#ENDIF

// =======================================================
// AA: Active Area design rules
// =======================================================

GROUP GAA_STD AA_?_TBS

AA_STD = AA NOT OUTSIDE STDB_all
ALL_AA_STD = ALL_AA NOT OUTSIDE STDB_all

AA_STD_h_edges = AA_h_edges TOUCH EDGE AA_STD
AA_STD_v_edges = AA_v_edges TOUCH EDGE AA_STD
ALL_AA_STD_h_edges = ALL_AA_h_edges TOUCH EDGE ALL_AA_STD
ALL_AA_STD_v_edges = ALL_AA_v_edges TOUCH EDGE ALL_AA_STD

AA_W_1_9T_TBS {
@ AA width in GATE poly direction in 9T DDB/SDB design = 0.096/0.144/0.192um
 good_edges_1 = INT (AA_STD_h_edges) == 0.096 ABUT<90 OPPOSITE
 good_edges_2 = INT (good_edges_1) == 0.144 ABUT<90 OPPOSITE
 good_edges_3 = INT (good_edges_2) == 0.192 ABUT<90 OPPOSITE
 err1 = good_edges_3 NOT OUTSIDE EDGE PowerRail_Area_90T
 err1 NOT OUTSIDE EDGE STDB_all
}

AA_W_1_75T_TBS {
@ AA width in GATE poly direction in 7.5T DDB/SDB design = 0.096/0.144um
 good_edges_1 = INT (AA_STD_h_edges) == 0.096 ABUT<90 OPPOSITE
 good_edges_2 = INT (good_edges_1) == 0.144 ABUT<90 OPPOSITE
 err1 = good_edges_2 NOT OUTSIDE EDGE PowerRail_Area_75T
 err1 NOT OUTSIDE EDGE STDB_all
}

AA_S_1a_TBS {
@ Space between ALL_AA and PowerRail centerline = 0.048um
@ Excluding pick-up AA, or AA not interact (V0, M0G, M1)
 chk_AA = ((ALL_AA_STD NOT TAP_RAW) INTERACT (OR V0 M0G M1)) INTERACT PowerRail_Area
 err1 = EXT chk_AA PowerRail_centerline_002 < 0.048-PowerRail_grid OPPOSITE REGION
 err2 = chk_AA NOT WITH EDGE (EXT [chk_AA] PowerRail_centerline_002 == 0.048-PowerRail_grid OPPOSITE)
 err1 NOT OUTSIDE STDB_all
 err2 NOT OUTSIDE STDB_all
}

AA_S_1b_9T_TBS {
@ Space between pick-up AA and PowerRail centerline in 9T DDB design = 0.24/0.144um
 chk_AA = ((ALL_AA_STD AND TAP_RAW) INTERACT PowerRail_Area) INTERACT PowerRail_Area_90T
 err1 = EXT chk_AA PowerRail_centerline_002 < 0.144-PowerRail_grid OPPOSITE REGION
 err2 = EXT chk_AA PowerRail_centerline_002 > 0.144-PowerRail_grid < 0.240-PowerRail_grid OPPOSITE REGION
 err3 = chk_AA NOT WITH EDGE ((EXT [chk_AA] PowerRail_centerline_002 == 0.144-PowerRail_grid OPPOSITE) OR EDGE (EXT [chk_AA] PowerRail_centerline_002 == 0.240-PowerRail_grid OPPOSITE))
 err1 NOT OUTSIDE (DDBTBS_real AND STDB_all)
 err2 NOT OUTSIDE (DDBTBS_real AND STDB_all)
 err3 NOT OUTSIDE (DDBTBS_real AND STDB_all)
}

AA_S_1b_75T_TBS {
@ Space between pick-up AA and PowerRail centerline in 7.5T DDB design = 0.192um
 chk_AA = ((ALL_AA_STD AND TAP_RAW) INTERACT PowerRail_Area) INTERACT PowerRail_Area_75T
 err1 = EXT chk_AA PowerRail_centerline_002 < 0.192-PowerRail_grid OPPOSITE REGION
 err2 = chk_AA NOT WITH EDGE (EXT [chk_AA] PowerRail_centerline_002 == 0.192-PowerRail_grid OPPOSITE)
 err1 NOT OUTSIDE (DDBTBS_real AND STDB_all)
 err2 NOT OUTSIDE (DDBTBS_real AND STDB_all)
}

AA_S_1b_AR_TBS {
@ Space between pick-up AA and PowerRail centerline in SDB design = 0.144/0.192um
 chk_AA = ((ALL_AA_STD AND TAP_RAW) INTERACT PowerRail_Area) INTERACT SDBTBS_real
 err1 = EXT chk_AA PowerRail_centerline_002 < 0.144-PowerRail_grid OPPOSITE REGION
 err2 = EXT chk_AA PowerRail_centerline_002 > 0.144-PowerRail_grid < 0.192-PowerRail_grid OPPOSITE REGION
 err3 = chk_AA NOT WITH EDGE ((EXT [chk_AA] PowerRail_centerline_002 == 0.144-PowerRail_grid OPPOSITE) OR EDGE (EXT [chk_AA] PowerRail_centerline_002 == 0.192-PowerRail_grid OPPOSITE))
 err1 NOT OUTSIDE (SDBTBS_real AND STDB_all)
 err2 NOT OUTSIDE (SDBTBS_real AND STDB_all)
 err3 NOT OUTSIDE (SDBTBS_real AND STDB_all)
}

AA_S_2_TBS {
@ Space between ALL_AA in S/D direction in GT_P96 >= 0.096um
 err1_TMP = EXT ALL_AA_STD ALL_AA_v_edges < 0.096 ABUT<90 OPPOSITE REGION
 err1 = err1_TMP NOT OUTSIDE GT_P96
 err1 NOT OUTSIDE STDB_all
}

AA_R_1_TBS {
@ AA must be a rectangle orthogonal to grid or single L-, U-, or combined L/U- shape
 err1 = ANGLE AA_STD > 0 < 90
 err1 NOT OUTSIDE EDGE STDB_all
}


// =======================================================
// M0: Local interconnect layer 1 design rules
// Contact on AA
// =======================================================

GROUP GM0_STD M0_?_TBS

M0_PowerRail_STD = M0 NOT OUTSIDE STDB_all

M0_S_2a_TBS {
@ Space between the long side of M0 and GT (width = 0.016/0.018/0.02um), except GT_P96 region. = 0.017/0.016/0.015um
 chk_M0 = (M0_L_edges COIN EDGE M0_PowerRail_STD) NOT OUTSIDE EDGE PowerRail_Area
 good_1 = EXT [chk_M0] GT_016 == 0.017 ABUT<90 OPPOSITE
 good_2 = EXT [chk_M0] GT_018 == 0.016 ABUT<90 OPPOSITE
 good_3 = EXT [chk_M0] GT_020 == 0.015 ABUT<90 OPPOSITE
 bad_TMP = chk_M0 NOT COIN EDGE (OR EDGE (OR EDGE good_1 good_2) good_3)
 err1_TMP = EXT [bad_TMP] GT <= 0.08 ABUT<90 OPPOSITE
 err1 = err1_TMP NOT INSIDE EDGE GT_P96
 err1 NOT OUTSIDE EDGE STDB_all
}

M0_S_2b_TBS {
@ Space between the long side of M0 and GT (width = 0.016/0.018/0.02/0.024um), inside GT_P96 region. = 0.02/0.019/0.018/0.016um
 chk_M0 = (M0_L_edges COIN EDGE M0_PowerRail_STD) NOT OUTSIDE EDGE PowerRail_Area
 good_1 = EXT [chk_M0] GT_016 == 0.020 ABUT<90 OPPOSITE
 good_2 = EXT [chk_M0] GT_018 == 0.019 ABUT<90 OPPOSITE
 good_3 = EXT [chk_M0] GT_020 == 0.018 ABUT<90 OPPOSITE
 good_4 = EXT [chk_M0] GT_024 == 0.016 ABUT<90 OPPOSITE
 bad_TMP = chk_M0 NOT COIN EDGE (OR EDGE (OR EDGE good_1 good_2) (OR EDGE good_3 good_4))
 err1_TMP = EXT [bad_TMP] GT <= 0.08 ABUT<90 OPPOSITE
 err1 = err1_TMP NOT OUTSIDE EDGE GT_P96
 err1 NOT OUTSIDE EDGE STDB_all
}

M0_EX_2_9T_TBS {
@ M0 line-end (line-end not interact PowerRail) extension outside of PowerRail centerline in 9T DDB design = 0.137/0.161/0.165/0.185/0.233um
 CHK_AREA = DDBTBS_real AND PowerRail_Area_90T
 chk_M0_TMP = (M0_W_edges COIN EDGE M0_PowerRail_STD) OUTSIDE EDGE PowerRail_Area_BusLine
 chk_M0 = chk_M0_TMP COIN EDGE (M0_PowerRail_STD INTERACT PowerRail_Area)
 good_1 = ENC PowerRail_Area_BusLine [chk_M0] == 0.137-PowerRail_width_half ABUT<90 OPPOSITE
 good_2 = ENC PowerRail_Area_BusLine [chk_M0] == 0.161-PowerRail_width_half ABUT<90 OPPOSITE
 good_3 = ENC PowerRail_Area_BusLine [chk_M0] == 0.165-PowerRail_width_half ABUT<90 OPPOSITE
 good_4 = ENC PowerRail_Area_BusLine [chk_M0] == 0.185-PowerRail_width_half ABUT<90 OPPOSITE
 good_5 = ENC PowerRail_Area_BusLine [chk_M0] == 0.233-PowerRail_width_half ABUT<90 OPPOSITE
 err1 = chk_M0 NOT TOUCH EDGE (OR EDGE (OR EDGE good_1 good_2) (OR EDGE good_3 (OR EDGE good_4 good_5)))
 err1 NOT OUTSIDE EDGE CHK_AREA
}

M0_EX_2_75T_TBS {
@ M0 line-end (line-end not interact PowerRail) extension outside of PowerRail centerline in 7.5T DDB design = 0.137/0.161/0.167/0.185/0.188/0.191um
 CHK_AREA = DDBTBS_real AND PowerRail_Area_75T
 chk_M0_TMP = (M0_W_edges COIN EDGE M0_PowerRail_STD) OUTSIDE EDGE PowerRail_Area_BusLine
 chk_M0 = chk_M0_TMP COIN EDGE (M0_PowerRail_STD INTERACT PowerRail_Area)
 good_1 = ENC PowerRail_Area_BusLine [chk_M0] == 0.137-PowerRail_width_half ABUT<90 OPPOSITE
 good_2 = ENC PowerRail_Area_BusLine [chk_M0] == 0.161-PowerRail_width_half ABUT<90 OPPOSITE
 good_3 = ENC PowerRail_Area_BusLine [chk_M0] == 0.167-PowerRail_width_half ABUT<90 OPPOSITE
 good_4 = ENC PowerRail_Area_BusLine [chk_M0] == 0.185-PowerRail_width_half ABUT<90 OPPOSITE
 good_5 = ENC PowerRail_Area_BusLine [chk_M0] == 0.188-PowerRail_width_half ABUT<90 OPPOSITE
 good_6 = ENC PowerRail_Area_BusLine [chk_M0] == 0.191-PowerRail_width_half ABUT<90 OPPOSITE
 err1 = chk_M0 NOT TOUCH EDGE (OR EDGE ((OR EDGE good_1 good_2) OR EDGE (OR EDGE good_3 good_4)) (OR EDGE good_5 good_6))
 err1 NOT OUTSIDE EDGE CHK_AREA
}

M0_EX_2_AR_TBS {
@ M0 line-end (line-end not interact PowerRail) extension outside of PowerRail centerline in SDB design = 0.137/0.161/0.169/0.185/0.188/0.201/0.233um
 CHK_AREA = SDBTBS_real AND STDB_all
 chk_M0_TMP = (M0_W_edges COIN EDGE M0_PowerRail_STD) OUTSIDE EDGE PowerRail_Area_BusLine
 chk_M0 = chk_M0_TMP COIN EDGE (M0_PowerRail_STD INTERACT PowerRail_Area)
 good_1 = ENC PowerRail_Area_BusLine [chk_M0] == 0.137-PowerRail_width_half ABUT<90 OPPOSITE
 good_2 = ENC PowerRail_Area_BusLine [chk_M0] == 0.161-PowerRail_width_half ABUT<90 OPPOSITE
 good_3 = ENC PowerRail_Area_BusLine [chk_M0] == 0.169-PowerRail_width_half ABUT<90 OPPOSITE
 good_4 = ENC PowerRail_Area_BusLine [chk_M0] == 0.185-PowerRail_width_half ABUT<90 OPPOSITE
 good_5 = ENC PowerRail_Area_BusLine [chk_M0] == 0.188-PowerRail_width_half ABUT<90 OPPOSITE
 good_6 = ENC PowerRail_Area_BusLine [chk_M0] == 0.201-PowerRail_width_half ABUT<90 OPPOSITE
 good_7 = ENC PowerRail_Area_BusLine [chk_M0] == 0.233-PowerRail_width_half ABUT<90 OPPOSITE
 err1 = chk_M0 NOT TOUCH EDGE (OR EDGE ((OR EDGE good_1 good_2) OR EDGE (OR EDGE good_3 good_4)) (OR EDGE (OR EDGE good_5 good_6) good_7))
 err1 NOT OUTSIDE EDGE CHK_AREA
}

M0_EX_2a_TBS {
@ Extension of M0 short side (short side not interact M0C) outside of AA (horizontal edge extend -0.019um) in GATE poly direction >= 0.012um
 chk_AA = AA NOT (EXPAND EDGE AA_h_edges INSIDE BY 0.019)
 chk_M0 = M0_W_edges NOT INSIDE EDGE M0C
 err1 = ENC chk_AA [chk_M0] < 0.012 ABUT<90 OPPOSITE INSIDE ALSO
 err1 NOT OUTSIDE EDGE STDB_all
}

M0_EX_2b_TBS {
@ M0 short side (short side interact M0C) extension outside of AA (horizontal edge extend -0.019um) in GATE poly direction >= 0.009um
 chk_AA = AA NOT (EXPAND EDGE AA_h_edges INSIDE BY 0.019)
 chk_M0 = M0_W_edges INSIDE EDGE M0C
 err1 = ENC chk_AA [chk_M0] < 0.009 ABUT<90 OPPOSITE INSIDE ALSO
 err1 NOT OUTSIDE EDGE STDB_all
}


// =======================================================
// M0C: Local interconnect layer 2 design rules
// M0C is a drawn layer and used for M0 cut
// =======================================================

GROUP GM0C_STD M0C_?_TBS

M0C_PowerRail_STD = M0C NOT OUTSIDE STDB_all

M0C_W_1_TBS {
@ M0C width in GATE poly direction = 0.051um
 chk_M0C = ANGLE M0C_PowerRail_STD == 0
 err1 = INT (chk_M0C) == 0.051 ABUT<90 OPPOSITE
 err1 NOT OUTSIDE EDGE STDB_all
}

M0C_S_1_TBS {
@ Space between M0C and PowerRail centerline = 0.007um
//;based on M0C_R_1_TBS
 chk_M0C = (M0C_h_edges COIN EDGE M0C_PowerRail_STD) NOT OUTSIDE EDGE PowerRail_Area_BusLine
 err1 = INT chk_M0C PowerRail_Area_BusLine < PowerRail_width_half-0.007 ABUT<90 OPPOSITE REGION
 err2 = INT chk_M0C PowerRail_Area_BusLine > PowerRail_width_half-0.007 <= PowerRail_width_half ABUT<90 OPPOSITE REGION EXCLUDE SHIELDED
 err1 NOT OUTSIDE STDB_all
 err2 NOT OUTSIDE STDB_all
}

M0C_EX_1a_TBS {
@ M0C extension outside of AOP_M0 in S/D direction, except GT_P96 region = 0.025um
 AOP_M0_ext_1 = AOP_M0_W_edges INSIDE EDGE M0C_PowerRail_STD
 AOP_M0_ext_2 = ENC AOP_M0_ext_1 M0C_h_edges <= 0.051 ABUT<90 OPPOSITE REGION EXCLUDE SHIELDED
 AOP_M0_ext_3 = OR AOP_M0 AOP_M0_ext_2
 AOP_M0_ext = (M0C_PowerRail_STD NOT AOP_M0_ext_3) INTERACT AOP_M0_ext_3 == 1  //;based on P2.W.1.TBS
 AOP_M0_c = AOP_M0_v_edges COIN EDGE AOP_M0_ext
 err1 = (AOP_M0_ext WITH EDGE (ENC (AOP_M0_c) M0C_PowerRail_STD == 0.025 ABUT<90 OPPOSITE)) NOT INSIDE GT_P96
 err1 NOT OUTSIDE STDB_all
}

M0C_EX_1b_TBS {
@ M0C extension outside of AOP_M0 in S/D direction in GT_P96 region = 0.028um
 AOP_M0_ext_1 = AOP_M0_W_edges INSIDE EDGE M0C_PowerRail_STD
 AOP_M0_ext_2 = ENC AOP_M0_ext_1 M0C_h_edges <= 0.051 ABUT<90 OPPOSITE REGION EXCLUDE SHIELDED
 AOP_M0_ext_3 = OR AOP_M0 AOP_M0_ext_2
 AOP_M0_ext = (M0C_PowerRail_STD NOT AOP_M0_ext_3) INTERACT AOP_M0_ext_3 == 1  //;based on P2.W.1.TBS
 AOP_M0_c = AOP_M0_v_edges COIN EDGE AOP_M0_ext
 err1 = (AOP_M0_ext WITH EDGE (ENC (AOP_M0_c) M0C_PowerRail_STD == 0.028 ABUT<90 OPPOSITE)) NOT OUTSIDE GT_P96
 err1 NOT OUTSIDE STDB_all
}

M0C_O_1_TBS {
@ M0C overlap M0 in poly direction = 0.026/0.051um
 chk_M0C = M0C_h_edges COIN EDGE M0C_PowerRail_STD
 err1 = INT chk_M0C M0 < 0.026 ABUT<90 OPPOSITE REGION
 err2 = INT chk_M0C M0 > 0.026 < 0.051 ABUT<90 OPPOSITE REGION EXCLUDE SHIELDED  //;based on M0C_W_1_TBS
 err1 NOT OUTSIDE STDB_all
 err2 NOT OUTSIDE STDB_all
}

M0C_R_1_TBS {
@ M0C must interact with RSPMK1
 err1 = M0C_PowerRail_STD NOT INTERACT RSPMK1
 err1 NOT OUTSIDE STDB_all
}

M0C_R_2_TBS {
@ M0C must be a rectangle, other shapes like L, T, U-shape are not allowed
 err1 = M0C_PowerRail_STD NOT RECTANGLE ORTHOGONAL ONLY
 err1 NOT OUTSIDE STDB_all
}


// =======================================================
// M0G: Local interconnect layer 3 design rules
// =======================================================

GROUP GM0G_STD M0G_?_TBS

M0G_PowerRail_STD = M0G NOT OUTSIDE STDB_all
M0G_PowerRail_STD_h_edges = M0G_h_edges COIN EDGE M0G_PowerRail_STD
M0G_PowerRail_STD_v_edges = M0G_v_edges COIN EDGE M0G_PowerRail_STD

M0G_040_STD = M0G_040 NOT OUTSIDE STDB_all
M0G_050_STD = M0G_050 NOT OUTSIDE STDB_all
M0G_088_STD = M0G_088 NOT OUTSIDE STDB_all
M0G_090_STD = M0G_090 NOT OUTSIDE STDB_all

M0G_S_1_9T_TBS {
@ Space between M0G (width = 0.04um) line and PowerRail centerline in 9T DDB design = 0.066/0.076/0.172/0.220/0.268um
 chk_M0G = M0G_040_STD NOT OUTSIDE PowerRail_Area_90T
 good_066 = EXT [chk_M0G] PowerRail_centerline_002 == 0.066-PowerRail_grid ABUT<90 OPPOSITE
 good_076 = EXT [chk_M0G] PowerRail_centerline_002 == 0.076-PowerRail_grid ABUT<90 OPPOSITE
 good_172 = EXT [chk_M0G] PowerRail_centerline_002 == 0.172-PowerRail_grid ABUT<90 OPPOSITE
 good_220 = EXT [chk_M0G] PowerRail_centerline_002 == 0.220-PowerRail_grid ABUT<90 OPPOSITE
 good_268 = EXT [chk_M0G] PowerRail_centerline_002 == 0.268-PowerRail_grid ABUT<90 OPPOSITE
 err1 = chk_M0G NOT WITH EDGE (OR EDGE (OR EDGE (good_066 OR EDGE good_076) (good_172 OR EDGE good_220)) good_268)
 err1 NOT OUTSIDE (DDBTBS_real AND STDB_all)
}

M0G_S_1_75T_TBS {
@ Space between M0G (width = 0.04um) line and PowerRail centerline in 7.5T DDB design = 0.066/0.172/0.196/0.204/0.218/0.220um
 chk_M0G = M0G_040_STD NOT OUTSIDE PowerRail_Area_75T
 good_066 = EXT [chk_M0G] PowerRail_centerline_002 == 0.066-PowerRail_grid ABUT<90 OPPOSITE
 good_172 = EXT [chk_M0G] PowerRail_centerline_002 == 0.172-PowerRail_grid ABUT<90 OPPOSITE
 good_196 = EXT [chk_M0G] PowerRail_centerline_002 == 0.196-PowerRail_grid ABUT<90 OPPOSITE
 good_204 = EXT [chk_M0G] PowerRail_centerline_002 == 0.204-PowerRail_grid ABUT<90 OPPOSITE
 good_218 = EXT [chk_M0G] PowerRail_centerline_002 == 0.218-PowerRail_grid ABUT<90 OPPOSITE
 good_220 = EXT [chk_M0G] PowerRail_centerline_002 == 0.220-PowerRail_grid ABUT<90 OPPOSITE
 err1 = chk_M0G NOT WITH EDGE (OR EDGE (OR EDGE (good_066 OR EDGE good_172) (good_196 OR EDGE good_204)) (good_218 OR EDGE good_220))
 err1 NOT OUTSIDE (DDBTBS_real AND STDB_all)
}

M0G_S_1_AR_TBS {
@ Space between M0G (width = 0.04um) line and PowerRail centerline in SDB design. = 0.066/0.068/0.076/0.172/0.206/0.22/0.268um
 chk_M0G = M0G_040_STD NOT OUTSIDE (SDBTBS_real AND STDB_all)
 good_066 = EXT [chk_M0G] PowerRail_centerline_002 == 0.066-PowerRail_grid ABUT<90 OPPOSITE
 good_068 = EXT [chk_M0G] PowerRail_centerline_002 == 0.068-PowerRail_grid ABUT<90 OPPOSITE
 good_076 = EXT [chk_M0G] PowerRail_centerline_002 == 0.076-PowerRail_grid ABUT<90 OPPOSITE
 good_172 = EXT [chk_M0G] PowerRail_centerline_002 == 0.172-PowerRail_grid ABUT<90 OPPOSITE
 good_206 = EXT [chk_M0G] PowerRail_centerline_002 == 0.206-PowerRail_grid ABUT<90 OPPOSITE
 good_220 = EXT [chk_M0G] PowerRail_centerline_002 == 0.220-PowerRail_grid ABUT<90 OPPOSITE
 good_268 = EXT [chk_M0G] PowerRail_centerline_002 == 0.268-PowerRail_grid ABUT<90 OPPOSITE
 err1 = chk_M0G NOT WITH EDGE (OR EDGE (OR EDGE (good_066 OR EDGE good_068) (good_076 OR EDGE good_172)) (OR EDGE (good_206 OR EDGE good_220) good_268))
 err1 NOT OUTSIDE STDB_all
}

M0G_S_2_EX_1_9T_TBS {
@ M0G.S.2.9TBS: Space between M0G (width = 0.04um) line-end and GT centerline in 9T DDB design = 0.042um
@ M0G.EX.1.9TBS: M0G (width = 0.04um) line-end extension GT centerline in 9T DDB design = 0.008um
 CHK_AREA = DDBTBS_real AND STDB_all
 chk_M0G = LENGTH (M0G_040_STD NOT OUTSIDE PowerRail_Area_90T) == 0.04
 chk_GT = INT GT <= 0.024 OPPOSITE REGION CENTERLINE 0.0002
 good_ext = EXT [chk_M0G] chk_GT == 0.042-0.0001 ABUT<90 OPPOSITE MEASURE ALL
 good_enc = ENC chk_GT [chk_M0G] == 0.008-0.0001 ABUT<90 OPPOSITE MEASURE ALL

 err1 = chk_M0G NOT COIN EDGE (OR EDGE good_ext good_enc)
 err1 NOT OUTSIDE EDGE CHK_AREA
}

M0G_S_2_EX_1_75T_TBS {
@ M0G.S.2.7TBS: Space between M0G (width = 0.04um) line-end and GT centerline in 7.5T DDB design = 0.042/0.045um
@ M0G.EX.1.7TBS: M0G (width = 0.04um) line-end extension GT centerline in 7.5T DDB design = 0.006/0.032um
 CHK_AREA = DDBTBS_real AND STDB_all
 chk_M0G = LENGTH (M0G_040_STD NOT OUTSIDE PowerRail_Area_75T) == 0.04
 chk_GT = INT GT <= 0.024 OPPOSITE REGION CENTERLINE 0.0002
 good_ext_1 = EXT [chk_M0G] chk_GT == 0.042-0.0001 ABUT<90 OPPOSITE MEASURE ALL
 good_ext_2 = EXT [chk_M0G] chk_GT == 0.045-0.0001 ABUT<90 OPPOSITE MEASURE ALL
 good_enc_1 = ENC chk_GT [chk_M0G] == 0.006-0.0001 ABUT<90 OPPOSITE MEASURE ALL
 good_enc_2 = ENC chk_GT [chk_M0G] == 0.032-0.0001 ABUT<90 OPPOSITE MEASURE ALL

 err1 = chk_M0G NOT COIN EDGE (OR EDGE (OR EDGE good_ext_1 good_ext_2) (OR EDGE good_enc_1 good_enc_2))
 err1 NOT OUTSIDE EDGE CHK_AREA
}

M0G_S_2_EX_1_AR_TBS {
@ M0G.S.2.ARTBS: Space between M0G (width = 0.04um) line-end and GT centerline in SDB design = 0.039/0.042um
@ M0G.EX.1.ARTBS: M0G (width = 0.04um) line-end extension GT centerline in SDB design = 0.006/0.032/0.034um
 CHK_AREA = SDBTBS_real AND STDB_all
 chk_M0G = LENGTH M0G_040_STD == 0.04
 chk_GT = INT GT <= 0.024 OPPOSITE REGION CENTERLINE 0.0002
 good_ext_1 = EXT [chk_M0G] chk_GT == 0.039-0.0001 ABUT<90 OPPOSITE MEASURE ALL
 good_ext_2 = EXT [chk_M0G] chk_GT == 0.042-0.0001 ABUT<90 OPPOSITE MEASURE ALL
 good_enc_1 = ENC chk_GT [chk_M0G] == 0.006-0.0001 ABUT<90 OPPOSITE MEASURE ALL
 good_enc_2 = ENC chk_GT [chk_M0G] == 0.032-0.0001 ABUT<90 OPPOSITE MEASURE ALL
 good_enc_3 = ENC chk_GT [chk_M0G] == 0.034-0.0001 ABUT<90 OPPOSITE MEASURE ALL

 err1 = chk_M0G NOT COIN EDGE (OR EDGE (OR EDGE good_ext_1 good_ext_2) (OR EDGE (OR EDGE good_enc_1 good_enc_2) good_enc_3))
 err1 NOT OUTSIDE EDGE CHK_AREA
}

M0G_S_3_9T_TBS {
@ Space between M0G (width = 0.05um) and PowerRail centerline in 9T DDB design = 0.167/0.176/0.183/0.195/0.215/0.231/0.263um
 chk_M0G = ANGLE (M0G_050_STD NOT OUTSIDE PowerRail_Area_90T) == 0
 good_167 = EXT [chk_M0G] PowerRail_centerline_002 == 0.167-PowerRail_grid ABUT<90 OPPOSITE EXCLUDE SHIELDED
 good_176 = EXT [chk_M0G] PowerRail_centerline_002 == 0.176-PowerRail_grid ABUT<90 OPPOSITE EXCLUDE SHIELDED
 good_183 = EXT [chk_M0G] PowerRail_centerline_002 == 0.183-PowerRail_grid ABUT<90 OPPOSITE EXCLUDE SHIELDED
 good_195 = EXT [chk_M0G] PowerRail_centerline_002 == 0.195-PowerRail_grid ABUT<90 OPPOSITE EXCLUDE SHIELDED
 good_215 = EXT [chk_M0G] PowerRail_centerline_002 == 0.215-PowerRail_grid ABUT<90 OPPOSITE EXCLUDE SHIELDED
 good_231 = EXT [chk_M0G] PowerRail_centerline_002 == 0.231-PowerRail_grid ABUT<90 OPPOSITE EXCLUDE SHIELDED
 good_263 = EXT [chk_M0G] PowerRail_centerline_002 == 0.263-PowerRail_grid ABUT<90 OPPOSITE EXCLUDE SHIELDED
 err1 = (((((((M0G_050_STD NOT OUTSIDE PowerRail_Area_90T) NOT WITH EDGE good_167) NOT WITH EDGE good_176) NOT WITH EDGE good_183) NOT WITH EDGE good_195) NOT WITH EDGE good_215) NOT WITH EDGE good_231) NOT WITH EDGE good_263
 err1 NOT OUTSIDE (DDBTBS_real AND STDB_all)
}

M0G_S_3_75T_TBS {
@ Space between M0G (width = 0.05um) and PowerRail centerline in 7.5T DDB design = 0.170/0.191/0.199/0.215um
 chk_M0G = ANGLE (M0G_050_STD NOT OUTSIDE PowerRail_Area_75T) == 0
 good_170 = EXT [chk_M0G] PowerRail_centerline_002 == 0.170-PowerRail_grid ABUT<90 OPPOSITE EXCLUDE SHIELDED
 good_191 = EXT [chk_M0G] PowerRail_centerline_002 == 0.191-PowerRail_grid ABUT<90 OPPOSITE EXCLUDE SHIELDED
 good_199 = EXT [chk_M0G] PowerRail_centerline_002 == 0.199-PowerRail_grid ABUT<90 OPPOSITE EXCLUDE SHIELDED
 good_215 = EXT [chk_M0G] PowerRail_centerline_002 == 0.215-PowerRail_grid ABUT<90 OPPOSITE EXCLUDE SHIELDED
 err1 = ((((M0G_050_STD NOT OUTSIDE PowerRail_Area_75T) NOT WITH EDGE good_170) NOT WITH EDGE good_191) NOT WITH EDGE good_199) NOT WITH EDGE good_215
 err1 NOT OUTSIDE (DDBTBS_real AND STDB_all)
}

M0G_S_3_AR_TBS {
@ Space between M0G (width = 0.05um) and PowerRail centerline in SDB design. = 0.167/0.17/0.183/0.191/0.199/0.215/0.231/0.239/0.247/0.263um
 chk_M0G = ANGLE M0G_050_STD == 0
 good_167 = EXT [chk_M0G] PowerRail_centerline_002 == 0.167-PowerRail_grid ABUT<90 OPPOSITE EXCLUDE SHIELDED
 good_170 = EXT [chk_M0G] PowerRail_centerline_002 == 0.170-PowerRail_grid ABUT<90 OPPOSITE EXCLUDE SHIELDED
 good_183 = EXT [chk_M0G] PowerRail_centerline_002 == 0.183-PowerRail_grid ABUT<90 OPPOSITE EXCLUDE SHIELDED
 good_191 = EXT [chk_M0G] PowerRail_centerline_002 == 0.191-PowerRail_grid ABUT<90 OPPOSITE EXCLUDE SHIELDED
 good_199 = EXT [chk_M0G] PowerRail_centerline_002 == 0.199-PowerRail_grid ABUT<90 OPPOSITE EXCLUDE SHIELDED
 good_215 = EXT [chk_M0G] PowerRail_centerline_002 == 0.215-PowerRail_grid ABUT<90 OPPOSITE EXCLUDE SHIELDED
 good_231 = EXT [chk_M0G] PowerRail_centerline_002 == 0.231-PowerRail_grid ABUT<90 OPPOSITE EXCLUDE SHIELDED
 good_239 = EXT [chk_M0G] PowerRail_centerline_002 == 0.239-PowerRail_grid ABUT<90 OPPOSITE EXCLUDE SHIELDED
 good_247 = EXT [chk_M0G] PowerRail_centerline_002 == 0.247-PowerRail_grid ABUT<90 OPPOSITE EXCLUDE SHIELDED
 good_263 = EXT [chk_M0G] PowerRail_centerline_002 == 0.263-PowerRail_grid ABUT<90 OPPOSITE EXCLUDE SHIELDED
 err1 = ((((((((((M0G_050_STD NOT OUTSIDE (SDBTBS_real AND STDB_all)) NOT WITH EDGE good_167) NOT WITH EDGE good_170) NOT WITH EDGE good_183) NOT WITH EDGE good_191) NOT WITH EDGE good_199) NOT WITH EDGE good_215) NOT WITH EDGE good_231) NOT WITH EDGE good_239) NOT WITH EDGE good_247) NOT WITH EDGE good_263
 err1 NOT OUTSIDE (SDBTBS_real AND STDB_all)
}

M0G_S_4_TBS {
@ Space between M0G (width = 0.05um) centerline and GT centerline = 0/0.009/0.019um
 chk_M0G = INT (ANGLE M0G_050_STD == 90) <= 0.060 OPPOSITE REGION CENTERLINE 0.0002
 chk_GT = INT GT <= 0.024 OPPOSITE REGION CENTERLINE 0.0002
 err1 = EXT chk_M0G chk_GT < 0.009-0.0002 ABUT<90 OPPOSITE REGION MEASURE ALL
 err2 = EXT chk_M0G chk_GT > 0.009-0.0002 < 0.019-0.0002 ABUT<90 OPPOSITE REGION MEASURE ALL
 err3 = chk_M0G NOT WITH EDGE ((EXT [chk_M0G] chk_GT <= 0.019-0.0002 ABUT<90 OPPOSITE MEASURE ALL) OR EDGE (chk_M0G INSIDE EDGE chk_GT))
 err1 NOT OUTSIDE STDB_all
 err2 NOT OUTSIDE STDB_all
 err3 NOT OUTSIDE STDB_all
}

M0G_S_4_AR_TBS {
@ Space between M0G (width = 0.05um) centerline and GT centerline in SDB design. = 0/0.009/0.01/0.013/0.016/0.019um
 chk_M0G = INT (ANGLE M0G_050_STD == 90) <= 0.060 OPPOSITE REGION CENTERLINE 0.0002
 chk_GT = INT GT <= 0.024 OPPOSITE REGION CENTERLINE 0.0002
 err1 = EXT chk_M0G chk_GT < 0.009-0.0002 ABUT<90 OPPOSITE REGION MEASURE ALL
 err2 = EXT chk_M0G chk_GT > 0.010-0.0002 < 0.013-0.0002 ABUT<90 OPPOSITE REGION MEASURE ALL
 err3 = EXT chk_M0G chk_GT > 0.013-0.0002 < 0.016-0.0002 ABUT<90 OPPOSITE REGION MEASURE ALL
 err4 = EXT chk_M0G chk_GT > 0.016-0.0002 < 0.019-0.0002 ABUT<90 OPPOSITE REGION MEASURE ALL
 err5 = chk_M0G NOT WITH EDGE ((EXT [chk_M0G] chk_GT <= 0.019-0.0002 ABUT<90 OPPOSITE MEASURE ALL) OR EDGE (chk_M0G INSIDE EDGE chk_GT))
 err1 NOT OUTSIDE (SDBTBS_real AND STDB_all)
 err2 NOT OUTSIDE (SDBTBS_real AND STDB_all)
 err3 NOT OUTSIDE (SDBTBS_real AND STDB_all)
 err4 NOT OUTSIDE (SDBTBS_real AND STDB_all)
 err5 NOT OUTSIDE (SDBTBS_real AND STDB_all)
}

M0G_S_5_9T_TBS {
@ Space between M0G (width = 0.054/0.09um) and PowerRail centerline in 9T DDB design = 0.051um
 chk_M0G = ANGLE (M0G_090_STD NOT OUTSIDE PowerRail_Area_90T) == 0
 good_051 = EXT [chk_M0G] PowerRail_centerline_002 == 0.051-PowerRail_grid ABUT<90 OPPOSITE EXCLUDE SHIELDED
 err1 = (M0G_090_STD NOT OUTSIDE PowerRail_Area_90T) NOT WITH EDGE good_051
 err1 NOT OUTSIDE (DDBTBS_real AND STDB_all)
}

M0G_S_5_75T_TBS {
@ Space between M0G (width = 0.054/0.09um) and PowerRail centerline in 7.5T DDB design = 0.042um
 chk_M0G = ANGLE (M0G_090_STD NOT OUTSIDE PowerRail_Area_75T) == 0
 good_042 = EXT [chk_M0G] PowerRail_centerline_002 == 0.042-PowerRail_grid ABUT<90 OPPOSITE EXCLUDE SHIELDED
 err1 = (M0G_090_STD NOT OUTSIDE PowerRail_Area_75T) NOT WITH EDGE good_042
 err1 NOT OUTSIDE (DDBTBS_real AND STDB_all)
}

M0G_S_5_AR_TBS {
@ Space between M0G (width = 0.051/0.054/0.088um) and PowerRail centerline in SDB design. = 0.042/0.053um
 chk_M0G = ANGLE M0G_088_STD == 0
 good_042 = EXT [chk_M0G] PowerRail_centerline_002 == 0.042-PowerRail_grid ABUT<90 OPPOSITE EXCLUDE SHIELDED
 good_053 = EXT [chk_M0G] PowerRail_centerline_002 == 0.053-PowerRail_grid ABUT<90 OPPOSITE EXCLUDE SHIELDED
 err1 = ((M0G_088_STD NOT OUTSIDE (SDBTBS_real AND STDB_all)) NOT WITH EDGE good_042) NOT WITH EDGE good_053
 err1 NOT OUTSIDE (SDBTBS_real AND STDB_all)
}

M0G_O_1_TBS {
@ M0G (width = 0.088um) and (GT (width = 0.016/0.018/0.02/0.024um) NOT P2) overlap in S/D direction = 0.008/0.009/0.010/0.012um
 err1 = DFM COPY (DFM SPACE GT_0_016 M0G_088 < 0.008 BY INT HORIZONTAL) REGION
 err2 = DFM COPY (DFM SPACE GT_0_018 M0G_088 < 0.009 BY INT HORIZONTAL) REGION
 err3 = DFM COPY (DFM SPACE GT_0_020 M0G_088 < 0.010 BY INT HORIZONTAL) REGION
 err4 = DFM COPY (DFM SPACE GT_0_024 M0G_088 < 0.012 BY INT HORIZONTAL) REGION
 err5 = DFM COPY (DFM SPACE GT_0_016 M0G_088 > 0.008 <= 0.016 BY INT HORIZONTAL) REGION
 err6 = DFM COPY (DFM SPACE GT_0_018 M0G_088 > 0.009 <= 0.018 BY INT HORIZONTAL) REGION
 err7 = DFM COPY (DFM SPACE GT_0_020 M0G_088 > 0.010 <= 0.020 BY INT HORIZONTAL) REGION
 err8 = DFM COPY (DFM SPACE GT_0_024 M0G_088 > 0.012 <= 0.024 BY INT HORIZONTAL) REGION
 err1 NOT OUTSIDE STDB_all
 err2 NOT OUTSIDE STDB_all
 err3 NOT OUTSIDE STDB_all
 err4 NOT OUTSIDE STDB_all
 err5 NOT OUTSIDE STDB_all
 err6 NOT OUTSIDE STDB_all
 err7 NOT OUTSIDE STDB_all
 err8 NOT OUTSIDE STDB_all
}

M0G_S_7_TBS {
@ Space between the short side of AOP_M0G (width = 0.04um) when PRL > -0.02um. >= 0.078um
 err1 = EXT AOP_M0G_040_W_sides < 0.078 ABUT<90 OPPOSITE EXTENDED 0.02 REGION
 err1 NOT OUTSIDE STDB_all
}

M0G_S_9a_TBS {
@ Space between the center of M0G (width = 0.05um) when PRL = 0.05um inside DDB standard-cell >= 0.105um
 err1 = EXT M0G_050 < 0.105-0.05 ABUT<90 OPPOSITE REGION PROJ==0.05
 err1 NOT OUTSIDE (DDBTBS_real AND STDB_all)
}

M0G_S_9b_TBS {
@ Space between the center of M0G (width = 0.05um) when PRL = 0.05um inside SDB standard-cell >= 0.099um
 err1 = EXT M0G_050 < 0.099-0.05 ABUT<90 OPPOSITE REGION PROJ==0.05
 err1 NOT OUTSIDE (SDBTBS_real AND STDB_all)
}

M0G_S_10_TBS {
@ Space between the center of M0G (width = 0.05um) when PRL < 0.05um. >= 0.106um
 err1_corner = EXT m0g_050_center < 0.106-0.0002 ABUT<90 PROJ >= 0 <= 0.0001 REGION
 err1 = (EXT m0g_050_center < 0.106-0.0003 ABUT<90 CORNER TO CORNER REGION) OR err1_corner
 err1 NOT OUTSIDE STDB_all
}

M0G_S_11a_TBS {
@ Space between M0G and AOP_AA (Overlap is not allowed, except ((M0G AND AOP_AA) INTERACT M0)) (Except M0G.S.11b.TBS) >= 0.039um
 EDG_WAIVE_7b = ANGLE M0G_S_7a_7b_Chk == 0
 EDG_WAIVE_M0 = EXT [EDG_WAIVE_7b] AOP_AA >= 0.013 < 0.039 ABUT<90
 EDG_WAIVE_AA = EXT EDG_WAIVE_7b [AOP_AA] >= 0.013 < 0.039 ABUT<90
 EDG_CHECK = (M0G_S_7a_7b_Chk NOT COIN EDGE EDG_WAIVE_M0) NOT COIN EDGE M0G_in_AOP_AA_interact_M0
 err1 = EXT EDG_CHECK (AOP_AA NOT COIN EDGE EDG_WAIVE_AA) < 0.039 ABUT<90 REGION
 err1 NOT OUTSIDE STDB_all

 err2 = M0G_S_7a_7b_Chk AND AOP_AA
 err2 NOT OUTSIDE STDB_all
}

M0G_S_11b_TBS {
@ Space between M0G and AOP_AA in GATE poly direction (Overlap is not allowed, except ((M0G AND AOP_AA) INTERACT M0)) >= 0.019um
 err1 = EXT (ANGLE M0G_S_7a_7b_Chk == 0) AOP_AA < 0.019 ABUT>0<90 REGION
 err1 NOT OUTSIDE STDB_all

 err2 = (M0G_S_7a_7b_Chk COIN EDGE M0G) COIN EDGE AA_h_edges
 err2 NOT OUTSIDE EDGE STDB_all

 err3 = M0G_S_7a_7b_Chk AND AOP_AA
 err3 NOT OUTSIDE STDB_all

 err4 = M0G INTERACT AOP_AA SINGULAR ONLY
 err4 NOT OUTSIDE STDB_all
}

M0G_S_12a_TBS {
@ Space between M0G (width = 0.04um, not interact M0) to AOP_GT in GT_P96 region >= 0.031um
 err1_TMP = EXT (M0G_040 NOT INTERACT M0) AOP_GT < 0.031 ABUT<90 SINGULAR REGION
 err1 = err1_TMP NOT OUTSIDE GT_P96
 err1 NOT OUTSIDE STDB_all
}

M0G_S_13_TBS {
@ Space between M0G (width = 0.04um) and (M0 NOT M0C) in S/D direction (PRL > -0.016um) >= 0.028um
 err1 = EXT M0G_040 M0_NOT_M0C_v_edges < 0.028 ABUT<90 OPPOSITE EXTENDED 0.016 REGION
 err1 NOT OUTSIDE STDB_all
}

M0G_S_14a_TBS {
@ Space between M0G (width = 0.04um) and the short side of M0 (short side NOT INTERACT M0C) when PRL >= -0.018um in 7.5T design >= 0.032um
 err1_TMP = EXT M0G_040 (M0_W_edges OUTSIDE EDGE M0C) < 0.032 ABUT<90 OPPOSITE EXTENDED 0.018+GLOBAL_TOLERANCE REGION
 err1 = err1_TMP NOT OUTSIDE PowerRail_Area_75T
 err1 NOT OUTSIDE STDB_all
}

M0G_S_14b_TBS {
@ Space between M0G (width = 0.04um) and the short side of M0 (short side NOT INTERACT M0C) when PRL >= -0.018um in 9T design >= 0.035um
 err1_TMP = EXT M0G_040 (M0_W_edges OUTSIDE EDGE M0C) < 0.035 ABUT<90 OPPOSITE EXTENDED 0.018+GLOBAL_TOLERANCE REGION
 err1 = err1_TMP NOT OUTSIDE PowerRail_Area_90T
 err1 NOT OUTSIDE STDB_all
}

M0G_S_15_TBS {
@ Space between M0G (width = 0.05um) and the short side of M0 (short side NOT INTERACT M0C) when PRL >= -0.018um. >= 0.03um
 err1 = EXT M0G_050 (M0_W_edges OUTSIDE EDGE M0C) < 0.030 ABUT<90 OPPOSITE EXTENDED 0.018+GLOBAL_TOLERANCE REGION
 err1 NOT OUTSIDE STDB_all
}

// =======================================================
// Square Via-0 design rules
// =======================================================

GROUP GV0_STD V0_?_TBS

V0_STD = V0 NOT OUTSIDE STDB_all
V0N_STD = V0N AND V0_STD

V0i_STD = V0i NOT OUTSIDE STDB_all
V0iN_STD = (RECTANGLE V0i == 0.032 BY == 0.032 ORTHOGONAL ONLY) AND V0i_STD

V0iN_STD_M0 = V0iN_STD INTERACT M0
V0iN_STD_M0G = V0iN_STD INTERACT M0G

V0_S_1_9T_TBS {
@ Space between V0 (interact with M0) center-line and PowerRail center-line in 9T DDB design = 0.024/0.095/0.127/0.133/0.149/0.160/0.169/0.176/0.199/0.201um
 chk_V0_in_M0 = V0iN_STD_M0 INSIDE M0
 chk_V0 = ANGLE chk_V0_in_M0 == 0
 good_1 = EXT [chk_V0] PowerRail_centerline_002 == 0.024-0.016-PowerRail_grid ABUT<90 OPPOSITE
 good_2 = EXT [chk_V0] PowerRail_centerline_002 == 0.095-0.016-PowerRail_grid ABUT<90 OPPOSITE
 good_3 = EXT [chk_V0] PowerRail_centerline_002 == 0.127-0.016-PowerRail_grid ABUT<90 OPPOSITE
 good_4 = EXT [chk_V0] PowerRail_centerline_002 == 0.133-0.016-PowerRail_grid ABUT<90 OPPOSITE
 good_5 = EXT [chk_V0] PowerRail_centerline_002 == 0.149-0.016-PowerRail_grid ABUT<90 OPPOSITE
 good_6 = EXT [chk_V0] PowerRail_centerline_002 == 0.160-0.016-PowerRail_grid ABUT<90 OPPOSITE
 good_7 = EXT [chk_V0] PowerRail_centerline_002 == 0.169-0.016-PowerRail_grid ABUT<90 OPPOSITE
 good_8 = EXT [chk_V0] PowerRail_centerline_002 == 0.176-0.016-PowerRail_grid ABUT<90 OPPOSITE
 good_9 = EXT [chk_V0] PowerRail_centerline_002 == 0.199-0.016-PowerRail_grid ABUT<90 OPPOSITE
 good_0 = EXT [chk_V0] PowerRail_centerline_002 == 0.201-0.016-PowerRail_grid ABUT<90 OPPOSITE
 good_all = OR EDGE (OR EDGE (OR EDGE (OR EDGE good_1 good_2) (OR EDGE good_3 good_4)) (OR EDGE (OR EDGE good_5 good_6) (OR EDGE good_7 good_8))) (OR EDGE good_9 good_0)
 err1 = (chk_V0_in_M0 NOT WITH EDGE good_all) NOT OUTSIDE PowerRail_Area_90T
 err1 NOT OUTSIDE (DDBTBS_real AND STDB_all)
}

V0_S_1_75T_TBS {
@ Space between V0 (interact with M0) center-line and PowerRail center-line in 7.5T DDB design = 0.024/0.093/0.095/0.111/0.127/0.130/0.135/0.143/0.157/0.160um
 chk_V0_in_M0 = V0iN_STD_M0 INSIDE M0
 chk_V0 = ANGLE chk_V0_in_M0 == 0
 good_1 = EXT [chk_V0] PowerRail_centerline_002 == 0.024-0.016-PowerRail_grid ABUT<90 OPPOSITE
 good_2 = EXT [chk_V0] PowerRail_centerline_002 == 0.093-0.016-PowerRail_grid ABUT<90 OPPOSITE
 good_3 = EXT [chk_V0] PowerRail_centerline_002 == 0.095-0.016-PowerRail_grid ABUT<90 OPPOSITE
 good_4 = EXT [chk_V0] PowerRail_centerline_002 == 0.111-0.016-PowerRail_grid ABUT<90 OPPOSITE
 good_5 = EXT [chk_V0] PowerRail_centerline_002 == 0.127-0.016-PowerRail_grid ABUT<90 OPPOSITE
 good_6 = EXT [chk_V0] PowerRail_centerline_002 == 0.130-0.016-PowerRail_grid ABUT<90 OPPOSITE
 good_7 = EXT [chk_V0] PowerRail_centerline_002 == 0.135-0.016-PowerRail_grid ABUT<90 OPPOSITE
 good_8 = EXT [chk_V0] PowerRail_centerline_002 == 0.143-0.016-PowerRail_grid ABUT<90 OPPOSITE
 good_9 = EXT [chk_V0] PowerRail_centerline_002 == 0.157-0.016-PowerRail_grid ABUT<90 OPPOSITE
 good_0 = EXT [chk_V0] PowerRail_centerline_002 == 0.160-0.016-PowerRail_grid ABUT<90 OPPOSITE
 good_all = OR EDGE (OR EDGE (OR EDGE (OR EDGE good_1 good_2) (OR EDGE good_3 good_4)) (OR EDGE (OR EDGE good_5 good_6) (OR EDGE good_7 good_8))) (OR EDGE good_9 good_0)
 err1 = (chk_V0_in_M0 NOT WITH EDGE good_all) NOT OUTSIDE PowerRail_Area_75T
 err1 NOT OUTSIDE (DDBTBS_real AND STDB_all)
}

V0_S_1_AR_TBS {
@ Space between V0 (interact with M0) center-line and PowerRail center-line in SDB design = 0.024/0.093/0.095/0.096/0.102/0.109/0.111/0.125/0.127/0.128/0.133/0.137/0.143/0.15/0.151/0.157/0.160/0.162/0.166/0.169/0.176/0.182/0.185/0.197/0.199/0.201um
 chk_V0_in_M0 = V0iN_STD_M0 INSIDE M0
 chk_V0 = ANGLE chk_V0_in_M0 == 0
 good_1 = EXT [chk_V0] PowerRail_centerline_002 == 0.024-0.016-PowerRail_grid ABUT<90 OPPOSITE
 good_2 = EXT [chk_V0] PowerRail_centerline_002 == 0.093-0.016-PowerRail_grid ABUT<90 OPPOSITE
 good_3 = EXT [chk_V0] PowerRail_centerline_002 == 0.095-0.016-PowerRail_grid ABUT<90 OPPOSITE
 good_4 = EXT [chk_V0] PowerRail_centerline_002 == 0.096-0.016-PowerRail_grid ABUT<90 OPPOSITE
 good_5 = EXT [chk_V0] PowerRail_centerline_002 == 0.102-0.016-PowerRail_grid ABUT<90 OPPOSITE
 good_6 = EXT [chk_V0] PowerRail_centerline_002 == 0.109-0.016-PowerRail_grid ABUT<90 OPPOSITE
 good_7 = EXT [chk_V0] PowerRail_centerline_002 == 0.111-0.016-PowerRail_grid ABUT<90 OPPOSITE
 good_8 = EXT [chk_V0] PowerRail_centerline_002 == 0.125-0.016-PowerRail_grid ABUT<90 OPPOSITE
 good_9 = EXT [chk_V0] PowerRail_centerline_002 == 0.127-0.016-PowerRail_grid ABUT<90 OPPOSITE
 good_10 = EXT [chk_V0] PowerRail_centerline_002 == 0.128-0.016-PowerRail_grid ABUT<90 OPPOSITE
 good_11 = EXT [chk_V0] PowerRail_centerline_002 == 0.133-0.016-PowerRail_grid ABUT<90 OPPOSITE
 good_12 = EXT [chk_V0] PowerRail_centerline_002 == 0.137-0.016-PowerRail_grid ABUT<90 OPPOSITE
 good_13 = EXT [chk_V0] PowerRail_centerline_002 == 0.143-0.016-PowerRail_grid ABUT<90 OPPOSITE
 good_14 = EXT [chk_V0] PowerRail_centerline_002 == 0.150-0.016-PowerRail_grid ABUT<90 OPPOSITE
 good_15 = EXT [chk_V0] PowerRail_centerline_002 == 0.151-0.016-PowerRail_grid ABUT<90 OPPOSITE
 good_16 = EXT [chk_V0] PowerRail_centerline_002 == 0.157-0.016-PowerRail_grid ABUT<90 OPPOSITE
 good_17 = EXT [chk_V0] PowerRail_centerline_002 == 0.160-0.016-PowerRail_grid ABUT<90 OPPOSITE
 good_18 = EXT [chk_V0] PowerRail_centerline_002 == 0.162-0.016-PowerRail_grid ABUT<90 OPPOSITE
 good_19 = EXT [chk_V0] PowerRail_centerline_002 == 0.166-0.016-PowerRail_grid ABUT<90 OPPOSITE
 good_20 = EXT [chk_V0] PowerRail_centerline_002 == 0.169-0.016-PowerRail_grid ABUT<90 OPPOSITE
 good_21 = EXT [chk_V0] PowerRail_centerline_002 == 0.176-0.016-PowerRail_grid ABUT<90 OPPOSITE
 good_22 = EXT [chk_V0] PowerRail_centerline_002 == 0.182-0.016-PowerRail_grid ABUT<90 OPPOSITE
 good_23 = EXT [chk_V0] PowerRail_centerline_002 == 0.185-0.016-PowerRail_grid ABUT<90 OPPOSITE
 good_24 = EXT [chk_V0] PowerRail_centerline_002 == 0.197-0.016-PowerRail_grid ABUT<90 OPPOSITE
 good_25 = EXT [chk_V0] PowerRail_centerline_002 == 0.199-0.016-PowerRail_grid ABUT<90 OPPOSITE
 good_26 = EXT [chk_V0] PowerRail_centerline_002 == 0.201-0.016-PowerRail_grid ABUT<90 OPPOSITE
 good_all = OR EDGE (OR EDGE (OR EDGE (OR EDGE (OR EDGE (OR EDGE (OR EDGE (OR EDGE (OR EDGE (OR EDGE (OR EDGE (OR EDGE (OR EDGE (OR EDGE (OR EDGE (OR EDGE (OR EDGE (OR EDGE (OR EDGE (OR EDGE (OR EDGE (OR EDGE (OR EDGE (OR EDGE (OR EDGE good_1 good_2) good_3) good_4) good_5) good_6) good_7) good_8) good_9) good_10) good_11) good_12) good_13) good_14) good_15) good_16) good_17) good_18) good_19) good_20) good_21) good_22) good_23) good_24) good_25) good_26
 err1 = (chk_V0_in_M0 NOT WITH EDGE good_all) NOT OUTSIDE SDBTBS_real
 err1 NOT OUTSIDE STDB_all
}

V0_S_2_9T_TBS {
@ Space between V0 (interact with M0G) center-line and PowerRail center-line in 9T DDB design = 0.192/0.201/0.208/0.220/0.240/0.256/0.288um
 chk_V0_in_M0G = V0iN_STD_M0G INSIDE M0G
 chk_V0 = ANGLE chk_V0_in_M0G == 0
 good_1 = EXT [chk_V0] PowerRail_centerline_002 == 0.192-0.016-PowerRail_grid ABUT<90 OPPOSITE
 good_2 = EXT [chk_V0] PowerRail_centerline_002 == 0.201-0.016-PowerRail_grid ABUT<90 OPPOSITE
 good_3 = EXT [chk_V0] PowerRail_centerline_002 == 0.208-0.016-PowerRail_grid ABUT<90 OPPOSITE
 good_4 = EXT [chk_V0] PowerRail_centerline_002 == 0.220-0.016-PowerRail_grid ABUT<90 OPPOSITE
 good_5 = EXT [chk_V0] PowerRail_centerline_002 == 0.240-0.016-PowerRail_grid ABUT<90 OPPOSITE
 good_6 = EXT [chk_V0] PowerRail_centerline_002 == 0.256-0.016-PowerRail_grid ABUT<90 OPPOSITE
 good_7 = EXT [chk_V0] PowerRail_centerline_002 == 0.288-0.016-PowerRail_grid ABUT<90 OPPOSITE
 good_all = OR EDGE (OR EDGE (OR EDGE (OR EDGE good_1 good_2) (OR EDGE good_3 good_4)) (or edge good_5 good_6)) good_7
 err1 = (chk_V0_in_M0G NOT WITH EDGE good_all) NOT OUTSIDE PowerRail_Area_90T
 err1 NOT OUTSIDE (DDBTBS_real AND STDB_all)
}

V0_S_2_75T_TBS {
@ Space between V0 (interact with M0G) center-line and PowerRail center-line in 7.5T DDB design = 0.192/0.195/0.216/0.224/0.238/0.240um
 chk_V0_in_M0G = V0iN_STD_M0G INSIDE M0G
 chk_V0 = ANGLE chk_V0_in_M0G == 0
 good_1 = EXT [chk_V0] PowerRail_centerline_002 == 0.192-0.016-PowerRail_grid ABUT<90 OPPOSITE
 good_2 = EXT [chk_V0] PowerRail_centerline_002 == 0.195-0.016-PowerRail_grid ABUT<90 OPPOSITE
 good_3 = EXT [chk_V0] PowerRail_centerline_002 == 0.216-0.016-PowerRail_grid ABUT<90 OPPOSITE
 good_4 = EXT [chk_V0] PowerRail_centerline_002 == 0.224-0.016-PowerRail_grid ABUT<90 OPPOSITE
 good_5 = EXT [chk_V0] PowerRail_centerline_002 == 0.238-0.016-PowerRail_grid ABUT<90 OPPOSITE
 good_6 = EXT [chk_V0] PowerRail_centerline_002 == 0.240-0.016-PowerRail_grid ABUT<90 OPPOSITE
 good_all = OR EDGE (OR EDGE (OR EDGE good_1 good_2) (OR EDGE good_3 good_4)) (OR EDGE good_5 good_6)
 err1 = (chk_V0_in_M0G NOT WITH EDGE good_all) NOT OUTSIDE PowerRail_Area_75T
 err1 NOT OUTSIDE (DDBTBS_real AND STDB_all)
}

V0_S_2_AR_TBS {
@ Space between V0 (interact with M0G) center-line and PowerRail center-line in SDB design = 0.192/0.195/208/0.216/0.224/0.226/0.240/256/0.264/0.272/0.288um
 chk_V0_in_M0G = V0iN_STD_M0G INSIDE M0G
 chk_V0 = ANGLE chk_V0_in_M0G == 0
 good_1 = EXT [chk_V0] PowerRail_centerline_002 == 0.192-0.016-PowerRail_grid ABUT<90 OPPOSITE
 good_2 = EXT [chk_V0] PowerRail_centerline_002 == 0.195-0.016-PowerRail_grid ABUT<90 OPPOSITE
 good_3 = EXT [chk_V0] PowerRail_centerline_002 == 0.208-0.016-PowerRail_grid ABUT<90 OPPOSITE
 good_4 = EXT [chk_V0] PowerRail_centerline_002 == 0.216-0.016-PowerRail_grid ABUT<90 OPPOSITE
 good_5 = EXT [chk_V0] PowerRail_centerline_002 == 0.224-0.016-PowerRail_grid ABUT<90 OPPOSITE
 good_6 = EXT [chk_V0] PowerRail_centerline_002 == 0.226-0.016-PowerRail_grid ABUT<90 OPPOSITE
 good_7 = EXT [chk_V0] PowerRail_centerline_002 == 0.240-0.016-PowerRail_grid ABUT<90 OPPOSITE
 good_8 = EXT [chk_V0] PowerRail_centerline_002 == 0.256-0.016-PowerRail_grid ABUT<90 OPPOSITE
 good_9 = EXT [chk_V0] PowerRail_centerline_002 == 0.264-0.016-PowerRail_grid ABUT<90 OPPOSITE
 good_10 = EXT [chk_V0] PowerRail_centerline_002 == 0.272-0.016-PowerRail_grid ABUT<90 OPPOSITE
 good_11 = EXT [chk_V0] PowerRail_centerline_002 == 0.288-0.016-PowerRail_grid ABUT<90 OPPOSITE
 good_all = OR EDGE (OR EDGE (OR EDGE (OR EDGE (OR EDGE (OR EDGE (OR EDGE (OR EDGE good_1 good_2) (OR EDGE good_3 good_4)) (OR EDGE good_5 good_6)) good_7) good_8) good_9) good_10) good_11
 err1 = (chk_V0_in_M0G NOT WITH EDGE good_all) NOT OUTSIDE SDBTBS_real
 err1 NOT OUTSIDE STDB_all
}

V0_EN_1_9T_TBS {
@ V0 enclosure by M0G (width = 0.04um) with other two sides >= 0.004um in 9T DDB design = 0.012/0.018/0.029um
@ Exclude V0 totally enclosured by M0
@ DRC waive if enclosure >= 0.036um. = 0.012/0.018/0.029
 chk_V0N = ((V0iN_STD INTERACT M0G_040) NOT INSIDE M0_NOT_M0C) NOT OUTSIDE PowerRail_Area_90T
 err1 = ENC chk_V0N M0G_040 > 0.004 < 0.012 ABUT>0<90 OPPOSITE REGION
 err2 = ENC chk_V0N M0G_040 > 0.012 < 0.018 ABUT>0<90 OPPOSITE REGION
 err3 = ENC chk_V0N M0G_040 > 0.018 < 0.029 ABUT>0<90 OPPOSITE REGION
 err4 = ENC chk_V0N M0G_040 > 0.029 < 0.036 ABUT>0<90 OPPOSITE REGION
 err5 = ENC chk_V0N M0G_040_eq_040_edges < 0.012 ABUT>0<90 OPPOSITE REGION //;short side enclosure should be >= 0.012
 err1 NOT OUTSIDE (DDBTBS_real AND STDB_all)
 err2 NOT OUTSIDE (DDBTBS_real AND STDB_all)
 err3 NOT OUTSIDE (DDBTBS_real AND STDB_all)
 err4 NOT OUTSIDE (DDBTBS_real AND STDB_all)
 err5 NOT OUTSIDE (DDBTBS_real AND STDB_all)

 err6 = ENC chk_V0N M0G_040 < 0.004 ABUT<90 OPPOSITE REGION OUTSIDE ALSO  //;minimum requirement
 err6 NOT OUTSIDE (DDBTBS_real AND STDB_all)
}

V0_EN_1_75T_TBS {
@ V0 enclosure by M0G (width = 0.04um) with other two sides >= 0.004um in 7.5T DDB design = 0.016um
@ Exclude V0 totally enclosured by M0
@ DRC waive if enclosure >= 0.036um
 chk_V0N = ((V0iN_STD INTERACT M0G_040) NOT INSIDE M0_NOT_M0C) NOT OUTSIDE PowerRail_Area_75T
 err1 = ENC chk_V0N M0G_040 > 0.004 < 0.016 ABUT>0<90 OPPOSITE REGION
 err2 = ENC chk_V0N M0G_040 > 0.016 < 0.036 ABUT>0<90 OPPOSITE REGION
 err3 = ENC chk_V0N M0G_040_eq_040_edges < 0.016 ABUT>0<90 OPPOSITE REGION //;short side enclosure should be >= 0.016
 err1 NOT OUTSIDE (DDBTBS_real AND STDB_all)
 err2 NOT OUTSIDE (DDBTBS_real AND STDB_all)
 err3 NOT OUTSIDE (DDBTBS_real AND STDB_all)

 err4 = ENC chk_V0N M0G_040 < 0.004 ABUT<90 OPPOSITE REGION OUTSIDE ALSO  //;minimum requirement
 err4 NOT OUTSIDE (DDBTBS_real AND STDB_all)
}

V0_EN_1_AR_TBS {
@ V0 Enclosure by M0G (width = 0.04um) with other two sides >= 0.004um in SDB design = 0.016/0.035um
@ Exclude V0 totally enclosured by M0
@ DRC waive if enclosure >= 0.036um
 chk_V0N = ((V0iN_STD INTERACT M0G_040) NOT INSIDE M0_NOT_M0C) NOT OUTSIDE SDBTBS_real
 err1 = ENC chk_V0N M0G_040 > 0.004 < 0.016 ABUT>0<90 OPPOSITE REGION
 err2 = ENC chk_V0N M0G_040 > 0.016 < 0.035 ABUT>0<90 OPPOSITE REGION
 err3 = ENC chk_V0N M0G_040_eq_040_edges < 0.016 ABUT>0<90 OPPOSITE REGION //;short side enclosure should be >= 0.016
 err1 NOT OUTSIDE (SDBTBS_real AND STDB_all)
 err2 NOT OUTSIDE (SDBTBS_real AND STDB_all)
 err3 NOT OUTSIDE (SDBTBS_real AND STDB_all)

 err4 = ENC chk_V0N M0G_040 < 0.004 ABUT<90 OPPOSITE REGION OUTSIDE ALSO  //;minimum requirement
 err4 NOT OUTSIDE (SDBTBS_real AND STDB_all)
}

V0_EN_2a_2b_TBS {
@ V0.EN.2a.TBS: V0 enclosure by M0G (width = 0.05um) in gate poly direction >= 0.009um with other side >= 0.002um. >= 0.016um
@ V0.EN.2b.TBS: V0 enclosure by M0G (width = 0.05um) in four direction >= 0.009um
 err1 = ANGLE (ENC [V0iN_STD] M0G_050 < 0.009 ABUT<90 OPPOSITE) == 0
 err1 NOT OUTSIDE EDGE STDB_all

 err2 = RECTANGLE ENCLOSURE (V0iN_STD INTERACT M0G_050) M0G_050 ABUT<90 OUTSIDE ALSO
 GOOD 0.009 OPPOSITE 0.002 OPPOSITE 0.009 OPPOSITE 0.016 OPPOSITE
 GOOD 0.009 OPPOSITE 0.009 OPPOSITE 0.009 OPPOSITE 0.009 OPPOSITE
 err2 NOT OUTSIDE STDB_all
}

V0_EN_2c_AR_TBS {
@ V0 Enclosure by M0G (width = 0.05um) in Gate poly direction >= 0.009um with other side >= 0um in SDB design >= 0.018um
 err1 = ANGLE (ENC [V0iN_STD] M0G_050 < 0.009 ABUT<90 OPPOSITE) == 0
 err1 NOT OUTSIDE EDGE SDBTBS_real

 err2 = RECTANGLE ENCLOSURE (V0iN_STD INTERACT M0G_050) M0G_050 ABUT<90 OUTSIDE ALSO
 GOOD 0 0.009 OPPOSITE 0.009 OPPOSITE 0.018 OPPOSITE
 GOOD 0 0.009 OPPOSITE 0.018 OPPOSITE 0.009 OPPOSITE
 err2 NOT OUTSIDE SDBTBS_real
}

V0_EN_3_TBS {
@ V0 Enclosure by M1 (width = 0.032um) line-end with the other two sides >= 0um in DDB design
@ DRC waive if enclosure >= 0.048um. = 0.038/0.04
 chk_V0N = V0iN_STD NOT OUTSIDE (OR M1_STD_good_032 (INT M1_STD == 0.032 OPPOSITE REGION PARA ONLY))
 err1 = ENC chk_V0N M1_STD_032_end < 0.038 ABUT<90 OPPOSITE REGION
 err2 = ENC chk_V0N M1_STD_032_end > 0.038 < 0.040 ABUT<90 OPPOSITE REGION
 err3 = ENC chk_V0N M1_STD_032_end > 0.040 < 0.048 ABUT<90 OPPOSITE REGION
 err1 NOT OUTSIDE DDBTBS_real
 err2 NOT OUTSIDE DDBTBS_real
 err3 NOT OUTSIDE DDBTBS_real

 err5 = ENC chk_V0N M1 < 0.001 ABUT>0<90 SINGULAR REGION OUTSIDE ALSO  //;point touch
 err5 NOT OUTSIDE DDBTBS_real
}

V0_EN_3_AR_TBS {
@ V0 enclosure by M1 (width = 0.032um) line-end with the other two sides >= 0um in SDB design = 0.036/0.038/0.040um
@ DRC waive if enclosure >= 0.048um
 chk_V0N = V0iN_STD NOT OUTSIDE (OR M1_STD_good_032 (INT M1_STD == 0.032 OPPOSITE REGION PARA ONLY))
 err1 = ENC chk_V0N M1_STD_032_end < 0.036 ABUT<90 OPPOSITE REGION
 err2 = ENC chk_V0N M1_STD_032_end > 0.036 < 0.038 ABUT<90 OPPOSITE REGION
 err3 = ENC chk_V0N M1_STD_032_end > 0.038 < 0.040 ABUT<90 OPPOSITE REGION
 err4 = ENC chk_V0N M1_STD_032_end > 0.040 < 0.048 ABUT<90 OPPOSITE REGION
 err1 NOT OUTSIDE SDBTBS_real
 err2 NOT OUTSIDE SDBTBS_real
 err3 NOT OUTSIDE SDBTBS_real
 err4 NOT OUTSIDE SDBTBS_real

 err5 = ENC chk_V0N M1 < 0.001 ABUT>0<90 SINGULAR REGION OUTSIDE ALSO  //;point touch
 err5 NOT OUTSIDE SDBTBS_real
}

V0_EN_4_9T_TBS {
@ V0 enclosure by M1 (width = 0.034um) line-end with the other two sides >= 0.001um in 9T DDB design
@ DRC waive if enclosure >= 0.048um. = 0.038/0.040/0.041um
 chk_V0N = (V0iN_STD NOT OUTSIDE (OR M1_STD_good_034 (INT M1_STD == 0.034 OPPOSITE REGION PARA ONLY))) NOT OUTSIDE PowerRail_Area_90T
 err1 = ENC chk_V0N M1_STD_034_end < 0.038 ABUT<90 OPPOSITE REGION
 err2 = ENC chk_V0N M1_STD_034_end > 0.038 < 0.040 ABUT<90 OPPOSITE REGION
 err3 = ENC chk_V0N M1_STD_034_end > 0.040 < 0.041 ABUT<90 OPPOSITE REGION
 err4 = ENC chk_V0N M1_STD_034_end > 0.041 < 0.048 ABUT<90 OPPOSITE REGION
 err1 NOT OUTSIDE (DDBTBS_real AND STDB_all)
 err2 NOT OUTSIDE (DDBTBS_real AND STDB_all)
 err3 NOT OUTSIDE (DDBTBS_real AND STDB_all)
 err4 NOT OUTSIDE (DDBTBS_real AND STDB_all)

 err5 = ENC chk_V0N M1 < 0.001 ABUT<90 SINGULAR REGION OUTSIDE ALSO  //;minimum requirement
 err5 NOT OUTSIDE (DDBTBS_real AND STDB_all)
}

V0_EN_4_75T_TBS {
@ V0 enclosure by M1 (width = 0.034um) line-end with the other two sides >= 0.001um in 7.5T DDB design
@ DRC waive if enclosure >= 0.048um. = 0.038/0.040um
 chk_V0N = (V0iN_STD NOT OUTSIDE (OR M1_STD_good_034 (INT M1_STD == 0.034 OPPOSITE REGION PARA ONLY))) NOT OUTSIDE PowerRail_Area_75T
 err1 = ENC chk_V0N M1_STD_034_end < 0.038 ABUT<90 OPPOSITE REGION
 err2 = ENC chk_V0N M1_STD_034_end > 0.038 < 0.040 ABUT<90 OPPOSITE REGION
 err3 = ENC chk_V0N M1_STD_034_end > 0.040 < 0.048 ABUT<90 OPPOSITE REGION
 err1 NOT OUTSIDE (DDBTBS_real AND STDB_all)
 err2 NOT OUTSIDE (DDBTBS_real AND STDB_all)
 err3 NOT OUTSIDE (DDBTBS_real AND STDB_all)

 err5 = ENC chk_V0N M1 < 0.001 ABUT<90 SINGULAR REGION OUTSIDE ALSO  //;minimum requirement
 err5 NOT OUTSIDE (DDBTBS_real AND STDB_all)
}

V0_EN_4_AR_TBS {
@ V0 Enclosure by M1 (width = 0.034um) line-end with the other two sides >= 0.001um in SDB design = 0.038/0.040um
@ DRC waive if enclosure >= 0.048um
 chk_V0N = (V0iN_STD NOT OUTSIDE (OR M1_STD_good_034 (INT M1_STD == 0.034 OPPOSITE REGION PARA ONLY))) NOT OUTSIDE SDBTBS_real
 err1 = ENC chk_V0N M1_STD_034_end < 0.038 ABUT<90 OPPOSITE REGION
 err2 = ENC chk_V0N M1_STD_034_end > 0.038 < 0.040 ABUT<90 OPPOSITE REGION
 err3 = ENC chk_V0N M1_STD_034_end > 0.040 < 0.048 ABUT<90 OPPOSITE REGION
 err1 NOT OUTSIDE (SDBTBS_real AND STDB_all)
 err2 NOT OUTSIDE (SDBTBS_real AND STDB_all)
 err3 NOT OUTSIDE (SDBTBS_real AND STDB_all)

 err5 = ENC chk_V0N M1 < 0.001 ABUT<90 SINGULAR REGION OUTSIDE ALSO  //;minimum requirement
 err5 NOT OUTSIDE (SDBTBS_real AND STDB_all)
}

V0_EN_5_75T_TBS {
@ V0 enclosure by M1 (width = 0.035um) line-end with the other two sides = 0/0.003um in 7.5T DDB design = 0.038/0.040um
@ DRC waive if enclosure >= 0.048um
 chk_V0N = (V0iN_STD NOT OUTSIDE (OR M1_STD_good_035 (INT M1_STD == 0.035 OPPOSITE REGION PARA ONLY))) NOT OUTSIDE PowerRail_Area_75T
 err1 = ENC chk_V0N M1_STD_035_line < 0.003 ABUT>0<90 OPPOSITE REGION
 err2 = ENC chk_V0N M1_STD_035_end < 0.038 ABUT<90 OPPOSITE REGION
 err3 = ENC chk_V0N M1_STD_035_end > 0.038 < 0.040 ABUT<90 OPPOSITE REGION
 err4 = ENC chk_V0N M1_STD_035_end > 0.040 < 0.048 ABUT<90 OPPOSITE REGION
 err1 NOT OUTSIDE (DDBTBS_real AND STDB_all)
 err2 NOT OUTSIDE (DDBTBS_real AND STDB_all)
 err3 NOT OUTSIDE (DDBTBS_real AND STDB_all)
 err4 NOT OUTSIDE (DDBTBS_real AND STDB_all)

 err5 = ENC chk_V0N M1 < 0.003 ABUT>0<90 SINGULAR REGION OUTSIDE ALSO  //;minimum requirement
 err5 NOT OUTSIDE (DDBTBS_real AND STDB_all)
}

V0_EN_5_AR_TBS {
@ V0 Enclosure by M1 (width = 0.035um) line-end with the other two sides = 0/0.003um in SDB design = 0.038um
@ DRC waive if enclosure >= 0.048um
 chk_V0N = (V0iN_STD NOT OUTSIDE (OR M1_STD_good_035 (INT M1_STD == 0.035 OPPOSITE REGION PARA ONLY))) NOT OUTSIDE SDBTBS_real
 err1 = ENC chk_V0N M1_STD_035_line < 0.003 ABUT>0<90 OPPOSITE REGION
 err2 = ENC chk_V0N M1_STD_035_end < 0.038 ABUT<90 OPPOSITE REGION
 err3 = ENC chk_V0N M1_STD_035_end > 0.038 < 0.048 ABUT<90 OPPOSITE REGION
 err1 NOT OUTSIDE SDBTBS_real
 err2 NOT OUTSIDE SDBTBS_real
 err3 NOT OUTSIDE DDBTBS_real

 err5 = ENC chk_V0N M1 < 0.003 ABUT>0<90 SINGULAR REGION OUTSIDE ALSO  //;minimum requirement
 err5 NOT OUTSIDE SDBTBS_real
}

V0_EN_6_TBS {
@ V0 Enclosure by M1 (width = 0.046um) line-end with the other two sides = 0/0.003/0.007/0.011/0.014um in in DDB design
@ DRC waive if enclosure >= 0.048um. = 0.032
 chk_V0N = V0iN_STD NOT OUTSIDE (OR M1_STD_good_046 (INT M1_STD == 0.046 OPPOSITE REGION PARA ONLY))
 err1 = ENC chk_V0N M1_STD_046_line < 0.003 ABUT>0<90 OPPOSITE REGION
 err2 = ENC chk_V0N M1_STD_046_line > 0.003 < 0.007 ABUT>0<90 OPPOSITE REGION
 err3 = ENC chk_V0N M1_STD_046_line > 0.007 < 0.011 ABUT>0<90 OPPOSITE REGION
 err4 = ENC chk_V0N M1_STD_046_line > 0.011 < 0.014 ABUT>0<90 OPPOSITE REGION
 err5 = ENC chk_V0N M1_STD_046_end < 0.032 ABUT<90 OPPOSITE REGION
 err6 = ENC chk_V0N M1_STD_046_end > 0.032 < 0.048 ABUT<90 OPPOSITE REGION
 err1 NOT OUTSIDE DDBTBS_real
 err2 NOT OUTSIDE DDBTBS_real
 err3 NOT OUTSIDE DDBTBS_real
 err4 NOT OUTSIDE DDBTBS_real
 err5 NOT OUTSIDE DDBTBS_real
 err6 NOT OUTSIDE DDBTBS_real

 err7 = ENC chk_V0N M1 < 0.003 ABUT>0<90 SINGULAR REGION OUTSIDE ALSO  //;minimum requirement
 err7 NOT OUTSIDE DDBTBS_real
}

V0_EN_6_AR_TBS {
@ V0 Enclosure by M1 (width = 0.046um) line-end with the other two sides = 0/0.004/0.007/0.01/0.014um in SDB design = 0.032um
@ DRC waive if enclosure >= 0.048um
 chk_V0N = V0iN_STD NOT OUTSIDE (OR M1_STD_good_046 (INT M1_STD == 0.046 OPPOSITE REGION PARA ONLY))
 err1 = ENC chk_V0N M1_STD_046_line < 0.003 ABUT>0<90 OPPOSITE REGION
 err2 = ENC chk_V0N M1_STD_046_line > 0.003 < 0.007 ABUT>0<90 OPPOSITE REGION
 err3 = ENC chk_V0N M1_STD_046_end > 0.007 < 0.011 ABUT<90 OPPOSITE REGION
 err4 = ENC chk_V0N M1_STD_046_end > 0.011 < 0.014 ABUT<90 OPPOSITE REGION
 err5 = ENC chk_V0N M1_STD_046_end > 0.014 < 0.032 ABUT<90 OPPOSITE REGION
 err6 = ENC chk_V0N M1_STD_046_end > 0.032 < 0.048 ABUT<90 OPPOSITE REGION
 err1 NOT OUTSIDE SDBTBS_real
 err2 NOT OUTSIDE SDBTBS_real
 err3 NOT OUTSIDE SDBTBS_real
 err4 NOT OUTSIDE SDBTBS_real
 err5 NOT OUTSIDE SDBTBS_real
 err6 NOT OUTSIDE SDBTBS_real

 err7 = ENC chk_V0N M1 < 0.003 ABUT>0<90 SINGULAR REGION OUTSIDE ALSO  //;minimum requirement
 err7 NOT OUTSIDE SDBTBS_real
}

V0_EN_7_9T_TBS {
@ V0 enclosure by M1 (width = 0.05um) line-end with the other two sides >= 0.009um in 9T DDB design = 0.025/0.027/0.029/0.035um
@ DRC waive if enclosure >= 0.036um
 chk_V0N = (V0iN_STD NOT OUTSIDE (OR M1_STD_good_050 (INT M1_STD == 0.050 OPPOSITE REGION PARA ONLY))) NOT OUTSIDE PowerRail_Area_90T
 err1 = ENC chk_V0N M1_STD_050_end < 0.025 ABUT<90 OPPOSITE REGION
 err2 = ENC chk_V0N M1_STD_050_end > 0.025 < 0.027 ABUT<90 OPPOSITE REGION
 err3 = ENC chk_V0N M1_STD_050_end > 0.027 < 0.029 ABUT<90 OPPOSITE REGION
 err4 = ENC chk_V0N M1_STD_050_end > 0.029 < 0.035 ABUT<90 OPPOSITE REGION
 err5 = ENC chk_V0N M1_STD_050_end > 0.035 < 0.036 ABUT<90 OPPOSITE REGION
 err1 NOT OUTSIDE (DDBTBS_real AND STDB_all)
 err2 NOT OUTSIDE (DDBTBS_real AND STDB_all)
 err3 NOT OUTSIDE (DDBTBS_real AND STDB_all)
 err4 NOT OUTSIDE (DDBTBS_real AND STDB_all)
 err5 NOT OUTSIDE (DDBTBS_real AND STDB_all)

 err6 = ENC chk_V0N M1 < 0.009 ABUT<90 SINGULAR REGION OUTSIDE ALSO  //;for minimum requirement and corner enclosure
 err6 NOT OUTSIDE (DDBTBS_real AND STDB_all)
}

V0_EN_7_75T_TBS {
@ V0 enclosure by M1 (width = 0.05um) line-end with the other two sides = 0.006/0.009/0.012um in 7.5T DDB design = 0.025/0.028um
@ DRC waive if enclosure >= 0.036um
 chk_V0N = (V0iN_STD NOT OUTSIDE (OR M1_STD_good_050 (INT M1_STD == 0.050 OPPOSITE REGION PARA ONLY))) NOT OUTSIDE PowerRail_Area_75T
 err1 = ENC chk_V0N M1_STD_050_line < 0.006 ABUT<90 OPPOSITE REGION
 err2 = ENC chk_V0N M1_STD_050_line > 0.006 < 0.009 ABUT<90 OPPOSITE REGION
 err3 = ENC chk_V0N M1_STD_050_line > 0.009 < 0.012 ABUT<90 OPPOSITE REGION
 err4 = ENC chk_V0N M1_STD_050_end < 0.025 ABUT<90 OPPOSITE REGION
 err5 = ENC chk_V0N M1_STD_050_end > 0.025 < 0.028 ABUT<90 OPPOSITE REGION
 err6 = ENC chk_V0N M1_STD_050_end > 0.028 < 0.036 ABUT<90 OPPOSITE REGION
 err1 NOT OUTSIDE (DDBTBS_real AND STDB_all)
 err2 NOT OUTSIDE (DDBTBS_real AND STDB_all)
 err3 NOT OUTSIDE (DDBTBS_real AND STDB_all)
 err4 NOT OUTSIDE (DDBTBS_real AND STDB_all)
 err5 NOT OUTSIDE (DDBTBS_real AND STDB_all)
 err6 NOT OUTSIDE (DDBTBS_real AND STDB_all)

 err7 = ENC chk_V0N M1 < 0.006 ABUT<90 SINGULAR REGION OUTSIDE ALSO  //;for minimum requirement and corner enclosure
 err7 NOT OUTSIDE (DDBTBS_real AND STDB_all)
}

V0_EN_7_AR_TBS {
@ V0 enclosure by M1 (width = 0.050um) line-end with the other two sides >= 0.006um in SDB design = 0.025/0.028um
@ DRC waive if enclosure >= 0.036um
 chk_V0N = (V0iN_STD NOT OUTSIDE (OR M1_STD_good_050 (INT M1_STD == 0.050 OPPOSITE REGION PARA ONLY))) NOT OUTSIDE SDBTBS_real
 err1 = ENC chk_V0N M1_STD_050_end < 0.025 ABUT<90 OPPOSITE REGION
 err2 = ENC chk_V0N M1_STD_050_end > 0.025 < 0.028 ABUT<90 OPPOSITE REGION
 err3 = ENC chk_V0N M1_STD_050_end > 0.028 < 0.036 ABUT<90 OPPOSITE REGION
 err1 NOT OUTSIDE (SDBTBS_real AND STDB_all)
 err2 NOT OUTSIDE (SDBTBS_real AND STDB_all)
 err3 NOT OUTSIDE (SDBTBS_real AND STDB_all)

 err4 = ENC chk_V0N M1 < 0.006 ABUT<90 SINGULAR REGION OUTSIDE ALSO  //;for minimum requirement and corner enclosure
 err4 NOT OUTSIDE (SDBTBS_real AND STDB_all)
}

V0_EN_13_AR_TBS {
@ Enclosure by M1 (width = 0.058um) line-end with the other two sides >= 0.006um in SDB design = 0.025um
@ Drc waive if enclosure >= 0.036um
 chk_V0N = (V0iN_STD NOT OUTSIDE (OR M1_STD_good_058 (INT M1_STD == 0.058 OPPOSITE REGION PARA ONLY))) NOT OUTSIDE SDBTBS_real
 err1 = ENC chk_V0N M1_STD_058_end < 0.025 ABUT<90 OPPOSITE REGION
 err2 = ENC chk_V0N M1_STD_058_end > 0.025 < 0.036 ABUT<90 OPPOSITE REGION
 err1 NOT OUTSIDE (SDBTBS_real AND STDB_all)
 err2 NOT OUTSIDE (SDBTBS_real AND STDB_all)

 err3 = ENC chk_V0N M1 < 0.006 ABUT<90 SINGULAR REGION OUTSIDE ALSO  //;for minimum requirement and corner enclosure
 err3 NOT OUTSIDE (SDBTBS_real AND STDB_all)
}

V0_EN_8_9T_TBS {
@ V0 enclosure by M1 (width = 0.064um) in three direction in 9T DDB design = 0.016um
 CHK_AREA = DDBTBS_real AND STDB_all
 chk_V0N = (V0iN_STD NOT OUTSIDE (OR M1_STD_good_064 (INT M1_STD == 0.064 OPPOSITE REGION PARA ONLY))) NOT OUTSIDE PowerRail_Area_90T
 err1 = chk_V0N NOT (chk_V0N WITH EDGE (ENC [chk_V0N] M1 == 0.016 ABUT<90 OPPOSITE) == 3)
 err1 NOT OUTSIDE EDGE CHK_AREA

 err2 = ENC chk_V0N M1 < 0.016 ABUT<90 SINGULAR REGION OUTSIDE ALSO  //;for minimum requirement and corner enclosure
 err2 NOT OUTSIDE CHK_AREA
}

V0_EN_8_75T_TBS {
@ Enclosure by M1 (width = 0.064um) line-end with the other two sides >= 0.016um in 7.5T DDB design = 0.016/0.017/0.025um
@ DRC waive if enclosure >= 0.036um
 chk_V0N = (V0iN_STD NOT OUTSIDE (OR M1_STD_good_064 (INT M1_STD == 0.064 OPPOSITE REGION PARA ONLY))) NOT OUTSIDE PowerRail_Area_75T
 err1 = ENC chk_V0N M1_STD_064_end > 0.016 < 0.017 ABUT<90 OPPOSITE REGION
 err2 = ENC chk_V0N M1_STD_064_end > 0.017 < 0.025 ABUT<90 OPPOSITE REGION
 err3 = ENC chk_V0N M1_STD_064_end > 0.025 < 0.036 ABUT<90 OPPOSITE REGION
 err1 NOT OUTSIDE (DDBTBS_real AND STDB_all)
 err2 NOT OUTSIDE (DDBTBS_real AND STDB_all)
 err3 NOT OUTSIDE (DDBTBS_real AND STDB_all)

 err4 = ENC chk_V0N M1 < 0.016 ABUT<90 SINGULAR REGION OUTSIDE ALSO  //;for minimum requirement and corner enclosure
 err4 NOT OUTSIDE (DDBTBS_real AND STDB_all)
}

V0_EN_8_AR_TBS {
@ Enclosure by M1 (width = 0.064um) line-end with the other two sides >= 0.016um in SDB design = 0.016/0.017um
@ DRC waive if enclosure >= 0.025um
 chk_V0N = (V0iN_STD NOT OUTSIDE (OR M1_STD_good_064 (INT M1_STD == 0.064 OPPOSITE REGION PARA ONLY))) NOT OUTSIDE SDBTBS_real
 err1 = ENC chk_V0N M1_STD_064_end > 0.016 < 0.017 ABUT<90 OPPOSITE REGION
 err2 = ENC chk_V0N M1_STD_064_end > 0.017 < 0.025 ABUT<90 OPPOSITE REGION
 err1 NOT OUTSIDE (SDBTBS_real AND STDB_all)
 err2 NOT OUTSIDE (SDBTBS_real AND STDB_all)

 err3 = ENC chk_V0N M1 < 0.016 ABUT<90 SINGULAR REGION OUTSIDE ALSO  //;for minimum requirement and corner enclosure
 err3 NOT OUTSIDE (SDBTBS_real AND STDB_all)
}

V0_EN_9_75T_TBS {
@ Enclosure by M1 (width = 0.066um) line-end with the other two sides >= 0.017um in 7.5T DDB design = 0.016um
@ DRC waive if enclosure >= 0.036um
 chk_V0N = (V0iN_STD NOT OUTSIDE (OR M1_STD_good_066 (INT M1_STD == 0.066 OPPOSITE REGION PARA ONLY))) NOT OUTSIDE PowerRail_Area_75T
 err1 = ENC chk_V0N M1_STD_066_end < 0.016 ABUT<90 OPPOSITE REGION
 err2 = ENC chk_V0N M1_STD_066_end > 0.016 < 0.036 ABUT<90 OPPOSITE REGION
 err3 = RECTANGLE ENCLOSURE chk_V0N M1 ABUT<90 SINGULAR OUTSIDE ALSO GOOD 0.016 0.017 OPPOSITE 0.016 0.017 OPPOSITE
 err1 NOT OUTSIDE (DDBTBS_real AND STDB_all)
 err2 NOT OUTSIDE (DDBTBS_real AND STDB_all)
 err3 NOT OUTSIDE (DDBTBS_real AND STDB_all)
}

V0_EN_9_AR_TBS {
@ Enclosure by M1 (width = 0.066um) line-end with the other two sides >= 0.017um in SDB design = 0.016um
@ DRC waive if enclosure >= 0.025um
 chk_V0N = (V0iN_STD NOT OUTSIDE (OR M1_STD_good_066 (INT M1_STD == 0.066 OPPOSITE REGION PARA ONLY))) NOT OUTSIDE SDBTBS_real
 err1 = ENC chk_V0N M1_STD_066_end < 0.016 ABUT<90 OPPOSITE REGION
 err2 = ENC chk_V0N M1_STD_066_end > 0.016 < 0.025 ABUT<90 OPPOSITE REGION
 err3 = RECTANGLE ENCLOSURE chk_V0N M1 ABUT<90 SINGULAR OUTSIDE ALSO GOOD 0.016 0.017 OPPOSITE 0.016 0.017 OPPOSITE
 err1 NOT OUTSIDE (SDBTBS_real AND STDB_all)
 err2 NOT OUTSIDE (SDBTBS_real AND STDB_all)
 err3 NOT OUTSIDE (SDBTBS_real AND STDB_all)
}

V0_EN_10_75T_TBS {
@ Enclosure by M1 (width = 0.076um) line-end with the other two sides >= 0.009um in 7.5T DDB design = 0.025um
@ DRC waive if enclosure >= 0.036um
 chk_V0N = (V0iN_STD NOT OUTSIDE (OR M1_STD_good_076 (INT M1_STD == 0.076 OPPOSITE REGION PARA ONLY))) NOT OUTSIDE PowerRail_Area_75T
 err1 = ENC chk_V0N M1_STD_076_end < 0.025 ABUT<90 OPPOSITE REGION
 err2 = ENC chk_V0N M1_STD_076_end > 0.025 < 0.036 ABUT<90 OPPOSITE REGION
 err3 = RECTANGLE ENCLOSURE chk_V0N M1 ABUT<90 SINGULAR OUTSIDE ALSO GOOD 0.009 0.025 OPPOSITE 0.009 0.025 OPPOSITE
 err1 NOT OUTSIDE (DDBTBS_real AND STDB_all)
 err2 NOT OUTSIDE (DDBTBS_real AND STDB_all)
 err3 NOT OUTSIDE (DDBTBS_real AND STDB_all)
}

V0_EN_10_AR_TBS {
@ Enclosure by M1 (width = 0.076um) line-end with the other two sides >= 0.009um in SDB design = 0.025um
@ DRC waive if enclosure >= 0.036um
 chk_V0N = (V0iN_STD NOT OUTSIDE (OR M1_STD_good_076 (INT M1_STD == 0.076 OPPOSITE REGION PARA ONLY))) NOT OUTSIDE SDBTBS_real
 err1 = ENC chk_V0N M1_STD_076_end < 0.025 ABUT<90 OPPOSITE REGION
 err2 = ENC chk_V0N M1_STD_076_end > 0.025 < 0.036 ABUT<90 OPPOSITE REGION
 err3 = RECTANGLE ENCLOSURE chk_V0N M1 ABUT<90 SINGULAR OUTSIDE ALSO GOOD 0.009 0.025 OPPOSITE 0.009 0.025 OPPOSITE
 err1 NOT OUTSIDE (SDBTBS_real AND STDB_all)
 err2 NOT OUTSIDE (SDBTBS_real AND STDB_all)
 err3 NOT OUTSIDE (SDBTBS_real AND STDB_all)
}

V0_EN_11_AR_TBS {
@ Enclosure by M1 (width = 0.082um) line-end with the other two sides = 0.009/0.016/0.024/0.025um in SDB design = 0.012/0.016/0.025um
@ DRC waive if enclosure >= 0.036um
@ Enclosure = (0.009, 0.012)/(0.009, 0.016)/(0.012, 0.016) by two neighbor sides is not allowed
 chk_V0N = (V0iN_STD NOT OUTSIDE (OR M1_STD_good_082 (INT M1_STD == 0.082 OPPOSITE REGION PARA ONLY))) NOT OUTSIDE SDBTBS_real
 lside_enc_a = chk_V0N TOUCH EDGE (ENC [chk_V0N] M1_STD_082_line == 0.025 ABUT<90 OPPOSITE)
 lside_enc_b = chk_V0N TOUCH EDGE (ENC [chk_V0N] M1_STD_082_line == 0.016 ABUT<90 OPPOSITE)
 lside_enc_c = chk_V0N TOUCH EDGE (ENC [chk_V0N] M1_STD_082_line == 0.034 ABUT<90 OPPOSITE)
 lside_enc_d = chk_V0N TOUCH EDGE (ENC [chk_V0N] M1_STD_082_line == 0.024 ABUT<90 OPPOSITE)
 lside_enc_e = chk_V0N TOUCH EDGE (ENC [chk_V0N] M1_STD_082_line == 0.026 ABUT<90 OPPOSITE)
 lside_enc_f = chk_V0N TOUCH EDGE (ENC [chk_V0N] M1_STD_082_line == 0.009 ABUT<90 OPPOSITE)
 lside_enc_g = chk_V0N TOUCH EDGE (ENC [chk_V0N] M1_STD_082_line == 0.041 ABUT<90 OPPOSITE)
 lside_enc_good = OR EDGE (OR EDGE (OR EDGE lside_enc_a lside_enc_b) (OR EDGE lside_enc_c lside_enc_d)) (OR EDGE (OR EDGE lside_enc_e lside_enc_f) lside_enc_g)
 lside_enc_good_via = OR (INT lside_enc_a == 0.032 OPPOSITE REGION) (INT lside_enc_b lside_enc_c == 0.032 OPPOSITE REGION) (INT lside_enc_d lside_enc_e == 0.032 OPPOSITE REGION) (INT lside_enc_f lside_enc_g == 0.032 OPPOSITE REGION)
 err1 = chk_V0N NOT lside_enc_good_via
 err1 NOT OUTSIDE (SDBTBS_real AND STDB_all)

 err2 = ENC (chk_V0N NOT TOUCH EDGE lside_enc_good) M1_STD_082_end < 0.012 ABUT<90 OPPOSITE REGION
 err3 = ENC (chk_V0N NOT TOUCH EDGE lside_enc_good) M1_STD_082_end > 0.012 < 0.016 ABUT<90 OPPOSITE REGION
 err4 = ENC (chk_V0N NOT TOUCH EDGE lside_enc_good) M1_STD_082_end > 0.016 < 0.025 ABUT<90 OPPOSITE REGION
 err5 = ENC (chk_V0N NOT TOUCH EDGE lside_enc_good) M1_STD_082_end > 0.025 < 0.036 ABUT<90 OPPOSITE REGION
 err6 = OR (INT (ENC [chk_V0N] M1 == 0.009 ABUT<90 SINGULAR OPPOSITE) (ENC [chk_V0N] M1 == 0.012 ABUT<90 SINGULAR OPPOSITE) < 0.005 ABUT==90 INTERSECTING ONLY REGION)
        (INT (ENC [chk_V0N] M1 == 0.009 ABUT<90 SINGULAR OPPOSITE) (ENC [chk_V0N] M1 == 0.016 ABUT<90 SINGULAR OPPOSITE) < 0.005 ABUT==90 INTERSECTING ONLY REGION)
        (INT (ENC [chk_V0N] M1 == 0.012 ABUT<90 SINGULAR OPPOSITE) (ENC [chk_V0N] M1 == 0.016 ABUT<90 SINGULAR OPPOSITE) < 0.005 ABUT==90 INTERSECTING ONLY REGION)

 err2 NOT OUTSIDE (SDBTBS_real AND STDB_all)
 err3 NOT OUTSIDE (SDBTBS_real AND STDB_all)
 err4 NOT OUTSIDE (SDBTBS_real AND STDB_all)
 err5 NOT OUTSIDE (SDBTBS_real AND STDB_all)
 err6 NOT OUTSIDE (SDBTBS_real AND STDB_all)
}

V0_EN_11_9T_TBS {
@ Enclosure by M1 (width = 0.082um) line-end with the other two sides = 0.016/0.025/0.034um in 9T DDB design = 0.009/0.016/0.025/0.032um
@ Enclosure = (0.009, 0.016) by two neighbor sides is not allowed
@ DRC waive if enclosure >= 0.036um
 chk_V0N = (V0iN_STD NOT OUTSIDE (OR M1_STD_good_082 (INT M1_STD == 0.082 OPPOSITE REGION PARA ONLY))) NOT OUTSIDE PowerRail_Area_90T
 lside_enc_a = chk_V0N TOUCH EDGE (ENC [chk_V0N] M1_STD_082_line == 0.025 ABUT<90 OPPOSITE)
 lside_enc_b = chk_V0N TOUCH EDGE (ENC [chk_V0N] M1_STD_082_line == 0.016 ABUT<90 OPPOSITE)
 lside_enc_c = chk_V0N TOUCH EDGE (ENC [chk_V0N] M1_STD_082_line == 0.034 ABUT<90 OPPOSITE)
 lside_enc_good = OR EDGE lside_enc_a (OR EDGE lside_enc_b lside_enc_c)
 lside_enc_good_via = (INT lside_enc_a == 0.032 OPPOSITE REGION) OR (INT lside_enc_b lside_enc_c == 0.032 OPPOSITE REGION)
 err1 = chk_V0N NOT lside_enc_good_via
 err1 NOT OUTSIDE (DDBTBS_real AND STDB_all)

 err2 = ENC (chk_V0N NOT TOUCH EDGE lside_enc_good) M1_STD_082_end < 0.009 ABUT<90 OPPOSITE REGION
 err3 = ENC (chk_V0N NOT TOUCH EDGE lside_enc_good) M1_STD_082_end > 0.009 < 0.016 ABUT<90 OPPOSITE REGION
 err4 = ENC (chk_V0N NOT TOUCH EDGE lside_enc_good) M1_STD_082_end > 0.016 < 0.025 ABUT<90 OPPOSITE REGION
 err5 = ENC (chk_V0N NOT TOUCH EDGE lside_enc_good) M1_STD_082_end > 0.025 < 0.032 ABUT<90 OPPOSITE REGION
 err6 = ENC (chk_V0N NOT TOUCH EDGE lside_enc_good) M1_STD_082_end > 0.032 < 0.036 ABUT<90 OPPOSITE REGION
 err7 = INT (ENC [chk_V0N] M1 == 0.009 ABUT<90 SINGULAR OPPOSITE) (ENC [chk_V0N] M1 == 0.016 ABUT<90 SINGULAR OPPOSITE) < 0.005 ABUT==90 INTERSECTING ONLY REGION

 err2 NOT OUTSIDE (DDBTBS_real AND STDB_all)
 err3 NOT OUTSIDE (DDBTBS_real AND STDB_all)
 err4 NOT OUTSIDE (DDBTBS_real AND STDB_all)
 err5 NOT OUTSIDE (DDBTBS_real AND STDB_all)
 err6 NOT OUTSIDE (DDBTBS_real AND STDB_all)
 err7 NOT OUTSIDE (DDBTBS_real AND STDB_all)
}

V0_EN_11_75T_TBS {
@ Enclosure by M1 (width = 0.082um) line-end with the other two sides = 0.016/0.025/0.034um in 7.5T DDB design = 0.016/0.018/0.024/0.025/0.029/0.032/0.035um
@ DRC waive if enclosure >= 0.036um
 chk_V0N = (V0iN_STD NOT OUTSIDE (OR M1_STD_good_082 (INT M1_STD == 0.082 OPPOSITE REGION PARA ONLY))) NOT OUTSIDE PowerRail_Area_75T
 lside_enc_a = chk_V0N TOUCH EDGE (ENC [chk_V0N] M1_STD_082_line == 0.025 ABUT<90 OPPOSITE)
 lside_enc_b = chk_V0N TOUCH EDGE (ENC [chk_V0N] M1_STD_082_line == 0.016 ABUT<90 OPPOSITE)
 lside_enc_c = chk_V0N TOUCH EDGE (ENC [chk_V0N] M1_STD_082_line == 0.034 ABUT<90 OPPOSITE)
 lside_enc_good = OR EDGE lside_enc_a (OR EDGE lside_enc_b lside_enc_c)
 lside_enc_good_via = (INT lside_enc_a == 0.032 OPPOSITE REGION) OR (INT lside_enc_b lside_enc_c == 0.032 OPPOSITE REGION)
 err1 = chk_V0N NOT lside_enc_good_via
 err1 NOT OUTSIDE (DDBTBS_real AND STDB_all)

 err2 = ENC (chk_V0N NOT TOUCH EDGE lside_enc_good) M1_STD_082_end < 0.016 ABUT<90 OPPOSITE REGION
 err3 = ENC (chk_V0N NOT TOUCH EDGE lside_enc_good) M1_STD_082_end > 0.016 < 0.018 ABUT<90 OPPOSITE REGION
 err4 = ENC (chk_V0N NOT TOUCH EDGE lside_enc_good) M1_STD_082_end > 0.018 < 0.024 ABUT<90 OPPOSITE REGION
 err5 = ENC (chk_V0N NOT TOUCH EDGE lside_enc_good) M1_STD_082_end > 0.024 < 0.025 ABUT<90 OPPOSITE REGION
 err6 = ENC (chk_V0N NOT TOUCH EDGE lside_enc_good) M1_STD_082_end > 0.025 < 0.029 ABUT<90 OPPOSITE REGION
 err7 = ENC (chk_V0N NOT TOUCH EDGE lside_enc_good) M1_STD_082_end > 0.029 < 0.032 ABUT<90 OPPOSITE REGION
 err8 = ENC (chk_V0N NOT TOUCH EDGE lside_enc_good) M1_STD_082_end > 0.032 < 0.035 ABUT<90 OPPOSITE REGION

 err2 NOT OUTSIDE (DDBTBS_real AND STDB_all)
 err3 NOT OUTSIDE (DDBTBS_real AND STDB_all)
 err4 NOT OUTSIDE (DDBTBS_real AND STDB_all)
 err5 NOT OUTSIDE (DDBTBS_real AND STDB_all)
 err6 NOT OUTSIDE (DDBTBS_real AND STDB_all)
 err7 NOT OUTSIDE (DDBTBS_real AND STDB_all)
 err8 NOT OUTSIDE (DDBTBS_real AND STDB_all)
}

V0_S_3_TBS {
@ Space to M0G (different net and PRL > 0) >= 0.04um
@ DRC only check space along M1 enclosure V0 > 0
 err1 = EXT M0G (V0_STD NOT COIN INSIDE EDGE M1) < 0.04 ABUT<90 OPPOSITE REGION MEASURE ALL NOT CONNECTED
 err1 NOT OUTSIDE STDB_all
}

V0_S_4_TBS {
@ Space between V0 and (M0 NOT M0C) (different net) in S/D direction when PRL > 0um. >= 0.028um
@ DRC only check space along M1 enclosure V0 > 0 in S/D direction
 err1 = EXT M0_NOT_M0C_v_edges (V0_STD NOT COIN INSIDE EDGE M1) < 0.028 ABUT<90 OPPOSITE REGION MEASURE ALL NOT CONNECTED
 err1 NOT OUTSIDE STDB_all
}

V0_EN_12_TBS {
@ Enclosure by M1 corner (0.032um <= M1 width <= 0.046um) for opposite side (line-end) >= 0.036um with the other two sides >= 0um. >= 0.041um
 err1 = RECTANGLE ENCLOSURE (V0N NOT OUTSIDE (M1 WITH WIDTH >= 0.032 <= 0.046)) M1 ABUT<90 SINGULAR
 GOOD 0.0 0.036 OPPOSITE 0.0 0.041 OPPOSITE
 err1 NOT OUTSIDE STDB_all
}


// =======================================================
// Metal-1 design rules (double patterning process)
// =======================================================

GROUP GM1_STD M1_?_TBS

M1_STD = M1 NOT OUTSIDE STDB_all

M1_STD_good_032 = M1_STD WITH WIDTH == 0.032
M1_STD_good_034 = M1_STD WITH WIDTH == 0.034
M1_STD_good_035 = M1_STD WITH WIDTH == 0.035
M1_STD_good_038 = M1_STD WITH WIDTH == 0.038
M1_STD_good_046 = M1_STD WITH WIDTH == 0.046
M1_STD_good_050 = M1_STD WITH WIDTH == 0.050
M1_STD_good_058 = M1_STD WITH WIDTH == 0.058
M1_STD_good_063 = M1_STD WITH WIDTH == 0.063
M1_STD_good_064 = M1_STD WITH WIDTH == 0.064
M1_STD_good_066 = M1_STD WITH WIDTH == 0.066
M1_STD_good_076 = M1_STD WITH WIDTH == 0.076
M1_STD_good_077 = M1_STD WITH WIDTH == 0.077
M1_STD_good_082 = M1_STD WITH WIDTH == 0.082
M1_STD_good_090 = M1_STD WITH WIDTH == 0.090
M1_STD_good_096 = M1_STD WITH WIDTH == 0.096

M1_STD_032_end = LENGTH (M1_convex_eq_two_edges COIN EDGE M1_STD) == 0.032
M1_STD_034_end = LENGTH (M1_convex_eq_two_edges COIN EDGE M1_STD) == 0.034
M1_STD_035_end = LENGTH (M1_convex_eq_two_edges COIN EDGE M1_STD) == 0.035
M1_STD_038_end = LENGTH (M1_convex_eq_two_edges COIN EDGE M1_STD) == 0.038
M1_STD_046_end = LENGTH (M1_convex_eq_two_edges COIN EDGE M1_STD) == 0.046
M1_STD_050_end = LENGTH (M1_convex_eq_two_edges COIN EDGE M1_STD) == 0.050
M1_STD_058_end = LENGTH (M1_convex_eq_two_edges COIN EDGE M1_STD) == 0.058
M1_STD_063_end = LENGTH (M1_convex_eq_two_edges COIN EDGE M1_STD) == 0.063
M1_STD_064_end = LENGTH (M1_convex_eq_two_edges COIN EDGE M1_STD) == 0.064
M1_STD_066_end = LENGTH (M1_convex_eq_two_edges COIN EDGE M1_STD) == 0.066
M1_STD_076_end = LENGTH (M1_convex_eq_two_edges COIN EDGE M1_STD) == 0.076
M1_STD_077_end = LENGTH (M1_convex_eq_two_edges COIN EDGE M1_STD) == 0.077
M1_STD_082_end = LENGTH (M1_convex_eq_two_edges COIN EDGE M1_STD) == 0.082
M1_STD_090_end = LENGTH (M1_convex_eq_two_edges COIN EDGE M1_STD) == 0.090
M1_STD_096_end = LENGTH (M1_convex_eq_two_edges COIN EDGE M1_STD) == 0.096

M1_STD_032_line = M1_STD touch edge ((INT [M1_STD] == 0.032 ABUT<90 OPPOSITE) TOUCH EDGE M1_STD_good_032)
M1_STD_034_line = M1_STD touch edge ((INT [M1_STD] == 0.034 ABUT<90 OPPOSITE) TOUCH EDGE M1_STD_good_034)
M1_STD_035_line = M1_STD touch edge ((INT [M1_STD] == 0.035 ABUT<90 OPPOSITE) TOUCH EDGE M1_STD_good_035)
M1_STD_038_line = M1_STD touch edge ((INT [M1_STD] == 0.038 ABUT<90 OPPOSITE) TOUCH EDGE M1_STD_good_038)
M1_STD_046_line = M1_STD touch edge ((INT [M1_STD] == 0.046 ABUT<90 OPPOSITE) TOUCH EDGE M1_STD_good_046)
M1_STD_050_line = M1_STD touch edge ((INT [M1_STD] == 0.050 ABUT<90 OPPOSITE) TOUCH EDGE M1_STD_good_050)
M1_STD_058_line = M1_STD touch edge ((INT [M1_STD] == 0.058 ABUT<90 OPPOSITE) TOUCH EDGE M1_STD_good_058)
M1_STD_063_line = M1_STD touch edge ((INT [M1_STD] == 0.063 ABUT<90 OPPOSITE) TOUCH EDGE M1_STD_good_063)
M1_STD_064_line = M1_STD touch edge ((INT [M1_STD] == 0.064 ABUT<90 OPPOSITE) TOUCH EDGE M1_STD_good_064)
M1_STD_066_line = M1_STD touch edge ((INT [M1_STD] == 0.066 ABUT<90 OPPOSITE) TOUCH EDGE M1_STD_good_066)
M1_STD_076_line = M1_STD touch edge ((INT [M1_STD] == 0.076 ABUT<90 OPPOSITE) TOUCH EDGE M1_STD_good_076)
M1_STD_077_line = M1_STD touch edge ((INT [M1_STD] == 0.077 ABUT<90 OPPOSITE) TOUCH EDGE M1_STD_good_077)
M1_STD_082_line = M1_STD touch edge ((INT [M1_STD] == 0.082 ABUT<90 OPPOSITE) TOUCH EDGE M1_STD_good_082)
M1_STD_090_line = M1_STD touch edge ((INT [M1_STD] == 0.090 ABUT<90 OPPOSITE) TOUCH EDGE M1_STD_good_090)
M1_STD_096_line = M1_STD touch edge ((INT [M1_STD] == 0.096 ABUT<90 OPPOSITE) TOUCH EDGE M1_STD_good_096)

M1_W_1_9T_TBS {
@ M1 width in 9T DDB design = 0.032/0.034/0.038/0.046/0.05/0.064/0.082/0.09/0.096um
 err1_TMP = M1_STD NOT (OR M1_STD_good_032 M1_STD_good_034 M1_STD_good_038 M1_STD_good_046 M1_STD_good_050 M1_STD_good_064 M1_STD_good_082 M1_STD_good_090 M1_STD_good_096)
 err1 = err1_TMP NOT OUTSIDE PowerRail_Area_90T
 err1 NOT OUTSIDE (DDBTBS_real AND STDB_all)

 err2 = (INT M1_STD < 0.032 ABUT<90 SINGULAR REGION) NOT OUTSIDE PowerRail_Area_90T
 err2 NOT OUTSIDE (DDBTBS_real AND STDB_all)
}

M1_W_1_75T_TBS {
@ M1 width in 7.5T DDB design = 0.032/0.034/0.035/0.046/0.05/0.064/0.066/0.076/0.082/0.09/0.096um
 err1_TMP = M1_STD NOT (OR M1_STD_good_032 M1_STD_good_034 M1_STD_good_035 M1_STD_good_046 M1_STD_good_050 M1_STD_good_064 M1_STD_good_066 M1_STD_good_076 M1_STD_good_082 M1_STD_good_090 M1_STD_good_096)
 err1 = err1_TMP NOT OUTSIDE PowerRail_Area_75T
 err1 NOT OUTSIDE (DDBTBS_real AND STDB_all)

 err2 = (INT M1_STD < 0.032 ABUT<90 SINGULAR REGION) NOT OUTSIDE PowerRail_Area_75T
 err2 NOT OUTSIDE (DDBTBS_real AND STDB_all)
}

M1_W_1_AR_TBS {
@ M1 width in SDB design = 0.032/0.034/0.035/0.038/0.046/0.050/0.058/0.063/0.064/0.066/0.076/0.077/0.082/0.09um
 err1_TMP = M1_STD NOT (OR M1_STD_good_032 M1_STD_good_034 M1_STD_good_035 M1_STD_good_038 M1_STD_good_046 M1_STD_good_050 M1_STD_good_058 M1_STD_good_063 M1_STD_good_064 M1_STD_good_066 M1_STD_good_076 M1_STD_good_077 M1_STD_good_082 M1_STD_good_090)
 err1 = err1_TMP NOT OUTSIDE SDBTBS_real
 err1 NOT OUTSIDE (SDBTBS_real AND STDB_all)

 err2 = (INT M1_STD < 0.032 ABUT<90 SINGULAR REGION) NOT OUTSIDE PowerRail_Area
 err2 NOT OUTSIDE (SDBTBS_real AND STDB_all)
}

M1_S_1a_9T_TBS {
@ Space between M1 (width = 0.032um) line and PowerRail centerline in 9T DDB design = 0.144um
 chk_M1 = M1_STD_032_line NOT OUTSIDE EDGE PowerRail_Area_90T
 err1 = EXT chk_M1 PowerRail_centerline_002 < 0.144-PowerRail_grid ABUT<90 OPPOSITE REGION MEASURE ALL
 err2 = (M1_STD_good_032 NOT WITH EDGE (EXT [M1_STD_032_line] PowerRail_centerline_002 <= 0.144-PowerRail_grid ABUT<90 OPPOSITE MEASURE ALL)) NOT OUTSIDE PowerRail_Area_90T

 err1 NOT OUTSIDE (DDBTBS_real AND STDB_all)
 err2 NOT OUTSIDE (DDBTBS_real AND STDB_all)
}

M1_S_1a_75T_TBS {
@ Space between M1 (width = 0.032um) line and PowerRail centerline in 7.5T DDB design = 0.077/0.141/0.144um
 chk_M1 = M1_STD_032_line NOT OUTSIDE EDGE PowerRail_Area_75T
 err1 = EXT chk_M1 PowerRail_centerline_002 < 0.077-PowerRail_grid ABUT<90 OPPOSITE REGION MEASURE ALL
 err2 = EXT chk_M1 PowerRail_centerline_002 > 0.077-PowerRail_grid < 0.141-PowerRail_grid ABUT<90 OPPOSITE REGION MEASURE ALL
 err3 = EXT chk_M1 PowerRail_centerline_002 > 0.141-PowerRail_grid < 0.144-PowerRail_grid ABUT<90 OPPOSITE REGION MEASURE ALL
 err4 = (M1_STD_good_032 NOT WITH EDGE (EXT [M1_STD_032_line] PowerRail_centerline_002 <= 0.144-PowerRail_grid ABUT<90 OPPOSITE MEASURE ALL)) NOT OUTSIDE PowerRail_Area_75T

 err1 NOT OUTSIDE (DDBTBS_real AND STDB_all)
 err2 NOT OUTSIDE (DDBTBS_real AND STDB_all)
 err3 NOT OUTSIDE (DDBTBS_real AND STDB_all)
 err4 NOT OUTSIDE (DDBTBS_real AND STDB_all)
}

M1_S_1a_AR_TBS {
@ Space between M1 (width = 0.032um) line and PowerRail centerline in SDB design. = 0.077/0.08/0.109/0.141/0.144/0.161/0.173/0.190um
 chk_M1 = M1_STD_032_line NOT OUTSIDE EDGE SDBTBS_real
 err1 = EXT chk_M1 PowerRail_centerline_002 < 0.077-PowerRail_grid ABUT<90 OPPOSITE REGION MEASURE ALL
 err2 = EXT chk_M1 PowerRail_centerline_002 > 0.077-PowerRail_grid < 0.080-PowerRail_grid ABUT<90 OPPOSITE REGION MEASURE ALL
 err3 = EXT chk_M1 PowerRail_centerline_002 > 0.080-PowerRail_grid < 0.109-PowerRail_grid ABUT<90 OPPOSITE REGION MEASURE ALL
 err4 = EXT chk_M1 PowerRail_centerline_002 > 0.109-PowerRail_grid < 0.141-PowerRail_grid ABUT<90 OPPOSITE REGION MEASURE ALL
 err5 = EXT chk_M1 PowerRail_centerline_002 > 0.141-PowerRail_grid < 0.144-PowerRail_grid ABUT<90 OPPOSITE REGION MEASURE ALL
 err6 = EXT chk_M1 PowerRail_centerline_002 > 0.144-PowerRail_grid < 0.161-PowerRail_grid ABUT<90 OPPOSITE REGION MEASURE ALL
 err7 = EXT chk_M1 PowerRail_centerline_002 > 0.161-PowerRail_grid < 0.173-PowerRail_grid ABUT<90 OPPOSITE REGION MEASURE ALL
 err8 = EXT chk_M1 PowerRail_centerline_002 > 0.173-PowerRail_grid < 0.190-PowerRail_grid ABUT<90 OPPOSITE REGION MEASURE ALL
 err9 = (M1_STD_good_032 NOT WITH EDGE (EXT [M1_STD_032_line] PowerRail_centerline_002 <= 0.190-PowerRail_grid ABUT<90 OPPOSITE MEASURE ALL)) NOT OUTSIDE SDBTBS_real

 err1 NOT OUTSIDE (SDBTBS_real AND STDB_all)
 err2 NOT OUTSIDE (SDBTBS_real AND STDB_all)
 err3 NOT OUTSIDE (SDBTBS_real AND STDB_all)
 err4 NOT OUTSIDE (SDBTBS_real AND STDB_all)
 err5 NOT OUTSIDE (SDBTBS_real AND STDB_all)
 err6 NOT OUTSIDE (SDBTBS_real AND STDB_all)
 err7 NOT OUTSIDE (SDBTBS_real AND STDB_all)
 err8 NOT OUTSIDE (SDBTBS_real AND STDB_all)
 err9 NOT OUTSIDE (SDBTBS_real AND STDB_all)
}

M1_S_1b_EX_1_9T_TBS {
@ M1.S.1b.9TBS: Space between M1 (width = 0.032um) line-end and GT centerline in 9T DDB design = 0.042um
@ M1.EX.1.9TBS: M1 (width = 0.032um) line-end extension GT centerline in 9T DDB design = 0.006/0.008um
 CHK_AREA = DDBTBS_real AND STDB_all
 chk_M1 = (ANGLE M1_STD_032_end == 90) NOT OUTSIDE EDGE PowerRail_Area_90T
 chk_GT = INT GT <= 0.024 OPPOSITE REGION CENTERLINE 0.0002  //;based on GT_W_1_TBS
 good_ext_1 = EXT [chk_M1] chk_GT == 0.042-0.0001 ABUT<90 OPPOSITE
 good_enc_1 = ENC chk_GT [chk_M1] == 0.006-0.0001 ABUT<90 OPPOSITE
 good_enc_2 = ENC chk_GT [chk_M1] == 0.008-0.0001 ABUT<90 OPPOSITE

 err1 = (chk_M1 NOT COIN EDGE good_ext_1) NOT COIN EDGE (OR EDGE good_enc_1 good_enc_2)
 err1 NOT OUTSIDE EDGE CHK_AREA
}

M1_S_1b_EX_1_75T_TBS {
@ M1.S.1b.7TBS: Space between M1 (width = 0.032um) line-end and GT centerline in 7.5T DDB design
@ DRC flag all M1 (width = 0.032um) line-end space to GT centerline. = \um
@ M1.EX.1.7TBS: M1 (width = 0.032um) line-end extension GT centerline in 7.5T DDB design = 0.006/0.008um
 CHK_AREA = DDBTBS_real AND STDB_all
 chk_M1 = (ANGLE M1_STD_032_end == 90) NOT OUTSIDE EDGE PowerRail_Area_75T
 chk_GT = INT GT <= 0.024 OPPOSITE REGION CENTERLINE 0.0002  //;based on GT_W_1_TBS
 good_enc_1 = ENC chk_GT [chk_M1] == 0.006-0.0001 ABUT<90 OPPOSITE
 good_enc_2 = ENC chk_GT [chk_M1] == 0.008-0.0001 ABUT<90 OPPOSITE

 err1 = chk_M1 NOT COIN EDGE (OR EDGE good_enc_1 good_enc_2)
 err1 NOT OUTSIDE EDGE CHK_AREA

//; err2 = (ANGLE M1_STD_032_end == 0) NOT OUTSIDE EDGE PowerRail_Area_90T
//; err2 NOT OUTSIDE EDGE STDB_all  //;line-end perpendicular GT centerline
}

M1_S_2a_9T_TBS {
@ Space between M1 (width = 0.034um) line and PowerRail centerline in 9T DDB design = 0.078/0.11/0.175/0.190um
 chk_M1 = (ANGLE M1_STD_034_line == 0) NOT OUTSIDE EDGE PowerRail_Area_90T
 err1 = EXT chk_M1 PowerRail_centerline_002 < 0.078-PowerRail_grid ABUT<90 OPPOSITE REGION MEASURE ALL
 err2 = EXT chk_M1 PowerRail_centerline_002 > 0.078-PowerRail_grid < 0.110-PowerRail_grid ABUT<90 OPPOSITE REGION MEASURE ALL
 err3 = EXT chk_M1 PowerRail_centerline_002 > 0.110-PowerRail_grid < 0.175-PowerRail_grid ABUT<90 OPPOSITE REGION MEASURE ALL
 err4 = EXT chk_M1 PowerRail_centerline_002 > 0.175-PowerRail_grid < 0.190-PowerRail_grid ABUT<90 OPPOSITE REGION MEASURE ALL
 err5 = ((M1_STD_good_034 WITH EDGE chk_M1) NOT WITH EDGE (EXT [chk_M1] PowerRail_centerline_002 <= 0.190-PowerRail_grid ABUT<90 OPPOSITE MEASURE ALL)) NOT OUTSIDE PowerRail_Area_90T

 err1 NOT OUTSIDE (DDBTBS_real AND STDB_all)
 err2 NOT OUTSIDE (DDBTBS_real AND STDB_all)
 err3 NOT OUTSIDE (DDBTBS_real AND STDB_all)
 err4 NOT OUTSIDE (DDBTBS_real AND STDB_all)
 err5 NOT OUTSIDE (DDBTBS_real AND STDB_all)
}

M1_S_2a_75T_TBS {
@ Space between M1 (width = 0.034um) line and PowerRail centerline in 7.5T DDB design = 0.078/0.110um
 chk_M1 = (ANGLE M1_STD_034_line == 0) NOT OUTSIDE EDGE PowerRail_Area_75T
 err1 = EXT chk_M1 PowerRail_centerline_002 < 0.078-PowerRail_grid ABUT<90 OPPOSITE REGION MEASURE ALL
 err2 = EXT chk_M1 PowerRail_centerline_002 > 0.078-PowerRail_grid < 0.110-PowerRail_grid ABUT<90 OPPOSITE REGION MEASURE ALL
 err3 = ((M1_STD_good_034 WITH EDGE chk_M1) NOT WITH EDGE (EXT [chk_M1] PowerRail_centerline_002 <= 0.110-PowerRail_grid ABUT<90 OPPOSITE MEASURE ALL)) NOT OUTSIDE PowerRail_Area_75T

 err1 NOT OUTSIDE (DDBTBS_real AND STDB_all)
 err2 NOT OUTSIDE (DDBTBS_real AND STDB_all)
 err3 NOT OUTSIDE (DDBTBS_real AND STDB_all)
}

M1_S_2a_AR_TBS {
@ Space between M1 (width = 0.034um) line and PowerRail centerline in SDB design. = 0.078/0.127um
 chk_M1 = (ANGLE M1_STD_034_line == 0) NOT OUTSIDE EDGE SDBTBS_real
 err1 = EXT chk_M1 PowerRail_centerline_002 < 0.078-PowerRail_grid ABUT<90 OPPOSITE REGION MEASURE ALL
 err2 = EXT chk_M1 PowerRail_centerline_002 > 0.078-PowerRail_grid < 0.127-PowerRail_grid ABUT<90 OPPOSITE REGION MEASURE ALL
 err3 = (M1_STD_good_034 WITH EDGE chk_M1) NOT WITH EDGE (EXT [chk_M1] PowerRail_centerline_002 <= 0.127-PowerRail_grid ABUT<90 OPPOSITE MEASURE ALL)

 err1 NOT OUTSIDE (SDBTBS_real AND STDB_all)
 err2 NOT OUTSIDE (SDBTBS_real AND STDB_all)
 err3 NOT OUTSIDE (SDBTBS_real AND STDB_all)
}

M1_S_2b_9T_TBS {
@ Space between M1 (width = 0.034um) centerline and GT centerline in 9T DDB design. = 0.008/0.022/0.026/0.048um
//;based on M1_S_2a_9T_TBS
 chk_M1 = INT (ANGLE M1_STD_034_line == 90) == 0.034 ABUT<90 OPPOSITE REGION CENTERLINE 0.0002
 chk_GT = INT GT <= 0.024 OPPOSITE REGION CENTERLINE 0.0002  //;based on GT_W_1_TBS
 err1 = (EXT chk_M1 chk_GT < 0.008-0.0001*2 ABUT<90 OPPOSITE REGION MEASURE ALL) NOT OUTSIDE PowerRail_Area_90T
 err2 = (EXT chk_M1 chk_GT > 0.008-0.0001*2 < 0.022-0.0001*2 ABUT<90 OPPOSITE REGION MEASURE ALL) NOT OUTSIDE PowerRail_Area_90T
 err3 = (EXT chk_M1 chk_GT > 0.022-0.0001*2 < 0.026-0.0001*2 ABUT<90 OPPOSITE REGION MEASURE ALL) NOT OUTSIDE PowerRail_Area_90T
 err4 = (EXT chk_M1 chk_GT > 0.026-0.0001*2 < 0.048-0.0001*2 ABUT<90 OPPOSITE REGION MEASURE ALL) NOT OUTSIDE PowerRail_Area_90T
 err5 = (chk_M1 NOT WITH EDGE (EXT [chk_M1] chk_GT <= 0.048-0.0001*2 ABUT<90 OPPOSITE MEASURE ALL)) NOT OUTSIDE PowerRail_Area_90T

 err1 NOT OUTSIDE (DDBTBS_real AND STDB_all)
 err2 NOT OUTSIDE (DDBTBS_real AND STDB_all)
 err3 NOT OUTSIDE (DDBTBS_real AND STDB_all)
 err4 NOT OUTSIDE (DDBTBS_real AND STDB_all)
 err5 NOT OUTSIDE (DDBTBS_real AND STDB_all)
}

M1_S_2b_75T_TBS {
@ Space between M1 (width = 0.034um) centerline and GT centerline in 7.5T DDB design. = 0.008/0.026/0.037um
//;based on M1_S_2a_75T_TBS
 chk_M1 = INT (ANGLE M1_STD_034_line == 90) == 0.034 ABUT<90 OPPOSITE REGION CENTERLINE 0.0002
 chk_GT = INT GT <= 0.024 OPPOSITE REGION CENTERLINE 0.0002  //;based on GT_W_1_TBS
 err1 = (EXT chk_M1 chk_GT < 0.008-0.0001*2 ABUT<90 OPPOSITE REGION MEASURE ALL) NOT OUTSIDE PowerRail_Area_75T
 err2 = (EXT chk_M1 chk_GT > 0.008-0.0001*2 < 0.026-0.0001*2 ABUT<90 OPPOSITE REGION MEASURE ALL) NOT OUTSIDE PowerRail_Area_75T
 err3 = (EXT chk_M1 chk_GT > 0.026-0.0001*2 < 0.037-0.0001*2 ABUT<90 OPPOSITE REGION MEASURE ALL) NOT OUTSIDE PowerRail_Area_75T
 err4 = (chk_M1 NOT WITH EDGE (EXT [chk_M1] chk_GT <= 0.037-0.0001*2 ABUT<90 OPPOSITE MEASURE ALL)) NOT OUTSIDE PowerRail_Area_75T

 err1 NOT OUTSIDE (DDBTBS_real AND STDB_all)
 err2 NOT OUTSIDE (DDBTBS_real AND STDB_all)
 err3 NOT OUTSIDE (DDBTBS_real AND STDB_all)
 err4 NOT OUTSIDE (DDBTBS_real AND STDB_all)
}

M1_S_2c_EX_2_9T_TBS {
@ M1.S.2c.9TBS: Space between M1 (width = 0.034um) line-end and GT centerline in 9T DDB design = 0.040um
@ M1.EX.2.9TBS: M1 (width = 0.034um) line-end extension GT centerline in 9T DDB design = 0.006/0.008um
 CHK_AREA = DDBTBS_real AND STDB_all
 chk_M1 = (ANGLE M1_STD_034_end == 90) NOT OUTSIDE EDGE PowerRail_Area_90T
 chk_GT = INT GT <= 0.024 OPPOSITE REGION CENTERLINE 0.0002  //;based on GT_W_1_TBS
 good_ext_1 = EXT [chk_M1] chk_GT == 0.040-0.0001 ABUT<90 OPPOSITE
 good_enc_1 = ENC chk_GT [chk_M1] == 0.006-0.0001 ABUT<90 OPPOSITE
 good_enc_2 = ENC chk_GT [chk_M1] == 0.008-0.0001 ABUT<90 OPPOSITE

 err1 = (chk_M1 NOT COIN EDGE good_ext_1) NOT COIN EDGE (OR EDGE good_enc_1 good_enc_2)
 err1 NOT OUTSIDE EDGE CHK_AREA
}

M1_S_2c_EX_2_75T_TBS {
@ M1.S.2c.7TBS: Space between M1 (width = 0.034um) line-end and GT centerline in 7.5T DDB design
@ DRC flag all M1 (width = 0.034um) line-end space to GT centerline = \um
@ M1.EX.2.7TBS: M1 (width = 0.034um) line-end extension GT centerline in 7.5T DDB design = 0.006/0.008um
 CHK_AREA = DDBTBS_real AND STDB_all
 chk_M1 = (ANGLE M1_STD_034_end == 90) NOT OUTSIDE EDGE PowerRail_Area_75T
 chk_GT = INT GT <= 0.024 OPPOSITE REGION CENTERLINE 0.0002  //;based on GT_W_1_TBS
 good_enc_1 = ENC chk_GT [chk_M1] == 0.006-0.0001 ABUT<90 OPPOSITE
 good_enc_2 = ENC chk_GT [chk_M1] == 0.008-0.0001 ABUT<90 OPPOSITE

 err1 = chk_M1 NOT COIN EDGE (OR EDGE good_enc_1 good_enc_2)
 err1 NOT OUTSIDE EDGE CHK_AREA
}

M1_S_2d_TBS {
@ Space between M1 (width = 0.034um) line-end and PowerRail centerline.
@ DRC flag horizontal M1 (width = 0.034um) line-end = \um
 err1 = ANGLE M1_STD_034_end == 0
 err1 NOT OUTSIDE EDGE STDB_all  //;line-end parallel PowerRail centerline
}

M1_S_3a_75T_TBS {
@ Space between M1 (width = 0.035um) line and PowerRail centerline in 7.5T DDB design = 0.141um
 chk_M1 = (ANGLE M1_STD_035_line == 0) NOT OUTSIDE EDGE PowerRail_Area_75T
 good_141 = EXT [M1_STD_035_line] PowerRail_centerline_002 == 0.141-PowerRail_grid ABUT<90 OPPOSITE MEASURE ALL
 err1 = (M1_STD_good_035 NOT WITH EDGE good_141) NOT OUTSIDE PowerRail_Area_75T
 err2 = (EXT M1_STD_035_line PowerRail_centerline_002 < 0.141-PowerRail_grid ABUT<90 OPPOSITE REGION MEASURE ALL) NOT OUTSIDE PowerRail_Area_75T

 err1 NOT OUTSIDE (DDBTBS_real AND STDB_all)
 err2 NOT OUTSIDE (DDBTBS_real AND STDB_all)
}

M1_S_3a_AR_TBS {
@ Space between M1 (width = 0.035um) line and PowerRail centerline in SDB design. = 0.141um
 chk_M1 = (ANGLE M1_STD_035_line == 0) NOT OUTSIDE EDGE SDBTBS_real
 good_141 = EXT [M1_STD_035_line] PowerRail_centerline_002 == 0.141-PowerRail_grid ABUT<90 OPPOSITE MEASURE ALL
 err1 = M1_STD_good_035 NOT WITH EDGE good_141
 err2 = EXT M1_STD_035_line PowerRail_centerline_002 < 0.141-PowerRail_grid ABUT<90 OPPOSITE REGION MEASURE ALL

 err1 NOT OUTSIDE (SDBTBS_real AND STDB_all)
 err2 NOT OUTSIDE (SDBTBS_real AND STDB_all)
}

M1_S_3b_EX_3_75T_TBS {
@ M1.S.3b.7TBS: Space between M1 (width = 0.035um) line-end and GT centerline in 7.5T DDB design
@ DRC flag all M1 (width = 0.035um) line-end space to GT centerline. = \um
@ M1.EX.3b.7TBS: M1 (width = 0.035um) line-end extension GT centerline in 7.5T DDB design = 0.006/0.008um
 CHK_AREA = DDBTBS_real AND STDB_all
 chk_M1 = (ANGLE M1_STD_035_end == 90) NOT OUTSIDE EDGE PowerRail_Area_75T
 chk_GT = INT GT <= 0.024 OPPOSITE REGION CENTERLINE 0.0002  //;based on GT_W_1_TBS
 good_1 = ENC chk_GT (chk_M1) == 0.006-0.0001 ABUT<90 OPPOSITE
 good_2 = ENC chk_GT (good_1) == 0.008-0.0001 ABUT<90 OPPOSITE
 err1 = good_2 NOT OUTSIDE EDGE PowerRail_Area_75T
 err1 NOT OUTSIDE EDGE CHK_AREA

 err2 = (ANGLE M1_STD_035_end == 0) NOT OUTSIDE EDGE PowerRail_Area_75T
 err2 NOT OUTSIDE EDGE CHK_AREA
}

M1_S_3b_EX_3_AR_TBS {
@ M1.S.3b.ARTBS: Space between M1 (width = 0.035um) line-end and GT centerline in SDB design = 0.046um
@ M1.EX.3.ARTBS: M1 (width = 0.035um) line-end extension GT centerline in SDB design = 0.006um
 CHK_AREA = SDBTBS_real AND STDB_all
 chk_M1 = (ANGLE M1_STD_035_end == 90) NOT OUTSIDE EDGE SDBTBS_real
 chk_GT = INT GT <= 0.024 OPPOSITE REGION CENTERLINE 0.0002  //;based on GT_W_1_TBS
 good_1 = ENC chk_GT (chk_M1) == 0.006-0.0001 ABUT<90 OPPOSITE
 good_2 = EXT chk_GT (good_1) == 0.046-0.0001 ABUT<90 OPPOSITE
 err1 = good_2 NOT OUTSIDE EDGE SDBTBS_real
 err1 NOT OUTSIDE EDGE CHK_AREA

 err2 = ANGLE M1_STD_035_end == 0
 err2 NOT OUTSIDE EDGE CHK_AREA
}

M1_S_4a_9T_TBS {
@ Space between M1 (width = 0.038um) centerline and GT centerline in 9T DDB design = 0.026um
 chk_M1 = INT (ANGLE M1_STD_038_line == 90) == 0.038 ABUT<90 OPPOSITE REGION CENTERLINE 0.0002
 chk_GT = INT GT <= 0.024 OPPOSITE REGION CENTERLINE 0.0002  //;based on GT_W_1_TBS
 err1 = (EXT chk_M1 chk_GT < 0.026-0.0001*2 ABUT<90 OPPOSITE REGION MEASURE ALL) NOT OUTSIDE PowerRail_Area_90T
 err2 = (chk_M1 NOT WITH EDGE (EXT [chk_M1] chk_GT <= 0.026-0.0001*2 ABUT<90 OPPOSITE MEASURE ALL)) NOT OUTSIDE PowerRail_Area_90T

 err1 NOT OUTSIDE (DDBTBS_real AND STDB_all)
 err2 NOT OUTSIDE (DDBTBS_real AND STDB_all)
}

M1_S_4a_AR_TBS {
@ Space between M1 (width = 0.038um) centerline and GT centerline in SDB design. = 0.001/0.01/0.012/0.02/0.022/0.026/0.029/0.031/0.033/0.035/0.042/0.045um
//;based on M1_S_2a_9T_TBS
 chk_M1 = INT (ANGLE M1_STD_038_line == 90) == 0.038 ABUT<90 OPPOSITE REGION CENTERLINE 0.0002
 chk_GT = INT GT <= 0.024 OPPOSITE REGION CENTERLINE 0.0002  //;based on GT_W_1_TBS
 err1 = (EXT chk_M1 chk_GT > 0.001-0.0001*2 < 0.010-0.0001*2 ABUT<90 OPPOSITE REGION MEASURE ALL) NOT OUTSIDE SDBTBS_real
 err2 = (EXT chk_M1 chk_GT > 0.001-0.0001*2 < 0.010-0.0001*2 ABUT<90 OPPOSITE REGION MEASURE ALL) NOT OUTSIDE SDBTBS_real
 err3 = (EXT chk_M1 chk_GT > 0.010-0.0001*2 < 0.012-0.0001*2 ABUT<90 OPPOSITE REGION MEASURE ALL) NOT OUTSIDE SDBTBS_real
 err4 = (EXT chk_M1 chk_GT > 0.012-0.0001*2 < 0.020-0.0001*2 ABUT<90 OPPOSITE REGION MEASURE ALL) NOT OUTSIDE SDBTBS_real
 err5 = (EXT chk_M1 chk_GT > 0.020-0.0001*2 < 0.022-0.0001*2 ABUT<90 OPPOSITE REGION MEASURE ALL) NOT OUTSIDE SDBTBS_real
 err6 = (EXT chk_M1 chk_GT > 0.022-0.0001*2 < 0.026-0.0001*2 ABUT<90 OPPOSITE REGION MEASURE ALL) NOT OUTSIDE SDBTBS_real
 err7 = (EXT chk_M1 chk_GT > 0.026-0.0001*2 < 0.029-0.0001*2 ABUT<90 OPPOSITE REGION MEASURE ALL) NOT OUTSIDE SDBTBS_real
 err8 = (EXT chk_M1 chk_GT > 0.029-0.0001*2 < 0.031-0.0001*2 ABUT<90 OPPOSITE REGION MEASURE ALL) NOT OUTSIDE SDBTBS_real
 err9 = (EXT chk_M1 chk_GT > 0.031-0.0001*2 < 0.033-0.0001*2 ABUT<90 OPPOSITE REGION MEASURE ALL) NOT OUTSIDE SDBTBS_real
 err10 = (EXT chk_M1 chk_GT > 0.033-0.0001*2 < 0.035-0.0001*2 ABUT<90 OPPOSITE REGION MEASURE ALL) NOT OUTSIDE SDBTBS_real
 err11 = (EXT chk_M1 chk_GT > 0.035-0.0001*2 < 0.042-0.0001*2 ABUT<90 OPPOSITE REGION MEASURE ALL) NOT OUTSIDE SDBTBS_real
 err12 = (EXT chk_M1 chk_GT > 0.042-0.0001*2 < 0.045-0.0001*2 ABUT<90 OPPOSITE REGION MEASURE ALL) NOT OUTSIDE SDBTBS_real
 err13 = (chk_M1 NOT WITH EDGE (EXT [chk_M1] chk_GT <= 0.045-0.0001*2 ABUT<90 OPPOSITE MEASURE ALL)) NOT OUTSIDE SDBTBS_real

 err1 NOT OUTSIDE (SDBTBS_real AND STDB_all)
 err2 NOT OUTSIDE (SDBTBS_real AND STDB_all)
 err3 NOT OUTSIDE (SDBTBS_real AND STDB_all)
 err4 NOT OUTSIDE (SDBTBS_real AND STDB_all)
 err5 NOT OUTSIDE (SDBTBS_real AND STDB_all)
 err6 NOT OUTSIDE (SDBTBS_real AND STDB_all)
 err7 NOT OUTSIDE (SDBTBS_real AND STDB_all)
 err8 NOT OUTSIDE (SDBTBS_real AND STDB_all)
 err9 NOT OUTSIDE (SDBTBS_real AND STDB_all)
 err10 NOT OUTSIDE (SDBTBS_real AND STDB_all)
 err11 NOT OUTSIDE (SDBTBS_real AND STDB_all)
 err12 NOT OUTSIDE (SDBTBS_real AND STDB_all)
 err13 NOT OUTSIDE (SDBTBS_real AND STDB_all)
}

M1_S_4b_9T_TBS {
@ Space between M1 (width = 0.038um) line-end and PowerRail centerline in 9T DDB design
@ DRC flag horizontal M1 (width = 0.038um) line-end = \um
 CHK_AREA = DDBTBS_real AND STDB_all
 err1 = (ANGLE M1_STD_038_end == 0) NOT OUTSIDE EDGE PowerRail_Area_90T
 err1 NOT OUTSIDE EDGE CHK_AREA  //;line-end parallel PowerRail centerline
}

M1_S_4b_EX_10a_AR_TBS {
@ M1.S.4b.ARTBS: Space between M1 (width = 0.038um) line-end and PowerRail centerline SDBTBS = 0.129/0.236um
@ M1.EX.10a.ARTBS: M1 (width = 0.038um) line-end extension PowerRail centerline in SDB design = 0.189um
 chk_M1 = (ANGLE M1_STD_038_end == 0) NOT OUTSIDE EDGE SDBTBS_real
 good_1 = EXT (chk_M1) PowerRail_centerline_002 == 0.129-PowerRail_grid ABUT<90 OPPOSITE MEASURE ALL
 good_2 = EXT (good_1) PowerRail_centerline_002 == 0.236-PowerRail_grid ABUT<90 OPPOSITE MEASURE ALL
 good_3 = ENC PowerRail_centerline_002 (good_2) == 0.189-PowerRail_grid ABUT<90 OPPOSITE MEASURE ALL
 err1 = good_3 NOT OUTSIDE EDGE STDB_all
 err1 NOT OUTSIDE EDGE SDBTBS_real
}

M1_S_4c_AR_TBS {
@ Space between M1 (width = 0.038um) line and PowerRail centerline in SDB design. = 0.173/0.184um
 chk_M1 = (ANGLE M1_STD_038_line == 0) NOT OUTSIDE EDGE SDBTBS_real
 err1 = EXT chk_M1 PowerRail_centerline_002 < 0.173-PowerRail_grid ABUT<90 OPPOSITE REGION
 err2 = EXT chk_M1 PowerRail_centerline_002 > 0.173-PowerRail_grid < 0.184-PowerRail_grid ABUT<90 OPPOSITE REGION MEASURE ALL
 err3 = (M1_STD_good_038 WITH EDGE chk_M1) NOT WITH EDGE (EXT [chk_M1] PowerRail_centerline_002 <= 0.184-PowerRail_grid ABUT<90 OPPOSITE MEASURE ALL)

 err1 NOT OUTSIDE (SDBTBS_real AND STDB_all)
 err2 NOT OUTSIDE (SDBTBS_real AND STDB_all)
 err3 NOT OUTSIDE (SDBTBS_real AND STDB_all)
}

M1_S_4d_EX_10b_AR_TBS {
@ M1.S.4d.ARTBS: Space between M1 (width = 0.038um) line-end and GT centerline in SDB design = 0.012um
@ M1.EX.10b.ARTBS: M1 (width = 0.038um) line-end extension GT centerline in SDB design = 0.026um
 CHK_AREA = SDBTBS_real AND STDB_all
 chk_M1 = (ANGLE M1_STD_038_end == 90) NOT OUTSIDE EDGE SDBTBS_real
 chk_GT = INT GT <= 0.024 OPPOSITE REGION CENTERLINE 0.0002  //;based on GT_W_1_TBS
 good_1 = EXT (chk_M1) chk_GT == 0.012-0.0001 ABUT<90 OPPOSITE MEASURE ALL
 good_2 = ENC chk_GT (good_1) == 0.026-0.0001 ABUT<90 OPPOSITE
 err1 = good_2 NOT OUTSIDE EDGE SDBTBS_real
 err1 NOT OUTSIDE EDGE CHK_AREA
}

M1_S_5a_9T_TBS {
@ Space between M1 (width = 0.046um) centerline and GT centerline in 9T DDB design. = 0.002/0.006/0.011/0.016/0.030/0.048um
 chk_M1 = INT (ANGLE M1_STD_046_line == 90) == 0.046 ABUT<90 OPPOSITE REGION CENTERLINE 0.0002
 chk_GT = INT GT <= 0.024 OPPOSITE REGION CENTERLINE 0.0002  //;based on GT_W_1_TBS
 err1 = (EXT chk_M1 chk_GT < 0.002-0.0002 ABUT<90 OPPOSITE REGION MEASURE ALL) NOT OUTSIDE PowerRail_Area_90T
 err2 = (EXT chk_M1 chk_GT > 0.002-0.0002 < 0.006-0.0002 ABUT<90 OPPOSITE REGION MEASURE ALL) NOT OUTSIDE PowerRail_Area_90T
 err3 = (EXT chk_M1 chk_GT > 0.006-0.0002 < 0.011-0.0002 ABUT<90 OPPOSITE REGION MEASURE ALL) NOT OUTSIDE PowerRail_Area_90T
 err4 = (EXT chk_M1 chk_GT > 0.011-0.0002 < 0.016-0.0002 ABUT<90 OPPOSITE REGION MEASURE ALL) NOT OUTSIDE PowerRail_Area_90T
 err5 = (EXT chk_M1 chk_GT > 0.016-0.0002 < 0.030-0.0002 ABUT<90 OPPOSITE REGION MEASURE ALL) NOT OUTSIDE PowerRail_Area_90T
 err6 = (EXT chk_M1 chk_GT > 0.030-0.0002 < 0.048-0.0002 ABUT<90 OPPOSITE REGION MEASURE ALL) NOT OUTSIDE PowerRail_Area_90T
 err7 = (chk_M1 NOT WITH EDGE (EXT [chk_M1] chk_GT <= 0.048-0.0002 ABUT<90 OPPOSITE MEASURE ALL)) NOT OUTSIDE PowerRail_Area_90T

 err1 NOT OUTSIDE (DDBTBS_real AND STDB_all)
 err2 NOT OUTSIDE (DDBTBS_real AND STDB_all)
 err3 NOT OUTSIDE (DDBTBS_real AND STDB_all)
 err4 NOT OUTSIDE (DDBTBS_real AND STDB_all)
 err5 NOT OUTSIDE (DDBTBS_real AND STDB_all)
 err6 NOT OUTSIDE (DDBTBS_real AND STDB_all)
 err7 NOT OUTSIDE (DDBTBS_real AND STDB_all)
}

M1_S_5a_75T_TBS {
@ Space between M1 (width = 0.046um) centerline and GT centerline in 7.5T DDB design. = 0.002/0.007/0.011/0.016/0.030/0.048um
 chk_M1 = INT (ANGLE M1_STD_046_line == 90) == 0.046 ABUT<90 OPPOSITE REGION CENTERLINE 0.0002
 chk_GT = INT GT <= 0.024 OPPOSITE REGION CENTERLINE 0.0002  //;based on GT_W_1_TBS
 err1 = (EXT chk_M1 chk_GT < 0.002-0.0002 ABUT<90 OPPOSITE REGION MEASURE ALL) NOT OUTSIDE PowerRail_Area_75T
 err2 = (EXT chk_M1 chk_GT > 0.002-0.0002 < 0.007-0.0002 ABUT<90 OPPOSITE REGION MEASURE ALL) NOT OUTSIDE PowerRail_Area_75T
 err3 = (EXT chk_M1 chk_GT > 0.007-0.0002 < 0.011-0.0002 ABUT<90 OPPOSITE REGION MEASURE ALL) NOT OUTSIDE PowerRail_Area_75T
 err4 = (EXT chk_M1 chk_GT > 0.011-0.0002 < 0.016-0.0002 ABUT<90 OPPOSITE REGION MEASURE ALL) NOT OUTSIDE PowerRail_Area_75T
 err5 = (EXT chk_M1 chk_GT > 0.016-0.0002 < 0.030-0.0002 ABUT<90 OPPOSITE REGION MEASURE ALL) NOT OUTSIDE PowerRail_Area_75T
 err6 = (EXT chk_M1 chk_GT > 0.030-0.0002 < 0.048-0.0002 ABUT<90 OPPOSITE REGION MEASURE ALL) NOT OUTSIDE PowerRail_Area_75T
 err7 = (chk_M1 NOT WITH EDGE (EXT [chk_M1] chk_GT <= 0.048-0.0002 ABUT<90 OPPOSITE MEASURE ALL)) NOT OUTSIDE PowerRail_Area_75T

 err1 NOT OUTSIDE (DDBTBS_real AND STDB_all)
 err2 NOT OUTSIDE (DDBTBS_real AND STDB_all)
 err3 NOT OUTSIDE (DDBTBS_real AND STDB_all)
 err4 NOT OUTSIDE (DDBTBS_real AND STDB_all)
 err5 NOT OUTSIDE (DDBTBS_real AND STDB_all)
 err6 NOT OUTSIDE (DDBTBS_real AND STDB_all)
 err7 NOT OUTSIDE (DDBTBS_real AND STDB_all)
}

M1_S_5a_AR_TBS {
@ Space between M1 (width = 0.046um) centerline and GT centerline in SDB design. = 0.001/0.005/0.01/0.012/0.017/0.023/0.026/0.029/0.033/0.035/0.038/0.041/0.045um
 chk_M1 = INT (ANGLE M1_STD_046_line == 90) == 0.046 ABUT<90 OPPOSITE REGION CENTERLINE 0.0002
 chk_GT = INT GT <= 0.024 OPPOSITE REGION CENTERLINE 0.0002  //;based on GT_W_1_TBS
 err1 = EXT chk_M1 chk_GT > 0.001-0.0002 < 0.005-0.0002 ABUT<90 OPPOSITE REGION MEASURE ALL
 err2 = EXT chk_M1 chk_GT > 0.001-0.0002 < 0.005-0.0002 ABUT<90 OPPOSITE REGION MEASURE ALL
 err3 = EXT chk_M1 chk_GT > 0.005-0.0002 < 0.010-0.0002 ABUT<90 OPPOSITE REGION MEASURE ALL
 err4 = EXT chk_M1 chk_GT > 0.010-0.0002 < 0.012-0.0002 ABUT<90 OPPOSITE REGION MEASURE ALL
 err5 = EXT chk_M1 chk_GT > 0.012-0.0002 < 0.017-0.0002 ABUT<90 OPPOSITE REGION MEASURE ALL
 err6 = EXT chk_M1 chk_GT > 0.017-0.0002 < 0.023-0.0002 ABUT<90 OPPOSITE REGION MEASURE ALL
 err7 = EXT chk_M1 chk_GT > 0.023-0.0002 < 0.026-0.0002 ABUT<90 OPPOSITE REGION MEASURE ALL
 err8 = EXT chk_M1 chk_GT > 0.026-0.0002 < 0.029-0.0002 ABUT<90 OPPOSITE REGION MEASURE ALL
 err9 = EXT chk_M1 chk_GT > 0.029-0.0002 < 0.033-0.0002 ABUT<90 OPPOSITE REGION MEASURE ALL
 err10 = EXT chk_M1 chk_GT > 0.033-0.0002 < 0.035-0.0002 ABUT<90 OPPOSITE REGION MEASURE ALL
 err11 = EXT chk_M1 chk_GT > 0.035-0.0002 < 0.038-0.0002 ABUT<90 OPPOSITE REGION MEASURE ALL
 err12 = EXT chk_M1 chk_GT > 0.038-0.0002 < 0.041-0.0002 ABUT<90 OPPOSITE REGION MEASURE ALL
 err13 = EXT chk_M1 chk_GT > 0.041-0.0002 < 0.045-0.0002 ABUT<90 OPPOSITE REGION MEASURE ALL
 err14 = chk_M1 NOT WITH EDGE (EXT [chk_M1] chk_GT <= 0.045-0.0002 ABUT<90 OPPOSITE MEASURE ALL)

 err1 NOT OUTSIDE (SDBTBS_real AND STDB_all)
 err2 NOT OUTSIDE (SDBTBS_real AND STDB_all)
 err3 NOT OUTSIDE (SDBTBS_real AND STDB_all)
 err4 NOT OUTSIDE (SDBTBS_real AND STDB_all)
 err5 NOT OUTSIDE (SDBTBS_real AND STDB_all)
 err6 NOT OUTSIDE (SDBTBS_real AND STDB_all)
 err7 NOT OUTSIDE (SDBTBS_real AND STDB_all)
 err8 NOT OUTSIDE (SDBTBS_real AND STDB_all)
 err9 NOT OUTSIDE (SDBTBS_real AND STDB_all)
 err10 NOT OUTSIDE (SDBTBS_real AND STDB_all)
 err11 NOT OUTSIDE (SDBTBS_real AND STDB_all)
 err12 NOT OUTSIDE (SDBTBS_real AND STDB_all)
 err13 NOT OUTSIDE (SDBTBS_real AND STDB_all)
 err14 NOT OUTSIDE (SDBTBS_real AND STDB_all)
}

M1_S_5b_EX_4_9T_TBS {
@ M1.S.5b.9TBS: Space between M1 (width = 0.046um) line-end and PowerRail centerline in 9T DDB design = 0.087/0.119/0.151/0.183/0.215/0.240/0.279um
@ M1.EX.4.9TBS: M1 (width = 0.046um) line-end extension PowerRail centerline in 9T DDB design = 0.265um
 CHK_AREA = DDBTBS_real AND STDB_all
 chk_M1 = (ANGLE M1_STD_046_end == 0) NOT OUTSIDE EDGE PowerRail_Area_90T
 good_1 = EXT (chk_M1) PowerRail_centerline_002 == 0.087-PowerRail_grid ABUT<90 OPPOSITE
 good_2 = EXT (good_1) PowerRail_centerline_002 == 0.119-PowerRail_grid ABUT<90 OPPOSITE
 good_3 = EXT (good_2) PowerRail_centerline_002 == 0.151-PowerRail_grid ABUT<90 OPPOSITE
 good_4 = EXT (good_3) PowerRail_centerline_002 == 0.183-PowerRail_grid ABUT<90 OPPOSITE
 good_5 = EXT (good_4) PowerRail_centerline_002 == 0.215-PowerRail_grid ABUT<90 OPPOSITE
 good_6 = EXT (good_5) PowerRail_centerline_002 == 0.240-PowerRail_grid ABUT<90 OPPOSITE
 good_7 = EXT (good_6) PowerRail_centerline_002 == 0.279-PowerRail_grid ABUT<90 OPPOSITE
 err1 = (ENC PowerRail_centerline_002 (good_7) == 0.265-PowerRail_grid ABUT<90 OPPOSITE MEASURE ALL) NOT OUTSIDE EDGE PowerRail_Area_90T
 err1 NOT OUTSIDE EDGE CHK_AREA
}

M1_S_5b_75T_TBS {
@ Space between M1 (width = 0.046um) line-end and PowerRail centerline in 7.5T DDB design. = 0.082/0.087/0.109/0.119/0.151/0.183/0.215um
 CHK_AREA = DDBTBS_real AND STDB_all
 chk_M1 = (ANGLE M1_STD_046_end == 0) NOT OUTSIDE EDGE PowerRail_Area_75T
 good_1 = EXT (chk_M1) PowerRail_centerline_002 == 0.082-PowerRail_grid ABUT<90 OPPOSITE
 good_2 = EXT (good_1) PowerRail_centerline_002 == 0.087-PowerRail_grid ABUT<90 OPPOSITE
 good_3 = EXT (good_2) PowerRail_centerline_002 == 0.109-PowerRail_grid ABUT<90 OPPOSITE
 good_4 = EXT (good_3) PowerRail_centerline_002 == 0.119-PowerRail_grid ABUT<90 OPPOSITE
 good_5 = EXT (good_4) PowerRail_centerline_002 == 0.151-PowerRail_grid ABUT<90 OPPOSITE
 good_6 = EXT (good_5) PowerRail_centerline_002 == 0.183-PowerRail_grid ABUT<90 OPPOSITE
 good_7 = EXT (good_6) PowerRail_centerline_002 == 0.215-PowerRail_grid ABUT<90 OPPOSITE
 err1 = good_7 NOT OUTSIDE EDGE PowerRail_Area_75T
 err1 NOT OUTSIDE EDGE CHK_AREA
}

M1_S_5b_EX_4_AR_TBS {
@ M1.S.5b.ARTBS: Space between M1 (width = 0.046um) line-end and PowerRail centerline in SDB design = 0.081/0.085/0.11/0.119/0.151/0.183/0.204/0.215/0.236/0.247/0.268umum
@ M1.EX.4.ARTBS: M1 (width = 0.046um) line-end extension PowerRail centerline in SDB design_real = 0.135/0.189/0.221/0.265um
 chk_M1 = (ANGLE M1_STD_046_end == 0) NOT OUTSIDE EDGE SDBTBS_real
 good_1 = EXT (chk_M1) PowerRail_centerline_002 == 0.081-PowerRail_grid ABUT<90 OPPOSITE
 good_2 = EXT (good_1) PowerRail_centerline_002 == 0.085-PowerRail_grid ABUT<90 OPPOSITE
 good_3 = EXT (good_2) PowerRail_centerline_002 == 0.110-PowerRail_grid ABUT<90 OPPOSITE
 good_4 = EXT (good_3) PowerRail_centerline_002 == 0.119-PowerRail_grid ABUT<90 OPPOSITE
 good_5 = EXT (good_4) PowerRail_centerline_002 == 0.151-PowerRail_grid ABUT<90 OPPOSITE
 good_6 = EXT (good_5) PowerRail_centerline_002 == 0.183-PowerRail_grid ABUT<90 OPPOSITE
 good_7 = EXT (good_6) PowerRail_centerline_002 == 0.204-PowerRail_grid ABUT<90 OPPOSITE
 good_8 = EXT (good_7) PowerRail_centerline_002 == 0.215-PowerRail_grid ABUT<90 OPPOSITE
 good_9 = EXT (good_8) PowerRail_centerline_002 == 0.236-PowerRail_grid ABUT<90 OPPOSITE
 good_10 = EXT (good_9) PowerRail_centerline_002 == 0.247-PowerRail_grid ABUT<90 OPPOSITE
 good_11 = EXT (good_10) PowerRail_centerline_002 == 0.268-PowerRail_grid ABUT<90 OPPOSITE

 good_12 = ENC PowerRail_centerline_002 (good_11) == 0.135-PowerRail_grid ABUT<90 OPPOSITE MEASURE ALL
 good_13 = ENC PowerRail_centerline_002 (good_12) == 0.189-PowerRail_grid ABUT<90 OPPOSITE MEASURE ALL
 good_14 = ENC PowerRail_centerline_002 (good_13) == 0.221-PowerRail_grid ABUT<90 OPPOSITE MEASURE ALL
 good_15 = ENC PowerRail_centerline_002 (good_14) == 0.265-PowerRail_grid ABUT<90 OPPOSITE MEASURE ALL
 err1 = good_15 NOT OUTSIDE EDGE STDB_all
 err1 NOT OUTSIDE EDGE SDBTBS_real
}

M1_S_6a_9T_TBS {
@ Space between M1 (width = 0.05um) line and PowerRail centerline in 9T DDB design = 0.078/0.108/0.144/0.176/0.195/0.208/0.240/0.263um
 chk_M1 = (ANGLE M1_STD_050_line == 0) NOT OUTSIDE EDGE PowerRail_Area_90T
 err1 = EXT chk_M1 PowerRail_centerline_002 < 0.078-PowerRail_grid ABUT<90 OPPOSITE REGION
 err2 = EXT chk_M1 PowerRail_centerline_002 > 0.078-PowerRail_grid < 0.108-PowerRail_grid ABUT<90 OPPOSITE REGION MEASURE ALL
 err3 = EXT chk_M1 PowerRail_centerline_002 > 0.108-PowerRail_grid < 0.144-PowerRail_grid ABUT<90 OPPOSITE REGION MEASURE ALL
 err4 = EXT chk_M1 PowerRail_centerline_002 > 0.144-PowerRail_grid < 0.176-PowerRail_grid ABUT<90 OPPOSITE REGION MEASURE ALL
 err5 = EXT chk_M1 PowerRail_centerline_002 > 0.176-PowerRail_grid < 0.195-PowerRail_grid ABUT<90 OPPOSITE REGION MEASURE ALL
 err6 = EXT chk_M1 PowerRail_centerline_002 > 0.195-PowerRail_grid < 0.208-PowerRail_grid ABUT<90 OPPOSITE REGION MEASURE ALL
 err7 = EXT chk_M1 PowerRail_centerline_002 > 0.208-PowerRail_grid < 0.240-PowerRail_grid ABUT<90 OPPOSITE REGION MEASURE ALL
 err8 = EXT chk_M1 PowerRail_centerline_002 > 0.240-PowerRail_grid < 0.263-PowerRail_grid ABUT<90 OPPOSITE REGION MEASURE ALL
//; err9 = (M1_STD_good_050 WITH EDGE chk_M1) NOT WITH EDGE (EXT [chk_M1] PowerRail_centerline_002 <= 0.263-PowerRail_grid ABUT<90 OPPOSITE MEASURE ALL)  //;impossible case

 err1 NOT OUTSIDE (DDBTBS_real AND STDB_all)
 err2 NOT OUTSIDE (DDBTBS_real AND STDB_all)
 err3 NOT OUTSIDE (DDBTBS_real AND STDB_all)
 err4 NOT OUTSIDE (DDBTBS_real AND STDB_all)
 err5 NOT OUTSIDE (DDBTBS_real AND STDB_all)
 err6 NOT OUTSIDE (DDBTBS_real AND STDB_all)
 err7 NOT OUTSIDE (DDBTBS_real AND STDB_all)
 err8 NOT OUTSIDE (DDBTBS_real AND STDB_all)
//; err9 NOT OUTSIDE (DDBTBS_real AND STDB_all)
}

M1_S_6a_75T_TBS {
@ Space between M1 (width = 0.05um) line and PowerRail centerline in 7.5T DDB design = 0.080/0.108/0.109/0.144/0.173/0.176/0.208/0.215um
 chk_M1 = (ANGLE M1_STD_050_line == 0) NOT OUTSIDE EDGE PowerRail_Area_75T
 err1 = EXT chk_M1 PowerRail_centerline_002 < 0.080-PowerRail_grid ABUT<90 OPPOSITE REGION MEASURE ALL
 err2 = EXT chk_M1 PowerRail_centerline_002 > 0.080-PowerRail_grid < 0.108-PowerRail_grid ABUT<90 OPPOSITE REGION MEASURE ALL
 err3 = EXT chk_M1 PowerRail_centerline_002 > 0.109-PowerRail_grid < 0.144-PowerRail_grid ABUT<90 OPPOSITE REGION MEASURE ALL
 err4 = EXT chk_M1 PowerRail_centerline_002 > 0.109-PowerRail_grid < 0.144-PowerRail_grid ABUT<90 OPPOSITE REGION MEASURE ALL
 err5 = EXT chk_M1 PowerRail_centerline_002 > 0.144-PowerRail_grid < 0.173-PowerRail_grid ABUT<90 OPPOSITE REGION MEASURE ALL
 err6 = EXT chk_M1 PowerRail_centerline_002 > 0.173-PowerRail_grid < 0.176-PowerRail_grid ABUT<90 OPPOSITE REGION MEASURE ALL
 err7 = EXT chk_M1 PowerRail_centerline_002 > 0.176-PowerRail_grid < 0.208-PowerRail_grid ABUT<90 OPPOSITE REGION MEASURE ALL
 err8 = EXT chk_M1 PowerRail_centerline_002 > 0.208-PowerRail_grid < 0.215-PowerRail_grid ABUT<90 OPPOSITE REGION MEASURE ALL
//; err9 = (M1_STD_good_050 WITH EDGE chk_M1) NOT WITH EDGE (EXT [chk_M1] PowerRail_centerline_002 <= 0.215-PowerRail_grid ABUT<90 OPPOSITE MEASURE ALL)  //;impossible case

 err1 NOT OUTSIDE (DDBTBS_real AND STDB_all)
 err2 NOT OUTSIDE (DDBTBS_real AND STDB_all)
 err3 NOT OUTSIDE (DDBTBS_real AND STDB_all)
 err4 NOT OUTSIDE (DDBTBS_real AND STDB_all)
 err5 NOT OUTSIDE (DDBTBS_real AND STDB_all)
 err6 NOT OUTSIDE (DDBTBS_real AND STDB_all)
 err7 NOT OUTSIDE (DDBTBS_real AND STDB_all)
 err8 NOT OUTSIDE (DDBTBS_real AND STDB_all)
//; err9 NOT OUTSIDE (DDBTBS_real AND STDB_all)
}

M1_S_6a_AR_TBS {
@ Space between M1 (width = 0.05um) line and PowerRail centerline in SDB design. = 0.077/0.108/0.112/0.126/0.141/0.144/0.172/0.173/0.176/0.19/0.208/0.215/0.263um
 chk_M1 = (ANGLE M1_STD_050_line == 0) NOT OUTSIDE EDGE SDBTBS_real
 err1 = EXT chk_M1 PowerRail_centerline_002 < 0.077-PowerRail_grid ABUT<90 OPPOSITE REGION MEASURE ALL
 err2 = EXT chk_M1 PowerRail_centerline_002 > 0.077-PowerRail_grid < 0.108-PowerRail_grid ABUT<90 OPPOSITE REGION MEASURE ALL
 err3 = EXT chk_M1 PowerRail_centerline_002 > 0.108-PowerRail_grid < 0.112-PowerRail_grid ABUT<90 OPPOSITE REGION MEASURE ALL
 err4 = EXT chk_M1 PowerRail_centerline_002 > 0.112-PowerRail_grid < 0.126-PowerRail_grid ABUT<90 OPPOSITE REGION MEASURE ALL
 err5 = EXT chk_M1 PowerRail_centerline_002 > 0.126-PowerRail_grid < 0.141-PowerRail_grid ABUT<90 OPPOSITE REGION MEASURE ALL
 err6 = EXT chk_M1 PowerRail_centerline_002 > 0.141-PowerRail_grid < 0.144-PowerRail_grid ABUT<90 OPPOSITE REGION MEASURE ALL
 err7 = EXT chk_M1 PowerRail_centerline_002 > 0.144-PowerRail_grid < 0.172-PowerRail_grid ABUT<90 OPPOSITE REGION MEASURE ALL
 err8 = EXT chk_M1 PowerRail_centerline_002 > 0.173-PowerRail_grid < 0.176-PowerRail_grid ABUT<90 OPPOSITE REGION MEASURE ALL
 err9 = EXT chk_M1 PowerRail_centerline_002 > 0.176-PowerRail_grid < 0.190-PowerRail_grid ABUT<90 OPPOSITE REGION MEASURE ALL
 err10 = EXT chk_M1 PowerRail_centerline_002 > 0.190-PowerRail_grid < 0.208-PowerRail_grid ABUT<90 OPPOSITE REGION MEASURE ALL
 err11 = EXT chk_M1 PowerRail_centerline_002 > 0.208-PowerRail_grid < 0.215-PowerRail_grid ABUT<90 OPPOSITE REGION MEASURE ALL
 err12 = EXT chk_M1 PowerRail_centerline_002 > 0.215-PowerRail_grid < 0.263-PowerRail_grid ABUT<90 OPPOSITE REGION MEASURE ALL
//; err13 = (M1_STD_good_050 WITH EDGE chk_M1) NOT WITH EDGE (EXT [chk_M1] PowerRail_centerline_002 <= 0.263-PowerRail_grid ABUT<90 OPPOSITE MEASURE ALL)  //;impossible case

 err1 NOT OUTSIDE (SDBTBS_real AND STDB_all)
 err2 NOT OUTSIDE (SDBTBS_real AND STDB_all)
 err3 NOT OUTSIDE (SDBTBS_real AND STDB_all)
 err4 NOT OUTSIDE (SDBTBS_real AND STDB_all)
 err5 NOT OUTSIDE (SDBTBS_real AND STDB_all)
 err6 NOT OUTSIDE (SDBTBS_real AND STDB_all)
 err7 NOT OUTSIDE (SDBTBS_real AND STDB_all)
 err8 NOT OUTSIDE (SDBTBS_real AND STDB_all)
 err9 NOT OUTSIDE (SDBTBS_real AND STDB_all)
 err10 NOT OUTSIDE (SDBTBS_real AND STDB_all)
 err11 NOT OUTSIDE (SDBTBS_real AND STDB_all)
 err12 NOT OUTSIDE (SDBTBS_real AND STDB_all)
//; err13 NOT OUTSIDE (SDBTBS_real AND STDB_all)
}

M1_S_6b_TBS {
@ Space between M1 (width = 0.05um) centerline and GT centerline in DDB design. = 0/0.009/0.019/0.026/0.037/0.048um
 chk_M1 = INT (ANGLE M1_STD_050_line == 90) == 0.050 ABUT<90 OPPOSITE REGION CENTERLINE 0.0002
 chk_GT = INT GT <= 0.024 OPPOSITE REGION CENTERLINE 0.0002  //;based on GT_W_1_TBS
 err1 = EXT chk_M1 chk_GT < 0.009-0.0002 ABUT<90 OPPOSITE REGION MEASURE ALL
 err2 = EXT chk_M1 chk_GT > 0.009-0.0002 < 0.019-0.0002 ABUT<90 OPPOSITE REGION MEASURE ALL
 err3 = EXT chk_M1 chk_GT > 0.019-0.0002 < 0.026-0.0002 ABUT<90 OPPOSITE REGION MEASURE ALL
 err4 = EXT chk_M1 chk_GT > 0.026-0.0002 < 0.037-0.0002 ABUT<90 OPPOSITE REGION MEASURE ALL
 err5 = EXT chk_M1 chk_GT > 0.037-0.0002 < 0.048-0.0002 ABUT<90 OPPOSITE REGION MEASURE ALL
 err6 = chk_M1 NOT WITH EDGE ((EXT [chk_M1] chk_GT <= 0.048-0.0002 ABUT<90 OPPOSITE MEASURE ALL) OR EDGE (chk_M1 INSIDE EDGE chk_GT))

 err1 NOT OUTSIDE (DDBTBS_real AND STDB_all)
 err2 NOT OUTSIDE (DDBTBS_real AND STDB_all)
 err3 NOT OUTSIDE (DDBTBS_real AND STDB_all)
 err4 NOT OUTSIDE (DDBTBS_real AND STDB_all)
 err5 NOT OUTSIDE (DDBTBS_real AND STDB_all)
 err6 NOT OUTSIDE (DDBTBS_real AND STDB_all)
}

M1_S_6b_AR_TBS {
@ Space between M1 (width = 0.05um) centerline and GT centerline in SDB design. = 0/0.009/0.01/0.012/0.016/0.019/0.026/0.045/0.048um
 chk_M1 = INT (ANGLE M1_STD_050_line == 90) == 0.050 ABUT<90 OPPOSITE REGION CENTERLINE 0.0002
 chk_GT = INT GT <= 0.024 OPPOSITE REGION CENTERLINE 0.0002  //;based on GT_W_1_TBS
 err1 = EXT chk_M1 chk_GT < 0.009-0.0002 ABUT<90 OPPOSITE REGION MEASURE ALL
 err2 = EXT chk_M1 chk_GT > 0.010-0.0002 < 0.012-0.0002 ABUT<90 OPPOSITE REGION MEASURE ALL
 err3 = EXT chk_M1 chk_GT > 0.012-0.0002 < 0.016-0.0002 ABUT<90 OPPOSITE REGION MEASURE ALL
 err4 = EXT chk_M1 chk_GT > 0.016-0.0002 < 0.019-0.0002 ABUT<90 OPPOSITE REGION MEASURE ALL
 err5 = EXT chk_M1 chk_GT > 0.019-0.0002 < 0.026-0.0002 ABUT<90 OPPOSITE REGION MEASURE ALL
 err6 = EXT chk_M1 chk_GT > 0.026-0.0002 < 0.045-0.0002 ABUT<90 OPPOSITE REGION MEASURE ALL
 err7 = EXT chk_M1 chk_GT > 0.045-0.0002 < 0.048-0.0002 ABUT<90 OPPOSITE REGION MEASURE ALL
 err8 = chk_M1 NOT WITH EDGE ((EXT [chk_M1] chk_GT <= 0.048-0.0002 ABUT<90 OPPOSITE MEASURE ALL) OR EDGE (chk_M1 INSIDE EDGE chk_GT))

 err1 NOT OUTSIDE (SDBTBS_real AND STDB_all)
 err2 NOT OUTSIDE (SDBTBS_real AND STDB_all)
 err3 NOT OUTSIDE (SDBTBS_real AND STDB_all)
 err4 NOT OUTSIDE (SDBTBS_real AND STDB_all)
 err5 NOT OUTSIDE (SDBTBS_real AND STDB_all)
 err6 NOT OUTSIDE (SDBTBS_real AND STDB_all)
 err7 NOT OUTSIDE (SDBTBS_real AND STDB_all)
 err8 NOT OUTSIDE (SDBTBS_real AND STDB_all)
}

M1_S_6c_EX_5a_9T_TBS {
@ M1.S.6c.9TBS: Space between M1 (width = 0.05um) line-end and PowerRail centerline in 9T DDB design = 0.087/0.151/0.183/0.215/0.247/0.279um
@ M1.EX.5a.9TBS: M1 (width = 0.05um) line-end extension PowerRail centerline in 9T DDB design = 0.265um
 CHK_AREA = DDBTBS_real AND STDB_all
 chk_M1 = ANGLE M1_STD_050_end == 0
 good_1 = EXT (chk_M1) PowerRail_centerline_002 == 0.087-PowerRail_grid ABUT<90 OPPOSITE
 good_2 = EXT (good_1) PowerRail_centerline_002 == 0.151-PowerRail_grid ABUT<90 OPPOSITE
 good_3 = EXT (good_2) PowerRail_centerline_002 == 0.183-PowerRail_grid ABUT<90 OPPOSITE
 good_4 = EXT (good_3) PowerRail_centerline_002 == 0.215-PowerRail_grid ABUT<90 OPPOSITE
 good_5 = EXT (good_4) PowerRail_centerline_002 == 0.247-PowerRail_grid ABUT<90 OPPOSITE
 good_6 = EXT (good_5) PowerRail_centerline_002 == 0.279-PowerRail_grid ABUT<90 OPPOSITE
 good_7 = ENC PowerRail_centerline_002 (good_6) == 0.265-PowerRail_grid ABUT<90 OPPOSITE MEASURE ALL
 err1 = good_7 NOT OUTSIDE EDGE PowerRail_Area_90T
 err1 NOT OUTSIDE EDGE CHK_AREA
}

M1_S_6c_EX_5a_75T_TBS {
@ M1.S.6c.7TBS: Space between M1 (width = 0.05um) line-end and PowerRail centerline in 7.5T DDB design = 0.087/0.119/0.151/0.175/0.183/0.215um
@ M1.EX.5a.7TBS: M1 (width = 0.05um) line-end extension PowerRail centerline in 7.5T DDB design = 0.236um
 CHK_AREA = DDBTBS_real AND STDB_all
 chk_M1 = ANGLE M1_STD_050_end == 0
 good_1 = EXT (chk_M1) PowerRail_centerline_002 == 0.087-PowerRail_grid ABUT<90 OPPOSITE
 good_2 = EXT (good_1) PowerRail_centerline_002 == 0.119-PowerRail_grid ABUT<90 OPPOSITE
 good_3 = EXT (good_2) PowerRail_centerline_002 == 0.151-PowerRail_grid ABUT<90 OPPOSITE
 good_4 = EXT (good_3) PowerRail_centerline_002 == 0.175-PowerRail_grid ABUT<90 OPPOSITE
 good_5 = EXT (good_4) PowerRail_centerline_002 == 0.183-PowerRail_grid ABUT<90 OPPOSITE
 good_6 = EXT (good_5) PowerRail_centerline_002 == 0.215-PowerRail_grid ABUT<90 OPPOSITE
 good_7 = ENC PowerRail_centerline_002 (good_6) == 0.236-PowerRail_grid ABUT<90 OPPOSITE MEASURE ALL
 err1 = good_7 NOT OUTSIDE EDGE PowerRail_Area_75T
 err1 NOT OUTSIDE EDGE CHK_AREA
}

M1_S_6c_EX_5a_AR_TBS {
@ M1.S.6c.ARTBS: Space between M1 (width = 0.050um) line-end and PowerRail centerline in SDB design = 0.087/0.109/0.119/0.151/0.175/0.183/0.199/0.215/0.247/0.279um
@ M1.EX.5a.ARTBS: M1 (width = 0.050um) line-end extension PowerRail centerline in SDB design = 0.233/0.236/0.265um
 chk_M1 = (ANGLE M1_STD_050_end == 0) NOT OUTSIDE EDGE SDBTBS_real
 good_1 = EXT (chk_M1) PowerRail_centerline_002 == 0.087-PowerRail_grid ABUT<90 OPPOSITE
 good_2 = EXT (good_1) PowerRail_centerline_002 == 0.109-PowerRail_grid ABUT<90 OPPOSITE
 good_3 = EXT (good_2) PowerRail_centerline_002 == 0.119-PowerRail_grid ABUT<90 OPPOSITE
 good_4 = EXT (good_3) PowerRail_centerline_002 == 0.151-PowerRail_grid ABUT<90 OPPOSITE
 good_5 = EXT (good_4) PowerRail_centerline_002 == 0.175-PowerRail_grid ABUT<90 OPPOSITE
 good_6 = EXT (good_5) PowerRail_centerline_002 == 0.183-PowerRail_grid ABUT<90 OPPOSITE
 good_7 = EXT (good_6) PowerRail_centerline_002 == 0.199-PowerRail_grid ABUT<90 OPPOSITE
 good_8 = EXT (good_7) PowerRail_centerline_002 == 0.215-PowerRail_grid ABUT<90 OPPOSITE
 good_9 = EXT (good_8) PowerRail_centerline_002 == 0.247-PowerRail_grid ABUT<90 OPPOSITE
 good_10 = EXT (good_9) PowerRail_centerline_002 == 0.279-PowerRail_grid ABUT<90 OPPOSITE

 good_11 = ENC PowerRail_centerline_002 (good_10) == 0.233-PowerRail_grid ABUT<90 OPPOSITE MEASURE ALL
 good_12 = ENC PowerRail_centerline_002 (good_11) == 0.236-PowerRail_grid ABUT<90 OPPOSITE MEASURE ALL
 good_13 = ENC PowerRail_centerline_002 (good_12) == 0.265-PowerRail_grid ABUT<90 OPPOSITE MEASURE ALL
 err1 = good_13 NOT OUTSIDE EDGE STDB_all
 err1 NOT OUTSIDE EDGE SDBTBS_real
}

M1_S_6d_EX_5b_9T_TBS {
@ M1.S.6d.9TBS: Space between M1 (width = 0.05um) line-end and GT centerline in 9T DDB design = 0.007/0.020/0.029/0.030/0.039/0.048um
@ M1.EX.5b.9TBS: M1 (width = 0.05um) line-end extension GT centerline in 9T DDB design = 0.007/0.015um
 CHK_AREA = DDBTBS_real AND STDB_all
 chk_M1 = ANGLE M1_STD_050_end == 90
 chk_GT = INT GT <= 0.024 OPPOSITE REGION CENTERLINE 0.0002  //;based on GT_W_1_TBS
 good_ext_1 = EXT [chk_M1] chk_GT == 0.007-0.0001 ABUT<90 OPPOSITE MEASURE ALL
 good_ext_2 = EXT [chk_M1] chk_GT == 0.020-0.0001 ABUT<90 OPPOSITE MEASURE ALL
 good_ext_3 = EXT [chk_M1] chk_GT == 0.029-0.0001 ABUT<90 OPPOSITE MEASURE ALL
 good_ext_4 = EXT [chk_M1] chk_GT == 0.030-0.0001 ABUT<90 OPPOSITE MEASURE ALL
 good_ext_5 = EXT [chk_M1] chk_GT == 0.039-0.0001 ABUT<90 OPPOSITE MEASURE ALL
 good_ext_6 = EXT [chk_M1] chk_GT == 0.048-0.0001 ABUT<90 OPPOSITE MEASURE ALL
 good_enc_1 = ENC chk_GT [chk_M1] == 0.007-0.0001 ABUT<90 OPPOSITE
 good_enc_2 = ENC chk_GT [chk_M1] == 0.015-0.0001 ABUT<90 OPPOSITE
 good_ext = OR EDGE (OR EDGE (good_ext_1 OR EDGE good_ext_2) (good_ext_3 OR EDGE good_ext_4)) (good_ext_5 OR EDGE good_ext_6)
 good_enc = OR EDGE good_enc_1 good_enc_2

 err1 = ((chk_M1 NOT COIN EDGE good_ext) NOT COIN EDGE good_enc) NOT OUTSIDE EDGE PowerRail_Area_90T
 err1 NOT OUTSIDE EDGE CHK_AREA
}

M1_S_6d_EX_5b_75T_TBS {
@ M1.S.6d.7TBS: Space between M1 (width = 0.05um) line-end and GT centerline in 7.5T DDB design = 0.007/0.029/0.030/0.039/0.048um
@ M1.EX.5b.7TBS: M1 (width = 0.05um) line-end extension GT centerline in 7.5T DDB design = 0.015um
 CHK_AREA = DDBTBS_real AND STDB_all
 chk_M1 = ANGLE M1_STD_050_end == 90
 chk_GT = INT GT <= 0.024 OPPOSITE REGION CENTERLINE 0.0002  //;based on GT_W_1_TBS
 good_ext_1 = EXT [chk_M1] chk_GT == 0.007-0.0001 ABUT<90 OPPOSITE MEASURE ALL
 good_ext_2 = EXT [chk_M1] chk_GT == 0.029-0.0001 ABUT<90 OPPOSITE MEASURE ALL
 good_ext_3 = EXT [chk_M1] chk_GT == 0.030-0.0001 ABUT<90 OPPOSITE MEASURE ALL
 good_ext_4 = EXT [chk_M1] chk_GT == 0.039-0.0001 ABUT<90 OPPOSITE MEASURE ALL
 good_ext_5 = EXT [chk_M1] chk_GT == 0.048-0.0001 ABUT<90 OPPOSITE MEASURE ALL
 good_enc = ENC chk_GT [chk_M1] == 0.015-0.0001 ABUT<90 OPPOSITE
 good_ext = OR EDGE (OR EDGE (good_ext_1 OR EDGE good_ext_2) (good_ext_3 OR EDGE good_ext_4)) good_ext_5

 err1 = ((chk_M1 NOT COIN EDGE good_ext) NOT COIN EDGE good_enc) NOT OUTSIDE EDGE PowerRail_Area_75T
 err1 NOT OUTSIDE EDGE CHK_AREA
}

M1_S_6d_EX_5b_AR_TBS {
@ M1.S.6d.ARTBS: Space between M1 (width = 0.050um) line-end and GT centerline in SDB design = 0.002/0.004/0.007/0.013/0.015/0.023/0.029/0.033/0.034um
@ M1.EX.5b.ARTBS: M1 (width = 0.050um) line-end extension GT centerline in SDB design = 0.015/0.026/0.033/0.043/0.044um
 chk_M1 = (ANGLE M1_STD_050_end == 90) NOT OUTSIDE EDGE SDBTBS_real
 chk_GT = INT GT <= 0.024 OPPOSITE REGION CENTERLINE 0.0002  //;based on GT_W_1_TBS
 good_1 = EXT (chk_M1) chk_GT == 0.002-0.0001 ABUT<90 OPPOSITE
 good_2 = EXT (good_1) chk_GT == 0.004-0.0001 ABUT<90 OPPOSITE
 good_3 = EXT (good_2) chk_GT == 0.007-0.0001 ABUT<90 OPPOSITE
 good_4 = EXT (good_3) chk_GT == 0.013-0.0001 ABUT<90 OPPOSITE
 good_5 = EXT (good_4) chk_GT == 0.015-0.0001 ABUT<90 OPPOSITE
 good_6 = EXT (good_5) chk_GT == 0.023-0.0001 ABUT<90 OPPOSITE
 good_7 = EXT (good_6) chk_GT == 0.029-0.0001 ABUT<90 OPPOSITE
 good_8 = EXT (good_7) chk_GT == 0.033-0.0001 ABUT<90 OPPOSITE
 good_9 = EXT (good_8) chk_GT == 0.034-0.0001 ABUT<90 OPPOSITE
 good_10 = ENC chk_GT (good_9) == 0.015-0.0001 ABUT<90 OPPOSITE
 good_11 = ENC chk_GT (good_10) == 0.026-0.0001 ABUT<90 OPPOSITE
 good_12 = ENC chk_GT (good_11) == 0.033-0.0001 ABUT<90 OPPOSITE
 good_13 = ENC chk_GT (good_12) == 0.043-0.0001 ABUT<90 OPPOSITE
 err1 = ENC chk_GT (good_13) == 0.044-0.0001 ABUT<90 OPPOSITE
 err1 NOT OUTSIDE EDGE SDBTBS_real
}

M1_S_15a_EX_11_AR_TBS {
@ M1.S.15a.ARTBS: Space between M1 (width = 0.058um) line-end and PowerRail centerline in SDB design = 0.151/0.183/0.199um
@ M1.EX.11.ARTBS: M1 (width = 0.058um) line-end extension PowerRail centerline SDBTBS = 0.236um
 CHK_AREA = SDBTBS_real AND STDB_all
 chk_M1 = (ANGLE M1_STD_058_end == 0) NOT OUTSIDE EDGE SDBTBS_real
 good_1 = EXT (chk_M1) PowerRail_centerline_002 == 0.151-PowerRail_grid ABUT<90 OPPOSITE
 good_2 = EXT (good_1) PowerRail_centerline_002 == 0.183-PowerRail_grid ABUT<90 OPPOSITE
 good_3 = EXT (good_2) PowerRail_centerline_002 == 0.199-PowerRail_grid ABUT<90 OPPOSITE
 err1 = ENC PowerRail_centerline_002 (good_3) == 0.236-PowerRail_grid ABUT<90 OPPOSITE MEASURE ALL
 err1 NOT OUTSIDE EDGE CHK_AREA
}

M1_S_15b_AR_TBS {
@ Space between M1 (width = 0.058um) centerline and GT centerline in SDB design. = 0.035um
 chk_M1 = INT (ANGLE M1_STD_058_line == 90) == 0.058 ABUT<90 OPPOSITE REGION CENTERLINE 0.0002
 chk_GT = INT GT <= 0.024 OPPOSITE REGION CENTERLINE 0.0002  //;based on GT_W_1_TBS
 err1 = EXT chk_M1 chk_GT < 0.035-0.0002 ABUT<90 OPPOSITE REGION MEASURE ALL
 err2 = chk_M1 NOT WITH EDGE ((EXT [chk_M1] chk_GT <= 0.035-0.0002 ABUT<90 OPPOSITE MEASURE ALL) OR EDGE (chk_M1 COIN INSIDE EDGE chk_GT))

 err1 NOT OUTSIDE SDBTBS_real
 err2 NOT OUTSIDE SDBTBS_real
}

M1_S_16a_AR_TBS {
@ Space between M1 (width = 0.063um) line and PowerRail centerline in SDB design. = 0.077um
 chk_M1 = (ANGLE M1_STD_063_line == 0) NOT OUTSIDE EDGE SDBTBS_real
 err1 = EXT chk_M1 PowerRail_centerline_002 < 0.077-PowerRail_grid ABUT<90 OPPOSITE REGION MEASURE ALL
 err2 = (M1_STD_good_063 WITH EDGE chk_M1) NOT WITH EDGE (EXT [chk_M1] PowerRail_centerline_002 <= 0.077-PowerRail_grid ABUT<90 OPPOSITE MEASURE ALL)

 err1 NOT OUTSIDE (SDBTBS_real AND STDB_all)
 err2 NOT OUTSIDE (SDBTBS_real AND STDB_all)
}

M1_S_16b_AR_TBS {
@ Space between M1 (width = 0.063um) line-end and GT centerline in SDB design. = 0.004um
 chk_M1 = ANGLE M1_STD_063_end == 90
 chk_GT = INT GT <= 0.024 OPPOSITE REGION CENTERLINE 0.0002  //;based on GT_W_1_TBS
 err1 = EXT chk_M1 chk_GT < 0.004-0.0001 ABUT<90 OPPOSITE REGION MEASURE ALL
 err2 = chk_M1 NOT TOUCH EDGE ((EXT [chk_M1] chk_GT <= 0.004-0.0001 ABUT<90 OPPOSITE MEASURE ALL) OR EDGE (chk_M1 COIN INSIDE EDGE chk_GT))

 err1 NOT OUTSIDE SDBTBS_real
 err2 NOT OUTSIDE EDGE SDBTBS_real
}

M1_S_7a_9T_TBS {
@ Space between M1 (width = 0.064um) line and PowerRail centerline in 9T DDB design. = 0.144/0.256um
 chk_M1 = (ANGLE M1_STD_064_line == 0) NOT OUTSIDE EDGE PowerRail_Area_90T
 err1 = EXT chk_M1 PowerRail_centerline_002 < 0.144-PowerRail_grid ABUT<90 OPPOSITE REGION MEASURE ALL
 err2 = EXT chk_M1 PowerRail_centerline_002 > 0.144-PowerRail_grid < 0.256-PowerRail_grid ABUT<90 OPPOSITE REGION MEASURE ALL
//; err3 = (M1_STD_good_064 WITH EDGE chk_M1) NOT WITH EDGE (EXT [chk_M1] PowerRail_centerline_002 <= 0.256-PowerRail_grid ABUT<90 OPPOSITE MEASURE ALL) //;impossible case

 err1 NOT OUTSIDE (DDBTBS_real AND STDB_all)
 err2 NOT OUTSIDE (DDBTBS_real AND STDB_all)
//; err3 NOT OUTSIDE (DDBTBS_real AND STDB_all)
}

M1_S_7a_75T_TBS {
@ Space between M1 (width = 0.064um) line and PowerRail centerline in 7.5T DDB design. = 0.208um
 chk_M1 = (ANGLE M1_STD_064_line == 0) NOT OUTSIDE EDGE PowerRail_Area_75T
 err1 = EXT chk_M1 PowerRail_centerline_002 < 0.208-PowerRail_grid ABUT<90 OPPOSITE REGION MEASURE ALL
//; err2 = (M1_STD_good_064 WITH EDGE chk_M1) NOT WITH EDGE (EXT [chk_M1] PowerRail_centerline_002 <= 0.208-PowerRail_grid ABUT<90 OPPOSITE MEASURE ALL)  //;impossible case

 err1 NOT OUTSIDE (DDBTBS_real AND STDB_all)
//; err2 NOT OUTSIDE (DDBTBS_real AND STDB_all)
}

M1_S_7a_AR_TBS {
@ Space between M1 (width = 0.064um) line and PowerRail centerline in SDB design. = 0.077/0.144/0.208/0.256um
 chk_M1 = (ANGLE M1_STD_064_line == 0) NOT OUTSIDE EDGE SDBTBS_real
 err1 = EXT chk_M1 PowerRail_centerline_002 < 0.077-PowerRail_grid ABUT<90 OPPOSITE REGION MEASURE ALL
 err2 = EXT chk_M1 PowerRail_centerline_002 > 0.077-PowerRail_grid < 0.144-PowerRail_grid ABUT<90 OPPOSITE REGION MEASURE ALL
 err3 = EXT chk_M1 PowerRail_centerline_002 > 0.144-PowerRail_grid < 0.208-PowerRail_grid ABUT<90 OPPOSITE REGION MEASURE ALL
 err4 = EXT chk_M1 PowerRail_centerline_002 > 0.208-PowerRail_grid < 0.256-PowerRail_grid ABUT<90 OPPOSITE REGION MEASURE ALL

 err1 NOT OUTSIDE (SDBTBS_real AND STDB_all)
 err2 NOT OUTSIDE (SDBTBS_real AND STDB_all)
 err3 NOT OUTSIDE (SDBTBS_real AND STDB_all)
 err4 NOT OUTSIDE (SDBTBS_real AND STDB_all)
}

M1_S_7b_9T_TBS {
@ Space between M1 (width = 0.064um) centerline and GT centerline in 9T DDB design = 0.048um
 chk_M1 = INT (ANGLE M1_STD_064_line == 90) == 0.064 ABUT<90 OPPOSITE REGION CENTERLINE 0.0002
 chk_GT = INT GT <= 0.024 OPPOSITE REGION CENTERLINE 0.0002  //;based on GT_W_1_TBS
 err1 = (EXT chk_M1 chk_GT < 0.048-0.0002 ABUT<90 OPPOSITE REGION MEASURE ALL) NOT OUTSIDE PowerRail_Area_90T
 err2 = (chk_M1 NOT WITH EDGE (EXT [chk_M1] chk_GT <= 0.048-0.0002 ABUT<90 OPPOSITE MEASURE ALL)) NOT OUTSIDE PowerRail_Area_90T

 err1 NOT OUTSIDE (DDBTBS_real AND STDB_all)
 err2 NOT OUTSIDE (DDBTBS_real AND STDB_all)
}

M1_S_7b_75T_TBS {
@ Space between M1 (width = 0.064um) centerline and GT centerline in 7.5T DDB design = 0.009/0.012/0.019/0.048um
 chk_M1 = INT (ANGLE M1_STD_064_line == 90) == 0.064 ABUT<90 OPPOSITE REGION CENTERLINE 0.0002
 chk_GT = INT GT <= 0.024 OPPOSITE REGION CENTERLINE 0.0002  //;based on GT_W_1_TBS
 err1 = (EXT chk_M1 chk_GT < 0.009-0.0002 ABUT<90 OPPOSITE REGION MEASURE ALL) NOT OUTSIDE PowerRail_Area_75T
 err2 = (EXT chk_M1 chk_GT > 0.009-0.0002 < 0.012-0.0002 ABUT<90 OPPOSITE REGION MEASURE ALL) NOT OUTSIDE PowerRail_Area_75T
 err3 = (EXT chk_M1 chk_GT > 0.012-0.0002 < 0.019-0.0002 ABUT<90 OPPOSITE REGION MEASURE ALL) NOT OUTSIDE PowerRail_Area_75T
 err4 = (EXT chk_M1 chk_GT > 0.019-0.0002 < 0.048-0.0002 ABUT<90 OPPOSITE REGION MEASURE ALL) NOT OUTSIDE PowerRail_Area_75T
 err5 = (chk_M1 NOT WITH EDGE (EXT [chk_M1] chk_GT <= 0.048-0.0002 ABUT<90 OPPOSITE MEASURE ALL)) NOT OUTSIDE PowerRail_Area_75T

 err1 NOT OUTSIDE (DDBTBS_real AND STDB_all)
 err2 NOT OUTSIDE (DDBTBS_real AND STDB_all)
 err3 NOT OUTSIDE (DDBTBS_real AND STDB_all)
 err4 NOT OUTSIDE (DDBTBS_real AND STDB_all)
 err5 NOT OUTSIDE (DDBTBS_real AND STDB_all)
}

M1_S_7b_AR_TBS {
@ Space between M1 (width = 0.064um) centerline and GT centerline in SDB design. = 0.007/0.01/0.012/0.019/0.026/0.045/um
 chk_M1 = INT (ANGLE M1_STD_064_line == 90) == 0.064 ABUT<90 OPPOSITE REGION CENTERLINE 0.0002
 chk_GT = INT GT <= 0.024 OPPOSITE REGION CENTERLINE 0.0002  //;based on GT_W_1_TBS
 err1 = EXT chk_M1 chk_GT < 0.007-0.0002 ABUT<90 OPPOSITE REGION MEASURE ALL
 err2 = EXT chk_M1 chk_GT > 0.007-0.0002 < 0.010-0.0002 ABUT<90 OPPOSITE REGION MEASURE ALL
 err3 = EXT chk_M1 chk_GT > 0.010-0.0002 < 0.012-0.0002 ABUT<90 OPPOSITE REGION MEASURE ALL
 err4 = EXT chk_M1 chk_GT > 0.012-0.0002 < 0.019-0.0002 ABUT<90 OPPOSITE REGION MEASURE ALL
 err5 = EXT chk_M1 chk_GT > 0.019-0.0002 < 0.026-0.0002 ABUT<90 OPPOSITE REGION MEASURE ALL
 err6 = EXT chk_M1 chk_GT > 0.026-0.0002 < 0.045-0.0002 ABUT<90 OPPOSITE REGION MEASURE ALL
 err7 = chk_M1 NOT WITH EDGE (EXT [chk_M1] chk_GT <= 0.045-0.0002 ABUT<90 OPPOSITE MEASURE ALL)

 err1 NOT OUTSIDE (SDBTBS_real AND STDB_all)
 err2 NOT OUTSIDE (SDBTBS_real AND STDB_all)
 err3 NOT OUTSIDE (SDBTBS_real AND STDB_all)
 err4 NOT OUTSIDE (SDBTBS_real AND STDB_all)
 err5 NOT OUTSIDE (SDBTBS_real AND STDB_all)
 err6 NOT OUTSIDE (SDBTBS_real AND STDB_all)
 err7 NOT OUTSIDE (SDBTBS_real AND STDB_all)
}

M1_S_7c_EX_6a_9T_TBS {
@ M1.S.7c.9TBS: Space between M1 (width = 0.064um) line-end and PowerRail centerline in 9T DDB design
@ DRC flag all M1 (width = 0.064um) line-end space to PowerRail centerline = \um
@ M1.EX.6a.9TBS: M1 (width = 0.064um) line-end extension PowerRail centerline in 9T DDB design = 0.208um
 CHK_AREA = DDBTBS_real AND STDB_all
 chk_M1 = (ANGLE M1_STD_064_end == 0) NOT OUTSIDE EDGE PowerRail_Area_90T
 err1 = ENC PowerRail_centerline_002 (chk_M1) == 0.208-PowerRail_grid ABUT<90 OPPOSITE MEASURE ALL
 err1 NOT OUTSIDE EDGE CHK_AREA
}

M1_S_7c_EX_6a_75T_TBS {
@ M1.S.7c.7TBS: Space between M1 (width = 0.064um) line-end and PowerRail centerline in 7.5T DDB design = 0.087/0.175/0.208um
@ M1.EX.6a.7TBS: M1 (width = 0.064um) line-end extension PowerRail centerline in 7.5T DDB design = 0.144/0.176um
 CHK_AREA = DDBTBS_real AND STDB_all
 chk_M1 = (ANGLE M1_STD_064_end == 0) NOT OUTSIDE EDGE PowerRail_Area_75T
 good_1 = EXT (chk_M1) PowerRail_centerline_002 == 0.087-PowerRail_grid ABUT<90 OPPOSITE
 good_2 = EXT (good_1) PowerRail_centerline_002 == 0.175-PowerRail_grid ABUT<90 OPPOSITE
 good_3 = EXT (good_2) PowerRail_centerline_002 == 0.208-PowerRail_grid ABUT<90 OPPOSITE
 good_4 = ENC PowerRail_centerline_002 (good_3) == 0.144-PowerRail_grid ABUT<90 OPPOSITE MEASURE ALL
 good_5 = ENC PowerRail_centerline_002 (good_4) == 0.176-PowerRail_grid ABUT<90 OPPOSITE MEASURE ALL
 err1 = good_5 NOT OUTSIDE EDGE PowerRail_Area_75T
 err1 NOT OUTSIDE EDGE CHK_AREA
}

M1_S_7c_EX_6a_AR_TBS {
@ M1.S.7c.ARTBS: Space between M1 (width = 0.064um) line-end and PowerRail centerline in SDB design = 0.119/0.191/0.223/0.239/0.255um
@ M1.EX.6a.ARTBS: M1 (width = 0.064um) line-end extension PowerRail centerline in SDB design = 0.141/0.225/0.273um
 CHK_AREA = SDBTBS_real AND STDB_all
 chk_M1 = (ANGLE M1_STD_064_end == 0) NOT OUTSIDE EDGE SDBTBS_real
 good_1 = EXT (chk_M1) PowerRail_centerline_002 == 0.119-PowerRail_grid ABUT<90 OPPOSITE
 good_2 = EXT (good_1) PowerRail_centerline_002 == 0.191-PowerRail_grid ABUT<90 OPPOSITE
 good_3 = EXT (good_2) PowerRail_centerline_002 == 0.223-PowerRail_grid ABUT<90 OPPOSITE
 good_4 = EXT (good_3) PowerRail_centerline_002 == 0.239-PowerRail_grid ABUT<90 OPPOSITE
 good_5 = EXT (good_4) PowerRail_centerline_002 == 0.255-PowerRail_grid ABUT<90 OPPOSITE
 good_6 = ENC PowerRail_centerline_002 (good_5) == 0.141-PowerRail_grid ABUT<90 OPPOSITE MEASURE ALL
 good_7 = ENC PowerRail_centerline_002 (good_6) == 0.225-PowerRail_grid ABUT<90 OPPOSITE MEASURE ALL
 good_8 = ENC PowerRail_centerline_002 (good_7) == 0.273-PowerRail_grid ABUT<90 OPPOSITE MEASURE ALL
 err1 = good_8 NOT OUTSIDE EDGE STDB_all
 err1 NOT OUTSIDE EDGE CHK_AREA
}

M1_S_7d_EX_6b_9T_TBS {
@ M1.S.7d.9TBS: Space between M1 (width = 0.064um) line-end and GT centerline in 9T DDB design = 0.016um
@ M1.EX.6b.9TBS: M1 (width = 0.064um) line-end extension GT centerline in 9T DDB design = 0.023/0.034um
 CHK_AREA = DDBTBS_real AND STDB_all
 chk_M1 = (ANGLE M1_STD_064_end == 90) NOT OUTSIDE EDGE PowerRail_Area_90T
 chk_GT = INT GT <= 0.024 OPPOSITE REGION CENTERLINE 0.0002  //;based on GT_W_1_TBS
 good_1 = EXT (chk_M1) chk_GT == 0.016-0.0001 ABUT<90 OPPOSITE MEASURE ALL
 good_2 = ENC chk_GT (good_1) == 0.023-0.0001 ABUT<90 OPPOSITE
 good_3 = ENC chk_GT (good_2) == 0.034-0.0001 ABUT<90 OPPOSITE
 err1 = good_3 NOT OUTSIDE EDGE PowerRail_Area_90T
 err1 NOT OUTSIDE EDGE CHK_AREA
}

M1_S_7d_EX_6b_75T_TBS {
@ M1.S.7d.7TBS: Space between M1 (width = 0.064um) line-end and GT centerline in 7.5T DDB design = 0.009/0.020/0.023um
@ M1.EX.6b.7TBS: M1 (width = 0.064um) line-end extension GT centerline in 7.5T DDB design = 0.006/0.013/0.032/0.034/0.035/0.044um
 CHK_AREA = DDBTBS_real AND STDB_all
 chk_M1 = (ANGLE M1_STD_064_end == 90) NOT OUTSIDE EDGE PowerRail_Area_75T
 chk_GT = INT GT <= 0.024 OPPOSITE REGION CENTERLINE 0.0002  //;based on GT_W_1_TBS
 good_ext_1 = EXT [chk_M1] chk_GT == 0.009-0.0001 ABUT<90 OPPOSITE MEASURE ALL
 good_ext_2 = EXT [chk_M1] chk_GT == 0.020-0.0001 ABUT<90 OPPOSITE MEASURE ALL
 good_ext_3 = EXT [chk_M1] chk_GT == 0.023-0.0001 ABUT<90 OPPOSITE MEASURE ALL
 good_enc_1 = ENC chk_GT [chk_M1] == 0.006-0.0001 ABUT<90 OPPOSITE
 good_enc_2 = ENC chk_GT [chk_M1] == 0.013-0.0001 ABUT<90 OPPOSITE
 good_enc_3 = ENC chk_GT [chk_M1] == 0.032-0.0001 ABUT<90 OPPOSITE
 good_enc_4 = ENC chk_GT [chk_M1] == 0.034-0.0001 ABUT<90 OPPOSITE
 good_enc_5 = ENC chk_GT [chk_M1] == 0.035-0.0001 ABUT<90 OPPOSITE
 good_enc_6 = ENC chk_GT [chk_M1] == 0.044-0.0001 ABUT<90 OPPOSITE
 good_enc = OR EDGE (OR EDGE (OR EDGE good_enc_1 good_enc_2) (OR EDGE good_enc_3 good_enc_4)) (OR EDGE good_enc_5 good_enc_6)
 good_ext = OR EDGE (OR EDGE good_ext_1 good_ext_2) good_ext_3

 err1 = ((chk_M1 NOT COIN EDGE good_ext) NOT COIN EDGE good_enc) NOT OUTSIDE EDGE PowerRail_Area_75T
 err1 NOT OUTSIDE EDGE CHK_AREA
}

M1_S_7d_EX_6b_AR_TBS {
@ M1.S.7d.ARTBS: Space between M1 (width = 0.064um) line-end and GT centerline in SDB design = 0.013/0.022/0.032um
@ M1.EX.6b.ARTBS: M1 (width = 0.064um) line-end extension GT centerline in SDB design = 0.006/0.025/0.032/0.034/0.044um
 CHK_AREA = SDBTBS_real AND STDB_all
 chk_M1 = (ANGLE M1_STD_064_end == 90) NOT OUTSIDE EDGE SDBTBS_real
 chk_GT = INT GT <= 0.024 OPPOSITE REGION CENTERLINE 0.0002  //;based on GT_W_1_TBS
 good_1 = EXT (chk_M1) chk_GT == 0.013-0.0001 ABUT<90 OPPOSITE
 good_2 = EXT (good_1) chk_GT == 0.022-0.0001 ABUT<90 OPPOSITE
 good_3 = EXT (good_2) chk_GT == 0.032-0.0001 ABUT<90 OPPOSITE
 good_4 = ENC chk_GT (good_3) == 0.006-0.0001 ABUT<90 OPPOSITE
 good_5 = ENC chk_GT (good_4) == 0.025-0.0001 ABUT<90 OPPOSITE
 good_6 = ENC chk_GT (good_5) == 0.032-0.0001 ABUT<90 OPPOSITE
 good_7 = ENC chk_GT (good_6) == 0.034-0.0001 ABUT<90 OPPOSITE
 good_8 = ENC chk_GT (good_7) == 0.044-0.0001 ABUT<90 OPPOSITE
 err1 = good_8 NOT OUTSIDE EDGE STDB_all
 err1 NOT OUTSIDE EDGE CHK_AREA
}

M1_S_8a_75T_TBS {
@ Space between M1 (width = 0.066um) line and PowerRail centerline in 7.5T DDB design = 0.078/0.110um
 chk_M1 = (ANGLE M1_STD_066_line == 0) NOT OUTSIDE EDGE PowerRail_Area_75T
 err1 = EXT chk_M1 PowerRail_centerline_002 < 0.078-PowerRail_grid ABUT<90 OPPOSITE REGION MEASURE ALL
 err2 = EXT chk_M1 PowerRail_centerline_002 > 0.078-PowerRail_grid < 0.110-PowerRail_grid ABUT<90 OPPOSITE REGION MEASURE ALL
 err3 = (M1_STD_good_066 WITH EDGE chk_M1) NOT WITH EDGE (EXT [chk_M1] PowerRail_centerline_002 <= 0.110-PowerRail_grid ABUT<90 OPPOSITE MEASURE ALL)

 err1 NOT OUTSIDE (DDBTBS_real AND STDB_all)
 err2 NOT OUTSIDE (DDBTBS_real AND STDB_all)
 err3 NOT OUTSIDE (DDBTBS_real AND STDB_all)
}

M1_S_8a_AR_TBS {
@ Space between M1 (width = 0.066um) line and PowerRail centerline in SDB design. = 0.078/0.110um
 chk_M1 = (ANGLE M1_STD_066_line == 0) NOT OUTSIDE EDGE SDBTBS_real
 err1 = EXT chk_M1 PowerRail_centerline_002 < 0.078-PowerRail_grid ABUT<90 OPPOSITE REGION MEASURE ALL
 err2 = EXT chk_M1 PowerRail_centerline_002 > 0.078-PowerRail_grid < 0.110-PowerRail_grid ABUT<90 OPPOSITE REGION MEASURE ALL
 err3 = (M1_STD_good_066 WITH EDGE chk_M1) NOT WITH EDGE (EXT [chk_M1] PowerRail_centerline_002 <= 0.110-PowerRail_grid ABUT<90 OPPOSITE MEASURE ALL)

 err1 NOT OUTSIDE (SDBTBS_real AND STDB_all)
 err2 NOT OUTSIDE (SDBTBS_real AND STDB_all)
 err3 NOT OUTSIDE (SDBTBS_real AND STDB_all)
}

M1_S_8b_EX_7_75T_TBS {
@ M1.S.8b.7TBS: Space between M1 (width = 0.066um) line-end and GT centerline in 7.5T DDB design = 0.016um
@ M1.EX.7.7TBS: M1 (width = 0.066um) line-end extension GT centerline in 7.5T DDB design
@ DRC flag all M1 (width = 0.066um) line-end space to GT centerline. =
 CHK_AREA = DDBTBS_real AND STDB_all
 chk_M1 = (ANGLE M1_STD_066_end == 90) NOT OUTSIDE EDGE PowerRail_Area_75T
 chk_GT = INT GT <= 0.024 OPPOSITE REGION CENTERLINE 0.0002  //;based on GT_W_1_TBS
 err1 = EXT (chk_M1) chk_GT == 0.016-0.0001 ABUT<90 OPPOSITE
 err1 NOT OUTSIDE EDGE CHK_AREA
}

M1_S_8b_EX_7_AR_TBS {
@ M1.S.8b.ARTBS: Space between M1 (width = 0.066um) line-end and GT centerline in SDB design = 0.016um
@ M1.EX.7.ARTBS: M1 (width = 0.066um) line-end extension GT centerline SDBTBS = 0.006/0.018um
 CHK_AREA = SDBTBS_real AND STDB_all
 chk_M1 = (ANGLE M1_STD_066_end == 90) NOT OUTSIDE EDGE SDBTBS_real
 chk_GT = INT GT <= 0.024 OPPOSITE REGION CENTERLINE 0.0002  //;based on GT_W_1_TBS
 good_1 = EXT (chk_M1) chk_GT == 0.016-0.0001 ABUT<90 OPPOSITE
 good_2 = ENC chk_GT (good_1) == 0.006-0.0001 ABUT<90 OPPOSITE
 good_3 = ENC chk_GT (good_2) == 0.018-0.0001 ABUT<90 OPPOSITE
 err1 = good_3 NOT OUTSIDE EDGE SDBTBS_real
 err1 NOT OUTSIDE EDGE CHK_AREA
}

M1_S_9a_75T_TBS {
@ Space between M1 (width = 0.076um) line and PowerRail centerline in 7.5T DDB design = 0.144um
 chk_M1 = (ANGLE M1_STD_076_line == 0) NOT OUTSIDE EDGE PowerRail_Area_75T
 err1 = EXT chk_M1 PowerRail_centerline_002 < 0.144-PowerRail_grid ABUT<90 OPPOSITE REGION MEASURE ALL
 err2 = (M1_STD_good_076 WITH EDGE chk_M1) NOT WITH EDGE (EXT [chk_M1] PowerRail_centerline_002 <= 0.144-PowerRail_grid ABUT<90 OPPOSITE MEASURE ALL)

 err1 NOT OUTSIDE (DDBTBS_real AND STDB_all)
 err2 NOT OUTSIDE (DDBTBS_real AND STDB_all)
}

M1_S_9a_AR_TBS {
@ Space between M1 (width = 0.076um) line and PowerRail centerline in SDB design. = 0.144um
 chk_M1 = (ANGLE M1_STD_076_line == 0) NOT OUTSIDE EDGE SDBTBS_real
 err1 = EXT chk_M1 PowerRail_centerline_002 < 0.144-PowerRail_grid ABUT<90 OPPOSITE REGION MEASURE ALL
 err2 = (M1_STD_good_076 WITH EDGE chk_M1) NOT WITH EDGE (EXT [chk_M1] PowerRail_centerline_002 <= 0.144-PowerRail_grid ABUT<90 OPPOSITE MEASURE ALL)

 err1 NOT OUTSIDE (SDBTBS_real AND STDB_all)
 err2 NOT OUTSIDE (SDBTBS_real AND STDB_all)
}

M1_S_9b_EX_8_75T_TBS {
@ M1.S.9b.7TBS: Space between M1 (width = 0.076um) line-end and GT centerline in 7.5T DDB design = 0.01um
@ M1.EX.8.7TBS: M1 (width = 0.076um) line-end extension GT centerline in 7.5T DDB design = 0.022um
 CHK_AREA = DDBTBS_real AND STDB_all
 chk_M1 = (ANGLE M1_STD_076_end == 90) NOT OUTSIDE EDGE PowerRail_Area_75T
 chk_GT = INT GT <= 0.024 OPPOSITE REGION CENTERLINE 0.0002  //;based on GT_W_1_TBS
 good_1 = EXT (chk_M1) chk_GT == 0.010-0.0001 ABUT<90 OPPOSITE
 good_2 = ENC chk_GT (good_1) == 0.022-0.0001 ABUT<90 OPPOSITE
 err1 = good_2 NOT OUTSIDE EDGE PowerRail_Area_75T
 err1 NOT OUTSIDE EDGE CHK_AREA
}

M1_S_9b_EX_8_AR_TBS {
@ M1.S.9b.ARTBS: Space between M1 (width = 0.076um) line-end and GT centerline in SDB design = 0.01um
@ M1.EX.8.ARTBS: M1 (width = 0.076um) line-end extension GT centerline in SDB design = 0.022um
 CHK_AREA = SDBTBS_real AND STDB_all
 chk_M1 = (ANGLE M1_STD_076_end == 90) NOT OUTSIDE EDGE SDBTBS_real
 chk_GT = INT GT <= 0.024 OPPOSITE REGION CENTERLINE 0.0002  //;based on GT_W_1_TBS
 good_1 = EXT (chk_M1) chk_GT == 0.010-0.0001 ABUT<90 OPPOSITE
 good_2 = ENC chk_GT (good_1) == 0.022-0.0001 ABUT<90 OPPOSITE
 err1 = good_2 NOT OUTSIDE EDGE SDBTBS_real
 err1 NOT OUTSIDE EDGE CHK_AREA
}

M1_EX_12_AR_TBS {
@ M1 (width = 0.077um) line-end extension PowerRail centerline in SDB design. = 0.204um
 chk_M1 = (ANGLE M1_STD_077_end == 0) NOT OUTSIDE EDGE SDBTBS_real
 err1 = ENC PowerRail_centerline_002 (chk_M1) == 0.204-PowerRail_grid ABUT<90 OPPOSITE MEASURE ALL
 err1 NOT OUTSIDE EDGE SDBTBS_real
}

M1_S_17a_AR_TBS {
@ Space between M1 (width = 0.077um) centerline and GT centerline in SDB design. = 0.0315um
 chk_M1 = INT (ANGLE M1_STD_077_line == 90) == 0.077 ABUT<90 OPPOSITE REGION CENTERLINE 0.0002
 chk_GT = INT GT <= 0.024 OPPOSITE REGION CENTERLINE 0.0002  //;based on GT_W_1_TBS
 err1 = EXT chk_M1 chk_GT < 0.0315-0.0001*2 ABUT<90 OPPOSITE REGION MEASURE ALL
 err2 = chk_M1 NOT WITH EDGE (EXT [chk_M1] chk_GT <= 0.0315-0.0001*2 ABUT<90 OPPOSITE MEASURE ALL)

 err1 NOT OUTSIDE (SDBTBS_real AND STDB_all)
 err2 NOT OUTSIDE (SDBTBS_real AND STDB_all)
}

M1_S_10a_9T_TBS {
@ Space between M1 (width = 0.082um) line and PowerRail centerline in 9T DDB design. = 0.092/0.108/0.135/0.247um
 chk_M1 = (ANGLE M1_STD_082_line == 0) NOT OUTSIDE EDGE PowerRail_Area_90T
 err1 = EXT chk_M1 PowerRail_centerline_002 < 0.092-PowerRail_grid ABUT<90 OPPOSITE REGION MEASURE ALL
 err2 = EXT chk_M1 PowerRail_centerline_002 > 0.092-PowerRail_grid < 0.108-PowerRail_grid ABUT<90 OPPOSITE REGION MEASURE ALL
 err3 = EXT chk_M1 PowerRail_centerline_002 > 0.108-PowerRail_grid < 0.135-PowerRail_grid ABUT<90 OPPOSITE REGION MEASURE ALL
 err4 = EXT chk_M1 PowerRail_centerline_002 > 0.135-PowerRail_grid < 0.247-PowerRail_grid ABUT<90 OPPOSITE REGION MEASURE ALL
//; err5 = (M1_STD_good_082 WITH EDGE chk_M1) NOT WITH EDGE (EXT [chk_M1] PowerRail_centerline_002 <= 0.247-PowerRail_grid ABUT<90 OPPOSITE MEASURE ALL)  //;impossible case

 err1 NOT OUTSIDE (DDBTBS_real AND STDB_all)
 err2 NOT OUTSIDE (DDBTBS_real AND STDB_all)
 err3 NOT OUTSIDE (DDBTBS_real AND STDB_all)
 err4 NOT OUTSIDE (DDBTBS_real AND STDB_all)
//; err5 NOT OUTSIDE (DDBTBS_real AND STDB_all)
}

M1_S_10a_75T_TBS {
@ Space between M1 (width = 0.082um) line and PowerRail centerline in 7.5T DDB design. = 0.19um
 chk_M1 = (ANGLE M1_STD_082_line == 0) NOT OUTSIDE EDGE PowerRail_Area_75T
 err1 = EXT chk_M1 PowerRail_centerline_002 < 0.19-PowerRail_grid ABUT<90 OPPOSITE REGION MEASURE ALL
 err2 = (M1_STD_good_082 WITH EDGE chk_M1) NOT WITH EDGE (EXT [chk_M1] PowerRail_centerline_002 <= 0.19-PowerRail_grid ABUT<90 OPPOSITE MEASURE ALL)

 err1 NOT OUTSIDE (DDBTBS_real AND STDB_all)
 err2 NOT OUTSIDE (DDBTBS_real AND STDB_all)
}

M1_S_10a_AR_TBS {
@ Space between M1 (width = 0.082um) line and PowerRail centerline in SDB design. = 0.141/0.199um
 chk_M1 = (ANGLE M1_STD_082_line == 0) NOT OUTSIDE EDGE SDBTBS_real
 err1 = EXT chk_M1 PowerRail_centerline_002 < 0.141-PowerRail_grid ABUT<90 OPPOSITE REGION MEASURE ALL
 err2 = EXT chk_M1 PowerRail_centerline_002 > 0.141-PowerRail_grid < 0.199-PowerRail_grid ABUT<90 OPPOSITE REGION MEASURE ALL
 err3 = (M1_STD_good_082 WITH EDGE chk_M1) NOT WITH EDGE (EXT [chk_M1] PowerRail_centerline_002 <= 0.199-PowerRail_grid ABUT<90 OPPOSITE MEASURE ALL)

 err1 NOT OUTSIDE (SDBTBS_real AND STDB_all)
 err2 NOT OUTSIDE (SDBTBS_real AND STDB_all)
 err3 NOT OUTSIDE (SDBTBS_real AND STDB_all)
}

M1_S_10b_9T_TBS {
@ Space between M1 (width = 0.082um) centerline and GT centerline in 9T DDB design = 0/0.007/0.009/0.019/0.026/0.032/0.035/0.048um
 chk_M1 = (INT (ANGLE M1_STD_082_line == 90) == 0.082 ABUT<90 OPPOSITE REGION CENTERLINE 0.0002) NOT OUTSIDE PowerRail_Area_90T
 chk_GT = INT GT <= 0.024 OPPOSITE REGION CENTERLINE 0.0002  //;based on GT_W_1_TBS
 err1 = EXT chk_M1 chk_GT < 0.007-0.0002 ABUT<90 OPPOSITE REGION MEASURE ALL
 err2 = EXT chk_M1 chk_GT > 0.007-0.0002 < 0.009-0.0002 ABUT<90 OPPOSITE REGION MEASURE ALL
 err3 = EXT chk_M1 chk_GT > 0.009-0.0002 < 0.019-0.0002 ABUT<90 OPPOSITE REGION MEASURE ALL
 err4 = EXT chk_M1 chk_GT > 0.019-0.0002 < 0.026-0.0002 ABUT<90 OPPOSITE REGION MEASURE ALL
 err5 = EXT chk_M1 chk_GT > 0.026-0.0002 < 0.032-0.0002 ABUT<90 OPPOSITE REGION MEASURE ALL
 err6 = EXT chk_M1 chk_GT > 0.032-0.0002 < 0.035-0.0002 ABUT<90 OPPOSITE REGION MEASURE ALL
 err7 = EXT chk_M1 chk_GT > 0.035-0.0002 < 0.048-0.0002 ABUT<90 OPPOSITE REGION MEASURE ALL
 err8 = chk_M1 NOT WITH EDGE ((EXT [chk_M1] chk_GT <= 0.048-0.0002 ABUT<90 OPPOSITE MEASURE ALL) OR EDGE (chk_M1 COIN INSIDE EDGE chk_GT))

 err1 NOT OUTSIDE (DDBTBS_real AND STDB_all)
 err2 NOT OUTSIDE (DDBTBS_real AND STDB_all)
 err3 NOT OUTSIDE (DDBTBS_real AND STDB_all)
 err4 NOT OUTSIDE (DDBTBS_real AND STDB_all)
 err5 NOT OUTSIDE (DDBTBS_real AND STDB_all)
 err6 NOT OUTSIDE (DDBTBS_real AND STDB_all)
 err7 NOT OUTSIDE (DDBTBS_real AND STDB_all)
 err8 NOT OUTSIDE (DDBTBS_real AND STDB_all)
}

M1_S_10b_75T_TBS {
@ Space between M1 (width = 0.082um) centerline and GT centerline in 7.5T DDB design = 0/0.003/0.007/0.009/0.01/0.019/0.025/0.026/0.035/0.048um
 chk_M1 = (INT (ANGLE M1_STD_082_line == 90) == 0.082 ABUT<90 OPPOSITE REGION CENTERLINE 0.0002) NOT OUTSIDE PowerRail_Area_75T
 chk_GT = INT GT <= 0.024 OPPOSITE REGION CENTERLINE 0.0002  //;based on GT_W_1_TBS
 err1 = EXT chk_M1 chk_GT < 0.003-0.0002 ABUT<90 OPPOSITE REGION MEASURE ALL
 err2 = EXT chk_M1 chk_GT > 0.003-0.0002 < 0.007-0.0002 ABUT<90 OPPOSITE REGION MEASURE ALL
 err3 = EXT chk_M1 chk_GT > 0.007-0.0002 < 0.009-0.0002 ABUT<90 OPPOSITE REGION MEASURE ALL
 err4 = EXT chk_M1 chk_GT > 0.010-0.0002 < 0.019-0.0002 ABUT<90 OPPOSITE REGION MEASURE ALL
 err5 = EXT chk_M1 chk_GT > 0.010-0.0002 < 0.019-0.0002 ABUT<90 OPPOSITE REGION MEASURE ALL
 err6 = EXT chk_M1 chk_GT > 0.019-0.0002 < 0.025-0.0002 ABUT<90 OPPOSITE REGION MEASURE ALL
 err7 = EXT chk_M1 chk_GT > 0.026-0.0002 < 0.035-0.0002 ABUT<90 OPPOSITE REGION MEASURE ALL
 err8 = EXT chk_M1 chk_GT > 0.026-0.0002 < 0.035-0.0002 ABUT<90 OPPOSITE REGION MEASURE ALL
 err9 = EXT chk_M1 chk_GT > 0.035-0.0002 < 0.048-0.0002 ABUT<90 OPPOSITE REGION MEASURE ALL
 err10 = chk_M1 NOT WITH EDGE ((EXT [chk_M1] chk_GT <= 0.048-0.0002 ABUT<90 OPPOSITE MEASURE ALL) OR EDGE (chk_M1 COIN INSIDE EDGE chk_GT))

 err1 NOT OUTSIDE (DDBTBS_real AND STDB_all)
 err2 NOT OUTSIDE (DDBTBS_real AND STDB_all)
 err3 NOT OUTSIDE (DDBTBS_real AND STDB_all)
 err4 NOT OUTSIDE (DDBTBS_real AND STDB_all)
 err5 NOT OUTSIDE (DDBTBS_real AND STDB_all)
 err6 NOT OUTSIDE (DDBTBS_real AND STDB_all)
 err7 NOT OUTSIDE (DDBTBS_real AND STDB_all)
 err8 NOT OUTSIDE (DDBTBS_real AND STDB_all)
 err9 NOT OUTSIDE (DDBTBS_real AND STDB_all)
 err10 NOT OUTSIDE (DDBTBS_real AND STDB_all)
}

M1_S_10b_AR_TBS {
@ Space between M1 (width = 0.082um) centerline and GT centerline in SDB design. = 0/0.002/0.006/0.007/0.009/0.01/0.019/0.025/0.026/0.035/0.037/0.039/0.045/0.048um
 chk_M1 = (INT (ANGLE M1_STD_082_line == 90) == 0.082 ABUT<90 OPPOSITE REGION CENTERLINE 0.0002) NOT OUTSIDE SDBTBS_real
 chk_GT = INT GT <= 0.024 OPPOSITE REGION CENTERLINE 0.0002  //;based on GT_W_1_TBS
 err1 = EXT chk_M1 chk_GT < 0.002-0.0002 ABUT<90 OPPOSITE REGION MEASURE ALL
 err2 = EXT chk_M1 chk_GT > 0.002-0.0002 < 0.006-0.0002 ABUT<90 OPPOSITE REGION MEASURE ALL
 err3 = EXT chk_M1 chk_GT > 0.007-0.0002 < 0.009-0.0002 ABUT<90 OPPOSITE REGION MEASURE ALL
 err4 = EXT chk_M1 chk_GT > 0.010-0.0002 < 0.019-0.0002 ABUT<90 OPPOSITE REGION MEASURE ALL
 err5 = EXT chk_M1 chk_GT > 0.019-0.0002 < 0.025-0.0002 ABUT<90 OPPOSITE REGION MEASURE ALL
 err6 = EXT chk_M1 chk_GT > 0.026-0.0002 < 0.035-0.0002 ABUT<90 OPPOSITE REGION MEASURE ALL
 err7 = EXT chk_M1 chk_GT > 0.035-0.0002 < 0.037-0.0002 ABUT<90 OPPOSITE REGION MEASURE ALL
 err8 = EXT chk_M1 chk_GT > 0.037-0.0002 < 0.039-0.0002 ABUT<90 OPPOSITE REGION MEASURE ALL
 err9 = EXT chk_M1 chk_GT > 0.039-0.0002 < 0.045-0.0002 ABUT<90 OPPOSITE REGION MEASURE ALL
 err10 = EXT chk_M1 chk_GT > 0.045-0.0002 < 0.048-0.0002 ABUT<90 OPPOSITE REGION MEASURE ALL
 err11 = chk_M1 NOT WITH EDGE ((EXT [chk_M1] chk_GT <= 0.048-0.0002 ABUT<90 OPPOSITE MEASURE ALL) OR EDGE (chk_M1 COIN INSIDE EDGE chk_GT))

 err1 NOT OUTSIDE (SDBTBS_real AND STDB_all)
 err2 NOT OUTSIDE (SDBTBS_real AND STDB_all)
 err3 NOT OUTSIDE (SDBTBS_real AND STDB_all)
 err4 NOT OUTSIDE (SDBTBS_real AND STDB_all)
 err5 NOT OUTSIDE (SDBTBS_real AND STDB_all)
 err6 NOT OUTSIDE (SDBTBS_real AND STDB_all)
 err7 NOT OUTSIDE (SDBTBS_real AND STDB_all)
 err8 NOT OUTSIDE (SDBTBS_real AND STDB_all)
 err9 NOT OUTSIDE (SDBTBS_real AND STDB_all)
 err10 NOT OUTSIDE (SDBTBS_real AND STDB_all)
 err11 NOT OUTSIDE (SDBTBS_real AND STDB_all)
}

M1_S_10c_EX_9a_9T_TBS {
@ M1.S.10c.9TBS: Space between M1 (width = 0.082um) line-end and PowerRail centerline in 9T DDB design = 0.108/0.144/0.171/0.176/0.208/0.235/0.240/0.256/0.272um
@ M1.EX.9a.9TBS: M1 (width = 0.082um) line-end extension PowerRail centerline in 9T DDB design = 0.19/0.272/0.208um
 CHK_AREA = DDBTBS_real AND STDB_all
 chk_M1 = (ANGLE M1_STD_082_end == 0) NOT OUTSIDE EDGE PowerRail_Area_90T
 good_1 = EXT (chk_M1) PowerRail_centerline_002 == 0.108-PowerRail_grid ABUT<90 OPPOSITE
 good_2 = EXT (good_1) PowerRail_centerline_002 == 0.144-PowerRail_grid ABUT<90 OPPOSITE
 good_3 = EXT (good_2) PowerRail_centerline_002 == 0.171-PowerRail_grid ABUT<90 OPPOSITE
 good_4 = EXT (good_3) PowerRail_centerline_002 == 0.176-PowerRail_grid ABUT<90 OPPOSITE
 good_5 = EXT (good_4) PowerRail_centerline_002 == 0.208-PowerRail_grid ABUT<90 OPPOSITE
 good_6 = EXT (good_5) PowerRail_centerline_002 == 0.235-PowerRail_grid ABUT<90 OPPOSITE
 good_7 = EXT (good_6) PowerRail_centerline_002 == 0.240-PowerRail_grid ABUT<90 OPPOSITE
 good_8 = EXT (good_7) PowerRail_centerline_002 == 0.256-PowerRail_grid ABUT<90 OPPOSITE
 good_9 = EXT (good_8) PowerRail_centerline_002 == 0.272-PowerRail_grid ABUT<90 OPPOSITE
 good_10 = ENC PowerRail_centerline_002 (good_9) == 0.190-PowerRail_grid ABUT<90 OPPOSITE MEASURE ALL
 good_11 = ENC PowerRail_centerline_002 (good_10) == 0.272-PowerRail_grid ABUT<90 OPPOSITE MEASURE ALL
 good_12 = ENC PowerRail_centerline_002 (good_11) == 0.208-PowerRail_grid ABUT<90 OPPOSITE MEASURE ALL
 err1 = good_12 NOT OUTSIDE EDGE PowerRail_Area_90T
 err1 NOT OUTSIDE EDGE CHK_AREA
}

M1_S_10c_EX_9a_75T_TBS {
@ M1.S.10c.7TBS: Space between M1 (width = 0.082um) line-end and PowerRail centerline in 7.5T DDB design = 0.08/0.112/0.144/0.176/0.208um
@ M1.EX.9a.7TBS: M1 (width = 0.082um) line-end extension PowerRail centerline in 7.5T DDB design = 0.240um
 CHK_AREA = DDBTBS_real AND STDB_all
 chk_M1 = (ANGLE M1_STD_082_end == 0) NOT OUTSIDE EDGE PowerRail_Area_75T
 good_1 = EXT (chk_M1) PowerRail_centerline_002 == 0.080-PowerRail_grid ABUT<90 OPPOSITE
 good_2 = EXT (good_1) PowerRail_centerline_002 == 0.112-PowerRail_grid ABUT<90 OPPOSITE
 good_3 = EXT (good_2) PowerRail_centerline_002 == 0.144-PowerRail_grid ABUT<90 OPPOSITE
 good_4 = EXT (good_3) PowerRail_centerline_002 == 0.176-PowerRail_grid ABUT<90 OPPOSITE
 good_5 = EXT (good_4) PowerRail_centerline_002 == 0.208-PowerRail_grid ABUT<90 OPPOSITE
 good_6 = ENC PowerRail_centerline_002 (good_5) == 0.240-PowerRail_grid ABUT<90 OPPOSITE MEASURE ALL
 err1 = good_6 NOT OUTSIDE EDGE PowerRail_Area_75T
 err1 NOT OUTSIDE EDGE CHK_AREA
}

M1_S_10c_EX_9a_AR_TBS {
@ M1.S.10c.ARTBS: Space between M1 (width = 0.082um) line-end and PowerRail centerline in SDB design = 0.08/0.112/0.144/0.176/0.208/0.224/0.24/0.256um
@ M1.EX.9a.ARTBS: M1 (width = 0.082um) line-end extension PowerRail centerline in SDB design = 0.24/0.272um
 CHK_AREA = SDBTBS_real AND STDB_all
 chk_M1 = (ANGLE M1_STD_082_end == 0) NOT OUTSIDE EDGE SDBTBS_real
 good_1 = EXT (chk_M1) PowerRail_centerline_002 == 0.080-PowerRail_grid ABUT<90 OPPOSITE
 good_2 = EXT (good_1) PowerRail_centerline_002 == 0.112-PowerRail_grid ABUT<90 OPPOSITE
 good_3 = EXT (good_2) PowerRail_centerline_002 == 0.144-PowerRail_grid ABUT<90 OPPOSITE
 good_4 = EXT (good_3) PowerRail_centerline_002 == 0.176-PowerRail_grid ABUT<90 OPPOSITE
 good_5 = EXT (good_4) PowerRail_centerline_002 == 0.208-PowerRail_grid ABUT<90 OPPOSITE
 good_6 = EXT (good_5) PowerRail_centerline_002 == 0.224-PowerRail_grid ABUT<90 OPPOSITE
 good_7 = EXT (good_6) PowerRail_centerline_002 == 0.240-PowerRail_grid ABUT<90 OPPOSITE
 good_8 = EXT (good_7) PowerRail_centerline_002 == 0.256-PowerRail_grid ABUT<90 OPPOSITE
 good_9 = ENC PowerRail_centerline_002 (good_8) == 0.240-PowerRail_grid ABUT<90 OPPOSITE MEASURE ALL
 good_10 = ENC PowerRail_centerline_002 (good_9) == 0.272-PowerRail_grid ABUT<90 OPPOSITE MEASURE ALL
 err1 = good_10 NOT OUTSIDE EDGE SDBTBS_real
 err1 NOT OUTSIDE EDGE CHK_AREA
}

M1_S_10d_EX_9b_9T_TBS {
@ M1.S.10d.9TBS: Space between M1 (width = 0.082um) line-end and GT centerline in 9T DDB design = 0.007/0.023/0.045um
@ M1.EX.9b.9TBS: M1 (width = 0.082um) line-end extension GT centerline in 9T DDB design = 0.037um
 CHK_AREA = DDBTBS_real AND STDB_all
 chk_M1 = (ANGLE M1_STD_082_end == 90) NOT OUTSIDE EDGE PowerRail_Area_90T
 chk_GT = INT GT <= 0.024 OPPOSITE REGION CENTERLINE 0.0002  //;based on GT_W_1_TBS
 good_1 = EXT (chk_M1) chk_GT == 0.007-0.0001 ABUT<90 OPPOSITE
 good_2 = EXT (good_1) chk_GT == 0.023-0.0001 ABUT<90 OPPOSITE
 good_3 = EXT (good_2) chk_GT == 0.045-0.0001 ABUT<90 OPPOSITE
 good_4 = ENC chk_GT (good_3) == 0.037-0.0001 ABUT<90 OPPOSITE
 err1 = good_4 NOT OUTSIDE EDGE PowerRail_Area_90T
 err1 NOT OUTSIDE EDGE CHK_AREA
}

M1_S_10d_EX_9b_75T_TBS {
@ M1.S.10d.7TBS: Space between M1 (width = 0.082um) line-end and GT centerline in 7.5T DDB design = 0.029um
@ M1.EX.9b.7TBS: M1 (width = 0.082um) line-end extension GT centerline in 7.5T DDB design = 0.013um
 CHK_AREA = DDBTBS_real AND STDB_all
 chk_M1 = (ANGLE M1_STD_082_end == 90) NOT OUTSIDE EDGE PowerRail_Area_75T
 chk_GT = INT GT <= 0.024 OPPOSITE REGION CENTERLINE 0.0002  //;based on GT_W_1_TBS
 good_1 = EXT (chk_M1) chk_GT == 0.029-0.0001 ABUT<90 OPPOSITE
 good_2 = ENC chk_GT (good_1) == 0.013-0.0001 ABUT<90 OPPOSITE
 err1 = good_2 NOT OUTSIDE EDGE PowerRail_Area_75T
 err1 NOT OUTSIDE EDGE CHK_AREA
}

M1_S_10d_AR_TBS {
@ Space between M1 (width = 0.082um) line-end and GT centerline in SDB design. = 0.001/0.02um
 CHK_AREA = SDBTBS_real AND STDB_all
 chk_M1 = (ANGLE M1_STD_082_end == 90) NOT OUTSIDE EDGE SDBTBS_real
 chk_GT = INT GT <= 0.024 OPPOSITE REGION CENTERLINE 0.0002  //;based on GT_W_1_TBS
 good_1 = EXT (chk_M1) chk_GT == 0.001-0.0001 ABUT<90 OPPOSITE
 good_2 = EXT (good_1) chk_GT == 0.020-0.0001 ABUT<90 OPPOSITE
 err1 = good_2 NOT OUTSIDE EDGE SDBTBS_real
 err1 NOT OUTSIDE EDGE CHK_AREA
}

M1_S_11a_75T_TBS {
@ Space between M1 (width = 0.096um) line-end and PowerRail centerline in 7.5T DDB design
@ DRC flag horizontal M1 (width = 0.096um) line-end = \um
 CHK_AREA = DDBTBS_real AND STDB_all
 err1 = (ANGLE M1_STD_096_line == 0) NOT OUTSIDE EDGE PowerRail_Area_75T
 err1 NOT OUTSIDE EDGE CHK_AREA
}

M1_S_11b_75T_TBS {
@ Space between M1 (width = 0.096um) centerline and GT centerline in 7.5T DDB design = 0.048um
 chk_M1 = INT (ANGLE M1_STD_096_line == 90) == 0.096 ABUT<90 OPPOSITE REGION CENTERLINE 0.0002
 chk_GT = INT GT <= 0.024 OPPOSITE REGION CENTERLINE 0.0002  //;based on GT_W_1_TBS
 err1 = (EXT chk_M1 chk_GT < 0.048-0.0002 ABUT<90 OPPOSITE REGION MEASURE ALL) NOT OUTSIDE PowerRail_Area_75T
 err2 = (chk_M1 NOT WITH EDGE (EXT [chk_M1] chk_GT <= 0.048-0.0002 ABUT<90 OPPOSITE MEASURE ALL)) NOT OUTSIDE PowerRail_Area_75T

 err1 NOT OUTSIDE (DDBTBS_real AND STDB_all)
 err2 NOT OUTSIDE (DDBTBS_real AND STDB_all)
}

M1_S_11c_9T_TBS {
@ Space between M1 (width = 0.096um) centerline and GT centerline in 9T DDB design = 0.041um
 chk_M1 = INT (ANGLE M1_STD_096_line == 90) == 0.096 ABUT<90 OPPOSITE REGION CENTERLINE 0.0002
 chk_GT = INT GT <= 0.024 OPPOSITE REGION CENTERLINE 0.0002  //;based on GT_W_1_TBS
 err1 = (EXT chk_M1 chk_GT < 0.041-0.0002 ABUT<90 OPPOSITE REGION MEASURE ALL) NOT OUTSIDE PowerRail_Area_90T
 err2 = (chk_M1 NOT WITH EDGE (EXT [chk_M1] chk_GT <= 0.041-0.0002 ABUT<90 OPPOSITE MEASURE ALL)) NOT OUTSIDE PowerRail_Area_90T

 err1 NOT OUTSIDE (DDBTBS_real AND STDB_all)
 err2 NOT OUTSIDE (DDBTBS_real AND STDB_all)
}

M1_EX_1_AR_TBS {
@ M1 (width = 0.032um) line-end extension GT centerline in SDB design. = 0.006/0.008um
 CHK_AREA = SDBTBS_real AND STDB_all
 chk_M1 = (ANGLE M1_STD_032_end == 90) NOT OUTSIDE EDGE SDBTBS_real
 chk_GT = INT GT <= 0.024 OPPOSITE REGION CENTERLINE 0.0002  //;based on GT_W_1_TBS
 good_1 = ENC chk_GT (chk_M1) == 0.006-0.0001 ABUT<90 OPPOSITE
 good_2 = ENC chk_GT (good_1) == 0.008-0.0001 ABUT<90 OPPOSITE
 err1 = good_2 NOT OUTSIDE EDGE SDBTBS_real
 err1 NOT OUTSIDE EDGE CHK_AREA
}

M1_EX_2_AR_TBS {
@ M1 (width = 0.034um) line-end extension GT centerline in SDB design. = 0.006/0.008um
 CHK_AREA = SDBTBS_real AND STDB_all
 chk_M1 = (ANGLE M1_STD_034_end == 90) NOT OUTSIDE EDGE SDBTBS_real
 chk_GT = INT GT <= 0.024 OPPOSITE REGION CENTERLINE 0.0002  //;based on GT_W_1_TBS
 good_1 = ENC chk_GT (chk_M1) == 0.006-0.0001 ABUT<90 OPPOSITE
 good_2 = ENC chk_GT (good_1) == 0.008-0.0001 ABUT<90 OPPOSITE
 err1 = good_2 NOT OUTSIDE EDGE SDBTBS_real
 err1 NOT OUTSIDE EDGE CHK_AREA
}

M1_R_1a_9T_TBS {
@ M1 (width = 0.032um) must be horizontal in 9T DDB design
 CHK_AREA = DDBTBS_real AND STDB_all
 chk_M1 = M1_STD_good_032 NOT OUTSIDE PowerRail_Area_90T
 err1 = ANGLE (INT [chk_M1] == 0.032 ABUT<90 OPPOSITE) == 90
 err2 = EXT chk_M1 < 0.005 ABUT INTERSECTING ONLY REGION

 err1 NOT OUTSIDE EDGE CHK_AREA
 err2 NOT OUTSIDE CHK_AREA
}

M1_R_1a_75T_W032_TBS {
@ M1 (width = 0.032/0.035/0.066/0.076um) must be horizontal in 7.5T DDB design
 CHK_AREA = DDBTBS_real AND STDB_all
 chk_M1 = M1_STD_good_032 NOT OUTSIDE PowerRail_Area_75T
 err1 = ANGLE (INT [chk_M1] == 0.032 ABUT<90 OPPOSITE) == 90
 err2 = EXT chk_M1 < 0.005 ABUT INTERSECTING ONLY REGION

 err1 NOT OUTSIDE EDGE CHK_AREA
 err2 NOT OUTSIDE CHK_AREA
}

M1_R_1a_75T_W035_TBS {
@ M1 (width = 0.032/0.035/0.066/0.076um) must be horizontal in 7.5T DDB design
 CHK_AREA = DDBTBS_real AND STDB_all
 chk_M1 = M1_STD_good_035 NOT OUTSIDE PowerRail_Area_75T
 err1 = ANGLE (INT [chk_M1] == 0.035 ABUT<90 OPPOSITE) == 90
 err2 = EXT chk_M1 < 0.005 ABUT INTERSECTING ONLY REGION

 err1 NOT OUTSIDE EDGE CHK_AREA
 err2 NOT OUTSIDE CHK_AREA
}

M1_R_1a_75T_W066_TBS {
@ M1 (width = 0.032/0.035/0.066/0.076um) must be horizontal in 7.5T DDB design
 CHK_AREA = DDBTBS_real AND STDB_all
 chk_M1 = M1_STD_good_066 NOT OUTSIDE PowerRail_Area_75T
 err1 = ANGLE (INT [chk_M1] == 0.066 ABUT<90 OPPOSITE) == 90
 err2 = EXT chk_M1 < 0.005 ABUT INTERSECTING ONLY REGION

 err1 NOT OUTSIDE EDGE CHK_AREA
 err2 NOT OUTSIDE CHK_AREA
}

M1_R_1a_75T_W076_TBS {
@ M1 (width = 0.032/0.035/0.066/0.076um) must be horizontal in 7.5T DDB design
 CHK_AREA = DDBTBS_real AND STDB_all
 chk_M1 = M1_STD_good_076 NOT OUTSIDE PowerRail_Area_75T
 err1 = ANGLE (INT [chk_M1] == 0.076 ABUT<90 OPPOSITE) == 90
 err2 = EXT chk_M1 < 0.005 ABUT INTERSECTING ONLY REGION

 err1 NOT OUTSIDE EDGE CHK_AREA
 err2 NOT OUTSIDE CHK_AREA
}

M1_R_1b_9T_TBS {
@ M1 (width = 0.038um) must be vertical in 9T DDB design
 CHK_AREA = DDBTBS_real AND STDB_all
 chk_M1 = M1_STD_good_038 NOT OUTSIDE PowerRail_Area_90T
 err1 = ANGLE (INT [chk_M1] == 0.038 ABUT<90 OPPOSITE) == 0
 err2 = EXT chk_M1 < 0.005 ABUT INTERSECTING ONLY REGION

 err1 NOT OUTSIDE EDGE CHK_AREA
 err2 NOT OUTSIDE CHK_AREA
}

M1_R_1c_TBS {
@ M1 (width = 0.046um) must be vertical
 err1 = ANGLE (INT [M1_STD_good_046] == 0.046 ABUT<90 OPPOSITE) == 0
 err2 = EXT M1_STD_good_046 < 0.005 ABUT INTERSECTING ONLY REGION

 err1 NOT OUTSIDE EDGE STDB_all
 err2 NOT OUTSIDE STDB_all
}

M1_R_1d_TBS {
@ M1 (width = 0.09um) must be horizontal
 err1 = ANGLE (INT [M1_STD_good_090] == 0.090 ABUT<90 OPPOSITE) == 90
 err2 = EXT M1_STD_good_090 < 0.005 ABUT INTERSECTING ONLY REGION

 err1 NOT OUTSIDE EDGE STDB_all
 err2 NOT OUTSIDE STDB_all
}

M1_R_2_TBS {
@ M1 (width = 0.09um) must interact with RSPMK1
 err1 = M1_STD_good_090 NOT INTERACT RSPMK1
 err1 NOT OUTSIDE STDB_all
}

M1_R_3_75T_TBS {
@ M1 (width = 0.096um) must be vertical in 7.5T DDB design
 CHK_AREA = DDBTBS_real AND STDB_all
 chk_M1 = M1_STD_good_096 NOT OUTSIDE PowerRail_Area_75T
 err1 = ANGLE (INT [chk_M1] == 0.096 ABUT<90 OPPOSITE) == 0
 err2 = EXT chk_M1 < 0.005 ABUT INTERSECTING ONLY REGION

 err1 NOT OUTSIDE EDGE CHK_AREA
 err2 NOT OUTSIDE CHK_AREA
}

M1_R_4_TBS {
@ M1 must be orthogonal to grid
 err1 = ANGLE M1_STD > 0 < 90
 err1 NOT OUTSIDE EDGE STDB_all
}

M1_S_12_TBS {
@ Space between M1 and line-end (width < 0.046um, and PRL > -0.016um) in 9T DDB design >= 0.07um
 err1 = (EXT M1_line M1_end_0.046 < 0.070 ABUT<90 OPPOSITE EXTENDED 0.016 REGION) NOT OUTSIDE PowerRail_Area_90T
 err1 NOT OUTSIDE (DDBTBS_real AND STDB_all)
}

M1_S_13_TBS {
@ Space between M1 and line-end (0.046um <= M1 width <= 0.049um, and PRL > -0.016um) >= 0.036um
 err1 = EXT M1_line M1_end_0.046_0.049 < 0.036 ABUT<90 OPPOSITE EXTENDED 0.016 REGION
 err1 NOT OUTSIDE STDB_all
}

M1_S_14_TBS {
@ Space between M1 line-end and line-end (width < 0.046um, and PRL > -0.016um) in 9T DDB design >= 0.081um
 err1 = (EXT M1_end_0.046 < 0.081 ABUT<90 OPPOSITE EXTENDED 0.016 REGION) NOT OUTSIDE PowerRail_Area_90T
 err1 NOT OUTSIDE (DDBTBS_real AND STDB_all)
}

M1_convex_corner = INT [M1] < 0.0002 ABUT==90 INTERSECTING ONLY
M1_concave_corner = EXT [M1] < 0.0002 ABUT==90 INTERSECTING ONLY

M1_S_15_TBS {
@ Space between M1 outside vertex (M1 line-end outer vertex or L-shape outer vertex) and nearby L-shape inner vertex. >= 0.047um
@ DRC flag if both projection space < 0.036um
 Y1 = (EXT [M1_v_edges] < 0.036 ABUT<90 OPPOSITE EXTENDED 0.047) OR EDGE (EXT [M1_h_edges] < 0.036 ABUT<90 OPPOSITE EXTENDED 0.047)
 Y2 = EXT M1_convex_corner M1_concave_corner < 0.047 ABUT<90
 err1_a = INT Y1 < 0.001 ABUT==90 INTERSECTING ONLY
 err1_b = EXT Y1 < 0.001 ABUT==90 INTERSECTING ONLY
 err1_c = DFM PROPERTY Y2 err1_a err1_b ABUT ALSO OVERLAP MULTI [-= (count(err1_a) > 0 && count(err1_b) > 0) ? 1 : 0] > 0
 err1 = DFM COPY err1_c REGION
 err1 NOT OUTSIDE STDB_all
}


// =======================================================
// Common Derivations For Dummy Check Rules
// =======================================================

NPAA_EXT = EXTENTS NPAA
M0DOP_M0 = M0 OR (M0DOP NOT INSIDE DMCMK1)
M0DOP_M0_40 = OR (M0DOP_M0 WITH WIDTH == 0.04) (M0DOP_M0 WITH WIDTH == 0.042)
OCOVL_NOT_OCOVLM4 = OCOVL NOT OCOVLM4

// =======================================================
// For FEOL Dummy Pattern Check Rules
// =======================================================

GROUP GDUMC DUMC_?

#IFDEF CHIPB_RULES_CHECK YES
DUMC_1 {
@ Inside edge of CHIPB space to DMC1 >= 3um, Outside and cut is not allowed.
 err1 = ENC DMC1 CHIPB < 3 ABUT<90 SINGULAR REGION OUTSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
#ENDIF

 
P2DUM_outside_DMCMK1 = P2DUM NOT INSIDE DMCMK1
P2DOP_outside_DMCMK1 = P2DOP NOT INSIDE DMCMK1
SNDUM_outside_DMCMK1 = SNDUM NOT INSIDE DMCMK1
SPDUM_outside_DMCMK1 = SPDUM NOT INSIDE DMCMK1
AADUM_outside_DMCMK1 = AADUM NOT INSIDE DMCMK1
AADOP_outside_DMCMK1 = AADOP NOT INSIDE DMCMK1
ARDUM_outside_DMCMK1 = ARDUM NOT INSIDE DMCMK1
ARDOP_outside_DMCMK1 = ARDOP NOT INSIDE DMCMK1
GTDUM_outside_DMCMK1 = GTDUM NOT INSIDE DMCMK1
GTDOP_outside_DMCMK1 = GTDOP NOT INSIDE DMCMK1
M0DUM_outside_DMCMK1 = M0DUM NOT INSIDE DMCMK1
M0DOP_outside_DMCMK1 = M0DOP NOT INSIDE DMCMK1
M0GDUM_outside_DMCMK1 = M0GDUM NOT INSIDE DMCMK1
M0GDOP_outside_DMCMK1 = M0GDOP NOT INSIDE DMCMK1
M0CDUM_outside_DMCMK1 = M0CDUM NOT INSIDE DMCMK1
M0CDOP_outside_DMCMK1 = M0CDOP NOT INSIDE DMCMK1
AR_HDOP_outside_DMCMK1 = AR_HDOP NOT INSIDE DMCMK1
AR_VDOP_outside_DMCMK1 = AR_VDOP NOT INSIDE DMCMK1
ARBL_outside_DMCMK1 = ARBL NOT INSIDE DMCMK1
V0DUM_outside_DMCMK1 = V0DUM NOT INSIDE DMCMK1
V0DPDUM_outside_DMCMK1 = V0DPDUM NOT INSIDE DMCMK1
 
DUMC_2_DUMBA {
@ DMC1 space to DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, NPAA_EXT, AA, AADMP, PPAA, GT, GTDMP, P2, P2DMP, (P2DOP NOT INSIDE DMCMK1), M0, M0DMP, M0C, M0CDMP, M0G, M0GDMP, SN, SP, (SNDUM NOT INSIDE DMCMK1), (SPDUM NOT INSIDE DMCMK1) Overlap is not allowed. >= 3um
 err1 = EXT DUMBA DMC1 < 3 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_2_DUMBP {
@ DMC1 space to DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, NPAA_EXT, AA, AADMP, PPAA, GT, GTDMP, P2, P2DMP, (P2DOP NOT INSIDE DMCMK1), M0, M0DMP, M0C, M0CDMP, M0G, M0GDMP, SN, SP, (SNDUM NOT INSIDE DMCMK1), (SPDUM NOT INSIDE DMCMK1) Overlap is not allowed. >= 3um
 err1 = EXT DUMBP DMC1 < 3 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_2_ARDUB {
@ DMC1 space to DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, NPAA_EXT, AA, AADMP, PPAA, GT, GTDMP, P2, P2DMP, (P2DOP NOT INSIDE DMCMK1), M0, M0DMP, M0C, M0CDMP, M0G, M0GDMP, SN, SP, (SNDUM NOT INSIDE DMCMK1), (SPDUM NOT INSIDE DMCMK1) Overlap is not allowed. >= 3um
 err1 = EXT ARDUB DMC1 < 3 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_2_P2DUB {
@ DMC1 space to DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, NPAA_EXT, AA, AADMP, PPAA, GT, GTDMP, P2, P2DMP, (P2DOP NOT INSIDE DMCMK1), M0, M0DMP, M0C, M0CDMP, M0G, M0GDMP, SN, SP, (SNDUM NOT INSIDE DMCMK1), (SPDUM NOT INSIDE DMCMK1) Overlap is not allowed. >= 3um
 err1 = EXT P2DUB DMC1 < 3 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_2_M0DUB {
@ DMC1 space to DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, NPAA_EXT, AA, AADMP, PPAA, GT, GTDMP, P2, P2DMP, (P2DOP NOT INSIDE DMCMK1), M0, M0DMP, M0C, M0CDMP, M0G, M0GDMP, SN, SP, (SNDUM NOT INSIDE DMCMK1), (SPDUM NOT INSIDE DMCMK1) Overlap is not allowed. >= 3um
 err1 = EXT M0DUB DMC1 < 3 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_2_M0CDUB {
@ DMC1 space to DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, NPAA_EXT, AA, AADMP, PPAA, GT, GTDMP, P2, P2DMP, (P2DOP NOT INSIDE DMCMK1), M0, M0DMP, M0C, M0CDMP, M0G, M0GDMP, SN, SP, (SNDUM NOT INSIDE DMCMK1), (SPDUM NOT INSIDE DMCMK1) Overlap is not allowed. >= 3um
 err1 = EXT M0CDUB DMC1 < 3 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_2_M0GDUB {
@ DMC1 space to DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, NPAA_EXT, AA, AADMP, PPAA, GT, GTDMP, P2, P2DMP, (P2DOP NOT INSIDE DMCMK1), M0, M0DMP, M0C, M0CDMP, M0G, M0GDMP, SN, SP, (SNDUM NOT INSIDE DMCMK1), (SPDUM NOT INSIDE DMCMK1) Overlap is not allowed. >= 3um
 err1 = EXT M0GDUB DMC1 < 3 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_2_NPAA_EXT {
@ DMC1 space to DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, NPAA_EXT, AA, AADMP, PPAA, GT, GTDMP, P2, P2DMP, (P2DOP NOT INSIDE DMCMK1), M0, M0DMP, M0C, M0CDMP, M0G, M0GDMP, SN, SP, (SNDUM NOT INSIDE DMCMK1), (SPDUM NOT INSIDE DMCMK1) Overlap is not allowed. >= 3um
 err1 = EXT NPAA_EXT DMC1 < 3 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_2_AA {
@ DMC1 space to DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, NPAA_EXT, AA, AADMP, PPAA, GT, GTDMP, P2, P2DMP, (P2DOP NOT INSIDE DMCMK1), M0, M0DMP, M0C, M0CDMP, M0G, M0GDMP, SN, SP, (SNDUM NOT INSIDE DMCMK1), (SPDUM NOT INSIDE DMCMK1) Overlap is not allowed. >= 3um
 err1 = EXT AA DMC1 < 3 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_2_AADMP {
@ DMC1 space to DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, NPAA_EXT, AA, AADMP, PPAA, GT, GTDMP, P2, P2DMP, (P2DOP NOT INSIDE DMCMK1), M0, M0DMP, M0C, M0CDMP, M0G, M0GDMP, SN, SP, (SNDUM NOT INSIDE DMCMK1), (SPDUM NOT INSIDE DMCMK1) Overlap is not allowed. >= 3um
 err1 = EXT AADMP DMC1 < 3 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_2_PPAA {
@ DMC1 space to DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, NPAA_EXT, AA, AADMP, PPAA, GT, GTDMP, P2, P2DMP, (P2DOP NOT INSIDE DMCMK1), M0, M0DMP, M0C, M0CDMP, M0G, M0GDMP, SN, SP, (SNDUM NOT INSIDE DMCMK1), (SPDUM NOT INSIDE DMCMK1) Overlap is not allowed. >= 3um
 err1 = EXT PPAA DMC1 < 3 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_2_GT {
@ DMC1 space to DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, NPAA_EXT, AA, AADMP, PPAA, GT, GTDMP, P2, P2DMP, (P2DOP NOT INSIDE DMCMK1), M0, M0DMP, M0C, M0CDMP, M0G, M0GDMP, SN, SP, (SNDUM NOT INSIDE DMCMK1), (SPDUM NOT INSIDE DMCMK1) Overlap is not allowed. >= 3um
 err1 = EXT GT DMC1 < 3 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_2_GTDMP {
@ DMC1 space to DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, NPAA_EXT, AA, AADMP, PPAA, GT, GTDMP, P2, P2DMP, (P2DOP NOT INSIDE DMCMK1), M0, M0DMP, M0C, M0CDMP, M0G, M0GDMP, SN, SP, (SNDUM NOT INSIDE DMCMK1), (SPDUM NOT INSIDE DMCMK1) Overlap is not allowed. >= 3um
 err1 = EXT GTDMP DMC1 < 3 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_2_P2 {
@ DMC1 space to DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, NPAA_EXT, AA, AADMP, PPAA, GT, GTDMP, P2, P2DMP, (P2DOP NOT INSIDE DMCMK1), M0, M0DMP, M0C, M0CDMP, M0G, M0GDMP, SN, SP, (SNDUM NOT INSIDE DMCMK1), (SPDUM NOT INSIDE DMCMK1) Overlap is not allowed. >= 3um
 err1 = EXT P2 DMC1 < 3 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_2_P2DMP {
@ DMC1 space to DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, NPAA_EXT, AA, AADMP, PPAA, GT, GTDMP, P2, P2DMP, (P2DOP NOT INSIDE DMCMK1), M0, M0DMP, M0C, M0CDMP, M0G, M0GDMP, SN, SP, (SNDUM NOT INSIDE DMCMK1), (SPDUM NOT INSIDE DMCMK1) Overlap is not allowed. >= 3um
 err1 = EXT P2DMP DMC1 < 3 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_2_M0 {
@ DMC1 space to DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, NPAA_EXT, AA, AADMP, PPAA, GT, GTDMP, P2, P2DMP, (P2DOP NOT INSIDE DMCMK1), M0, M0DMP, M0C, M0CDMP, M0G, M0GDMP, SN, SP, (SNDUM NOT INSIDE DMCMK1), (SPDUM NOT INSIDE DMCMK1) Overlap is not allowed. >= 3um
 err1 = EXT M0 DMC1 < 3 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_2_M0DMP {
@ DMC1 space to DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, NPAA_EXT, AA, AADMP, PPAA, GT, GTDMP, P2, P2DMP, (P2DOP NOT INSIDE DMCMK1), M0, M0DMP, M0C, M0CDMP, M0G, M0GDMP, SN, SP, (SNDUM NOT INSIDE DMCMK1), (SPDUM NOT INSIDE DMCMK1) Overlap is not allowed. >= 3um
 err1 = EXT M0DMP DMC1 < 3 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_2_M0C {
@ DMC1 space to DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, NPAA_EXT, AA, AADMP, PPAA, GT, GTDMP, P2, P2DMP, (P2DOP NOT INSIDE DMCMK1), M0, M0DMP, M0C, M0CDMP, M0G, M0GDMP, SN, SP, (SNDUM NOT INSIDE DMCMK1), (SPDUM NOT INSIDE DMCMK1) Overlap is not allowed. >= 3um
 err1 = EXT M0C DMC1 < 3 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_2_M0CDMP {
@ DMC1 space to DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, NPAA_EXT, AA, AADMP, PPAA, GT, GTDMP, P2, P2DMP, (P2DOP NOT INSIDE DMCMK1), M0, M0DMP, M0C, M0CDMP, M0G, M0GDMP, SN, SP, (SNDUM NOT INSIDE DMCMK1), (SPDUM NOT INSIDE DMCMK1) Overlap is not allowed. >= 3um
 err1 = EXT M0CDMP DMC1 < 3 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_2_M0G {
@ DMC1 space to DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, NPAA_EXT, AA, AADMP, PPAA, GT, GTDMP, P2, P2DMP, (P2DOP NOT INSIDE DMCMK1), M0, M0DMP, M0C, M0CDMP, M0G, M0GDMP, SN, SP, (SNDUM NOT INSIDE DMCMK1), (SPDUM NOT INSIDE DMCMK1) Overlap is not allowed. >= 3um
 err1 = EXT M0G DMC1 < 3 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_2_M0GDMP {
@ DMC1 space to DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, NPAA_EXT, AA, AADMP, PPAA, GT, GTDMP, P2, P2DMP, (P2DOP NOT INSIDE DMCMK1), M0, M0DMP, M0C, M0CDMP, M0G, M0GDMP, SN, SP, (SNDUM NOT INSIDE DMCMK1), (SPDUM NOT INSIDE DMCMK1) Overlap is not allowed. >= 3um
 err1 = EXT M0GDMP DMC1 < 3 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_2_SN {
@ DMC1 space to DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, NPAA_EXT, AA, AADMP, PPAA, GT, GTDMP, P2, P2DMP, (P2DOP NOT INSIDE DMCMK1), M0, M0DMP, M0C, M0CDMP, M0G, M0GDMP, SN, SP, (SNDUM NOT INSIDE DMCMK1), (SPDUM NOT INSIDE DMCMK1) Overlap is not allowed. >= 3um
 err1 = EXT SN DMC1 < 3 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_2_SP {
@ DMC1 space to DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, NPAA_EXT, AA, AADMP, PPAA, GT, GTDMP, P2, P2DMP, (P2DOP NOT INSIDE DMCMK1), M0, M0DMP, M0C, M0CDMP, M0G, M0GDMP, SN, SP, (SNDUM NOT INSIDE DMCMK1), (SPDUM NOT INSIDE DMCMK1) Overlap is not allowed. >= 3um
 err1 = EXT SP DMC1 < 3 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_2_P2DOP {
@ DMC1 space to DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, NPAA_EXT, AA, AADMP, PPAA, GT, GTDMP, P2, P2DMP, (P2DOP NOT INSIDE DMCMK1), M0, M0DMP, M0C, M0CDMP, M0G, M0GDMP, SN, SP, (SNDUM NOT INSIDE DMCMK1), (SPDUM NOT INSIDE DMCMK1), Overlap is not allowed. >= 3um
 err1 = EXT P2DOP_outside_DMCMK1 DMC1 < 3 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_2_SNDUM {
@ DMC1 space to DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, NPAA_EXT, AA, AADMP, PPAA, GT, GTDMP, P2, P2DMP, (P2DOP NOT INSIDE DMCMK1), M0, M0DMP, M0C, M0CDMP, M0G, M0GDMP, SN, SP, (SNDUM NOT INSIDE DMCMK1), (SPDUM NOT INSIDE DMCMK1), Overlap is not allowed. >= 3um
 err1 = EXT SNDUM_outside_DMCMK1 DMC1 < 3 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_2_SPDUM {
@ DMC1 space to DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, NPAA_EXT, AA, AADMP, PPAA, GT, GTDMP, P2, P2DMP, (P2DOP NOT INSIDE DMCMK1), M0, M0DMP, M0C, M0CDMP, M0G, M0GDMP, SN, SP, (SNDUM NOT INSIDE DMCMK1), (SPDUM NOT INSIDE DMCMK1), Overlap is not allowed. >= 3um
 err1 = EXT SPDUM_outside_DMCMK1 DMC1 < 3 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_3_AADUM {
@ DMC1 space to (AADUM NOT INSIDE DMCMK1), (AADOP NOT INSIDE DMCMK1), (P2DUM NOT INSIDE DMCMK1), (M0DUM NOT INSIDE DMCMK1), (M0DOP NOT INSIDE DMCMK1), (M0GDUM NOT INSIDE DMCMK1), (M0GDOP NOT INSIDE DMCMK1), DIR, DIRDMP, RESP1, Overlap is not allowed. >= 0.27um
 err1 = EXT DMC1 AADUM_outside_DMCMK1 < 0.27 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_3_AADOP {
@ DMC1 space to (AADUM NOT INSIDE DMCMK1), (AADOP NOT INSIDE DMCMK1), (P2DUM NOT INSIDE DMCMK1), (M0DUM NOT INSIDE DMCMK1), (M0DOP NOT INSIDE DMCMK1), (M0GDUM NOT INSIDE DMCMK1), (M0GDOP NOT INSIDE DMCMK1), DIR, DIRDMP, RESP1, Overlap is not allowed. >= 0.27um
 err1 = EXT DMC1 AADOP_outside_DMCMK1 < 0.27 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_3_P2DUM {
@ DMC1 space to (AADUM NOT INSIDE DMCMK1), (AADOP NOT INSIDE DMCMK1), (P2DUM NOT INSIDE DMCMK1), (M0DUM NOT INSIDE DMCMK1), (M0DOP NOT INSIDE DMCMK1), (M0GDUM NOT INSIDE DMCMK1), (M0GDOP NOT INSIDE DMCMK1), DIR, DIRDMP, RESP1, Overlap is not allowed. >= 0.27um
 err1 = EXT DMC1 P2DUM_outside_DMCMK1 < 0.27 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_3_M0DUM {
@ DMC1 space to (AADUM NOT INSIDE DMCMK1), (AADOP NOT INSIDE DMCMK1), (P2DUM NOT INSIDE DMCMK1), (M0DUM NOT INSIDE DMCMK1), (M0DOP NOT INSIDE DMCMK1), (M0GDUM NOT INSIDE DMCMK1), (M0GDOP NOT INSIDE DMCMK1), DIR, DIRDMP, RESP1, Overlap is not allowed. >= 0.27um
 err1 = EXT DMC1 M0DUM_outside_DMCMK1 < 0.27 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_3_M0DOP {
@ DMC1 space to (AADUM NOT INSIDE DMCMK1), (AADOP NOT INSIDE DMCMK1), (P2DUM NOT INSIDE DMCMK1), (M0DUM NOT INSIDE DMCMK1), (M0DOP NOT INSIDE DMCMK1), (M0GDUM NOT INSIDE DMCMK1), (M0GDOP NOT INSIDE DMCMK1), DIR, DIRDMP, RESP1, Overlap is not allowed. >= 0.27um
 err1 = EXT DMC1 M0DOP_outside_DMCMK1 < 0.27 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_3_M0GDUM {
@ DMC1 space to (AADUM NOT INSIDE DMCMK1), (AADOP NOT INSIDE DMCMK1), (P2DUM NOT INSIDE DMCMK1), (M0DUM NOT INSIDE DMCMK1), (M0DOP NOT INSIDE DMCMK1), (M0GDUM NOT INSIDE DMCMK1), (M0GDOP NOT INSIDE DMCMK1), DIR, DIRDMP, RESP1, Overlap is not allowed. >= 0.27um
 err1 = EXT DMC1 M0GDUM_outside_DMCMK1 < 0.27 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_3_M0GDOP {
@ DMC1 space to (AADUM NOT INSIDE DMCMK1), (AADOP NOT INSIDE DMCMK1), (P2DUM NOT INSIDE DMCMK1), (M0DUM NOT INSIDE DMCMK1), (M0DOP NOT INSIDE DMCMK1), (M0GDUM NOT INSIDE DMCMK1), (M0GDOP NOT INSIDE DMCMK1), DIR, DIRDMP, RESP1, Overlap is not allowed. >= 0.27um
 err1 = EXT DMC1 M0GDOP_outside_DMCMK1 < 0.27 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_3_DIR {
@ DMC1 space to (AADUM NOT INSIDE DMCMK1), (AADOP NOT INSIDE DMCMK1), (P2DUM NOT INSIDE DMCMK1), (M0DUM NOT INSIDE DMCMK1), (M0DOP NOT INSIDE DMCMK1), (M0GDUM NOT INSIDE DMCMK1), (M0GDOP NOT INSIDE DMCMK1), DIR, DIRDMP, RESP1, Overlap is not allowed. >= 0.27um
 err1 = EXT DMC1 DIR < 0.27 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_3_DIRDMP {
@ DMC1 space to (AADUM NOT INSIDE DMCMK1), (AADOP NOT INSIDE DMCMK1), (P2DUM NOT INSIDE DMCMK1), (M0DUM NOT INSIDE DMCMK1), (M0DOP NOT INSIDE DMCMK1), (M0GDUM NOT INSIDE DMCMK1), (M0GDOP NOT INSIDE DMCMK1), DIR, DIRDMP, RESP1, Overlap is not allowed. >= 0.27um
 err1 = EXT DMC1 DIRDMP < 0.27 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_3_RESP1 {
@ DMC1 space to (AADUM NOT INSIDE DMCMK1), (AADOP NOT INSIDE DMCMK1), (P2DUM NOT INSIDE DMCMK1), (M0DUM NOT INSIDE DMCMK1), (M0DOP NOT INSIDE DMCMK1), (M0GDUM NOT INSIDE DMCMK1), (M0GDOP NOT INSIDE DMCMK1), DIR, DIRDMP, RESP1, Overlap is not allowed. >= 0.27um
 err1 = EXT DMC1 RESP1 < 0.27 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_4_AR_H {
@ DMC1 space to AR_H, AR_V, (AR_HDOP NOT INSIDE DMCMK1), (AR_VDOP NOT INSIDE DMCMK1), (ARBL NOT INSIDE DMCMK1), Overlap is not allowed. >= 0.144um
 err1 = EXT AR_H DMC1 < 0.144 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_4_AR_V {
@ DMC1 space to AR_H, AR_V, (AR_HDOP NOT INSIDE DMCMK1), (AR_VDOP NOT INSIDE DMCMK1), (ARBL NOT INSIDE DMCMK1), Overlap is not allowed. >= 0.144um
 err1 = EXT AR_V DMC1 < 0.144 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_4_AR_HDOP {
@ DMC1 space to AR_H, AR_V, (AR_HDOP NOT INSIDE DMCMK1), (AR_VDOP NOT INSIDE DMCMK1), (ARBL NOT INSIDE DMCMK1), Overlap is not allowed. >= 0.144um
 err1 = EXT AR_HDOP_outside_DMCMK1 DMC1 < 0.144 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_4_AR_VDOP {
@ DMC1 space to AR_H, AR_V, (AR_HDOP NOT INSIDE DMCMK1), (AR_VDOP NOT INSIDE DMCMK1), (ARBL NOT INSIDE DMCMK1), Overlap is not allowed. >= 0.144um
 err1 = EXT AR_VDOP_outside_DMCMK1 DMC1 < 0.144 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_4_ARBL {
@ DMC1 space to AR_H, AR_V, (AR_HDOP NOT INSIDE DMCMK1), (AR_VDOP NOT INSIDE DMCMK1), (ARBL NOT INSIDE DMCMK1), Overlap is not allowed. >= 0.144um
 err1 = EXT ARBL_outside_DMCMK1 DMC1 < 0.144 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_5 {
@ DMC1 space to AR, Overlap is not allowed. >= 0.16um
 err1 = EXT DMC1 AR < 0.16 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_6 {
@ DMC1 space to (ARDUM NOT INSIDE DMCMK1), (ARDOP NOT INSIDE DMCMK1), Overlap is not allowed. >= 0.182um
 err1 = EXT DMC1 ARDUM_outside_DMCMK1 < 0.182 ABUT<90 SINGULAR REGION INSIDE ALSO
 err2 = EXT DMC1 ARDOP_outside_DMCMK1 < 0.182 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

DUMC_7 {
@ DMC1 space to (GTDUM NOT INSIDE DMCMK1), (GTDOP NOT INSIDE DMCMK1), Overlap is not allowed. >= 0.274um
 err1 = EXT DMC1 GTDUM_outside_DMCMK1 < 0.274 ABUT<90 SINGULAR REGION INSIDE ALSO
 err2 = EXT DMC1 GTDOP_outside_DMCMK1 < 0.274 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

DUMC_8 {
@ DMC1 space to GT_P96 edge, Cut is not allowed. >= 0.006um
 chk_area = (SIZE GT_P96 BY 0.006) NOT (SIZE GT_P96 BY -0.006)
 chk_area AND DMC1
}

DUMC_9 {
@ DMC1 space to (M0CDUM NOT INSIDE DMCMK1), Overlap is not allowed. >= 0.346um
 err1 = EXT DMC1 M0CDUM_outside_DMCMK1 < 0.346 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_10 {
@ DMC1 space to (M0CDOP NOT INSIDE DMCMK1), Overlap is not allowed. >= 0.75um
 err1 = EXT DMC1 M0CDOP_outside_DMCMK1 < 0.75 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_11 {
@ DMC1 space to INST, Overlap is not allowed. >= 0.21um
 err1 = EXT DMC1 INST < 0.210 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_12_PSUB {
@ DMC1 space to PSUB, NW, DNW edge . Cut is not allowed. >= 0.001um
 chk_area = (SIZE PSUB BY 0.001) NOT (SIZE PSUB BY -0.001)
 chk_area AND DMC1
}

DUMC_12_NW {
@ DMC1 space to PSUB, NW, DNW edge . Cut is not allowed. >= 0.001um
 chk_area = (SIZE NW BY 0.001) NOT (SIZE NW BY -0.001)
 chk_area AND DMC1
}

DUMC_12_DNW {
@ DMC1 space to PSUB, NW, DNW edge . Cut is not allowed. >= 0.001um
 chk_area = (SIZE DNW BY 0.001) NOT (SIZE DNW BY -0.001)
 chk_area AND DMC1
}

DUMC_13 {
@ DMC1 space to RESNW, Overlap is not allowed. >= 0.384um
 err1 = EXT DMC1 RESNW < 0.384 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_14 {
@ DMC1 space to PLRES, RESP2, LDBK, DMPNP, DSTR, VARMOS, EFUSE, V0, Overlap is not allowed. >= 0um
 err1 = DMC1 AND (OR PLRES RESP2 LDBK DMPNP DSTR VARMOS EFUSE V0)
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_15 {
@ DMC1 space to INDMY, Overlap is not allowed. >= 0.2um
 err1 = EXT DMC1 INDMY < 0.200 ABUT<90 SINGULAR REGION INSIDE ALSO
//; err2 = EXT DMC1 OCOVL < 0.200 ABUT<90 SINGULAR REGION MEASURE ALL
 err1 NOT INSIDE SealR_NOT_BULK
//; err2 NOT INSIDE SealR_NOT_BULK
}

DUMC_16 {
@ DMC1 space to OCCDFH, OCOVL_NOT_OCOVLM4, Overlap is not allowed. >= 3um
 err1 = EXT DMC1 OCCDFH < 3 ABUT<90 SINGULAR REGION INSIDE ALSO
 err2 = EXT DMC1 OCOVL_NOT_OCOVLM4 < 3 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

//DUMC_17 {
//@ DMC1 space to ESD1 >= 0.189um
// err1 = EXT DMC1 ESD1 < 0.189 ABUT<90 SINGULAR REGION MEASURE ALL
// err1 NOT INSIDE SealR_NOT_BULK
//}

DUMC_18 {
@ DMC1 space to DIOMK1, DIOMK2, Overlap is not allowed. >= 0.025um
 err1 = EXT DMC1 DIOMK1 < 0.025 ABUT<90 SINGULAR REGION INSIDE ALSO
 err2 = EXT DMC1 DIOMK2 < 0.025 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

DUMC_19 {
@ DMC1 space to MARKG, MARKS, NODMF, Overlap is not allowed. >= 0.4um
 err1 = EXT DMC1 MARKG < 0.400 ABUT<90 SINGULAR REGION INSIDE ALSO
 err2 = EXT DMC1 MARKS < 0.400 ABUT<90 SINGULAR REGION INSIDE ALSO
 err3 = EXT DMC1 NODMF < 0.400 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
}

DUMC_20_HVT_N {
@ DMC1 space to edge of HVT_N, HVT_P, SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, Cut is not allowed. >= 0.026um
 chk_area = (SIZE HVT_N BY 0.026) NOT (SIZE HVT_N BY -0.026)
 chk_area AND DMC1
}

DUMC_20_HVT_P {
@ DMC1 space to edge of HVT_N, HVT_P, SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, Cut is not allowed. >= 0.026um
 chk_area = (SIZE HVT_P BY 0.026) NOT (SIZE HVT_P BY -0.026)
 chk_area AND DMC1
}

DUMC_20_SVT_N {
@ DMC1 space to edge of HVT_N, HVT_P, SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, Cut is not allowed. >= 0.026um
 chk_area = (SIZE SVT_N BY 0.026) NOT (SIZE SVT_N BY -0.026)
 chk_area AND DMC1
}

DUMC_20_SVT_P {
@ DMC1 space to edge of HVT_N, HVT_P, SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, Cut is not allowed. >= 0.026um
 chk_area = (SIZE SVT_P BY 0.026) NOT (SIZE SVT_P BY -0.026)
 chk_area AND DMC1
}

DUMC_20_LVT_N {
@ DMC1 space to edge of HVT_N, HVT_P, SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, Cut is not allowed. >= 0.026um
 chk_area = (SIZE LVT_N BY 0.026) NOT (SIZE LVT_N BY -0.026)
 chk_area AND DMC1
}

DUMC_20_LVT_P {
@ DMC1 space to edge of HVT_N, HVT_P, SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, Cut is not allowed. >= 0.026um
 chk_area = (SIZE LVT_P BY 0.026) NOT (SIZE LVT_P BY -0.026)
 chk_area AND DMC1
}

DUMC_20_ULVT_N {
@ DMC1 space to edge of HVT_N, HVT_P, SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, Cut is not allowed. >= 0.026um
 chk_area = (SIZE ULVT_N BY 0.026) NOT (SIZE ULVT_N BY -0.026)
 chk_area AND DMC1
}

DUMC_20_ULVT_P {
@ DMC1 space to edge of HVT_N, HVT_P, SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, Cut is not allowed. >= 0.026um
 chk_area = (SIZE ULVT_P BY 0.026) NOT (SIZE ULVT_P BY -0.026)
 chk_area AND DMC1
}

DUMC_20_LFN_N {
@ DMC1 space to edge of HVT_N, HVT_P, SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, Cut is not allowed. >= 0.026um
 chk_area = (SIZE LFN_N BY 0.026) NOT (SIZE LFN_N BY -0.026)
 chk_area AND DMC1
}

DUMC_20_LFN_P {
@ DMC1 space to edge of HVT_N, HVT_P, SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, Cut is not allowed. >= 0.026um
 chk_area = (SIZE LFN_P BY 0.026) NOT (SIZE LFN_P BY -0.026)
 chk_area AND DMC1
}

DUMC_21_DG {
@ DMC1 space to edge of DG, DGUD, DGV, Cut is not allowed. >= 3um
 chk_area = (SIZE DG BY 3) NOT (SIZE DG BY -3)
 chk_area AND DMC1
}

DUMC_21_DGUD {
@ DMC1 space to edge of DG, DGUD, DGV, Cut is not allowed. >= 3um
 chk_area = (SIZE DGUD BY 3) NOT (SIZE DGUD BY -3)
 chk_area AND DMC1
}

DUMC_21_DGV {
@ DMC1 space to edge of DG, DGUD, DGV, Cut is not allowed. >= 3um
 chk_area = (SIZE DGV BY 3) NOT (SIZE DGV BY -3)
 chk_area AND DMC1
}

#IFDEF CHIPB_RULES_CHECK YES
DUMC_22 {
@ Inside edge of CHIPB space to DMC2, Outside and cut is not allowed >= 0.45um
 err1 = ENC DMC2 CHIPB < 0.45 ABUT<90 SINGULAR REGION OUTSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
#ENDIF

DUMC_23_DUMBA {
@ DMC2 space to DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, AR_H, AR_V, (AR_HDOP NOT INSIDE DMCMK1), (AR_VDOP NOT INSIDE DMCMK1), (ARBL NOT INSIDE DMCMK1), Overlap is not allowed. >= 0.144um
 err1 = EXT DMC2 DUMBA < 0.144 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_23_DUMBP {
@ DMC2 space to DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, AR_H, AR_V, (AR_HDOP NOT INSIDE DMCMK1), (AR_VDOP NOT INSIDE DMCMK1), (ARBL NOT INSIDE DMCMK1), Overlap is not allowed. >= 0.144um
 err1 = EXT DMC2 DUMBP < 0.144 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_23_ARDUB {
@ DMC2 space to DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, AR_H, AR_V, (AR_HDOP NOT INSIDE DMCMK1), (AR_VDOP NOT INSIDE DMCMK1), (ARBL NOT INSIDE DMCMK1), Overlap is not allowed. >= 0.144um
 err1 = EXT DMC2 ARDUB < 0.144 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_23_P2DUB {
@ DMC2 space to DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, AR_H, AR_V, (AR_HDOP NOT INSIDE DMCMK1), (AR_VDOP NOT INSIDE DMCMK1), (ARBL NOT INSIDE DMCMK1), Overlap is not allowed. >= 0.144um
 err1 = EXT DMC2 P2DUB < 0.144 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_23_M0DUB {
@ DMC2 space to DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, AR_H, AR_V, (AR_HDOP NOT INSIDE DMCMK1), (AR_VDOP NOT INSIDE DMCMK1), (ARBL NOT INSIDE DMCMK1), Overlap is not allowed. >= 0.144um
 err1 = EXT DMC2 M0DUB < 0.144 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_23_M0CDUB {
@ DMC2 space to DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, AR_H, AR_V, (AR_HDOP NOT INSIDE DMCMK1), (AR_VDOP NOT INSIDE DMCMK1), (ARBL NOT INSIDE DMCMK1), Overlap is not allowed. >= 0.144um
 err1 = EXT DMC2 M0CDUB < 0.144 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_23_M0GDUB {
@ DMC2 space to DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, AR_H, AR_V, (AR_HDOP NOT INSIDE DMCMK1), (AR_VDOP NOT INSIDE DMCMK1), (ARBL NOT INSIDE DMCMK1), Overlap is not allowed. >= 0.144um
 err1 = EXT DMC2 M0GDUB < 0.144 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_23_AR_H {
@ DMC2 space to DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, AR_H, AR_V, (AR_HDOP NOT INSIDE DMCMK1), (AR_VDOP NOT INSIDE DMCMK1), (ARBL NOT INSIDE DMCMK1), Overlap is not allowed. >= 0.144um
 err1 = EXT DMC2 AR_H < 0.144 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_23_AR_V {
@ DMC2 space to DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, AR_H, AR_V, (AR_HDOP NOT INSIDE DMCMK1), (AR_VDOP NOT INSIDE DMCMK1), (ARBL NOT INSIDE DMCMK1), Overlap is not allowed. >= 0.144um
 err1 = EXT DMC2 AR_V < 0.144 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_23_AR_HDOP {
@ DMC2 space to DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, AR_H, AR_V, (AR_HDOP NOT INSIDE DMCMK1), (AR_VDOP NOT INSIDE DMCMK1), (ARBL NOT INSIDE DMCMK1), Overlap is not allowed. >= 0.144um
 err1 = EXT DMC2 AR_HDOP_outside_DMCMK1 < 0.144 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_23_AR_VDOP {
@ DMC2 space to DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, AR_H, AR_V, (AR_HDOP NOT INSIDE DMCMK1), (AR_VDOP NOT INSIDE DMCMK1), (ARBL NOT INSIDE DMCMK1), Overlap is not allowed. >= 0.144um
 err1 = EXT DMC2 AR_VDOP_outside_DMCMK1 < 0.144 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_23_ARBL {
@ DMC2 space to DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, AR_H, AR_V, (AR_HDOP NOT INSIDE DMCMK1), (AR_VDOP NOT INSIDE DMCMK1), (ARBL NOT INSIDE DMCMK1), Overlap is not allowed. >= 0.144um
 err1 = EXT DMC2 ARBL_outside_DMCMK1 < 0.144 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_24_NPAA_EXT {
@ DMC2 space to NPAA_EXT, RESNW, MARKG, MARKS, NODMF, Overlap is not allowed. >= 0.4um
 err1 = EXT DMC2 NPAA_EXT < 0.4 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_24_RESNW {
@ DMC2 space to NPAA_EXT, RESNW, MARKG, MARKS, NODMF, Overlap is not allowed. >= 0.4um
 err1 = EXT DMC2 RESNW < 0.4 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_24_MARKG {
@ DMC2 space to NPAA_EXT, RESNW, MARKG, MARKS, NODMF, Overlap is not allowed. >= 0.4um
 err1 = EXT DMC2 MARKG < 0.4 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_24_MARKS {
@ DMC2 space to NPAA_EXT, RESNW, MARKG, MARKS, NODMF, Overlap is not allowed. >= 0.4um
 err1 = EXT DMC2 MARKS < 0.4 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_24_NODMF {
@ DMC2 space to NPAA_EXT, RESNW, MARKG, MARKS, NODMF, Overlap is not allowed. >= 0.4um
 err1 = EXT DMC2 NODMF < 0.4 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_25_AA {
@ DMC2 space to AA, AADMP, PPAA, M0, M0DMP, (M0DOP NOT INSIDE DMCMK1), M0G, M0GDMP, (M0GDOP NOT INSIDE DMCMK1), INDMY, DG, DGUD, DGV, Overlap is not allowed. >= 0.2um
 err1 = EXT DMC2 AA < 0.200 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_25_AADMP {
@ DMC2 space to AA, AADMP, PPAA, M0, M0DMP, (M0DOP NOT INSIDE DMCMK1), M0G, M0GDMP, (M0GDOP NOT INSIDE DMCMK1), INDMY, DG, DGUD, DGV, Overlap is not allowed. >= 0.2um
 err1 = EXT DMC2 AADMP < 0.200 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_25_PPAA {
@ DMC2 space to AA, AADMP, PPAA, M0, M0DMP, (M0DOP NOT INSIDE DMCMK1), M0G, M0GDMP, (M0GDOP NOT INSIDE DMCMK1), INDMY, DG, DGUD, DGV, Overlap is not allowed. >= 0.2um
 err1 = EXT DMC2 PPAA < 0.200 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_25_M0 {
@ DMC2 space to AA, AADMP, PPAA, M0, M0DMP, (M0DOP NOT INSIDE DMCMK1), M0G, M0GDMP, (M0GDOP NOT INSIDE DMCMK1), INDMY, DG, DGUD, DGV, Overlap is not allowed. >= 0.2um
 err1 = EXT DMC2 M0 < 0.200 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_25_M0DMP {
@ DMC2 space to AA, AADMP, PPAA, M0, M0DMP, (M0DOP NOT INSIDE DMCMK1), M0G, M0GDMP, (M0GDOP NOT INSIDE DMCMK1), INDMY, DG, DGUD, DGV, Overlap is not allowed. >= 0.2um
 err1 = EXT DMC2 M0DMP < 0.200 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_25_M0DOP {
@ DMC2 space to AA, AADMP, PPAA, M0, M0DMP, (M0DOP NOT INSIDE DMCMK1), M0G, M0GDMP, (M0GDOP NOT INSIDE DMCMK1), INDMY, DG, DGUD, DGV , Overlap is not allowed. >= 0.2um
 err1 = EXT DMC2 M0DOP_outside_DMCMK1 < 0.200 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_25_M0G {
@ DMC2 space to AA, AADMP, PPAA, M0, M0DMP, (M0DOP NOT INSIDE DMCMK1), M0G, M0GDMP, (M0GDOP NOT INSIDE DMCMK1), INDMY, DG, DGUD, DGV, Overlap is not allowed. >= 0.2um
 err1 = EXT DMC2 M0G < 0.200 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_25_M0GDMP {
@ DMC2 space to AA, AADMP, PPAA, M0, M0DMP, (M0DOP NOT INSIDE DMCMK1), M0G, M0GDMP, (M0GDOP NOT INSIDE DMCMK1), INDMY, DG, DGUD, DGV, Overlap is not allowed. >= 0.2um
 err1 = EXT DMC2 M0GDMP < 0.200 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_25_M0GDOP {
@ DMC2 space to AA, AADMP, PPAA, M0, M0DMP, (M0DOP NOT INSIDE DMCMK1), M0G, M0GDMP, (M0GDOP NOT INSIDE DMCMK1), INDMY, DG, DGUD, DGV, Overlap is not allowed. >= 0.2um
 err1 = EXT DMC2 M0GDOP_outside_DMCMK1 < 0.200 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_25_INDMY {
@ DMC2 space to AA, AADMP, PPAA, M0, M0DMP, (M0DOP NOT INSIDE DMCMK1), M0G, M0GDMP, (M0GDOP NOT INSIDE DMCMK1), INDMY, DG, DGUD, DGV, Overlap is not allowed. >= 0.2um
 err1 = EXT DMC2 INDMY < 0.200 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_25_DG {
@ DMC2 space to AA, AADMP, PPAA, M0, M0DMP, (M0DOP NOT INSIDE DMCMK1), M0G, M0GDMP, (M0GDOP NOT INSIDE DMCMK1), INDMY, DG, DGUD, DGV, Overlap is not allowed. >= 0.2um
 err1 = EXT DMC2 DG < 0.200 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_25_DGUD {
@ DMC2 space to AA, AADMP, PPAA, M0, M0DMP, (M0DOP NOT INSIDE DMCMK1), M0G, M0GDMP, (M0GDOP NOT INSIDE DMCMK1), INDMY, DG, DGUD, DGV, Overlap is not allowed. >= 0.2um
 err1 = EXT DMC2 DGUD < 0.200 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_25_DGV {
@ DMC2 space to AA, AADMP, PPAA, M0, M0DMP, (M0DOP NOT INSIDE DMCMK1), M0G, M0GDMP, (M0GDOP NOT INSIDE DMCMK1), INDMY, DG, DGUD, DGV, Overlap is not allowed. >= 0.2um
 err1 = EXT DMC2 DGV < 0.200 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

//DUMC_25_OCOVL_NOT_OCOVLM4 {
//@ DMC2 space to AA, AADMP, PPAA, M0, M0DMP, (M0DOP NOT INSIDE DMCMK1), M0G, M0GDMP, (M0GDOP NOT INSIDE DMCMK1), INDMY, OCOVL_NOT_OCOVLM4, DG, DGUD, DGV >= 0.2um
// err1 = EXT DMC2 OCOVL_NOT_OCOVLM4 < 0.200 ABUT<90 SINGULAR REGION MEASURE ALL
// err1 NOT INSIDE SealR_NOT_BULK
//}

DUMC_26_AADUM {
@ DMC2 space to (AADUM NOT INSIDE DMCMK1), (AADOP NOT INSIDE DMCMK1), (P2DUM NOT INSIDE DMCMK1), (M0DUM NOT INSIDE DMCMK1), M0C, M0CDMP, (M0GDUM NOT INSIDE DMCMK1), Overlap is not allowed. >= 0.27um
 err1 = EXT DMC2 AADUM_outside_DMCMK1 < 0.27 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_26_AADOP {
@ DMC2 space to (AADUM NOT INSIDE DMCMK1), (AADOP NOT INSIDE DMCMK1), (P2DUM NOT INSIDE DMCMK1), (M0DUM NOT INSIDE DMCMK1), M0C, M0CDMP, (M0GDUM NOT INSIDE DMCMK1), Overlap is not allowed. >= 0.27um
 err1 = EXT DMC2 AADOP_outside_DMCMK1 < 0.27 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_26_P2DUM {
@ DMC2 space to (AADUM NOT INSIDE DMCMK1), (AADOP NOT INSIDE DMCMK1), (P2DUM NOT INSIDE DMCMK1), (M0DUM NOT INSIDE DMCMK1), M0C, M0CDMP, (M0GDUM NOT INSIDE DMCMK1), Overlap is not allowed. >= 0.27um
 err1 = EXT DMC2 P2DUM_outside_DMCMK1 < 0.27 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_26_M0DUM {
@ DMC2 space to (AADUM NOT INSIDE DMCMK1), (AADOP NOT INSIDE DMCMK1), (P2DUM NOT INSIDE DMCMK1), (M0DUM NOT INSIDE DMCMK1), M0C, M0CDMP, (M0GDUM NOT INSIDE DMCMK1), Overlap is not allowed. >= 0.27um
 err1 = EXT DMC2 M0DUM_outside_DMCMK1 < 0.27 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_26_M0C {
@ DMC2 space to (AADUM NOT INSIDE DMCMK1), (AADOP NOT INSIDE DMCMK1), (P2DUM NOT INSIDE DMCMK1), (M0DUM NOT INSIDE DMCMK1), M0C, M0CDMP, (M0GDUM NOT INSIDE DMCMK1), Overlap is not allowed. >= 0.27um
 err1 = EXT DMC2 M0C < 0.27 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_26_M0CDMP {
@ DMC2 space to (AADUM NOT INSIDE DMCMK1), (AADOP NOT INSIDE DMCMK1), (P2DUM NOT INSIDE DMCMK1), (M0DUM NOT INSIDE DMCMK1), M0C, M0CDMP, (M0GDUM NOT INSIDE DMCMK1), Overlap is not allowed. >= 0.27um
 err1 = EXT DMC2 M0CDMP < 0.27 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_26_M0GDUM {
@ DMC2 space to (AADUM NOT INSIDE DMCMK1), (AADOP NOT INSIDE DMCMK1), (P2DUM NOT INSIDE DMCMK1), (M0DUM NOT INSIDE DMCMK1), M0C, M0CDMP, (M0GDUM NOT INSIDE DMCMK1), Overlap is not allowed. >= 0.27um
 err1 = EXT DMC2 M0GDUM_outside_DMCMK1 < 0.27 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_27 {
@ DMC2 space to AR, Overlap is not allowed. >= 0.16um
 err1 = EXT DMC2 AR < 0.16 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_28 {
@ DMC2 space to (ARDUM NOT INSIDE DMCMK1), (ARDOP NOT INSIDE DMCMK1), Overlap is not allowed. >= 0.182um
 err1 = EXT DMC2 ARDUM_outside_DMCMK1 < 0.182 ABUT<90 SINGULAR REGION INSIDE ALSO
 err2 = EXT DMC2 ARDOP_outside_DMCMK1 < 0.182 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

DUMC_29 {
@ DMC2 space to GT, GTDMP, (GTDUM NOT INSIDE DMCMK1), (GTDOP NOT INSIDE DMCMK1), Overlap is not allowed. >= 0.274um
 err1 = EXT DMC2 DMP_GT < 0.274 ABUT<90 SINGULAR REGION INSIDE ALSO
 err2 = EXT DMC2 GTDUM_outside_DMCMK1 < 0.274 ABUT<90 SINGULAR REGION INSIDE ALSO
 err3 = EXT DMC2 GTDOP_outside_DMCMK1 < 0.274 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
}

DUMC_30_GT_P96 {
@ DMC2 space to edge of GT_P96, PSUB, NW, DNW, SN, SP, (SNDUM NOT INSIDE DMCMK1), (SPDUM NOT INSIDE DMCMK1), HVT_N, HVT_P, SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, Cut is not allowed. >= 0.001um
 chk_area = (SIZE GT_P96 BY 0.001) NOT (SIZE GT_P96 BY -0.001)
 chk_area AND DMC2
}

DUMC_30_PSUB {
@ DMC2 space to edge of GT_P96, PSUB, NW, DNW, SN, SP, (SNDUM NOT INSIDE DMCMK1), (SPDUM NOT INSIDE DMCMK1), HVT_N, HVT_P, SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, Cut is not allowed. >= 0.001um
 chk_area = (SIZE PSUB BY 0.001) NOT (SIZE PSUB BY -0.001)
 chk_area AND DMC2
}

DUMC_30_NW {
@ DMC2 space to edge of GT_P96, PSUB, NW, DNW, SN, SP, (SNDUM NOT INSIDE DMCMK1), (SPDUM NOT INSIDE DMCMK1), HVT_N, HVT_P, SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, Cut is not allowed. >= 0.001um
 chk_area = (SIZE NW BY 0.001) NOT (SIZE NW BY -0.001)
 chk_area AND DMC2
}

DUMC_30_DNW {
@ DMC2 space to edge of GT_P96, PSUB, NW, DNW, SN, SP, (SNDUM NOT INSIDE DMCMK1), (SPDUM NOT INSIDE DMCMK1), HVT_N, HVT_P, SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, Cut is not allowed. >= 0.001um
 chk_area = (SIZE DNW BY 0.001) NOT (SIZE DNW BY -0.001)
 chk_area AND DMC2
}

DUMC_30_SN {
@ DMC2 space to edge of GT_P96, PSUB, NW, DNW, SN, SP, (SNDUM NOT INSIDE DMCMK1), (SPDUM NOT INSIDE DMCMK1), HVT_N, HVT_P, SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, Cut is not allowed. >= 0.001um
 chk_area = (SIZE SN BY 0.001) NOT (SIZE SN BY -0.001)
 chk_area AND DMC2
}

DUMC_30_SP {
@ DMC2 space to edge of GT_P96, PSUB, NW, DNW, SN, SP, (SNDUM NOT INSIDE DMCMK1), (SPDUM NOT INSIDE DMCMK1) HVT_N, HVT_P, SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, Cut is not allowed. >= 0.001um
 chk_area = (SIZE SP BY 0.001) NOT (SIZE SP BY -0.001)
 chk_area AND DMC2
}

DUMC_30_SNDUM {
@ DMC2 space to edge of GT_P96, PSUB, NW, DNW, SN, SP, (SNDUM NOT INSIDE DMCMK1), (SPDUM NOT INSIDE DMCMK1), HVT_N, HVT_P, SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, Cut is not allowed. >= 0.001um
 chk_area = (SIZE SNDUM_outside_DMCMK1 BY 0.001) NOT (SIZE SNDUM_outside_DMCMK1 BY -0.001)
 chk_area AND DMC2
}

DUMC_30_SPDUM {
@ DMC2 space to edge of GT_P96, PSUB, NW, DNW, SN, SP, (SNDUM NOT INSIDE DMCMK1), (SPDUM NOT INSIDE DMCMK1), HVT_N, HVT_P, SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, Cut is not allowed. >= 0.001um
 chk_area = (SIZE SPDUM_outside_DMCMK1 BY 0.001) NOT (SIZE SPDUM_outside_DMCMK1 BY -0.001)
 chk_area AND DMC2
}

DUMC_30_HVT_N {
@ DMC2 space to edge of GT_P96, PSUB, NW, DNW, SN, SP, (SNDUM NOT INSIDE DMCMK1), (SPDUM NOT INSIDE DMCMK1), HVT_N, HVT_P, SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, Cut is not allowed. >= 0.001um
 chk_area = (SIZE HVT_N BY 0.001) NOT (SIZE HVT_N BY -0.001)
 chk_area AND DMC2
}

DUMC_30_HVT_P {
@ DMC2 space to edge of GT_P96, PSUB, NW, DNW, SN, SP, (SNDUM NOT INSIDE DMCMK1), (SPDUM NOT INSIDE DMCMK1), HVT_N, HVT_P, SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, Cut is not allowed. >= 0.001um
 chk_area = (SIZE HVT_P BY 0.001) NOT (SIZE HVT_P BY -0.001)
 chk_area AND DMC2
}

DUMC_30_SVT_N {
@ DMC2 space to edge of GT_P96, PSUB, NW, DNW, SN, SP, (SNDUM NOT INSIDE DMCMK1), (SPDUM NOT INSIDE DMCMK1), HVT_N, HVT_P, SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, Cut is not allowed. >= 0.001um
 chk_area = (SIZE SVT_N BY 0.001) NOT (SIZE SVT_N BY -0.001)
 chk_area AND DMC2
}

DUMC_30_SVT_P {
@ DMC2 space to edge of GT_P96, PSUB, NW, DNW, SN, SP, (SNDUM NOT INSIDE DMCMK1), (SPDUM NOT INSIDE DMCMK1), HVT_N, HVT_P, SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, Cut is not allowed. >= 0.001um
 chk_area = (SIZE SVT_P BY 0.001) NOT (SIZE SVT_P BY -0.001)
 chk_area AND DMC2
}

DUMC_30_LVT_N {
@ DMC2 space to edge of GT_P96, PSUB, NW, DNW, SN, SP, (SNDUM NOT INSIDE DMCMK1), (SPDUM NOT INSIDE DMCMK1), HVT_N, HVT_P, SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, Cut is not allowed. >= 0.001um
 chk_area = (SIZE LVT_N BY 0.001) NOT (SIZE LVT_N BY -0.001)
 chk_area AND DMC2
}

DUMC_30_LVT_P {
@ DMC2 space to edge of GT_P96, PSUB, NW, DNW, SN, SP, (SNDUM NOT INSIDE DMCMK1), (SPDUM NOT INSIDE DMCMK1), HVT_N, HVT_P, SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, Cut is not allowed. >= 0.001um
 chk_area = (SIZE LVT_P BY 0.001) NOT (SIZE LVT_P BY -0.001)
 chk_area AND DMC2
}

DUMC_30_ULVT_N {
@ DMC2 space to edge of GT_P96, PSUB, NW, DNW, SN, SP, (SNDUM NOT INSIDE DMCMK1), (SPDUM NOT INSIDE DMCMK1), HVT_N, HVT_P, SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, Cut is not allowed. >= 0.001um
 chk_area = (SIZE ULVT_N BY 0.001) NOT (SIZE ULVT_N BY -0.001)
 chk_area AND DMC2
}

DUMC_30_ULVT_P {
@ DMC2 space to edge of GT_P96, PSUB, NW, DNW, SN, SP, (SNDUM NOT INSIDE DMCMK1), (SPDUM NOT INSIDE DMCMK1), HVT_N, HVT_P, SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, Cut is not allowed. >= 0.001um
 chk_area = (SIZE ULVT_P BY 0.001) NOT (SIZE ULVT_P BY -0.001)
 chk_area AND DMC2
}

DUMC_30_LFN_N {
@ DMC2 space to edge of GT_P96, PSUB, NW, DNW, SN, SP, (SNDUM NOT INSIDE DMCMK1), (SPDUM NOT INSIDE DMCMK1), HVT_N, HVT_P, SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, Cut is not allowed. >= 0.001um
 chk_area = (SIZE LFN_N BY 0.001) NOT (SIZE LFN_N BY -0.001)
 chk_area AND DMC2
}

DUMC_30_LFN_P {
@ DMC2 space to edge of GT_P96, PSUB, NW, DNW, SN, SP, (SNDUM NOT INSIDE DMCMK1), (SPDUM NOT INSIDE DMCMK1), HVT_N, HVT_P, SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, Cut is not allowed. >= 0.001um
 chk_area = (SIZE LFN_P BY 0.001) NOT (SIZE LFN_P BY -0.001)
 chk_area AND DMC2
}

DUMC_31 {
@ DMC2 space to P2, P2DMP, (P2DOP NOT INSIDE DMCMK1), Overlap is not allowed. >= 0.18um
 err1 = EXT DMC2 P2 < 0.18 ABUT<90 SINGULAR REGION INSIDE ALSO
 err2 = EXT DMC2 P2DMP < 0.18 ABUT<90 SINGULAR REGION INSIDE ALSO
 err3 = EXT DMC2 P2DOP_outside_DMCMK1 < 0.18 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
}

DUMC_32 {
@ DMC2 horizontal space to M0DOP_M0, Overlap is not allowed. >= 0.215um
 err1 = EXT (ANGLE DMC2 == 90) M0DOP_M0 < 0.215 ABUT<90 OPPOSITE REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_33 {
@ DMC2 space to (M0CDUM NOT INSIDE DMCMK1), Overlap is not allowed. >= 0.3um
 err1 = EXT DMC2 M0CDUM_outside_DMCMK1 < 0.300 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_34 {
@ DMC2 space to (M0CDOP NOT INSIDE DMCMK1), Overlap is not allowed. >= 0.75um
 err1 = EXT DMC2 M0CDOP_outside_DMCMK1 < 0.750 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_35 {
@ DMC2 space to INST, Overlap is not allowed. >= 0.21um
 err1 = EXT DMC2 INST < 0.210 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_36 {
@ DMC2 space to DIR, DIRDMP, RESP1, Overlap is not allowed. >= 0.35um
 err1 = EXT DMC2 DIR < 0.35 ABUT<90 SINGULAR REGION INSIDE ALSO
 err2 = EXT DMC2 DIRDMP < 0.35 ABUT<90 SINGULAR REGION INSIDE ALSO
 err3 = EXT DMC2 RESP1 < 0.35 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
}

DUMC_37 {
@ DMC2 space to PLRES, RESP2, LDBK, DMPNP, DSTR, VARMOS, EFUSE, Overlap is not allowed. >= 0um
 err1 = DMC2 AND (OR PLRES RESP2 LDBK DMPNP DSTR VARMOS EFUSE)
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_38 {
@ DMC2 space to RSPMK1, Overlap is not allowed. >= 0.001um
 err1 = EXT DMC2 RSPMK1 < 0.001 ABUT<90 SINGULAR REGION INSIDE ALSO
// err2 = EXT DMC2 RSPMK2 < 0.001 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
// err2 NOT INSIDE SealR_NOT_BULK
}

DUMC_39 {
@ DMC2 space to OCCDFH, Overlap is not allowed. >= 0.32um
 err1 = EXT DMC2 OCCDFH < 0.32 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

//DUMC_40 {
//@ DMC2 space to ESD1 >= 0.189um
// err1 = EXT DMC2 ESD1 < 0.189 ABUT<90 SINGULAR REGION MEASURE ALL
// err1 NOT INSIDE SealR_NOT_BULK
//}

DUMC_41 {
@ DMC2 space to DIOMK1, DIOMK2, Overlap is not allowed. >= 0.025um
 err1 = EXT DMC2 DIOMK1 < 0.025 ABUT<90 SINGULAR REGION INSIDE ALSO
 err2 = EXT DMC2 DIOMK2 < 0.025 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

DUMC_42 {
@ DMC2 space to V0, Overlap is not allowed. >= 0.04um
 err1 = EXT DMC2 V0 < 0.04 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_43 {
@ DMC2 space to DMC1, Overlap is not allowed. >= 0.285um
 err1 = EXT DMC2 DMC1 < 0.285 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

#IFDEF CHIPB_RULES_CHECK YES
DUMC_44 {
@ Inside edge of CHIPB space to DMC3, Outside and cut is not allowed. >= 0.45um
 err1 = ENC DMC3 CHIPB < 0.45 ABUT<90 SINGULAR REGION OUTSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
#ENDIF

DUMC_45_DUMBA {
@ DMC3 space to DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, AR_H, AR_V, (AR_HDOP NOT INSIDE DMCMK1), (AR_VDOP NOT INSIDE DMCMK1), (ARBL NOT INSIDE DMCMK1), Overlap is not allowed. >= 0.144um
 err1 = EXT DMC3 DUMBA < 0.144 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_45_DUMBP {
@ DMC3 space to DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, AR_H, AR_V, (AR_HDOP NOT INSIDE DMCMK1), (AR_VDOP NOT INSIDE DMCMK1), (ARBL NOT INSIDE DMCMK1), Overlap is not allowed. >= 0.144um
 err1 = EXT DMC3 DUMBP < 0.144 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_45_ARDUB {
@ DMC3 space to DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, AR_H, AR_V, (AR_HDOP NOT INSIDE DMCMK1), (AR_VDOP NOT INSIDE DMCMK1), (ARBL NOT INSIDE DMCMK1), Overlap is not allowed. >= 0.144um
 err1 = EXT DMC3 ARDUB < 0.144 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_45_P2DUB {
@ DMC3 space to DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, AR_H, AR_V, (AR_HDOP NOT INSIDE DMCMK1), (AR_VDOP NOT INSIDE DMCMK1), (ARBL NOT INSIDE DMCMK1), Overlap is not allowed. >= 0.144um
 err1 = EXT DMC3 P2DUB < 0.144 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_45_M0DUB {
@ DMC3 space to DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, AR_H, AR_V, (AR_HDOP NOT INSIDE DMCMK1), (AR_VDOP NOT INSIDE DMCMK1), (ARBL NOT INSIDE DMCMK1), Overlap is not allowed. >= 0.144um
 err1 = EXT DMC3 M0DUB < 0.144 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_45_M0CDUB {
@ DMC3 space to DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, AR_H, AR_V, (AR_HDOP NOT INSIDE DMCMK1), (AR_VDOP NOT INSIDE DMCMK1), (ARBL NOT INSIDE DMCMK1), Overlap is not allowed. >= 0.144um
 err1 = EXT DMC3 M0CDUB < 0.144 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_45_M0GDUB {
@ DMC3 space to DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, AR_H, AR_V, (AR_HDOP NOT INSIDE DMCMK1), (AR_VDOP NOT INSIDE DMCMK1), (ARBL NOT INSIDE DMCMK1), Overlap is not allowed. >= 0.144um
 err1 = EXT DMC3 M0GDUB < 0.144 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_45_AR_H {
@ DMC3 space to DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, AR_H, AR_V, (AR_HDOP NOT INSIDE DMCMK1), (AR_VDOP NOT INSIDE DMCMK1), (ARBL NOT INSIDE DMCMK1), Overlap is not allowed. >= 0.144um
 err1 = EXT DMC3 AR_H < 0.144 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_45_AR_V {
@ DMC3 space to DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, AR_H, AR_V, (AR_HDOP NOT INSIDE DMCMK1), (AR_VDOP NOT INSIDE DMCMK1), (ARBL NOT INSIDE DMCMK1), Overlap is not allowed. >= 0.144um
 err1 = EXT DMC3 AR_V < 0.144 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_45_AR_HDOP {
@ DMC3 space to DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, AR_H, AR_V, (AR_HDOP NOT INSIDE DMCMK1), (AR_VDOP NOT INSIDE DMCMK1), (ARBL NOT INSIDE DMCMK1), Overlap is not allowed. >= 0.144um
 err1 = EXT DMC3 AR_HDOP_outside_DMCMK1 < 0.144 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_45_AR_VDOP {
@ DMC3 space to DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, AR_H, AR_V, (AR_HDOP NOT INSIDE DMCMK1), (AR_VDOP NOT INSIDE DMCMK1), (ARBL NOT INSIDE DMCMK1), Overlap is not allowed. >= 0.144um
 err1 = EXT DMC3 AR_VDOP_outside_DMCMK1 < 0.144 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_45_ARBL {
@ DMC3 space to DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, AR_H, AR_V, (AR_HDOP NOT INSIDE DMCMK1), (AR_VDOP NOT INSIDE DMCMK1), (ARBL NOT INSIDE DMCMK1), Overlap is not allowed. >= 0.144um
 err1 = EXT DMC3 ARBL_outside_DMCMK1 < 0.144 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_46_NPAA_EXT {
@ DMC3 space to NPAA_EXT, RESNW, MARKG, MARKS, NODMF, Overlap is not allowed. >= 0.4um
 err1 = EXT DMC3 NPAA_EXT < 0.4 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_46_RESNW {
@ DMC3 space to NPAA_EXT, RESNW, MARKG, MARKS, NODMF, Overlap is not allowed. >= 0.4um
 err1 = EXT DMC3 RESNW < 0.4 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_46_MARKG {
@ DMC3 space to NPAA_EXT, RESNW, MARKG, MARKS, NODMF, Overlap is not allowed. >= 0.4um
 err1 = EXT DMC3 MARKG < 0.4 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_46_MARKS {
@ DMC3 space to NPAA_EXT, RESNW, MARKG, MARKS, NODMF, Overlap is not allowed. >= 0.4um
 err1 = EXT DMC3 MARKS < 0.4 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_46_NODMF {
@ DMC3 space to NPAA_EXT, RESNW, MARKG, MARKS, NODMF, Overlap is not allowed. >= 0.4um
 err1 = EXT DMC3 NODMF < 0.4 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_47_AA {
@ DMC3 space to AA, AADMP, PPAA, M0, M0DMP, (M0DOP NOT INSIDE DMCMK1), M0G, M0GDMP, (M0GDOP NOT INSIDE DMCMK1), INDMY, Overlap is not allowed. >= 0.2um
 err1 = EXT DMC3 AA < 0.2 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_47_AADMP {
@ DMC3 space to AA, AADMP, PPAA, M0, M0DMP, (M0DOP NOT INSIDE DMCMK1), M0G, M0GDMP, (M0GDOP NOT INSIDE DMCMK1), INDMY, Overlap is not allowed. >= 0.2um
 err1 = EXT DMC3 AADMP < 0.2 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_47_PPAA {
@ DMC3 space to AA, AADMP, PPAA, M0, M0DMP, (M0DOP NOT INSIDE DMCMK1), M0G, M0GDMP, (M0GDOP NOT INSIDE DMCMK1), INDMY, Overlap is not allowed. >= 0.2um
 err1 = EXT DMC3 PPAA < 0.2 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_47_M0 {
@ DMC3 space to AA, AADMP, PPAA, M0, M0DMP, (M0DOP NOT INSIDE DMCMK1), M0G, M0GDMP, (M0GDOP NOT INSIDE DMCMK1), INDMY, Overlap is not allowed. >= 0.2um
 err1 = EXT DMC3 M0 < 0.2 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_47_M0DMP {
@ DMC3 space to AA, AADMP, PPAA, M0, M0DMP, (M0DOP NOT INSIDE DMCMK1), M0G, M0GDMP, (M0GDOP NOT INSIDE DMCMK1), INDMY, Overlap is not allowed. >= 0.2um
 err1 = EXT DMC3 M0DMP < 0.2 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_47_M0DOP {
@ DMC3 space to AA, AADMP, PPAA, M0, M0DMP, (M0DOP NOT INSIDE DMCMK1), M0G, M0GDMP, (M0GDOP NOT INSIDE DMCMK1), INDMY, Overlap is not allowed. >= 0.2um
 err1 = EXT DMC3 M0DOP_outside_DMCMK1 < 0.2 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_47_M0G {
@ DMC3 space to AA, AADMP, PPAA, M0, M0DMP, (M0DOP NOT INSIDE DMCMK1), M0G, M0GDMP, (M0GDOP NOT INSIDE DMCMK1), INDMY, Overlap is not allowed. >= 0.2um
 err1 = EXT DMC3 M0G < 0.2 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_47_M0GDMP {
@ DMC3 space to AA, AADMP, PPAA, M0, M0DMP, (M0DOP NOT INSIDE DMCMK1), M0G, M0GDMP, (M0GDOP NOT INSIDE DMCMK1), INDMY, Overlap is not allowed. >= 0.2um
 err1 = EXT DMC3 M0GDMP < 0.2 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_47_M0GDOP {
@ DMC3 space to AA, AADMP, PPAA, M0, M0DMP, (M0DOP NOT INSIDE DMCMK1), M0G, M0GDMP, (M0GDOP NOT INSIDE DMCMK1), INDMY, Overlap is not allowed. >= 0.2um
 err1 = EXT DMC3 M0GDOP_outside_DMCMK1 < 0.2 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_47_INDMY {
@ DMC3 space to AA, AADMP, PPAA, M0, M0DMP, (M0DOP NOT INSIDE DMCMK1), M0G, M0GDMP, (M0GDOP NOT INSIDE DMCMK1), INDMY, Overlap is not allowed. >= 0.2um
 err1 = EXT DMC3 INDMY < 0.2 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

//DUMC_47_OCOVL_NOT_OCOVLM4 {
//@ DMC3 space to AA, AADMP, PPAA, M0, M0DMP, (M0DOP NOT INSIDE DMCMK1), M0G, M0GDMP, (M0GDOP NOT INSIDE DMCMK1), INDMY, OCOVL_NOT_OCOVLM4 >= 0.2um
//err1 = EXT DMC3 OCOVL_NOT_OCOVLM4 < 0.2 ABUT<90 SINGULAR REGION MEASURE ALL
// err1 NOT INSIDE SealR_NOT_BULK
//}

DUMC_48_AADUM {
@ DMC3 space to (AADUM NOT INSIDE DMCMK1), (AADOP NOT INSIDE DMCMK1), (P2DUM NOT INSIDE DMCMK1), (M0DUM NOT INSIDE DMCMK1), M0C, M0CDMP, (M0GDUM NOT INSIDE DMCMK1), DMC1, Overlap is not allowed. >= 0.27um
 err1 = EXT DMC3 AADUM_outside_DMCMK1 < 0.27 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_48_AADOP {
@ DMC3 space to (AADUM NOT INSIDE DMCMK1), (AADOP NOT INSIDE DMCMK1), (P2DUM NOT INSIDE DMCMK1), (M0DUM NOT INSIDE DMCMK1), M0C, M0CDMP, (M0GDUM NOT INSIDE DMCMK1), DMC1, Overlap is not allowed. >= 0.27um
 err1 = EXT DMC3 AADOP_outside_DMCMK1 < 0.27 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_48_P2DUM {
@ DMC3 space to (AADUM NOT INSIDE DMCMK1), (AADOP NOT INSIDE DMCMK1), (P2DUM NOT INSIDE DMCMK1), (M0DUM NOT INSIDE DMCMK1), M0C, M0CDMP, (M0GDUM NOT INSIDE DMCMK1), DMC1, Overlap is not allowed. >= 0.27um
 err1 = EXT DMC3 P2DUM_outside_DMCMK1 < 0.27 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_48_M0DUM {
@ DMC3 space to (AADUM NOT INSIDE DMCMK1), (AADOP NOT INSIDE DMCMK1), (P2DUM NOT INSIDE DMCMK1), (M0DUM NOT INSIDE DMCMK1), M0C, M0CDMP, (M0GDUM NOT INSIDE DMCMK1), DMC1, Overlap is not allowed. >= 0.27um
 err1 = EXT DMC3 M0DUM_outside_DMCMK1 < 0.27 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_48_M0C {
@ DMC3 space to (AADUM NOT INSIDE DMCMK1), (AADOP NOT INSIDE DMCMK1), (P2DUM NOT INSIDE DMCMK1), (M0DUM NOT INSIDE DMCMK1), M0C, M0CDMP, (M0GDUM NOT INSIDE DMCMK1), DMC1, Overlap is not allowed. >= 0.27um
 err1 = EXT DMC3 M0C < 0.27 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_48_M0CDMP {
@ DMC3 space to (AADUM NOT INSIDE DMCMK1), (AADOP NOT INSIDE DMCMK1), (P2DUM NOT INSIDE DMCMK1), (M0DUM NOT INSIDE DMCMK1), M0C, M0CDMP, (M0GDUM NOT INSIDE DMCMK1), DMC1, Overlap is not allowed. >= 0.27um
 err1 = EXT DMC3 M0CDMP < 0.27 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_48_M0GDUM {
@ DMC3 space to (AADUM NOT INSIDE DMCMK1), (AADOP NOT INSIDE DMCMK1), (P2DUM NOT INSIDE DMCMK1), (M0DUM NOT INSIDE DMCMK1), M0C, M0CDMP, (M0GDUM NOT INSIDE DMCMK1), DMC1, Overlap is not allowed. >= 0.27um
 err1 = EXT DMC3 M0GDUM_outside_DMCMK1 < 0.27 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_48_DMC1 {
@ DMC3 space to (AADUM NOT INSIDE DMCMK1), (AADOP NOT INSIDE DMCMK1), (P2DUM NOT INSIDE DMCMK1), (M0DUM NOT INSIDE DMCMK1), M0C, M0CDMP, (M0GDUM NOT INSIDE DMCMK1), DMC1, Overlap is not allowed. >= 0.27um
 err1 = EXT DMC3 DMC1 < 0.27 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_49 {
@ DMC3 space to AR, Overlap is not allowed. >= 0.16um
 err1 = EXT DMC3 AR < 0.16 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_50 {
@ DMC3 space to (ARDUM NOT INSIDE DMCMK1), (ARDOP NOT INSIDE DMCMK1), Overlap is not allowed. >= 0.182um
 err1 = EXT DMC3 ARDUM_outside_DMCMK1 < 0.182 ABUT<90 SINGULAR REGION INSIDE ALSO
 err2 = EXT DMC3 ARDOP_outside_DMCMK1 < 0.182 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

DUMC_51 {
@ DMC3 space to GT, GTDMP, (GTDUM NOT INSIDE DMCMK1), (GTDOP NOT INSIDE DMCMK1), Overlap is not allowed. >= 0.274um
 err1 = EXT DMC3 DMP_GT < 0.274 ABUT<90 SINGULAR REGION INSIDE ALSO
 err2 = EXT DMC3 GTDUM_outside_DMCMK1 < 0.274 ABUT<90 SINGULAR REGION INSIDE ALSO
 err3 = EXT DMC3 GTDOP_outside_DMCMK1 < 0.274 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
}

DUMC_52_GT_P96 {
@ DMC3 space to edge of GT_P96, PSUB, NW, DNW, SN, SP, (SNDUM NOT INSIDE DMCMK1), (SPDUM NOT INSIDE DMCMK1), Cut is not allowed. >= 0.001um
 chk_area = (SIZE GT_P96 BY 0.001) NOT (SIZE GT_P96 BY -0.001)
 chk_area AND DMC3
}

DUMC_52_PSUB {
@ DMC3 space to edge of GT_P96, PSUB, NW, DNW, SN, SP, (SNDUM NOT INSIDE DMCMK1), (SPDUM NOT INSIDE DMCMK1), Cut is not allowed. >= 0.001um
 chk_area = (SIZE PSUB BY 0.001) NOT (SIZE PSUB BY -0.001)
 chk_area AND DMC3
}

DUMC_52_NW {
@ DMC3 space to edge of GT_P96, PSUB, NW, DNW, SN, SP, (SNDUM NOT INSIDE DMCMK1), (SPDUM NOT INSIDE DMCMK1), Cut is not allowed. >= 0.001um
 chk_area = (SIZE NW BY 0.001) NOT (SIZE NW BY -0.001)
 chk_area AND DMC3
}

DUMC_52_DNW {
@ DMC3 space to edge of GT_P96, PSUB, NW, DNW, SN, SP, (SNDUM NOT INSIDE DMCMK1), (SPDUM NOT INSIDE DMCMK1), Cut is not allowed. >= 0.001um
 chk_area = (SIZE DNW BY 0.001) NOT (SIZE DNW BY -0.001)
 chk_area AND DMC3
}

DUMC_52_SN {
@ DMC3 space to edge of GT_P96, PSUB, NW, DNW, SN, SP, (SNDUM NOT INSIDE DMCMK1), (SPDUM NOT INSIDE DMCMK1), Cut is not allowed. >= 0.001um
 chk_area = (SIZE SN BY 0.001) NOT (SIZE SN BY -0.001)
 chk_area AND DMC3
}

DUMC_52_SP {
@ DMC3 space to edge of GT_P96, PSUB, NW, DNW, SN, SP, (SNDUM NOT INSIDE DMCMK1), (SPDUM NOT INSIDE DMCMK1), Cut is not allowed. >= 0.001um
 chk_area = (SIZE SP BY 0.001) NOT (SIZE SP BY -0.001)
 chk_area AND DMC3
}

DUMC_52_SNDUM {
@ DMC3 space to edge of GT_P96, PSUB, NW, DNW, SN, SP, (SNDUM NOT INSIDE DMCMK1), (SPDUM NOT INSIDE DMCMK1), Cut is not allowed. >= 0.001um
 chk_area = (SIZE SNDUM_outside_DMCMK1 BY 0.001) NOT (SIZE SNDUM_outside_DMCMK1 BY -0.001)
 chk_area AND DMC3
}

DUMC_52_SPDUM {
@ DMC3 space to edge of GT_P96, PSUB, NW, DNW, SN, SP, (SNDUM NOT INSIDE DMCMK1), (SPDUM NOT INSIDE DMCMK1), Cut is not allowed. >= 0.001um
 chk_area = (SIZE SPDUM_outside_DMCMK1 BY 0.001) NOT (SIZE SPDUM_outside_DMCMK1 BY -0.001)
 chk_area AND DMC3
}

DUMC_53 {
@ DMC3 space to P2, P2DMP, (P2DOP NOT INSIDE DMCMK1), Overlap is not allowed. >= 0.18um
 err1 = EXT DMC3 P2 < 0.18 ABUT<90 SINGULAR REGION INSIDE ALSO
 err2 = EXT DMC3 P2DMP < 0.18 ABUT<90 SINGULAR REGION INSIDE ALSO
 err3 = EXT DMC3 P2DOP_outside_DMCMK1 < 0.18 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
}

DUMC_54 {
@ DMC3 horizontal space to M0DOP_M0_40, Overlap is not allowed. >= 0.23um
 err1 = EXT M0DOP_M0_40 (ANGLE DMC3 == 90) < 0.23 ABUT<90 OPPOSITE REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_55 {
@ DMC3 space to (M0CDUM NOT INSIDE DMCMK1), Overlap is not allowed. >= 0.3um
 err1 = EXT DMC3 M0CDUM_outside_DMCMK1 < 0.300 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_56 {
@ DMC3 space to (M0CDOP NOT INSIDE DMCMK1), Overlap is not allowed. >= 0.75um
 err1 = EXT DMC3 M0CDOP_outside_DMCMK1 < 0.750 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_57 {
@ DMC3 space to INST, Overlap is not allowed. >= 0.21um
 err1 = EXT DMC3 INST < 0.210 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_58 {
@ DMC3 space to DIR, DIRDMP, RESP1, Overlap is not allowed. >= 0.35um
 err1 = EXT DMC3 DIR < 0.350 ABUT<90 SINGULAR REGION INSIDE ALSO
 err2 = EXT DMC3 DIRDMP < 0.350 ABUT<90 SINGULAR REGION INSIDE ALSO
 err3 = EXT DMC3 RESP1 < 0.350 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
}

DUMC_59 {
@ DMC3 space to PLRES, RESP2, LDBK, DMPNP, DSTR, VARMOS, EFUSE, Overlap is not allowed. >= 0um
 err1 = DMC3 AND (OR PLRES RESP2 LDBK DMPNP DSTR VARMOS EFUSE)
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_60 {
@ DMC3 space to RSPMK1, Overlap is not allowed. >= 0.001um
 err1 = EXT DMC3 RSPMK1 < 0.001 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_61 {
@ DMC3 space to OCCDFH, Overlap is not allowed. >= 0.32um
 err1 = EXT DMC3 OCCDFH < 0.32 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

//DUMC_62 {
//@ DMC3 space to ESD1 >= 0.189um
// err1 = EXT DMC3 ESD1 < 0.189 ABUT<90 SINGULAR REGION MEASURE ALL
// err1 NOT INSIDE SealR_NOT_BULK
//}

DUMC_63 {
@ DMC3 space to DIOMK1, DIOMK2, Overlap is not allowed. >= 0.025um
 err1 = EXT DMC3 DIOMK1 < 0.025 ABUT<90 SINGULAR REGION INSIDE ALSO
 err2 = EXT DMC3 DIOMK2 < 0.025 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

DUMC_64 {
@ DMC3 space to V0, Overlap is not allowed. >= 0.04um
 err1 = EXT DMC3 V0 < 0.04 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_65_HVT_N {
@ DMC3 space to edge of HVT_N, HVT_P, SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, Cut is not allowed. >= 0.007um
 chk_area = (SIZE HVT_N BY 0.007) NOT (SIZE HVT_N BY -0.007)
 chk_area AND DMC3
}

DUMC_65_HVT_P {
@ DMC3 space to edge of HVT_N, HVT_P, SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, Cut is not allowed. >= 0.007um
 chk_area = (SIZE HVT_P BY 0.007) NOT (SIZE HVT_P BY -0.007)
 chk_area AND DMC3
}

DUMC_65_SVT_N {
@ DMC3 space to edge of HVT_N, HVT_P, SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, Cut is not allowed. >= 0.007um
 chk_area = (SIZE SVT_N BY 0.007) NOT (SIZE SVT_N BY -0.007)
 chk_area AND DMC3
}

DUMC_65_SVT_P {
@ DMC3 space to edge of HVT_N, HVT_P, SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, Cut is not allowed. >= 0.007um
 chk_area = (SIZE SVT_P BY 0.007) NOT (SIZE SVT_P BY -0.007)
 chk_area AND DMC3
}

DUMC_65_LVT_N {
@ DMC3 space to edge of HVT_N, HVT_P, SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, Cut is not allowed. >= 0.007um
 chk_area = (SIZE LVT_N BY 0.007) NOT (SIZE LVT_N BY -0.007)
 chk_area AND DMC3
}

DUMC_65_LVT_P {
@ DMC3 space to edge of HVT_N, HVT_P, SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, Cut is not allowed. >= 0.007um
 chk_area = (SIZE LVT_P BY 0.007) NOT (SIZE LVT_P BY -0.007)
 chk_area AND DMC3
}

DUMC_65_ULVT_N {
@ DMC3 space to edge of HVT_N, HVT_P, SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, Cut is not allowed. >= 0.007um
 chk_area = (SIZE ULVT_N BY 0.007) NOT (SIZE ULVT_N BY -0.007)
 chk_area AND DMC3
}

DUMC_65_ULVT_P {
@ DMC3 space to edge of HVT_N, HVT_P, SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, Cut is not allowed. >= 0.007um
 chk_area = (SIZE ULVT_P BY 0.007) NOT (SIZE ULVT_P BY -0.007)
 chk_area AND DMC3
}

DUMC_65_LFN_N {
@ DMC3 space to edge of HVT_N, HVT_P, SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, Cut is not allowed. >= 0.007um
 chk_area = (SIZE LFN_N BY 0.007) NOT (SIZE LFN_N BY -0.007)
 chk_area AND DMC3
}

DUMC_65_LFN_P {
@ DMC3 space to edge of HVT_N, HVT_P, SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, Cut is not allowed. >= 0.007um
 chk_area = (SIZE LFN_P BY 0.007) NOT (SIZE LFN_P BY -0.007)
 chk_area AND DMC3
}

DUMC_66 {
@ Inside edge of DG space to DMC3, Outside and cut is not allowed. >= 0.002um
 err1 = ENC DMC3 DG < 0.002 ABUT<90 SINGULAR REGION OUTSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_67_DGUD {
@ DMC3 space to edge of DGUD, DGV, Cut is not allowed. >= 0.002um
 chk_area = (SIZE DGUD BY 0.002) NOT (SIZE DGUD BY -0.002)
 chk_area AND DMC3
}

DUMC_67_DGV {
@ DMC3 space to edge of DGUD, DGV, Cut is not allowed. >= 0.002um
 chk_area = (SIZE DGV BY 0.002) NOT (SIZE DGV BY -0.002)
 chk_area AND DMC3
}

DUMC_68 {
@ DMC3 space to DMC2, Overlap is not allowed. >= 0.192um
 err1 = EXT DMC3 DMC2 < 0.192 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_69 {
@ DMC3 horizontal space to DMC2, Overlap is not allowed. >= 0.215um
 err1 = EXT (ANGLE DMC3 == 90) DMC2 < 0.215 ABUT<90 OPPOSITE REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

#IFDEF CHIPB_RULES_CHECK YES
DUMC_70 {
@ Inside edge of CHIPB space to DMC4, Outside and cut is not allowed. >= 0.45um
 err1 = ENC DMC4 CHIPB < 0.45 ABUT<90 SINGULAR REGION OUTSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
#ENDIF

DUMC_71_DUMBA {
@ DMC4 space to DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, AR_H, AR_V, (AR_HDOP NOT INSIDE DMCMK1), (AR_VDOP NOT INSIDE DMCMK1), (ARBL NOT INSIDE DMCMK1), Overlap is not allowed. >= 0.144um
 err1 = EXT DMC4 DUMBA < 0.144 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_71_DUMBP {
@ DMC4 space to DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, AR_H, AR_V, (AR_HDOP NOT INSIDE DMCMK1), (AR_VDOP NOT INSIDE DMCMK1), (ARBL NOT INSIDE DMCMK1), Overlap is not allowed. >= 0.144um
 err1 = EXT DMC4 DUMBP < 0.144 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_71_ARDUB {
@ DMC4 space to DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, AR_H, AR_V, (AR_HDOP NOT INSIDE DMCMK1), (AR_VDOP NOT INSIDE DMCMK1), (ARBL NOT INSIDE DMCMK1), Overlap is not allowed. >= 0.144um
 err1 = EXT DMC4 ARDUB < 0.144 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_71_P2DUB {
@ DMC4 space to DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, AR_H, AR_V, (AR_HDOP NOT INSIDE DMCMK1), (AR_VDOP NOT INSIDE DMCMK1), (ARBL NOT INSIDE DMCMK1), Overlap is not allowed. >= 0.144um
 err1 = EXT DMC4 P2DUB < 0.144 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_71_M0DUB {
@ DMC4 space to DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, AR_H, AR_V, (AR_HDOP NOT INSIDE DMCMK1), (AR_VDOP NOT INSIDE DMCMK1), (ARBL NOT INSIDE DMCMK1), Overlap is not allowed. >= 0.144um
 err1 = EXT DMC4 M0DUB < 0.144 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_71_M0CDUB {
@ DMC4 space to DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, AR_H, AR_V, (AR_HDOP NOT INSIDE DMCMK1), (AR_VDOP NOT INSIDE DMCMK1), (ARBL NOT INSIDE DMCMK1), Overlap is not allowed. >= 0.144um
 err1 = EXT DMC4 M0CDUB < 0.144 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_71_M0GDUB {
@ DMC4 space to DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, AR_H, AR_V, (AR_HDOP NOT INSIDE DMCMK1), (AR_VDOP NOT INSIDE DMCMK1), (ARBL NOT INSIDE DMCMK1), Overlap is not allowed. >= 0.144um
 err1 = EXT DMC4 M0GDUB < 0.144 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_71_AR_H {
@ DMC4 space to DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, AR_H, AR_V, (AR_HDOP NOT INSIDE DMCMK1), (AR_VDOP NOT INSIDE DMCMK1), (ARBL NOT INSIDE DMCMK1), Overlap is not allowed. >= 0.144um
 err1 = EXT DMC4 AR_H < 0.144 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_71_AR_V {
@ DMC4 space to DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, AR_H, AR_V, (AR_HDOP NOT INSIDE DMCMK1), (AR_VDOP NOT INSIDE DMCMK1), (ARBL NOT INSIDE DMCMK1), Overlap is not allowed. >= 0.144um
 err1 = EXT DMC4 AR_V < 0.144 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_71_AR_HDOP {
@ DMC4 space to DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, AR_H, AR_V, (AR_HDOP NOT INSIDE DMCMK1), (AR_VDOP NOT INSIDE DMCMK1), (ARBL NOT INSIDE DMCMK1), Overlap is not allowed. >= 0.144um
 err1 = EXT DMC4 AR_HDOP_outside_DMCMK1 < 0.144 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_71_AR_VDOP {
@ DMC4 space to DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, AR_H, AR_V, (AR_HDOP NOT INSIDE DMCMK1), (AR_VDOP NOT INSIDE DMCMK1), (ARBL NOT INSIDE DMCMK1), Overlap is not allowed. >= 0.144um
 err1 = EXT DMC4 AR_VDOP_outside_DMCMK1 < 0.144 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_71_ARBL {
@ DMC4 space to DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, AR_H, AR_V, (AR_HDOP NOT INSIDE DMCMK1), (AR_VDOP NOT INSIDE DMCMK1), (ARBL NOT INSIDE DMCMK1), Overlap is not allowed. >= 0.144um
 err1 = EXT DMC4 ARBL_outside_DMCMK1 < 0.144 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_72_NPAA_EXT {
@ DMC4 space to NPAA_EXT, RESNW, MARKG, MARKS, NODMF, Overlap is not allowed. >= 0.4um
 err1 = EXT DMC4 NPAA_EXT < 0.4 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_72_RESNW {
@ DMC4 space to NPAA_EXT, RESNW, MARKG, MARKS, NODMF, Overlap is not allowed. >= 0.4um
 err1 = EXT DMC4 RESNW < 0.4 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_72_MARKG {
@ DMC4 space to NPAA_EXT, RESNW, MARKG, MARKS, NODMF, Overlap is not allowed. >= 0.4um
 err1 = EXT DMC4 MARKG < 0.4 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_72_MARKS {
@ DMC4 space to NPAA_EXT, RESNW, MARKG, MARKS, NODMF, Overlap is not allowed. >= 0.4um
 err1 = EXT DMC4 MARKS < 0.4 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_72_NODMF {
@ DMC4 space to NPAA_EXT, RESNW, MARKG, MARKS, NODMF, Overlap is not allowed. >= 0.4um
 err1 = EXT DMC4 NODMF < 0.4 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_73_AA {
@ DMC4 space to AA, AADMP, PPAA, M0, M0DMP, (M0DOP NOT INSIDE DMCMK1), M0G, M0GDMP, (M0GDOP NOT INSIDE DMCMK1), INDMY, DG, DGUD, DGV, Overlap is not allowed. >= 0.2um
 err1 = EXT DMC4 AA < 0.2 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_73_AADMP {
@ DMC4 space to AA, AADMP, PPAA, M0, M0DMP, (M0DOP NOT INSIDE DMCMK1), M0G, M0GDMP, (M0GDOP NOT INSIDE DMCMK1), INDMY, DG, DGUD, DGV, Overlap is not allowed. >= 0.2um
 err1 = EXT DMC4 AADMP < 0.2 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_73_PPAA {
@ DMC4 space to AA, AADMP, PPAA, M0, M0DMP, (M0DOP NOT INSIDE DMCMK1), M0G, M0GDMP, (M0GDOP NOT INSIDE DMCMK1), INDMY, DG, DGUD, DGV, Overlap is not allowed. >= 0.2um
 err1 = EXT DMC4 PPAA < 0.2 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_73_M0 {
@ DMC4 space to AA, AADMP, PPAA, M0, M0DMP, (M0DOP NOT INSIDE DMCMK1), M0G, M0GDMP, (M0GDOP NOT INSIDE DMCMK1), INDMY, DG, DGUD, DGV, Overlap is not allowed. >= 0.2um
 err1 = EXT DMC4 M0 < 0.2 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_73_M0DMP {
@ DMC4 space to AA, AADMP, PPAA, M0, M0DMP, (M0DOP NOT INSIDE DMCMK1), M0G, M0GDMP, (M0GDOP NOT INSIDE DMCMK1), INDMY, DG, DGUD, DGV, Overlap is not allowed. >= 0.2um
 err1 = EXT DMC4 M0DMP < 0.2 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_73_M0DOP {
@ DMC4 space to AA, AADMP, PPAA, M0, M0DMP, (M0DOP NOT INSIDE DMCMK1), M0G, M0GDMP, (M0GDOP NOT INSIDE DMCMK1), INDMY, DG, DGUD, DGV, Overlap is not allowed. >= 0.2um
 err1 = EXT DMC4 M0DOP_outside_DMCMK1 < 0.2 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_73_M0G {
@ DMC4 space to AA, AADMP, PPAA, M0, M0DMP, (M0DOP NOT INSIDE DMCMK1), M0G, M0GDMP, (M0GDOP NOT INSIDE DMCMK1), INDMY, DG, DGUD, DGV, Overlap is not allowed. >= 0.2um
 err1 = EXT DMC4 M0G < 0.2 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_73_M0GDMP {
@ DMC4 space to AA, AADMP, PPAA, M0, M0DMP, (M0DOP NOT INSIDE DMCMK1), M0G, M0GDMP, (M0GDOP NOT INSIDE DMCMK1), INDMY, DG, DGUD, DGV, Overlap is not allowed. >= 0.2um
 err1 = EXT DMC4 M0GDMP < 0.2 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_73_M0GDOP {
@ DMC4 space to AA, AADMP, PPAA, M0, M0DMP, (M0DOP NOT INSIDE DMCMK1), M0G, M0GDMP, (M0GDOP NOT INSIDE DMCMK1), INDMY, DG, DGUD, DGV, Overlap is not allowed. >= 0.2um
 err1 = EXT DMC4 M0GDOP_outside_DMCMK1 < 0.2 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_73_INDMY {
@ DMC4 space to AA, AADMP, PPAA, M0, M0DMP, (M0DOP NOT INSIDE DMCMK1), M0G, M0GDMP, (M0GDOP NOT INSIDE DMCMK1), INDMY, DG, DGUD, DGV, Overlap is not allowed. >= 0.2um
 err1 = EXT DMC4 INDMY < 0.2 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

//DUMC_73_OCOVL_NOT_OCOVLM4 {
//@ DMC4 space to AA, AADMP, PPAA, M0, M0DMP, (M0DOP NOT INSIDE DMCMK1), M0G, M0GDMP, (M0GDOP NOT INSIDE DMCMK1), INDMY, DG, DGUD, DGV, Overlap is not allowed. >= 0.2um
// err1 = EXT DMC4 OCOVL_NOT_OCOVLM4 < 0.2 ABUT<90 SINGULAR REGION MEASURE ALL
// err1 NOT INSIDE SealR_NOT_BULK
//}

DUMC_73_DG {
@ DMC4 space to AA, AADMP, PPAA, M0, M0DMP, (M0DOP NOT INSIDE DMCMK1), M0G, M0GDMP, (M0GDOP NOT INSIDE DMCMK1), INDMY, DG, DGUD, DGV, Overlap is not allowed. >= 0.2um
 err1 = EXT DMC4 DG < 0.2 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_73_DGUD {
@ DMC4 space to AA, AADMP, PPAA, M0, M0DMP, (M0DOP NOT INSIDE DMCMK1), M0G, M0GDMP, (M0GDOP NOT INSIDE DMCMK1), INDMY, DG, DGUD, DGV, Overlap is not allowed. >= 0.2um
 err1 = EXT DMC4 DGUD < 0.2 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_73_DGV {
@ DMC4 space to AA, AADMP, PPAA, M0, M0DMP, (M0DOP NOT INSIDE DMCMK1), M0G, M0GDMP, (M0GDOP NOT INSIDE DMCMK1), INDMY, DG, DGUD, DGV, Overlap is not allowed. >= 0.2um
 err1 = EXT DMC4 DGV < 0.2 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_74_AADUM {
@ DMC4 space to (AADUM NOT INSIDE DMCMK1), (AADOP NOT INSIDE DMCMK1), (P2DUM NOT INSIDE DMCMK1), (M0DUM NOT INSIDE DMCMK1), M0C, M0CDMP, (M0GDUM NOT INSIDE DMCMK1), DMC1, Overlap is not allowed. >= 0.27um
 err1 = EXT DMC4 AADUM_outside_DMCMK1 < 0.27 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_74_AADOP {
@ DMC4 space to (AADUM NOT INSIDE DMCMK1), (AADOP NOT INSIDE DMCMK1), (P2DUM NOT INSIDE DMCMK1), (M0DUM NOT INSIDE DMCMK1), M0C, M0CDMP, (M0GDUM NOT INSIDE DMCMK1), DMC1, Overlap is not allowed. >= 0.27um
 err1 = EXT DMC4 AADOP_outside_DMCMK1 < 0.27 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_74_P2DUM {
@ DMC4 space to (AADUM NOT INSIDE DMCMK1), (AADOP NOT INSIDE DMCMK1), (P2DUM NOT INSIDE DMCMK1), (M0DUM NOT INSIDE DMCMK1), M0C, M0CDMP, (M0GDUM NOT INSIDE DMCMK1), DMC1, Overlap is not allowed. >= 0.27um
 err1 = EXT DMC4 P2DUM_outside_DMCMK1 < 0.27 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_74_M0DUM {
@ DMC4 space to (AADUM NOT INSIDE DMCMK1), (AADOP NOT INSIDE DMCMK1), (P2DUM NOT INSIDE DMCMK1), (M0DUM NOT INSIDE DMCMK1), M0C, M0CDMP, (M0GDUM NOT INSIDE DMCMK1), DMC1, Overlap is not allowed. >= 0.27um
 err1 = EXT DMC4 M0DUM_outside_DMCMK1 < 0.27 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_74_M0C {
@ DMC4 space to (AADUM NOT INSIDE DMCMK1), (AADOP NOT INSIDE DMCMK1), (P2DUM NOT INSIDE DMCMK1), (M0DUM NOT INSIDE DMCMK1), M0C, M0CDMP, (M0GDUM NOT INSIDE DMCMK1), DMC1, Overlap is not allowed. >= 0.27um
 err1 = EXT DMC4 M0C < 0.27 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_74_M0CDMP {
@ DMC4 space to (AADUM NOT INSIDE DMCMK1), (AADOP NOT INSIDE DMCMK1), (P2DUM NOT INSIDE DMCMK1), (M0DUM NOT INSIDE DMCMK1), M0C, M0CDMP, (M0GDUM NOT INSIDE DMCMK1), DMC1, Overlap is not allowed. >= 0.27um
 err1 = EXT DMC4 M0CDMP < 0.27 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_74_M0GDUM {
@ DMC4 space to (AADUM NOT INSIDE DMCMK1), (AADOP NOT INSIDE DMCMK1), (P2DUM NOT INSIDE DMCMK1), (M0DUM NOT INSIDE DMCMK1), M0C, M0CDMP, (M0GDUM NOT INSIDE DMCMK1), DMC1, Overlap is not allowed. >= 0.27um
 err1 = EXT DMC4 M0GDUM_outside_DMCMK1 < 0.27 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_74_DMC1 {
@ DMC4 space to (AADUM NOT INSIDE DMCMK1), (AADOP NOT INSIDE DMCMK1), (P2DUM NOT INSIDE DMCMK1), (M0DUM NOT INSIDE DMCMK1), M0C, M0CDMP, (M0GDUM NOT INSIDE DMCMK1), DMC1, Overlap is not allowed. >= 0.27um
 err1 = EXT DMC4 DMC1 < 0.27 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_75 {
@ DMC4 space to AR, Overlap is not allowed. >= 0.16um
 err1 = EXT DMC4 AR < 0.16 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_76 {
@ DMC4 space to (ARDUM NOT INSIDE DMCMK1), (ARDOP NOT INSIDE DMCMK1), Overlap is not allowed. >= 0.182um
 err1 = EXT DMC4 ARDUM_outside_DMCMK1 < 0.182 ABUT<90 SINGULAR REGION INSIDE ALSO
 err2 = EXT DMC4 ARDOP_outside_DMCMK1 < 0.182 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

DUMC_77 {
@ DMC4 space to GT, GTDMP, (GTDUM NOT INSIDE DMCMK1), (GTDOP NOT INSIDE DMCMK1), Overlap is not allowed. >= 0.274um
 err1 = EXT DMC4 DMP_GT < 0.274 ABUT<90 SINGULAR REGION INSIDE ALSO
 err2 = EXT DMC4 GTDUM_outside_DMCMK1 < 0.274 ABUT<90 SINGULAR REGION INSIDE ALSO
 err3 = EXT DMC4 GTDOP_outside_DMCMK1 < 0.274 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
}

DUMC_78_GT_P96 {
@ DMC4 space to edge of GT_P96, PSUB, NW, DNW, SN, SP, (SNDUM NOT INSIDE DMCMK1), (SPDUM NOT INSIDE DMCMK1), HVT_N, HVT_P, SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, Cut is not allowed. >= 0.001um
 chk_area = (SIZE GT_P96 BY 0.001) NOT (SIZE GT_P96 BY -0.001)
 chk_area AND DMC4
}

DUMC_78_PSUB {
@ DMC4 space to edge of GT_P96, PSUB, NW, DNW, SN, SP, (SNDUM NOT INSIDE DMCMK1), (SPDUM NOT INSIDE DMCMK1), HVT_N, HVT_P, SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, Cut is not allowed. >= 0.001um
 chk_area = (SIZE PSUB BY 0.001) NOT (SIZE PSUB BY -0.001)
 chk_area AND DMC4
}

DUMC_78_NW {
@ DMC4 space to edge of GT_P96, PSUB, NW, DNW, SN, SP, (SNDUM NOT INSIDE DMCMK1), (SPDUM NOT INSIDE DMCMK1), HVT_N, HVT_P, SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, Cut is not allowed. >= 0.001um
 chk_area = (SIZE NW BY 0.001) NOT (SIZE NW BY -0.001)
 chk_area AND DMC4
}

DUMC_78_DNW {
@ DMC4 space to edge of GT_P96, PSUB, NW, DNW, SN, SP, (SNDUM NOT INSIDE DMCMK1), (SPDUM NOT INSIDE DMCMK1), HVT_N, HVT_P, SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, Cut is not allowed. >= 0.001um
 chk_area = (SIZE DNW BY 0.001) NOT (SIZE DNW BY -0.001)
 chk_area AND DMC4
}

DUMC_78_SN {
@ DMC4 space to edge of GT_P96, PSUB, NW, DNW, SN, SP, (SNDUM NOT INSIDE DMCMK1), (SPDUM NOT INSIDE DMCMK1), HVT_N, HVT_P, SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, Cut is not allowed. >= 0.001um
 chk_area = (SIZE SN BY 0.001) NOT (SIZE SN BY -0.001)
 chk_area AND DMC4
}

DUMC_78_SP {
@ DMC4 space to edge of GT_P96, PSUB, NW, DNW, SN, SP, (SNDUM NOT INSIDE DMCMK1), (SPDUM NOT INSIDE DMCMK1), HVT_N, HVT_P, SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, Cut is not allowed. >= 0.001um
 chk_area = (SIZE SP BY 0.001) NOT (SIZE SP BY -0.001)
 chk_area AND DMC4
}

DUMC_78_SNDUM {
@ DMC4 space to edge of GT_P96, PSUB, NW, DNW, SN, SP, (SNDUM NOT INSIDE DMCMK1), (SPDUM NOT INSIDE DMCMK1), HVT_N, HVT_P, SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, Cut is not allowed. >= 0.001um
 chk_area = (SIZE SNDUM_outside_DMCMK1 BY 0.001) NOT (SIZE SNDUM_outside_DMCMK1 BY -0.001)
 chk_area AND DMC4
}

DUMC_78_SPDUM {
@ DMC4 space to edge of GT_P96, PSUB, NW, DNW, SN, SP, (SNDUM NOT INSIDE DMCMK1), (SPDUM NOT INSIDE DMCMK1), HVT_N, HVT_P, SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, Cut is not allowed. >= 0.001um
 chk_area = (SIZE SPDUM_outside_DMCMK1 BY 0.001) NOT (SIZE SPDUM_outside_DMCMK1 BY -0.001)
 chk_area AND DMC4
}

DUMC_78_HVT_N {
@ DMC4 space to edge of GT_P96, PSUB, NW, DNW, SN, SP, (SNDUM NOT INSIDE DMCMK1), (SPDUM NOT INSIDE DMCMK1), HVT_N, HVT_P, SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, Cut is not allowed. >= 0.001um
 chk_area = (SIZE HVT_N BY 0.001) NOT (SIZE HVT_N BY -0.001)
 chk_area AND DMC4
}

DUMC_78_HVT_P {
@ DMC4 space to edge of GT_P96, PSUB, NW, DNW, SN, SP, (SNDUM NOT INSIDE DMCMK1), (SPDUM NOT INSIDE DMCMK1), HVT_N, HVT_P, SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, Cut is not allowed. >= 0.001um
 chk_area = (SIZE HVT_P BY 0.001) NOT (SIZE HVT_P BY -0.001)
 chk_area AND DMC4
}

DUMC_78_SVT_N {
@ DMC4 space to edge of GT_P96, PSUB, NW, DNW, SN, SP, (SNDUM NOT INSIDE DMCMK1), (SPDUM NOT INSIDE DMCMK1), HVT_N, HVT_P, SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, Cut is not allowed. >= 0.001um
 chk_area = (SIZE SVT_N BY 0.001) NOT (SIZE SVT_N BY -0.001)
 chk_area AND DMC4
}

DUMC_78_SVT_P {
@ DMC4 space to edge of GT_P96, PSUB, NW, DNW, SN, SP, (SNDUM NOT INSIDE DMCMK1), (SPDUM NOT INSIDE DMCMK1), HVT_N, HVT_P, SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, Cut is not allowed. >= 0.001um
 chk_area = (SIZE SVT_P BY 0.001) NOT (SIZE SVT_P BY -0.001)
 chk_area AND DMC4
}

DUMC_78_LVT_N {
@ DMC4 space to edge of GT_P96, PSUB, NW, DNW, SN, SP, (SNDUM NOT INSIDE DMCMK1), (SPDUM NOT INSIDE DMCMK1), HVT_N, HVT_P, SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, Cut is not allowed. >= 0.001um
 chk_area = (SIZE LVT_N BY 0.001) NOT (SIZE LVT_N BY -0.001)
 chk_area AND DMC4
}

DUMC_78_LVT_P {
@ DMC4 space to edge of GT_P96, PSUB, NW, DNW, SN, SP, (SNDUM NOT INSIDE DMCMK1), (SPDUM NOT INSIDE DMCMK1), HVT_N, HVT_P, SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, Cut is not allowed. >= 0.001um
 chk_area = (SIZE LVT_P BY 0.001) NOT (SIZE LVT_P BY -0.001)
 chk_area AND DMC4
}

DUMC_78_ULVT_N {
@ DMC4 space to edge of GT_P96, PSUB, NW, DNW, SN, SP, (SNDUM NOT INSIDE DMCMK1), (SPDUM NOT INSIDE DMCMK1), HVT_N, HVT_P, SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, Cut is not allowed. >= 0.001um
 chk_area = (SIZE ULVT_N BY 0.001) NOT (SIZE ULVT_N BY -0.001)
 chk_area AND DMC4
}

DUMC_78_ULVT_P {
@ DMC4 space to edge of GT_P96, PSUB, NW, DNW, SN, SP, (SNDUM NOT INSIDE DMCMK1), (SPDUM NOT INSIDE DMCMK1), HVT_N, HVT_P, SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, Cut is not allowed. >= 0.001um
 chk_area = (SIZE ULVT_P BY 0.001) NOT (SIZE ULVT_P BY -0.001)
 chk_area AND DMC4
}

DUMC_78_LFN_N {
@ DMC4 space to edge of GT_P96, PSUB, NW, DNW, SN, SP, (SNDUM NOT INSIDE DMCMK1), (SPDUM NOT INSIDE DMCMK1), HVT_N, HVT_P, SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, Cut is not allowed. >= 0.001um
 chk_area = (SIZE LFN_N BY 0.001) NOT (SIZE LFN_N BY -0.001)
 chk_area AND DMC4
}

DUMC_78_LFN_P {
@ DMC4 space to edge of GT_P96, PSUB, NW, DNW, SN, SP, (SNDUM NOT INSIDE DMCMK1), (SPDUM NOT INSIDE DMCMK1), HVT_N, HVT_P, SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, Cut is not allowed. >= 0.001um
 chk_area = (SIZE LFN_P BY 0.001) NOT (SIZE LFN_P BY -0.001)
 chk_area AND DMC4
}

DUMC_79 {
@ DMC4 space to P2, P2DMP, (P2DOP NOT INSIDE DMCMK1), Overlap is not allowed. >= 0.18um
 err1 = EXT DMC4 P2 < 0.18 ABUT<90 SINGULAR REGION INSIDE ALSO
 err2 = EXT DMC4 P2DMP < 0.18 ABUT<90 SINGULAR REGION INSIDE ALSO
 err3 = EXT DMC4 P2DOP_outside_DMCMK1 < 0.18 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
}

DUMC_80 {
@ DMC4 space to (M0CDUM NOT INSIDE DMCMK1), Overlap is not allowed. >= 0.3um
 err1 = EXT DMC4 M0CDUM_outside_DMCMK1 < 0.30 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_81 {
@ DMC4 space to (M0CDOP NOT INSIDE DMCMK1), Overlap is not allowed. >= 0.75um
 err1 = EXT DMC4 M0CDOP_outside_DMCMK1 < 0.75 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_82 {
@ DMC4 space to INST, Overlap is not allowed. >= 0.21um
 err1 = EXT DMC4 INST < 0.21 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_83 {
@ DMC4 space to DIR, DIRDMP, RESP1, Overlap is not allowed. >= 0.35um
 err1 = EXT DMC4 DIR < 0.35 ABUT<90 SINGULAR REGION INSIDE ALSO
 err2 = EXT DMC4 DIRDMP < 0.35 ABUT<90 SINGULAR REGION INSIDE ALSO
 err3 = EXT DMC4 RESP1 < 0.35 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
}

DUMC_84 {
@ DMC4 space to PLRES, RESP2, LDBK, DMPNP, DSTR, VARMOS, EFUSE, Overlap is not allowed. >= 0um
 err1 = DMC4 AND (OR PLRES RESP2 LDBK DMPNP DSTR VARMOS EFUSE)
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_85 {
@ DMC4 space to OCCDFH, Overlap is not allowed. >= 0.32um
 err1 = EXT DMC4 OCCDFH < 0.32 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

//DUMC_86 {
//@ DMC4 space to ESD1 >= 0.189um
// err1 = EXT DMC4 ESD1 < 0.189 ABUT<90 SINGULAR REGION MEASURE ALL
// err1 NOT INSIDE SealR_NOT_BULK
//}

DUMC_87 {
@ DMC4 space to DIOMK1, DIOMK2, Overlap is not allowed. >= 0.025um
 err1 = EXT DMC4 DIOMK1 < 0.025 ABUT<90 SINGULAR REGION INSIDE ALSO
 err2 = EXT DMC4 DIOMK2 < 0.025 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

DUMC_88 {
@ DMC4 space to V0, Overlap is not allowed. >= 0.04um
 err1 = EXT DMC4 V0 < 0.04 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_89 {
@ DMC4 space to DMC2, Overlap is not allowed. >= 0.142um
 err1 = EXT DMC4 DMC2 < 0.142 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_90 {
@ DMC4 vertical space to DMC2, Overlap is not allowed. >= 0.192um
 err1 = EXT DMC4 (ANGLE DMC2 == 0) < 0.192 ABUT<90 OPPOSITE REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_91 {
@ DMC4 space to DMC3, Overlap is not allowed. >= 0.192um
 err1 = EXT DMC4 DMC3 < 0.192 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_92 {
@ DMC4 horizontal space to DMC3, Overlap is not allowed. >= 0.2um
 err1 = EXT DMC4 (ANGLE DMC3 == 90) < 0.2 ABUT<90 OPPOSITE REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

#IFDEF CHIPB_RULES_CHECK YES
DUMC_93 {
@ Inside edge of CHIPB space to DMC5, Outside and cut is not allowed. >= 0.45um
 err1 = ENC DMC5 CHIPB < 0.45 ABUT<90 SINGULAR REGION OUTSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
#ENDIF

DUMC_94_DUMBA {
@ DMC5 space to DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, AR_H, AR_V, (AR_HDOP NOT INSIDE DMCMK1), (AR_VDOP NOT INSIDE DMCMK1), (ARBL NOT INSIDE DMCMK1), Overlap is not allowed. >= 0.144um
 err1 = EXT DMC5 DUMBA < 0.144 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_94_DUMBP {
@ DMC5 space to DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, AR_H, AR_V, (AR_HDOP NOT INSIDE DMCMK1), (AR_VDOP NOT INSIDE DMCMK1), (ARBL NOT INSIDE DMCMK1), Overlap is not allowed. >= 0.144um
 err1 = EXT DMC5 DUMBP < 0.144 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_94_ARDUB {
@ DMC5 space to DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, AR_H, AR_V, (AR_HDOP NOT INSIDE DMCMK1), (AR_VDOP NOT INSIDE DMCMK1), (ARBL NOT INSIDE DMCMK1), Overlap is not allowed. >= 0.144um
 err1 = EXT DMC5 ARDUB < 0.144 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_94_P2DUB {
@ DMC5 space to DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, AR_H, AR_V, (AR_HDOP NOT INSIDE DMCMK1), (AR_VDOP NOT INSIDE DMCMK1), (ARBL NOT INSIDE DMCMK1), Overlap is not allowed. >= 0.144um
 err1 = EXT DMC5 P2DUB < 0.144 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_94_M0DUB {
@ DMC5 space to DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, AR_H, AR_V, (AR_HDOP NOT INSIDE DMCMK1), (AR_VDOP NOT INSIDE DMCMK1), (ARBL NOT INSIDE DMCMK1), Overlap is not allowed. >= 0.144um
 err1 = EXT DMC5 M0DUB < 0.144 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_94_M0CDUB {
@ DMC5 space to DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, AR_H, AR_V, (AR_HDOP NOT INSIDE DMCMK1), (AR_VDOP NOT INSIDE DMCMK1), (ARBL NOT INSIDE DMCMK1), Overlap is not allowed. >= 0.144um
 err1 = EXT DMC5 M0CDUB < 0.144 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_94_M0GDUB {
@ DMC5 space to DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, AR_H, AR_V, (AR_HDOP NOT INSIDE DMCMK1), (AR_VDOP NOT INSIDE DMCMK1), (ARBL NOT INSIDE DMCMK1), Overlap is not allowed. >= 0.144um
 err1 = EXT DMC5 M0GDUB < 0.144 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_94_AR_H {
@ DMC5 space to DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, AR_H, AR_V, (AR_HDOP NOT INSIDE DMCMK1), (AR_VDOP NOT INSIDE DMCMK1), (ARBL NOT INSIDE DMCMK1), Overlap is not allowed. >= 0.144um
 err1 = EXT DMC5 AR_H < 0.144 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_94_AR_V {
@ DMC5 space to DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, AR_H, AR_V, (AR_HDOP NOT INSIDE DMCMK1), (AR_VDOP NOT INSIDE DMCMK1), (ARBL NOT INSIDE DMCMK1), Overlap is not allowed. >= 0.144um
 err1 = EXT DMC5 AR_V < 0.144 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_94_AR_HDOP {
@ DMC5 space to DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, AR_H, AR_V, (AR_HDOP NOT INSIDE DMCMK1), (AR_VDOP NOT INSIDE DMCMK1), (ARBL NOT INSIDE DMCMK1), Overlap is not allowed. >= 0.144um
 err1 = EXT DMC5 AR_HDOP_outside_DMCMK1 < 0.144 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_94_AR_VDOP {
@ DMC5 space to DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, AR_H, AR_V, (AR_HDOP NOT INSIDE DMCMK1), (AR_VDOP NOT INSIDE DMCMK1), (ARBL NOT INSIDE DMCMK1), Overlap is not allowed. >= 0.144um
 err1 = EXT DMC5 AR_VDOP_outside_DMCMK1 < 0.144 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_94_ARBL {
@ DMC5 space to DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, AR_H, AR_V, (AR_HDOP NOT INSIDE DMCMK1), (AR_VDOP NOT INSIDE DMCMK1), (ARBL NOT INSIDE DMCMK1), Overlap is not allowed. >= 0.144um
 err1 = EXT DMC5 ARBL_outside_DMCMK1 < 0.144 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_95_NPAA_EXT {
@ DMC5 space to NPAA_EXT, RESNW, MARKG, MARKS, NODMF, Overlap is not allowed. >= 0.4um
 err1 = EXT DMC5 NPAA_EXT < 0.4 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_95_RESNW {
@ DMC5 space to NPAA_EXT, RESNW, MARKG, MARKS, NODMF, Overlap is not allowed. >= 0.4um
 err1 = EXT DMC5 RESNW < 0.4 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_95_MARKG {
@ DMC5 space to NPAA_EXT, RESNW, MARKG, MARKS, NODMF, Overlap is not allowed. >= 0.4um
 err1 = EXT DMC5 MARKG < 0.4 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_95_MARKS {
@ DMC5 space to NPAA_EXT, RESNW, MARKG, MARKS, NODMF, Overlap is not allowed. >= 0.4um
 err1 = EXT DMC5 MARKS < 0.4 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_95_NODMF {
@ DMC5 space to NPAA_EXT, RESNW, MARKG, MARKS, NODMF, Overlap is not allowed. >= 0.4um
 err1 = EXT DMC5 NODMF < 0.4 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_96_AA {
@ DMC5 space to AA, AADMP, PPAA, M0, M0DMP, (M0DOP NOT INSIDE DMCMK1), M0G, M0GDMP, (M0GDOP NOT INSIDE DMCMK1), INDMY, Overlap is not allowed. >= 0.2um
 err1 = EXT DMC5 AA < 0.2 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_96_AADMP {
@ DMC5 space to AA, AADMP, PPAA, M0, M0DMP, (M0DOP NOT INSIDE DMCMK1), M0G, M0GDMP, (M0GDOP NOT INSIDE DMCMK1), INDMY, Overlap is not allowed. >= 0.2um
 err1 = EXT DMC5 AADMP < 0.2 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_96_PPAA {
@ DMC5 space to AA, AADMP, PPAA, M0, M0DMP, (M0DOP NOT INSIDE DMCMK1), M0G, M0GDMP, (M0GDOP NOT INSIDE DMCMK1), INDMY, Overlap is not allowed. >= 0.2um
 err1 = EXT DMC5 PPAA < 0.2 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_96_M0 {
@ DMC5 space to AA, AADMP, PPAA, M0, M0DMP, (M0DOP NOT INSIDE DMCMK1), M0G, M0GDMP, (M0GDOP NOT INSIDE DMCMK1), INDMY, Overlap is not allowed. >= 0.2um
 err1 = EXT DMC5 M0 < 0.2 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_96_M0DMP {
@ DMC5 space to AA, AADMP, PPAA, M0, M0DMP, (M0DOP NOT INSIDE DMCMK1), M0G, M0GDMP, (M0GDOP NOT INSIDE DMCMK1), INDMY, Overlap is not allowed. >= 0.2um
 err1 = EXT DMC5 M0DMP < 0.2 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_96_M0DOP {
@ DMC5 space to AA, AADMP, PPAA, M0, M0DMP, (M0DOP NOT INSIDE DMCMK1), M0G, M0GDMP, (M0GDOP NOT INSIDE DMCMK1), INDMY, Overlap is not allowed. >= 0.2um
 err1 = EXT DMC5 M0DOP_outside_DMCMK1 < 0.2 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_96_M0G {
@ DMC5 space to AA, AADMP, PPAA, M0, M0DMP, (M0DOP NOT INSIDE DMCMK1), M0G, M0GDMP, (M0GDOP NOT INSIDE DMCMK1), INDMY, Overlap is not allowed. >= 0.2um
 err1 = EXT DMC5 M0G < 0.2 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_96_M0GDMP {
@ DMC5 space to AA, AADMP, PPAA, M0, M0DMP, (M0DOP NOT INSIDE DMCMK1), M0G, M0GDMP, (M0GDOP NOT INSIDE DMCMK1), INDMY, Overlap is not allowed. >= 0.2um
 err1 = EXT DMC5 M0GDMP < 0.2 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_96_M0GDOP {
@ DMC5 space to AA, AADMP, PPAA, M0, M0DMP, (M0DOP NOT INSIDE DMCMK1), M0G, M0GDMP, (M0GDOP NOT INSIDE DMCMK1), INDMY, Overlap is not allowed. >= 0.2um
 err1 = EXT DMC5 M0GDOP_outside_DMCMK1 < 0.2 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_96_INDMY {
@ DMC5 space to AA, AADMP, PPAA, M0, M0DMP, (M0DOP NOT INSIDE DMCMK1), M0G, M0GDMP, (M0GDOP NOT INSIDE DMCMK1), INDMY, Overlap is not allowed. >= 0.2um
 err1 = EXT DMC5 INDMY < 0.2 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

//DUMC_96_OCOVL_NOT_OCOVLM4 {
//@ DMC5 space to AA, AADMP, PPAA, M0, M0DMP, (M0DOP NOT INSIDE DMCMK1), M0G, M0GDMP, (M0GDOP NOT INSIDE DMCMK1), INDMY, OCOVL_NOT_OCOVLM4 >= 0.2um
// err1 = EXT DMC5 OCOVL_NOT_OCOVLM4 < 0.2 ABUT<90 SINGULAR REGION MEASURE ALL
// err1 NOT INSIDE SealR_NOT_BULK
//}

DUMC_97_AADUM {
@ DMC5 space to (AADUM NOT INSIDE DMCMK1), (AADOP NOT INSIDE DMCMK1), (P2DUM NOT INSIDE DMCMK1), (M0DUM NOT INSIDE DMCMK1), M0C, M0CDMP, (M0GDUM NOT INSIDE DMCMK1), DMC1, Overlap is not allowed. >= 0.27um
 err1 = EXT DMC5 AADUM_outside_DMCMK1 < 0.27 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_97_AADOP {
@ DMC5 space to (AADUM NOT INSIDE DMCMK1), (AADOP NOT INSIDE DMCMK1), (P2DUM NOT INSIDE DMCMK1), (M0DUM NOT INSIDE DMCMK1), M0C, M0CDMP, (M0GDUM NOT INSIDE DMCMK1), DMC1, Overlap is not allowed. >= 0.27um
 err1 = EXT DMC5 AADOP_outside_DMCMK1 < 0.27 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_97_P2DUM {
@ DMC5 space to (AADUM NOT INSIDE DMCMK1), (AADOP NOT INSIDE DMCMK1), (P2DUM NOT INSIDE DMCMK1), (M0DUM NOT INSIDE DMCMK1), M0C, M0CDMP, (M0GDUM NOT INSIDE DMCMK1), DMC1, Overlap is not allowed. >= 0.27um
 err1 = EXT DMC5 P2DUM_outside_DMCMK1 < 0.27 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_97_M0DUM {
@ DMC5 space to (AADUM NOT INSIDE DMCMK1), (AADOP NOT INSIDE DMCMK1), (P2DUM NOT INSIDE DMCMK1), (M0DUM NOT INSIDE DMCMK1), M0C, M0CDMP, (M0GDUM NOT INSIDE DMCMK1), DMC1, Overlap is not allowed. >= 0.27um
 err1 = EXT DMC5 M0DUM_outside_DMCMK1 < 0.27 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_97_M0C {
@ DMC5 space to (AADUM NOT INSIDE DMCMK1), (AADOP NOT INSIDE DMCMK1), (P2DUM NOT INSIDE DMCMK1), (M0DUM NOT INSIDE DMCMK1), M0C, M0CDMP, (M0GDUM NOT INSIDE DMCMK1), DMC1, Overlap is not allowed. >= 0.27um
 err1 = EXT DMC5 M0C < 0.27 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_97_M0CDMP {
@ DMC5 space to (AADUM NOT INSIDE DMCMK1), (AADOP NOT INSIDE DMCMK1), (P2DUM NOT INSIDE DMCMK1), (M0DUM NOT INSIDE DMCMK1), M0C, M0CDMP, (M0GDUM NOT INSIDE DMCMK1), DMC1, Overlap is not allowed. >= 0.27um
 err1 = EXT DMC5 M0CDMP < 0.27 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_97_M0GDUM {
@ DMC5 space to (AADUM NOT INSIDE DMCMK1), (AADOP NOT INSIDE DMCMK1), (P2DUM NOT INSIDE DMCMK1), (M0DUM NOT INSIDE DMCMK1), M0C, M0CDMP, (M0GDUM NOT INSIDE DMCMK1), DMC1, Overlap is not allowed. >= 0.27um
 err1 = EXT DMC5 M0GDUM_outside_DMCMK1 < 0.27 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_97_DMC1 {
@ DMC5 space to (AADUM NOT INSIDE DMCMK1), (AADOP NOT INSIDE DMCMK1), (P2DUM NOT INSIDE DMCMK1), (M0DUM NOT INSIDE DMCMK1), M0C, M0CDMP, (M0GDUM NOT INSIDE DMCMK1), DMC1, Overlap is not allowed. >= 0.27um
 err1 = EXT DMC5 DMC1 < 0.27 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_98 {
@ DMC5 space to AR, Overlap is not allowed. >= 0.16um
 err1 = EXT DMC5 AR < 0.16 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_99 {
@ DMC5 space to (ARDUM NOT INSIDE DMCMK1), (ARDOP NOT INSIDE DMCMK1), Overlap is not allowed. >= 0.182um
 err1 = EXT DMC5 ARDUM_outside_DMCMK1 < 0.182 ABUT<90 SINGULAR REGION INSIDE ALSO
 err2 = EXT DMC5 ARDOP_outside_DMCMK1 < 0.182 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

DUMC_100 {
@ DMC5 space to GT, GTDMP, (GTDUM NOT INSIDE DMCMK1), (GTDOP NOT INSIDE DMCMK1), Overlap is not allowed. >= 0.274um
 err1 = EXT DMC5 DMP_GT < 0.274 ABUT<90 SINGULAR REGION INSIDE ALSO
 err2 = EXT DMC5 GTDUM_outside_DMCMK1 < 0.274 ABUT<90 SINGULAR REGION INSIDE ALSO
 err3 = EXT DMC5 GTDOP_outside_DMCMK1 < 0.274 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
}

DUMC_101_GT_P96 {
@ DMC5 space to edge of GT_P96, PSUB, NW, DNW, SN, SP, (SNDUM NOT INSIDE DMCMK1), (SPDUM NOT INSIDE DMCMK1), Cut is not allowed. >= 0.001um
 chk_area = (SIZE GT_P96 BY 0.001) NOT (SIZE GT_P96 BY -0.001)
 chk_area AND DMC5
}

DUMC_101_PSUB {
@ DMC5 space to edge of GT_P96, PSUB, NW, DNW, SN, SP, (SNDUM NOT INSIDE DMCMK1), (SPDUM NOT INSIDE DMCMK1), Cut is not allowed. >= 0.001um
 chk_area = (SIZE PSUB BY 0.001) NOT (SIZE PSUB BY -0.001)
 chk_area AND DMC5
}

DUMC_101_NW {
@ DMC5 space to edge of GT_P96, PSUB, NW, DNW, SN, SP, (SNDUM NOT INSIDE DMCMK1), (SPDUM NOT INSIDE DMCMK1), Cut is not allowed. >= 0.001um
 chk_area = (SIZE NW BY 0.001) NOT (SIZE NW BY -0.001)
 chk_area AND DMC5
}

DUMC_101_DNW {
@ DMC5 space to edge of GT_P96, PSUB, NW, DNW, SN, SP, (SNDUM NOT INSIDE DMCMK1), (SPDUM NOT INSIDE DMCMK1), Cut is not allowed. >= 0.001um
 chk_area = (SIZE DNW BY 0.001) NOT (SIZE DNW BY -0.001)
 chk_area AND DMC5
}

DUMC_101_SN {
@ DMC5 space to edge of GT_P96, PSUB, NW, DNW, SN, SP, (SNDUM NOT INSIDE DMCMK1), (SPDUM NOT INSIDE DMCMK1), Cut is not allowed. >= 0.001um
 chk_area = (SIZE SN BY 0.001) NOT (SIZE SN BY -0.001)
 chk_area AND DMC5
}

DUMC_101_SP {
@ DMC5 space to edge of GT_P96, PSUB, NW, DNW, SN, SP, (SNDUM NOT INSIDE DMCMK1), (SPDUM NOT INSIDE DMCMK1), Cut is not allowed. >= 0.001um
 chk_area = (SIZE SP BY 0.001) NOT (SIZE SP BY -0.001)
 chk_area AND DMC5
}

DUMC_101_SNDUM {
@ DMC5 space to edge of GT_P96, PSUB, NW, DNW, SN, SP, (SNDUM NOT INSIDE DMCMK1), (SPDUM NOT INSIDE DMCMK1), Cut is not allowed. >= 0.001um
 chk_area = (SIZE SNDUM_outside_DMCMK1 BY 0.001) NOT (SIZE SNDUM_outside_DMCMK1 BY -0.001)
 chk_area AND DMC5
}

DUMC_101_SPDUM {
@ DMC5 space to edge of GT_P96, PSUB, NW, DNW, SN, SP, (SNDUM NOT INSIDE DMCMK1), (SPDUM NOT INSIDE DMCMK1), Cut is not allowed. >= 0.001um
 chk_area = (SIZE SPDUM_outside_DMCMK1 BY 0.001) NOT (SIZE SPDUM_outside_DMCMK1 BY -0.001)
 chk_area AND DMC5
}

DUMC_102 {
@ DMC5 space to P2, P2DMP, (P2DOP NOT INSIDE DMCMK1), Overlap is not allowed. >= 0.18um
 err1 = EXT DMC5 P2 < 0.18 ABUT<90 SINGULAR REGION INSIDE ALSO
 err2 = EXT DMC5 P2DMP < 0.18 ABUT<90 SINGULAR REGION INSIDE ALSO
 err3 = EXT DMC5 P2DOP_outside_DMCMK1 < 0.18 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
}

DUMC_103 {
@ DMC5 space to (M0CDUM NOT INSIDE DMCMK1), Overlap is not allowed. >= 0.3um
 err1 = EXT DMC5 M0CDUM_outside_DMCMK1 < 0.300 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_104 {
@ DMC5 space to (M0CDOP NOT INSIDE DMCMK1), Overlap is not allowed. >= 0.75um
 err1 = EXT DMC5 M0CDOP_outside_DMCMK1 < 0.750 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_105 {
@ DMC5 space to INST, Overlap is not allowed. >= 0.21um
 err1 = EXT DMC5 INST < 0.21 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_106 {
@ DMC5 space to DIR, DIRDMP, RESP1, Overlap is not allowed. >= 0.35um
 err1 = EXT DMC5 DIR < 0.35 ABUT<90 SINGULAR REGION INSIDE ALSO
 err2 = EXT DMC5 DIRDMP < 0.35 ABUT<90 SINGULAR REGION INSIDE ALSO
 err3 = EXT DMC5 RESP1 < 0.35 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
}

DUMC_107 {
@ DMC5 space to PLRES, RESP2, LDBK, DMPNP, DSTR, VARMOS, EFUSE, Overlap is not allowed. >= 0um
 err1 = DMC5 AND (OR PLRES RESP2 LDBK DMPNP DSTR VARMOS EFUSE)
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_108 {
@ DMC5 space to OCCDFH, Overlap is not allowed. >= 0.32um
 err1 = EXT DMC5 OCCDFH < 0.32 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

//DUMC_109 {
//@ DMC5 space to ESD1 >= 0.189um
// err1 = EXT DMC5 ESD1 < 0.189 ABUT<90 SINGULAR REGION MEASURE ALL
// err1 NOT INSIDE SealR_NOT_BULK
//}

DUMC_110 {
@ DMC5 space to DIOMK1, DIOMK2, Overlap is not allowed. >= 0.025um
 err1 = EXT DMC5 DIOMK1 < 0.025 ABUT<90 SINGULAR REGION INSIDE ALSO
 err2 = EXT DMC5 DIOMK2 < 0.025 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

DUMC_111 {
@ DMC5 space to V0, Overlap is not allowed. >= 0.04um
 err1 = EXT DMC5 V0 < 0.04 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_112_HVT_N {
@ DMC5 space to edge of HVT_N, HVT_P, SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, Cut is not allowed. >= 0.007um
 chk_area = (SIZE HVT_N BY 0.007) NOT (SIZE HVT_N BY -0.007)
 chk_area AND DMC5
}

DUMC_112_HVT_P {
@ DMC5 space to edge of HVT_N, HVT_P, SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, Cut is not allowed. >= 0.007um
 chk_area = (SIZE HVT_P BY 0.007) NOT (SIZE HVT_P BY -0.007)
 chk_area AND DMC5
}

DUMC_112_SVT_N {
@ DMC5 space to edge of HVT_N, HVT_P, SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, Cut is not allowed. >= 0.007um
 chk_area = (SIZE SVT_N BY 0.007) NOT (SIZE SVT_N BY -0.007)
 chk_area AND DMC5
}

DUMC_112_SVT_P {
@ DMC5 space to edge of HVT_N, HVT_P, SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, Cut is not allowed. >= 0.007um
 chk_area = (SIZE SVT_P BY 0.007) NOT (SIZE SVT_P BY -0.007)
 chk_area AND DMC5
}

DUMC_112_LVT_N {
@ DMC5 space to edge of HVT_N, HVT_P, SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, Cut is not allowed. >= 0.007um
 chk_area = (SIZE LVT_N BY 0.007) NOT (SIZE LVT_N BY -0.007)
 chk_area AND DMC5
}

DUMC_112_LVT_P {
@ DMC5 space to edge of HVT_N, HVT_P, SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, Cut is not allowed. >= 0.007um
 chk_area = (SIZE LVT_P BY 0.007) NOT (SIZE LVT_P BY -0.007)
 chk_area AND DMC5
}

DUMC_112_ULVT_N {
@ DMC5 space to edge of HVT_N, HVT_P, SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, Cut is not allowed. >= 0.007um
 chk_area = (SIZE ULVT_N BY 0.007) NOT (SIZE ULVT_N BY -0.007)
 chk_area AND DMC5
}

DUMC_112_ULVT_P {
@ DMC5 space to edge of HVT_N, HVT_P, SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, Cut is not allowed. >= 0.007um
 chk_area = (SIZE ULVT_P BY 0.007) NOT (SIZE ULVT_P BY -0.007)
 chk_area AND DMC5
}

DUMC_112_LFN_N {
@ DMC5 space to edge of HVT_N, HVT_P, SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, Cut is not allowed. >= 0.007um
 chk_area = (SIZE LFN_N BY 0.007) NOT (SIZE LFN_N BY -0.007)
 chk_area AND DMC5
}

DUMC_112_LFN_P {
@ DMC5 space to edge of HVT_N, HVT_P, SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, Cut is not allowed. >= 0.007um
 chk_area = (SIZE LFN_P BY 0.007) NOT (SIZE LFN_P BY -0.007)
 chk_area AND DMC5
}

DUMC_113 {
@ Inside edge of DG space to DMC5, Outside and cut is not allowed >= 0.002um
 err1 = ENC DMC5 DG < 0.002 ABUT<90 SINGULAR REGION OUTSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_114_DGUD {
@ DMC5 space to edge of DGUD, DGV, Cut is not allowed. >= 0.002um
 chk_area = (SIZE DGUD BY 0.002) NOT (SIZE DGUD BY -0.002)
 chk_area AND DMC5
}

DUMC_114_DGV {
@ DMC5 space to edge of DGUD, DGV, Cut is not allowed. >= 0.002um
 chk_area = (SIZE DGV BY 0.002) NOT (SIZE DGV BY -0.002)
 chk_area AND DMC5
}

DUMC_115 {
@ DMC5 space to DMC2, DMC3, DMC4, Overlap is not allowed. >= 0.192um
 err1 = EXT DMC5 DMC2 < 0.192 ABUT<90 SINGULAR REGION INSIDE ALSO
 err2 = EXT DMC5 DMC3 < 0.192 ABUT<90 SINGULAR REGION INSIDE ALSO
 err3 = EXT DMC5 DMC4 < 0.192 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
}

DUMC_116 {
@ DMC5 horizontal space to DMC2, DMC3, DMC4, Overlap is not allowed. >= 0.2um
 err1 = EXT (ANGLE DMC5 == 90) DMC2 < 0.2 ABUT<90 OPPOSITE REGION INSIDE ALSO
 err2 = EXT (ANGLE DMC5 == 90) DMC3 < 0.2 ABUT<90 OPPOSITE REGION INSIDE ALSO
 err3 = EXT (ANGLE DMC5 == 90) DMC4 < 0.2 ABUT<90 OPPOSITE REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
}

#IFDEF CHIPB_RULES_CHECK YES
DUMC_117 {
@ Inside edge of CHIPB space to DMC6, Outside and cut is not allowed. >= 0.45um
 err1 = ENC DMC6 CHIPB < 0.45 ABUT<90 SINGULAR REGION OUTSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
#ENDIF

DUMC_118_DUMBA {
@ DMC6 space to DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, AR_H, AR_V, (AR_HDOP NOT INSIDE DMCMK1), (AR_VDOP NOT INSIDE DMCMK1), (ARBL NOT INSIDE DMCMK1), Overlap is not allowed. >= 0.144um
 err1 = EXT DMC6 DUMBA < 0.144 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_118_DUMBP {
@ DMC6 space to DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, AR_H, AR_V, (AR_HDOP NOT INSIDE DMCMK1), (AR_VDOP NOT INSIDE DMCMK1), (ARBL NOT INSIDE DMCMK1), Overlap is not allowed. >= 0.144um
 err1 = EXT DMC6 DUMBP < 0.144 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_118_ARDUB {
@ DMC6 space to DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, AR_H, AR_V, (AR_HDOP NOT INSIDE DMCMK1), (AR_VDOP NOT INSIDE DMCMK1), (ARBL NOT INSIDE DMCMK1), Overlap is not allowed. >= 0.144um
 err1 = EXT DMC6 ARDUB < 0.144 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_118_P2DUB {
@ DMC6 space to DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, AR_H, AR_V, (AR_HDOP NOT INSIDE DMCMK1), (AR_VDOP NOT INSIDE DMCMK1), (ARBL NOT INSIDE DMCMK1), Overlap is not allowed. >= 0.144um
 err1 = EXT DMC6 P2DUB < 0.144 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_118_M0DUB {
@ DMC6 space to DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, AR_H, AR_V, (AR_HDOP NOT INSIDE DMCMK1), (AR_VDOP NOT INSIDE DMCMK1), (ARBL NOT INSIDE DMCMK1), Overlap is not allowed. >= 0.144um
 err1 = EXT DMC6 M0DUB < 0.144 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_118_M0CDUB {
@ DMC6 space to DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, AR_H, AR_V, (AR_HDOP NOT INSIDE DMCMK1), (AR_VDOP NOT INSIDE DMCMK1), (ARBL NOT INSIDE DMCMK1), Overlap is not allowed. >= 0.144um
 err1 = EXT DMC6 M0CDUB < 0.144 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_118_M0GDUB {
@ DMC6 space to DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, AR_H, AR_V, (AR_HDOP NOT INSIDE DMCMK1), (AR_VDOP NOT INSIDE DMCMK1), (ARBL NOT INSIDE DMCMK1), Overlap is not allowed. >= 0.144um
 err1 = EXT DMC6 M0GDUB < 0.144 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_118_AR_H {
@ DMC6 space to DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, AR_H, AR_V, (AR_HDOP NOT INSIDE DMCMK1), (AR_VDOP NOT INSIDE DMCMK1), (ARBL NOT INSIDE DMCMK1), Overlap is not allowed. >= 0.144um
 err1 = EXT DMC6 AR_H < 0.144 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_118_AR_V {
@ DMC6 space to DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, AR_H, AR_V, (AR_HDOP NOT INSIDE DMCMK1), (AR_VDOP NOT INSIDE DMCMK1), (ARBL NOT INSIDE DMCMK1), Overlap is not allowed. >= 0.144um
 err1 = EXT DMC6 AR_V < 0.144 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_118_AR_HDOP {
@ DMC6 space to DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, AR_H, AR_V, (AR_HDOP NOT INSIDE DMCMK1), (AR_VDOP NOT INSIDE DMCMK1), (ARBL NOT INSIDE DMCMK1), Overlap is not allowed. >= 0.144um
 err1 = EXT DMC6 AR_HDOP_outside_DMCMK1 < 0.144 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_118_AR_VDOP {
@ DMC6 space to DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, AR_H, AR_V, (AR_HDOP NOT INSIDE DMCMK1), (AR_VDOP NOT INSIDE DMCMK1), (ARBL NOT INSIDE DMCMK1), Overlap is not allowed. >= 0.144um
 err1 = EXT DMC6 AR_VDOP_outside_DMCMK1 < 0.144 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_118_ARBL {
@ DMC6 space to DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, AR_H, AR_V, (AR_HDOP NOT INSIDE DMCMK1), (AR_VDOP NOT INSIDE DMCMK1), (ARBL NOT INSIDE DMCMK1), Overlap is not allowed. >= 0.144um
 err1 = EXT DMC6 ARBL_outside_DMCMK1 < 0.144 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_119_NPAA_EXT {
@ DMC6 space to NPAA_EXT, RESNW, MARKG, MARKS, NODMF, Overlap is not allowed >= 0.4um
 err1 = EXT DMC6 NPAA_EXT < 0.4 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_119_RESNW {
@ DMC6 space to NPAA_EXT, RESNW, MARKG, MARKS, NODMF, Overlap is not allowed >= 0.4um
 err1 = EXT DMC6 RESNW < 0.4 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_119_MARKG {
@ DMC6 space to NPAA_EXT, RESNW, MARKG, MARKS, NODMF, Overlap is not allowed >= 0.4um
 err1 = EXT DMC6 MARKG < 0.4 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_119_MARKS {
@ DMC6 space to NPAA_EXT, RESNW, MARKG, MARKS, NODMF, Overlap is not allowed >= 0.4um
 err1 = EXT DMC6 MARKS < 0.4 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_119_NODMF {
@ DMC6 space to NPAA_EXT, RESNW, MARKG, MARKS, NODMF, Overlap is not allowed >= 0.4um
 err1 = EXT DMC6 NODMF < 0.4 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_120_AA {
@ DMC6 space to AA, AADMP, PPAA, M0, M0DMP, (M0DOP NOT INSIDE DMCMK1), M0G, M0GDMP, (M0GDOP NOT INSIDE DMCMK1), INDMY, DG, DGUD, DGV, Overlap is not allowed >= 0.2um
 err1 = EXT DMC6 AA < 0.2 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_120_AADMP {
@ DMC6 space to AA, AADMP, PPAA, M0, M0DMP, (M0DOP NOT INSIDE DMCMK1), M0G, M0GDMP, (M0GDOP NOT INSIDE DMCMK1), INDMY, DG, DGUD, DGV, Overlap is not allowed >= 0.2um
 err1 = EXT DMC6 AADMP < 0.2 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_120_PPAA {
@ DMC6 space to AA, AADMP, PPAA, M0, M0DMP, (M0DOP NOT INSIDE DMCMK1), M0G, M0GDMP, (M0GDOP NOT INSIDE DMCMK1), INDMY, DG, DGUD, DGV, Overlap is not allowed >= 0.2um
 err1 = EXT DMC6 PPAA < 0.2 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_120_M0 {
@ DMC6 space to AA, AADMP, PPAA, M0, M0DMP, (M0DOP NOT INSIDE DMCMK1), M0G, M0GDMP, (M0GDOP NOT INSIDE DMCMK1), INDMY, DG, DGUD, DGV, Overlap is not allowed >= 0.2um
 err1 = EXT DMC6 M0 < 0.2 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_120_M0DMP {
@ DMC6 space to AA, AADMP, PPAA, M0, M0DMP, (M0DOP NOT INSIDE DMCMK1), M0G, M0GDMP, (M0GDOP NOT INSIDE DMCMK1), INDMY, DG, DGUD, DGV, Overlap is not allowed >= 0.2um
 err1 = EXT DMC6 M0DMP < 0.2 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_120_M0DOP {
@ DMC6 space to AA, AADMP, PPAA, M0, M0DMP, (M0DOP NOT INSIDE DMCMK1), M0G, M0GDMP, (M0GDOP NOT INSIDE DMCMK1), INDMY, DG, DGUD, DGV, Overlap is not allowed >= 0.2um
 err1 = EXT DMC6 M0DOP_outside_DMCMK1 < 0.2 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_120_M0G {
@ DMC6 space to AA, AADMP, PPAA, M0, M0DMP, (M0DOP NOT INSIDE DMCMK1), M0G, M0GDMP, (M0GDOP NOT INSIDE DMCMK1), INDMY, DG, DGUD, DGV, Overlap is not allowed >= 0.2um
 err1 = EXT DMC6 M0G < 0.2 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_120_M0GDMP {
@ DMC6 space to AA, AADMP, PPAA, M0, M0DMP, (M0DOP NOT INSIDE DMCMK1), M0G, M0GDMP, (M0GDOP NOT INSIDE DMCMK1), INDMY, DG, DGUD, DGV, Overlap is not allowed >= 0.2um
 err1 = EXT DMC6 M0GDMP < 0.2 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_120_M0GDOP {
@ DMC6 space to AA, AADMP, PPAA, M0, M0DMP, (M0DOP NOT INSIDE DMCMK1), M0G, M0GDMP, (M0GDOP NOT INSIDE DMCMK1), INDMY, DG, DGUD, DGV, Overlap is not allowed >= 0.2um
 err1 = EXT DMC6 M0GDOP_outside_DMCMK1 < 0.2 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_120_INDMY {
@ DMC6 space to AA, AADMP, PPAA, M0, M0DMP, (M0DOP NOT INSIDE DMCMK1), M0G, M0GDMP, (M0GDOP NOT INSIDE DMCMK1), INDMY, DG, DGUD, DGV, Overlap is not allowed >= 0.2um
 err1 = EXT DMC6 INDMY < 0.2 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

//DUMC_120_OCOVL_NOT_OCOVLM4 {
//@ DMC6 space to AA, AADMP, PPAA, M0, M0DMP, (M0DOP NOT INSIDE DMCMK1), M0G, M0GDMP, (M0GDOP NOT INSIDE DMCMK1), INDMY, DG, DGUD, DGV, Overlap is not allowed >= 0.2um
// err1 = EXT DMC6 OCOVL_NOT_OCOVLM4 < 0.2 ABUT<90 SINGULAR REGION INSIDE ALSO
// err1 NOT INSIDE SealR_NOT_BULK
//}

DUMC_120_DG {
@ DMC6 space to AA, AADMP, PPAA, M0, M0DMP, (M0DOP NOT INSIDE DMCMK1), M0G, M0GDMP, (M0GDOP NOT INSIDE DMCMK1), INDMY, DG, DGUD, DGV, Overlap is not allowed >= 0.2um
 err1 = EXT DMC6 DG < 0.2 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_120_DGUD {
@ DMC6 space to AA, AADMP, PPAA, M0, M0DMP, (M0DOP NOT INSIDE DMCMK1), M0G, M0GDMP, (M0GDOP NOT INSIDE DMCMK1), INDMY, DG, DGUD, DGV, Overlap is not allowed >= 0.2um
 err1 = EXT DMC6 DGUD < 0.2 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_120_DGV {
@ DMC6 space to AA, AADMP, PPAA, M0, M0DMP, (M0DOP NOT INSIDE DMCMK1), M0G, M0GDMP, (M0GDOP NOT INSIDE DMCMK1), INDMY, DG, DGUD, DGV, Overlap is not allowed >= 0.2um
 err1 = EXT DMC6 DGV < 0.2 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_121_AADUM {
@ DMC6 space to (AADUM NOT INSIDE DMCMK1), (AADOP NOT INSIDE DMCMK1), (P2DUM NOT INSIDE DMCMK1), (M0DUM NOT INSIDE DMCMK1), M0C, M0CDMP, (M0GDUM NOT INSIDE DMCMK1), DMC1, Overlap is not allowed.  >= 0.27um
 err1 = EXT DMC6 AADUM_outside_DMCMK1 < 0.27 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_121_AADOP {
@ DMC6 space to (AADUM NOT INSIDE DMCMK1), (AADOP NOT INSIDE DMCMK1), (P2DUM NOT INSIDE DMCMK1), (M0DUM NOT INSIDE DMCMK1), M0C, M0CDMP, (M0GDUM NOT INSIDE DMCMK1), DMC1, Overlap is not allowed.  >= 0.27um
 err1 = EXT DMC6 AADOP_outside_DMCMK1 < 0.27 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_121_P2DUM {
@ DMC6 space to (AADUM NOT INSIDE DMCMK1), (AADOP NOT INSIDE DMCMK1), (P2DUM NOT INSIDE DMCMK1), (M0DUM NOT INSIDE DMCMK1), M0C, M0CDMP, (M0GDUM NOT INSIDE DMCMK1), DMC1, Overlap is not allowed.  >= 0.27um
 err1 = EXT DMC6 P2DUM_outside_DMCMK1 < 0.27 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_121_M0DUM {
@ DMC6 space to (AADUM NOT INSIDE DMCMK1), (AADOP NOT INSIDE DMCMK1), (P2DUM NOT INSIDE DMCMK1), (M0DUM NOT INSIDE DMCMK1), M0C, M0CDMP, (M0GDUM NOT INSIDE DMCMK1), DMC1, Overlap is not allowed.  >= 0.27um
 err1 = EXT DMC6 M0DUM_outside_DMCMK1 < 0.27 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_121_M0C {
@ DMC6 space to (AADUM NOT INSIDE DMCMK1), (AADOP NOT INSIDE DMCMK1), (P2DUM NOT INSIDE DMCMK1), (M0DUM NOT INSIDE DMCMK1), M0C, M0CDMP, (M0GDUM NOT INSIDE DMCMK1), DMC1, Overlap is not allowed.  >= 0.27um
 err1 = EXT DMC6 M0C < 0.27 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_121_M0CDMP {
@ DMC6 space to (AADUM NOT INSIDE DMCMK1), (AADOP NOT INSIDE DMCMK1), (P2DUM NOT INSIDE DMCMK1), (M0DUM NOT INSIDE DMCMK1), M0C, M0CDMP, (M0GDUM NOT INSIDE DMCMK1), DMC1, Overlap is not allowed.  >= 0.27um
 err1 = EXT DMC6 M0CDMP < 0.27 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_121_M0GDUM {
@ DMC6 space to (AADUM NOT INSIDE DMCMK1), (AADOP NOT INSIDE DMCMK1), (P2DUM NOT INSIDE DMCMK1), (M0DUM NOT INSIDE DMCMK1), M0C, M0CDMP, (M0GDUM NOT INSIDE DMCMK1), DMC1, Overlap is not allowed.  >= 0.27um
 err1 = EXT DMC6 M0GDUM_outside_DMCMK1 < 0.27 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_121_DMC1 {
@ DMC6 space to (AADUM NOT INSIDE DMCMK1), (AADOP NOT INSIDE DMCMK1), (P2DUM NOT INSIDE DMCMK1), (M0DUM NOT INSIDE DMCMK1), M0C, M0CDMP, (M0GDUM NOT INSIDE DMCMK1), DMC1, Overlap is not allowed.  >= 0.27um
 err1 = EXT DMC6 DMC1 < 0.27 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_122 {
@ DMC6 space to AR, Overlap is not allowed >= 0.16um
 err1 = EXT DMC6 AR < 0.16 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_123 {
@ DMC6 space to (ARDUM NOT INSIDE DMCMK1), (ARDOP NOT INSIDE DMCMK1), Overlap is not allowed >= 0.182um
 err1 = EXT DMC6 ARDUM_outside_DMCMK1 < 0.182 ABUT<90 SINGULAR REGION INSIDE ALSO
 err2 = EXT DMC6 ARDOP_outside_DMCMK1 < 0.182 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

DUMC_124 {
@ DMC6 space to GT, GTDMP, (GTDUM NOT INSIDE DMCMK1), (GTDOP NOT INSIDE DMCMK1), Overlap is not allowed >= 0.274um
 err1 = EXT DMC6 DMP_GT < 0.274 ABUT<90 SINGULAR REGION INSIDE ALSO
 err2 = EXT DMC6 GTDUM_outside_DMCMK1 < 0.274 ABUT<90 SINGULAR REGION INSIDE ALSO
 err3 = EXT DMC6 GTDOP_outside_DMCMK1 < 0.274 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
}

DUMC_125_GT_P96 {
@ DMC6 space to edge of GT_P96, PSUB, NW, DNW, SN, SP, (SNDUM NOT INSIDE DMCMK1), (SPDUM NOT INSIDE DMCMK1), HVT_N, HVT_P, SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, Cut is not allowed >= 0.001um
 chk_area = (SIZE GT_P96 BY 0.001) NOT (SIZE GT_P96 BY -0.001)
 chk_area AND DMC6
}

DUMC_125_PSUB {
@ DMC6 space to edge of GT_P96, PSUB, NW, DNW, SN, SP, (SNDUM NOT INSIDE DMCMK1), (SPDUM NOT INSIDE DMCMK1), HVT_N, HVT_P, SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, Cut is not allowed >= 0.001um
 chk_area = (SIZE PSUB BY 0.001) NOT (SIZE PSUB BY -0.001)
 chk_area AND DMC6
}

DUMC_125_NW {
@ DMC6 space to edge of GT_P96, PSUB, NW, DNW, SN, SP, (SNDUM NOT INSIDE DMCMK1), (SPDUM NOT INSIDE DMCMK1), HVT_N, HVT_P, SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, Cut is not allowed >= 0.001um
 chk_area = (SIZE NW BY 0.001) NOT (SIZE NW BY -0.001)
 chk_area AND DMC6
}

DUMC_125_DNW {
@ DMC6 space to edge of GT_P96, PSUB, NW, DNW, SN, SP, (SNDUM NOT INSIDE DMCMK1), (SPDUM NOT INSIDE DMCMK1), HVT_N, HVT_P, SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, Cut is not allowed >= 0.001um
 chk_area = (SIZE DNW BY 0.001) NOT (SIZE DNW BY -0.001)
 chk_area AND DMC6
}

DUMC_125_SN {
@ DMC6 space to edge of GT_P96, PSUB, NW, DNW, SN, SP, (SNDUM NOT INSIDE DMCMK1), (SPDUM NOT INSIDE DMCMK1), HVT_N, HVT_P, SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, Cut is not allowed >= 0.001um
 chk_area = (SIZE SN BY 0.001) NOT (SIZE SN BY -0.001)
 chk_area AND DMC6
}

DUMC_125_SP {
@ DMC6 space to edge of GT_P96, PSUB, NW, DNW, SN, SP, (SNDUM NOT INSIDE DMCMK1), (SPDUM NOT INSIDE DMCMK1), HVT_N, HVT_P, SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, Cut is not allowed >= 0.001um
 chk_area = (SIZE SP BY 0.001) NOT (SIZE SP BY -0.001)
 chk_area AND DMC6
}

DUMC_125_SNDUM {
@ DMC6 space to edge of GT_P96, PSUB, NW, DNW, SN, SP, (SNDUM NOT INSIDE DMCMK1), (SPDUM NOT INSIDE DMCMK1), HVT_N, HVT_P, SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, Cut is not allowed >= 0.001um
 chk_area = (SIZE SNDUM_outside_DMCMK1 BY 0.001) NOT (SIZE SNDUM_outside_DMCMK1 BY -0.001)
 chk_area AND DMC6
}

DUMC_125_SPDUM {
@ DMC6 space to edge of GT_P96, PSUB, NW, DNW, SN, SP, (SNDUM NOT INSIDE DMCMK1), (SPDUM NOT INSIDE DMCMK1), HVT_N, HVT_P, SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, Cut is not allowed >= 0.001um
 chk_area = (SIZE SPDUM_outside_DMCMK1 BY 0.001) NOT (SIZE SPDUM_outside_DMCMK1 BY -0.001)
 chk_area AND DMC6
}

DUMC_125_HVT_N {
@ DMC6 space to edge of GT_P96, PSUB, NW, DNW, SN, SP, (SNDUM NOT INSIDE DMCMK1), (SPDUM NOT INSIDE DMCMK1), HVT_N, HVT_P, SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, Cut is not allowed >= 0.001um
 chk_area = (SIZE HVT_N BY 0.001) NOT (SIZE HVT_N BY -0.001)
 chk_area AND DMC6
}

DUMC_125_HVT_P {
@ DMC6 space to edge of GT_P96, PSUB, NW, DNW, SN, SP, (SNDUM NOT INSIDE DMCMK1), (SPDUM NOT INSIDE DMCMK1), HVT_N, HVT_P, SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, Cut is not allowed >= 0.001um
 chk_area = (SIZE HVT_P BY 0.001) NOT (SIZE HVT_P BY -0.001)
 chk_area AND DMC6
}

DUMC_125_SVT_N {
@ DMC6 space to edge of GT_P96, PSUB, NW, DNW, SN, SP, (SNDUM NOT INSIDE DMCMK1), (SPDUM NOT INSIDE DMCMK1), HVT_N, HVT_P, SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, Cut is not allowed >= 0.001um
 chk_area = (SIZE SVT_N BY 0.001) NOT (SIZE SVT_N BY -0.001)
 chk_area AND DMC6
}

DUMC_125_SVT_P {
@ DMC6 space to edge of GT_P96, PSUB, NW, DNW, SN, SP, (SNDUM NOT INSIDE DMCMK1), (SPDUM NOT INSIDE DMCMK1), HVT_N, HVT_P, SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, Cut is not allowed >= 0.001um
 chk_area = (SIZE SVT_P BY 0.001) NOT (SIZE SVT_P BY -0.001)
 chk_area AND DMC6
}

DUMC_125_LVT_N {
@ DMC6 space to edge of GT_P96, PSUB, NW, DNW, SN, SP, (SNDUM NOT INSIDE DMCMK1), (SPDUM NOT INSIDE DMCMK1), HVT_N, HVT_P, SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, Cut is not allowed >= 0.001um
 chk_area = (SIZE LVT_N BY 0.001) NOT (SIZE LVT_N BY -0.001)
 chk_area AND DMC6
}

DUMC_125_LVT_P {
@ DMC6 space to edge of GT_P96, PSUB, NW, DNW, SN, SP, (SNDUM NOT INSIDE DMCMK1), (SPDUM NOT INSIDE DMCMK1), HVT_N, HVT_P, SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, Cut is not allowed >= 0.001um
 chk_area = (SIZE LVT_P BY 0.001) NOT (SIZE LVT_P BY -0.001)
 chk_area AND DMC6
}

DUMC_125_ULVT_N {
@ DMC6 space to edge of GT_P96, PSUB, NW, DNW, SN, SP, (SNDUM NOT INSIDE DMCMK1), (SPDUM NOT INSIDE DMCMK1), HVT_N, HVT_P, SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, Cut is not allowed >= 0.001um
 chk_area = (SIZE ULVT_N BY 0.001) NOT (SIZE ULVT_N BY -0.001)
 chk_area AND DMC6
}

DUMC_125_ULVT_P {
@ DMC6 space to edge of GT_P96, PSUB, NW, DNW, SN, SP, (SNDUM NOT INSIDE DMCMK1), (SPDUM NOT INSIDE DMCMK1), HVT_N, HVT_P, SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, Cut is not allowed >= 0.001um
 chk_area = (SIZE ULVT_P BY 0.001) NOT (SIZE ULVT_P BY -0.001)
 chk_area AND DMC6
}

DUMC_125_LFN_N {
@ DMC6 space to edge of GT_P96, PSUB, NW, DNW, SN, SP, (SNDUM NOT INSIDE DMCMK1), (SPDUM NOT INSIDE DMCMK1), HVT_N, HVT_P, SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, Cut is not allowed >= 0.001um
 chk_area = (SIZE LFN_N BY 0.001) NOT (SIZE LFN_N BY -0.001)
 chk_area AND DMC6
}

DUMC_125_LFN_P {
@ DMC6 space to edge of GT_P96, PSUB, NW, DNW, SN, SP, (SNDUM NOT INSIDE DMCMK1), (SPDUM NOT INSIDE DMCMK1), HVT_N, HVT_P, SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, Cut is not allowed >= 0.001um
 chk_area = (SIZE LFN_P BY 0.001) NOT (SIZE LFN_P BY -0.001)
 chk_area AND DMC6
}

DUMC_126 {
@ DMC6 space to P2, P2DMP, (P2DOP NOT INSIDE DMCMK1), Overlap is not allowed >= 0.18um
 err1 = EXT DMC6 P2 < 0.18 ABUT<90 SINGULAR REGION INSIDE ALSO
 err2 = EXT DMC6 P2DMP < 0.18 ABUT<90 SINGULAR REGION INSIDE ALSO
 err3 = EXT DMC6 P2DOP_outside_DMCMK1 < 0.18 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
}

DUMC_127 {
@ DMC6 space to (M0CDUM NOT INSIDE DMCMK1), Overlap is not allowed >= 0.3um
 err1 = EXT DMC6 M0CDUM_outside_DMCMK1 < 0.300 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_128 {
@ DMC6 space to (M0CDOP NOT INSIDE DMCMK1), Overlap is not allowed >= 0.75um
 err1 = EXT DMC6 M0CDOP_outside_DMCMK1 < 0.750 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_129 {
@ DMC6 space to INST, Overlap is not allowed >= 0.21um
 err1 = EXT DMC6 INST < 0.21 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_130 {
@ DMC6 space to DIR, DIRDMP, RESP1, Overlap is not allowed >= 0.35um
 err1 = EXT DMC6 DIR < 0.35 ABUT<90 SINGULAR REGION INSIDE ALSO
 err2 = EXT DMC6 DIRDMP < 0.35 ABUT<90 SINGULAR REGION INSIDE ALSO
 err3 = EXT DMC6 RESP1 < 0.35 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
}

DUMC_131 {
@ DMC6 space to PLRES, RESP2, LDBK, DMPNP, DSTR, VARMOS, EFUSE, Overlap is not allowed >= 0um
 err1 = DMC6 AND (OR PLRES RESP2 LDBK DMPNP DSTR VARMOS EFUSE)
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_132 {
@ DMC6 space to OCCDFH, Overlap is not allowed >= 0.32um
 err1 = EXT DMC6 OCCDFH < 0.32 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

//DUMC_133 {
//@ DMC6 space to ESD1 >= 0.189um
// err1 = EXT DMC6 ESD1 < 0.189 ABUT<90 SINGULAR REGION MEASURE ALL
// err1 NOT INSIDE SealR_NOT_BULK
//}

DUMC_134 {
@ DMC6 space to DIOMK1, DIOMK2, Overlap is not allowed >= 0.025um
 err1 = EXT DMC6 DIOMK1 < 0.025 ABUT<90 SINGULAR REGION INSIDE ALSO
 err2 = EXT DMC6 DIOMK2 < 0.025 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

DUMC_135 {
@ DMC6 space to V0, Overlap is not allowed >= 0.04um
 err1 = EXT DMC6 V0 < 0.04 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_136 {
@ DMC6 space to DMC2, DMC4, Overlap is not allowed >= 0.142um
 err1 = EXT DMC6 DMC2 < 0.142 ABUT<90 SINGULAR REGION INSIDE ALSO
 err2 = EXT DMC6 DMC4 < 0.142 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

DUMC_137 {
@ DMC6 vertical space to DMC2, DMC4, Overlap is not allowed >= 0.192um
 err1 = EXT (ANGLE DMC6 == 0) DMC2 < 0.192 ABUT<90 OPPOSITE REGION INSIDE ALSO
 err2 = EXT (ANGLE DMC6 == 0) DMC4 < 0.192 ABUT<90 OPPOSITE REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

DUMC_138 {
@ DMC6 space to DMC3, DMC5, Overlap is not allowed >= 0.192um
 err1 = EXT DMC6 DMC3 < 0.192 ABUT<90 SINGULAR REGION INSIDE ALSO
 err2 = EXT DMC6 DMC5 < 0.192 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

DUMC_139 {
@ DMC6 horizontal space to DMC3, DMC5, Overlap is not allowed >= 0.2um
 err1 = EXT (ANGLE DMC6 == 90) DMC3 < 0.2 ABUT<90 OPPOSITE REGION INSIDE ALSO
 err2 = EXT (ANGLE DMC6 == 90) DMC5 < 0.2 ABUT<90 OPPOSITE REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

#IFDEF CHIPB_RULES_CHECK YES
DUMC_140 {
@ Inside edge of CHIPB space to DMC7, Outside and cut is not allowed >= 0.45um
 err1 = ENC DMC7 CHIPB < 0.45 ABUT<90 SINGULAR REGION OUTSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
#ENDIF

DUMC_141_DUMBA {
@ DMC7 space to DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, AR_H, AR_V, (AR_HDOP NOT INSIDE DMCMK1), (AR_VDOP NOT INSIDE DMCMK1), (ARBL NOT INSIDE DMCMK1), Overlap is not allowed >= 0.144um
 err1 = EXT DMC7 DUMBA < 0.144 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_141_DUMBP {
@ DMC7 space to DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, AR_H, AR_V, (AR_HDOP NOT INSIDE DMCMK1), (AR_VDOP NOT INSIDE DMCMK1), (ARBL NOT INSIDE DMCMK1), Overlap is not allowed >= 0.144um
 err1 = EXT DMC7 DUMBP < 0.144 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_141_ARDUB {
@ DMC7 space to DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, AR_H, AR_V, (AR_HDOP NOT INSIDE DMCMK1), (AR_VDOP NOT INSIDE DMCMK1), (ARBL NOT INSIDE DMCMK1), Overlap is not allowed >= 0.144um
 err1 = EXT DMC7 ARDUB < 0.144 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_141_P2DUB {
@ DMC7 space to DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, AR_H, AR_V, (AR_HDOP NOT INSIDE DMCMK1), (AR_VDOP NOT INSIDE DMCMK1), (ARBL NOT INSIDE DMCMK1), Overlap is not allowed >= 0.144um
 err1 = EXT DMC7 P2DUB < 0.144 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_141_M0DUB {
@ DMC7 space to DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, AR_H, AR_V, (AR_HDOP NOT INSIDE DMCMK1), (AR_VDOP NOT INSIDE DMCMK1), (ARBL NOT INSIDE DMCMK1), Overlap is not allowed >= 0.144um
 err1 = EXT DMC7 M0DUB < 0.144 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_141_M0CDUB {
@ DMC7 space to DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, AR_H, AR_V, (AR_HDOP NOT INSIDE DMCMK1), (AR_VDOP NOT INSIDE DMCMK1), (ARBL NOT INSIDE DMCMK1), Overlap is not allowed >= 0.144um
 err1 = EXT DMC7 M0CDUB < 0.144 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_141_M0GDUB {
@ DMC7 space to DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, AR_H, AR_V, (AR_HDOP NOT INSIDE DMCMK1), (AR_VDOP NOT INSIDE DMCMK1), (ARBL NOT INSIDE DMCMK1), Overlap is not allowed >= 0.144um
 err1 = EXT DMC7 M0GDUB < 0.144 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_141_AR_H {
@ DMC7 space to DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, AR_H, AR_V, (AR_HDOP NOT INSIDE DMCMK1), (AR_VDOP NOT INSIDE DMCMK1), (ARBL NOT INSIDE DMCMK1), Overlap is not allowed >= 0.144um
 err1 = EXT DMC7 AR_H < 0.144 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_141_AR_V {
@ DMC7 space to DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, AR_H, AR_V, (AR_HDOP NOT INSIDE DMCMK1), (AR_VDOP NOT INSIDE DMCMK1), (ARBL NOT INSIDE DMCMK1), Overlap is not allowed >= 0.144um
 err1 = EXT DMC7 AR_V < 0.144 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_141_AR_HDOP {
@ DMC7 space to DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, AR_H, AR_V, (AR_HDOP NOT INSIDE DMCMK1), (AR_VDOP NOT INSIDE DMCMK1), (ARBL NOT INSIDE DMCMK1), Overlap is not allowed >= 0.144um
 err1 = EXT DMC7 AR_HDOP_outside_DMCMK1 < 0.144 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_141_AR_VDOP {
@ DMC7 space to DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, AR_H, AR_V, (AR_HDOP NOT INSIDE DMCMK1), (AR_VDOP NOT INSIDE DMCMK1), (ARBL NOT INSIDE DMCMK1), Overlap is not allowed >= 0.144um
 err1 = EXT DMC7 AR_VDOP_outside_DMCMK1 < 0.144 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_141_ARBL {
@ DMC7 space to DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, AR_H, AR_V, (AR_HDOP NOT INSIDE DMCMK1), (AR_VDOP NOT INSIDE DMCMK1), (ARBL NOT INSIDE DMCMK1), Overlap is not allowed >= 0.144um
 err1 = EXT DMC7 ARBL_outside_DMCMK1 < 0.144 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_142_NPAA_EXT {
@ DMC7 space to NPAA_EXT, RESNW, MARKG, MARKS, NODMF, Overlap is not allowed >= 0.4um
 err1 = EXT DMC7 NPAA_EXT < 0.4 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_142_RESNW {
@ DMC7 space to NPAA_EXT, RESNW, MARKG, MARKS, NODMF, Overlap is not allowed >= 0.4um
 err1 = EXT DMC7 RESNW < 0.4 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_142_MARKG {
@ DMC7 space to NPAA_EXT, RESNW, MARKG, MARKS, NODMF, Overlap is not allowed >= 0.4um
 err1 = EXT DMC7 MARKG < 0.4 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_142_MARKS {
@ DMC7 space to NPAA_EXT, RESNW, MARKG, MARKS, NODMF, Overlap is not allowed >= 0.4um
 err1 = EXT DMC7 MARKS < 0.4 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_142_NODMF {
@ DMC7 space to NPAA_EXT, RESNW, MARKG, MARKS, NODMF, Overlap is not allowed >= 0.4um
 err1 = EXT DMC7 NODMF < 0.4 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_143_AA {
@ DMC7 space to AA, AADMP, PPAA, M0, M0DMP, (M0DOP NOT INSIDE DMCMK1), M0G, M0GDMP, (M0GDOP NOT INSIDE DMCMK1), INDMY, Overlap is not allowed >= 0.2um
 err1 = EXT DMC7 AA < 0.200 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_143_AADMP {
@ DMC7 space to AA, AADMP, PPAA, M0, M0DMP, (M0DOP NOT INSIDE DMCMK1), M0G, M0GDMP, (M0GDOP NOT INSIDE DMCMK1), INDMY, Overlap is not allowed >= 0.2um
 err1 = EXT DMC7 AADMP < 0.200 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_143_PPAA {
@ DMC7 space to AA, AADMP, PPAA, M0, M0DMP, (M0DOP NOT INSIDE DMCMK1), M0G, M0GDMP, (M0GDOP NOT INSIDE DMCMK1), INDMY, Overlap is not allowed >= 0.2um
 err1 = EXT DMC7 PPAA < 0.200 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_143_M0 {
@ DMC7 space to AA, AADMP, PPAA, M0, M0DMP, (M0DOP NOT INSIDE DMCMK1), M0G, M0GDMP, (M0GDOP NOT INSIDE DMCMK1), INDMY, Overlap is not allowed >= 0.2um
 err1 = EXT DMC7 M0 < 0.200 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_143_M0DMP {
@ DMC7 space to AA, AADMP, PPAA, M0, M0DMP, (M0DOP NOT INSIDE DMCMK1), M0G, M0GDMP, (M0GDOP NOT INSIDE DMCMK1), INDMY, Overlap is not allowed >= 0.2um
 err1 = EXT DMC7 M0DMP < 0.200 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_143_M0DOP {
@ DMC7 space to AA, AADMP, PPAA, M0, M0DMP, (M0DOP NOT INSIDE DMCMK1), M0G, M0GDMP, (M0GDOP NOT INSIDE DMCMK1), INDMY, Overlap is not allowed >= 0.2um
 err1 = EXT DMC7 M0DOP_outside_DMCMK1 < 0.200 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_143_M0G {
@ DMC7 space to AA, AADMP, PPAA, M0, M0DMP, (M0DOP NOT INSIDE DMCMK1), M0G, M0GDMP, (M0GDOP NOT INSIDE DMCMK1), INDMY, Overlap is not allowed >= 0.2um
 err1 = EXT DMC7 M0G < 0.200 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_143_M0GDMP {
@ DMC7 space to AA, AADMP, PPAA, M0, M0DMP, (M0DOP NOT INSIDE DMCMK1), M0G, M0GDMP, (M0GDOP NOT INSIDE DMCMK1), INDMY, Overlap is not allowed >= 0.2um
 err1 = EXT DMC7 M0GDMP < 0.200 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_143_M0GDOP {
@ DMC7 space to AA, AADMP, PPAA, M0, M0DMP, (M0DOP NOT INSIDE DMCMK1), M0G, M0GDMP, (M0GDOP NOT INSIDE DMCMK1), INDMY, Overlap is not allowed >= 0.2um
 err1 = EXT DMC7 M0GDOP_outside_DMCMK1 < 0.200 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_143_INDMY {
@ DMC7 space to AA, AADMP, PPAA, M0, M0DMP, (M0DOP NOT INSIDE DMCMK1), M0G, M0GDMP, (M0GDOP NOT INSIDE DMCMK1), INDMY, Overlap is not allowed >= 0.2um
 err1 = EXT DMC7 INDMY < 0.200 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

//DUMC_143_OCOVL_NOT_OCOVLM4 {
//@ DMC7 space to AA, AADMP, PPAA, M0, M0DMP, (M0DOP NOT INSIDE DMCMK1), M0G, M0GDMP, (M0GDOP NOT INSIDE DMCMK1), INDMY, OCOVL_NOT_OCOVLM4 >= 0.2um
// err1 = EXT DMC7 OCOVL_NOT_OCOVLM4 < 0.200 ABUT<90 SINGULAR REGION MEASURE ALL
// err1 NOT INSIDE SealR_NOT_BULK
//}

DUMC_144_AADUM {
@ DMC7 space to (AADUM NOT INSIDE DMCMK1), (AADOP NOT INSIDE DMCMK1), (P2DUM NOT INSIDE DMCMK1), (M0DUM NOT INSIDE DMCMK1), M0C, M0CDMP, (M0GDUM NOT INSIDE DMCMK1), DMC1, Overlap is not allowed >= 0.27um
 err1 = EXT DMC7 AADUM_outside_DMCMK1 < 0.27 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_144_AADOP {
@ DMC7 space to (AADUM NOT INSIDE DMCMK1), (AADOP NOT INSIDE DMCMK1), (P2DUM NOT INSIDE DMCMK1), (M0DUM NOT INSIDE DMCMK1), M0C, M0CDMP, (M0GDUM NOT INSIDE DMCMK1), DMC1, Overlap is not allowed >= 0.27um
 err1 = EXT DMC7 AADOP_outside_DMCMK1 < 0.27 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_144_P2DUM {
@ DMC7 space to (AADUM NOT INSIDE DMCMK1), (AADOP NOT INSIDE DMCMK1), (P2DUM NOT INSIDE DMCMK1), (M0DUM NOT INSIDE DMCMK1), M0C, M0CDMP, (M0GDUM NOT INSIDE DMCMK1), DMC1, Overlap is not allowed >= 0.27um
 err1 = EXT DMC7 P2DUM_outside_DMCMK1 < 0.27 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_144_M0DUM {
@ DMC7 space to (AADUM NOT INSIDE DMCMK1), (AADOP NOT INSIDE DMCMK1), (P2DUM NOT INSIDE DMCMK1), (M0DUM NOT INSIDE DMCMK1), M0C, M0CDMP, (M0GDUM NOT INSIDE DMCMK1), DMC1, Overlap is not allowed >= 0.27um
 err1 = EXT DMC7 M0DUM_outside_DMCMK1 < 0.27 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_144_M0C {
@ DMC7 space to (AADUM NOT INSIDE DMCMK1), (AADOP NOT INSIDE DMCMK1), (P2DUM NOT INSIDE DMCMK1), (M0DUM NOT INSIDE DMCMK1), M0C, M0CDMP, (M0GDUM NOT INSIDE DMCMK1), DMC1, Overlap is not allowed >= 0.27um
 err1 = EXT DMC7 M0C < 0.27 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_144_M0CDMP {
@ DMC7 space to (AADUM NOT INSIDE DMCMK1), (AADOP NOT INSIDE DMCMK1), (P2DUM NOT INSIDE DMCMK1), (M0DUM NOT INSIDE DMCMK1), M0C, M0CDMP, (M0GDUM NOT INSIDE DMCMK1), DMC1, Overlap is not allowed >= 0.27um
 err1 = EXT DMC7 M0CDMP < 0.27 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_144_M0GDUM {
@ DMC7 space to (AADUM NOT INSIDE DMCMK1), (AADOP NOT INSIDE DMCMK1), (P2DUM NOT INSIDE DMCMK1), (M0DUM NOT INSIDE DMCMK1), M0C, M0CDMP, (M0GDUM NOT INSIDE DMCMK1), DMC1, Overlap is not allowed >= 0.27um
 err1 = EXT DMC7 M0GDUM_outside_DMCMK1 < 0.27 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_144_DMC1 {
@ DMC7 space to (AADUM NOT INSIDE DMCMK1), (AADOP NOT INSIDE DMCMK1), (P2DUM NOT INSIDE DMCMK1), (M0DUM NOT INSIDE DMCMK1), M0C, M0CDMP, (M0GDUM NOT INSIDE DMCMK1), DMC1, Overlap is not allowed >= 0.27um
 err1 = EXT DMC7 DMC1 < 0.27 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_145 {
@ DMC7 space to AR, Overlap is not allowed >= 0.16um
 err1 = EXT DMC7 AR < 0.16 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_146 {
@ DMC7 space to (ARDUM NOT INSIDE DMCMK1), (ARDOP NOT INSIDE DMCMK1), Overlap is not allowed >= 0.182um
 err1 = EXT DMC7 ARDUM_outside_DMCMK1 < 0.182 ABUT<90 SINGULAR REGION INSIDE ALSO
 err2 = EXT DMC7 ARDOP_outside_DMCMK1 < 0.182 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

DUMC_147 {
@ DMC7 space to GT, GTDMP, (GTDUM NOT INSIDE DMCMK1), (GTDOP NOT INSIDE DMCMK1), Overlap is not allowed >= 0.274um
 err1 = EXT DMC7 DMP_GT < 0.274 ABUT<90 SINGULAR REGION INSIDE ALSO
 err2 = EXT DMC7 GTDUM_outside_DMCMK1 < 0.274 ABUT<90 SINGULAR REGION INSIDE ALSO
 err3 = EXT DMC7 GTDOP_outside_DMCMK1 < 0.274 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
}

DUMC_148_GT_P96 {
@ DMC7 space to edge of GT_P96, PSUB, NW, DNW, SN, SP, (SNDUM NOT INSIDE DMCMK1), (SPDUM NOT INSIDE DMCMK1), Cut is not allowed >= 0.001um
 chk_area = (SIZE GT_P96 BY 0.001) NOT (SIZE GT_P96 BY -0.001)
 chk_area AND DMC7
}

DUMC_148_PSUB {
@ DMC7 space to edge of GT_P96, PSUB, NW, DNW, SN, SP, (SNDUM NOT INSIDE DMCMK1), (SPDUM NOT INSIDE DMCMK1), Cut is not allowed >= 0.001um
 chk_area = (SIZE PSUB BY 0.001) NOT (SIZE PSUB BY -0.001)
 chk_area AND DMC7
}

DUMC_148_NW {
@ DMC7 space to edge of GT_P96, PSUB, NW, DNW, SN, SP, (SNDUM NOT INSIDE DMCMK1), (SPDUM NOT INSIDE DMCMK1), Cut is not allowed >= 0.001um
 chk_area = (SIZE NW BY 0.001) NOT (SIZE NW BY -0.001)
 chk_area AND DMC7
}

DUMC_148_DNW {
@ DMC7 space to edge of GT_P96, PSUB, NW, DNW, SN, SP, (SNDUM NOT INSIDE DMCMK1), (SPDUM NOT INSIDE DMCMK1), Cut is not allowed >= 0.001um
 chk_area = (SIZE DNW BY 0.001) NOT (SIZE DNW BY -0.001)
 chk_area AND DMC7
}

DUMC_148_SN {
@ DMC7 space to edge of GT_P96, PSUB, NW, DNW, SN, SP, (SNDUM NOT INSIDE DMCMK1), (SPDUM NOT INSIDE DMCMK1), Cut is not allowed >= 0.001um
 chk_area = (SIZE SN BY 0.001) NOT (SIZE SN BY -0.001)
 chk_area AND DMC7
}

DUMC_148_SP {
@ DMC7 space to edge of GT_P96, PSUB, NW, DNW, SN, SP, (SNDUM NOT INSIDE DMCMK1), (SPDUM NOT INSIDE DMCMK1), Cut is not allowed >= 0.001um
 chk_area = (SIZE SP BY 0.001) NOT (SIZE SP BY -0.001)
 chk_area AND DMC7
}

DUMC_148_SNDUM {
@ DMC7 space to edge of GT_P96, PSUB, NW, DNW, SN, SP, (SNDUM NOT INSIDE DMCMK1), (SPDUM NOT INSIDE DMCMK1), Cut is not allowed >= 0.001um
 chk_area = (SIZE SNDUM_outside_DMCMK1 BY 0.001) NOT (SIZE SNDUM_outside_DMCMK1 BY -0.001)
 chk_area AND DMC7
}

DUMC_148_SPDUM {
@ DMC7 space to edge of GT_P96, PSUB, NW, DNW, SN, SP, (SNDUM NOT INSIDE DMCMK1), (SPDUM NOT INSIDE DMCMK1), Cut is not allowed >= 0.001um
 chk_area = (SIZE SPDUM_outside_DMCMK1 BY 0.001) NOT (SIZE SPDUM_outside_DMCMK1 BY -0.001)
 chk_area AND DMC7
}

DUMC_149 {
@ DMC7 space to P2, P2DMP, (P2DOP NOT INSIDE DMCMK1), Overlap is not allowed >= 0.18um
 err1 = EXT DMC7 P2 < 0.18 ABUT<90 SINGULAR REGION INSIDE ALSO
 err2 = EXT DMC7 P2DMP < 0.18 ABUT<90 SINGULAR REGION INSIDE ALSO
 err3 = EXT DMC7 P2DOP_outside_DMCMK1 < 0.18 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
}

DUMC_150 {
@ DMC7 space to (M0CDUM NOT INSIDE DMCMK1), Overlap is not allowed >= 0.3um
 err1 = EXT DMC7 M0CDUM_outside_DMCMK1 < 0.300 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_151 {
@ DMC7 space to (M0CDOP NOT INSIDE DMCMK1), Overlap is not allowed >= 0.75um
 err1 = EXT DMC7 M0CDOP_outside_DMCMK1 < 0.750 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_152 {
@ DMC7 space to INST, Overlap is not allowed >= 0.21um
 err1 = EXT DMC7 INST < 0.21 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_153 {
@ DMC7 space to DIR, DIRDMP, RESP1, Overlap is not allowed >= 0.35um
 err1 = EXT DMC7 DIR < 0.35 ABUT<90 SINGULAR REGION INSIDE ALSO
 err2 = EXT DMC7 DIRDMP < 0.35 ABUT<90 SINGULAR REGION INSIDE ALSO
 err3 = EXT DMC7 RESP1 < 0.35 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
}

DUMC_154 {
@ DMC7 space to PLRES, RESP2, LDBK, DMPNP, DSTR, VARMOS, EFUSE, Overlap is not allowed >= 0um
 err1 = DMC7 AND (OR PLRES RESP2 LDBK DMPNP DSTR VARMOS EFUSE)
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_155 {
@ DMC7 space to OCCDFH, Overlap is not allowed >= 0.32um
 err1 = EXT DMC7 OCCDFH < 0.32 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

//DUMC_156 {
//@ DMC7 space to ESD1 >= 0.189um
// err1 = EXT DMC7 ESD1 < 0.189 ABUT<90 SINGULAR REGION MEASURE ALL
// err1 NOT INSIDE SealR_NOT_BULK
//}

DUMC_157 {
@ DMC7 space to DIOMK1, DIOMK2, Overlap is not allowed >= 0.025um
 err1 = EXT DMC7 DIOMK1 < 0.025 ABUT<90 SINGULAR REGION INSIDE ALSO
 err2 = EXT DMC7 DIOMK2 < 0.025 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

DUMC_158 {
@ DMC7 space to V0, Overlap is not allowed >= 0.04um
 err1 = EXT DMC7 V0 < 0.04 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_159_HVT_N {
@ DMC7 space to edge of HVT_N, HVT_P, SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, Cut is not allowed >= 0.007um
 chk_area = (SIZE HVT_N BY 0.007) NOT (SIZE HVT_N BY -0.007)
 chk_area AND DMC7
}

DUMC_159_HVT_P {
@ DMC7 space to edge of HVT_N, HVT_P, SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, Cut is not allowed >= 0.007um
 chk_area = (SIZE HVT_P BY 0.007) NOT (SIZE HVT_P BY -0.007)
 chk_area AND DMC7
}

DUMC_159_SVT_N {
@ DMC7 space to edge of HVT_N, HVT_P, SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, Cut is not allowed >= 0.007um
 chk_area = (SIZE SVT_N BY 0.007) NOT (SIZE SVT_N BY -0.007)
 chk_area AND DMC7
}

DUMC_159_SVT_P {
@ DMC7 space to edge of HVT_N, HVT_P, SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, Cut is not allowed >= 0.007um
 chk_area = (SIZE SVT_P BY 0.007) NOT (SIZE SVT_P BY -0.007)
 chk_area AND DMC7
}

DUMC_159_LVT_N {
@ DMC7 space to edge of HVT_N, HVT_P, SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, Cut is not allowed >= 0.007um
 chk_area = (SIZE LVT_N BY 0.007) NOT (SIZE LVT_N BY -0.007)
 chk_area AND DMC7
}

DUMC_159_LVT_P {
@ DMC7 space to edge of HVT_N, HVT_P, SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, Cut is not allowed >= 0.007um
 chk_area = (SIZE LVT_P BY 0.007) NOT (SIZE LVT_P BY -0.007)
 chk_area AND DMC7
}

DUMC_159_ULVT_N {
@ DMC7 space to edge of HVT_N, HVT_P, SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, Cut is not allowed >= 0.007um
 chk_area = (SIZE ULVT_N BY 0.007) NOT (SIZE ULVT_N BY -0.007)
 chk_area AND DMC7
}

DUMC_159_ULVT_P {
@ DMC7 space to edge of HVT_N, HVT_P, SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, Cut is not allowed >= 0.007um
 chk_area = (SIZE ULVT_P BY 0.007) NOT (SIZE ULVT_P BY -0.007)
 chk_area AND DMC7
}

DUMC_159_LFN_N {
@ DMC7 space to edge of HVT_N, HVT_P, SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, Cut is not allowed >= 0.007um
 chk_area = (SIZE LFN_N BY 0.007) NOT (SIZE LFN_N BY -0.007)
 chk_area AND DMC7
}

DUMC_159_LFN_P {
@ DMC7 space to edge of HVT_N, HVT_P, SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, Cut is not allowed >= 0.007um
 chk_area = (SIZE LFN_P BY 0.007) NOT (SIZE LFN_P BY -0.007)
 chk_area AND DMC7
}

DUMC_160 {
@ Inside edge of DG space to DMC7, Outside and cut is not allowed >= 0.002um
 err1 = ENC (DMC7 AND DG) DG < 0.002 ABUT<90 SINGULAR REGION OUTSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_161_DGUD {
@ DMC7 space to edge of DGUD, DGV, Cut is not allowed >= 0.002um
 chk_area = (SIZE DGUD BY 0.002) NOT (SIZE DGUD BY -0.002)
 chk_area AND DMC7
}

DUMC_161_DGV {
@ DMC7 space to edge of DGUD, DGV, Cut is not allowed >= 0.002um
 chk_area = (SIZE DGV BY 0.002) NOT (SIZE DGV BY -0.002)
 chk_area AND DMC7
}

DUMC_162_DMC2 {
@ DMC7 space to DMC2, DMC3, DMC4, DMC5, DMC6, Overlap is not allowed >= 0.192um
 err1 = EXT DMC7 DMC2 < 0.192 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_162_DMC3 {
@ DMC7 space to DMC2, DMC3, DMC4, DMC5, DMC6, Overlap is not allowed >= 0.192um
 err1 = EXT DMC7 DMC3 < 0.192 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_162_DMC4 {
@ DMC7 space to DMC2, DMC3, DMC4, DMC5, DMC6, Overlap is not allowed >= 0.192um
 err1 = EXT DMC7 DMC4 < 0.192 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_162_DMC5 {
@ DMC7 space to DMC2, DMC3, DMC4, DMC5, DMC6, Overlap is not allowed >= 0.192um
 err1 = EXT DMC7 DMC5 < 0.192 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_162_DMC6 {
@ DMC7 space to DMC2, DMC3, DMC4, DMC5, DMC6, Overlap is not allowed >= 0.192um
 err1 = EXT DMC7 DMC6 < 0.192 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_163_DMC2 {
@ DMC7 horizontal space to DMC2, DMC3, DMC4, DMC5, DMC6, Overlap is not allowed >= 0.2um
 err1 = EXT (ANGLE DMC7 == 90) DMC2 < 0.2 ABUT<90 OPPOSITE REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_163_DMC3 {
@ DMC7 horizontal space to DMC2, DMC3, DMC4, DMC5, DMC6, Overlap is not allowed >= 0.2um
 err1 = EXT (ANGLE DMC7 == 90) DMC3 < 0.2 ABUT<90 OPPOSITE REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_163_DMC4 {
@ DMC7 horizontal space to DMC2, DMC3, DMC4, DMC5, DMC6, Overlap is not allowed >= 0.2um
 err1 = EXT (ANGLE DMC7 == 90) DMC4 < 0.2 ABUT<90 OPPOSITE REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_163_DMC5 {
@ DMC7 horizontal space to DMC2, DMC3, DMC4, DMC5, DMC6, Overlap is not allowed >= 0.2um
 err1 = EXT (ANGLE DMC7 == 90) DMC5 < 0.2 ABUT<90 OPPOSITE REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_163_DMC6 {
@ DMC7 horizontal space to DMC2, DMC3, DMC4, DMC5, DMC6, Overlap is not allowed >= 0.2um
 err1 = EXT (ANGLE DMC7 == 90) DMC6 < 0.2 ABUT<90 OPPOSITE REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

#IFDEF CHIPB_RULES_CHECK YES
DUMC_164 {
@ Inside edge of CHIPB space to DMC8, Outside and cut is not allowed >= 0.45um
 err1 = ENC DMC8 CHIPB < 0.45 ABUT<90 SINGULAR REGION OUTSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
#ENDIF

DUMC_165 {
@ DMC8 space to DUMBA, AA, AADMP, (AADOP NOT INSIDE DMCMK1), PPAA, Overlap is not allowed >= 0.067um
 err1 = EXT DMC8 DUMBA < 0.067 ABUT<90 SINGULAR REGION INSIDE ALSO
 err2 = EXT DMC8 DMP_AA < 0.067 ABUT<90 SINGULAR REGION INSIDE ALSO
 err3 = EXT DMC8 AADOP_outside_DMCMK1 < 0.067 ABUT<90 SINGULAR REGION INSIDE ALSO
 err4 = EXT DMC8 PPAA < 0.067 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
 err4 NOT INSIDE SealR_NOT_BULK
}

DUMC_166 {
@ DMC8 space to DUMBP, Overlap is not allowed >= 0.144um
 err1 = EXT DMC8 DUMBP < 0.144 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_167 {
@ DMC8 space to NPAA_EXT, Overlap is not allowed >= 0.267um
 err1 = EXT DMC8 NPAA_EXT < 0.267 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_168 {
@ DMC8 space to (AADUM NOT INSIDE DMCMK1), (P2DUM NOT INSIDE DMCMK1), (M0DUM NOT INSIDE DMCMK1), (M0GDUM NOT INSIDE DMCMK1), Overlap is not allowed >= 0.27um
 err1 = EXT DMC8 AADUM_outside_DMCMK1 < 0.27 ABUT<90 SINGULAR REGION INSIDE ALSO
 err2 = EXT DMC8 P2DUM_outside_DMCMK1 < 0.27 ABUT<90 SINGULAR REGION INSIDE ALSO
 err3 = EXT DMC8 M0DUM_outside_DMCMK1 < 0.27 ABUT<90 SINGULAR REGION INSIDE ALSO
 err4 = EXT DMC8 M0GDUM_outside_DMCMK1 < 0.27 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
 err4 NOT INSIDE SealR_NOT_BULK
}

DUMC_169 {
@ DMC8 space to GT, GTDMP, (GTDUM NOT INSIDE DMCMK1), (GTDOP NOT INSIDE DMCMK1), Overlap is not allowed >= 0.344um
 err1 = EXT DMC8 DMP_GT < 0.344 ABUT<90 SINGULAR REGION INSIDE ALSO
 err2 = EXT DMC8 GTDUM_outside_DMCMK1 < 0.344 ABUT<90 SINGULAR REGION INSIDE ALSO
 err3 = EXT DMC8 GTDOP_outside_DMCMK1 < 0.344 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
}

DUMC_170 {
@ DMC8 space to edge of GT_P96, Cut is not allowed >= 0.04um
 chk_area = (SIZE GT_P96 BY 0.04) NOT (SIZE GT_P96 BY -0.04)
 chk_area AND DMC8
}

DUMC_171 {
@ DMC8 space to P2, P2DMP, (P2DOP NOT INSIDE DMCMK1), Overlap is not allowed >= 0.18um
 err1 = EXT DMC8 P2 < 0.18 ABUT<90 SINGULAR REGION INSIDE ALSO
 err2 = EXT DMC8 P2DMP < 0.18 ABUT<90 SINGULAR REGION INSIDE ALSO
 err3 = EXT DMC8 P2DOP_outside_DMCMK1 < 0.18 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
}

DUMC_172 {
@ DMC8 space to M0, M0DMP, (M0DOP NOT INSIDE DMCMK1), Overlap is not allowed >= 0.047um
 err1 = EXT DMC8 DMP_M0 < 0.047 ABUT<90 SINGULAR REGION INSIDE ALSO
 err2 = EXT DMC8 M0DOP_outside_DMCMK1 < 0.047 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

DUMC_173 {
@ DMC8 space to M0G, M0GDMP, (M0GDOP NOT INSIDE DMCMK1), Overlap is not allowed >= 0.05um
 err1 = EXT DMC8 DMP_M0G < 0.05 ABUT<90 SINGULAR REGION INSIDE ALSO
 err2 = EXT DMC8 M0GDOP_outside_DMCMK1 < 0.05 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

DUMC_174 {
@ DMC8 space to INST, Overlap is not allowed >= 0.118um
 err1 = EXT DMC8 INST < 0.118 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_175_RESNW {
@ DMC8 space to edge of RESNW, DG, DGUD, DGV, Cut is not allowed >= 0.001um
 chk_area = (SIZE RESNW BY 0.001) NOT (SIZE RESNW BY -0.001)
 chk_area AND DMC8
}

DUMC_175_DG {
@ DMC8 space to edge of RESNW, DG, DGUD, DGV, Cut is not allowed >= 0.001um
 chk_area = (SIZE DG BY 0.001) NOT (SIZE DG BY -0.001)
 chk_area AND DMC8
}

DUMC_175_DGUD {
@ DMC8 space to edge of RESNW, DG, DGUD, DGV, Cut is not allowed >= 0.001um
 chk_area = (SIZE DGUD BY 0.001) NOT (SIZE DGUD BY -0.001)
 chk_area AND DMC8
}

DUMC_175_DGV {
@ DMC8 space to edge of RESNW, DG, DGUD, DGV, Cut is not allowed >= 0.001um
 chk_area = (SIZE DGV BY 0.001) NOT (SIZE DGV BY -0.001)
 chk_area AND DMC8
}

DUMC_176 {
@ DMC8 space to DIR, DIRDMP, RESP1, Overlap is not allowed >= 0.07um
 err1 = EXT DMC8 DIR < 0.07 ABUT<90 SINGULAR REGION INSIDE ALSO
 err2 = EXT DMC8 DIRDMP < 0.07 ABUT<90 SINGULAR REGION INSIDE ALSO
 err3 = EXT DMC8 RESP1 < 0.07 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
}

DUMC_177 {
@ DMC8 space to PLRES, RESP2, LDBK, DMPNP, DSTR, VARMOS, EFUSE, V0, Overlap is not allowed >= 0um
 err1 = DMC8 AND (OR PLRES RESP2 LDBK DMPNP DSTR VARMOS EFUSE V0)
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_178 {
@ DMC8 space to INDMY, Overlap is not allowed >= 0.2um
 err1 = EXT DMC8 INDMY < 0.200 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_179 {
@ DMC8 space to OCCDFH, Overlap is not allowed >= 0.32um
 err1 = EXT DMC8 OCCDFH < 0.32 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

//DUMC_180 {
//@ DMC8 space to ESD1 >= 0.189um
// err1 = EXT DMC8 ESD1 < 0.189 ABUT<90 SINGULAR REGION MEASURE ALL
// err1 NOT INSIDE SealR_NOT_BULK
//}

DUMC_181 {
@ DMC8 space to DIOMK1, DIOMK2, Overlap is not allowed >= 0.059um
 err1 = EXT DMC8 DIOMK1 < 0.059 ABUT<90 SINGULAR REGION INSIDE ALSO
 err2 = EXT DMC8 DIOMK2 < 0.059 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

DUMC_182_DMC1 {
@ DMC8 space to DMC1, DMC2, DMC3, DMC4, DMC5, DMC6, DMC7, Overlap is not allowed >= 0.274um
 err1 = EXT DMC8 DMC1 < 0.274 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_182_DMC2 {
@ DMC8 space to DMC1, DMC2, DMC3, DMC4, DMC5, DMC6, DMC7, Overlap is not allowed >= 0.274um
 err1 = EXT DMC8 DMC2 < 0.274 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_182_DMC3 {
@ DMC8 space to DMC1, DMC2, DMC3, DMC4, DMC5, DMC6, DMC7, Overlap is not allowed >= 0.274um
 err1 = EXT DMC8 DMC3 < 0.274 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_182_DMC4 {
@ DMC8 space to DMC1, DMC2, DMC3, DMC4, DMC5, DMC6, DMC7, Overlap is not allowed >= 0.274um
 err1 = EXT DMC8 DMC4 < 0.274 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_182_DMC5 {
@ DMC8 space to DMC1, DMC2, DMC3, DMC4, DMC5, DMC6, DMC7, Overlap is not allowed >= 0.274um
 err1 = EXT DMC8 DMC5 < 0.274 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_182_DMC6 {
@ DMC8 space to DMC1, DMC2, DMC3, DMC4, DMC5, DMC6, DMC7, Overlap is not allowed >= 0.274um
 err1 = EXT DMC8 DMC6 < 0.274 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_182_DMC7 {
@ DMC8 space to DMC1, DMC2, DMC3, DMC4, DMC5, DMC6, DMC7, Overlap is not allowed >= 0.274um
 err1 = EXT DMC8 DMC7 < 0.274 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_183_PSUB {
@ DMC8 space to edge of PSUB, NW, DNW, SN, SP, (SNDUM NOT INSIDE DMCMK1), (SPDUM NOT INSIDE DMCMK1), Cut is not allowed >= 0.048um
 chk_area = (SIZE NW BY 0.048) NOT (SIZE NW BY -0.048)
 chk_area AND DMC8
}

DUMC_183_NW {
@ DMC8 space to edge of PSUB, NW, DNW, SN, SP, (SNDUM NOT INSIDE DMCMK1), (SPDUM NOT INSIDE DMCMK1), Cut is not allowed >= 0.048um
 chk_area = (SIZE NW BY 0.048) NOT (SIZE NW BY -0.048)
 chk_area AND DMC8
}

DUMC_183_DNW {
@ DMC8 space to edge of PSUB, NW, DNW, SN, SP, (SNDUM NOT INSIDE DMCMK1), (SPDUM NOT INSIDE DMCMK1), Cut is not allowed >= 0.048um
 chk_area = (SIZE DNW BY 0.048) NOT (SIZE DNW BY -0.048)
 chk_area AND DMC8
}

DUMC_183_SN {
@ DMC8 space to edge of PSUB, NW, DNW, SN, SP, (SNDUM NOT INSIDE DMCMK1), (SPDUM NOT INSIDE DMCMK1), Cut is not allowed >= 0.048um
 chk_area = (SIZE SN BY 0.048) NOT (SIZE SN BY -0.048)
 chk_area AND DMC8
}

DUMC_183_SP {
@ DMC8 space to edge of PSUB, NW, DNW, SN, SP, (SNDUM NOT INSIDE DMCMK1), (SPDUM NOT INSIDE DMCMK1), Cut is not allowed >= 0.048um
 chk_area = (SIZE SP BY 0.048) NOT (SIZE SP BY -0.048)
 chk_area AND DMC8
}

DUMC_183_SNDUM {
@ DMC8 space to edge of PSUB, NW, DNW, SN, SP, (SNDUM NOT INSIDE DMCMK1), (SPDUM NOT INSIDE DMCMK1), Cut is not allowed >= 0.048um
 chk_area = (SIZE SNDUM_outside_DMCMK1 BY 0.048) NOT (SIZE SNDUM_outside_DMCMK1 BY -0.048)
 chk_area AND DMC8
}

DUMC_183_SPDUM {
@ DMC8 space to edge of PSUB, NW, DNW, SN, SP, (SNDUM NOT INSIDE DMCMK1), (SPDUM NOT INSIDE DMCMK1), Cut is not allowed >= 0.048um
 chk_area = (SIZE SPDUM_outside_DMCMK1 BY 0.048) NOT (SIZE SPDUM_outside_DMCMK1 BY -0.048)
 chk_area AND DMC8
}

DUMC_184_HVT_N {
@ DMC8 space to edge of HVT_N, HVT_P, SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, Cut is not allowed >= 0.059um
 chk_area = (SIZE HVT_N BY 0.059) NOT (SIZE HVT_N BY -0.059)
 chk_area AND DMC8
}

DUMC_184_HVT_P {
@ DMC8 space to edge of HVT_N, HVT_P, SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, Cut is not allowed >= 0.059um
 chk_area = (SIZE HVT_P BY 0.059) NOT (SIZE HVT_P BY -0.059)
 chk_area AND DMC8
}

DUMC_184_SVT_N {
@ DMC8 space to edge of HVT_N, HVT_P, SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, Cut is not allowed >= 0.059um
 chk_area = (SIZE SVT_N BY 0.059) NOT (SIZE SVT_N BY -0.059)
 chk_area AND DMC8
}

DUMC_184_SVT_P {
@ DMC8 space to edge of HVT_N, HVT_P, SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, Cut is not allowed >= 0.059um
 chk_area = (SIZE SVT_P BY 0.059) NOT (SIZE SVT_P BY -0.059)
 chk_area AND DMC8
}

DUMC_184_LVT_N {
@ DMC8 space to edge of HVT_N, HVT_P, SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, Cut is not allowed >= 0.059um
 chk_area = (SIZE LVT_N BY 0.059) NOT (SIZE LVT_N BY -0.059)
 chk_area AND DMC8
}

DUMC_184_LVT_P {
@ DMC8 space to edge of HVT_N, HVT_P, SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, Cut is not allowed >= 0.059um
 chk_area = (SIZE LVT_P BY 0.059) NOT (SIZE LVT_P BY -0.059)
 chk_area AND DMC8
}

DUMC_184_ULVT_N {
@ DMC8 space to edge of HVT_N, HVT_P, SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, Cut is not allowed >= 0.059um
 chk_area = (SIZE ULVT_N BY 0.059) NOT (SIZE ULVT_N BY -0.059)
 chk_area AND DMC8
}

DUMC_184_ULVT_P {
@ DMC8 space to edge of HVT_N, HVT_P, SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, Cut is not allowed >= 0.059um
 chk_area = (SIZE ULVT_P BY 0.059) NOT (SIZE ULVT_P BY -0.059)
 chk_area AND DMC8
}

DUMC_184_LFN_N {
@ DMC8 space to edge of HVT_N, HVT_P, SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, Cut is not allowed >= 0.059um
 chk_area = (SIZE LFN_N BY 0.059) NOT (SIZE LFN_N BY -0.059)
 chk_area AND DMC8
}

DUMC_184_LFN_P {
@ DMC8 space to edge of HVT_N, HVT_P, SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, Cut is not allowed >= 0.059um
 chk_area = (SIZE LFN_P BY 0.059) NOT (SIZE LFN_P BY -0.059)
 chk_area AND DMC8
}

DUMC_185 {
@ DMC8 space to MARKG, MARKS, NODMF, Overlap is not allowed >= 0.4um
 err1 = EXT DMC8 MARKG < 0.400 ABUT<90 SINGULAR REGION INSIDE ALSO
 err2 = EXT DMC8 MARKS < 0.400 ABUT<90 SINGULAR REGION INSIDE ALSO
 err3 = EXT DMC8 NODMF < 0.400 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
}

#IFDEF CHIPB_RULES_CHECK YES
DUMC_186 {
@ Inside edge of CHIPB space to DMC9, Outside and cut is not allowed >= 0.45um
 err1 = ENC DMC9 CHIPB < 0.45 ABUT<90 SINGULAR REGION OUTSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
#ENDIF

DUMC_187 {
@ DMC9 space to DUMBA, AA, AADMP, (AADOP NOT INSIDE DMCMK1), PPAA, Overlap is not allowed >= 0.067um
 err1 = EXT DMC9 DUMBA < 0.067 ABUT<90 SINGULAR REGION INSIDE ALSO
 err2 = EXT DMC9 DMP_AA < 0.067 ABUT<90 SINGULAR REGION INSIDE ALSO
 err3 = EXT DMC9 AADOP_outside_DMCMK1 < 0.067 ABUT<90 SINGULAR REGION INSIDE ALSO
 err4 = EXT DMC9 PPAA < 0.067 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
 err4 NOT INSIDE SealR_NOT_BULK
}

DUMC_188 {
@ DMC9 space to DUMBP, Overlap is not allowed >= 0.144um
 err1 = EXT DMC9 DUMBP < 0.144 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_189 {
@ DMC9 space to NPAA_EXT, Overlap is not allowed >= 0.267um
 err1 = EXT DMC9 NPAA_EXT < 0.267 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_190 {
@ DMC9 space to (AADUM NOT INSIDE DMCMK1), (P2DUM NOT INSIDE DMCMK1), (M0DUM NOT INSIDE DMCMK1), (M0GDUM NOT INSIDE DMCMK1), Overlap is not allowed >= 0.27um
 err1 = EXT DMC9 AADUM_outside_DMCMK1 < 0.27 ABUT<90 SINGULAR REGION INSIDE ALSO
 err2 = EXT DMC9 P2DUM_outside_DMCMK1 < 0.27 ABUT<90 SINGULAR REGION INSIDE ALSO
 err3 = EXT DMC9 M0DUM_outside_DMCMK1 < 0.27 ABUT<90 SINGULAR REGION INSIDE ALSO
 err4 = EXT DMC9 M0GDUM_outside_DMCMK1 < 0.27 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
 err4 NOT INSIDE SealR_NOT_BULK
}

DUMC_191 {
@ DMC9 space to GT, GTDMP, (GTDUM NOT INSIDE DMCMK1), (GTDOP NOT INSIDE DMCMK1), Overlap is not allowed >= 0.344um
 err1 = EXT DMC9 DMP_GT < 0.344 ABUT<90 SINGULAR REGION INSIDE ALSO
 err2 = EXT DMC9 GTDUM_outside_DMCMK1 < 0.344 ABUT<90 SINGULAR REGION INSIDE ALSO
 err3 = EXT DMC9 GTDOP_outside_DMCMK1 < 0.344 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
}

DUMC_192 {
@ DMC9 space to edge of GT_P96, Cut is not allowed >= 0.04um
 chk_area = (SIZE GT_P96 BY 0.04) NOT (SIZE GT_P96 BY -0.04)
 chk_area AND DMC9
}

DUMC_193 {
@ DMC9 space to P2, P2DMP, (P2DOP NOT INSIDE DMCMK1), Overlap is not allowed >= 0.18um
 err1 = EXT DMC9 P2 < 0.18 ABUT<90 SINGULAR REGION INSIDE ALSO
 err2 = EXT DMC9 P2DMP < 0.18 ABUT<90 SINGULAR REGION INSIDE ALSO
 err3 = EXT DMC9 P2DOP_outside_DMCMK1 < 0.18 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
}

DUMC_194 {
@ DMC9 space to M0, M0DMP, (M0DOP NOT INSIDE DMCMK1), Overlap is not allowed >= 0.047um
 err1 = EXT DMC9 DMP_M0 < 0.047 ABUT<90 SINGULAR REGION INSIDE ALSO
 err2 = EXT DMC9 M0DOP_outside_DMCMK1 < 0.047 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

DUMC_195 {
@ DMC9 space to M0G, M0GDMP, (M0GDOP NOT INSIDE DMCMK1), Overlap is not allowed >= 0.05um
 err1 = EXT DMC9 DMP_M0G < 0.05 ABUT<90 SINGULAR REGION INSIDE ALSO
 err2 = EXT DMC9 M0GDOP_outside_DMCMK1 < 0.05 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

DUMC_196 {
@ DMC9 space to INST, Overlap is not allowed >= 0.118um
 err1 = EXT DMC9 INST < 0.118 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_197_RESNW {
@ DMC9 space to edge of RESNW, DG, DGUD, DGV, Cut is not allowed >= 0.001um
 chk_area = (SIZE RESNW BY 0.001) NOT (SIZE RESNW BY -0.001)
 chk_area AND DMC9
}

DUMC_197_DG {
@ DMC9 space to edge of RESNW, DG, DGUD, DGV, Cut is not allowed >= 0.001um
 chk_area = (SIZE DG BY 0.001) NOT (SIZE DG BY -0.001)
 chk_area AND DMC9
}

DUMC_197_DGUD {
@ DMC9 space to edge of RESNW, DG, DGUD, DGV, Cut is not allowed >= 0.001um
 chk_area = (SIZE DGUD BY 0.001) NOT (SIZE DGUD BY -0.001)
 chk_area AND DMC9
}

DUMC_197_DGV {
@ DMC9 space to edge of RESNW, DG, DGUD, DGV, Cut is not allowed >= 0.001um
 chk_area = (SIZE DGV BY 0.001) NOT (SIZE DGV BY -0.001)
 chk_area AND DMC9
}

DUMC_198 {
@ DMC9 space to DIR, DIRDMP, RESP1, Overlap is not allowed >= 0.07um
 err1 = EXT DMC9 DIR < 0.07 ABUT<90 SINGULAR REGION INSIDE ALSO
 err2 = EXT DMC9 DIRDMP < 0.07 ABUT<90 SINGULAR REGION INSIDE ALSO
 err3 = EXT DMC9 RESP1 < 0.07 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
}

DUMC_199 {
@ DMC9 space to PLRES, RESP2, LDBK, DMPNP, DSTR, VARMOS, EFUSE, V0, Overlap is not allowed >= 0um
 err1 = DMC9 AND (OR PLRES RESP2 LDBK DMPNP DSTR VARMOS EFUSE V0)
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_200 {
@ DMC9 space to INDMY, Overlap is not allowed >= 0.2um
 err1 = EXT DMC9 INDMY < 0.200 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_201 {
@ DMC9 space to OCCDFH, Overlap is not allowed >= 0.32um
 err1 = EXT DMC9 OCCDFH < 0.32 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

//DUMC_202 {
//@ DMC9 space to ESD1 >= 0.189um
// err1 = EXT DMC9 ESD1 < 0.189 ABUT<90 SINGULAR REGION MEASURE ALL
// err1 NOT INSIDE SealR_NOT_BULK
//}

DUMC_203 {
@ DMC9 space to DIOMK1, DIOMK2, Overlap is not allowed >= 0.059um
 err1 = EXT DMC9 DIOMK1 < 0.059 ABUT<90 SINGULAR REGION INSIDE ALSO
 err2 = EXT DMC9 DIOMK2 < 0.059 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

DUMC_204_DMC1 {
@ DMC9 space to DMC1, DMC2, DMC3, DMC4, DMC5, DMC6, DMC7, Overlap is not allowed >= 0.274um
 err1 = EXT DMC9 DMC1 < 0.274 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_204_DMC2 {
@ DMC9 space to DMC1, DMC2, DMC3, DMC4, DMC5, DMC6, DMC7, Overlap is not allowed >= 0.274um
 err1 = EXT DMC9 DMC2 < 0.274 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_204_DMC3 {
@ DMC9 space to DMC1, DMC2, DMC3, DMC4, DMC5, DMC6, DMC7, Overlap is not allowed >= 0.274um
 err1 = EXT DMC9 DMC3 < 0.274 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_204_DMC4 {
@ DMC9 space to DMC1, DMC2, DMC3, DMC4, DMC5, DMC6, DMC7, Overlap is not allowed >= 0.274um
 err1 = EXT DMC9 DMC4 < 0.274 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_204_DMC5 {
@ DMC9 space to DMC1, DMC2, DMC3, DMC4, DMC5, DMC6, DMC7, Overlap is not allowed >= 0.274um
 err1 = EXT DMC9 DMC5 < 0.274 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_204_DMC6 {
@ DMC9 space to DMC1, DMC2, DMC3, DMC4, DMC5, DMC6, DMC7, Overlap is not allowed >= 0.274um
 err1 = EXT DMC9 DMC6 < 0.274 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_204_DMC7 {
@ DMC9 space to DMC1, DMC2, DMC3, DMC4, DMC5, DMC6, DMC7, Overlap is not allowed >= 0.274um
 err1 = EXT DMC9 DMC7 < 0.274 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_205_PSUB {
@ DMC9 space to edge of PSUB, NW, DNW, SN, SP, (SNDUM NOT INSIDE DMCMK1), (SPDUM NOT INSIDE DMCMK1), Cut is not allowed >= 0.048um
 chk_area = (SIZE PSUB BY 0.048) NOT (SIZE PSUB BY -0.048)
 chk_area AND DMC9
}

DUMC_205_NW {
@ DMC9 space to edge of PSUB, NW, DNW, SN, SP, (SNDUM NOT INSIDE DMCMK1), (SPDUM NOT INSIDE DMCMK1), Cut is not allowed >= 0.048um
 chk_area = (SIZE NW BY 0.048) NOT (SIZE NW BY -0.048)
 chk_area AND DMC9
}

DUMC_205_DNW {
@ DMC9 space to edge of PSUB, NW, DNW, SN, SP, (SNDUM NOT INSIDE DMCMK1), (SPDUM NOT INSIDE DMCMK1), Cut is not allowed >= 0.048um
 chk_area = (SIZE DNW BY 0.048) NOT (SIZE DNW BY -0.048)
 chk_area AND DMC9
}

DUMC_205_SN {
@ DMC9 space to edge of PSUB, NW, DNW, SN, SP, (SNDUM NOT INSIDE DMCMK1), (SPDUM NOT INSIDE DMCMK1), Cut is not allowed >= 0.048um
 chk_area = (SIZE SN BY 0.048) NOT (SIZE SN BY -0.048)
 chk_area AND DMC9
}

DUMC_205_SP {
@ DMC9 space to edge of PSUB, NW, DNW, SN, SP, (SNDUM NOT INSIDE DMCMK1), (SPDUM NOT INSIDE DMCMK1), Cut is not allowed >= 0.048um
 chk_area = (SIZE SP BY 0.048) NOT (SIZE SP BY -0.048)
 chk_area AND DMC9
}

DUMC_205_SNDUM {
@ DMC9 space to edge of PSUB, NW, DNW, SN, SP, (SNDUM NOT INSIDE DMCMK1), (SPDUM NOT INSIDE DMCMK1), Cut is not allowed >= 0.048um
 chk_area = (SIZE SNDUM_outside_DMCMK1 BY 0.048) NOT (SIZE SNDUM_outside_DMCMK1 BY -0.048)
 chk_area AND DMC9
}

DUMC_205_SPDUM {
@ DMC9 space to edge of PSUB, NW, DNW, SN, SP, (SNDUM NOT INSIDE DMCMK1), (SPDUM NOT INSIDE DMCMK1), Cut is not allowed >= 0.048um
 chk_area = (SIZE SPDUM_outside_DMCMK1 BY 0.048) NOT (SIZE SPDUM_outside_DMCMK1 BY -0.048)
 chk_area AND DMC9
}

DUMC_206_HVT_N {
@ DMC9 space to edge of HVT_N, HVT_P, SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, Cut is not allowed >= 0.059um
 chk_area = (SIZE HVT_N BY 0.059) NOT (SIZE HVT_N BY -0.059)
 chk_area AND DMC9
}

DUMC_206_HVT_P {
@ DMC9 space to edge of HVT_N, HVT_P, SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, Cut is not allowed >= 0.059um
 chk_area = (SIZE HVT_P BY 0.059) NOT (SIZE HVT_P BY -0.059)
 chk_area AND DMC9
}

DUMC_206_SVT_N {
@ DMC9 space to edge of HVT_N, HVT_P, SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, Cut is not allowed >= 0.059um
 chk_area = (SIZE SVT_N BY 0.059) NOT (SIZE SVT_N BY -0.059)
 chk_area AND DMC9
}

DUMC_206_SVT_P {
@ DMC9 space to edge of HVT_N, HVT_P, SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, Cut is not allowed >= 0.059um
 chk_area = (SIZE SVT_P BY 0.059) NOT (SIZE SVT_P BY -0.059)
 chk_area AND DMC9
}

DUMC_206_LVT_N {
@ DMC9 space to edge of HVT_N, HVT_P, SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, Cut is not allowed >= 0.059um
 chk_area = (SIZE LVT_N BY 0.059) NOT (SIZE LVT_N BY -0.059)
 chk_area AND DMC9
}

DUMC_206_LVT_P {
@ DMC9 space to edge of HVT_N, HVT_P, SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, Cut is not allowed >= 0.059um
 chk_area = (SIZE LVT_P BY 0.059) NOT (SIZE LVT_P BY -0.059)
 chk_area AND DMC9
}

DUMC_206_ULVT_N {
@ DMC9 space to edge of HVT_N, HVT_P, SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, Cut is not allowed >= 0.059um
 chk_area = (SIZE ULVT_N BY 0.059) NOT (SIZE ULVT_N BY -0.059)
 chk_area AND DMC9
}

DUMC_206_ULVT_P {
@ DMC9 space to edge of HVT_N, HVT_P, SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, Cut is not allowed >= 0.059um
 chk_area = (SIZE ULVT_P BY 0.059) NOT (SIZE ULVT_P BY -0.059)
 chk_area AND DMC9
}

DUMC_206_LFN_N {
@ DMC9 space to edge of HVT_N, HVT_P, SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, Cut is not allowed >= 0.059um
 chk_area = (SIZE LFN_N BY 0.059) NOT (SIZE LFN_N BY -0.059)
 chk_area AND DMC9
}

DUMC_206_LFN_P {
@ DMC9 space to edge of HVT_N, HVT_P, SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, Cut is not allowed >= 0.059um
 chk_area = (SIZE LFN_P BY 0.059) NOT (SIZE LFN_P BY -0.059)
 chk_area AND DMC9
}

DUMC_207 {
@ DMC9 space to MARKG, MARKS, NODMF, Overlap is not allowed >= 0.4um
 err1 = EXT DMC9 MARKG < 0.400 ABUT<90 SINGULAR REGION INSIDE ALSO
 err2 = EXT DMC9 MARKS < 0.400 ABUT<90 SINGULAR REGION INSIDE ALSO
 err3 = EXT DMC9 NODMF < 0.400 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
}

DUMC_208 {
@ DMC9 space to DMC8, Overlap is not allowed >= 0.35um
 err1 = EXT DMC9 DMC8 < 0.35 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

#IFDEF CHIPB_RULES_CHECK YES
DUMC_209 {
@ Inside edge of CHIPB space to DMC10, Outside and cut is not allowed >= 0.75um
 err1 = ENC DMC10 CHIPB < 0.75 ABUT<90 SINGULAR REGION OUTSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
#ENDIF

DUMC_210 {
@ DMC10 space to M0CDUB, Overlap is not allowed >= 0.067um
 err1 = EXT DMC10 M0CDUB < 0.067 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_211_GT_P96 {
@ DMC10 space to edge of GT_P96, HVT_N, HVT_P, SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, Cut is not allowed >= 0.001um
 chk_area = (SIZE GT_P96 BY 0.001) NOT (SIZE GT_P96 BY -0.001)
 chk_area AND DMC10
}

DUMC_211_HVT_N {
@ DMC10 space to edge of GT_P96, HVT_N, HVT_P, SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, Cut is not allowed >= 0.001um
 chk_area = (SIZE HVT_N BY 0.001) NOT (SIZE HVT_N BY -0.001)
 chk_area AND DMC10
}

DUMC_211_HVT_P {
@ DMC10 space to edge of GT_P96, HVT_N, HVT_P, SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, Cut is not allowed >= 0.001um
 chk_area = (SIZE HVT_P BY 0.001) NOT (SIZE HVT_P BY -0.001)
 chk_area AND DMC10
}

DUMC_211_SVT_N {
@ DMC10 space to edge of GT_P96, HVT_N, HVT_P, SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, Cut is not allowed >= 0.001um
 chk_area = (SIZE SVT_N BY 0.001) NOT (SIZE SVT_N BY -0.001)
 chk_area AND DMC10
}

DUMC_211_SVT_P {
@ DMC10 space to edge of GT_P96, HVT_N, HVT_P, SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, Cut is not allowed >= 0.001um
 chk_area = (SIZE SVT_P BY 0.001) NOT (SIZE SVT_P BY -0.001)
 chk_area AND DMC10
}

DUMC_211_LVT_N {
@ DMC10 space to edge of GT_P96, HVT_N, HVT_P, SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, Cut is not allowed >= 0.001um
 chk_area = (SIZE LVT_N BY 0.001) NOT (SIZE LVT_N BY -0.001)
 chk_area AND DMC10
}

DUMC_211_LVT_P {
@ DMC10 space to edge of GT_P96, HVT_N, HVT_P, SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, Cut is not allowed >= 0.001um
 chk_area = (SIZE LVT_P BY 0.001) NOT (SIZE LVT_P BY -0.001)
 chk_area AND DMC10
}

DUMC_211_ULVT_N {
@ DMC10 space to edge of GT_P96, HVT_N, HVT_P, SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, Cut is not allowed >= 0.001um
 chk_area = (SIZE ULVT_N BY 0.001) NOT (SIZE ULVT_N BY -0.001)
 chk_area AND DMC10
}

DUMC_211_ULVT_P {
@ DMC10 space to edge of GT_P96, HVT_N, HVT_P, SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, Cut is not allowed >= 0.001um
 chk_area = (SIZE ULVT_P BY 0.001) NOT (SIZE ULVT_P BY -0.001)
 chk_area AND DMC10
}

DUMC_211_LFN_N {
@ DMC10 space to edge of GT_P96, HVT_N, HVT_P, SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, Cut is not allowed >= 0.001um
 chk_area = (SIZE LFN_N BY 0.001) NOT (SIZE LFN_N BY -0.001)
 chk_area AND DMC10
}

DUMC_211_LFN_P {
@ DMC10 space to edge of GT_P96, HVT_N, HVT_P, SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, Cut is not allowed >= 0.001um
 chk_area = (SIZE LFN_P BY 0.001) NOT (SIZE LFN_P BY -0.001)
 chk_area AND DMC10
}

DUMC_212_M0 {
@ DMC10 space to M0, M0DMP, (M0DUM NOT INSIDE DMCMK1), (M0DOP NOT INSIDE DMCMK1), M0G, M0GDMP, (M0GDUM NOT INSIDE DMCMK1), (M0GDOP NOT INSIDE DMCMK1), Overlap is not allowed >= 0.15um
 err1 = EXT DMC10 M0 < 0.15 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_212_M0DMP {
@ DMC10 space to M0, M0DMP, (M0DUM NOT INSIDE DMCMK1), (M0DOP NOT INSIDE DMCMK1), M0G, M0GDMP, (M0GDUM NOT INSIDE DMCMK1), (M0GDOP NOT INSIDE DMCMK1), Overlap is not allowed >= 0.15um
 err1 = EXT DMC10 M0DMP < 0.15 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_212_M0DUM {
@ DMC10 space to M0, M0DMP, (M0DUM NOT INSIDE DMCMK1), (M0DOP NOT INSIDE DMCMK1), M0G, M0GDMP, (M0GDUM NOT INSIDE DMCMK1), (M0GDOP NOT INSIDE DMCMK1), Overlap is not allowed >= 0.15um
 err1 = EXT DMC10 M0DUM_outside_DMCMK1 < 0.15 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_212_M0DOP {
@ DMC10 space to M0, M0DMP, (M0DUM NOT INSIDE DMCMK1), (M0DOP NOT INSIDE DMCMK1), M0G, M0GDMP, (M0GDUM NOT INSIDE DMCMK1), (M0GDOP NOT INSIDE DMCMK1), Overlap is not allowed >= 0.15um
 err1 = EXT DMC10 M0DOP_outside_DMCMK1 < 0.15 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_212_M0G {
@ DMC10 space to M0, M0DMP, (M0DUM NOT INSIDE DMCMK1), (M0DOP NOT INSIDE DMCMK1), M0G, M0GDMP, (M0GDUM NOT INSIDE DMCMK1), (M0GDOP NOT INSIDE DMCMK1), Overlap is not allowed >= 0.15um
 err1 = EXT DMC10 M0G < 0.15 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_212_M0GDMP {
@ DMC10 space to M0, M0DMP, (M0DUM NOT INSIDE DMCMK1), (M0DOP NOT INSIDE DMCMK1), M0G, M0GDMP, (M0GDUM NOT INSIDE DMCMK1), (M0GDOP NOT INSIDE DMCMK1), Overlap is not allowed >= 0.15um
 err1 = EXT DMC10 M0GDMP < 0.15 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_212_M0GDUM {
@ DMC10 space to M0, M0DMP, (M0DUM NOT INSIDE DMCMK1), (M0DOP NOT INSIDE DMCMK1), M0G, M0GDMP, (M0GDUM NOT INSIDE DMCMK1), (M0GDOP NOT INSIDE DMCMK1), Overlap is not allowed >= 0.15um
 err1 = EXT DMC10 M0GDUM_outside_DMCMK1 < 0.15 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_212_M0GDOP {
@ DMC10 space to M0, M0DMP, (M0DUM NOT INSIDE DMCMK1), (M0DOP NOT INSIDE DMCMK1), M0G, M0GDMP, (M0GDUM NOT INSIDE DMCMK1), (M0GDOP NOT INSIDE DMCMK1), Overlap is not allowed >= 0.15um
 err1 = EXT DMC10 M0GDOP_outside_DMCMK1 < 0.15 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_213 {
@ DMC10 space to M0C, M0CDMP, Overlap is not allowed >= 1um
 err1 = EXT DMC10 M0C < 1 ABUT<90 SINGULAR REGION INSIDE ALSO
 err2 = EXT DMC10 M0CDMP < 1 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

DUMC_214_M0CDUM {
@ DMC10 space to (M0CDUM NOT INSIDE DMCMK1), (M0CDOP NOT INSIDE DMCMK1), DMC1, DMC2, DMC3, DMC4, DMC5, DMC6, DMC7, Overlap is not allowed >= 0.75um
 err1 = EXT DMC10 M0CDUM_outside_DMCMK1 < 0.75 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_214_M0CDOP {
@ DMC10 space to (M0CDUM NOT INSIDE DMCMK1), (M0CDOP NOT INSIDE DMCMK1), DMC1, DMC2, DMC3, DMC4, DMC5, DMC6, DMC7, Overlap is not allowed >= 0.75um
 err1 = EXT DMC10 M0CDOP_outside_DMCMK1 < 0.75 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_214_DMC1 {
@ DMC10 space to (M0CDUM NOT INSIDE DMCMK1), (M0CDOP NOT INSIDE DMCMK1), DMC1, DMC2, DMC3, DMC4, DMC5, DMC6, DMC7, Overlap is not allowed >= 0.75um
 err1 = EXT DMC10 DMC1 < 0.75 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_214_DMC2 {
@ DMC10 space to (M0CDUM NOT INSIDE DMCMK1), (M0CDOP NOT INSIDE DMCMK1), DMC1, DMC2, DMC3, DMC4, DMC5, DMC6, DMC7, Overlap is not allowed >= 0.75um
 err1 = EXT DMC10 DMC2 < 0.75 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_214_DMC3 {
@ DMC10 space to (M0CDUM NOT INSIDE DMCMK1), (M0CDOP NOT INSIDE DMCMK1), DMC1, DMC2, DMC3, DMC4, DMC5, DMC6, DMC7, Overlap is not allowed >= 0.75um
 err1 = EXT DMC10 DMC3 < 0.75 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_214_DMC4 {
@ DMC10 space to (M0CDUM NOT INSIDE DMCMK1), (M0CDOP NOT INSIDE DMCMK1), DMC1, DMC2, DMC3, DMC4, DMC5, DMC6, DMC7, Overlap is not allowed >= 0.75um
 err1 = EXT DMC10 DMC4 < 0.75 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_214_DMC5 {
@ DMC10 space to (M0CDUM NOT INSIDE DMCMK1), (M0CDOP NOT INSIDE DMCMK1), DMC1, DMC2, DMC3, DMC4, DMC5, DMC6, DMC7, Overlap is not allowed >= 0.75um
 err1 = EXT DMC10 DMC5 < 0.75 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_214_DMC6 {
@ DMC10 space to (M0CDUM NOT INSIDE DMCMK1), (M0CDOP NOT INSIDE DMCMK1), DMC1, DMC2, DMC3, DMC4, DMC5, DMC6, DMC7, Overlap is not allowed >= 0.75um
 err1 = EXT DMC10 DMC6 < 0.75 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_214_DMC7 {
@ DMC10 space to (M0CDUM NOT INSIDE DMCMK1), (M0CDOP NOT INSIDE DMCMK1), DMC1, DMC2, DMC3, DMC4, DMC5, DMC6, DMC7, Overlap is not allowed >= 0.75um
 err1 = EXT DMC10 DMC7 < 0.75 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_215 {
@ DMC10 space to INST, Overlap is not allowed >= 0.18um
 err1 = EXT DMC10 INST < 0.18 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_216_MARKG {
@ DMC10 space to MARKG, MARKS, NODMF, Overlap is not allowed >= 0.4um
 err1 = EXT DMC10 MARKG < 0.4 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_216_MARKS {
@ DMC10 space to MARKG, MARKS, NODMF, Overlap is not allowed >= 0.4um
 err1 = EXT DMC10 MARKS < 0.4 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_216_NODMF {
@ DMC10 space to MARKG, MARKS, NODMF, Overlap is not allowed >= 0.4um
 err1 = EXT DMC10 NODMF < 0.4 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_217 {
@ DMC10 space to OCOVL_NOT_OCOVLM4, Overlap is not allowed >= 0.4um
 err1 = EXT DMC10 OCOVL_NOT_OCOVLM4 < 0.4 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

#IFDEF CHIPB_RULES_CHECK YES
DUMC_218 {
@ Inside edge of CHIPB space to DMC11, Outside and cut is not allowed >= 0.75um
 err1 = ENC DMC11 CHIPB < 0.75 ABUT<90 SINGULAR REGION OUTSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
#ENDIF

DUMC_219 {
@ DMC11 space to NPAA_EXT, Overlap is not allowed >= 0.44um
 err1 = EXT DMC11 NPAA_EXT < 0.44 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_220 {
@ DMC11 space to AA, AADMP, (AADUM NOT INSIDE DMCMK1), (AADOP NOT INSIDE DMCMK1), PPAA, Overlap is not allowed >= 0.24um
 err1 = EXT DMC11 DMP_AA < 0.24 ABUT<90 SINGULAR REGION INSIDE ALSO
 err2 = EXT DMC11 AADUM_outside_DMCMK1 < 0.24 ABUT<90 SINGULAR REGION INSIDE ALSO
 err3 = EXT DMC11 AADOP_outside_DMCMK1 < 0.24 ABUT<90 SINGULAR REGION INSIDE ALSO
 err4 = EXT DMC11 PPAA < 0.24 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
 err4 NOT INSIDE SealR_NOT_BULK
}

DUMC_221 {
@ DMC11 space to AR_H, (AR_HDOP NOT INSIDE DMCMK1), (ARBL NOT INSIDE DMCMK1), Overlap is not allowed >= 0.144um
 err1 = EXT DMC11 AR_H < 0.144 ABUT<90 SINGULAR REGION INSIDE ALSO
 err2 = EXT DMC11 AR_HDOP_outside_DMCMK1 < 0.144 ABUT<90 SINGULAR REGION INSIDE ALSO
 err3 = EXT DMC11 ARBL_outside_DMCMK1 < 0.144 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
}

DUMC_222_GT_P96 {
@ DMC11 space to edge of GT_P96, HVT_N, HVT_P, SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, Cut is not allowed >= 0.001um
 chk_area = (SIZE GT_P96 BY 0.001) NOT (SIZE GT_P96 BY -0.001)
 chk_area AND DMC11
}

DUMC_222_HVT_N {
@ DMC11 space to edge of GT_P96, HVT_N, HVT_P, SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, Cut is not allowed >= 0.001um
 chk_area = (SIZE HVT_N BY 0.001) NOT (SIZE HVT_N BY -0.001)
 chk_area AND DMC11
}

DUMC_222_HVT_P {
@ DMC11 space to edge of GT_P96, HVT_N, HVT_P, SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, Cut is not allowed >= 0.001um
 chk_area = (SIZE HVT_P BY 0.001) NOT (SIZE HVT_P BY -0.001)
 chk_area AND DMC11
}

DUMC_222_SVT_N {
@ DMC11 space to edge of GT_P96, HVT_N, HVT_P, SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, Cut is not allowed >= 0.001um
 chk_area = (SIZE SVT_N BY 0.001) NOT (SIZE SVT_N BY -0.001)
 chk_area AND DMC11
}

DUMC_222_SVT_P {
@ DMC11 space to edge of GT_P96, HVT_N, HVT_P, SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, Cut is not allowed >= 0.001um
 chk_area = (SIZE SVT_P BY 0.001) NOT (SIZE SVT_P BY -0.001)
 chk_area AND DMC11
}

DUMC_222_LVT_N {
@ DMC11 space to edge of GT_P96, HVT_N, HVT_P, SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, Cut is not allowed >= 0.001um
 chk_area = (SIZE LVT_N BY 0.001) NOT (SIZE LVT_N BY -0.001)
 chk_area AND DMC11
}

DUMC_222_LVT_P {
@ DMC11 space to edge of GT_P96, HVT_N, HVT_P, SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, Cut is not allowed >= 0.001um
 chk_area = (SIZE LVT_P BY 0.001) NOT (SIZE LVT_P BY -0.001)
 chk_area AND DMC11
}

DUMC_222_ULVT_N {
@ DMC11 space to edge of GT_P96, HVT_N, HVT_P, SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, Cut is not allowed >= 0.001um
 chk_area = (SIZE ULVT_N BY 0.001) NOT (SIZE ULVT_N BY -0.001)
 chk_area AND DMC11
}

DUMC_222_ULVT_P {
@ DMC11 space to edge of GT_P96, HVT_N, HVT_P, SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, Cut is not allowed >= 0.001um
 chk_area = (SIZE ULVT_P BY 0.001) NOT (SIZE ULVT_P BY -0.001)
 chk_area AND DMC11
}

DUMC_222_LFN_N {
@ DMC11 space to edge of GT_P96, HVT_N, HVT_P, SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, Cut is not allowed >= 0.001um
 chk_area = (SIZE LFN_N BY 0.001) NOT (SIZE LFN_N BY -0.001)
 chk_area AND DMC11
}

DUMC_222_LFN_P {
@ DMC11 space to edge of GT_P96, HVT_N, HVT_P, SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, Cut is not allowed >= 0.001um
 chk_area = (SIZE LFN_P BY 0.001) NOT (SIZE LFN_P BY -0.001)
 chk_area AND DMC11
}

DUMC_223_DMC1 {
@ DMC11 space to DMC1, DMC2, DMC3, DMC4, DMC5, DMC6, DMC7, Overlap is not allowed >= 0.75um
 err1 = EXT DMC11 DMC1 < 0.75 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_223_DMC2 {
@ DMC11 space to DMC1, DMC2, DMC3, DMC4, DMC5, DMC6, DMC7, Overlap is not allowed >= 0.75um
 err1 = EXT DMC11 DMC2 < 0.75 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_223_DMC3 {
@ DMC11 space to DMC1, DMC2, DMC3, DMC4, DMC5, DMC6, DMC7, Overlap is not allowed >= 0.75um
 err1 = EXT DMC11 DMC3 < 0.75 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_223_DMC4 {
@ DMC11 space to DMC1, DMC2, DMC3, DMC4, DMC5, DMC6, DMC7, Overlap is not allowed >= 0.75um
 err1 = EXT DMC11 DMC4 < 0.75 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_223_DMC5 {
@ DMC11 space to DMC1, DMC2, DMC3, DMC4, DMC5, DMC6, DMC7, Overlap is not allowed >= 0.75um
 err1 = EXT DMC11 DMC5 < 0.75 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_223_DMC6 {
@ DMC11 space to DMC1, DMC2, DMC3, DMC4, DMC5, DMC6, DMC7, Overlap is not allowed >= 0.75um
 err1 = EXT DMC11 DMC6 < 0.75 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_223_DMC7 {
@ DMC11 space to DMC1, DMC2, DMC3, DMC4, DMC5, DMC6, DMC7, Overlap is not allowed >= 0.75um
 err1 = EXT DMC11 DMC7 < 0.75 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_224 {
@ DMC11 space to INST, Overlap is not allowed >= 0um
 err1 = DMC11 AND INST
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_225_RESNW {
@ DMC11 space to RESNW, MARKG, MARKS, NODMF, Overlap is not allowed >= 0.4um
 err1 = EXT DMC11 RESNW < 0.4 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_225_MARKG {
@ DMC11 space to RESNW, MARKG, MARKS, NODMF, Overlap is not allowed >= 0.4um
 err1 = EXT DMC11 MARKG < 0.4 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_225_MARKS {
@ DMC11 space to RESNW, MARKG, MARKS, NODMF, Overlap is not allowed >= 0.4um
 err1 = EXT DMC11 MARKS < 0.4 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_225_NODMF {
@ DMC11 space to RESNW, MARKG, MARKS, NODMF, Overlap is not allowed >= 0.4um
 err1 = EXT DMC11 NODMF < 0.4 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_226 {
@ DMC11 space to OCOVL_NOT_OCOVLM4, Overlap is not allowed >= 0.4um
 err1 = EXT DMC11 OCOVL_NOT_OCOVLM4 < 0.4 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

#IFDEF CHIPB_RULES_CHECK YES
DUMC_227 {
@ Inside edge of CHIPB space to DMC12, Outside and cut is not allowed >= 0.75um
 err1 = ENC DMC12 CHIPB < 0.75 ABUT<90 SINGULAR REGION OUTSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
#ENDIF

DUMC_228 {
@ DMC12 space to NPAA_EXT, Overlap is not allowed >= 0.44um
 err1 = EXT DMC12 NPAA_EXT < 0.44 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_229 {
@ DMC12 space to AA, AADMP, (AADUM NOT INSIDE DMCMK1), (AADOP NOT INSIDE DMCMK1), PPAA, Overlap is not allowed >= 0.24um
 err1 = EXT DMC12 DMP_AA < 0.24 ABUT<90 SINGULAR REGION INSIDE ALSO
 err2 = EXT DMC12 AADUM_outside_DMCMK1 < 0.24 ABUT<90 SINGULAR REGION INSIDE ALSO
 err3 = EXT DMC12 AADOP_outside_DMCMK1 < 0.24 ABUT<90 SINGULAR REGION INSIDE ALSO
 err4 = EXT DMC12 PPAA < 0.24 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
 err4 NOT INSIDE SealR_NOT_BULK
}

DUMC_230_AR_H {
@ DMC12 space to AR_H, (AR_HDOP NOT INSIDE DMCMK1), (ARBL NOT INSIDE DMCMK1), DMC11, Overlap is not allowed >= 0.144um
 err1 = EXT DMC12 AR_H < 0.144 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_230_AR_HDOP {
@ DMC12 space to AR_H, (AR_HDOP NOT INSIDE DMCMK1), (ARBL NOT INSIDE DMCMK1), DMC11, Overlap is not allowed >= 0.144um
 err1 = EXT DMC12 AR_HDOP_outside_DMCMK1 < 0.144 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_230_ARBL {
@ DMC12 space to AR_H, (AR_HDOP NOT INSIDE DMCMK1), (ARBL NOT INSIDE DMCMK1), DMC11, Overlap is not allowed >= 0.144um
 err1 = EXT DMC12 ARBL_outside_DMCMK1 < 0.144 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_230_DMC11 {
@ DMC12 space to AR_H, (AR_HDOP NOT INSIDE DMCMK1), (ARBL NOT INSIDE DMCMK1), DMC11, Overlap is not allowed >= 0.144um
 err1 = EXT DMC12 DMC11 < 0.144 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_231_GT_P96 {
@ DMC12 space to edge of GT_P96, HVT_N, HVT_P, SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, Cut is not allowed >= 0.001um
 chk_area = (SIZE GT_P96 BY 0.001) NOT (SIZE GT_P96 BY -0.001)
 chk_area AND DMC12
}

DUMC_231_HVT_N {
@ DMC12 space to edge of GT_P96, HVT_N, HVT_P, SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, Cut is not allowed >= 0.001um
 chk_area = (SIZE HVT_N BY 0.001) NOT (SIZE HVT_N BY -0.001)
 chk_area AND DMC12
}

DUMC_231_HVT_P {
@ DMC12 space to edge of GT_P96, HVT_N, HVT_P, SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, Cut is not allowed >= 0.001um
 chk_area = (SIZE HVT_P BY 0.001) NOT (SIZE HVT_P BY -0.001)
 chk_area AND DMC12
}

DUMC_231_SVT_N {
@ DMC12 space to edge of GT_P96, HVT_N, HVT_P, SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, Cut is not allowed >= 0.001um
 chk_area = (SIZE SVT_N BY 0.001) NOT (SIZE SVT_N BY -0.001)
 chk_area AND DMC12
}

DUMC_231_SVT_P {
@ DMC12 space to edge of GT_P96, HVT_N, HVT_P, SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, Cut is not allowed >= 0.001um
 chk_area = (SIZE SVT_P BY 0.001) NOT (SIZE SVT_P BY -0.001)
 chk_area AND DMC12
}

DUMC_231_LVT_N {
@ DMC12 space to edge of GT_P96, HVT_N, HVT_P, SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, Cut is not allowed >= 0.001um
 chk_area = (SIZE LVT_N BY 0.001) NOT (SIZE LVT_N BY -0.001)
 chk_area AND DMC12
}

DUMC_231_LVT_P {
@ DMC12 space to edge of GT_P96, HVT_N, HVT_P, SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, Cut is not allowed >= 0.001um
 chk_area = (SIZE LVT_P BY 0.001) NOT (SIZE LVT_P BY -0.001)
 chk_area AND DMC12
}

DUMC_231_ULVT_N {
@ DMC12 space to edge of GT_P96, HVT_N, HVT_P, SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, Cut is not allowed >= 0.001um
 chk_area = (SIZE ULVT_N BY 0.001) NOT (SIZE ULVT_N BY -0.001)
 chk_area AND DMC12
}

DUMC_231_ULVT_P {
@ DMC12 space to edge of GT_P96, HVT_N, HVT_P, SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, Cut is not allowed >= 0.001um
 chk_area = (SIZE ULVT_P BY 0.001) NOT (SIZE ULVT_P BY -0.001)
 chk_area AND DMC12
}

DUMC_231_LFN_N {
@ DMC12 space to edge of GT_P96, HVT_N, HVT_P, SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, Cut is not allowed >= 0.001um
 chk_area = (SIZE LFN_N BY 0.001) NOT (SIZE LFN_N BY -0.001)
 chk_area AND DMC12
}

DUMC_231_LFN_P {
@ DMC12 space to edge of GT_P96, HVT_N, HVT_P, SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, Cut is not allowed >= 0.001um
 chk_area = (SIZE LFN_P BY 0.001) NOT (SIZE LFN_P BY -0.001)
 chk_area AND DMC12
}

DUMC_232_DMC1 {
@ DMC12 space to DMC1, DMC2, DMC3, DMC4, DMC5, DMC6, DMC7, Overlap is not allowed >= 0.75um
 err1 = EXT DMC12 DMC1 < 0.75 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_232_DMC2 {
@ DMC12 space to DMC1, DMC2, DMC3, DMC4, DMC5, DMC6, DMC7, Overlap is not allowed >= 0.75um
 err1 = EXT DMC12 DMC2 < 0.75 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_232_DMC3 {
@ DMC12 space to DMC1, DMC2, DMC3, DMC4, DMC5, DMC6, DMC7, Overlap is not allowed >= 0.75um
 err1 = EXT DMC12 DMC3 < 0.75 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_232_DMC4 {
@ DMC12 space to DMC1, DMC2, DMC3, DMC4, DMC5, DMC6, DMC7, Overlap is not allowed >= 0.75um
 err1 = EXT DMC12 DMC4 < 0.75 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_232_DMC5 {
@ DMC12 space to DMC1, DMC2, DMC3, DMC4, DMC5, DMC6, DMC7, Overlap is not allowed >= 0.75um
 err1 = EXT DMC12 DMC5 < 0.75 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_232_DMC6 {
@ DMC12 space to DMC1, DMC2, DMC3, DMC4, DMC5, DMC6, DMC7, Overlap is not allowed >= 0.75um
 err1 = EXT DMC12 DMC6 < 0.75 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_232_DMC7 {
@ DMC12 space to DMC1, DMC2, DMC3, DMC4, DMC5, DMC6, DMC7, Overlap is not allowed >= 0.75um
 err1 = EXT DMC12 DMC7 < 0.75 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_233 {
@ DMC12 space to INST, Overlap is not allowed >= 0um
 err1 = DMC12 AND INST
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_234_RESNW {
@ DMC12 space to RESNW, MARKG, MARKS, NODMF, Overlap is not allowed >= 0.4um
 err1 = EXT DMC12 RESNW < 0.4 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_234_MARKG {
@ DMC12 space to RESNW, MARKG, MARKS, NODMF, Overlap is not allowed >= 0.4um
 err1 = EXT DMC12 MARKG < 0.4 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_234_MARKS {
@ DMC12 space to RESNW, MARKG, MARKS, NODMF, Overlap is not allowed >= 0.4um
 err1 = EXT DMC12 MARKS < 0.4 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_234_NODMF {
@ DMC12 space to RESNW, MARKG, MARKS, NODMF, Overlap is not allowed >= 0.4um
 err1 = EXT DMC12 NODMF < 0.4 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_235 {
@ DMC12 space to OCOVL_NOT_OCOVLM4, Overlap is not allowed >= 0.4um
 err1 = EXT DMC12 OCOVL_NOT_OCOVLM4 < 0.4 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_236 {
@ DMC11 space to AR, GT, GTDMP, Overlap is not allowed >= 0.048um
 err1 = EXT DMC11 AR < 0.048 ABUT<90 SINGULAR REGION INSIDE ALSO
 err2 = EXT DMC11 GT < 0.048 ABUT<90 SINGULAR REGION INSIDE ALSO
 err3 = EXT DMC11 GTDMP < 0.048 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
}

DUMC_237 {
@ DMC12 space to AR, GT, GTDMP, Overlap is not allowed >= 0.048um
 err1 = EXT DMC12 AR < 0.048 ABUT<90 SINGULAR REGION INSIDE ALSO
 err2 = EXT DMC12 GT < 0.048 ABUT<90 SINGULAR REGION INSIDE ALSO
 err3 = EXT DMC12 GTDMP < 0.048 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
}

DUMC_238_AADOP {
@ AADOP/AADUM/ARDOP/ARDUM/AR_HDOP/AR_VDOP/GTDOP/GTDUM/P2DOP/P2DUM/SNDUM/SPDUM/M0DOP/M0DUM/M0CDOP/M0CDUM/M0GDOP/M0GDUM/V0DUM/V0DPDUM must be fully covered by DMCMK1.outside and cut is not allowed.These layer are dedicated for SMIC FEOL and MEOL dummy auto-insertion utility usage, can’t be used for manually drawn purpose; Drawn dummy layer please use main layer.
 err1 = NOT INSIDE AADOP DMCMK1
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_238_AADUM {
@ AADOP/AADUM/ARDOP/ARDUM/AR_HDOP/AR_VDOP/GTDOP/GTDUM/P2DOP/P2DUM/SNDUM/SPDUM/M0DOP/M0DUM/M0CDOP/M0CDUM/M0GDOP/M0GDUM/V0DUM/V0DPDUM must be fully covered by DMCMK1.outside and cut is not allowed.These layer are dedicated for SMIC FEOL and MEOL dummy auto-insertion utility usage, can’t be used for manually drawn purpose; Drawn dummy layer please use main layer.
 err1 = NOT INSIDE AADUM DMCMK1
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_238_ARDOP {
@ AADOP/AADUM/ARDOP/ARDUM/AR_HDOP/AR_VDOP/GTDOP/GTDUM/P2DOP/P2DUM/SNDUM/SPDUM/M0DOP/M0DUM/M0CDOP/M0CDUM/M0GDOP/M0GDUM/V0DUM/V0DPDUM must be fully covered by DMCMK1.outside and cut is not allowed.These layer are dedicated for SMIC FEOL and MEOL dummy auto-insertion utility usage, can’t be used for manually drawn purpose; Drawn dummy layer please use main layer.
 err1 = NOT INSIDE ARDOP DMCMK1
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_238_ARDUM {
@ AADOP/AADUM/ARDOP/ARDUM/AR_HDOP/AR_VDOP/GTDOP/GTDUM/P2DOP/P2DUM/SNDUM/SPDUM/M0DOP/M0DUM/M0CDOP/M0CDUM/M0GDOP/M0GDUM/V0DUM/V0DPDUM must be fully covered by DMCMK1.outside and cut is not allowed.These layer are dedicated for SMIC FEOL and MEOL dummy auto-insertion utility usage, can’t be used for manually drawn purpose; Drawn dummy layer please use main layer.
 err1 = NOT INSIDE ARDUM DMCMK1
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_238_AR_HDOP {
@ AADOP/AADUM/ARDOP/ARDUM/AR_HDOP/AR_VDOP/GTDOP/GTDUM/P2DOP/P2DUM/SNDUM/SPDUM/M0DOP/M0DUM/M0CDOP/M0CDUM/M0GDOP/M0GDUM/V0DUM/V0DPDUM must be fully covered by DMCMK1.outside and cut is not allowed.These layer are dedicated for SMIC FEOL and MEOL dummy auto-insertion utility usage, can’t be used for manually drawn purpose; Drawn dummy layer please use main layer.
 err1 = NOT INSIDE AR_HDOP DMCMK1
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_238_AR_VDOP {
@ AADOP/AADUM/ARDOP/ARDUM/AR_HDOP/AR_VDOP/GTDOP/GTDUM/P2DOP/P2DUM/SNDUM/SPDUM/M0DOP/M0DUM/M0CDOP/M0CDUM/M0GDOP/M0GDUM/V0DUM/V0DPDUM must be fully covered by DMCMK1.outside and cut is not allowed.These layer are dedicated for SMIC FEOL and MEOL dummy auto-insertion utility usage, can’t be used for manually drawn purpose; Drawn dummy layer please use main layer.
 err1 = NOT INSIDE AR_VDOP DMCMK1
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_238_GTDOP {
@ AADOP/AADUM/ARDOP/ARDUM/AR_HDOP/AR_VDOP/GTDOP/GTDUM/P2DOP/P2DUM/SNDUM/SPDUM/M0DOP/M0DUM/M0CDOP/M0CDUM/M0GDOP/M0GDUM/V0DUM/V0DPDUM must be fully covered by DMCMK1.outside and cut is not allowed.These layer are dedicated for SMIC FEOL and MEOL dummy auto-insertion utility usage, can’t be used for manually drawn purpose; Drawn dummy layer please use main layer.
 err1 = NOT INSIDE GTDOP DMCMK1
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_238_GTDUM {
@ AADOP/AADUM/ARDOP/ARDUM/AR_HDOP/AR_VDOP/GTDOP/GTDUM/P2DOP/P2DUM/SNDUM/SPDUM/M0DOP/M0DUM/M0CDOP/M0CDUM/M0GDOP/M0GDUM/V0DUM/V0DPDUM must be fully covered by DMCMK1.outside and cut is not allowed.These layer are dedicated for SMIC FEOL and MEOL dummy auto-insertion utility usage, can’t be used for manually drawn purpose; Drawn dummy layer please use main layer.
 err1 = NOT INSIDE GTDUM DMCMK1
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_238_P2DOP {
@ AADOP/AADUM/ARDOP/ARDUM/AR_HDOP/AR_VDOP/GTDOP/GTDUM/P2DOP/P2DUM/SNDUM/SPDUM/M0DOP/M0DUM/M0CDOP/M0CDUM/M0GDOP/M0GDUM/V0DUM/V0DPDUM must be fully covered by DMCMK1.outside and cut is not allowed.These layer are dedicated for SMIC FEOL and MEOL dummy auto-insertion utility usage, can’t be used for manually drawn purpose; Drawn dummy layer please use main layer.
 err1 = NOT INSIDE P2DOP DMCMK1
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_238_P2DUM {
@ AADOP/AADUM/ARDOP/ARDUM/AR_HDOP/AR_VDOP/GTDOP/GTDUM/P2DOP/P2DUM/SNDUM/SPDUM/M0DOP/M0DUM/M0CDOP/M0CDUM/M0GDOP/M0GDUM/V0DUM/V0DPDUM must be fully covered by DMCMK1.outside and cut is not allowed.These layer are dedicated for SMIC FEOL and MEOL dummy auto-insertion utility usage, can’t be used for manually drawn purpose; Drawn dummy layer please use main layer.
 err1 = NOT INSIDE P2DUM DMCMK1
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_238_SNDUM {
@ AADOP/AADUM/ARDOP/ARDUM/AR_HDOP/AR_VDOP/GTDOP/GTDUM/P2DOP/P2DUM/SNDUM/SPDUM/M0DOP/M0DUM/M0CDOP/M0CDUM/M0GDOP/M0GDUM/V0DUM/V0DPDUM must be fully covered by DMCMK1.outside and cut is not allowed.These layer are dedicated for SMIC FEOL and MEOL dummy auto-insertion utility usage, can’t be used for manually drawn purpose; Drawn dummy layer please use main layer.
 err1 = NOT INSIDE SNDUM DMCMK1
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_238_SPDUM {
@ AADOP/AADUM/ARDOP/ARDUM/AR_HDOP/AR_VDOP/GTDOP/GTDUM/P2DOP/P2DUM/SNDUM/SPDUM/M0DOP/M0DUM/M0CDOP/M0CDUM/M0GDOP/M0GDUM/V0DUM/V0DPDUM must be fully covered by DMCMK1.outside and cut is not allowed.These layer are dedicated for SMIC FEOL and MEOL dummy auto-insertion utility usage, can’t be used for manually drawn purpose; Drawn dummy layer please use main layer.
 err1 = NOT INSIDE SPDUM DMCMK1
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_238_M0DOP {
@ AADOP/AADUM/ARDOP/ARDUM/AR_HDOP/AR_VDOP/GTDOP/GTDUM/P2DOP/P2DUM/SNDUM/SPDUM/M0DOP/M0DUM/M0CDOP/M0CDUM/M0GDOP/M0GDUM/V0DUM/V0DPDUM must be fully covered by DMCMK1.outside and cut is not allowed.These layer are dedicated for SMIC FEOL and MEOL dummy auto-insertion utility usage, can’t be used for manually drawn purpose; Drawn dummy layer please use main layer.
 err1 = NOT INSIDE M0DOP DMCMK1
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_238_M0DUM {
@ AADOP/AADUM/ARDOP/ARDUM/AR_HDOP/AR_VDOP/GTDOP/GTDUM/P2DOP/P2DUM/SNDUM/SPDUM/M0DOP/M0DUM/M0CDOP/M0CDUM/M0GDOP/M0GDUM/V0DUM/V0DPDUM must be fully covered by DMCMK1.outside and cut is not allowed.These layer are dedicated for SMIC FEOL and MEOL dummy auto-insertion utility usage, can’t be used for manually drawn purpose; Drawn dummy layer please use main layer.
 err1 = NOT INSIDE M0DUM DMCMK1
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_238_M0CDOP {
@ AADOP/AADUM/ARDOP/ARDUM/AR_HDOP/AR_VDOP/GTDOP/GTDUM/P2DOP/P2DUM/SNDUM/SPDUM/M0DOP/M0DUM/M0CDOP/M0CDUM/M0GDOP/M0GDUM/V0DUM/V0DPDUM must be fully covered by DMCMK1.outside and cut is not allowed.These layer are dedicated for SMIC FEOL and MEOL dummy auto-insertion utility usage, can’t be used for manually drawn purpose; Drawn dummy layer please use main layer.
 err1 = NOT INSIDE M0CDOP DMCMK1
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_238_M0CDUM {
@ AADOP/AADUM/ARDOP/ARDUM/AR_HDOP/AR_VDOP/GTDOP/GTDUM/P2DOP/P2DUM/SNDUM/SPDUM/M0DOP/M0DUM/M0CDOP/M0CDUM/M0GDOP/M0GDUM/V0DUM/V0DPDUM must be fully covered by DMCMK1.outside and cut is not allowed.These layer are dedicated for SMIC FEOL and MEOL dummy auto-insertion utility usage, can’t be used for manually drawn purpose; Drawn dummy layer please use main layer.
 err1 = NOT INSIDE M0CDUM DMCMK1
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_238_M0GDOP {
@ AADOP/AADUM/ARDOP/ARDUM/AR_HDOP/AR_VDOP/GTDOP/GTDUM/P2DOP/P2DUM/SNDUM/SPDUM/M0DOP/M0DUM/M0CDOP/M0CDUM/M0GDOP/M0GDUM/V0DUM/V0DPDUM must be fully covered by DMCMK1.outside and cut is not allowed.These layer are dedicated for SMIC FEOL and MEOL dummy auto-insertion utility usage, can’t be used for manually drawn purpose; Drawn dummy layer please use main layer.
 err1 = NOT INSIDE M0GDOP DMCMK1
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_238_M0GDUM {
@ AADOP/AADUM/ARDOP/ARDUM/AR_HDOP/AR_VDOP/GTDOP/GTDUM/P2DOP/P2DUM/SNDUM/SPDUM/M0DOP/M0DUM/M0CDOP/M0CDUM/M0GDOP/M0GDUM/V0DUM/V0DPDUM must be fully covered by DMCMK1.outside and cut is not allowed.These layer are dedicated for SMIC FEOL and MEOL dummy auto-insertion utility usage, can’t be used for manually drawn purpose; Drawn dummy layer please use main layer.
 err1 = NOT INSIDE M0GDUM DMCMK1
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_238_V0DUM {
@ AADOP/AADUM/ARDOP/ARDUM/AR_HDOP/AR_VDOP/GTDOP/GTDUM/P2DOP/P2DUM/SNDUM/SPDUM/M0DOP/M0DUM/M0CDOP/M0CDUM/M0GDOP/M0GDUM/V0DUM/V0DPDUM must be fully covered by DMCMK1.outside and cut is not allowed.These layer are dedicated for SMIC FEOL and MEOL dummy auto-insertion utility usage, can’t be used for manually drawn purpose; Drawn dummy layer please use main layer.
 err1 = NOT INSIDE V0DUM DMCMK1
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_238_V0DPDUM {
@ AADOP/AADUM/ARDOP/ARDUM/AR_HDOP/AR_VDOP/GTDOP/GTDUM/P2DOP/P2DUM/SNDUM/SPDUM/M0DOP/M0DUM/M0CDOP/M0CDUM/M0GDOP/M0GDUM/V0DUM/V0DPDUM must be fully covered by DMCMK1.outside and cut is not allowed.These layer are dedicated for SMIC FEOL and MEOL dummy auto-insertion utility usage, can’t be used for manually drawn purpose; Drawn dummy layer please use main layer.
 err1 = NOT INSIDE V0DPDUM DMCMK1
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_239_AADOP {
@ AADOP/AADUM/ARDOP/ARDUM/AR_HDOP/AR_VDOP/GTDOP/GTDUM/P2DOP/P2DUM/SNDUM/SPDUM/M0DOP/M0DUM/M0CDOP/M0CDUM/M0GDOP/M0GDUM/V0DUM/V0DPDUM must be fully covered by {{{{{{{{{{{DMC1 or DMC2} or DMC3} or DMC4} or DMC5} or DMC6} or DMC7} or DMC8} or DMC9} or DMC10} or DMC11} or DMC12}.outside and cut is not allowed.These layer are dedicated for SMIC FEOL and MEOL dummy auto-insertion utility usage, can’t be used for manually drawn purpose; Drawn dummy layer please use main layer.
 err1 = OR DMC1 DMC2 DMC3 DMC4 DMC5 DMC6 DMC7 DMC8 DMC9 DMC10 DMC11 DMC12
 err2 = NOT INSIDE AADOP err1
 err2 NOT INSIDE SealR_NOT_BULK
}

DUMC_239_AADUM {
@ AADOP/AADUM/ARDOP/ARDUM/AR_HDOP/AR_VDOP/GTDOP/GTDUM/P2DOP/P2DUM/SNDUM/SPDUM/M0DOP/M0DUM/M0CDOP/M0CDUM/M0GDOP/M0GDUM/V0DUM/V0DPDUM must be fully covered by {{{{{{{{{{{DMC1 or DMC2} or DMC3} or DMC4} or DMC5} or DMC6} or DMC7} or DMC8} or DMC9} or DMC10} or DMC11} or DMC12}.outside and cut is not allowed.These layer are dedicated for SMIC FEOL and MEOL dummy auto-insertion utility usage, can’t be used for manually drawn purpose. Drawn dummy layer please use main layer.
 err1 = OR DMC1 DMC2 DMC3 DMC4 DMC5 DMC6 DMC7 DMC8 DMC9 DMC10 DMC11 DMC12
 err2 = NOT INSIDE AADUM err1
 err2 NOT INSIDE SealR_NOT_BULK
}

DUMC_239_ARDOP {
@ AADOP/AADUM/ARDOP/ARDUM/AR_HDOP/AR_VDOP/GTDOP/GTDUM/P2DOP/P2DUM/SNDUM/SPDUM/M0DOP/M0DUM/M0CDOP/M0CDUM/M0GDOP/M0GDUM/V0DUM/V0DPDUM must be fully covered by {{{{{{{{{{{DMC1 or DMC2} or DMC3} or DMC4} or DMC5} or DMC6} or DMC7} or DMC8} or DMC9} or DMC10} or DMC11} or DMC12}.outside and cut is not allowed.These layer are dedicated for SMIC FEOL and MEOL dummy auto-insertion utility usage, can’t be used for manually drawn purpose. Drawn dummy layer please use main layer.
 err1 = OR DMC1 DMC2 DMC3 DMC4 DMC5 DMC6 DMC7 DMC8 DMC9 DMC10 DMC11 DMC12
 err2 = NOT INSIDE ARDOP err1
 err2 NOT INSIDE SealR_NOT_BULK
}

DUMC_239_ARDUM {
@ AADOP/AADUM/ARDOP/ARDUM/AR_HDOP/AR_VDOP/GTDOP/GTDUM/P2DOP/P2DUM/SNDUM/SPDUM/M0DOP/M0DUM/M0CDOP/M0CDUM/M0GDOP/M0GDUM/V0DUM/V0DPDUM must be fully covered by {{{{{{{{{{{DMC1 or DMC2} or DMC3} or DMC4} or DMC5} or DMC6} or DMC7} or DMC8} or DMC9} or DMC10} or DMC11} or DMC12}.outside and cut is not allowed.These layer are dedicated for SMIC FEOL and MEOL dummy auto-insertion utility usage, can’t be used for manually drawn purpose. Drawn dummy layer please use main layer.
 err1 = OR DMC1 DMC2 DMC3 DMC4 DMC5 DMC6 DMC7 DMC8 DMC9 DMC10 DMC11 DMC12
 err2 = NOT INSIDE ARDUM err1
 err2 NOT INSIDE SealR_NOT_BULK
}

DUMC_239_AR_HDOP {
@ AADOP/AADUM/ARDOP/ARDUM/AR_HDOP/AR_VDOP/GTDOP/GTDUM/P2DOP/P2DUM/SNDUM/SPDUM/M0DOP/M0DUM/M0CDOP/M0CDUM/M0GDOP/M0GDUM/V0DUM/V0DPDUM must be fully covered by {{{{{{{{{{{DMC1 or DMC2} or DMC3} or DMC4} or DMC5} or DMC6} or DMC7} or DMC8} or DMC9} or DMC10} or DMC11} or DMC12}.outside and cut is not allowed.These layer are dedicated for SMIC FEOL and MEOL dummy auto-insertion utility usage, can’t be used for manually drawn purpose. Drawn dummy layer please use main layer.
 err1 = OR DMC1 DMC2 DMC3 DMC4 DMC5 DMC6 DMC7 DMC8 DMC9 DMC10 DMC11 DMC12
 err2 = NOT INSIDE AR_HDOP err1
 err2 NOT INSIDE SealR_NOT_BULK
}

DUMC_239_AR_VDOP {
@ AADOP/AADUM/ARDOP/ARDUM/AR_HDOP/AR_VDOP/GTDOP/GTDUM/P2DOP/P2DUM/SNDUM/SPDUM/M0DOP/M0DUM/M0CDOP/M0CDUM/M0GDOP/M0GDUM/V0DUM/V0DPDUM must be fully covered by {{{{{{{{{{{DMC1 or DMC2} or DMC3} or DMC4} or DMC5} or DMC6} or DMC7} or DMC8} or DMC9} or DMC10} or DMC11} or DMC12}.outside and cut is not allowed.These layer are dedicated for SMIC FEOL and MEOL dummy auto-insertion utility usage, can’t be used for manually drawn purpose. Drawn dummy layer please use main layer.
 err1 = OR DMC1 DMC2 DMC3 DMC4 DMC5 DMC6 DMC7 DMC8 DMC9 DMC10 DMC11 DMC12
 err2 = NOT INSIDE AR_VDOP err1
 err2 NOT INSIDE SealR_NOT_BULK
}

DUMC_239_GTDOP {
@ AADOP/AADUM/ARDOP/ARDUM/AR_HDOP/AR_VDOP/GTDOP/GTDUM/P2DOP/P2DUM/SNDUM/SPDUM/M0DOP/M0DUM/M0CDOP/M0CDUM/M0GDOP/M0GDUM/V0DUM/V0DPDUM must be fully covered by {{{{{{{{{{{DMC1 or DMC2} or DMC3} or DMC4} or DMC5} or DMC6} or DMC7} or DMC8} or DMC9} or DMC10} or DMC11} or DMC12}.outside and cut is not allowed.These layer are dedicated for SMIC FEOL and MEOL dummy auto-insertion utility usage, can’t be used for manually drawn purpose. Drawn dummy layer please use main layer.
 err1 = OR DMC1 DMC2 DMC3 DMC4 DMC5 DMC6 DMC7 DMC8 DMC9 DMC10 DMC11 DMC12
 err2 = NOT INSIDE GTDOP err1
 err2 NOT INSIDE SealR_NOT_BULK
}

DUMC_239_GTDUM {
@ AADOP/AADUM/ARDOP/ARDUM/AR_HDOP/AR_VDOP/GTDOP/GTDUM/P2DOP/P2DUM/SNDUM/SPDUM/M0DOP/M0DUM/M0CDOP/M0CDUM/M0GDOP/M0GDUM/V0DUM/V0DPDUM must be fully covered by {{{{{{{{{{{DMC1 or DMC2} or DMC3} or DMC4} or DMC5} or DMC6} or DMC7} or DMC8} or DMC9} or DMC10} or DMC11} or DMC12}.outside and cut is not allowed.These layer are dedicated for SMIC FEOL and MEOL dummy auto-insertion utility usage, can’t be used for manually drawn purpose. Drawn dummy layer please use main layer.
 err1 = OR DMC1 DMC2 DMC3 DMC4 DMC5 DMC6 DMC7 DMC8 DMC9 DMC10 DMC11 DMC12
 err2 = NOT INSIDE GTDUM err1
 err2 NOT INSIDE SealR_NOT_BULK
}

DUMC_239_P2DOP {
@ AADOP/AADUM/ARDOP/ARDUM/AR_HDOP/AR_VDOP/GTDOP/GTDUM/P2DOP/P2DUM/SNDUM/SPDUM/M0DOP/M0DUM/M0CDOP/M0CDUM/M0GDOP/M0GDUM/V0DUM/V0DPDUM must be fully covered by {{{{{{{{{{{DMC1 or DMC2} or DMC3} or DMC4} or DMC5} or DMC6} or DMC7} or DMC8} or DMC9} or DMC10} or DMC11} or DMC12}.outside and cut is not allowed.These layer are dedicated for SMIC FEOL and MEOL dummy auto-insertion utility usage, can’t be used for manually drawn purpose. Drawn dummy layer please use main layer.
 err1 = OR DMC1 DMC2 DMC3 DMC4 DMC5 DMC6 DMC7 DMC8 DMC9 DMC10 DMC11 DMC12
 err2 = NOT INSIDE P2DOP err1
 err2 NOT INSIDE SealR_NOT_BULK
}

DUMC_239_P2DUM {
@ AADOP/AADUM/ARDOP/ARDUM/AR_HDOP/AR_VDOP/GTDOP/GTDUM/P2DOP/P2DUM/SNDUM/SPDUM/M0DOP/M0DUM/M0CDOP/M0CDUM/M0GDOP/M0GDUM/V0DUM/V0DPDUM must be fully covered by {{{{{{{{{{{DMC1 or DMC2} or DMC3} or DMC4} or DMC5} or DMC6} or DMC7} or DMC8} or DMC9} or DMC10} or DMC11} or DMC12}.outside and cut is not allowed.These layer are dedicated for SMIC FEOL and MEOL dummy auto-insertion utility usage, can’t be used for manually drawn purpose. Drawn dummy layer please use main layer.
 err1 = OR DMC1 DMC2 DMC3 DMC4 DMC5 DMC6 DMC7 DMC8 DMC9 DMC10 DMC11 DMC12
 err2 = NOT INSIDE P2DUM err1
 err2 NOT INSIDE SealR_NOT_BULK
}

DUMC_239_SNDUM {
@ AADOP/AADUM/ARDOP/ARDUM/AR_HDOP/AR_VDOP/GTDOP/GTDUM/P2DOP/P2DUM/SNDUM/SPDUM/M0DOP/M0DUM/M0CDOP/M0CDUM/M0GDOP/M0GDUM/V0DUM/V0DPDUM must be fully covered by {{{{{{{{{{{DMC1 or DMC2} or DMC3} or DMC4} or DMC5} or DMC6} or DMC7} or DMC8} or DMC9} or DMC10} or DMC11} or DMC12}.outside and cut is not allowed.These layer are dedicated for SMIC FEOL and MEOL dummy auto-insertion utility usage, can’t be used for manually drawn purpose. Drawn dummy layer please use main layer.
 err1 = OR DMC1 DMC2 DMC3 DMC4 DMC5 DMC6 DMC7 DMC8 DMC9 DMC10 DMC11 DMC12
 err2 = NOT INSIDE SNDUM err1
 err2 NOT INSIDE SealR_NOT_BULK
}

DUMC_239_SPDUM {
@ AADOP/AADUM/ARDOP/ARDUM/AR_HDOP/AR_VDOP/GTDOP/GTDUM/P2DOP/P2DUM/SNDUM/SPDUM/M0DOP/M0DUM/M0CDOP/M0CDUM/M0GDOP/M0GDUM/V0DUM/V0DPDUM must be fully covered by {{{{{{{{{{{DMC1 or DMC2} or DMC3} or DMC4} or DMC5} or DMC6} or DMC7} or DMC8} or DMC9} or DMC10} or DMC11} or DMC12}.outside and cut is not allowed.These layer are dedicated for SMIC FEOL and MEOL dummy auto-insertion utility usage, can’t be used for manually drawn purpose. Drawn dummy layer please use main layer.
 err1 = OR DMC1 DMC2 DMC3 DMC4 DMC5 DMC6 DMC7 DMC8 DMC9 DMC10 DMC11 DMC12
 err2 = NOT INSIDE SPDUM err1
 err2 NOT INSIDE SealR_NOT_BULK
}

DUMC_239_M0DOP {
@ AADOP/AADUM/ARDOP/ARDUM/AR_HDOP/AR_VDOP/GTDOP/GTDUM/P2DOP/P2DUM/SNDUM/SPDUM/M0DOP/M0DUM/M0CDOP/M0CDUM/M0GDOP/M0GDUM/V0DUM/V0DPDUM must be fully covered by {{{{{{{{{{{DMC1 or DMC2} or DMC3} or DMC4} or DMC5} or DMC6} or DMC7} or DMC8} or DMC9} or DMC10} or DMC11} or DMC12}.outside and cut is not allowed.These layer are dedicated for SMIC FEOL and MEOL dummy auto-insertion utility usage, can’t be used for manually drawn purpose. Drawn dummy layer please use main layer.
 err1 = OR DMC1 DMC2 DMC3 DMC4 DMC5 DMC6 DMC7 DMC8 DMC9 DMC10 DMC11 DMC12
 err2 = NOT INSIDE M0DOP err1
 err2 NOT INSIDE SealR_NOT_BULK
}

DUMC_239_M0DUM {
@ AADOP/AADUM/ARDOP/ARDUM/AR_HDOP/AR_VDOP/GTDOP/GTDUM/P2DOP/P2DUM/SNDUM/SPDUM/M0DOP/M0DUM/M0CDOP/M0CDUM/M0GDOP/M0GDUM/V0DUM/V0DPDUM must be fully covered by {{{{{{{{{{{DMC1 or DMC2} or DMC3} or DMC4} or DMC5} or DMC6} or DMC7} or DMC8} or DMC9} or DMC10} or DMC11} or DMC12}.outside and cut is not allowed.These layer are dedicated for SMIC FEOL and MEOL dummy auto-insertion utility usage, can’t be used for manually drawn purpose. Drawn dummy layer please use main layer.
 err1 = OR DMC1 DMC2 DMC3 DMC4 DMC5 DMC6 DMC7 DMC8 DMC9 DMC10 DMC11 DMC12
 err2 = NOT INSIDE M0DUM err1
 err2 NOT INSIDE SealR_NOT_BULK
}

DUMC_239_M0CDOP {
@ AADOP/AADUM/ARDOP/ARDUM/AR_HDOP/AR_VDOP/GTDOP/GTDUM/P2DOP/P2DUM/SNDUM/SPDUM/M0DOP/M0DUM/M0CDOP/M0CDUM/M0GDOP/M0GDUM/V0DUM/V0DPDUM must be fully covered by {{{{{{{{{{{DMC1 or DMC2} or DMC3} or DMC4} or DMC5} or DMC6} or DMC7} or DMC8} or DMC9} or DMC10} or DMC11} or DMC12}.outside and cut is not allowed.These layer are dedicated for SMIC FEOL and MEOL dummy auto-insertion utility usage, can’t be used for manually drawn purpose. Drawn dummy layer please use main layer.
 err1 = OR DMC1 DMC2 DMC3 DMC4 DMC5 DMC6 DMC7 DMC8 DMC9 DMC10 DMC11 DMC12
 err2 = NOT INSIDE M0CDOP err1
 err2 NOT INSIDE SealR_NOT_BULK
}

DUMC_239_M0CDUM {
@ AADOP/AADUM/ARDOP/ARDUM/AR_HDOP/AR_VDOP/GTDOP/GTDUM/P2DOP/P2DUM/SNDUM/SPDUM/M0DOP/M0DUM/M0CDOP/M0CDUM/M0GDOP/M0GDUM/V0DUM/V0DPDUM must be fully covered by {{{{{{{{{{{DMC1 or DMC2} or DMC3} or DMC4} or DMC5} or DMC6} or DMC7} or DMC8} or DMC9} or DMC10} or DMC11} or DMC12}.outside and cut is not allowed.These layer are dedicated for SMIC FEOL and MEOL dummy auto-insertion utility usage, can’t be used for manually drawn purpose. Drawn dummy layer please use main layer.
 err1 = OR DMC1 DMC2 DMC3 DMC4 DMC5 DMC6 DMC7 DMC8 DMC9 DMC10 DMC11 DMC12
 err2 = NOT INSIDE M0CDUM err1
 err2 NOT INSIDE SealR_NOT_BULK
}

DUMC_239_M0GDOP {
@ AADOP/AADUM/ARDOP/ARDUM/AR_HDOP/AR_VDOP/GTDOP/GTDUM/P2DOP/P2DUM/SNDUM/SPDUM/M0DOP/M0DUM/M0CDOP/M0CDUM/M0GDOP/M0GDUM/V0DUM/V0DPDUM must be fully covered by {{{{{{{{{{{DMC1 or DMC2} or DMC3} or DMC4} or DMC5} or DMC6} or DMC7} or DMC8} or DMC9} or DMC10} or DMC11} or DMC12}.outside and cut is not allowed.These layer are dedicated for SMIC FEOL and MEOL dummy auto-insertion utility usage, can’t be used for manually drawn purpose. Drawn dummy layer please use main layer.
 err1 = OR DMC1 DMC2 DMC3 DMC4 DMC5 DMC6 DMC7 DMC8 DMC9 DMC10 DMC11 DMC12
 err2 = NOT INSIDE M0GDOP err1
 err2 NOT INSIDE SealR_NOT_BULK
}

DUMC_239_M0GDUM {
@ AADOP/AADUM/ARDOP/ARDUM/AR_HDOP/AR_VDOP/GTDOP/GTDUM/P2DOP/P2DUM/SNDUM/SPDUM/M0DOP/M0DUM/M0CDOP/M0CDUM/M0GDOP/M0GDUM/V0DUM/V0DPDUM must be fully covered by {{{{{{{{{{{DMC1 or DMC2} or DMC3} or DMC4} or DMC5} or DMC6} or DMC7} or DMC8} or DMC9} or DMC10} or DMC11} or DMC12}.outside and cut is not allowed.These layer are dedicated for SMIC FEOL and MEOL dummy auto-insertion utility usage, can’t be used for manually drawn purpose. Drawn dummy layer please use main layer.
 err1 = OR DMC1 DMC2 DMC3 DMC4 DMC5 DMC6 DMC7 DMC8 DMC9 DMC10 DMC11 DMC12
 err2 = NOT INSIDE M0GDUM err1
 err2 NOT INSIDE SealR_NOT_BULK
}

DUMC_239_V0DUM {
@ AADOP/AADUM/ARDOP/ARDUM/AR_HDOP/AR_VDOP/GTDOP/GTDUM/P2DOP/P2DUM/SNDUM/SPDUM/M0DOP/M0DUM/M0CDOP/M0CDUM/M0GDOP/M0GDUM/V0DUM/V0DPDUM must be fully covered by {{{{{{{{{{{DMC1 or DMC2} or DMC3} or DMC4} or DMC5} or DMC6} or DMC7} or DMC8} or DMC9} or DMC10} or DMC11} or DMC12}.outside and cut is not allowed.These layer are dedicated for SMIC FEOL and MEOL dummy auto-insertion utility usage, can’t be used for manually drawn purpose. Drawn dummy layer please use main layer.
 err1 = OR DMC1 DMC2 DMC3 DMC4 DMC5 DMC6 DMC7 DMC8 DMC9 DMC10 DMC11 DMC12
 err2 = NOT INSIDE V0DUM err1
 err2 NOT INSIDE SealR_NOT_BULK
}

DUMC_239_V0DPDUM {
@ AADOP/AADUM/ARDOP/ARDUM/AR_HDOP/AR_VDOP/GTDOP/GTDUM/P2DOP/P2DUM/SNDUM/SPDUM/M0DOP/M0DUM/M0CDOP/M0CDUM/M0GDOP/M0GDUM/V0DUM/V0DPDUM must be fully covered by {{{{{{{{{{{DMC1 or DMC2} or DMC3} or DMC4} or DMC5} or DMC6} or DMC7} or DMC8} or DMC9} or DMC10} or DMC11} or DMC12}.outside and cut is not allowed.These layer are dedicated for SMIC FEOL and MEOL dummy auto-insertion utility usage, can’t be used for manually drawn purpose. Drawn dummy layer please use main layer.
 err1 = OR DMC1 DMC2 DMC3 DMC4 DMC5 DMC6 DMC7 DMC8 DMC9 DMC10 DMC11 DMC12
 err2 = NOT INSIDE V0DPDUM err1
 err2 NOT INSIDE SealR_NOT_BULK
}

DUMC_240_241 {
@ AADUM fixed width = 0.384um
@ AADUM fixed length = 1.8um
 err1 = NOT RECTANGLE AADUM == 0.384 BY == 1.8
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_242_243 {
@ GTDUM fixed width = 0.22um
@ GTDUM fixed length = 1.18um
 err1 = NOT RECTANGLE GTDUM == 0.22 BY == 1.18
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_244_245 {
@ ARDUM fixed width = 0.1um
@ ARDUM fixed length = 1.236um
 err1 = NOT RECTANGLE ARDUM == 0.1 BY == 1.236
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_246_247 {
@ P2DUM fixed width = 0.13um
@ P2DUM fixed length = 1.36um
 err1 = NOT RECTANGLE P2DUM == 0.13 BY == 1.36
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_248_249 {
@ M0DUM fixed width = 0.1um
@ M0DUM fixed length = 1.18um
 err1 = NOT RECTANGLE M0DUM == 0.1 BY == 1.18
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_250_251 {
@ M0GDUM fixed width = 0.125um
@ M0GDUM fixed length = 2.02um
 err1 = NOT RECTANGLE M0GDUM == 0.125 BY == 2.02
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_252_253 {
@ M0CDUM fixed width = 0.19um
@ M0CDUM fixed length = 2.16um
 err1 = NOT RECTANGLE M0CDUM == 0.19 BY == 2.16
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_254_255 {
@ SNDUM fixed width = 0.624um
@ SNDUM fixed length = 2.16um
 err1 = NOT RECTANGLE SNDUM == 0.624 BY == 2.16
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_256_257 {
@ SPDUM fixed width = 0.624um
@ SPDUM fixed length = 2.16um
 err1 = NOT RECTANGLE SPDUM == 0.624 BY == 2.16
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_258_259 {
@ AR_HDOP minimum width >= 0.096um
@ AR_HDOP minimum length >= 0.21um
 err1 = NOT RECTANGLE AR_HDOP >= 0.096 BY >= 0.21
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_260 {
@ AR_VDOP minimum width >= 0.048um
 err1 = AR_VDOP WITH WIDTH < 0.048
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_261_262 {
@ AADOP minimum width >= 0.096um
@ AADOP minimum length >= 0.212um
 err1 = NOT RECTANGLE AADOP >= 0.096 BY >= 0.212
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_263_264 {
@ GTDOP minimum width >= 0.032um
@ GTDOP minimum length >= 0.208um
 err1 = NOT RECTANGLE GTDOP >= 0.032 BY >= 0.208
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_265_266 {
@ ARDOP fixed width = 0.02um
@ ARDOP minimum length >= 0.248um
 err1 = ARDOP NOT WITH WIDTH == 0.02
 err2 = RECTANGLE ARDOP == 0.02 BY < 0.248
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

DUMC_267_268 {
@ P2DOP minimum width >= 0.068um
@ P2DOP minimum length >= 0.87um
 err1 = NOT RECTANGLE P2DOP >= 0.068 BY >= 0.87
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_269_270 {
@ M0DOP minimum width >= 0.04um
@ M0DOP minimum length >= 0.208um
 err1 = NOT RECTANGLE M0DOP >= 0.04 BY >= 0.208
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_271_272 {
@ M0GDOP minimum width >= 0.04um
@ M0GDOP minimum length >= 0.118um
 err1 = NOT RECTANGLE M0GDOP >= 0.04 BY >= 0.118
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_273_274 {
@ M0CDOP minimum width >= 0.052um
@ M0CDOP minimum length >= 0.36um
 err1 = NOT RECTANGLE M0CDOP >= 0.052 BY >= 0.36
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_275 {
@ Minimum space between AADUM in vertical direction, overlap is not allowed. >= 0.288um
 err1 = EXT (ANGLE AADUM == 0) < 0.288 ABUT<90 REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_276 {
@ Minimum space between AADUM in horizontal direction, overlap is not allowed. >= 0.288um
 err1 = EXT (ANGLE AADUM == 90) < 0.288 ABUT<90 REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_277 {
@ Minimum space between GTDUM in vertical direction, overlap is not allowed. >= 0.164um
 err1 = EXT (ANGLE GTDUM == 0) < 0.164 ABUT<90 REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_278 {
@ Minimum space between GTDUM in horizontal direction, overlap is not allowed. >= 0.164um
 err1 = EXT (ANGLE GTDUM == 90) < 0.164 ABUT<90 REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_279 {
@ Minimum space between ARDUM in vertical direction, overlap is not allowed. >= 0.108um
 err1 = EXT (ANGLE ARDUM == 0) < 0.108 ABUT<90 REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_280 {
@ Minimum space between ARDUM in horizontal direction, overlap is not allowed. >= 0.108um
 err1 = EXT (ANGLE ARDUM == 90) < 0.108 ABUT<90 REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_281 {
@ Minimum space between P2DUM in vertical direction, overlap is not allowed. >= 0.27um
 err1 = EXT (ANGLE P2DUM == 0) < 0.27 ABUT<90 REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_282 {
@ Minimum space between P2DUM in horizontal direction, overlap is not allowed. >= 0.27um
 err1 = EXT (ANGLE P2DUM == 90) < 0.27 ABUT<90 REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_283 {
@ Minimum space between M0DUM in vertical direction, overlap is not allowed. >= 0.164um
 err1 = EXT (ANGLE M0DUM == 0) < 0.164 ABUT<90 REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_284 {
@ Minimum space between M0DUM in horizontal direction, overlap is not allowed. >= 0.164um
 err1 = EXT (ANGLE M0DUM == 90) < 0.164 ABUT<90 REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_285 {
@ Minimum space between M0GDUM in vertical direction, overlap is not allowed. >= 0.27um
 err1 = EXT (ANGLE M0GDUM == 0) < 0.27 ABUT<90 REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_286 {
@ Minimum space between M0GDUM in horizontal direction, overlap is not allowed. >= 0.27um
 err1 = EXT (ANGLE M0GDUM == 90) < 0.27 ABUT<90 REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_287 {
@ Minimum space between M0CDUM in vertical direction, overlap is not allowed. >= 0.3um
 err1 = EXT (ANGLE M0CDUM == 0) < 0.3 ABUT<90 REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_288 {
@ Minimum space between M0CDUM in horizontal direction, overlap is not allowed. >= 0.3um
 err1 = EXT (ANGLE M0CDUM == 90) < 0.3 ABUT<90 REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_289 {
@ Minimum space between SNDUM in vertical direction, overlap is not allowed. >= 0.3um
 err1 = EXT (ANGLE SNDUM == 0) < 0.3 ABUT<90 REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_290 {
@ Minimum space between SNDUM in horizontal direction, overlap is not allowed. >= 0.3um
 err1 = EXT (ANGLE SNDUM == 90) < 0.3 ABUT<90 REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_291 {
@ Minimum space between SPDUM in vertical direction, overlap is not allowed. >= 0.3um
 err1 = EXT (ANGLE SPDUM == 0) < 0.3 ABUT<90 REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_292 {
@ Minimum space between SPDUM in horizontal direction, overlap is not allowed. >= 0.3um
 err1 = EXT (ANGLE SPDUM == 90) < 0.3 ABUT<90 REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_293 {
@ Minimum space between AR_HDOP in vertical direction, overlap is not allowed. >= 0.096um
 err1 = EXT (ANGLE AR_HDOP == 0) < 0.096 ABUT<90 REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_294 {
@ Minimum space between AR_HDOP in horizontal direction, overlap is not allowed. >= 0.096um
 err1 = EXT (ANGLE AR_HDOP == 90) < 0.096 ABUT<90 REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_295 {
@ Minimum space between AR_VDOP in vertical direction, overlap is not allowed. >= 0.096um
 err1 = EXT (ANGLE AR_VDOP == 0) < 0.096 ABUT<90 REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_296 {
@ Minimum space between AR_VDOP in horizontal direction, overlap is not allowed. >= 0.142um
 err1 = EXT (ANGLE AR_VDOP == 90) < 0.142 ABUT<90 REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_297 {
@ Minimum space between AADOP in vertical direction, overlap is not allowed. >= 0.318um
 err1 = EXT (ANGLE AADOP == 0) < 0.318 ABUT<90 REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_298 {
@ Minimum space between AADOP in horizontal direction, overlap is not allowed. >= 0.318um
 err1 = EXT (ANGLE AADOP == 90) < 0.318 ABUT<90 REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_299 {
@ Minimum space between GTDOP in vertical direction, overlap is not allowed. >= 0.118um
 err1 = EXT (ANGLE GTDOP == 0) < 0.118 ABUT<90 REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_300 {
@ Minimum space between GTDOP in horizontal direction, overlap is not allowed. >= 0.072um
 err1 = EXT (ANGLE GTDOP == 90) < 0.072 ABUT<90 REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_301 {
@ Minimum space between ARDOP in vertical direction, overlap is not allowed. >= 0.228um
 err1 = EXT (ANGLE ARDOP == 0) < 0.228 ABUT<90 REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_302 {
@ Minimum space between ARDOP in horizontal direction, overlap is not allowed. >= 0.192um
 err1 = EXT (ANGLE ARDOP == 90) < 0.192 ABUT<90 REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_303 {
@ Minimum space between P2DOP in vertical direction, overlap is not allowed. >= 0.19um
 err1 = EXT (ANGLE P2DOP == 0) < 0.19 ABUT<90 REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_304 {
@ Minimum space between P2DOP in horizontal direction, overlap is not allowed. >= 0.19um
 err1 = EXT (ANGLE P2DOP == 90) < 0.19 ABUT<90 REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_305 {
@ Minimum space between M0DOP in vertical direction, overlap is not allowed. >= 0.2um
 err1 = EXT (ANGLE M0DOP == 0) < 0.2 ABUT<90 REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_306 {
@ Minimum space between M0DOP in horizontal direction, overlap is not allowed. >= 0.066um
 err1 = EXT (ANGLE M0DOP == 90) < 0.066 ABUT<90 REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_307 {
@ Minimum space between M0GDOP in vertical direction, overlap is not allowed. >= 0.182um
 err1 = EXT (ANGLE M0GDOP == 0) < 0.182 ABUT<90 REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_308 {
@ Minimum space between M0GDOP in horizontal direction, overlap is not allowed. >= 0.094um
 err1 = EXT (ANGLE M0GDOP == 90) < 0.094 ABUT<90 REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_309 {
@ Minimum space between M0CDOP in vertical direction, overlap is not allowed. >= 0.18um
 err1 = EXT (ANGLE M0CDOP == 0) < 0.18 ABUT<90 REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_310 {
@ Minimum space between M0CDOP in horizontal direction, overlap is not allowed. >= 0.18um
 err1 = EXT (ANGLE M0CDOP == 90) < 0.18 ABUT<90 REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_311 {
@ Minimum space between AADUM and AADOP, overlap is not allowed. >= 0.27um
 err1 = EXT AADUM AADOP < 0.27 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_312 {
@ Minimum space between GTDUM and GTDOP, overlap is not allowed. >= 0.27um
 err1 = EXT GTDUM GTDOP < 0.27 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_313 {
@ Minimum space between ARDUM and ARDOP, overlap is not allowed. >= 0.182um
 err1 = EXT ARDUM ARDOP < 0.182 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_314 {
@ Minimum space between P2DUM and P2DOP, overlap is not allowed. >= 0.27um
 err1 = EXT P2DUM P2DOP < 0.27 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_315 {
@ Minimum space between M0DUM and M0DOP, overlap is not allowed. >= 0.27um
 err1 = EXT M0DUM M0DOP < 0.27 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_316 {
@ Minimum space between M0GDUM and M0GDOP, overlap is not allowed. >= 0.27um
 err1 = EXT M0GDUM M0GDOP < 0.27 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_317 {
@ Minimum space between M0CDUM and M0CDOP, overlap is not allowed. >= 0.27um
 err1 = EXT M0CDUM M0CDOP < 0.27 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_318 {
@ DMC10 space to OCCDFH, overlap is not allowed. >= 0.8um
 err1 = EXT DMC10 OCCDFH < 0.8 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_319 {
@ DMC11, DMC12 space to OCCDFH, overlap is not allowed. >= 0.32um
 err1 = EXT DMC11 OCCDFH < 0.32 ABUT<90 SINGULAR REGION INSIDE ALSO
 err2 = EXT DMC12 OCCDFH < 0.32 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

DUMC_320 {
@ DMC2, DMC3, DMC4, DMC5, DMC6, DMC7, DMC8, DMC9 space to OCOVL_NOT_OCOVLM4, Overlap is not allowed. >= 0.4um
 err1 = EXT DMC2 OCOVL_NOT_OCOVLM4 < 0.4 ABUT<90 SINGULAR REGION INSIDE ALSO
 err2 = EXT DMC3 OCOVL_NOT_OCOVLM4 < 0.4 ABUT<90 SINGULAR REGION INSIDE ALSO
 err3 = EXT DMC4 OCOVL_NOT_OCOVLM4 < 0.4 ABUT<90 SINGULAR REGION INSIDE ALSO
 err4 = EXT DMC5 OCOVL_NOT_OCOVLM4 < 0.4 ABUT<90 SINGULAR REGION INSIDE ALSO
 err5 = EXT DMC6 OCOVL_NOT_OCOVLM4 < 0.4 ABUT<90 SINGULAR REGION INSIDE ALSO
 err6 = EXT DMC7 OCOVL_NOT_OCOVLM4 < 0.4 ABUT<90 SINGULAR REGION INSIDE ALSO
 err7 = EXT DMC8 OCOVL_NOT_OCOVLM4 < 0.4 ABUT<90 SINGULAR REGION INSIDE ALSO
 err8 = EXT DMC9 OCOVL_NOT_OCOVLM4 < 0.4 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
 err4 NOT INSIDE SealR_NOT_BULK
 err5 NOT INSIDE SealR_NOT_BULK
 err6 NOT INSIDE SealR_NOT_BULK
 err7 NOT INSIDE SealR_NOT_BULK
 err8 NOT INSIDE SealR_NOT_BULK
}

DUMC_321_DMC1 {
@ DMC1, DMC8, DMC9 space to (V0DUM NOT INSIDE DMCMK1) or (V0DPDUM NOT INSIDE DMCMK1), Overlap is not allowed. >= 0um
 err1 = AND DMC1 (OR V0DUM_outside_DMCMK1 V0DPDUM_outside_DMCMK1)
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_321_DMC8 {
@ DMC1, DMC8, DMC9 space to (V0DUM NOT INSIDE DMCMK1) or (V0DPDUM NOT INSIDE DMCMK1), Overlap is not allowed. >= 0um
 err1 = AND DMC8 (OR V0DUM_outside_DMCMK1 V0DPDUM_outside_DMCMK1)
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_321_DMC9 {
@ DMC1, DMC8, DMC9 space to (V0DUM NOT INSIDE DMCMK1) or (V0DPDUM NOT INSIDE DMCMK1), Overlap is not allowed. >= 0um
 err1 = AND DMC9 (OR V0DUM_outside_DMCMK1 V0DPDUM_outside_DMCMK1)
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_322 {
@ DMC2, DMC3, DMC4, DMC5, DMC6, DMC7 space to (V0DUM NOT INSIDE DMCMK1) or (V0DPDUM NOT INSIDE DMCMK1), Overlap is not allowed. >= 0.04um
 err0 = OR V0DUM_outside_DMCMK1 V0DPDUM_outside_DMCMK1
 err1 = EXT DMC2 err0 < 0.04 ABUT<90 SINGULAR REGION INSIDE ALSO
 err2 = EXT DMC3 err0 < 0.04 ABUT<90 SINGULAR REGION INSIDE ALSO
 err3 = EXT DMC4 err0 < 0.04 ABUT<90 SINGULAR REGION INSIDE ALSO
 err4 = EXT DMC5 err0 < 0.04 ABUT<90 SINGULAR REGION INSIDE ALSO
 err5 = EXT DMC6 err0 < 0.04 ABUT<90 SINGULAR REGION INSIDE ALSO
 err6 = EXT DMC7 err0 < 0.04 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
 err4 NOT INSIDE SealR_NOT_BULK
 err5 NOT INSIDE SealR_NOT_BULK
 err6 NOT INSIDE SealR_NOT_BULK
}

DUMC_323 {
@ AR_HDOP or AR_VDOP must be fully covered by ARBL
 err1 = NOT INSIDE (OR AR_HDOP AR_VDOP) ARBL
 err1 NOT INSIDE SealR_NOT_BULK
}


// =======================================================
// For BEOL Dummy Pattern Check Rules
// =======================================================

 
DUMC_401_M1 {
@ Space between MnDUM or MnDPDUM and Mn or MnDP (n = 1~3), Overlap is not allowed, except MARKS region. >= 0.75um
 err1 = EXT M1DUM_all M1 < 0.75 ABUT<90 SINGULAR REGION INSIDE ALSO
 err2 = EXT M1DUM_all M1DP < 0.75 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE MARKS
 err2 NOT INSIDE MARKS
}
 
DUMC_402_M1 {
@ Space between MnDUM or MnDPDUM and Mn or MnDP (width >= 2um) (n = 1~3), Overlap is not allowed, except MARKS region. >= 0.898um
 chk_mn = (OR M1 M1DP) WITH WIDTH >= 2
 err1 = EXT M1DUM_all chk_mn < 0.898 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE MARKS
}
 
DUMC_403_M1_NODMF {
@ Space between MnDUM or MnDPDUM and NODMF, MARKG, MARKS. (n = 1~3), Overlap is not allowed. >= 0.6um
 err1 = EXT M1DUM_all NODMF < 0.6 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_403_M1_MARKG {
@ Space between MnDUM or MnDPDUM and NODMF, MARKG, MARKS. (n = 1~3), Overlap is not allowed. >= 0.6um
 err1 = EXT M1DUM_all MARKG < 0.6 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_403_M1_MARKS {
@ Space between MnDUM or MnDPDUM and NODMF, MARKG, MARKS. (n = 1~3), Overlap is not allowed. >= 0.6um
 err1 = EXT M1DUM_all MARKS < 0.6 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_404_M1 {
@ Space between MnDUM or MnDPDUM and MnDUB (n = 1~3), Overlap is not allowed. >= 0.6um
 err1 = EXT M1DUM_all M1DUB < 0.6 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_405_M1 {
@ Space between MnDUM or MnDPDUM and INST (for INST only n = 1~2), Overlap is not allowed. >= 0.6um
 err1 = EXT M1DUM_all INST < 0.6 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

#IFDEF CHIPB_RULES_CHECK YES

 
DUMC_406_M1 {
@ Inside edge of CHIPB space to MnDUM or MnDPDUM (n = 1~3). Outside and cut is not allowed. >= 2um
 err1 = ENC M1DUM_all CHIPB < 2 ABUT<90 SINGULAR REGION OUTSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

#ENDIF

 
DUMC_407_M1 {
@ Space between MnDUM or MnDPDUM and MTFUSE (n = 1~3), Overlap is not allowed. >= 1um
 err1 = EXT M1DUM_all MTFUSE < 1 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_408_M1 {
@ Space between MnDUM or MnDPDUM and 45-degree Mn (n = 1~3), Overlap is not allowed. >= 0.75um
 err1 = EXT M1DUM_all M1_45_skew_edges < 0.75 ABUT<90 OPPOSITE2 REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_401_M2 {
@ Space between MnDUM or MnDPDUM and Mn or MnDP (n = 1~3), Overlap is not allowed, except MARKS region. >= 0.75um
 err1 = EXT M2DUM_all M2 < 0.75 ABUT<90 SINGULAR REGION INSIDE ALSO
 err2 = EXT M2DUM_all M2DP < 0.75 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE MARKS
 err2 NOT INSIDE MARKS
}
 
DUMC_402_M2 {
@ Space between MnDUM or MnDPDUM and Mn or MnDP (width >= 2um) (n = 1~3), Overlap is not allowed, except MARKS region. >= 0.898um
 chk_mn = (OR M2 M2DP) WITH WIDTH >= 2
 err1 = EXT M2DUM_all chk_mn < 0.898 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE MARKS
}
 
DUMC_403_M2_NODMF {
@ Space between MnDUM or MnDPDUM and NODMF, MARKG, MARKS. (n = 1~3), Overlap is not allowed. >= 0.6um
 err1 = EXT M2DUM_all NODMF < 0.6 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_403_M2_MARKG {
@ Space between MnDUM or MnDPDUM and NODMF, MARKG, MARKS. (n = 1~3), Overlap is not allowed. >= 0.6um
 err1 = EXT M2DUM_all MARKG < 0.6 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_403_M2_MARKS {
@ Space between MnDUM or MnDPDUM and NODMF, MARKG, MARKS. (n = 1~3), Overlap is not allowed. >= 0.6um
 err1 = EXT M2DUM_all MARKS < 0.6 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_404_M2 {
@ Space between MnDUM or MnDPDUM and MnDUB (n = 1~3), Overlap is not allowed. >= 0.6um
 err1 = EXT M2DUM_all M2DUB < 0.6 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_405_M2 {
@ Space between MnDUM or MnDPDUM and INST (for INST only n = 1~2), Overlap is not allowed. >= 0.6um
 err1 = EXT M2DUM_all INST < 0.6 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

#IFDEF CHIPB_RULES_CHECK YES

 
DUMC_406_M2 {
@ Inside edge of CHIPB space to MnDUM or MnDPDUM (n = 1~3). Outside and cut is not allowed. >= 2um
 err1 = ENC M2DUM_all CHIPB < 2 ABUT<90 SINGULAR REGION OUTSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

#ENDIF

 
DUMC_407_M2 {
@ Space between MnDUM or MnDPDUM and MTFUSE (n = 1~3), Overlap is not allowed. >= 1um
 err1 = EXT M2DUM_all MTFUSE < 1 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_408_M2 {
@ Space between MnDUM or MnDPDUM and 45-degree Mn (n = 1~3), Overlap is not allowed. >= 0.75um
 err1 = EXT M2DUM_all M2_45_skew_edges < 0.75 ABUT<90 OPPOSITE2 REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_401_M3 {
@ Space between MnDUM or MnDPDUM and Mn or MnDP (n = 1~3), Overlap is not allowed, except MARKS region. >= 0.75um
 err1 = EXT M3DUM_all M3 < 0.75 ABUT<90 SINGULAR REGION INSIDE ALSO
 err2 = EXT M3DUM_all M3DP < 0.75 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE MARKS
 err2 NOT INSIDE MARKS
}
 
DUMC_402_M3 {
@ Space between MnDUM or MnDPDUM and Mn or MnDP (width >= 2um) (n = 1~3), Overlap is not allowed, except MARKS region. >= 0.898um
 chk_mn = (OR M3 M3DP) WITH WIDTH >= 2
 err1 = EXT M3DUM_all chk_mn < 0.898 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE MARKS
}
 
DUMC_403_M3_NODMF {
@ Space between MnDUM or MnDPDUM and NODMF, MARKG, MARKS. (n = 1~3), Overlap is not allowed. >= 0.6um
 err1 = EXT M3DUM_all NODMF < 0.6 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_403_M3_MARKG {
@ Space between MnDUM or MnDPDUM and NODMF, MARKG, MARKS. (n = 1~3), Overlap is not allowed. >= 0.6um
 err1 = EXT M3DUM_all MARKG < 0.6 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_403_M3_MARKS {
@ Space between MnDUM or MnDPDUM and NODMF, MARKG, MARKS. (n = 1~3), Overlap is not allowed. >= 0.6um
 err1 = EXT M3DUM_all MARKS < 0.6 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_404_M3 {
@ Space between MnDUM or MnDPDUM and MnDUB (n = 1~3), Overlap is not allowed. >= 0.6um
 err1 = EXT M3DUM_all M3DUB < 0.6 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

#IFDEF CHIPB_RULES_CHECK YES

 
DUMC_406_M3 {
@ Inside edge of CHIPB space to MnDUM or MnDPDUM (n = 1~3). Outside and cut is not allowed. >= 2um
 err1 = ENC M3DUM_all CHIPB < 2 ABUT<90 SINGULAR REGION OUTSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

#ENDIF

 
DUMC_407_M3 {
@ Space between MnDUM or MnDPDUM and MTFUSE (n = 1~3), Overlap is not allowed. >= 1um
 err1 = EXT M3DUM_all MTFUSE < 1 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_408_M3 {
@ Space between MnDUM or MnDPDUM and 45-degree Mn (n = 1~3), Overlap is not allowed. >= 0.75um
 err1 = EXT M3DUM_all M3_45_skew_edges < 0.75 ABUT<90 OPPOSITE2 REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_409_M4 {
@ Space between MnDUM and Mn (n>=4), Overlap is not allowed, except MARKS region. >= 0.75um
 err1 = EXT M4DUM M4 < 0.75 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE MARKS
}
 
DUMC_410_M4 {
@ Space between MnDUM and Mn (width >= 2um) (n>=4), Overlap is not allowed, except MARKS region. >= 0.898um
 chk_mn = M4 WITH WIDTH >= 2
 err1 = EXT M4DUM chk_mn < 0.898 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE MARKS
}
 
DUMC_411_M4_NODMF {
@ Space between MnDUM and NODMF, MARKG, MARKS (n>=4), Overlap is not allowed. >= 0.6um
 err1 = EXT M4DUM NODMF < 0.6 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_411_M4_MARKG {
@ Space between MnDUM and NODMF, MARKG, MARKS (n>=4), Overlap is not allowed. >= 0.6um
 err1 = EXT M4DUM MARKG < 0.6 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_411_M4_MARKS {
@ Space between MnDUM and NODMF, MARKG, MARKS (n>=4), Overlap is not allowed. >= 0.6um
 err1 = EXT M4DUM MARKS < 0.6 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_412_M4 {
@ Space between MnDUM and MnDUB (n>=4), Overlap is not allowed. >= 0.6um
 err1 = EXT M4DUM M4DUB < 0.6 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

#IFDEF CHIPB_RULES_CHECK YES

 
DUMC_413_M4 {
@ Inside edge of CHIPB space to MnDUM (n>=4), Outside and cut is not allowed. >= 2um
 err1 = ENC M4DUM CHIPB < 2 ABUT<90 SINGULAR REGION OUTSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

#ENDIF

 
DUMC_414_M4 {
@ Space between MnDUM and 45-degree Mn (n>=4), Overlap is not allowed. >= 0.75um
 err1 = EXT M4DUM M4_45_skew_edges < 0.75 ABUT<90 OPPOSITE2 REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_409_M5 {
@ Space between MnDUM and Mn (n>=4), Overlap is not allowed, except MARKS region. >= 0.75um
 err1 = EXT M5DUM M5 < 0.75 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE MARKS
}
 
DUMC_410_M5 {
@ Space between MnDUM and Mn (width >= 2um) (n>=4), Overlap is not allowed, except MARKS region. >= 0.898um
 chk_mn = M5 WITH WIDTH >= 2
 err1 = EXT M5DUM chk_mn < 0.898 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE MARKS
}
 
DUMC_411_M5_NODMF {
@ Space between MnDUM and NODMF, MARKG, MARKS (n>=4), Overlap is not allowed. >= 0.6um
 err1 = EXT M5DUM NODMF < 0.6 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_411_M5_MARKG {
@ Space between MnDUM and NODMF, MARKG, MARKS (n>=4), Overlap is not allowed. >= 0.6um
 err1 = EXT M5DUM MARKG < 0.6 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_411_M5_MARKS {
@ Space between MnDUM and NODMF, MARKG, MARKS (n>=4), Overlap is not allowed. >= 0.6um
 err1 = EXT M5DUM MARKS < 0.6 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_412_M5 {
@ Space between MnDUM and MnDUB (n>=4), Overlap is not allowed. >= 0.6um
 err1 = EXT M5DUM M5DUB < 0.6 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

#IFDEF CHIPB_RULES_CHECK YES

 
DUMC_413_M5 {
@ Inside edge of CHIPB space to MnDUM (n>=4), Outside and cut is not allowed. >= 2um
 err1 = ENC M5DUM CHIPB < 2 ABUT<90 SINGULAR REGION OUTSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

#ENDIF

 
DUMC_414_M5 {
@ Space between MnDUM and 45-degree Mn (n>=4), Overlap is not allowed. >= 0.75um
 err1 = EXT M5DUM M5_45_skew_edges < 0.75 ABUT<90 OPPOSITE2 REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_409_M6 {
@ Space between MnDUM and Mn (n>=4), Overlap is not allowed, except MARKS region. >= 0.75um
 err1 = EXT M6DUM M6 < 0.75 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE MARKS
}
 
DUMC_410_M6 {
@ Space between MnDUM and Mn (width >= 2um) (n>=4), Overlap is not allowed, except MARKS region. >= 0.898um
 chk_mn = M6 WITH WIDTH >= 2
 err1 = EXT M6DUM chk_mn < 0.898 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE MARKS
}
 
DUMC_411_M6_NODMF {
@ Space between MnDUM and NODMF, MARKG, MARKS (n>=4), Overlap is not allowed. >= 0.6um
 err1 = EXT M6DUM NODMF < 0.6 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_411_M6_MARKG {
@ Space between MnDUM and NODMF, MARKG, MARKS (n>=4), Overlap is not allowed. >= 0.6um
 err1 = EXT M6DUM MARKG < 0.6 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_411_M6_MARKS {
@ Space between MnDUM and NODMF, MARKG, MARKS (n>=4), Overlap is not allowed. >= 0.6um
 err1 = EXT M6DUM MARKS < 0.6 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_412_M6 {
@ Space between MnDUM and MnDUB (n>=4), Overlap is not allowed. >= 0.6um
 err1 = EXT M6DUM M6DUB < 0.6 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

#IFDEF CHIPB_RULES_CHECK YES

 
DUMC_413_M6 {
@ Inside edge of CHIPB space to MnDUM (n>=4), Outside and cut is not allowed. >= 2um
 err1 = ENC M6DUM CHIPB < 2 ABUT<90 SINGULAR REGION OUTSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

#ENDIF

 
DUMC_414_M6 {
@ Space between MnDUM and 45-degree Mn (n>=4), Overlap is not allowed. >= 0.75um
 err1 = EXT M6DUM M6_45_skew_edges < 0.75 ABUT<90 OPPOSITE2 REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_409_M7 {
@ Space between MnDUM and Mn (n>=4), Overlap is not allowed, except MARKS region. >= 0.75um
 err1 = EXT M7DUM M7 < 0.75 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE MARKS
}
 
DUMC_410_M7 {
@ Space between MnDUM and Mn (width >= 2um) (n>=4), Overlap is not allowed, except MARKS region. >= 0.898um
 chk_mn = M7 WITH WIDTH >= 2
 err1 = EXT M7DUM chk_mn < 0.898 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE MARKS
}
 
DUMC_411_M7_NODMF {
@ Space between MnDUM and NODMF, MARKG, MARKS (n>=4), Overlap is not allowed. >= 0.6um
 err1 = EXT M7DUM NODMF < 0.6 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_411_M7_MARKG {
@ Space between MnDUM and NODMF, MARKG, MARKS (n>=4), Overlap is not allowed. >= 0.6um
 err1 = EXT M7DUM MARKG < 0.6 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_411_M7_MARKS {
@ Space between MnDUM and NODMF, MARKG, MARKS (n>=4), Overlap is not allowed. >= 0.6um
 err1 = EXT M7DUM MARKS < 0.6 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_412_M7 {
@ Space between MnDUM and MnDUB (n>=4), Overlap is not allowed. >= 0.6um
 err1 = EXT M7DUM M7DUB < 0.6 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

#IFDEF CHIPB_RULES_CHECK YES

 
DUMC_413_M7 {
@ Inside edge of CHIPB space to MnDUM (n>=4), Outside and cut is not allowed. >= 2um
 err1 = ENC M7DUM CHIPB < 2 ABUT<90 SINGULAR REGION OUTSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

#ENDIF

 
DUMC_414_M7 {
@ Space between MnDUM and 45-degree Mn (n>=4), Overlap is not allowed. >= 0.75um
 err1 = EXT M7DUM M7_45_skew_edges < 0.75 ABUT<90 OPPOSITE2 REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_423_TM2 {
@ Space between TMnDUM and TMn or TMn_40, Overlap is not allowed, except MARKS region. >= 0.75um
 err1 = EXT TM2DUM TM2 < 0.75 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE MARKS
}
 
DUMC_424_TM2 {
@ Space between TMnDUM and TMn or TMn_40 (width >= 4um), Overlap is not allowed, except MARKS region. >= 1.898um
 chk_TM2 = TM2 WITH WIDTH >= 4
 err1 = EXT TM2DUM chk_TM2 < 1.898 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE MARKS
}
 
DUMC_425_TM2 {
@ Space between TMnDUM and TMn or TMn_40 (width >= 7.0um), Overlap is not allowed, except MARKS region. >= 3um
 chk_TM2 = (TM2 WITH WIDTH >= 4) WITH WIDTH >= 7.0
 err1 = EXT TM2DUM chk_TM2 < 3.0 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE MARKS
}
 
DUMC_426_TM2 {
@ Space between TMnDUM and TMn or TMn_40 (width >= 10um), Overlap is not allowed, except MARKS region. >= 4.5um
 chk_TM2 = (TM2 WITH WIDTH >= 4) WITH WIDTH >= 10
 err1 = EXT TM2DUM chk_TM2 < 4.5 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE MARKS
}
 
DUMC_427_TM2_TM2DUB {
@ Space between TMnDUM and TMnDUB, NODMF, MARKG, MARKS, Overlap is not allowed. >= 0.7um
 err1 = EXT TM2DUM TM2DUB < 0.7 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_427_TM2_NODMF {
@ Space between TMnDUM and TMnDUB, NODMF, MARKG, MARKS, Overlap is not allowed. >= 0.7um
 err1 = EXT TM2DUM NODMF < 0.7 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_427_TM2_MARKG {
@ Space between TMnDUM and TMnDUB, NODMF, MARKG, MARKS, Overlap is not allowed. >= 0.7um
 err1 = EXT TM2DUM MARKG < 0.7 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_427_TM2_MARKS {
@ Space between TMnDUM and TMnDUB, NODMF, MARKG, MARKS, Overlap is not allowed. >= 0.7um
 err1 = EXT TM2DUM MARKS < 0.7 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

#IFDEF CHIPB_RULES_CHECK YES

 
DUMC_428_TM2 {
@ Inside edge of CHIPB space to TMnDUM, Outside and cut is not allowed. >= 2um
 err1 = ENC TM2DUM CHIPB < 2 ABUT<90 SINGULAR REGION OUTSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

#ENDIF

 
DUMC_429_TM2 {
@ Space between TMnDUM and 45-degree TMn or TMn_40, Overlap is not allowed, except MARKS region. >= 0.75um
 chk_TM2 = ANGLE TM2 > 44.5 < 45.5
 err1 = EXT TM2DUM chk_TM2 < 0.75 ABUT<90 OPPOSITE2 REGION INSIDE ALSO
 err1 NOT INSIDE MARKS
}

DUMC_434 {
@ Space between ALDUM and ALPA, Overlap is not allowed. >= 2.85um
 err1 = EXT ALDUM ALPA < 2.85 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_435_ALDUB {
@ Space between ALDUM and ALDUB, NODMF, MARKG, MARKS, Overlap is not allowed. >= 2.85um
 err1 = EXT ALDUM ALDUB < 2.85 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_435_NODMF {
@ Space between ALDUM and ALDUB, NODMF, MARKG, MARKS, Overlap is not allowed. >= 2.85um
 err1 = EXT ALDUM NODMF < 2.85 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_435_MARKG {
@ Space between ALDUM and ALDUB, NODMF, MARKG, MARKS, Overlap is not allowed. >= 2.85um
 err1 = EXT ALDUM MARKG < 2.85 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_435_MARKS {
@ Space between ALDUM and ALDUB, NODMF, MARKG, MARKS, Overlap is not allowed. >= 2.85um
 err1 = EXT ALDUM MARKS < 2.85 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

#IFDEF CHIPB_RULES_CHECK YES
DUMC_436 {
@ Inside edge of CHIPB space to ALDUM, Outside and cut is not allowed. >= 2um
 err1 = ENC ALDUM CHIPB < 2 ABUT<90 SINGULAR REGION OUTSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
#ENDIF

DUMC_437 {
@ Space between ALDUM and 45-degree ALPA, Overlap is not allowed. >= 2.85um
 chk_edge = ANGLE ALPA > 44.5 < 45.5
 err1 = EXT ALDUM chk_edge < 2.85 ABUT<90 OPPOSITE2 REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

 
DUMC_438_V1 {
@ Space between VnDUM (n = 1~7) and Vn, Overlap is not allowed, except MARKS region. >= 0.75um
 err1 = EXT V1DUM_all V1 < 0.75 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE MARKS
}
 
DUMC_439_V1 {
@ Space between VnDUM (n = 1~7) and VnDUB, Overlap is not allowed. >= 0.6um
 err1 = EXT V1DUM_all V1DUB < 0.6 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_440_V1_MARKG {
@ Space between VnDUM (n = 1~7) and MARKG, MARKS, NODMF, Overlap is not allowed. >= 0.6um
 err1 = EXT V1DUM_all MARKG < 0.6 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_440_V1_MARKS {
@ Space between VnDUM (n = 1~7) and MARKG, MARKS, NODMF, Overlap is not allowed. >= 0.6um
 err1 = EXT V1DUM_all MARKS < 0.6 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_440_V1_NODMF {
@ Space between VnDUM (n = 1~7) and MARKG, MARKS, NODMF, Overlap is not allowed. >= 0.6um
 err1 = EXT V1DUM_all NODMF < 0.6 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_441_V1 {
@ Space between VnDUM (n = 1~7) and INDMY, Overlap is not allowed. >= 0.6um
 err1 = EXT V1DUM_all INDMY < 0.6 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_442_V1 {
@ Space between VnDUM and MTFUSE (only n = 1-3), Overlap is not allowed. >= 1um
 err1 = EXT V1DUM_all MTFUSE < 1.000 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_438_V2 {
@ Space between VnDUM (n = 1~7) and Vn, Overlap is not allowed, except MARKS region. >= 0.75um
 err1 = EXT V2DUM_all V2 < 0.75 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE MARKS
}
 
DUMC_439_V2 {
@ Space between VnDUM (n = 1~7) and VnDUB, Overlap is not allowed. >= 0.6um
 err1 = EXT V2DUM_all V2DUB < 0.6 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_440_V2_MARKG {
@ Space between VnDUM (n = 1~7) and MARKG, MARKS, NODMF, Overlap is not allowed. >= 0.6um
 err1 = EXT V2DUM_all MARKG < 0.6 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_440_V2_MARKS {
@ Space between VnDUM (n = 1~7) and MARKG, MARKS, NODMF, Overlap is not allowed. >= 0.6um
 err1 = EXT V2DUM_all MARKS < 0.6 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_440_V2_NODMF {
@ Space between VnDUM (n = 1~7) and MARKG, MARKS, NODMF, Overlap is not allowed. >= 0.6um
 err1 = EXT V2DUM_all NODMF < 0.6 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_441_V2 {
@ Space between VnDUM (n = 1~7) and INDMY, Overlap is not allowed. >= 0.6um
 err1 = EXT V2DUM_all INDMY < 0.6 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_442_V2 {
@ Space between VnDUM and MTFUSE (only n = 1-3), Overlap is not allowed. >= 1um
 err1 = EXT V2DUM_all MTFUSE < 1.000 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_438_V3 {
@ Space between VnDUM (n = 1~7) and Vn, Overlap is not allowed, except MARKS region. >= 0.75um
 err1 = EXT V3DUM_all V3 < 0.75 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE MARKS
}
 
DUMC_439_V3 {
@ Space between VnDUM (n = 1~7) and VnDUB, Overlap is not allowed. >= 0.6um
 err1 = EXT V3DUM_all V3DUB < 0.6 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_440_V3_MARKG {
@ Space between VnDUM (n = 1~7) and MARKG, MARKS, NODMF, Overlap is not allowed. >= 0.6um
 err1 = EXT V3DUM_all MARKG < 0.6 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_440_V3_MARKS {
@ Space between VnDUM (n = 1~7) and MARKG, MARKS, NODMF, Overlap is not allowed. >= 0.6um
 err1 = EXT V3DUM_all MARKS < 0.6 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_440_V3_NODMF {
@ Space between VnDUM (n = 1~7) and MARKG, MARKS, NODMF, Overlap is not allowed. >= 0.6um
 err1 = EXT V3DUM_all NODMF < 0.6 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_441_V3 {
@ Space between VnDUM (n = 1~7) and INDMY, Overlap is not allowed. >= 0.6um
 err1 = EXT V3DUM_all INDMY < 0.6 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_442_V3 {
@ Space between VnDUM and MTFUSE (only n = 1-3), Overlap is not allowed. >= 1um
 err1 = EXT V3DUM_all MTFUSE < 1.000 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_438_V4 {
@ Space between VnDUM (n = 1~7) and Vn, Overlap is not allowed, except MARKS region. >= 0.75um
 err1 = EXT V4DUM V4 < 0.75 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE MARKS
}
 
DUMC_439_V4 {
@ Space between VnDUM (n = 1~7) and VnDUB, Overlap is not allowed. >= 0.6um
 err1 = EXT V4DUM V4DUB < 0.6 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_440_V4_MARKG {
@ Space between VnDUM (n = 1~7) and MARKG, MARKS, NODMF, Overlap is not allowed. >= 0.6um
 err1 = EXT V4DUM MARKG < 0.6 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_440_V4_MARKS {
@ Space between VnDUM (n = 1~7) and MARKG, MARKS, NODMF, Overlap is not allowed. >= 0.6um
 err1 = EXT V4DUM MARKS < 0.6 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_440_V4_NODMF {
@ Space between VnDUM (n = 1~7) and MARKG, MARKS, NODMF, Overlap is not allowed. >= 0.6um
 err1 = EXT V4DUM NODMF < 0.6 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_441_V4 {
@ Space between VnDUM (n = 1~7) and INDMY, Overlap is not allowed. >= 0.6um
 err1 = EXT V4DUM INDMY < 0.6 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_438_V5 {
@ Space between VnDUM (n = 1~7) and Vn, Overlap is not allowed, except MARKS region. >= 0.75um
 err1 = EXT V5DUM V5 < 0.75 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE MARKS
}
 
DUMC_439_V5 {
@ Space between VnDUM (n = 1~7) and VnDUB, Overlap is not allowed. >= 0.6um
 err1 = EXT V5DUM V5DUB < 0.6 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_440_V5_MARKG {
@ Space between VnDUM (n = 1~7) and MARKG, MARKS, NODMF, Overlap is not allowed. >= 0.6um
 err1 = EXT V5DUM MARKG < 0.6 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_440_V5_MARKS {
@ Space between VnDUM (n = 1~7) and MARKG, MARKS, NODMF, Overlap is not allowed. >= 0.6um
 err1 = EXT V5DUM MARKS < 0.6 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_440_V5_NODMF {
@ Space between VnDUM (n = 1~7) and MARKG, MARKS, NODMF, Overlap is not allowed. >= 0.6um
 err1 = EXT V5DUM NODMF < 0.6 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_441_V5 {
@ Space between VnDUM (n = 1~7) and INDMY, Overlap is not allowed. >= 0.6um
 err1 = EXT V5DUM INDMY < 0.6 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_438_V6 {
@ Space between VnDUM (n = 1~7) and Vn, Overlap is not allowed, except MARKS region. >= 0.75um
 err1 = EXT V6DUM V6 < 0.75 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE MARKS
}
 
DUMC_439_V6 {
@ Space between VnDUM (n = 1~7) and VnDUB, Overlap is not allowed. >= 0.6um
 err1 = EXT V6DUM V6DUB < 0.6 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_440_V6_MARKG {
@ Space between VnDUM (n = 1~7) and MARKG, MARKS, NODMF, Overlap is not allowed. >= 0.6um
 err1 = EXT V6DUM MARKG < 0.6 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_440_V6_MARKS {
@ Space between VnDUM (n = 1~7) and MARKG, MARKS, NODMF, Overlap is not allowed. >= 0.6um
 err1 = EXT V6DUM MARKS < 0.6 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_440_V6_NODMF {
@ Space between VnDUM (n = 1~7) and MARKG, MARKS, NODMF, Overlap is not allowed. >= 0.6um
 err1 = EXT V6DUM NODMF < 0.6 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_441_V6 {
@ Space between VnDUM (n = 1~7) and INDMY, Overlap is not allowed. >= 0.6um
 err1 = EXT V6DUM INDMY < 0.6 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_447_M1 {
@ Space between MnDOP or MnDPDOP and Mn (n = 1~3), Overlap is not allowed. >= 0.12um
 err1 = EXT M1DOP_all M1 < 0.12 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_451_M1 {
@ Space between MnDOP or MnDPDOP to Mn (width >= 0.18um) (n = 1~3), Overlap is not allowed. >= 0.15um
 chk_mn = M1 WITH WIDTH >= 0.18
 err1 = EXT M1DOP_all chk_mn < 0.15 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_452_M1 {
@ Space between MnDOP or MnDPDOP to Mn (width >= 0.50um) (n = 1~3), Overlap is not allowed. >= 0.22um
 chk_mn = (M1 WITH WIDTH >= 0.18) WITH WIDTH >= 0.50
 err1 = EXT M1DOP_all chk_mn < 0.22 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_453_M1 {
@ Space between MnDOP or MnDPDOP to Mn (width >= 1um) (n = 1~3), Overlap is not allowed. >= 0.45um
 chk_mn = M1 WITH WIDTH >= 1
 err1 = EXT M1DOP_all chk_mn < 0.45 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_454_M1 {
@ Space between MnDOP or MnDPDOP to Mn (width >= 2um) (n = 1~3), Overlap is not allowed. >= 0.898um
 chk_mn = (M1 WITH WIDTH >= 1) WITH WIDTH >= 2
 err1 = EXT M1DOP_all chk_mn < 0.898 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_455_M1_M1DUB {
@ Space between MnDOP or MnDPDOP and MnDUB, NODMF, MARKG, MARKS, LOGO, INST (for INST only n = 1~2) (n = 1~3), Overlap is not allowed. >= 0.6um
 err1 = EXT M1DOP_all M1DUB < 0.6 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_455_M1_NODMF {
@ Space between MnDOP or MnDPDOP and MnDUB, NODMF, MARKG, MARKS, LOGO, INST (for INST only n = 1~2) (n = 1~3), Overlap is not allowed. >= 0.6um
 err1 = EXT M1DOP_all NODMF < 0.6 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_455_M1_MARKG {
@ Space between MnDOP or MnDPDOP and MnDUB, NODMF, MARKG, MARKS, LOGO, INST (for INST only n = 1~2) (n = 1~3), Overlap is not allowed. >= 0.6um
 err1 = EXT M1DOP_all MARKG < 0.6 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_455_M1_MARKS {
@ Space between MnDOP or MnDPDOP and MnDUB, NODMF, MARKG, MARKS, LOGO, INST (for INST only n = 1~2) (n = 1~3), Overlap is not allowed. >= 0.6um
 err1 = EXT M1DOP_all MARKS < 0.6 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_455_M1_LOGO {
@ Space between MnDOP or MnDPDOP and MnDUB, NODMF, MARKG, MARKS, LOGO, INST (for INST only n = 1~2) (n = 1~3), Overlap is not allowed. >= 0.6um
 err1 = EXT M1DOP_all LOGO < 0.6 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_455_M1_INST {
@ Space between MnDOP or MnDPDOP and MnDUB, NODMF, MARKG, MARKS, LOGO, INST (for INST only n = 1~2) (n = 1~3), Overlap is not allowed. >= 0.6um
 err1 = EXT M1DOP_all INST < 0.6 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

#IFDEF CHIPB_RULES_CHECK YES

 
DUMC_456_M1 {
@ Inside edge of CHIPB space to MnDOP or MnDPDOP (n = 1~3), Outside and cut is not allowed. >= 2um
 err1 = ENC M1DOP_all CHIPB < 2 ABUT<90 SINGULAR REGION OUTSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

#ENDIF

 
DUMC_457_M1 {
@ Space between MnDOP or MnDPDOP and MTFUSE (only n = 1-3), Overlap is not allowed. >= 1um
 err1 = EXT M1DOP_all MTFUSE < 1 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_458_M1 {
@ Space between MnDOP or MnDPDOP to 45-degree Mn (n = 1~3), Overlap is not allowed. >= 0.175um
 chk_edge = ANGLE M1 > 44.5 < 45.5
 err1 = EXT M1DOP_all chk_edge < 0.175 ABUT<90 OPPOSITE2 REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_447_M2 {
@ Space between MnDOP or MnDPDOP and Mn (n = 1~3), Overlap is not allowed. >= 0.12um
 err1 = EXT M2DOP_all M2 < 0.12 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_451_M2 {
@ Space between MnDOP or MnDPDOP to Mn (width >= 0.18um) (n = 1~3), Overlap is not allowed. >= 0.15um
 chk_mn = M2 WITH WIDTH >= 0.18
 err1 = EXT M2DOP_all chk_mn < 0.15 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_452_M2 {
@ Space between MnDOP or MnDPDOP to Mn (width >= 0.50um) (n = 1~3), Overlap is not allowed. >= 0.22um
 chk_mn = (M2 WITH WIDTH >= 0.18) WITH WIDTH >= 0.50
 err1 = EXT M2DOP_all chk_mn < 0.22 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_453_M2 {
@ Space between MnDOP or MnDPDOP to Mn (width >= 1um) (n = 1~3), Overlap is not allowed. >= 0.45um
 chk_mn = M2 WITH WIDTH >= 1
 err1 = EXT M2DOP_all chk_mn < 0.45 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_454_M2 {
@ Space between MnDOP or MnDPDOP to Mn (width >= 2um) (n = 1~3), Overlap is not allowed. >= 0.898um
 chk_mn = (M2 WITH WIDTH >= 1) WITH WIDTH >= 2
 err1 = EXT M2DOP_all chk_mn < 0.898 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_455_M2_M2DUB {
@ Space between MnDOP or MnDPDOP and MnDUB, NODMF, MARKG, MARKS, LOGO, INST (for INST only n = 1~2) (n = 1~3), Overlap is not allowed. >= 0.6um
 err1 = EXT M2DOP_all M2DUB < 0.6 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_455_M2_NODMF {
@ Space between MnDOP or MnDPDOP and MnDUB, NODMF, MARKG, MARKS, LOGO, INST (for INST only n = 1~2) (n = 1~3), Overlap is not allowed. >= 0.6um
 err1 = EXT M2DOP_all NODMF < 0.6 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_455_M2_MARKG {
@ Space between MnDOP or MnDPDOP and MnDUB, NODMF, MARKG, MARKS, LOGO, INST (for INST only n = 1~2) (n = 1~3), Overlap is not allowed. >= 0.6um
 err1 = EXT M2DOP_all MARKG < 0.6 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_455_M2_MARKS {
@ Space between MnDOP or MnDPDOP and MnDUB, NODMF, MARKG, MARKS, LOGO, INST (for INST only n = 1~2) (n = 1~3), Overlap is not allowed. >= 0.6um
 err1 = EXT M2DOP_all MARKS < 0.6 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_455_M2_LOGO {
@ Space between MnDOP or MnDPDOP and MnDUB, NODMF, MARKG, MARKS, LOGO, INST (for INST only n = 1~2) (n = 1~3), Overlap is not allowed. >= 0.6um
 err1 = EXT M2DOP_all LOGO < 0.6 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_455_M2_INST {
@ Space between MnDOP or MnDPDOP and MnDUB, NODMF, MARKG, MARKS, LOGO, INST (for INST only n = 1~2) (n = 1~3), Overlap is not allowed. >= 0.6um
 err1 = EXT M2DOP_all INST < 0.6 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

#IFDEF CHIPB_RULES_CHECK YES

 
DUMC_456_M2 {
@ Inside edge of CHIPB space to MnDOP or MnDPDOP (n = 1~3), Outside and cut is not allowed. >= 2um
 err1 = ENC M2DOP_all CHIPB < 2 ABUT<90 SINGULAR REGION OUTSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

#ENDIF

 
DUMC_457_M2 {
@ Space between MnDOP or MnDPDOP and MTFUSE (only n = 1-3), Overlap is not allowed. >= 1um
 err1 = EXT M2DOP_all MTFUSE < 1 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_458_M2 {
@ Space between MnDOP or MnDPDOP to 45-degree Mn (n = 1~3), Overlap is not allowed. >= 0.175um
 chk_edge = ANGLE M2 > 44.5 < 45.5
 err1 = EXT M2DOP_all chk_edge < 0.175 ABUT<90 OPPOSITE2 REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_447_M3 {
@ Space between MnDOP or MnDPDOP and Mn (n = 1~3), Overlap is not allowed. >= 0.12um
 err1 = EXT M3DOP_all M3 < 0.12 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_451_M3 {
@ Space between MnDOP or MnDPDOP to Mn (width >= 0.18um) (n = 1~3), Overlap is not allowed. >= 0.15um
 chk_mn = M3 WITH WIDTH >= 0.18
 err1 = EXT M3DOP_all chk_mn < 0.15 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_452_M3 {
@ Space between MnDOP or MnDPDOP to Mn (width >= 0.50um) (n = 1~3), Overlap is not allowed. >= 0.22um
 chk_mn = (M3 WITH WIDTH >= 0.18) WITH WIDTH >= 0.50
 err1 = EXT M3DOP_all chk_mn < 0.22 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_453_M3 {
@ Space between MnDOP or MnDPDOP to Mn (width >= 1um) (n = 1~3), Overlap is not allowed. >= 0.45um
 chk_mn = M3 WITH WIDTH >= 1
 err1 = EXT M3DOP_all chk_mn < 0.45 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_454_M3 {
@ Space between MnDOP or MnDPDOP to Mn (width >= 2um) (n = 1~3), Overlap is not allowed. >= 0.898um
 chk_mn = (M3 WITH WIDTH >= 1) WITH WIDTH >= 2
 err1 = EXT M3DOP_all chk_mn < 0.898 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_455_M3_M3DUB {
@ Space between MnDOP or MnDPDOP and MnDUB, NODMF, MARKG, MARKS, LOGO, INST (for INST only n = 1~2) (n = 1~3), Overlap is not allowed. >= 0.6um
 err1 = EXT M3DOP_all M3DUB < 0.6 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_455_M3_NODMF {
@ Space between MnDOP or MnDPDOP and MnDUB, NODMF, MARKG, MARKS, LOGO, INST (for INST only n = 1~2) (n = 1~3), Overlap is not allowed. >= 0.6um
 err1 = EXT M3DOP_all NODMF < 0.6 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_455_M3_MARKG {
@ Space between MnDOP or MnDPDOP and MnDUB, NODMF, MARKG, MARKS, LOGO, INST (for INST only n = 1~2) (n = 1~3), Overlap is not allowed. >= 0.6um
 err1 = EXT M3DOP_all MARKG < 0.6 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_455_M3_MARKS {
@ Space between MnDOP or MnDPDOP and MnDUB, NODMF, MARKG, MARKS, LOGO, INST (for INST only n = 1~2) (n = 1~3), Overlap is not allowed. >= 0.6um
 err1 = EXT M3DOP_all MARKS < 0.6 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_455_M3_LOGO {
@ Space between MnDOP or MnDPDOP and MnDUB, NODMF, MARKG, MARKS, LOGO, INST (for INST only n = 1~2) (n = 1~3), Overlap is not allowed. >= 0.6um
 err1 = EXT M3DOP_all LOGO < 0.6 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

#IFDEF CHIPB_RULES_CHECK YES

 
DUMC_456_M3 {
@ Inside edge of CHIPB space to MnDOP or MnDPDOP (n = 1~3), Outside and cut is not allowed. >= 2um
 err1 = ENC M3DOP_all CHIPB < 2 ABUT<90 SINGULAR REGION OUTSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

#ENDIF

 
DUMC_457_M3 {
@ Space between MnDOP or MnDPDOP and MTFUSE (only n = 1-3), Overlap is not allowed. >= 1um
 err1 = EXT M3DOP_all MTFUSE < 1 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_458_M3 {
@ Space between MnDOP or MnDPDOP to 45-degree Mn (n = 1~3), Overlap is not allowed. >= 0.175um
 chk_edge = ANGLE M3 > 44.5 < 45.5
 err1 = EXT M3DOP_all chk_edge < 0.175 ABUT<90 OPPOSITE2 REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_459_M4 {
@ Space between MnDOP to Mn (n>=4), Overlap is not allowed. >= 0.12um
 err1 = EXT M4DOP M4 < 0.12 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_460_M4 {
@ Space between MnDOP to Mn (width >= 0.23um) (n>=4), Overlap is not allowed. >= 0.24um
 chk_M4 = M4 WITH WIDTH >= 0.23
 err1 = EXT M4DOP chk_M4 < 0.24 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_461_M4 {
@ Space between MnDOP to Mn (width >= 1um) (n>=4), Overlap is not allowed. >= 0.45um
 chk_M4 = (M4 WITH WIDTH >= 0.23) WITH WIDTH >= 1
 err1 = EXT M4DOP chk_M4 < 0.45 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_462_M4 {
@ Space between MnDOP to Mn (width >= 2um) (n>=4), Overlap is not allowed. >= 0.898um
 chk_M4 = (M4 WITH WIDTH >= 0.23) WITH WIDTH >= 2
 err1 = EXT M4DOP chk_M4 < 0.898 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_463_M4_M4DUB {
@ Space between MnDOP and MnDUB, NODMF, MARKG, MARKS, LOGO (n>=4), Overlap is not allowed. >= 0.6um
 err1 = EXT M4DOP_all M4DUB < 0.6 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_463_M4_NODMF {
@ Space between MnDOP and MnDUB, NODMF, MARKG, MARKS, LOGO (n>=4), Overlap is not allowed. >= 0.6um
 err1 = EXT M4DOP_all NODMF < 0.6 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_463_M4_MARKG {
@ Space between MnDOP and MnDUB, NODMF, MARKG, MARKS, LOGO (n>=4), Overlap is not allowed. >= 0.6um
 err1 = EXT M4DOP_all MARKG < 0.6 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_463_M4_MARKS {
@ Space between MnDOP and MnDUB, NODMF, MARKG, MARKS, LOGO (n>=4), Overlap is not allowed. >= 0.6um
 err1 = EXT M4DOP_all MARKS < 0.6 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_463_M4_LOGO {
@ Space between MnDOP and MnDUB, NODMF, MARKG, MARKS, LOGO (n>=4), Overlap is not allowed. >= 0.6um
 err1 = EXT M4DOP_all LOGO < 0.6 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

#IFDEF CHIPB_RULES_CHECK YES

 
DUMC_464_M4 {
@ Inside edge of CHIPB space to MnDOP (n>=4), Outside and cut is not allowed. >= 2um
 err1 = ENC M4DOP CHIPB < 2 ABUT<90 SINGULAR REGION OUTSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

#ENDIF

 
DUMC_465_M4 {
@ Space between MnDOP to 45-degree Mn (n>=4), Overlap is not allowed. >= 0.4um
 chk_M4 = ANGLE M4 > 44.5 < 45.5
 err1 = EXT M4DOP chk_M4 < 0.4 ABUT<90 OPPOSITE2 REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
M4DOP_h_edges = ANGLE M4DOP == 0
M4DOP_v_edges = ANGLE M4DOP == 90
M4DOP_WL_edges_a = DFM PROPERTY M4DOP M4DOP_h_edges M4DOP_v_edges OVERLAP ABUT ALSO MULTI [h_v_ratio = LENGTH(M4DOP_h_edges) - LENGTH(M4DOP_v_edges)] >= 0
M4DOP_WL_edges_b = DFM PROPERTY M4DOP M4DOP_h_edges M4DOP_v_edges OVERLAP ABUT ALSO MULTI [h_v_ratio = LENGTH(M4DOP_v_edges) - LENGTH(M4DOP_h_edges)] >= 0
M4DOP_W_edges = (M4DOP_v_edges COIN EDGE M4DOP_WL_edges_a) OR EDGE (M4DOP_h_edges COIN EDGE M4DOP_WL_edges_b)
M4DOP_L_edges = (M4DOP_h_edges COIN EDGE M4DOP_WL_edges_a) OR EDGE (M4DOP_v_edges COIN EDGE M4DOP_WL_edges_b)
 
DUMC_466_M4 {
@ When MnDOP width < 0.09um, the short side edge must perpendicular to Mn (n>=4)
 err1 = ANGLE (M4DOP_W_edges COIN EDGE (WITH WIDTH M4DOP < 0.09)) == 0
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
DUMC_459_M5 {
@ Space between MnDOP to Mn (n>=4), Overlap is not allowed. >= 0.12um
 err1 = EXT M5DOP M5 < 0.12 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_460_M5 {
@ Space between MnDOP to Mn (width >= 0.23um) (n>=4), Overlap is not allowed. >= 0.24um
 chk_M5 = M5 WITH WIDTH >= 0.23
 err1 = EXT M5DOP chk_M5 < 0.24 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_461_M5 {
@ Space between MnDOP to Mn (width >= 1um) (n>=4), Overlap is not allowed. >= 0.45um
 chk_M5 = (M5 WITH WIDTH >= 0.23) WITH WIDTH >= 1
 err1 = EXT M5DOP chk_M5 < 0.45 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_462_M5 {
@ Space between MnDOP to Mn (width >= 2um) (n>=4), Overlap is not allowed. >= 0.898um
 chk_M5 = (M5 WITH WIDTH >= 0.23) WITH WIDTH >= 2
 err1 = EXT M5DOP chk_M5 < 0.898 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_463_M5_M5DUB {
@ Space between MnDOP and MnDUB, NODMF, MARKG, MARKS, LOGO (n>=4), Overlap is not allowed. >= 0.6um
 err1 = EXT M5DOP_all M5DUB < 0.6 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_463_M5_NODMF {
@ Space between MnDOP and MnDUB, NODMF, MARKG, MARKS, LOGO (n>=4), Overlap is not allowed. >= 0.6um
 err1 = EXT M5DOP_all NODMF < 0.6 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_463_M5_MARKG {
@ Space between MnDOP and MnDUB, NODMF, MARKG, MARKS, LOGO (n>=4), Overlap is not allowed. >= 0.6um
 err1 = EXT M5DOP_all MARKG < 0.6 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_463_M5_MARKS {
@ Space between MnDOP and MnDUB, NODMF, MARKG, MARKS, LOGO (n>=4), Overlap is not allowed. >= 0.6um
 err1 = EXT M5DOP_all MARKS < 0.6 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_463_M5_LOGO {
@ Space between MnDOP and MnDUB, NODMF, MARKG, MARKS, LOGO (n>=4), Overlap is not allowed. >= 0.6um
 err1 = EXT M5DOP_all LOGO < 0.6 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

#IFDEF CHIPB_RULES_CHECK YES

 
DUMC_464_M5 {
@ Inside edge of CHIPB space to MnDOP (n>=4), Outside and cut is not allowed. >= 2um
 err1 = ENC M5DOP CHIPB < 2 ABUT<90 SINGULAR REGION OUTSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

#ENDIF

 
DUMC_465_M5 {
@ Space between MnDOP to 45-degree Mn (n>=4), Overlap is not allowed. >= 0.4um
 chk_M5 = ANGLE M5 > 44.5 < 45.5
 err1 = EXT M5DOP chk_M5 < 0.4 ABUT<90 OPPOSITE2 REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
M5DOP_h_edges = ANGLE M5DOP == 0
M5DOP_v_edges = ANGLE M5DOP == 90
M5DOP_WL_edges_a = DFM PROPERTY M5DOP M5DOP_h_edges M5DOP_v_edges OVERLAP ABUT ALSO MULTI [h_v_ratio = LENGTH(M5DOP_h_edges) - LENGTH(M5DOP_v_edges)] >= 0
M5DOP_WL_edges_b = DFM PROPERTY M5DOP M5DOP_h_edges M5DOP_v_edges OVERLAP ABUT ALSO MULTI [h_v_ratio = LENGTH(M5DOP_v_edges) - LENGTH(M5DOP_h_edges)] >= 0
M5DOP_W_edges = (M5DOP_v_edges COIN EDGE M5DOP_WL_edges_a) OR EDGE (M5DOP_h_edges COIN EDGE M5DOP_WL_edges_b)
M5DOP_L_edges = (M5DOP_h_edges COIN EDGE M5DOP_WL_edges_a) OR EDGE (M5DOP_v_edges COIN EDGE M5DOP_WL_edges_b)
 
DUMC_466_M5 {
@ When MnDOP width < 0.09um, the short side edge must perpendicular to Mn (n>=4)
 err1 = ANGLE (M5DOP_W_edges COIN EDGE (WITH WIDTH M5DOP < 0.09)) == 90
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
DUMC_459_M6 {
@ Space between MnDOP to Mn (n>=4), Overlap is not allowed. >= 0.12um
 err1 = EXT M6DOP M6 < 0.12 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_460_M6 {
@ Space between MnDOP to Mn (width >= 0.23um) (n>=4), Overlap is not allowed. >= 0.24um
 chk_M6 = M6 WITH WIDTH >= 0.23
 err1 = EXT M6DOP chk_M6 < 0.24 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_461_M6 {
@ Space between MnDOP to Mn (width >= 1um) (n>=4), Overlap is not allowed. >= 0.45um
 chk_M6 = (M6 WITH WIDTH >= 0.23) WITH WIDTH >= 1
 err1 = EXT M6DOP chk_M6 < 0.45 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_462_M6 {
@ Space between MnDOP to Mn (width >= 2um) (n>=4), Overlap is not allowed. >= 0.898um
 chk_M6 = (M6 WITH WIDTH >= 0.23) WITH WIDTH >= 2
 err1 = EXT M6DOP chk_M6 < 0.898 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_463_M6_M6DUB {
@ Space between MnDOP and MnDUB, NODMF, MARKG, MARKS, LOGO (n>=4), Overlap is not allowed. >= 0.6um
 err1 = EXT M6DOP_all M6DUB < 0.6 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_463_M6_NODMF {
@ Space between MnDOP and MnDUB, NODMF, MARKG, MARKS, LOGO (n>=4), Overlap is not allowed. >= 0.6um
 err1 = EXT M6DOP_all NODMF < 0.6 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_463_M6_MARKG {
@ Space between MnDOP and MnDUB, NODMF, MARKG, MARKS, LOGO (n>=4), Overlap is not allowed. >= 0.6um
 err1 = EXT M6DOP_all MARKG < 0.6 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_463_M6_MARKS {
@ Space between MnDOP and MnDUB, NODMF, MARKG, MARKS, LOGO (n>=4), Overlap is not allowed. >= 0.6um
 err1 = EXT M6DOP_all MARKS < 0.6 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_463_M6_LOGO {
@ Space between MnDOP and MnDUB, NODMF, MARKG, MARKS, LOGO (n>=4), Overlap is not allowed. >= 0.6um
 err1 = EXT M6DOP_all LOGO < 0.6 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

#IFDEF CHIPB_RULES_CHECK YES

 
DUMC_464_M6 {
@ Inside edge of CHIPB space to MnDOP (n>=4), Outside and cut is not allowed. >= 2um
 err1 = ENC M6DOP CHIPB < 2 ABUT<90 SINGULAR REGION OUTSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

#ENDIF

 
DUMC_465_M6 {
@ Space between MnDOP to 45-degree Mn (n>=4), Overlap is not allowed. >= 0.4um
 chk_M6 = ANGLE M6 > 44.5 < 45.5
 err1 = EXT M6DOP chk_M6 < 0.4 ABUT<90 OPPOSITE2 REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
M6DOP_h_edges = ANGLE M6DOP == 0
M6DOP_v_edges = ANGLE M6DOP == 90
M6DOP_WL_edges_a = DFM PROPERTY M6DOP M6DOP_h_edges M6DOP_v_edges OVERLAP ABUT ALSO MULTI [h_v_ratio = LENGTH(M6DOP_h_edges) - LENGTH(M6DOP_v_edges)] >= 0
M6DOP_WL_edges_b = DFM PROPERTY M6DOP M6DOP_h_edges M6DOP_v_edges OVERLAP ABUT ALSO MULTI [h_v_ratio = LENGTH(M6DOP_v_edges) - LENGTH(M6DOP_h_edges)] >= 0
M6DOP_W_edges = (M6DOP_v_edges COIN EDGE M6DOP_WL_edges_a) OR EDGE (M6DOP_h_edges COIN EDGE M6DOP_WL_edges_b)
M6DOP_L_edges = (M6DOP_h_edges COIN EDGE M6DOP_WL_edges_a) OR EDGE (M6DOP_v_edges COIN EDGE M6DOP_WL_edges_b)
 
DUMC_466_M6 {
@ When MnDOP width < 0.09um, the short side edge must perpendicular to Mn (n>=4)
 err1 = ANGLE (M6DOP_W_edges COIN EDGE (WITH WIDTH M6DOP < 0.09)) == 0
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
DUMC_459_M7 {
@ Space between MnDOP to Mn (n>=4), Overlap is not allowed. >= 0.12um
 err1 = EXT M7DOP M7 < 0.12 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_460_M7 {
@ Space between MnDOP to Mn (width >= 0.23um) (n>=4), Overlap is not allowed. >= 0.24um
 chk_M7 = M7 WITH WIDTH >= 0.23
 err1 = EXT M7DOP chk_M7 < 0.24 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_461_M7 {
@ Space between MnDOP to Mn (width >= 1um) (n>=4), Overlap is not allowed. >= 0.45um
 chk_M7 = (M7 WITH WIDTH >= 0.23) WITH WIDTH >= 1
 err1 = EXT M7DOP chk_M7 < 0.45 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_462_M7 {
@ Space between MnDOP to Mn (width >= 2um) (n>=4), Overlap is not allowed. >= 0.898um
 chk_M7 = (M7 WITH WIDTH >= 0.23) WITH WIDTH >= 2
 err1 = EXT M7DOP chk_M7 < 0.898 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_463_M7_M7DUB {
@ Space between MnDOP and MnDUB, NODMF, MARKG, MARKS, LOGO (n>=4), Overlap is not allowed. >= 0.6um
 err1 = EXT M7DOP_all M7DUB < 0.6 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_463_M7_NODMF {
@ Space between MnDOP and MnDUB, NODMF, MARKG, MARKS, LOGO (n>=4), Overlap is not allowed. >= 0.6um
 err1 = EXT M7DOP_all NODMF < 0.6 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_463_M7_MARKG {
@ Space between MnDOP and MnDUB, NODMF, MARKG, MARKS, LOGO (n>=4), Overlap is not allowed. >= 0.6um
 err1 = EXT M7DOP_all MARKG < 0.6 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_463_M7_MARKS {
@ Space between MnDOP and MnDUB, NODMF, MARKG, MARKS, LOGO (n>=4), Overlap is not allowed. >= 0.6um
 err1 = EXT M7DOP_all MARKS < 0.6 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_463_M7_LOGO {
@ Space between MnDOP and MnDUB, NODMF, MARKG, MARKS, LOGO (n>=4), Overlap is not allowed. >= 0.6um
 err1 = EXT M7DOP_all LOGO < 0.6 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

#IFDEF CHIPB_RULES_CHECK YES

 
DUMC_464_M7 {
@ Inside edge of CHIPB space to MnDOP (n>=4), Outside and cut is not allowed. >= 2um
 err1 = ENC M7DOP CHIPB < 2 ABUT<90 SINGULAR REGION OUTSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

#ENDIF

 
DUMC_465_M7 {
@ Space between MnDOP to 45-degree Mn (n>=4), Overlap is not allowed. >= 0.4um
 chk_M7 = ANGLE M7 > 44.5 < 45.5
 err1 = EXT M7DOP chk_M7 < 0.4 ABUT<90 OPPOSITE2 REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
M7DOP_h_edges = ANGLE M7DOP == 0
M7DOP_v_edges = ANGLE M7DOP == 90
M7DOP_WL_edges_a = DFM PROPERTY M7DOP M7DOP_h_edges M7DOP_v_edges OVERLAP ABUT ALSO MULTI [h_v_ratio = LENGTH(M7DOP_h_edges) - LENGTH(M7DOP_v_edges)] >= 0
M7DOP_WL_edges_b = DFM PROPERTY M7DOP M7DOP_h_edges M7DOP_v_edges OVERLAP ABUT ALSO MULTI [h_v_ratio = LENGTH(M7DOP_v_edges) - LENGTH(M7DOP_h_edges)] >= 0
M7DOP_W_edges = (M7DOP_v_edges COIN EDGE M7DOP_WL_edges_a) OR EDGE (M7DOP_h_edges COIN EDGE M7DOP_WL_edges_b)
M7DOP_L_edges = (M7DOP_h_edges COIN EDGE M7DOP_WL_edges_a) OR EDGE (M7DOP_v_edges COIN EDGE M7DOP_WL_edges_b)
 
DUMC_466_M7 {
@ When MnDOP width < 0.09um, the short side edge must perpendicular to Mn (n>=4)
 err1 = ANGLE (M7DOP_W_edges COIN EDGE (WITH WIDTH M7DOP < 0.09)) == 90
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
DUMC_474 {
@ Space between TM1DUM and MIM, CTOP, Overlap is not allowed. >= 2um
 err1 = EXT MIM TM1DUM < 2 ABUT<90 SINGULAR REGION INSIDE ALSO
 err2 = EXT CTOP TM1DUM < 2 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

DUMC_476 {
@ Space between (((M1DUM OR M1DPDUM) OR M1DOP) OR M1DPDOP) and OCOVLM1CA, OCOVLM1CB, OCOVLM2CA, OCOVLM4, OCOVLV0, Overlap is not allowed. >= 0.6um
 err1 = EXT (((M1DUM OR M1DPDUM) OR M1DOP) OR M1DPDOP) OCOVLM1CA < 0.6 ABUT<90 SINGULAR REGION INSIDE ALSO
 err2 = EXT (((M1DUM OR M1DPDUM) OR M1DOP) OR M1DPDOP) OCOVLM1CB < 0.6 ABUT<90 SINGULAR REGION INSIDE ALSO
 err3 = EXT (((M1DUM OR M1DPDUM) OR M1DOP) OR M1DPDOP) OCOVLM2CA < 0.6 ABUT<90 SINGULAR REGION INSIDE ALSO
 err4 = EXT (((M1DUM OR M1DPDUM) OR M1DOP) OR M1DPDOP) OCOVLM4 < 0.6 ABUT<90 SINGULAR REGION INSIDE ALSO
 err5 = EXT (((M1DUM OR M1DPDUM) OR M1DOP) OR M1DPDOP) OCOVLV0 < 0.6 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
 err4 NOT INSIDE SealR_NOT_BULK
 err5 NOT INSIDE SealR_NOT_BULK
}

DUMC_477 {
@ Space between (((M2DUM OR M2DPDUM) OR M2DOP) OR M2DPDOP) and OCOVLM2CA, OCOVLM4, Overlap is not allowed. >= 0.6um
 err1 = EXT (((M2DUM OR M2DPDUM) OR M2DOP) OR M2DPDOP) OCOVLM2CA < 0.6 ABUT<90 SINGULAR REGION INSIDE ALSO
 err2 = EXT (((M2DUM OR M2DPDUM) OR M2DOP) OR M2DPDOP) OCOVLM4 < 0.6 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

DUMC_478 {
@ Space between (((M3DUM OR M3DPDUM) OR M3DOP) OR M3DPDOP) and OCOVLM4, Overlap is not allowed. >= 0.6um
 err1 = EXT (((M3DUM OR M3DPDUM) OR M3DOP) OR M3DPDOP) OCOVLM4 < 0.6 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_479 {
@ Space between (M4DUM OR M4DOP) and OCOVLM4, Overlap is not allowed. >= 0.6um
 err1 = EXT (M4DUM OR M4DOP) OCOVLM4 < 0.6 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_480_M1DOP {
@ M1DOP/M1DUM/M1DPDOP/M1DPDUM/M2DUM/M2DOP/M2DPDUM/M2DPDOP/M3DUM/M3DOP/M3DPDUM/M3DPDOP/M4DUM/M4DOP/M5DUM/M5DOP/M6DUM/M6DOP/M7DUM/M7DOP/V1DUM/V2DUM/V3DUM/V4DUM/V5DUM/V6DUM/BV1DUM/BV2DUM/B1DUM/B1DOP/B2DUM/B2DOP/UTMDUM/TM1DUM/TM2DUM/ALDUM/MIMDUM/CTOPDUM/V0DUM/V0DPDUM must be covered by DMCMK2. Outside and cut is not allowed.These layers are dedicated for SMIC BEOL dummy auto-insertion utility usage, can't be used for manually drawn purpose. Drawn dummy layer please use main layer
 err1 = NOT INSIDE M1DOP DMCMK2
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_480_M1DUM {
@ M1DOP/M1DUM/M1DPDOP/M1DPDUM/M2DUM/M2DOP/M2DPDUM/M2DPDOP/M3DUM/M3DOP/M3DPDUM/M3DPDOP/M4DUM/M4DOP/M5DUM/M5DOP/M6DUM/M6DOP/M7DUM/M7DOP/V1DUM/V2DUM/V3DUM/V4DUM/V5DUM/V6DUM/BV1DUM/BV2DUM/B1DUM/B1DOP/B2DUM/B2DOP/UTMDUM/TM1DUM/TM2DUM/ALDUM/MIMDUM/CTOPDUM/V0DUM/V0DPDUM must be covered by DMCMK2. Outside and cut is not allowed.These layers are dedicated for SMIC BEOL dummy auto-insertion utility usage, can't be used for manually drawn purpose. Drawn dummy layer please use main layer
 err1 = NOT INSIDE M1DUM DMCMK2
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_480_M1DPDOP {
@ M1DOP/M1DUM/M1DPDOP/M1DPDUM/M2DUM/M2DOP/M2DPDUM/M2DPDOP/M3DUM/M3DOP/M3DPDUM/M3DPDOP/M4DUM/M4DOP/M5DUM/M5DOP/M6DUM/M6DOP/M7DUM/M7DOP/V1DUM/V2DUM/V3DUM/V4DUM/V5DUM/V6DUM/BV1DUM/BV2DUM/B1DUM/B1DOP/B2DUM/B2DOP/UTMDUM/TM1DUM/TM2DUM/ALDUM/MIMDUM/CTOPDUM/V0DUM/V0DPDUM must be covered by DMCMK2. Outside and cut is not allowed.These layers are dedicated for SMIC BEOL dummy auto-insertion utility usage, can't be used for manually drawn purpose. Drawn dummy layer please use main layer
 err1 = NOT INSIDE M1DPDOP DMCMK2
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_480_M1DPDUM {
@ M1DOP/M1DUM/M1DPDOP/M1DPDUM/M2DUM/M2DOP/M2DPDUM/M2DPDOP/M3DUM/M3DOP/M3DPDUM/M3DPDOP/M4DUM/M4DOP/M5DUM/M5DOP/M6DUM/M6DOP/M7DUM/M7DOP/V1DUM/V2DUM/V3DUM/V4DUM/V5DUM/V6DUM/BV1DUM/BV2DUM/B1DUM/B1DOP/B2DUM/B2DOP/UTMDUM/TM1DUM/TM2DUM/ALDUM/MIMDUM/CTOPDUM/V0DUM/V0DPDUM must be covered by DMCMK2. Outside and cut is not allowed.These layers are dedicated for SMIC BEOL dummy auto-insertion utility usage, can't be used for manually drawn purpose. Drawn dummy layer please use main layer
 err1 = NOT INSIDE M1DPDUM DMCMK2
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_480_M2DUM {
@ M1DOP/M1DUM/M1DPDOP/M1DPDUM/M2DUM/M2DOP/M2DPDUM/M2DPDOP/M3DUM/M3DOP/M3DPDUM/M3DPDOP/M4DUM/M4DOP/M5DUM/M5DOP/M6DUM/M6DOP/M7DUM/M7DOP/V1DUM/V2DUM/V3DUM/V4DUM/V5DUM/V6DUM/BV1DUM/BV2DUM/B1DUM/B1DOP/B2DUM/B2DOP/UTMDUM/TM1DUM/TM2DUM/ALDUM/MIMDUM/CTOPDUM/V0DUM/V0DPDUM must be covered by DMCMK2. Outside and cut is not allowed.These layers are dedicated for SMIC BEOL dummy auto-insertion utility usage, can't be used for manually drawn purpose. Drawn dummy layer please use main layer
 err1 = NOT INSIDE M2DUM DMCMK2
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_480_M2DOP {
@ M1DOP/M1DUM/M1DPDOP/M1DPDUM/M2DUM/M2DOP/M2DPDUM/M2DPDOP/M3DUM/M3DOP/M3DPDUM/M3DPDOP/M4DUM/M4DOP/M5DUM/M5DOP/M6DUM/M6DOP/M7DUM/M7DOP/V1DUM/V2DUM/V3DUM/V4DUM/V5DUM/V6DUM/BV1DUM/BV2DUM/B1DUM/B1DOP/B2DUM/B2DOP/UTMDUM/TM1DUM/TM2DUM/ALDUM/MIMDUM/CTOPDUM/V0DUM/V0DPDUM must be covered by DMCMK2. Outside and cut is not allowed.These layers are dedicated for SMIC BEOL dummy auto-insertion utility usage, can't be used for manually drawn purpose. Drawn dummy layer please use main layer
 err1 = NOT INSIDE M2DOP DMCMK2
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_480_M2DPDUM {
@ M1DOP/M1DUM/M1DPDOP/M1DPDUM/M2DUM/M2DOP/M2DPDUM/M2DPDOP/M3DUM/M3DOP/M3DPDUM/M3DPDOP/M4DUM/M4DOP/M5DUM/M5DOP/M6DUM/M6DOP/M7DUM/M7DOP/V1DUM/V2DUM/V3DUM/V4DUM/V5DUM/V6DUM/BV1DUM/BV2DUM/B1DUM/B1DOP/B2DUM/B2DOP/UTMDUM/TM1DUM/TM2DUM/ALDUM/MIMDUM/CTOPDUM/V0DUM/V0DPDUM must be covered by DMCMK2. Outside and cut is not allowed.These layers are dedicated for SMIC BEOL dummy auto-insertion utility usage, can't be used for manually drawn purpose. Drawn dummy layer please use main layer
 err1 = NOT INSIDE M2DPDUM DMCMK2
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_480_M2DPDOP {
@ M1DOP/M1DUM/M1DPDOP/M1DPDUM/M2DUM/M2DOP/M2DPDUM/M2DPDOP/M3DUM/M3DOP/M3DPDUM/M3DPDOP/M4DUM/M4DOP/M5DUM/M5DOP/M6DUM/M6DOP/M7DUM/M7DOP/V1DUM/V2DUM/V3DUM/V4DUM/V5DUM/V6DUM/BV1DUM/BV2DUM/B1DUM/B1DOP/B2DUM/B2DOP/UTMDUM/TM1DUM/TM2DUM/ALDUM/MIMDUM/CTOPDUM/V0DUM/V0DPDUM must be covered by DMCMK2. Outside and cut is not allowed.These layers are dedicated for SMIC BEOL dummy auto-insertion utility usage, can't be used for manually drawn purpose. Drawn dummy layer please use main layer
 err1 = NOT INSIDE M2DPDOP DMCMK2
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_480_M3DUM {
@ M1DOP/M1DUM/M1DPDOP/M1DPDUM/M2DUM/M2DOP/M2DPDUM/M2DPDOP/M3DUM/M3DOP/M3DPDUM/M3DPDOP/M4DUM/M4DOP/M5DUM/M5DOP/M6DUM/M6DOP/M7DUM/M7DOP/V1DUM/V2DUM/V3DUM/V4DUM/V5DUM/V6DUM/BV1DUM/BV2DUM/B1DUM/B1DOP/B2DUM/B2DOP/UTMDUM/TM1DUM/TM2DUM/ALDUM/MIMDUM/CTOPDUM/V0DUM/V0DPDUM must be covered by DMCMK2. Outside and cut is not allowed.These layers are dedicated for SMIC BEOL dummy auto-insertion utility usage, can't be used for manually drawn purpose. Drawn dummy layer please use main layer
 err1 = NOT INSIDE M3DUM DMCMK2
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_480_M3DOP {
@ M1DOP/M1DUM/M1DPDOP/M1DPDUM/M2DUM/M2DOP/M2DPDUM/M2DPDOP/M3DUM/M3DOP/M3DPDUM/M3DPDOP/M4DUM/M4DOP/M5DUM/M5DOP/M6DUM/M6DOP/M7DUM/M7DOP/V1DUM/V2DUM/V3DUM/V4DUM/V5DUM/V6DUM/BV1DUM/BV2DUM/B1DUM/B1DOP/B2DUM/B2DOP/UTMDUM/TM1DUM/TM2DUM/ALDUM/MIMDUM/CTOPDUM/V0DUM/V0DPDUM must be covered by DMCMK2. Outside and cut is not allowed.These layers are dedicated for SMIC BEOL dummy auto-insertion utility usage, can't be used for manually drawn purpose. Drawn dummy layer please use main layer
 err1 = NOT INSIDE M3DOP DMCMK2
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_480_M3DPDUM {
@ M1DOP/M1DUM/M1DPDOP/M1DPDUM/M2DUM/M2DOP/M2DPDUM/M2DPDOP/M3DUM/M3DOP/M3DPDUM/M3DPDOP/M4DUM/M4DOP/M5DUM/M5DOP/M6DUM/M6DOP/M7DUM/M7DOP/V1DUM/V2DUM/V3DUM/V4DUM/V5DUM/V6DUM/BV1DUM/BV2DUM/B1DUM/B1DOP/B2DUM/B2DOP/UTMDUM/TM1DUM/TM2DUM/ALDUM/MIMDUM/CTOPDUM/V0DUM/V0DPDUM must be covered by DMCMK2. Outside and cut is not allowed.These layers are dedicated for SMIC BEOL dummy auto-insertion utility usage, can't be used for manually drawn purpose. Drawn dummy layer please use main layer
 err1 = NOT INSIDE M3DPDUM DMCMK2
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_480_M3DPDOP {
@ M1DOP/M1DUM/M1DPDOP/M1DPDUM/M2DUM/M2DOP/M2DPDUM/M2DPDOP/M3DUM/M3DOP/M3DPDUM/M3DPDOP/M4DUM/M4DOP/M5DUM/M5DOP/M6DUM/M6DOP/M7DUM/M7DOP/V1DUM/V2DUM/V3DUM/V4DUM/V5DUM/V6DUM/BV1DUM/BV2DUM/B1DUM/B1DOP/B2DUM/B2DOP/UTMDUM/TM1DUM/TM2DUM/ALDUM/MIMDUM/CTOPDUM/V0DUM/V0DPDUM must be covered by DMCMK2. Outside and cut is not allowed.These layers are dedicated for SMIC BEOL dummy auto-insertion utility usage, can't be used for manually drawn purpose. Drawn dummy layer please use main layer
 err1 = NOT INSIDE M3DPDOP DMCMK2
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_480_M4DUM {
@ M1DOP/M1DUM/M1DPDOP/M1DPDUM/M2DUM/M2DOP/M2DPDUM/M2DPDOP/M3DUM/M3DOP/M3DPDUM/M3DPDOP/M4DUM/M4DOP/M5DUM/M5DOP/M6DUM/M6DOP/M7DUM/M7DOP/V1DUM/V2DUM/V3DUM/V4DUM/V5DUM/V6DUM/BV1DUM/BV2DUM/B1DUM/B1DOP/B2DUM/B2DOP/UTMDUM/TM1DUM/TM2DUM/ALDUM/MIMDUM/CTOPDUM/V0DUM/V0DPDUM must be covered by DMCMK2. Outside and cut is not allowed.These layers are dedicated for SMIC BEOL dummy auto-insertion utility usage, can't be used for manually drawn purpose. Drawn dummy layer please use main layer
 err1 = NOT INSIDE M4DUM DMCMK2
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_480_M4DOP {
@ M1DOP/M1DUM/M1DPDOP/M1DPDUM/M2DUM/M2DOP/M2DPDUM/M2DPDOP/M3DUM/M3DOP/M3DPDUM/M3DPDOP/M4DUM/M4DOP/M5DUM/M5DOP/M6DUM/M6DOP/M7DUM/M7DOP/V1DUM/V2DUM/V3DUM/V4DUM/V5DUM/V6DUM/BV1DUM/BV2DUM/B1DUM/B1DOP/B2DUM/B2DOP/UTMDUM/TM1DUM/TM2DUM/ALDUM/MIMDUM/CTOPDUM/V0DUM/V0DPDUM must be covered by DMCMK2. Outside and cut is not allowed.These layers are dedicated for SMIC BEOL dummy auto-insertion utility usage, can't be used for manually drawn purpose. Drawn dummy layer please use main layer
 err1 = NOT INSIDE M4DOP DMCMK2
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_480_M5DUM {
@ M1DOP/M1DUM/M1DPDOP/M1DPDUM/M2DUM/M2DOP/M2DPDUM/M2DPDOP/M3DUM/M3DOP/M3DPDUM/M3DPDOP/M4DUM/M4DOP/M5DUM/M5DOP/M6DUM/M6DOP/M7DUM/M7DOP/V1DUM/V2DUM/V3DUM/V4DUM/V5DUM/V6DUM/BV1DUM/BV2DUM/B1DUM/B1DOP/B2DUM/B2DOP/UTMDUM/TM1DUM/TM2DUM/ALDUM/MIMDUM/CTOPDUM/V0DUM/V0DPDUM must be covered by DMCMK2. Outside and cut is not allowed.These layers are dedicated for SMIC BEOL dummy auto-insertion utility usage, can't be used for manually drawn purpose. Drawn dummy layer please use main layer
 err1 = NOT INSIDE M5DUM DMCMK2
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_480_M5DOP {
@ M1DOP/M1DUM/M1DPDOP/M1DPDUM/M2DUM/M2DOP/M2DPDUM/M2DPDOP/M3DUM/M3DOP/M3DPDUM/M3DPDOP/M4DUM/M4DOP/M5DUM/M5DOP/M6DUM/M6DOP/M7DUM/M7DOP/V1DUM/V2DUM/V3DUM/V4DUM/V5DUM/V6DUM/BV1DUM/BV2DUM/B1DUM/B1DOP/B2DUM/B2DOP/UTMDUM/TM1DUM/TM2DUM/ALDUM/MIMDUM/CTOPDUM/V0DUM/V0DPDUM must be covered by DMCMK2. Outside and cut is not allowed.These layers are dedicated for SMIC BEOL dummy auto-insertion utility usage, can't be used for manually drawn purpose. Drawn dummy layer please use main layer
 err1 = NOT INSIDE M5DOP DMCMK2
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_480_M6DUM {
@ M1DOP/M1DUM/M1DPDOP/M1DPDUM/M2DUM/M2DOP/M2DPDUM/M2DPDOP/M3DUM/M3DOP/M3DPDUM/M3DPDOP/M4DUM/M4DOP/M5DUM/M5DOP/M6DUM/M6DOP/M7DUM/M7DOP/V1DUM/V2DUM/V3DUM/V4DUM/V5DUM/V6DUM/BV1DUM/BV2DUM/B1DUM/B1DOP/B2DUM/B2DOP/UTMDUM/TM1DUM/TM2DUM/ALDUM/MIMDUM/CTOPDUM/V0DUM/V0DPDUM must be covered by DMCMK2. Outside and cut is not allowed.These layers are dedicated for SMIC BEOL dummy auto-insertion utility usage, can't be used for manually drawn purpose. Drawn dummy layer please use main layer
 err1 = NOT INSIDE M6DUM DMCMK2
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_480_M6DOP {
@ M1DOP/M1DUM/M1DPDOP/M1DPDUM/M2DUM/M2DOP/M2DPDUM/M2DPDOP/M3DUM/M3DOP/M3DPDUM/M3DPDOP/M4DUM/M4DOP/M5DUM/M5DOP/M6DUM/M6DOP/M7DUM/M7DOP/V1DUM/V2DUM/V3DUM/V4DUM/V5DUM/V6DUM/BV1DUM/BV2DUM/B1DUM/B1DOP/B2DUM/B2DOP/UTMDUM/TM1DUM/TM2DUM/ALDUM/MIMDUM/CTOPDUM/V0DUM/V0DPDUM must be covered by DMCMK2. Outside and cut is not allowed.These layers are dedicated for SMIC BEOL dummy auto-insertion utility usage, can't be used for manually drawn purpose. Drawn dummy layer please use main layer
 err1 = NOT INSIDE M6DOP DMCMK2
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_480_M7DUM {
@ M1DOP/M1DUM/M1DPDOP/M1DPDUM/M2DUM/M2DOP/M2DPDUM/M2DPDOP/M3DUM/M3DOP/M3DPDUM/M3DPDOP/M4DUM/M4DOP/M5DUM/M5DOP/M6DUM/M6DOP/M7DUM/M7DOP/V1DUM/V2DUM/V3DUM/V4DUM/V5DUM/V6DUM/BV1DUM/BV2DUM/B1DUM/B1DOP/B2DUM/B2DOP/UTMDUM/TM1DUM/TM2DUM/ALDUM/MIMDUM/CTOPDUM/V0DUM/V0DPDUM must be covered by DMCMK2. Outside and cut is not allowed.These layers are dedicated for SMIC BEOL dummy auto-insertion utility usage, can't be used for manually drawn purpose. Drawn dummy layer please use main layer
 err1 = NOT INSIDE M7DUM DMCMK2
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_480_M7DOP {
@ M1DOP/M1DUM/M1DPDOP/M1DPDUM/M2DUM/M2DOP/M2DPDUM/M2DPDOP/M3DUM/M3DOP/M3DPDUM/M3DPDOP/M4DUM/M4DOP/M5DUM/M5DOP/M6DUM/M6DOP/M7DUM/M7DOP/V1DUM/V2DUM/V3DUM/V4DUM/V5DUM/V6DUM/BV1DUM/BV2DUM/B1DUM/B1DOP/B2DUM/B2DOP/UTMDUM/TM1DUM/TM2DUM/ALDUM/MIMDUM/CTOPDUM/V0DUM/V0DPDUM must be covered by DMCMK2. Outside and cut is not allowed.These layers are dedicated for SMIC BEOL dummy auto-insertion utility usage, can't be used for manually drawn purpose. Drawn dummy layer please use main layer
 err1 = NOT INSIDE M7DOPi DMCMK2
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_480_V1DUM {
@ M1DOP/M1DUM/M1DPDOP/M1DPDUM/M2DUM/M2DOP/M2DPDUM/M2DPDOP/M3DUM/M3DOP/M3DPDUM/M3DPDOP/M4DUM/M4DOP/M5DUM/M5DOP/M6DUM/M6DOP/M7DUM/M7DOP/V1DUM/V2DUM/V3DUM/V4DUM/V5DUM/V6DUM/BV1DUM/BV2DUM/B1DUM/B1DOP/B2DUM/B2DOP/UTMDUM/TM1DUM/TM2DUM/ALDUM/MIMDUM/CTOPDUM/V0DUM/V0DPDUM must be covered by DMCMK2. Outside and cut is not allowed.These layers are dedicated for SMIC BEOL dummy auto-insertion utility usage, can't be used for manually drawn purpose. Drawn dummy layer please use main layer
 err1 = NOT INSIDE V1DUM DMCMK2
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_480_V2DUM {
@ M1DOP/M1DUM/M1DPDOP/M1DPDUM/M2DUM/M2DOP/M2DPDUM/M2DPDOP/M3DUM/M3DOP/M3DPDUM/M3DPDOP/M4DUM/M4DOP/M5DUM/M5DOP/M6DUM/M6DOP/M7DUM/M7DOP/V1DUM/V2DUM/V3DUM/V4DUM/V5DUM/V6DUM/BV1DUM/BV2DUM/B1DUM/B1DOP/B2DUM/B2DOP/UTMDUM/TM1DUM/TM2DUM/ALDUM/MIMDUM/CTOPDUM/V0DUM/V0DPDUM must be covered by DMCMK2. Outside and cut is not allowed.These layers are dedicated for SMIC BEOL dummy auto-insertion utility usage, can't be used for manually drawn purpose. Drawn dummy layer please use main layer
 err1 = NOT INSIDE V2DUM DMCMK2
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_480_V3DUM {
@ M1DOP/M1DUM/M1DPDOP/M1DPDUM/M2DUM/M2DOP/M2DPDUM/M2DPDOP/M3DUM/M3DOP/M3DPDUM/M3DPDOP/M4DUM/M4DOP/M5DUM/M5DOP/M6DUM/M6DOP/M7DUM/M7DOP/V1DUM/V2DUM/V3DUM/V4DUM/V5DUM/V6DUM/BV1DUM/BV2DUM/B1DUM/B1DOP/B2DUM/B2DOP/UTMDUM/TM1DUM/TM2DUM/ALDUM/MIMDUM/CTOPDUM/V0DUM/V0DPDUM must be covered by DMCMK2. Outside and cut is not allowed.These layers are dedicated for SMIC BEOL dummy auto-insertion utility usage, can't be used for manually drawn purpose. Drawn dummy layer please use main layer
 err1 = NOT INSIDE V3DUM DMCMK2
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_480_V4DUM {
@ M1DOP/M1DUM/M1DPDOP/M1DPDUM/M2DUM/M2DOP/M2DPDUM/M2DPDOP/M3DUM/M3DOP/M3DPDUM/M3DPDOP/M4DUM/M4DOP/M5DUM/M5DOP/M6DUM/M6DOP/M7DUM/M7DOP/V1DUM/V2DUM/V3DUM/V4DUM/V5DUM/V6DUM/BV1DUM/BV2DUM/B1DUM/B1DOP/B2DUM/B2DOP/UTMDUM/TM1DUM/TM2DUM/ALDUM/MIMDUM/CTOPDUM/V0DUM/V0DPDUM must be covered by DMCMK2. Outside and cut is not allowed.These layers are dedicated for SMIC BEOL dummy auto-insertion utility usage, can't be used for manually drawn purpose. Drawn dummy layer please use main layer
 err1 = NOT INSIDE V4DUM DMCMK2
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_480_V5DUM {
@ M1DOP/M1DUM/M1DPDOP/M1DPDUM/M2DUM/M2DOP/M2DPDUM/M2DPDOP/M3DUM/M3DOP/M3DPDUM/M3DPDOP/M4DUM/M4DOP/M5DUM/M5DOP/M6DUM/M6DOP/M7DUM/M7DOP/V1DUM/V2DUM/V3DUM/V4DUM/V5DUM/V6DUM/BV1DUM/BV2DUM/B1DUM/B1DOP/B2DUM/B2DOP/UTMDUM/TM1DUM/TM2DUM/ALDUM/MIMDUM/CTOPDUM/V0DUM/V0DPDUM must be covered by DMCMK2. Outside and cut is not allowed.These layers are dedicated for SMIC BEOL dummy auto-insertion utility usage, can't be used for manually drawn purpose. Drawn dummy layer please use main layer
 err1 = NOT INSIDE V5DUM DMCMK2
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_480_V6DUM {
@ M1DOP/M1DUM/M1DPDOP/M1DPDUM/M2DUM/M2DOP/M2DPDUM/M2DPDOP/M3DUM/M3DOP/M3DPDUM/M3DPDOP/M4DUM/M4DOP/M5DUM/M5DOP/M6DUM/M6DOP/M7DUM/M7DOP/V1DUM/V2DUM/V3DUM/V4DUM/V5DUM/V6DUM/BV1DUM/BV2DUM/B1DUM/B1DOP/B2DUM/B2DOP/UTMDUM/TM1DUM/TM2DUM/ALDUM/MIMDUM/CTOPDUM/V0DUM/V0DPDUM must be covered by DMCMK2. Outside and cut is not allowed.These layers are dedicated for SMIC BEOL dummy auto-insertion utility usage, can't be used for manually drawn purpose. Drawn dummy layer please use main layer
 err1 = NOT INSIDE V6DUM DMCMK2
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_480_BV1DUM {
@ M1DOP/M1DUM/M1DPDOP/M1DPDUM/M2DUM/M2DOP/M2DPDUM/M2DPDOP/M3DUM/M3DOP/M3DPDUM/M3DPDOP/M4DUM/M4DOP/M5DUM/M5DOP/M6DUM/M6DOP/M7DUM/M7DOP/V1DUM/V2DUM/V3DUM/V4DUM/V5DUM/V6DUM/BV1DUM/BV2DUM/B1DUM/B1DOP/B2DUM/B2DOP/UTMDUM/TM1DUM/TM2DUM/ALDUM/MIMDUM/CTOPDUM/V0DUM/V0DPDUM must be covered by DMCMK2. Outside and cut is not allowed.These layers are dedicated for SMIC BEOL dummy auto-insertion utility usage, can't be used for manually drawn purpose. Drawn dummy layer please use main layer
 err1 = NOT INSIDE BV1DUM DMCMK2
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_480_BV2DUM {
@ M1DOP/M1DUM/M1DPDOP/M1DPDUM/M2DUM/M2DOP/M2DPDUM/M2DPDOP/M3DUM/M3DOP/M3DPDUM/M3DPDOP/M4DUM/M4DOP/M5DUM/M5DOP/M6DUM/M6DOP/M7DUM/M7DOP/V1DUM/V2DUM/V3DUM/V4DUM/V5DUM/V6DUM/BV1DUM/BV2DUM/B1DUM/B1DOP/B2DUM/B2DOP/UTMDUM/TM1DUM/TM2DUM/ALDUM/MIMDUM/CTOPDUM/V0DUM/V0DPDUM must be covered by DMCMK2. Outside and cut is not allowed.These layers are dedicated for SMIC BEOL dummy auto-insertion utility usage, can't be used for manually drawn purpose. Drawn dummy layer please use main layer
 err1 = NOT INSIDE BV2DUM DMCMK2
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_480_B1DUM {
@ M1DOP/M1DUM/M1DPDOP/M1DPDUM/M2DUM/M2DOP/M2DPDUM/M2DPDOP/M3DUM/M3DOP/M3DPDUM/M3DPDOP/M4DUM/M4DOP/M5DUM/M5DOP/M6DUM/M6DOP/M7DUM/M7DOP/V1DUM/V2DUM/V3DUM/V4DUM/V5DUM/V6DUM/BV1DUM/BV2DUM/B1DUM/B1DOP/B2DUM/B2DOP/UTMDUM/TM1DUM/TM2DUM/ALDUM/MIMDUM/CTOPDUM/V0DUM/V0DPDUM must be covered by DMCMK2. Outside and cut is not allowed.These layers are dedicated for SMIC BEOL dummy auto-insertion utility usage, can't be used for manually drawn purpose. Drawn dummy layer please use main layer
 err1 = NOT INSIDE B1DUM DMCMK2
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_480_B1DOP {
@ M1DOP/M1DUM/M1DPDOP/M1DPDUM/M2DUM/M2DOP/M2DPDUM/M2DPDOP/M3DUM/M3DOP/M3DPDUM/M3DPDOP/M4DUM/M4DOP/M5DUM/M5DOP/M6DUM/M6DOP/M7DUM/M7DOP/V1DUM/V2DUM/V3DUM/V4DUM/V5DUM/V6DUM/BV1DUM/BV2DUM/B1DUM/B1DOP/B2DUM/B2DOP/UTMDUM/TM1DUM/TM2DUM/ALDUM/MIMDUM/CTOPDUM/V0DUM/V0DPDUM must be covered by DMCMK2. Outside and cut is not allowed.These layers are dedicated for SMIC BEOL dummy auto-insertion utility usage, can't be used for manually drawn purpose. Drawn dummy layer please use main layer
 err1 = NOT INSIDE B1DOP DMCMK2
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_480_B2DUM {
@ M1DOP/M1DUM/M1DPDOP/M1DPDUM/M2DUM/M2DOP/M2DPDUM/M2DPDOP/M3DUM/M3DOP/M3DPDUM/M3DPDOP/M4DUM/M4DOP/M5DUM/M5DOP/M6DUM/M6DOP/M7DUM/M7DOP/V1DUM/V2DUM/V3DUM/V4DUM/V5DUM/V6DUM/BV1DUM/BV2DUM/B1DUM/B1DOP/B2DUM/B2DOP/UTMDUM/TM1DUM/TM2DUM/ALDUM/MIMDUM/CTOPDUM/V0DUM/V0DPDUM must be covered by DMCMK2. Outside and cut is not allowed.These layers are dedicated for SMIC BEOL dummy auto-insertion utility usage, can't be used for manually drawn purpose. Drawn dummy layer please use main layer
 err1 = NOT INSIDE B2DUM DMCMK2
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_480_B2DOP {
@ M1DOP/M1DUM/M1DPDOP/M1DPDUM/M2DUM/M2DOP/M2DPDUM/M2DPDOP/M3DUM/M3DOP/M3DPDUM/M3DPDOP/M4DUM/M4DOP/M5DUM/M5DOP/M6DUM/M6DOP/M7DUM/M7DOP/V1DUM/V2DUM/V3DUM/V4DUM/V5DUM/V6DUM/BV1DUM/BV2DUM/B1DUM/B1DOP/B2DUM/B2DOP/UTMDUM/TM1DUM/TM2DUM/ALDUM/MIMDUM/CTOPDUM/V0DUM/V0DPDUM must be covered by DMCMK2. Outside and cut is not allowed.These layers are dedicated for SMIC BEOL dummy auto-insertion utility usage, can't be used for manually drawn purpose. Drawn dummy layer please use main layer
 err1 = NOT INSIDE B2DOP DMCMK2
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_480_UTMDUM {
@ M1DOP/M1DUM/M1DPDOP/M1DPDUM/M2DUM/M2DOP/M2DPDUM/M2DPDOP/M3DUM/M3DOP/M3DPDUM/M3DPDOP/M4DUM/M4DOP/M5DUM/M5DOP/M6DUM/M6DOP/M7DUM/M7DOP/V1DUM/V2DUM/V3DUM/V4DUM/V5DUM/V6DUM/BV1DUM/BV2DUM/B1DUM/B1DOP/B2DUM/B2DOP/UTMDUM/TM1DUM/TM2DUM/ALDUM/MIMDUM/CTOPDUM/V0DUM/V0DPDUM must be covered by DMCMK2. Outside and cut is not allowed.These layers are dedicated for SMIC BEOL dummy auto-insertion utility usage, can't be used for manually drawn purpose. Drawn dummy layer please use main layer
 err1 = NOT INSIDE UTMDUM DMCMK2
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_480_TM1DUM {
@ M1DOP/M1DUM/M1DPDOP/M1DPDUM/M2DUM/M2DOP/M2DPDUM/M2DPDOP/M3DUM/M3DOP/M3DPDUM/M3DPDOP/M4DUM/M4DOP/M5DUM/M5DOP/M6DUM/M6DOP/M7DUM/M7DOP/V1DUM/V2DUM/V3DUM/V4DUM/V5DUM/V6DUM/BV1DUM/BV2DUM/B1DUM/B1DOP/B2DUM/B2DOP/UTMDUM/TM1DUM/TM2DUM/ALDUM/MIMDUM/CTOPDUM/V0DUM/V0DPDUM must be covered by DMCMK2. Outside and cut is not allowed.These layers are dedicated for SMIC BEOL dummy auto-insertion utility usage, can't be used for manually drawn purpose. Drawn dummy layer please use main layer
 err1 = NOT INSIDE TM1DUM DMCMK2
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_480_TM2DUM {
@ M1DOP/M1DUM/M1DPDOP/M1DPDUM/M2DUM/M2DOP/M2DPDUM/M2DPDOP/M3DUM/M3DOP/M3DPDUM/M3DPDOP/M4DUM/M4DOP/M5DUM/M5DOP/M6DUM/M6DOP/M7DUM/M7DOP/V1DUM/V2DUM/V3DUM/V4DUM/V5DUM/V6DUM/BV1DUM/BV2DUM/B1DUM/B1DOP/B2DUM/B2DOP/UTMDUM/TM1DUM/TM2DUM/ALDUM/MIMDUM/CTOPDUM/V0DUM/V0DPDUM must be covered by DMCMK2. Outside and cut is not allowed.These layers are dedicated for SMIC BEOL dummy auto-insertion utility usage, can't be used for manually drawn purpose. Drawn dummy layer please use main layer
 err1 = NOT INSIDE TM2DUM DMCMK2
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_480_ALDUM {
@ M1DOP/M1DUM/M1DPDOP/M1DPDUM/M2DUM/M2DOP/M2DPDUM/M2DPDOP/M3DUM/M3DOP/M3DPDUM/M3DPDOP/M4DUM/M4DOP/M5DUM/M5DOP/M6DUM/M6DOP/M7DUM/M7DOP/V1DUM/V2DUM/V3DUM/V4DUM/V5DUM/V6DUM/BV1DUM/BV2DUM/B1DUM/B1DOP/B2DUM/B2DOP/UTMDUM/TM1DUM/TM2DUM/ALDUM/MIMDUM/CTOPDUM/V0DUM/V0DPDUM must be covered by DMCMK2. Outside and cut is not allowed.These layers are dedicated for SMIC BEOL dummy auto-insertion utility usage, can't be used for manually drawn purpose. Drawn dummy layer please use main layer
 err1 = NOT INSIDE ALDUM DMCMK2
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_480_MIMDUM {
@ M1DOP/M1DUM/M1DPDOP/M1DPDUM/M2DUM/M2DOP/M2DPDUM/M2DPDOP/M3DUM/M3DOP/M3DPDUM/M3DPDOP/M4DUM/M4DOP/M5DUM/M5DOP/M6DUM/M6DOP/M7DUM/M7DOP/V1DUM/V2DUM/V3DUM/V4DUM/V5DUM/V6DUM/BV1DUM/BV2DUM/B1DUM/B1DOP/B2DUM/B2DOP/UTMDUM/TM1DUM/TM2DUM/ALDUM/MIMDUM/CTOPDUM/V0DUM/V0DPDUM must be covered by DMCMK2. Outside and cut is not allowed.These layers are dedicated for SMIC BEOL dummy auto-insertion utility usage, can't be used for manually drawn purpose. Drawn dummy layer please use main layer
 err1 = NOT INSIDE MIMDUM DMCMK2
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_480_CTOPDUM {
@ M1DOP/M1DUM/M1DPDOP/M1DPDUM/M2DUM/M2DOP/M2DPDUM/M2DPDOP/M3DUM/M3DOP/M3DPDUM/M3DPDOP/M4DUM/M4DOP/M5DUM/M5DOP/M6DUM/M6DOP/M7DUM/M7DOP/V1DUM/V2DUM/V3DUM/V4DUM/V5DUM/V6DUM/BV1DUM/BV2DUM/B1DUM/B1DOP/B2DUM/B2DOP/UTMDUM/TM1DUM/TM2DUM/ALDUM/MIMDUM/CTOPDUM/V0DUM/V0DPDUM must be covered by DMCMK2. Outside and cut is not allowed.These layers are dedicated for SMIC BEOL dummy auto-insertion utility usage, can't be used for manually drawn purpose. Drawn dummy layer please use main layer
 err1 = NOT INSIDE CTOPDUM DMCMK2
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_480_V0DUM {
@ M1DOP/M1DUM/M1DPDOP/M1DPDUM/M2DUM/M2DOP/M2DPDUM/M2DPDOP/M3DUM/M3DOP/M3DPDUM/M3DPDOP/M4DUM/M4DOP/M5DUM/M5DOP/M6DUM/M6DOP/M7DUM/M7DOP/V1DUM/V2DUM/V3DUM/V4DUM/V5DUM/V6DUM/BV1DUM/BV2DUM/B1DUM/B1DOP/B2DUM/B2DOP/UTMDUM/TM1DUM/TM2DUM/ALDUM/MIMDUM/CTOPDUM/V0DUM/V0DPDUM must be covered by DMCMK2. Outside and cut is not allowed.These layers are dedicated for SMIC BEOL dummy auto-insertion utility usage, can't be used for manually drawn purpose. Drawn dummy layer please use main layer
 err1 = NOT INSIDE V0DUM DMCMK2
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_480_V0DPDUM {
@ M1DOP/M1DUM/M1DPDOP/M1DPDUM/M2DUM/M2DOP/M2DPDUM/M2DPDOP/M3DUM/M3DOP/M3DPDUM/M3DPDOP/M4DUM/M4DOP/M5DUM/M5DOP/M6DUM/M6DOP/M7DUM/M7DOP/V1DUM/V2DUM/V3DUM/V4DUM/V5DUM/V6DUM/BV1DUM/BV2DUM/B1DUM/B1DOP/B2DUM/B2DOP/UTMDUM/TM1DUM/TM2DUM/ALDUM/MIMDUM/CTOPDUM/V0DUM/V0DPDUM must be covered by DMCMK2. Outside and cut is not allowed.These layers are dedicated for SMIC BEOL dummy auto-insertion utility usage, can't be used for manually drawn purpose. Drawn dummy layer please use main layer
 err1 = NOT INSIDE V0DPDUM DMCMK2
 err1 NOT INSIDE SealR_NOT_BULK
}


 
DUMC_481_M1 {
@ MnDUM or MnDPDUM (n = 1~3) minimum width >= 0.118um
 err1 = M1DUM_all WITH WIDTH < 0.118
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_481_M2 {
@ MnDUM or MnDPDUM (n = 1~3) minimum width >= 0.118um
 err1 = M2DUM_all WITH WIDTH < 0.118
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_481_M3 {
@ MnDUM or MnDPDUM (n = 1~3) minimum width >= 0.118um
 err1 = M3DUM_all WITH WIDTH < 0.118
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_482_M4 {
@ MnDUM (n>=4) minimum width >= 0.11um
 err1 = M4DUM WITH WIDTH < 0.11
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_482_M5 {
@ MnDUM (n>=4) minimum width >= 0.11um
 err1 = M5DUM WITH WIDTH < 0.11
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_482_M6 {
@ MnDUM (n>=4) minimum width >= 0.11um
 err1 = M6DUM WITH WIDTH < 0.11
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_482_M7 {
@ MnDUM (n>=4) minimum width >= 0.11um
 err1 = M7DUM WITH WIDTH < 0.11
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_483_M1 {
@ MnDOP or MnDPDOP (n = 1~3) minimum width >= 0.06um
 err1 = M1DOP_all WITH WIDTH < 0.06
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_483_M2 {
@ MnDOP or MnDPDOP (n = 1~3) minimum width >= 0.06um
 err1 = M2DOP_all WITH WIDTH < 0.06
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_483_M3 {
@ MnDOP or MnDPDOP (n = 1~3) minimum width >= 0.06um
 err1 = M3DOP_all WITH WIDTH < 0.06
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_484_M4 {
@ MnDOP (n>=4) minimum width >= 0.06um
 err1 = M4DOP WITH WIDTH < 0.06
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_484_M5 {
@ MnDOP (n>=4) minimum width >= 0.06um
 err1 = M5DOP WITH WIDTH < 0.06
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_484_M6 {
@ MnDOP (n>=4) minimum width >= 0.06um
 err1 = M6DOP WITH WIDTH < 0.06
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_484_M7 {
@ MnDOP (n>=4) minimum width >= 0.06um
 err1 = M7DOP WITH WIDTH < 0.06
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_488_TM2 {
@ TMnDUM (n = 1~2) minimum width >= 1.0um
 err1 = TM2DUM WITH WIDTH < 1
 err1 NOT INSIDE SealR_NOT_BULK
}


DUMC_490 {
@ ALDUM fixed width = 7.0um
 err1 = ALDUM NOT WITH WIDTH == 7.0
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_491 {
@ MIMDUM fixed width = 0.78um
 err1 = MIMDUM NOT WITH WIDTH == 0.78
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_492 {
@ CTOPDUM fixed width = 1.58um
 err1 = CTOPDUM NOT WITH WIDTH == 1.58
 err1 NOT INSIDE SealR_NOT_BULK
}

 
DUMC_493_M1 {
@ Space between (MnDUM or MnDPDUM) and MnDUM, MnDPDUM (n = 1~3), Overlap is not allowed. >= 0.094um
 err1 = EXT M1DUM_all < 0.094 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_493_M2 {
@ Space between (MnDUM or MnDPDUM) and MnDUM, MnDPDUM (n = 1~3), Overlap is not allowed. >= 0.094um
 err1 = EXT M2DUM_all < 0.094 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_493_M3 {
@ Space between (MnDUM or MnDPDUM) and MnDUM, MnDPDUM (n = 1~3), Overlap is not allowed. >= 0.094um
 err1 = EXT M3DUM_all < 0.094 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_494_M4 {
@ Space between MnDUM and MnDUM (n>=4), Overlap is not allowed. >= 0.102um
 err1 = EXT M4DUM < 0.102 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_494_M5 {
@ Space between MnDUM and MnDUM (n>=4), Overlap is not allowed. >= 0.102um
 err1 = EXT M5DUM < 0.102 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_494_M6 {
@ Space between MnDUM and MnDUM (n>=4), Overlap is not allowed. >= 0.102um
 err1 = EXT M6DUM < 0.102 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_494_M7 {
@ Space between MnDUM and MnDUM (n>=4), Overlap is not allowed. >= 0.102um
 err1 = EXT M7DUM < 0.102 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_495_M1 {
@ Space between (MnDOP or MnDPDOP) and MnDOP, MnDPDOP (n = 1~3), Overlap is not allowed >= 0.08um
 err1 = EXT M1DOP_all < 0.08 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_495_M2 {
@ Space between (MnDOP or MnDPDOP) and MnDOP, MnDPDOP (n = 1~3), Overlap is not allowed >= 0.08um
 err1 = EXT M2DOP_all < 0.08 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_495_M3 {
@ Space between (MnDOP or MnDPDOP) and MnDOP, MnDPDOP (n = 1~3), Overlap is not allowed >= 0.08um
 err1 = EXT M3DOP_all < 0.08 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_496_M4 {
@ Space between MnDOP and MnDOP (n>=4), Overlap is not allowed. >= 0.06um
 err1 = EXT M4DOP < 0.06 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_496_M5 {
@ Space between MnDOP and MnDOP (n>=4), Overlap is not allowed. >= 0.06um
 err1 = EXT M5DOP < 0.06 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_496_M6 {
@ Space between MnDOP and MnDOP (n>=4), Overlap is not allowed. >= 0.06um
 err1 = EXT M6DOP < 0.06 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_496_M7 {
@ Space between MnDOP and MnDOP (n>=4), Overlap is not allowed. >= 0.06um
 err1 = EXT M7DOP < 0.06 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_497_M1 {
@ Space between (MnDUM or MnDPDUM) and MnDOP, MnDPDOP (n = 1~3), Overlap is not allowed >= 0.2um
 err1 = EXT M1DUM_all M1DOP_all < 0.2 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_497_M2 {
@ Space between (MnDUM or MnDPDUM) and MnDOP, MnDPDOP (n = 1~3), Overlap is not allowed >= 0.2um
 err1 = EXT M2DUM_all M2DOP_all < 0.2 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_497_M3 {
@ Space between (MnDUM or MnDPDUM) and MnDOP, MnDPDOP (n = 1~3), Overlap is not allowed >= 0.2um
 err1 = EXT M3DUM_all M3DOP_all < 0.2 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_498_M4 {
@ Space between MnDUM and MnDOP (n>=4), Overlap is not allowed. >= 0.2um
 err1 = EXT M4DUM M4DOP < 0.2 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_498_M5 {
@ Space between MnDUM and MnDOP (n>=4), Overlap is not allowed. >= 0.2um
 err1 = EXT M5DUM M5DOP < 0.2 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_498_M6 {
@ Space between MnDUM and MnDOP (n>=4), Overlap is not allowed. >= 0.2um
 err1 = EXT M6DUM M6DOP < 0.2 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_498_M7 {
@ Space between MnDUM and MnDOP (n>=4), Overlap is not allowed. >= 0.2um
 err1 = EXT M7DUM M7DOP < 0.2 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_503_TM2 {
@ Space between TMnDUM and TMnDUM (n = 1~2) >= 0.75um
 err1 = EXT TM2DUM < 0.75 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_505_V1 {
@ VnDUM width (n>=1) = 0.096um
 err1 = V1DUM NOT WITH WIDTH == 0.096
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_506_V1 {
@ Space between VnDUM and VnDUM (n>=1), Overlap is not allowed >= 0.242um
 err1 = EXT V1DUM < 0.242 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_505_V2 {
@ VnDUM width (n>=1) = 0.096um
 err1 = V2DUM NOT WITH WIDTH == 0.096
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_506_V2 {
@ Space between VnDUM and VnDUM (n>=1), Overlap is not allowed >= 0.242um
 err1 = EXT V2DUM < 0.242 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_505_V3 {
@ VnDUM width (n>=1) = 0.096um
 err1 = V3DUM NOT WITH WIDTH == 0.096
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_506_V3 {
@ Space between VnDUM and VnDUM (n>=1), Overlap is not allowed >= 0.242um
 err1 = EXT V3DUM < 0.242 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_505_V4 {
@ VnDUM width (n>=1) = 0.096um
 err1 = V4DUM NOT WITH WIDTH == 0.096
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_506_V4 {
@ Space between VnDUM and VnDUM (n>=1), Overlap is not allowed >= 0.242um
 err1 = EXT V4DUM < 0.242 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_505_V5 {
@ VnDUM width (n>=1) = 0.096um
 err1 = V5DUM NOT WITH WIDTH == 0.096
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_506_V5 {
@ Space between VnDUM and VnDUM (n>=1), Overlap is not allowed >= 0.242um
 err1 = EXT V5DUM < 0.242 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_505_V6 {
@ VnDUM width (n>=1) = 0.096um
 err1 = V6DUM NOT WITH WIDTH == 0.096
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_506_V6 {
@ Space between VnDUM and VnDUM (n>=1), Overlap is not allowed >= 0.242um
 err1 = EXT V6DUM < 0.242 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_507_V1 {
@ VnDUM enclosure by bottom metal dummy (MnDUM or MnDPDUM) (n = 1~3) (all sides), Outside is not allowed. VnDUM enclosure by bottom metal dummy MnDUM (n>=4) (all sides), Outside is not allowed.Base on metal option to select bottom metal dummy >= 0.007um
 err1 = ENC V1DUM (OR M1DUM M1DPDUM ) < 0.007 ABUT<90 SINGULAR REGION OUTSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_507_V2 {
@ VnDUM enclosure by bottom metal dummy (MnDUM or MnDPDUM) (n = 1~3) (all sides), Outside is not allowed. VnDUM enclosure by bottom metal dummy MnDUM (n>=4) (all sides), Outside is not allowed.Base on metal option to select bottom metal dummy >= 0.007um
 err1 = ENC V2DUM (OR M2DUM M2DPDUM ) < 0.007 ABUT<90 SINGULAR REGION OUTSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_507_V3 {
@ VnDUM enclosure by bottom metal dummy (MnDUM or MnDPDUM) (n = 1~3) (all sides), Outside is not allowed. VnDUM enclosure by bottom metal dummy MnDUM (n>=4) (all sides), Outside is not allowed.Base on metal option to select bottom metal dummy >= 0.007um
 err1 = ENC V3DUM (OR M3DUM M3DPDUM ) < 0.007 ABUT<90 SINGULAR REGION OUTSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_507_V4 {
@ VnDUM enclosure by bottom metal dummy (MnDUM or MnDPDUM) (n = 1~3) (all sides), Outside is not allowed. VnDUM enclosure by bottom metal dummy MnDUM (n>=4) (all sides), Outside is not allowed.Base on metal option to select bottom metal dummy >= 0.007um
 err1 = ENC V4DUM M4DUM < 0.007 ABUT<90 SINGULAR REGION OUTSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_507_V5 {
@ VnDUM enclosure by bottom metal dummy (MnDUM or MnDPDUM) (n = 1~3) (all sides), Outside is not allowed. VnDUM enclosure by bottom metal dummy MnDUM (n>=4) (all sides), Outside is not allowed.Base on metal option to select bottom metal dummy >= 0.007um
 err1 = ENC V5DUM M5DUM < 0.007 ABUT<90 SINGULAR REGION OUTSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_507_V6 {
@ VnDUM enclosure by bottom metal dummy (MnDUM or MnDPDUM) (n = 1~3) (all sides), Outside is not allowed. VnDUM enclosure by bottom metal dummy MnDUM (n>=4) (all sides), Outside is not allowed.Base on metal option to select bottom metal dummy >= 0.007um
 err1 = ENC V6DUM M6DUM < 0.007 ABUT<90 SINGULAR REGION OUTSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_507_V7 {
@ VnDUM enclosure by bottom metal dummy (MnDUM or MnDPDUM) (n = 1~3) (all sides), Outside is not allowed. VnDUM enclosure by bottom metal dummy MnDUM (n>=4) (all sides), Outside is not allowed.Base on metal option to select bottom metal dummy >= 0.007um
 err1 = ENC V7DUM M7DUM < 0.007 ABUT<90 SINGULAR REGION OUTSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_508_V1 {
@ VnDUM (n = 1~2) enclosure by upper metal dummy (MnDUM or MnDPDUM) (n = 2~3) (all sides), Outside is not allowed.VnDUM (n>=3) enclosure by upper metal dummy MnDUM (n>=4) (all sides), Outside is not allowed. (base on metal option to select upper metal dummy) >= 0.007um
 err1 = ENC V1DUM (OR M2DUM M2DPDUM) < 0.007 ABUT<90 SINGULAR REGION OUTSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_508_V2 {
@ VnDUM (n = 1~2) enclosure by upper metal dummy (MnDUM or MnDPDUM) (n = 2~3) (all sides), Outside is not allowed.VnDUM (n>=3) enclosure by upper metal dummy MnDUM (n>=4) (all sides), Outside is not allowed. (base on metal option to select upper metal dummy) >= 0.007um
 err1 = ENC V2DUM (OR M3DUM M3DPDUM) < 0.007 ABUT<90 SINGULAR REGION OUTSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
DUMC_508_V3 {
@ VnDUM (n = 1~2) enclosure by upper metal dummy (MnDUM or MnDPDUM) (n = 2~3) (all sides), Outside is not allowed.VnDUM (n>=3) enclosure by upper metal dummy MnDUM (n>=4) (all sides), Outside is not allowed. (base on metal option to select upper metal dummy) >= 0.007um
 err1 = ENC V3DUM M4DUM < 0.007 ABUT<90 SINGULAR REGION OUTSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_508_V4 {
@ VnDUM (n = 1~2) enclosure by upper metal dummy (MnDUM or MnDPDUM) (n = 2~3) (all sides), Outside is not allowed.VnDUM (n>=3) enclosure by upper metal dummy MnDUM (n>=4) (all sides), Outside is not allowed. (base on metal option to select upper metal dummy) >= 0.007um
 err1 = ENC V4DUM M5DUM < 0.007 ABUT<90 SINGULAR REGION OUTSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_508_V5 {
@ VnDUM (n = 1~2) enclosure by upper metal dummy (MnDUM or MnDPDUM) (n = 2~3) (all sides), Outside is not allowed.VnDUM (n>=3) enclosure by upper metal dummy MnDUM (n>=4) (all sides), Outside is not allowed. (base on metal option to select upper metal dummy) >= 0.007um
 err1 = ENC V5DUM M6DUM < 0.007 ABUT<90 SINGULAR REGION OUTSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_508_V6 {
@ VnDUM (n = 1~2) enclosure by upper metal dummy (MnDUM or MnDPDUM) (n = 2~3) (all sides), Outside is not allowed.VnDUM (n>=3) enclosure by upper metal dummy MnDUM (n>=4) (all sides), Outside is not allowed. (base on metal option to select upper metal dummy) >= 0.007um
 err1 = ENC V6DUM M7DUM < 0.007 ABUT<90 SINGULAR REGION OUTSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_508_V7 {
@ VnDUM (n = 1~2) enclosure by upper metal dummy (MnDUM or MnDPDUM) (n = 2~3) (all sides), Outside is not allowed.VnDUM (n>=3) enclosure by upper metal dummy MnDUM (n>=4) (all sides), Outside is not allowed. (base on metal option to select upper metal dummy) >= 0.007um
 err1 = ENC V7DUM M8DUM < 0.007 ABUT<90 SINGULAR REGION OUTSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_509 {
@ Space between (M1DUM or M1DPDUM) and OCCDFH, OCCDM1, Overlap is not allowed. >= 0.75um
  err1 = EXT M1DUM_all OCCDFH < 0.75 ABUT<90 SINGULAR REGION INSIDE ALSO
  err2 = EXT M1DUM_all OCCDM1 < 0.75 ABUT<90 SINGULAR REGION INSIDE ALSO
  err1 NOT INSIDE SealR_NOT_BULK
  err2 NOT INSIDE SealR_NOT_BULK
}

DUMC_510_M2 {
@ Space between (MnDUM or MnDPDUM) and OCCDMn (n = 2~3), Overlap is not allowed. >= 0.75um
  err1 = EXT M2DUM_all OCCDM2 < 0.75 ABUT<90 SINGULAR REGION INSIDE ALSO
  err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_510_M3 {
@ Space between (MnDUM or MnDPDUM) and OCCDMn (n = 2~3), Overlap is not allowed. >= 0.75um
  err1 = EXT M3DUM_all OCCDM3 < 0.75 ABUT<90 SINGULAR REGION INSIDE ALSO
  err1 NOT INSIDE SealR_NOT_BULK
}

 
DUMC_511_M4 {
@ Space between MnDUM and OCCDMn (n>=4), Overlap is not allowed. >= 0.75um
 err1 = EXT M4DUM OCCDM4 < 0.75 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_511_M5 {
@ Space between MnDUM and OCCDMn (n>=4), Overlap is not allowed. >= 0.75um
 err1 = EXT M5DUM OCCDM5 < 0.75 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_511_M6 {
@ Space between MnDUM and OCCDMn (n>=4), Overlap is not allowed. >= 0.75um
 err1 = EXT M6DUM OCCDM6 < 0.75 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_511_M7 {
@ Space between MnDUM and OCCDMn (n>=4), Overlap is not allowed. >= 0.75um
 err1 = EXT M7DUM OCCDM7 < 0.75 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_513 {
@ Space between (M1DOP or M1DPDOP) and OCCDFH, OCCDM1, Overlap is not allowed. >= 0.335um
 err1 = EXT M1DOP_all OCCDFH < 0.335 ABUT<90 SINGULAR REGION INSIDE ALSO
 err2 = EXT M1DOP_all OCCDM1 < 0.335 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

DUMC_514_M2 {
@ Space between (MnDOP or MnDPDOP) and OCCDMn (n = 2~3), Overlap is not allowed. >= 0.335um
 err1 = EXT M2DOP_all OCCDM2 < 0.335 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_514_M3 {
@ Space between (MnDOP or MnDPDOP) and OCCDMn (n = 2~3), Overlap is not allowed. >= 0.335um
 err1 = EXT M3DOP_all OCCDM3 < 0.335 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

 
DUMC_515_M4 {
@ Space between MnDOP and OCCDMn (n>=4), Overlap is not allowed. >= 0.335um
 err1 = EXT M4DOP OCCDM4 < 0.335 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_515_M5 {
@ Space between MnDOP and OCCDMn (n>=4), Overlap is not allowed. >= 0.335um
 err1 = EXT M5DOP OCCDM5 < 0.335 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_515_M6 {
@ Space between MnDOP and OCCDMn (n>=4), Overlap is not allowed. >= 0.335um
 err1 = EXT M6DOP OCCDM6 < 0.335 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
 
DUMC_515_M7 {
@ Space between MnDOP and OCCDMn (n>=4), Overlap is not allowed. >= 0.335um
 err1 = EXT M7DOP OCCDM7 < 0.335 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_517 {
@ Space between MIMDUM or CTOPDUM and MIM, CTOP, Overlap is not allowed. >= 2.000um
 err1 = EXT (OR MIMDUM CTOPDUM) (OR MIM CTOP) < 2 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_518_MIMDUB {
@ Space between MIMDUM or CTOPDUM and MIMDUB, CTOPDUB, NODMF, MARKG, MARKS, TM1, Overlap is not allowed. >= 2.000um
 err1 = EXT (OR MIMDUM CTOPDUM) MIMDUB < 2 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_518_CTOPDUB {
@ Space between MIMDUM or CTOPDUM and MIMDUB, CTOPDUB, NODMF, MARKG, MARKS, TM1, Overlap is not allowed. >= 2.000um
 err1 = EXT (OR MIMDUM CTOPDUM) CTOPDUB < 2 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_518_NODMF {
@ Space between MIMDUM or CTOPDUM and MIMDUB, CTOPDUB, NODMF, MARKG, MARKS, TM1, Overlap is not allowed. >= 2.000um
 err1 = EXT (OR MIMDUM CTOPDUM) NODMF < 2 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_518_MARKG {
@ Space between MIMDUM or CTOPDUM and MIMDUB, CTOPDUB, NODMF, MARKG, MARKS, TM1, Overlap is not allowed. >= 2.000um
 err1 = EXT (OR MIMDUM CTOPDUM) MARKG < 2 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_518_MARKS {
@ Space between MIMDUM or CTOPDUM and MIMDUB, CTOPDUB, NODMF, MARKG, MARKS, TM1, Overlap is not allowed. >= 2.000um
 err1 = EXT (OR MIMDUM CTOPDUM) MARKS < 2 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_518_TM1 {
@ Space between MIMDUM or CTOPDUM and MIMDUB, CTOPDUB, NODMF, MARKG, MARKS, TM1, Overlap is not allowed. >= 2.000um
 err1 = EXT (OR MIMDUM CTOPDUM) TM1i < 2 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

#IFDEF CHIPB_RULES_CHECK YES
DUMC_519 {
@ Inside edge of CHIPB space to MIMDUM, CTOPDUM, Outside is not allowed. >= 2.000um
 err1 = ENC (OR MIMDUM CTOPDUM) CHIPB < 2 ABUT<90 SINGULAR REGION OUTSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}
#ENDIF

DUMC_520 {
@ Space between MIMDUM and 45-degree MIM, Overlap is not allowed. >= 2.000um
 chk_edge = ANGLE MIM > 44.5 < 45.5
 err1 = EXT MIMDUM chk_edge < 2 ABUT<90 OPPOSITE2 REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_521 {
@ Space between CTOPDUM and 45-degree CTOP, Overlap is not allowed >= 2.000um
 chk_edge = ANGLE CTOP > 44.5 < 45.5
 err1 = EXT CTOPDUM chk_edge < 2 ABUT<90 OPPOSITE2 REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_522 {
@ MIMDUM must be enclosed by CTOPDUM, outside and cut is not allowed = 0.400um
 err1 = SIZE MIMDUM BY 0.4
 err2 = XOR err1 CTOPDUM
 err2 NOT INSIDE SealR_NOT_BULK
}

DUMC_523 {
@ V0DUM width = 0.096um
 err1 = V0DUM NOT WITH WIDTH == 0.096
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_524 {
@ Space between (V0DUM or V0DPDUM) and V0DUM, V0DPDUM, Overlap is not allowed >= 0.106um
 err1 = EXT (OR V0DUM V0DPDUM) < 0.106 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_525 {
@ Space between (V0DUM or V0DPDUM) and V0, Overlap is not allowed >= 0.75um
 err1 = EXT (OR V0DUM V0DPDUM) V0 < 0.75 ABUT<90 SINGULAR REGION INSIDE ALSO
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_526 {
@ (V0DUM or V0DPDUM) enclosure by M0GDUM, outside is not allowed >= 0um
 err1 = (OR V0DUM V0DPDUM ) NOT INSIDE M0GDUM
 err1 NOT INSIDE SealR_NOT_BULK
}

DUMC_527 {
@ (V0DUM or V0DPDUM) enclosure by (M1DUM or M1DPDUM), outside is not allowed >= 0um
 err1 = (OR V0DUM V0DPDUM ) NOT INSIDE (OR M1DUM M1DPDUM )
 err1 NOT INSIDE SealR_NOT_BULK
}

