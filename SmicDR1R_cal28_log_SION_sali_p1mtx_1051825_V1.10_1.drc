#! tvf
namespace import tvf::*

#Note 1: This Rule File will select to check M1,1xMn(n=2~8),2xMn(B1,B2),8xTMn(Mn=TM1,TM2),10xTMn(STM1,STM2),MTT2; 1xVn(n=1~7),2xVn(W0, W1),8xTVn(Vn=TV1,TV2),10xTVn(STV1,STV2).
#Note 2: "Switches selection 1" is for Metallization Options,please select one "value" for each switch in "Switches selection 1" base on the chip design.
#         Here user can refer to design rule for metal options
#Note 3: This runset must be run with calibre v2013.4_15.12


#//*************************************
#//    Switches selection 1 
#//*************************************

set total_metal_counts 12      		;# Valid value is 5,6,7,8,9,10,11,12.

set 2X_metal_counts 2         		;# Valid value is 0,1,2.

set 8X_top_metal_counts 2     		;# Valid value is 0,1,2.

set 10X_top_metal_counts 0    		;# Valid value is 0,1,2.
    
set MTT2_top_metal_counts 0   		;# Valid value is 0,1.

#//*************************************
#//    Switches selection 2 
#//*************************************

set DEFINE_PAD_BY_TEXT  1    		
					;# Valid value is 0, 1. The default setting is 1.
                             		;# When“?VDD?”,”?VCC?”,“?VSS?”,”?GND?” as text name using layer ALPATXT on ALPA.
                             		;# If valid value is 0, it is regarded as I/O PAD; if valid value is 1, it is regarded POWER PAD.    

set CONNECT_ALL_RESISTOR 0   		
					;# Valid value is 0, 1. The default setting is 0 
                             		;# When resistors are between PAD and AA injector. 
                             		;# If valid value is 0, the connection is broken; if valid value is 1, the connection is not broken.
 
VERBATIM {
//*************************************
//    Switches selection 3
//*************************************

/*This section describes the chip corner requirements to prevent the chip design interferes with seal ring.
1. This switch only applies for chips that need to have seal ring insertion. The chip corner rule check option is default turned on in DRC script.
2. In case for the building block/IP level design, or the chip level design with seal ring already inserted, please turn off this check option.
*/

#DEFINE CORN_CHECK YES      
					// Please set the switch based on the descriptions above.
                            		// The default setting is "YES" to check chip coner rules.
                            		// Please change the "YES" in "NO" if CORN rules shouldn't be checked.

//*************************************
//    Switches selection 4
//*************************************

/*DRC runset provides switch for BORDER rule DRC check, which is turn-on by default, this switch can be turn-off for IP level DRC check.*/

#DEFINE BORDER_CHECK YES    
					// Please set the switch based on the descriptions above.
                            		// The default setting is "YES" to check BORDER rules.
                            		// Please change the "YES" in "NO" if BORDER rules shouldn't be checked.

//*************************************
//    Switches selection 5
//*************************************

/*Please notice that all guideline rules are named as *_G in this runset file*/

#DEFINE Guidelines_rules_CHECK YES       
					// Please set the switch based on the descriptions below.
                                        // The default setting is "YES" to check Guidelines rules.
                                        // Please change the "YES" into "NO" if Guidelines rules shouldn't be checked.

   #IFDEF Guidelines_rules_CHECK YES 
#DEFINE Guidelines_ESDrules_CHECK NO    
   #ENDIF                               
					// This switch is only for ESD guideline rules.
					// The default setting for Guidelines_ESDrules_CHECK is "NO" to not check ESD rules, when the Guidelines_rules_CHECK is set to "YES".
                                        // Please change the "NO" into "YES" to check the ESD rules, and set Guidelines_rules_CHECK to "YES". 

//*************************************
//    Switches selection 6
//*************************************

/*Please notice that priority 1/2/3 DFM rules are named as *_R_DFM1, *_R_DFM2 and *_R_DFM3 respectively in this runset file*/

#DEFINE DFM_rules_CHECK_priority_1_2 YES    
					// Please set the switch based on the descriptions in DR.
                                	// The default setting is "YES" to check check priority 1/2 DFM rules.
                                	// Please change the "YES" to "NO" if you don't want to check these rules.

#DEFINE DFM_rules_CHECK_priority_3 NO     
					// This switch is for priority 3 DFM rules.
                                	// The default setting is "NO" not to check priority 3 DFM rules.
                                	// Please change the "NO" to "YES" if you also want to check priority 3 DFM rules together with other rules.

//*************************************
//    Switches selection 7
//*************************************

/*This switch is only for offgrid check rule DGR.1.
All the geometry design must be an integer multiple of 0.005um OUTSIDE SRAM region (OUTSIDE INST covered region).
*/

#DEFINE OFFGRID_CHECK YES                   
					// The default setting is "YES" to check offgrid check rule DGR.1.
                                	// Please change the "YES" to "NO" if you also want to check offgrid check rule DGR.1 together with other rules.

//*************************************
//    Switches selection 8
//*************************************
 
#DEFINE CHIP_CHECK YES          
					// This switch is only for GT_55 rule.
                                	// The default setting is "YES" to check chip level.
                                	// Please change the "YES" to "NO" if you also want to check IP level.     

//*************************************
//    Switches selection 9 
//*************************************

#DEFINE LU_3_CHECK FAST    
					// This switch is only for LU_3_3a_G, LU_3_3b_G, LU_3_3c_G, LU_3_3d_G rules.
					// The default setting is "FAST" to fast check LU_3_? rules and reduce runtime,yet it may report false alarm in min space value.
					// Please change the "FAST" to "ACCURATE",if you want to accurately check LU_3_? rules, yet it have long runtime.
                              

//*********************the END for switch setting*************************************************

//********************************************************************************       
//                           CALIBRE DRC PROGRAM		         	    
//******************************************************************************** 

//=================================================================================
//|                                                                               |
//|  28nm 1P12M Calibre DRC rule file for                                         | 
//|                                                                               |
//|       SMIC:     28nm Logic Low Power (Poly/SION) 1.05V/1.8V/2.5V Design Rules |
//|                                                                               |
//|       Doc. No:   TD-LO28-DR-2006         Doc.Rev: 1R  Tech Dev.Rev : 1.10     |
//|                                                                               |
//|       SMIC  Technologies                                                      |
//|                                                                               |
//|===============================================================================|
//|                                                                               |
//|    DISCLAIMER                                                                 |
//|                                                                               |
//|   SMIC hereby provides the quality information to you but makes no claims,    |
//| promises or guarantees about the accuracy, completeness, or adequacy of the   |
//| information herein. The information contained herein is provided on an "AS IS"|
//| basis without any warranty, and SMIC assumes no obligation to provide support |
//| of any kind or otherwise maintain the information.                            |
//|                                                                               |
//|   SMIC disclaims any representation that the information does not infringe any|
//| intellectual property rights or proprietary rights of any third parties.SMIC  |
//| makes no other warranty, whether express, implied or statutory as to any      |
//| matter whatsoever, including but not limited to the accuracy or sufficiency of|
//| any information or the merchantability and fitness for a particular purpose.  |
//| Neither SMIC nor any of its representatives shall be liable for any cause of  |
//| action incurred to connect to this service.                                   |
//|                                                                               |
//|===============================================================================|
//|                                                                               |
//|    STATEMENT OF USE AND CONFIDENTIALITY                                       |
//|                                                                               |
//|   The following/attached material contains confidential and proprietary       |
//| information of SMIC. This material is based upon information which SMIC       |
//| considers reliable, but SMIC neither represents nor warrants that such        |
//| information is accurate or complete, and it must not be relied upon as such.  |
//| This information was prepared for informational purposes and is for the use by|
//| SMIC's customer only. SMIC reserves the right to make changes in the          |
//| information at any time without notice.                                       |
//|   No part of this information may be reproduced, transmitted, transcribed,    |
//| stored in a retrieval system, or translated into any human or computer        |
//| language, in any form or by any means, electronic, mechanical, magnetic,      |
//| optical, chemical, manual, or otherwise, without the prior written consent of |
//| SMIC. Any unauthorized use or disclosure of this material is strictly         |
//| prohibited and may be unlawful. By accepting this material, the receiving     |
//| party shall be deemed to have acknowledged, accepted, and agreed to be bound  |
//| by the foregoing limitations and restrictions. Thank you.                     |
//|                                                                               |
//|===============================================================================|
//|                                                                               |
//|   This file includes SVRF/TVF Technology under license by Mentor Graphics     |
//| Corporation.  "SVRF/TVF Technology" shall mean Mentor Graphics' Standard      |
//| Verification Rule Format ("SVRF") and Tcl Verification Format ("TVF")         |
//| proprietary syntaxes for expressing process rules.  You shall not use SVRF/TVF|
//| Technology unless you are a Mentor Graphics customer with a license to use the|
//| applicable Mentor Graphics software. The exact terms of your obligations and  |
//| rights are governed by your respective license.  You shall not use SVRF/TVF   |
//| Technology except: (a) for your internal business purposes and (b) for use    |
//| with Mentor Graphics' Calibre tools. All SVRF/TVF Technology constitutes or   |
//| contains trade secrets and confidential information of Mentor Graphics or its |
//| licensors. You shall not make SVRF/TVF Technology available in any form to any|
//| person other than your employees and on-site contractors, excluding Mentor    |
//| Graphics competitors, whose job performance requires access and who are under |
//| obligations of confidentiality.                                               |
//|                                                                               |
//|=====================================================================================|
//|                                                                                     |
//| Validated with Calibre version v2013.4_15.12                                        |
//|                                                                                     |
//| Revision History :                                                                  |
//|                                                                                     |
//|     Rev            Date          Who                      What                 	|
//| -----------   -------------  -----------   -----------------------------------------|
//| V1.10_1       22-Sep-2015   Dorian Zheng    1.Update procedure "Mn_one_width","GATE_LE" and "GATEDMP_LE" definition to reduce runtime (No impact for DRC result.).|
//|						2.Modify GTDMP_18_R log file's name (No impact for DRC result.).|
//|						3.Update ESD_15,ESD_17,P2_15,DUMC_TMn_5,CT_7_7c_7d_7e_7f_7g_7h,CT_7e_R,CT_12 to reduce false alarm.|
//|						4.Optimize 1xRVn_7 to reduce run time and correct checking range.|
//|						5.Update below rules to reduce runtime only:|
//|						  Update AA_2a/2b/4a/4a_R_DFM3/4c/20/22/34,NW_6,GT_5/6a/6b/6c/7a/7b/7c/7d/20/21b/21c/21d/22/24.|
//|						  Update GT_29a/29b/29c/30a_R_DFM3/30b/33/39a/39b/49_R_DFM3/50/51_R_DFM3/52/53/57.|
//|						  Update GTMK2_1,P2_8,GTDMP_7/12/21.    |
//|						  Update 1XVn_2a_2b/3_3a_3b_3c_3d/3_3a_3b_3c_3d_R_DFM3/4_4a_4b_4c_4d_R_DFM3.|
//|						  Update 1XVn_5a/5b/5c/6a/6b/6c,1XRVn_3_3a_3b_3c_3d/4/5a/5b/5c/7,MOM_1,2XMn_4_5.|
//|						  Update M1_3/5a/6a/6b/17a,1XMn_1/5a/5b/5c/5d/15a/15a_R_DFM3/16,LU_4.|
//|											|
//|     Rev                 Date          Who                      What                 |
//| -----------------   -------------  -----------  ------------------------------------|
//| V1.10_1R            13-Jan-2015      Li Liu     Update density rules coding as below: 
//|                                                   AA_21a, AA_21b,AA_21b_R_DFM3,AA_21c,AA_21d,AA_21e,AA_21f
//|                                                   AADMP_18_R_DFM3,GT_34,GT_35,GT_36,GTDMP_18_R_DFM3,P2_22_R_DFM2
//|                                                   M1_19,M1_20,M1_21_R_DFM2,M1_22,M1_23,1XMn_18,1XMn_19,1XMn_20_R_DFM2
//|                                                   1XMn_21,1XMn_22,1XMn_23,1XMn_24,2XMn_11,2XMn_12,2XMn_13_R_DFM2
//|                                                    8XTMn_5,8XTMn_5_h_R_DFM2,8XTMn_6_R_DFM2,8XTMn_7,10XTMn_5,10XTMn_6_l_R_DFM2
//|                                                    10XTMn_6_h_R_DFM2,10XTMn_7,MTT2_8,MTT2_9,ALPA_3_R_DFM2,ALPA_5,ALPA_6,DUMC_P2_10,
//|                                                Update connection, related these coding as below:
//|                                                    DNW_5,DNW_8,DNW_9,NW_5~ NW_8,GT_22,GT_28,GT_56,GTDMP_10,GTDMP_11,GTDMP_12
//|                                                    CT_2c,CT_18,M1_10~M1_15,1XMn_8~1XMn_13,2XMn_8,2XVn_4.
//|                                                Update DGR.1,DGR4, AA.6, AA.27a/b, AA.23, LVT_N.11, LVT_P.11, AADMP.1 ,
//|                                                  AADMP.18/GTDMP.18, AADMP.17 ,AADMP.13, G.T.5/36, GT.6a/7a, GT.8d, GT.22
//|                                                  GT.30a/30a[R], GT.35, GT.31/55 ,GT.28/56 ,CT.6/6a/6b/6c//6a[R]/6b[R ,CT.9/9a/9b/9c,
//|                                                  M1.11c, M1.12~15, M1.17b/17c,1xMn.1, 1xMn.10-13, 1xMn.15b, 1xRVn.7 ,1xRVn.8
//|                                                  2xMn.1,8xTMn.2c,8xTMn.5/.5[R] ,10xTMn.5/.6[R]  LT.4/6, MTT2.5 ,MTT2.8/9
//|                                                  PA.4, DUP.5, RESAA.5[G] RESP1.5[G] EFU.6, EFU.8, CT.12/GT.27/SAB.12/SAB.5/M1.7[R]
//|                                                  1xMn.6[R]/ 1xMn.24,LU.1/2/3/6, LU.4. DUMC.GT.07, DUMC.Mn.00, DUMC.P2.05,
//|                                                  DUMC.M1.06-07, DUMC.Mn.05-07
//|                                                Add the switch "#DEFINE Guidelines_ESDrules_CHECK NO","#DEFINE LU_3_CHECK FAST"  
//|                                                Add AADMP.9/GTDMP.8, DG.16/17,TG.15/16; SN.15b/SP.15b ,M1.30, RESAA.13[G]/RESP1.14[G]
//|                                                Add LD rules, IND rules. 
//|                                                Change AA.1b[R]/ AA.21f[R]/ M1.7[R]/ 1xMn.6[R]/ 2xMn.6[R]/ 8xTMn .2d[R]/ 10xTMn .2d[R] to pri 3
//|                                                Change GTDMP.24 to main rule. GT.36[R]:change to main rule
//|                                                Change SN.15/SP.15 rule No to SN.15a/SP.15a.
//|                                                Delete DUMC.GT.22; MD.6[R]/ ALPA.4[R]
//|                                                Separate s SR.2[G]/3[G]/4[G]/5[G] to two rules at straight direction 
//|                                                    and at 45 degree angle area;
//|                                                Change SR.6[G]/7[G] ruel value,
//|                                                   Update SR.14[G] description;
//|                                                Delete [G] for SR.11-14.
//|
//|   Pre1.0_20141006   6-Oct-2014      Li Liu       update 1XRVn.8a,1XRVn.8b,1XRVn.8c to reduce runtime  |
//|  
//|   Pre1.0_20140924   24-Sep-2014     Li Liu        update CONNECT definition to avoid missing violations for below rules     
//|                                                    DNW_5 DNW_8 DNW_9  NW_6 NW_7 NW_8 GT_22 GT_55 CT_2c 
//|                                                    1XVn_10_R_DFM3 1XRVn_13_R_DFM3 2XV8_4 2XV9_4
//|
//|   V1.0_0R           7-Jul-2014     Li Liu             initial version             |
//| ------------------------------------------------------------------------------------|
//|=====================================================================================|
}


VERBATIM {
//************************************
//Calibre severity proposals
//************************************
LAYOUT INPUT EXCEPTION SEVERITY PATH_NONSIMPLE 2
LAYOUT INPUT EXCEPTION SEVERITY PATH_CIRCULAR 6
LAYOUT INPUT EXCEPTION SEVERITY POLYGON_NONSIMPLE 2
LAYOUT INPUT EXCEPTION SEVERITY POLYGON_NOT_CLOSED 2
LAYOUT INPUT EXCEPTION SEVERITY PATH_ENDSEGMENT_SHORT 2
LAYOUT INPUT EXCEPTION SEVERITY PATH_ACUTE 4
LAYOUT INPUT EXCEPTION SEVERITY PATH_WIDTH_ZERO 2
LAYOUT INPUT EXCEPTION SEVERITY POLYGON_IS_RECTANGLE 2
LAYOUT INPUT EXCEPTION SEVERITY BOX_RECORD 4
LAYOUT INPUT EXCEPTION SEVERITY NODE_RECORD 4

LAYOUT ERROR ON INPUT YES
LAYOUT PROCESS BOX RECORD NO
LAYOUT PROCESS NODE RECORD NO
LAYOUT ALLOW DUPLICATE CELL NO


SVRF VERSION "v2013.1_14.11"
FLATTEN VERY SMALL CELLS YES


//*************************************
//     DIRECTIVE SECTION
//*************************************
LAYOUT PRIMARY "topcell" 
LAYOUT PATH "xxx.gds"
LAYOUT SYSTEM GDSII 

DRC RESULTS DATABASE "TOP_SmicDR1R_cal28_log_sali_p1mtx.OUT" ASCII 
DRC SUMMARY REPORT "TOP_SmicDR1R_cal28_log_sali_p1mtx.SUM" HIER 

PRECISION       1000
RESOLUTION      5

FLAG ACUTE YES
FLAG NONSIMPLE YES
FLAG SKEW YES
FLAG OFFGRID YES


DRC EXCLUDE FALSE NOTCH YES

TEXT DEPTH PRIMARY

LVS POWER NAME "?VDD?" "?VCC?"
LVS GROUND NAME  "?VSS?" "?GND?"


GROUP Guidelines_rules ?_G 
GROUP Guidelines_ESDrules ESD_?_G

#IFDEF Guidelines_rules_CHECK NO
DRC UNSELECT CHECK Guidelines_rules
#ENDIF

#IFDEF Guidelines_ESDrules_CHECK NO
DRC UNSELECT CHECK Guidelines_ESDrules
#ENDIF


GROUP DFM_rules_all ?_R_?
//GROUP DFM_rules_priority_1_2 ?_R_DFM1 ?_R_DFM2
GROUP DFM_rules_priority_1_2 ?_R_DFM2
GROUP DFM_rules_priority_3 ?_R_DFM3


#IFDEF DFM_rules_CHECK_priority_1_2 NO
DRC UNSELECT CHECK DFM_rules_priority_1_2
#ENDIF

#IFDEF DFM_rules_CHECK_priority_3 NO
DRC UNSELECT CHECK DFM_rules_priority_3
#ENDIF


GROUP GDGR_1 DGR_1_?
#IFDEF OFFGRID_CHECK NO
DRC UNSELECT CHECK GDGR_1
#ENDIF


//************************************
//     INPUT LAYER STATEMENTS
//************************************

LAYER MAP 6  DATATYPE  0  600
LAYER PSR 600

LAYER MAP 6  DATATYPE  239  601
LAYER PSRBL 601

LAYER MAP 9  DATATYPE  0  602
LAYER KV 602

LAYER MAP 10  DATATYPE  0  603
LAYER AA 603

LAYER MAP 10  DATATYPE  1  604
LAYER AADUM 604

LAYER MAP 10  DATATYPE  7  605
LAYER AADOP 605

LAYER MAP 12  DATATYPE  138  606
LAYER SNBL 606

LAYER MAP 12  DATATYPE  150  607
LAYER NLDB 607

LAYER MAP 13  DATATYPE  150  608
LAYER PLDB 608

LAYER MAP 13  DATATYPE  239  609
LAYER SPBL 609

LAYER MAP 14  DATATYPE  0  610
LAYER NW 610

LAYER MAP 15  DATATYPE  0  611
LAYER TP 611

LAYER MAP 16  DATATYPE  0  612
LAYER PC 612

LAYER MAP 19  DATATYPE  0  613
LAYER DNW 613

LAYER MAP 20  DATATYPE  0  614
LAYER PWi 614

LAYER MAP 21  DATATYPE  0  615
LAYER NC 615

LAYER MAP 24  DATATYPE  0  616
LAYER TN 616

LAYER MAP 26  DATATYPE  0  617
LAYER LOGO 617

LAYER MAP 29  DATATYPE  0  618
LAYER DG 618

LAYER MAP 29  DATATYPE  2  619
LAYER DGOD 619

LAYER MAP 30  DATATYPE  0  620
LAYER GT 620

LAYER MAP 30  DATATYPE  1  621
LAYER GTDUM 621

LAYER MAP 30  DATATYPE  7  622
LAYER GTDOP 622

LAYER MAP 31  DATATYPE  0  623
LAYER P2 623

LAYER MAP 33  DATATYPE  0  624
LAYER P4 624

LAYER MAP 34  DATATYPE  0  625
LAYER HR 625

LAYER MAP 35  DATATYPE  0  626
LAYER NLL 626

LAYER MAP 36  DATATYPE  0  627
LAYER NLH 627

LAYER MAP 37  DATATYPE  0  628
LAYER PLH 628

LAYER MAP 38  DATATYPE  0  629
LAYER PLL 629

LAYER MAP 39  DATATYPE  0  630
LAYER HRP 630

LAYER MAP 40  DATATYPE  0  631
LAYER SN 631

LAYER MAP 41  DATATYPE  0  632
LAYER ESD1 632

LAYER MAP 43  DATATYPE  0  633
LAYER SP 633

LAYER MAP 44  DATATYPE  0  634
LAYER MVP 634

LAYER MAP 45  DATATYPE  0  635
LAYER MVN 635

LAYER MAP 46  DATATYPE  0  636
LAYER VTPH 636

LAYER MAP 47  DATATYPE  0  637
LAYER VTNH 637

LAYER MAP 48  DATATYPE  0  638
LAYER SAB 638

LAYER MAP 50  DATATYPE  0  639
LAYER CT 639

LAYER MAP 60  DATATYPE  0  640
LAYER INSTi 640

LAYER MAP 60  DATATYPE  4  641
LAYER DPSRAM 641

LAYER MAP 61  DATATYPE  0  642
LAYER M1i 642

LAYER MAP 61  DATATYPE  1  643
LAYER M1DUM 643

LAYER MAP 61  DATATYPE  7  644
LAYER M1DOP 644

LAYER MAP 62  DATATYPE  0  645
LAYER M2i 645

LAYER MAP 62  DATATYPE  1  646
LAYER M2DUM 646

LAYER MAP 62  DATATYPE  7  647
LAYER M2DOP 647

LAYER MAP 63  DATATYPE  0  648
LAYER M3i 648

LAYER MAP 63  DATATYPE  1  649
LAYER M3DUM 649

LAYER MAP 63  DATATYPE  7  650
LAYER M3DOP 650

LAYER MAP 64  DATATYPE  0  651
LAYER M4i 651

LAYER MAP 64  DATATYPE  1  652
LAYER M4DUM 652

LAYER MAP 64  DATATYPE  7  653
LAYER M4DOP 653

LAYER MAP 65  DATATYPE  0  654
LAYER M5i 654

LAYER MAP 65  DATATYPE  1  655
LAYER M5DUM 655

LAYER MAP 65  DATATYPE  7  656
LAYER M5DOP 656

LAYER MAP 66  DATATYPE  0  657
LAYER M6i 657

LAYER MAP 66  DATATYPE  1  658
LAYER M6DUM 658

LAYER MAP 66  DATATYPE  7  659
LAYER M6DOP 659

LAYER MAP 67  DATATYPE  0  660
LAYER M7i 660

LAYER MAP 67  DATATYPE  1  661
LAYER M7DUM 661

LAYER MAP 67  DATATYPE  7  662
LAYER M7DOP 662

LAYER MAP 68  DATATYPE  0  663
LAYER M8i 663

LAYER MAP 68  DATATYPE  1  664
LAYER M8DUM 664

LAYER MAP 68  DATATYPE  7  665
LAYER M8DOP 665

LAYER MAP 70  DATATYPE  0  666
LAYER V1i 666

LAYER MAP 70  DATATYPE  1  667
LAYER V1DUM 667

LAYER MAP 70  DATATYPE  6  668
LAYER V1DUB 668

LAYER MAP 71  DATATYPE  0  670
LAYER V2i 670

LAYER MAP 71  DATATYPE  1  671
LAYER V2DUM 671

LAYER MAP 71  DATATYPE  6  672
LAYER V2DUB 672

LAYER MAP 72  DATATYPE  0  674
LAYER V3i 674

LAYER MAP 72  DATATYPE  1  675
LAYER V3DUM 675

LAYER MAP 72  DATATYPE  6  676
LAYER V3DUB 676

LAYER MAP 73  DATATYPE  0  678
LAYER V4i 678

LAYER MAP 73  DATATYPE  1  679
LAYER V4DUM 679

LAYER MAP 73  DATATYPE  6  680
LAYER V4DUB 680

LAYER MAP 74  DATATYPE  0  682
LAYER V5i 682

LAYER MAP 74  DATATYPE  1  683
LAYER V5DUM 683

LAYER MAP 74  DATATYPE  6  684
LAYER V5DUB 684

LAYER MAP 75  DATATYPE  0  686
LAYER V6i 686

LAYER MAP 75  DATATYPE  1  687
LAYER V6DUM 687

LAYER MAP 75  DATATYPE  6  688
LAYER V6DUB 688

LAYER MAP 76  DATATYPE  0  690
LAYER V7i 690

LAYER MAP 76  DATATYPE  1  691
LAYER V7DUM 691

LAYER MAP 76  DATATYPE  6  692
LAYER V7DUB 692

LAYER MAP 80  DATATYPE  0  694
LAYER PA 694

LAYER MAP 81  DATATYPE  1  695
LAYER GTFUSE 695

LAYER MAP 83  DATATYPE  0  696
LAYER ALPA 696

LAYER MAP 84  DATATYPE  0  697
LAYER SM 697

LAYER MAP 84  DATATYPE  239  698
LAYER SMMK 698

LAYER MAP 85  DATATYPE  0  699
LAYER PSUB 699

LAYER MAP 86  DATATYPE  0  700
LAYER PCR 700

LAYER MAP 90  DATATYPE  0  701
LAYER DUMBM 701

LAYER MAP 91  DATATYPE  0  702
LAYER DUMBA 702

LAYER MAP 92  DATATYPE  0  703
LAYER DUMBP 703

LAYER MAP 93  DATATYPE  0  704
LAYER VARMOS 704

LAYER MAP 94  DATATYPE  0  705
LAYER VARJUN 705

LAYER MAP 95  DATATYPE  0  706
LAYER RESNW 706

LAYER MAP 96  DATATYPE  0  707
LAYER RESP1 707

LAYER MAP 97  DATATYPE  0  709
LAYER RESAA 709

LAYER MAP 99  DATATYPE  0  710
LAYER SDOP 710

LAYER MAP 104  DATATYPE  0  711
LAYER PDRF 711

LAYER MAP 105  DATATYPE  0  712
LAYER PWH 712

LAYER MAP 106  DATATYPE  0  713
LAYER NWH 713

LAYER MAP 120  DATATYPE  0  714
LAYER TM1i 714

LAYER MAP 120  DATATYPE  1  715
LAYER TM1DUM 715

LAYER MAP 121  DATATYPE  0  717
LAYER TV1i 717

LAYER MAP 121  DATATYPE  1  718
LAYER TV1DUM 718

LAYER MAP 122  DATATYPE  0  720
LAYER TM2i 720

LAYER MAP 122  DATATYPE  1  721
LAYER TM2DUM 721

LAYER MAP 123  DATATYPE  0  723
LAYER TV2i 723

LAYER MAP 123  DATATYPE  1  724
LAYER TV2DUM 724

LAYER MAP 130  DATATYPE  0  726
LAYER MD 726

LAYER MAP 138  DATATYPE  0  728
LAYER DSTR 728

LAYER MAP 151  DATATYPE  1  729
LAYER M1DUBi 729

LAYER MAP 152  DATATYPE  1  730
LAYER M2DUBi 730

LAYER MAP 153  DATATYPE  1  731
LAYER M3DUBi 731

LAYER MAP 154  DATATYPE  1  732
LAYER M4DUBi 732

LAYER MAP 155  DATATYPE  1  733
LAYER M5DUBi 733

LAYER MAP 156  DATATYPE  1  734
LAYER M6DUBi 734

LAYER MAP 157  DATATYPE  1  735
LAYER M7DUBi 735

LAYER MAP 158  DATATYPE  1  736
LAYER M8DUBi 736

LAYER MAP 159  DATATYPE  1  737
LAYER BIPOLA 737

LAYER MAP 159  DATATYPE  11  738
LAYER HVT 738

LAYER MAP 159  DATATYPE  12  739
LAYER LVT 739

LAYER MAP 159  DATATYPE  151  740
LAYER UHVT 740

LAYER MAP 159  DATATYPE  152  741
LAYER ULVT 741

LAYER MAP 165  DATATYPE  0  742
LAYER BCB1 742

LAYER MAP 167  DATATYPE  0  743
LAYER BCB2 743

LAYER MAP 180  DATATYPE  0  744
LAYER NODMF 744

LAYER MAP 183  DATATYPE  0  745
LAYER JVARDUM 745

LAYER MAP 189  DATATYPE  0  746
LAYER MARKG 746

LAYER MAP 190  DATATYPE  0  747
LAYER MARKF 747

LAYER MAP 191  DATATYPE  3  748
LAYER DTDMY 748

LAYER MAP 193  DATATYPE  1  749
LAYER TM1DUB 749

LAYER MAP 194  DATATYPE  1  750
LAYER TM2DUB 750

LAYER MAP 194  DATATYPE  2  751
LAYER MTT2DB 751

LAYER MAP 203  DATATYPE  0  752
LAYER WN 752

LAYER MAP 203  DATATYPE  239  753
LAYER WNBL 753

LAYER MAP 204  DATATYPE  0  754
LAYER WP 754

LAYER MAP 204  DATATYPE  239  755
LAYER WPBL 755

LAYER MAP 211  DATATYPE  1  756
LAYER MOMDMY 756

LAYER MAP 212  DATATYPE  0  757
LAYER INDMY 757

LAYER MAP 218  DATATYPE  0  758
LAYER LVP 758

LAYER MAP 219  DATATYPE  0  759
LAYER LVN 759

LAYER MAP 224  DATATYPE  0  760
LAYER MGR 760

LAYER MAP 231  DATATYPE  0  761
LAYER MTT2i 761

LAYER MAP 231  DATATYPE  1  762
LAYER MTT2DM 762

LAYER MAP 127  DATATYPE  0  763
LAYER BORDER  763

LAYER MAP 216  DATATYPE 150 766
LAYER   LDBK    766

LAYER MAP 189  DATATYPE  151 767
LAYER MARKS 767

LAYER MAP 89  DATATYPE 158   768
LAYER GBD20  768

LAYER MAP 89  DATATYPE 159   769
LAYER GBU15 769

LAYER MAP 89  DATATYPE 11   770
LAYER M1V18i 770

LAYER MAP 89  DATATYPE 12   771
LAYER M1V25i 771

LAYER MAP 89  DATATYPE 13   772
LAYER M1V33i 772

LAYER MAP 89  DATATYPE 15   773
LAYER M1V50i 773

LAYER MAP 89  DATATYPE 21   774
LAYER M2V18i 774

LAYER MAP 89  DATATYPE 22   775
LAYER M2V25i 775

LAYER MAP 89  DATATYPE 23   776
LAYER M2V33i 776

LAYER MAP 89  DATATYPE 25   777
LAYER M2V50i 777

LAYER MAP 89  DATATYPE 31   778
LAYER M3V18i 778

LAYER MAP 89  DATATYPE 32   779
LAYER M3V25i 779

LAYER MAP 89  DATATYPE 33   780
LAYER M3V33i 780

LAYER MAP 89  DATATYPE 35   781
LAYER M3V50i 781

LAYER MAP 89  DATATYPE 41   782
LAYER M4V18i 782

LAYER MAP 89  DATATYPE 42   783
LAYER M4V25i 783

LAYER MAP 89  DATATYPE 43   784
LAYER M4V33i 784

LAYER MAP 89  DATATYPE 45   785
LAYER M4V50i 785

LAYER MAP 89  DATATYPE 51   786
LAYER M5V18i 786

LAYER MAP 89  DATATYPE 52   787
LAYER M5V25i 787

LAYER MAP 89  DATATYPE 53   788
LAYER M5V33i 788

LAYER MAP 89  DATATYPE 55   789
LAYER M5V50i 789

LAYER MAP 89  DATATYPE 61   790
LAYER M6V18i 790

LAYER MAP 89  DATATYPE 62   791
LAYER M6V25i 791

LAYER MAP 89  DATATYPE 63   792
LAYER M6V33i 792

LAYER MAP 89  DATATYPE 65   793
LAYER M6V50i 793

LAYER MAP 89  DATATYPE 71   794
LAYER M7V18i 794

LAYER MAP 89  DATATYPE 72   795
LAYER M7V25i 795

LAYER MAP 89  DATATYPE 73   796
LAYER M7V33i 796

LAYER MAP 89  DATATYPE 75   797
LAYER M7V50i 797

LAYER MAP 89  DATATYPE 81   798
LAYER M8V18i 798

LAYER MAP 89  DATATYPE 82   799
LAYER M8V25i 799

LAYER MAP 89  DATATYPE 83   800
LAYER M8V33i 800

LAYER MAP 89  DATATYPE 85   801
LAYER M8V50i 801

LAYER MAP 89  DATATYPE 156   802
LAYER DUPMK1 802

LAYER MAP 29  DATATYPE 3   803
LAYER DGUD 803

LAYER MAP 81  DATATYPE 0  804
LAYER FUSE 804

LAYER MAP 60  DATATYPE 1  805
LAYER STSRAM 805

LAYER MAP 60  DATATYPE 5  806
LAYER LRSRAM 806

LAYER MAP 133 DATATYPE 1  807
LAYER ESDHV 807

LAYER MAP 97  DATATYPE 3  808
LAYER DIFRES 808

LAYER MAP 60  DATATYPE 12  809
LAYER 2PSRAM 809

LAYER MAP 60  DATATYPE 9  810
LAYER RFSRAM 810

LAYER MAP 83  DATATYPE 11  811
LAYER ALDUM 811

LAYER MAP 83  DATATYPE 6  812
LAYER ALDUB 812

LAYER MAP 10 DATATYPE 8 816
LAYER AADMP 816

LAYER MAP 30 DATATYPE 8 817
LAYER GTDMP 817

LAYER MAP 133  DATATYPE 0  818
LAYER ESDIO1 818

LAYER MAP 96   DATATYPE 3  819
LAYER PLRES  819

LAYER MAP 34   DATATYPE 239  820
LAYER HRBL  820

LAYER MAP 125   DATATYPE 0  821
LAYER TG  821

LAYER MAP 159   DATATYPE 6  822
LAYER ZVT  822

LAYER MAP 89    DATATYPE 168  823
LAYER GTMK2  823

LAYER MAP 125   DATATYPE 1    824
LAYER TGV  824

LAYER MAP 125   DATATYPE 3    825
LAYER OVERDR  825

LAYER MAP 29    DATATYPE 1    826
LAYER DGV     826

LAYER MAP 181    DATATYPE 0    827
LAYER RFDEV   827

LAYER MAP 81    DATATYPE 2    828
LAYER EFUSE   828

LAYER MAP 81    DATATYPE 152    829
LAYER FUSEMK1   829

LAYER MAP 181    DATATYPE 6    830
LAYER RFMK1   830

LAYER MAP 60    DATATYPE 150    831
LAYER HPBL   831

LAYER MAP 89    DATATYPE 16    832
LAYER M1V12i	832

LAYER MAP 89    DATATYPE 17    833
LAYER M1V15i     833

LAYER MAP 89    DATATYPE 26    834
LAYER M2V12i	834

LAYER MAP 89    DATATYPE 27    835
LAYER M2V15i	835

LAYER MAP 89    DATATYPE 36    836
LAYER M3V12i	836

LAYER MAP 89    DATATYPE 37    837
LAYER M3V15i	837

LAYER MAP 89    DATATYPE 46    838
LAYER M4V12i	838

LAYER MAP 89    DATATYPE 47    839
LAYER M4V15i	839

LAYER MAP 89    DATATYPE 56    840
LAYER M5V12i	840

LAYER MAP 89    DATATYPE 57    841
LAYER M5V15i	841

LAYER MAP 89    DATATYPE 66    842
LAYER M6V12i	842

LAYER MAP 89    DATATYPE 67    843
LAYER M6V15i	843

LAYER MAP 89    DATATYPE 76    844
LAYER M7V12i	844

LAYER MAP 89    DATATYPE 77    845
LAYER M7V15i	845

LAYER MAP 89    DATATYPE 86    846
LAYER M8V12i	846

LAYER MAP 89    DATATYPE 87    847
LAYER M8V15i	847

LAYER MAP 31    DATATYPE 1     852
LAYER P2DUM     852

LAYER MAP 31    DATATYPE 7     853
LAYER P2DOP     853

LAYER MAP 225  DATATYPE  0  900
LAYER W0i 900

LAYER MAP 141  DATATYPE  0  901
LAYER B1i 901

LAYER MAP 226  DATATYPE  0  902
LAYER W1i 902

LAYER MAP 142  DATATYPE  0  903
LAYER B2i 903

LAYER MAP 243  DATATYPE  0  904
LAYER STV1i 904

LAYER MAP 228  DATATYPE  0  905
LAYER STM1i 905

LAYER MAP 244  DATATYPE  0  906
LAYER STV2i 906

LAYER MAP 229  DATATYPE  0  907
LAYER STM2i 907

LAYER MAP 200  DATATYPE  0  908
LAYER LTi 908

LAYER MAP 141  DATATYPE  1  909
LAYER B1DUM 909

LAYER MAP 142  DATATYPE  1  910
LAYER B2DUM 910

LAYER MAP 243  DATATYPE  1  911
LAYER STV1DM 911

LAYER MAP 228  DATATYPE  1  912
LAYER STM1DM 912

LAYER MAP 244  DATATYPE  1  913
LAYER STV2DM 913

LAYER MAP 229  DATATYPE  1  914
LAYER STM2DM 914

LAYER MAP 159  DATATYPE  158  915
LAYER LVT_N 915

LAYER MAP 159  DATATYPE  168  916
LAYER LVT_P 916

LAYER MAP 159  DATATYPE  159  917
LAYER ULVT_N 917

LAYER MAP 159  DATATYPE  169  918
LAYER ULVT_P 918

LAYER MAP 194  DATATYPE  154  919
LAYER B1R 919

LAYER MAP 194  DATATYPE  155  920
LAYER B2R 920

LAYER MAP 201  DATATYPE  0  921
LAYER TM1R 921

LAYER MAP 202  DATATYPE  0  922
LAYER TM2R 922

LAYER MAP 194  DATATYPE  150  923
LAYER STM1R 923

LAYER MAP 194  DATATYPE  151  924
LAYER STM2R 924

LAYER MAP 194  DATATYPE  153  925
LAYER MTT2R 925

LAYER MAP 89  DATATYPE  91  926
LAYER B1V18i 926

LAYER MAP 89  DATATYPE  92  927
LAYER B1V25i 927

LAYER MAP 89  DATATYPE  93  928
LAYER B1V33i 928

LAYER MAP 89  DATATYPE  95  929
LAYER B1V50i 929

LAYER MAP 89  DATATYPE  96  930
LAYER B1V12i 930

LAYER MAP 89  DATATYPE  97  931
LAYER B1V15i 931

LAYER MAP 89  DATATYPE  101  932
LAYER B2V18i 932

LAYER MAP 89  DATATYPE  102  933
LAYER B2V25i 933

LAYER MAP 89  DATATYPE  103  934
LAYER B2V33i 934

LAYER MAP 89  DATATYPE  105  935
LAYER B2V50i 935

LAYER MAP 89  DATATYPE  106  936
LAYER B2V12i 936

LAYER MAP 89  DATATYPE  107  937
LAYER B2V15i 937

LAYER MAP 141  DATATYPE  6  938
LAYER B1DUBi 938

LAYER MAP 142  DATATYPE  6  939
LAYER B2DUBi 939

LAYER MAP 194  DATATYPE  5  940
LAYER STM1DB 940

LAYER MAP 194  DATATYPE  4  941
LAYER STM2DB 941

LAYER MAP 81  DATATYPE  4  942
LAYER FUSEAD 942

LAYER MAP 41  DATATYPE  2  943
LAYER ESDCLP 943

LAYER MAP 41  DATATYPE  8  944
LAYER ESDPOB 944

LAYER MAP 87  DATATYPE  2  945
LAYER CLPDMY 945

LAYER MAP 41  DATATYPE  7  946
LAYER LBESD 946

LAYER MAP 131  DATATYPE  170  947
LAYER LDNMK1 947

LAYER MAP 91  DATATYPE  4  948
LAYER OCCD 948

LAYER MAP 91  DATATYPE  5  949
LAYER OCOVL 949

LAYER MAP 91  DATATYPE  6  950
LAYER OCCDFH 950

LAYER MAP 91  DATATYPE  7  951
LAYER OCCDFV 951

LAYER MAP 91  DATATYPE  8  952
LAYER OCCDFDB 952

LAYER MAP 91  DATATYPE  9  953
LAYER OCCDBDB 953

LAYER MAP 91  DATATYPE  10  954
LAYER OCCDB 954

LAYER MAP 6  DATATYPE  1  955
LAYER PSRDUM 955

LAYER MAP 6  DATATYPE  11  956
LAYER PSRNDUM 956

LAYER MAP 141  DATATYPE  7  957
LAYER B1DOP 957

LAYER MAP 142  DATATYPE  7  958
LAYER B2DOP 958

LAYER MAP 131 DATATYPE 175  959 
LAYER VDDMK1 959 

LAYER MAP 131  DATATYPE 176  960
LAYER VSSMK1 960

LAYER MAP 131  DATATYPE 177  961
LAYER LUWMK1 961

LAYER MAP 127  DATATYPE	1  963
LAYER PRBOUN	963

LAYER MAP 83  DATATYPE 2  962
LAYER MAP 83  TEXTTYPE 2  962
LAYER ALPATXT 962

LAYER MAP 999 DATATYPE 1115 4325
LAYER EMPTY3 4325

LAYER MAP 999 DATATYPE 1116 4326
LAYER EMPTY4 4326

LAYER MAP 999 DATATYPE 1117 4327
LAYER EMPTY5 4327

LAYER MAP 999 DATATYPE 1118 4328
LAYER EMPTY6 4328

LAYER MAP 999 DATATYPE 1119 4329
LAYER EMPTY7 4329

LAYER MAP 999 DATATYPE 1120 4330
LAYER EMPTY8 4330

LAYER MAP 999 DATATYPE 1121 4331
LAYER EMPTY9 4331

LAYER MAP 999 DATATYPE 1122 4332
LAYER EMPTY10 4332


INST  = COPY INSTi

AADUM_G = AADUM OR AADOP
GTDUM_G = GTDUM OR GTDOP

AA_all = AA OR AA_DMY
AA_all_3 = AA OR (AADMP OR AADOP)
AA_with_dummy = AA OR AADUM_G

GT_all = GT OR POLY_DMY
GT_all_3 = GT OR (GTDMP OR GTDOP)
GT_all_3_real = GT_all_3 NOT P2
GT_with_dummy = GT OR GTDUM_G
GT_with_dummy_real = GT_with_dummy NOT P2

P2_all = P2 or (P2DUM or P2DOP)

ALPA_all = ALPA OR ALDUM
}


#//***********************************************************************************************************
#// DRC STRUCTURE CONTROL CENTER
#//***********************************************************************************************************

#generate top_metal_counts and M1_and_1XMn_metal_counts
set top_metal_counts [expr $8X_top_metal_counts +$10X_top_metal_counts +$MTT2_top_metal_counts]
set M1_and_1XMn_metal_counts [expr $total_metal_counts -$2X_metal_counts -$top_metal_counts]
set inter_metal_counts [expr $total_metal_counts -$top_metal_counts]

#puts $top_metal_counts
#puts $M1_and_1XMn_metal_counts

#---------------------------------------------------------------------------------------------
#generate the layer list for M1 and 1X metal and via
set M1_and_1XMn_list_temp { M1 M2 M3 M4 M5 M6 M7 M8 }
set 1XVn_list_temp { V1 V2 V3 V4 V5 V6 V7 }

set M1_and_1XMn_list [lrange $M1_and_1XMn_list_temp 0 [expr $M1_and_1XMn_metal_counts -1] ]
set 1XVn_list [lrange $1XVn_list_temp 0 [expr $M1_and_1XMn_metal_counts -2] ]


#puts $M1_and_1XMn_list
#puts $1XVn_list

#---------------------------------------------------------------------------------------------

#generate the layer list for 2X metal and via
if { $2X_metal_counts > 0 } {
  set 2X_metal_list_temp { B1 B2 }
  set 2X_via_list_temp { W0 W1 }

  set 2X_metal_list [lrange $2X_metal_list_temp [expr 2 -$2X_metal_counts] end]
  set 2X_via_list [lrange $2X_via_list_temp [expr 2 -$2X_metal_counts] end]
} else {
  set 2X_metal_list ""
  set 2X_via_list ""
}


#puts $2X_metal_list
#puts $2X_via_list

#---------------------------------------------------------------------------------------------

#generate the layer list for 8X metal and via
if { $8X_top_metal_counts == 2 } {
  set 8X_metal_list_temp { TM1 TM2 }
  set 8X_via_list_temp { TV1 TV2 }

  set 8X_metal_list { TM1 TM2 }
  set 8X_via_list { TV1 TV2 }

} elseif { ($8X_top_metal_counts == 1) && ($MTT2_top_metal_counts == 1) } {
  set 8X_metal_list { TM1 }
  set 8X_via_list { TV1 }

} elseif { ($8X_top_metal_counts == 1) && ($MTT2_top_metal_counts == 0) } {
  set 8X_metal_list { TM2 }
  set 8X_via_list { TV2 }
} elseif { $8X_top_metal_counts == 0 } {
  set 8X_metal_list ""
  set 8X_via_list ""
}

#puts $8X_metal_list
#puts $8X_via_list


#---------------------------------------------------------------------------------------------

#generate the layer list for 10X metal and via
if { $10X_top_metal_counts == 2 } {
  set 10X_metal_list_temp { STM1 STM2 }
  set 10X_via_list_temp { STV1 STV2 }

  set 10X_metal_list [lrange $10X_metal_list_temp [expr 2 -$10X_top_metal_counts] end]
  set 10X_via_list [lrange $10X_via_list_temp [expr 2 -$10X_top_metal_counts] end]

} elseif { ($10X_top_metal_counts == 1) && ($MTT2_top_metal_counts == 0) } {

  set 10X_metal_list { STM2 }
  set 10X_via_list {STV2 }

} elseif { $10X_top_metal_counts == 0 } {
  set 10X_metal_list ""
  set 10X_via_list ""
}

#puts $10X_metal_list
#puts $10X_via_list

#---------------------------------------------------------------------------------------------


#generate the layer list for all metal layers or via layers
set inter_metal_list [concat $M1_and_1XMn_list $2X_metal_list]

set inter_via_list [concat $1XVn_list $2X_via_list]

if { $MTT2_top_metal_counts == 0 } {
  set total_metal_list [concat $M1_and_1XMn_list $2X_metal_list $8X_metal_list $10X_metal_list]
  set total_via_list [concat $1XVn_list $2X_via_list $8X_via_list $10X_via_list]

  set top_metal_list [concat $8X_metal_list $10X_metal_list]
  set top_via_list [concat $8X_via_list $10X_via_list]
} else {
  set total_metal_list [concat $M1_and_1XMn_list $2X_metal_list $8X_metal_list $10X_metal_list MTT2]
  set total_via_list [concat $1XVn_list $2X_via_list $8X_via_list $10X_via_list LT]

  set top_metal_list [concat $8X_metal_list $10X_metal_list MTT2]
  set top_via_list [concat $8X_via_list $10X_via_list LT]
}

set total_metal_via_list $total_metal_list
for { set i 1 } { $i < [llength $total_metal_list] } {incr i } {
  set total_metal_via_list [linsert $total_metal_via_list [expr $i*2 -1 ] [lindex $total_via_list [expr $i -1] ] ]
}

#puts $total_metal_list
#puts [llength $total_metal_list]
#puts $total_via_list
#puts [llength $total_via_list]
#puts $total_metal_via_list


#generate layer mapping for all metal and via dummy related
for { set i 1 } { $i <= 8 } { incr i } {
  set mateal_dummy(M$i) "(OR M${i}DUM M${i}DOP)"
}

set mateal_dummy(B1) "(OR B1DUM B1DOP)"
set mateal_dummy(B2) "(OR B2DUM B2DOP)"

set mateal_dummy(TM1) TM1DUM
set mateal_dummy(TM2) TM2DUM

set mateal_dummy(STM1) STM1DM
set mateal_dummy(STM2) STM2DM

set mateal_dummy(MTT2) MTT2DM

for { set i 1 } { $i <= 7 } { incr i } {
  set via_dummy(V$i) V${i}DUM
}


set via_dummy(TV1) TV1DUM
set via_dummy(TV2) TV2DUM

set via_dummy(STV1) STV1DM
set via_dummy(STV2) STV2DM


# generate layer mapping and connection for all metal and via
set total_metal_via_list_with_name_mapping ""
for { set i 1 } { $i <= [llength $inter_metal_list] } { incr i } {
  lappend total_metal_via_list_with_name_mapping M$i
  if {$i < [llength $inter_metal_list] } {
  lappend total_metal_via_list_with_name_mapping V$i
  }
}
if { [llength $top_metal_list] == 2 } {
  set total_metal_via_list_with_name_mapping [ concat $total_metal_via_list_with_name_mapping { TV1 TM1 TV2 TM2 } ]
} elseif { [llength $top_metal_list] == 1 } {
  set total_metal_via_list_with_name_mapping [ concat $total_metal_via_list_with_name_mapping { TV2 TM2 } ]
}
#puts $total_metal_via_list_with_name_mapping
for { set i 0 } { $i < [expr [llength $total_metal_via_list_with_name_mapping] -2] } { incr i 2 } {
  CONNECT [lindex $total_metal_via_list_with_name_mapping $i] [lindex $total_metal_via_list_with_name_mapping [expr $i +2]] BY [lindex $total_metal_via_list_with_name_mapping [expr $i +1]]
}

for { set i 1 } { $i <= [llength $inter_metal_list] } { incr i } {
  SETLAYER M$i = COPY [lindex $inter_metal_list [expr $i -1] ]i
  SETLAYER M${i}_all = OR [lindex $inter_metal_list [expr $i -1] ]i $mateal_dummy([lindex $inter_metal_list [expr $i -1] ])

  SETLAYER M${i}V12 = COPY [lindex $inter_metal_list [expr $i -1] ]V12i
  SETLAYER M${i}V15 = COPY [lindex $inter_metal_list [expr $i -1] ]V15i
  SETLAYER M${i}V18 = COPY [lindex $inter_metal_list [expr $i -1] ]V18i
  SETLAYER M${i}V25 = COPY [lindex $inter_metal_list [expr $i -1] ]V25i
  SETLAYER M${i}V33 = COPY [lindex $inter_metal_list [expr $i -1] ]V33i
  SETLAYER M${i}V50 = COPY [lindex $inter_metal_list [expr $i -1] ]V50i

  SETLAYER M${i}DUB = COPY [lindex $inter_metal_list [expr $i -1] ]DUBi
}

for { set i 1 } { $i <= [llength $inter_via_list] } { incr i } {
  SETLAYER V$i = COPY [lindex $inter_via_list [expr $i -1] ]i

  if { ([string equal [lindex $inter_via_list [expr $i -1] ] W0 ] != 1) && ([string equal [lindex $inter_via_list [expr $i -1] ] W1 ] != 1) } {
    SETLAYER V${i}_all = OR [lindex $inter_via_list [expr $i -1] ]i $via_dummy([lindex $inter_via_list [expr $i -1] ])
  }
}

if { [llength $top_metal_list] == 2 } {
  SETLAYER TM1 = COPY [lindex $top_metal_list 0]i
  SETLAYER TM2 = COPY [lindex $top_metal_list 1]i

  SETLAYER TV1 = COPY [lindex $top_via_list 0]i
  SETLAYER TV2 = COPY [lindex $top_via_list 1]i

  SETLAYER TM1_all = OR [lindex $top_metal_list 0]i $mateal_dummy([lindex $top_metal_list 0])
  SETLAYER TM2_all = OR [lindex $top_metal_list 1]i $mateal_dummy([lindex $top_metal_list 1])

  SETLAYER TV1_all = OR [lindex $top_via_list 0]i $via_dummy([lindex $top_via_list 0])

  if { [string equal [lindex $top_via_list 1] LT ] != 1 } {
    SETLAYER TV2_all = OR [lindex $top_via_list 1]i $via_dummy([lindex $top_via_list 1])
  } else {
    SETLAYER TV2_all = COPY [lindex $top_via_list 1]i
  }
  SETLAYER TV1_underneath_metal = COPY [lindex $inter_metal_list end]i
  SETLAYER TV2_underneath_metal = COPY [lindex $total_metal_list end-1]i

} elseif { [llength $top_metal_list] == 1 } {
  SETLAYER TM2 = COPY [lindex $top_metal_list 0]i

  SETLAYER TV2 = COPY [lindex $top_via_list 0]i

  SETLAYER TM2_all = OR [lindex $top_metal_list 0]i $mateal_dummy([lindex $top_metal_list 0])

  if { [string equal [lindex $top_via_list 0] LT ] != 1 } {
    SETLAYER TV2_all = OR [lindex $top_via_list 0]i $via_dummy([lindex $top_via_list 0])
  } else {
    SETLAYER TV2_all = COPY [lindex $top_via_list 0]i
  }
    SETLAYER TV2_underneath_metal = COPY [lindex $inter_metal_list end]i
}

#generate 2X metal and via with layer name mapping to Mn or Vn
set 2X_metal_with_name_mapping_Mn ""
set 2X_via_with_name_mapping_Vn ""

set 2X_metal_with_name_mapping_Mn_j ""
set 2X_via_with_name_mapping_Vn_j ""

if { $2X_metal_counts > 0 } {

  for { set i 0 } { $i < $2X_metal_counts } { incr i } {

    lappend 2X_metal_with_name_mapping_Mn M[expr [llength $inter_metal_list] -$2X_metal_counts +1 +$i]
    lappend 2X_via_with_name_mapping_Vn V[expr [llength $inter_metal_list] -1 -$2X_metal_counts +1 +$i]

    lappend 2X_metal_with_name_mapping_Mn_j [expr [llength $inter_metal_list] -$2X_metal_counts +1 +$i]
    lappend 2X_via_with_name_mapping_Vn_j [expr [llength $inter_metal_list] -1 -$2X_metal_counts +1 +$i]
  }
}


#generate top metal and top via with layer name mapping to TMn or TVn
if { $top_metal_counts == 2 } {

  set top_metal_list_with_name_mapping_TMn { TM1 TM2 }
  set top_metal_list_with_name_mapping_TMn_j { 1 2 }

  set top_via_list_with_name_mapping_TVn { TV1 TV2 }
  set top_via_list_with_name_mapping_TVn_j { 1 2 }

} elseif { $top_metal_counts == 1 } {

  set top_metal_list_with_name_mapping_TMn { TM2 }
  set top_metal_list_with_name_mapping_TMn_j { 2 }

  set top_via_list_with_name_mapping_TVn { TV2 }
  set top_via_list_with_name_mapping_TVn_j { 2 }

}

#generate total metal and total via with layer name mapping to Mn, Vn, TMn or TVn
set inter_metal_list_with_name_mapping [ concat $M1_and_1XMn_list $2X_metal_with_name_mapping_Mn ]
set total_metal_list_with_name_mapping [ concat $M1_and_1XMn_list $2X_metal_with_name_mapping_Mn $top_metal_list_with_name_mapping_TMn ]

set inter_via_list_with_name_mapping [ concat $1XVn_list $2X_via_with_name_mapping_Vn ]
set total_via_list_with_name_mapping [ concat $1XVn_list $2X_via_with_name_mapping_Vn $top_via_list_with_name_mapping_TVn ]


#set metal layer voltage
foreach total_metal $inter_metal_list_with_name_mapping {
set metal_voltage_list_12 ""
set metal_voltage_list_15 ""
set metal_voltage_list_18 ""
set metal_voltage_list_25 ""
set metal_voltage_list_33 ""
set metal_voltage_list_50 ""
   for { set j 1 } { $j <= [llength $inter_metal_list_with_name_mapping] } { incr j } {
  
  SETLAYER metal_voltage_temp_12_${j}_${total_metal} = NET AREA RATIO $total_metal (M$j INTERACT M${j}V12) > 0
  lappend metal_voltage_list_12  metal_voltage_temp_12_${j}_$total_metal

  SETLAYER metal_voltage_temp_15_${j}_${total_metal} = NET AREA RATIO $total_metal (M$j INTERACT M${j}V15) > 0
  lappend metal_voltage_list_15 metal_voltage_temp_15_${j}_$total_metal

  SETLAYER metal_voltage_temp_18_${j}_${total_metal} = NET AREA RATIO $total_metal (M$j INTERACT M${j}V18) > 0
  lappend metal_voltage_list_18 metal_voltage_temp_18_${j}_$total_metal

  SETLAYER metal_voltage_temp_25_${j}_${total_metal} = NET AREA RATIO $total_metal (M$j INTERACT M${j}V25) > 0
  lappend metal_voltage_list_25 metal_voltage_temp_25_${j}_$total_metal

  SETLAYER metal_voltage_temp_33_${j}_${total_metal} = NET AREA RATIO $total_metal (M$j INTERACT M${j}V33) > 0
  lappend metal_voltage_list_33 metal_voltage_temp_33_${j}_$total_metal

  SETLAYER metal_voltage_temp_50_${j}_${total_metal} = NET AREA RATIO $total_metal (M$j INTERACT M${j}V50) > 0
  lappend metal_voltage_list_50 metal_voltage_temp_50_${j}_$total_metal
}


SETLAYER metal_voltage_temp_all_12_$total_metal = OR $metal_voltage_list_12
SETLAYER ${total_metal}_voltage_12 = $total_metal AND metal_voltage_temp_all_12_$total_metal 

SETLAYER metal_voltage_temp_all_15_$total_metal = OR ${metal_voltage_list_15}
SETLAYER ${total_metal}_voltage_15 = $total_metal AND metal_voltage_temp_all_15_$total_metal 

SETLAYER metal_voltage_temp_all_18_$total_metal = OR ${metal_voltage_list_18}
SETLAYER ${total_metal}_voltage_18 = $total_metal AND metal_voltage_temp_all_18_$total_metal 

SETLAYER metal_voltage_temp_all_25_$total_metal = OR ${metal_voltage_list_25}
SETLAYER ${total_metal}_voltage_25 = $total_metal AND metal_voltage_temp_all_25_$total_metal 

SETLAYER metal_voltage_temp_all_33_$total_metal = OR ${metal_voltage_list_33}
SETLAYER ${total_metal}_voltage_33 = $total_metal AND metal_voltage_temp_all_33_$total_metal 

SETLAYER metal_voltage_temp_all_50_$total_metal = OR ${metal_voltage_list_50}
SETLAYER ${total_metal}_voltage_50 = $total_metal AND metal_voltage_temp_all_50_$total_metal 
}


for { set j 1 } { $j < [llength $inter_metal_list_with_name_mapping] } { incr j } {
  SETLAYER V${j}_voltage_12 = (NET AREA RATIO V$j M${j}_voltage_12 > 0) OR (NET AREA RATIO V$j M[expr $j +1]_voltage_12 > 0)
  SETLAYER V${j}_voltage_15 = (NET AREA RATIO V$j M${j}_voltage_15 > 0) OR (NET AREA RATIO V$j M[expr $j +1]_voltage_15 > 0)
  SETLAYER V${j}_voltage_18 = (NET AREA RATIO V$j M${j}_voltage_18 > 0) OR (NET AREA RATIO V$j M[expr $j +1]_voltage_18 > 0)
  SETLAYER V${j}_voltage_25 = (NET AREA RATIO V$j M${j}_voltage_25 > 0) OR (NET AREA RATIO V$j M[expr $j +1]_voltage_25 > 0)
  SETLAYER V${j}_voltage_33 = (NET AREA RATIO V$j M${j}_voltage_33 > 0) OR (NET AREA RATIO V$j M[expr $j +1]_voltage_33 > 0)
  SETLAYER V${j}_voltage_50 = (NET AREA RATIO V$j M${j}_voltage_50 > 0) OR (NET AREA RATIO V$j M[expr $j +1]_voltage_50 > 0)
}

VERBATIM {
//*************************************
// CONNECTION
//*************************************
GT_raw = (GT NOT P2) NOT SAB 

CONNECT M1 GT_raw NTAP PTAP PSD NSD BY CT
CONNECT NTAP NW     
CONNECT NW DNW
CONNECT PTAP PW
CONNECT TM2 ALPA BY PA
CONNECT ALPA MD

PSD  = PACT NOT PGATE
NSD  = NACT NOT NGATE

//LAYOUT TOP LAYER M1i V1i M2i V2i M3i V3i M4i V4i M5i V5i M6i V6i M7i V7i M8i TV1i TM1i TV2i TM2ii MTT2ii
LAYOUT BASE LAYER AA GT CT SN SP

VIRTUAL CONNECT NAME "?VDD?" "?VCC?" "?VSS?" "?GND?"
VIRTUAL CONNECT COLON YES


//******************************************
//    LAYER DERIVATIONS AND OPERATIONS
//******************************************

//==================
//  Resistor Def
//==================

NWR     = NW INTERACT RESNW
AAR     = AA INTERACT RESAA
NR      = NWR INSIDE AA

//==================
//   Well Def
//==================

DRC:1   = EXTENT DRAWN ORIGINAL
BULK    = SIZE DRC:1 BY 1.0
PW      = (BULK NOT NW) NOT PSUB

//==================
// Transistor Def
//==================

/*
PACT    = SP AND AA
NACT    = SN AND AA

PTAP    = PACT NOT NW
NTAP    = NACT AND NW
TAP     = PTAP OR NTAP

//GATE    = AA AND GT
GATE0 = (((GT NOT P2) INTERACT CT) AND AA ) not INST
GATE_SRAM = (((GT NOT P2) INTERACT CT) AND AA ) and INST
AA1 = (AA INTERACT GATE0) NOT GATE0 
AA2 = AA1 TOUCH GATE0 > 1  
AA3 = AA1 INTERACT CT     
AA4 = AA2 OR AA3   
GATE1 = GATE0 TOUCH AA4 == 2  
GATE2 = GATE0 AND LDBK 
AA_s1= ((AA INTERACT GATE_SRAM) NOT GATE_SRAM ) interact CT
GATE3 = GATE_SRAM touch AA_s1 == 2 
GATE = (GATE1 OR GATE2) or GATE3
*/


NGATE = GATE AND SN
PGATE = GATE AND SP

//========new definition=========================
NACT = (AA and SN) NOT NW
PACT = (AA and SP) AND NW
NTAP = (AA and SN) AND NW
PTAP = (AA and SP) NOT NW
TAP  = PTAP OR NTAP

GATE = AA AND GT

POLY_DMY = (GTDUM OR GTDOP) OR GTDMP 
AA_DMY   = (AADUM OR AADOP) OR AADMP

PAA = AA AND SP
NAA = AA AND SN


//---------------------------------------------------------------------------------------------------------------------------------------

POLY_JOG_E2_temp1 = CONVEX EDGE GT ANGLE1 == 90 LENGTH1 >= 0.005 <= 0.03 ANGLE2 == 90   WITH LENGTH >= 0.03 <= 0.09
POLY_JOG_E1_temp1 = CONVEX EDGE GT ANGLE1 == 90 LENGTH1 >= 0.03 <= 0.09 ANGLE2 == 270 LENGTH2 >= 0.005 WITH LENGTH >= 0.005 <= 0.03
POLY_JOG_E1_E2_corner = INT POLY_JOG_E2_temp1 POLY_JOG_E1_temp1 <= 0.005 ABUT INTERSECTING ONLY REGION
POLY_JOG_E2_temp2 = POLY_JOG_E2_temp1 TOUCH EDGE POLY_JOG_E1_E2_corner
POLY_JOG_E2_temp3 = INT [POLY_JOG_E2_temp2] GT == 0.06 OPPOSITE
POLY_JOG_E2 = POLY_JOG_E2_temp2 TOUCH EDGE POLY_JOG_E2_temp3
POLY_JOG_E1 = POLY_JOG_E1_temp1 TOUCH EDGE (POLY_JOG_E1_E2_corner WITH EDGE POLY_JOG_E2)
POLY_JOG = INT POLY_JOG_E1 GT >= 0.03 <= 0.09 REGION OPPOSITE
POLY_JOG2 = INT POLY_JOG_E1 GT == 0.08 REGION OPPOSITE
POLY_JOG_EDGE = POLY_JOG_E2 COIN EDGE POLY_JOG
POLY_JOG_EDGE1 = POLY_JOG_E2 COIN EDGE POLY_JOG2 

POLY_JOG_GT_16 = POLY_JOG WITH EDGE (LENGTH POLY_JOG_E2 == 0.08)

//---------------------------------------------------------------------------------------------------------------------------------------

POLY_JOG_E2_temp11 = CONVEX EDGE GT ANGLE1 == 90 LENGTH1 >= 0.005 <= 0.03 ANGLE2 == 90 LENGTH2 >= 0.005 <= 0.03  WITH LENGTH >= 0.03 <= 0.09
POLY_JOG_E1_temp11 = CONVEX EDGE GT ANGLE1 == 90 LENGTH1 >= 0.03 <= 0.09 ANGLE2 == 270 LENGTH2 >= 0.005 WITH LENGTH >= 0.005 <= 0.03
POLY_JOG_E3_temp11 = CONVEX EDGE GT ANGLE1 == 90 LENGTH1 >= 0.03 <= 0.09 ANGLE2 == 270 LENGTH2 >= 0.001 WITH LENGTH >= 0.005 <= 0.03
POLY_JOG_E1_E2_corner1 = INT POLY_JOG_E2_temp11 POLY_JOG_E1_temp11 <= 0.005 ABUT INTERSECTING ONLY REGION
POLY_JOG_E3_E2_corner1 = INT POLY_JOG_E2_temp11 POLY_JOG_E3_temp11 <= 0.005 ABUT INTERSECTING ONLY REGION

POLY_JOG_E2_temp21 = (POLY_JOG_E2_temp11 TOUCH EDGE POLY_JOG_E1_E2_corner1) TOUCH EDGE POLY_JOG_E3_E2_corner1
POLY_JOG_E2_temp31 = INT [POLY_JOG_E2_temp21] GT == 0.06 OPPOSITE
POLY_JOG_E21 = POLY_JOG_E2_temp21 TOUCH EDGE POLY_JOG_E2_temp31

POLY_JOG_E11 = POLY_JOG_E1_temp11 TOUCH EDGE (POLY_JOG_E1_E2_corner1 WITH EDGE POLY_JOG_E21)
POLY_JOG_E31 = POLY_JOG_E1_temp11 TOUCH EDGE (POLY_JOG_E3_E2_corner1 WITH EDGE POLY_JOG_E21)
POLY_JOG1 = INT POLY_JOG_E11 POLY_JOG_E31 >= 0.03 <= 0.09 REGION OPPOSITE


AAEIGT  = AA INSIDE EDGE GT
GTEIAA  = GT INSIDE EDGE AA
INTERGT = GT NOT GATE

LVNW = NW NOT (DG OR TG)
HVNW = NW AND (DG OR TG)
NW25 = NW AND TG
NW18 = NW AND DG

DGTG = DG OR TG

NODMF_SIZE_0.4 = SIZE NODMF BY 0.4

//=====================
//     CT Def
//=====================

ACT_CT   = CT AND AA
INTERCT  = CT INTERACT INTERGT

//=====================
//     Line end Def
//=====================

GT_end = LENGTH GT <= 0.1
GT_line = LENGTH GT > 0.1

GT_with_dummy_end = LENGTH GT_with_dummy <= 0.1
GT_with_dummy_line = LENGTH GT_with_dummy > 0.1

GT_all_end = LENGTH GT_all <= 0.1
GT_all_line = LENGTH GT_all > 0.1

CORN = INT DRC:1 < 70 ABUT REGION

//===============================
//     Run length space rule Def
//===============================
}
#//=======================================================================================================================================================
#//     Run length space rule Def------below codes suppose the direction of MTW1, MTW2, MTW can be horizontal or vertical to parallel run length direction
#//=======================================================================================================================================================

proc Mn_3 { MTLAY MTW1 MTW2  MTLEN MTSPA } {
 SETLAYER MTLAY0 = $MTLAY WITH WIDTH > $MTW1 <= $MTW2
 SETLAYER MTLAY0_1 = ENC MTLAY0 \[$MTLAY\] <= $MTSPA ABUT < 90 OPPOSITE
 SETLAYER X = LENGTH (CONVEX EDGE $MTLAY == 1) < $MTSPA
 SETLAYER MTLAY1_1 = MTLAY0_1 NOT COIN EDGE (LENGTH (MTLAY0_1 NOT TOUCH EDGE (INT \[MTLAY0_1\] X < 0.001 ABUT)) <= $MTLEN)
 SETLAYER MTLAY1_2 = MTLAY0_1 NOT COIN EDGE (LENGTH (MTLAY0_1 NOT TOUCH EDGE (EXT \[MTLAY0_1\] X < 0.001 ABUT)) <= $MTLEN)
 SETLAYER MTLAY1_3 = MTLAY1_1 OR EDGE MTLAY1_2
 SETLAYER MTLAY1_4 = PATH LENGTH (X OR EDGE MTLAY1_3) > $MTLEN
 SETLAYER MTLAY1 = MTLAY1_3 COIN EDGE MTLAY1_4
 SETLAYER Y_EDGE0 = DFM SPACE $MTLAY MTLAY1 < $MTSPA BY EXT BY LAYER $MTLAY
 SETLAYER Y_EDGE0_REGION = DFM COPY Y_EDGE0 REGION
 SETLAYER Y_EDGE0_REGION1 = DFM PROPERTY Y_EDGE0_REGION Y_EDGE0 OVERLAP ABUT ALSO MULTI \[-= EC(Y_EDGE0)\ ] > $MTLEN
 SETLAYER Y_EDGE1 = (DFM COPY Y_EDGE0 EDGE) COIN EDGE Y_EDGE0_REGION1
 SETLAYER Y_EDGE = $MTLAY COIN EDGE Y_EDGE1
 SETLAYER Z = X OR EDGE Y_EDGE
 SETLAYER M = EXPAND EDGE Z INSIDE BY 0.001 corner fill
 SETLAYER L = EXPAND EDGE (Y_EDGE COIN EDGE Z) INSIDE BY 0.001
 SETLAYER P0 = DFM PROPERTY M L OVERLAP ABUT ALSO MULTI \[ -=AREA(L) \] > $MTLEN * 0.001
 SETLAYER P = L INTERACT P0
 SETLAYER Q = Z TOUCH EDGE P
 OUTLAYER (EXT Q < $MTSPA OPPOSITE REGION) NOT MARKS
}

proc Mn_3_PART { MTLAY MTW1 MTW2  MTLEN MTSPA } {
 SETLAYER MTLAY0 = $MTLAY WITH WIDTH > $MTW1 <= $MTW2
 SETLAYER MTLAY0_1 = ENC MTLAY0 \[$MTLAY\] <= $MTSPA ABUT < 90 OPPOSITE
 SETLAYER X = LENGTH (CONVEX EDGE $MTLAY == 1) < $MTSPA
 SETLAYER MTLAY1_1 = MTLAY0_1 NOT COIN EDGE (LENGTH (MTLAY0_1 NOT TOUCH EDGE (INT \[MTLAY0_1\] X < 0.001 ABUT)) <= $MTLEN)
 SETLAYER MTLAY1_2 = MTLAY0_1 NOT COIN EDGE (LENGTH (MTLAY0_1 NOT TOUCH EDGE (EXT \[MTLAY0_1\] X < 0.001 ABUT)) <= $MTLEN)
 SETLAYER MTLAY1_3 = MTLAY1_1 OR EDGE MTLAY1_2
 SETLAYER MTLAY1_4 = PATH LENGTH (X OR EDGE MTLAY1_3) > $MTLEN
 SETLAYER MTLAY1 = MTLAY1_3 COIN EDGE MTLAY1_4
 SETLAYER Y_EDGE0 = DFM SPACE $MTLAY MTLAY1 < $MTSPA BY EXT BY LAYER $MTLAY
 SETLAYER Y_EDGE0_REGION = DFM COPY Y_EDGE0 REGION
 SETLAYER Y_EDGE0_REGION1 = DFM PROPERTY Y_EDGE0_REGION Y_EDGE0 OVERLAP ABUT ALSO MULTI \[-= EC(Y_EDGE0)\ ] > $MTLEN
 SETLAYER Y_EDGE1 = (DFM COPY Y_EDGE0 EDGE) COIN EDGE Y_EDGE0_REGION1
 SETLAYER Y_EDGE = $MTLAY COIN EDGE Y_EDGE1
 SETLAYER Z = X OR EDGE Y_EDGE
 SETLAYER M = EXPAND EDGE Z INSIDE BY 0.001 corner fill
 SETLAYER L = EXPAND EDGE (Y_EDGE COIN EDGE Z) INSIDE BY 0.001
 SETLAYER P0 = DFM PROPERTY M L OVERLAP ABUT ALSO MULTI \[ -=AREA(L) \] > $MTLEN * 0.001
 SETLAYER P = L INTERACT P0
 SETLAYER Q = Z TOUCH EDGE P
 SETLAYER OUT3 = EXT Q < $MTSPA OPPOSITE REGION
}

#----------------------------------------------------------------------------------------------------
proc Mn_3_both { MTLAY MTW MTLEN MTSPA } {
 SETLAYER MTLAY0 = $MTLAY WITH WIDTH >= $MTW
 SETLAYER MTLAY0_1 = ENC MTLAY0 \[$MTLAY\] <= $MTSPA ABUT < 90 OPPOSITE
 SETLAYER X = LENGTH (CONVEX EDGE $MTLAY == 1) < $MTSPA
 SETLAYER MTLAY1_1 = MTLAY0_1 NOT COIN EDGE (LENGTH (MTLAY0_1 NOT TOUCH EDGE (INT \[MTLAY0_1\] X < 0.001 ABUT)) <= $MTLEN)
 SETLAYER MTLAY1_2 = MTLAY0_1 NOT COIN EDGE (LENGTH (MTLAY0_1 NOT TOUCH EDGE (EXT \[MTLAY0_1\] X < 0.001 ABUT)) <= $MTLEN)
 SETLAYER MTLAY1_3 = MTLAY1_1 OR EDGE MTLAY1_2
 SETLAYER MTLAY1_4 = PATH LENGTH (X OR EDGE MTLAY1_3) > $MTLEN
 SETLAYER MTLAY1 = MTLAY1_3 COIN EDGE MTLAY1_4
 SETLAYER Y_EDGE0 = DFM SPACE MTLAY1 < $MTSPA BY EXT
 SETLAYER Y_EDGE0_REGION = DFM COPY Y_EDGE0 REGION
 SETLAYER Y_EDGE0_REGION1 = DFM PROPERTY Y_EDGE0_REGION Y_EDGE0 OVERLAP ABUT ALSO MULTI \[-= EC(Y_EDGE0)\ ] > $MTLEN
 SETLAYER Y_EDGE1 = (DFM COPY Y_EDGE0 EDGE) COIN EDGE Y_EDGE0_REGION1
 SETLAYER Y_EDGE = $MTLAY COIN EDGE Y_EDGE1
 SETLAYER Z = X OR EDGE Y_EDGE
 SETLAYER M = EXPAND EDGE Z INSIDE BY 0.001 corner fill
 SETLAYER L = EXPAND EDGE (Y_EDGE COIN EDGE Z) INSIDE BY 0.001
 SETLAYER P0 = DFM PROPERTY M L OVERLAP ABUT ALSO MULTI \[ -=AREA(L) \] > $MTLEN * 0.001
 SETLAYER P = L INTERACT P0
 SETLAYER Q = Z TOUCH EDGE P
 OUTLAYER (EXT Q < $MTSPA OPPOSITE REGION) NOT MARKS
}

#----------------------------------------------------------------------------------------------------
proc Mn_one_width { MTLAY MTW MTLEN MTSPA } {
 SETLAYER MTLAY_WIDE = $MTLAY INTERACT ($MTLAY WITH WIDTH >= $MTW)
 SETLAYER MTLAY0_1 = INT (MTLAY_WIDE) < $MTW OPPOSITE

 SETLAYER X = LENGTH (CONVEX EDGE $MTLAY == 1) < $MTSPA
 SETLAYER MTLAY1_1 = MTLAY0_1 NOT COIN EDGE (LENGTH (MTLAY0_1 NOT TOUCH EDGE (INT \[MTLAY0_1\] X < 0.001 ABUT)) <= $MTLEN)
 SETLAYER MTLAY1_2 = MTLAY0_1 NOT COIN EDGE (LENGTH (MTLAY0_1 NOT TOUCH EDGE (EXT \[MTLAY0_1\] X < 0.001 ABUT)) <= $MTLEN)
 SETLAYER MTLAY1_3 = MTLAY1_1 OR EDGE MTLAY1_2
 SETLAYER MTLAY1_4 = PATH LENGTH (X OR EDGE MTLAY1_3) > $MTLEN
 SETLAYER MTLAY1 = MTLAY1_3 COIN EDGE MTLAY1_4

 SETLAYER Y_EDGE0 = EXT $MTLAY MTLAY1 < $MTSPA OPPOSITE EXCLUDe SHIElDED
 SETLAYER Y_EDGE0_REGION = EXT $MTLAY MTLAY1 < $MTSPA OPPOSITE REGION EXCLUDE SHIElDED
 SETLAYER Y_EDGE0_REGION1 = DFM PROPERTY Y_EDGE0_REGION Y_EDGE0 OVERLAP ABUT ALSO MULTI \[-= EC(Y_EDGE0)\ ] > $MTLEN
 SETLAYER Y_EDGE1 = (DFM COPY Y_EDGE0 EDGE) COIN EDGE Y_EDGE0_REGION1
 SETLAYER Y_EDGE = $MTLAY COIN EDGE Y_EDGE1
 SETLAYER Z = X OR EDGE Y_EDGE
 SETLAYER M = EXPAND EDGE Z INSIDE BY 0.001 corner fill
 SETLAYER L = EXPAND EDGE (Y_EDGE COIN EDGE Z) INSIDE BY 0.001
 SETLAYER P0 = DFM PROPERTY M L OVERLAP ABUT ALSO MULTI \[ -=AREA(L) \] > $MTLEN * 0.001
 SETLAYER P = L INTERACT P0
 SETLAYER Q = Z TOUCH EDGE (LENGTH P > 0.001)
 SETLAYER N = ENCLOSE RECTANGLE (EXT Q < $MTSPA OPPOSITE REGION) 0.001 $MTLEN  
 OUTLAYER N NOT MARKS
}

proc Mn_one_width_PART { MTLAY MTW MTLEN MTSPA } {
 SETLAYER MTLAY_WIDE = $MTLAY INTERACT ($MTLAY WITH WIDTH >= $MTW)
 SETLAYER MTLAY0_1 = INT (MTLAY_WIDE) < $MTW OPPOSITE

 SETLAYER X = LENGTH (CONVEX EDGE $MTLAY == 1) < $MTSPA
 SETLAYER MTLAY1_1 = MTLAY0_1 NOT COIN EDGE (LENGTH (MTLAY0_1 NOT TOUCH EDGE (INT \[MTLAY0_1\] X < 0.001 ABUT)) <= $MTLEN)
 SETLAYER MTLAY1_2 = MTLAY0_1 NOT COIN EDGE (LENGTH (MTLAY0_1 NOT TOUCH EDGE (EXT \[MTLAY0_1\] X < 0.001 ABUT)) <= $MTLEN)
 SETLAYER MTLAY1_3 = MTLAY1_1 OR EDGE MTLAY1_2
 SETLAYER MTLAY1_4 = PATH LENGTH (X OR EDGE MTLAY1_3) > $MTLEN
 SETLAYER MTLAY1 = MTLAY1_3 COIN EDGE MTLAY1_4

 SETLAYER Y_EDGE0 = EXT $MTLAY MTLAY1 < $MTSPA OPPOSITE EXCLUDe SHIElDED
 SETLAYER Y_EDGE0_REGION = EXT $MTLAY MTLAY1 < $MTSPA OPPOSITE REGION EXCLUDE SHIElDED
 SETLAYER Y_EDGE0_REGION1 = DFM PROPERTY Y_EDGE0_REGION Y_EDGE0 OVERLAP ABUT ALSO MULTI \[-= EC(Y_EDGE0)\ ] > $MTLEN
 SETLAYER Y_EDGE1 = (DFM COPY Y_EDGE0 EDGE) COIN EDGE Y_EDGE0_REGION1
 SETLAYER Y_EDGE = $MTLAY COIN EDGE Y_EDGE1
 SETLAYER Z = X OR EDGE Y_EDGE
 SETLAYER M = EXPAND EDGE Z INSIDE BY 0.001 corner fill
 SETLAYER L = EXPAND EDGE (Y_EDGE COIN EDGE Z) INSIDE BY 0.001
 SETLAYER P0 = DFM PROPERTY M L OVERLAP ABUT ALSO MULTI \[ -=AREA(L) \] > $MTLEN * 0.001
 SETLAYER P = L INTERACT P0
 SETLAYER Q = Z TOUCH EDGE (LENGTH P > 0.001)
 SETLAYER OUT3 = EXT Q < $MTSPA OPPOSITE REGION
}

proc Mn_one_width_special { MTLAY MTW MTLEN MTSPA } {
 SETLAYER MTLAY0 = $MTLAY WITH WIDTH > $MTW
 SETLAYER MTLAY0_1 = ENC MTLAY0 \[$MTLAY\] < $MTSPA ABUT < 90 OPPOSITE
 SETLAYER X = LENGTH (CONVEX EDGE $MTLAY == 1) < $MTSPA
 SETLAYER MTLAY1_1 = MTLAY0_1 NOT COIN EDGE (LENGTH (MTLAY0_1 NOT TOUCH EDGE (INT \[MTLAY0_1\] X < 0.001 ABUT)) <= $MTLEN)
 SETLAYER MTLAY1_2 = MTLAY0_1 NOT COIN EDGE (LENGTH (MTLAY0_1 NOT TOUCH EDGE (EXT \[MTLAY0_1\] X < 0.001 ABUT)) <= $MTLEN)
 SETLAYER MTLAY1_3 = MTLAY1_1 OR EDGE MTLAY1_2
 SETLAYER MTLAY1_4 = PATH LENGTH (X OR EDGE MTLAY1_3) > $MTLEN
 SETLAYER MTLAY1 = MTLAY1_3 COIN EDGE MTLAY1_4
 SETLAYER Y_EDGE0 = DFM SPACE $MTLAY MTLAY1 < $MTSPA BY EXT BY LAYER $MTLAY
 SETLAYER Y_EDGE0_REGION = DFM COPY Y_EDGE0 REGION
 SETLAYER Y_EDGE0_REGION1 = DFM PROPERTY Y_EDGE0_REGION Y_EDGE0 OVERLAP ABUT ALSO MULTI \[-= EC(Y_EDGE0)\ ] > $MTLEN
 SETLAYER Y_EDGE1 = (DFM COPY Y_EDGE0 EDGE) COIN EDGE Y_EDGE0_REGION1
 SETLAYER Y_EDGE = $MTLAY COIN EDGE Y_EDGE1
 SETLAYER Z = X OR EDGE Y_EDGE
 SETLAYER M = EXPAND EDGE Z INSIDE BY 0.001 corner fill
 SETLAYER L = EXPAND EDGE (Y_EDGE COIN EDGE Z) INSIDE BY 0.001
 SETLAYER P0 = DFM PROPERTY M L OVERLAP ABUT ALSO MULTI \[ -=AREA(L) \] > $MTLEN * 0.001
 SETLAYER P = L INTERACT P0
 SETLAYER Q = Z TOUCH EDGE P
 OUTLAYER (EXT Q < $MTSPA OPPOSITE REGION) NOT MARKS
}
#---------------------------------------------------------------------------------------------------------------------------------------------

#For two layers' PRL rules
#Only request LAY1 >= width
proc PRL2_one_width { LAY1 LAY2 MTW MTLEN MTSPA } {
 SETLAYER MTLAY0 = $LAY1 WITH WIDTH >= $MTW
 SETLAYER MTLAY0_1 = ENC MTLAY0 \[$LAY1\] <= $MTSPA ABUT < 90 OPPOSITE
 SETLAYER X = CONVEX EDGE $LAY1 == 1
 SETLAYER MTLAY1_1 = MTLAY0_1 NOT COIN EDGE (LENGTH (MTLAY0_1 NOT TOUCH EDGE (INT \[MTLAY0_1\] X < 0.001 ABUT)) <= $MTLEN)
 SETLAYER MTLAY1_2 = MTLAY0_1 NOT COIN EDGE (LENGTH (MTLAY0_1 NOT TOUCH EDGE (EXT \[MTLAY0_1\] X < 0.001 ABUT)) <= $MTLEN)
 SETLAYER MTLAY1 = MTLAY1_1 OR EDGE MTLAY1_2
 SETLAYER Y_EDGE0 = DFM SPACE $LAY2 MTLAY1 < $MTSPA BY EXT BY LAYER $LAY2
 SETLAYER Y_EDGE0_REGION = DFM COPY Y_EDGE0 REGION
 SETLAYER Y_EDGE0_REGION1 = DFM PROPERTY Y_EDGE0_REGION Y_EDGE0 OVERLAP ABUT ALSO MULTI \[-= EC(Y_EDGE0)\ ] > $MTLEN
 SETLAYER Y_EDGE1 = (DFM COPY Y_EDGE0 EDGE) COIN EDGE Y_EDGE0_REGION1
 SETLAYER Y_EDGE = $LAY1 COIN EDGE Y_EDGE1
 SETLAYER Z = X OR EDGE Y_EDGE
 SETLAYER M = EXPAND EDGE Z INSIDE BY 0.001 corner fill
 SETLAYER L = EXPAND EDGE (Y_EDGE COIN EDGE Z) INSIDE BY 0.001
 SETLAYER P0 = DFM PROPERTY M L OVERLAP ABUT ALSO MULTI \[ -=AREA(L) \] > $MTLEN * 0.001
 SETLAYER P = L INTERACT P0
 SETLAYER Q = Z TOUCH EDGE P
 OUTLAYER (EXT Q Y_EDGE1 < $MTSPA OPPOSITE REGION) NOT MARKS
}

proc PRL2_one_width_PART { LAY1 LAY2 MTW MTLEN MTSPA } {
 SETLAYER MTLAY0 = $LAY1 WITH WIDTH >= $MTW
 SETLAYER MTLAY0_1 = ENC MTLAY0 \[$LAY1\] <= $MTSPA ABUT < 90 OPPOSITE
 SETLAYER X = CONVEX EDGE $LAY1 == 1
 SETLAYER MTLAY1_1 = MTLAY0_1 NOT COIN EDGE (LENGTH (MTLAY0_1 NOT TOUCH EDGE (INT \[MTLAY0_1\] X < 0.001 ABUT)) <= $MTLEN)
 SETLAYER MTLAY1_2 = MTLAY0_1 NOT COIN EDGE (LENGTH (MTLAY0_1 NOT TOUCH EDGE (EXT \[MTLAY0_1\] X < 0.001 ABUT)) <= $MTLEN)
 SETLAYER MTLAY1 = MTLAY1_1 OR EDGE MTLAY1_2
 SETLAYER Y_EDGE0 = DFM SPACE $LAY2 MTLAY1 < $MTSPA BY EXT BY LAYER $LAY2
 SETLAYER Y_EDGE0_REGION = DFM COPY Y_EDGE0 REGION
 SETLAYER Y_EDGE0_REGION1 = DFM PROPERTY Y_EDGE0_REGION Y_EDGE0 OVERLAP ABUT ALSO MULTI \[-= EC(Y_EDGE0)\ ] > $MTLEN
 SETLAYER Y_EDGE1 = (DFM COPY Y_EDGE0 EDGE) COIN EDGE Y_EDGE0_REGION1
 SETLAYER Y_EDGE = $LAY1 COIN EDGE Y_EDGE1
 SETLAYER Z = X OR EDGE Y_EDGE
 SETLAYER M = EXPAND EDGE Z INSIDE BY 0.001 corner fill
 SETLAYER L = EXPAND EDGE (Y_EDGE COIN EDGE Z) INSIDE BY 0.001
 SETLAYER P0 = DFM PROPERTY M L OVERLAP ABUT ALSO MULTI \[ -=AREA(L) \] > $MTLEN * 0.001
 SETLAYER P = L INTERACT P0
 SETLAYER Q = Z TOUCH EDGE P
 SETLAYER OUT3 = EXT Q Y_EDGE1 < $MTSPA OPPOSITE REGION
}

#For two layers' PRL rules
#Only request LAY1 >= width1 and <= width2
proc PRL2_two_width { LAY1 LAY2 MTW1 MTW2 MTLEN MTSPA } {
 SETLAYER MTLAY0 = $LAY1 WITH WIDTH >= $MTW1 <= $MTW2
 SETLAYER MTLAY0_1 = ENC MTLAY0 \[$LAY1\] <= $MTSPA ABUT < 90 OPPOSITE
 SETLAYER X = CONVEX EDGE $LAY1 == 1
 SETLAYER MTLAY1_1 = MTLAY0_1 NOT COIN EDGE (LENGTH (MTLAY0_1 NOT TOUCH EDGE (INT \[MTLAY0_1\] X < 0.001 ABUT)) <= $MTLEN)
 SETLAYER MTLAY1_2 = MTLAY0_1 NOT COIN EDGE (LENGTH (MTLAY0_1 NOT TOUCH EDGE (EXT \[MTLAY0_1\] X < 0.001 ABUT)) <= $MTLEN)
 SETLAYER MTLAY1 = MTLAY1_1 OR EDGE MTLAY1_2
 SETLAYER Y_EDGE0 = DFM SPACE $LAY2 MTLAY1 < $MTSPA BY EXT BY LAYER $LAY2
 SETLAYER Y_EDGE0_REGION = DFM COPY Y_EDGE0 REGION
 SETLAYER Y_EDGE0_REGION1 = DFM PROPERTY Y_EDGE0_REGION Y_EDGE0 OVERLAP ABUT ALSO MULTI \[-= EC(Y_EDGE0)\ ] > $MTLEN
 SETLAYER Y_EDGE1 = (DFM COPY Y_EDGE0 EDGE) COIN EDGE Y_EDGE0_REGION1
 SETLAYER Y_EDGE = $LAY1 COIN EDGE Y_EDGE1
 SETLAYER Z = X OR EDGE Y_EDGE
 SETLAYER M = EXPAND EDGE Z INSIDE BY 0.001 corner fill
 SETLAYER L = EXPAND EDGE (Y_EDGE COIN EDGE Z) INSIDE BY 0.001
 SETLAYER P0 = DFM PROPERTY M L OVERLAP ABUT ALSO MULTI \[ -=AREA(L) \] > $MTLEN * 0.001
 SETLAYER P = L INTERACT P0
 SETLAYER Q = Z TOUCH EDGE P
 OUTLAYER (EXT Q Y_EDGE1 < $MTSPA OPPOSITE REGION) NOT MARKS
}

proc PRL2_two_width_PART { LAY1 LAY2 MTW1 MTW2 MTLEN MTSPA } {
 SETLAYER MTLAY0 = $LAY1 WITH WIDTH >= $MTW1 <= $MTW2
 SETLAYER MTLAY0_1 = ENC MTLAY0 \[$LAY1\] <= $MTSPA ABUT < 90 OPPOSITE
 SETLAYER X = CONVEX EDGE $LAY1 == 1
 SETLAYER MTLAY1_1 = MTLAY0_1 NOT COIN EDGE (LENGTH (MTLAY0_1 NOT TOUCH EDGE (INT \[MTLAY0_1\] X < 0.001 ABUT)) <= $MTLEN)
 SETLAYER MTLAY1_2 = MTLAY0_1 NOT COIN EDGE (LENGTH (MTLAY0_1 NOT TOUCH EDGE (EXT \[MTLAY0_1\] X < 0.001 ABUT)) <= $MTLEN)
 SETLAYER MTLAY1 = MTLAY1_1 OR EDGE MTLAY1_2
 SETLAYER Y_EDGE0 = DFM SPACE $LAY2 MTLAY1 < $MTSPA BY EXT BY LAYER $LAY2
 SETLAYER Y_EDGE0_REGION = DFM COPY Y_EDGE0 REGION
 SETLAYER Y_EDGE0_REGION1 = DFM PROPERTY Y_EDGE0_REGION Y_EDGE0 OVERLAP ABUT ALSO MULTI \[-= EC(Y_EDGE0)\ ] > $MTLEN
 SETLAYER Y_EDGE1 = (DFM COPY Y_EDGE0 EDGE) COIN EDGE Y_EDGE0_REGION1
 SETLAYER Y_EDGE = $LAY1 COIN EDGE Y_EDGE1
 SETLAYER Z = X OR EDGE Y_EDGE
 SETLAYER M = EXPAND EDGE Z INSIDE BY 0.001 corner fill
 SETLAYER L = EXPAND EDGE (Y_EDGE COIN EDGE Z) INSIDE BY 0.001
 SETLAYER P0 = DFM PROPERTY M L OVERLAP ABUT ALSO MULTI \[ -=AREA(L) \] > $MTLEN * 0.001
 SETLAYER P = L INTERACT P0
 SETLAYER Q = Z TOUCH EDGE P
 SETLAYER OUT3 = EXT Q Y_EDGE1 < $MTSPA OPPOSITE REGION
}

#----------------------------------------------------------------------------------------------------
proc Mn_4f { VLAY MTLAY MTW1 MTW2 MTSPA MTLEN MTVSPA } {
 SETLAYER X0 = EXT $MTLAY X2 < $MTSPA  ABUT <90 opposite REGION measure all       
 SETLAYER X1 = $MTLAY WITH WIDTH > $MTW1<= $MTW2     
 SETLAYER X2 = X1 ENCLOSE $VLAY
 SETLAYER gaps  = ext X2 $MTLAY < $MTSPA  opposite region measure all
 SETLAYER edges_check1 = ext X2 $MTLAY < $MTSPA  opposite measure all
 SETLAYER gap1 = dfm property gaps edges_check1 overlap abut also multi \
  \[ wmax = max(ew(edges_check1)) \] \
  \[ wmin = min(ew(edges_check1)) \] \
  \[ l    = sum(ec(edges_check1)) \]> $MTLEN \
  \[ -= max(ew(edges_check1)) - min(ew(edges_check1)) \] <=0.006
 SETLAYER gap = gap1  OR ( X0 with edge (path length (X0 coin edge $MTLAY)> $MTLEN ))
 SETLAYER X4 = $MTLAY COIN EDGE gap
 OUTLAYER (EXT X4 ($VLAY INSIDE X2)< $MTVSPA ABUT<90 REGION) NOT MARKS
}



#---------------------------------------------------------------------------------------------------------------------------------------
proc SHAPE { LAYER } {
SETLAYER  ${LAYER}_VEX_0 = CONVEX EDGE $LAYER == 0
SETLAYER  ${LAYER}_VEX_1 = CONVEX EDGE $LAYER == 1
SETLAYER  ${LAYER}_VEX_2 = CONVEX EDGE $LAYER == 2
SETLAYER  ${LAYER}_LS = (($LAYER NOT WITH EDGE ${LAYER}_VEX_0) WITH EDGE ${LAYER}_VEX_1 == 2) WITH EDGE ${LAYER}_VEX_2 == 4

SETLAYER  ${LAYER}_TS1 = (($LAYER NOT WITH EDGE ${LAYER}_VEX_0) WITH EDGE ${LAYER}_VEX_1 == 4) WITH EDGE ${LAYER}_VEX_2 == 4
SETLAYER  ${LAYER}_TS2 = EXPAND EDGE (${LAYER}_VEX_2 COIN EDGE ${LAYER}_TS1) OUTSIDE BY 0.005 CORNER FILL
SETLAYER  ${LAYER}_TS3 = ${LAYER}_TS2 WITH EDGE ${LAYER}_VEX_2 == 3
SETLAYER  ${LAYER}_TS = ${LAYER}_TS1 INTERACT ${LAYER}_TS3 == 1

SETLAYER  ${LAYER}_US = (($LAYER WITH EDGE ${LAYER}_VEX_0 == 1) WITH EDGE ${LAYER}_VEX_1 == 2) WITH EDGE ${LAYER}_VEX_2 == 5
SETLAYER  ${LAYER}_OS = (($LAYER WITH EDGE ${LAYER}_VEX_0 == 4) NOT WITH EDGE ${LAYER}_VEX_1) WITH EDGE ${LAYER}_VEX_2 == 4
}

SHAPE GT
SHAPE GT_real
SHAPE GT_with_dummy_real
SHAPE GT_with_dummy
SHAPE AA

#---------------------------------------------------------------------------------------------------------------------------------------
proc WL_RATIO { layer } {
SETLAYER  ${layer}_EDGE_TEMP = DFM SPACE $layer < 10 BY INT
SETLAYER  ${layer}_L = DFM COPY (DFM PROPERTY ${layer}_EDGE_TEMP $layer OVERLAP ABUT ALSO MULTI \[ -= EC(${layer}_EDGE_TEMP)/EW(${layer}_EDGE_TEMP) \] >= 1) EDGE
SETLAYER  ${layer}_W = ($layer NOT COIN EDGE ${layer}_L) OR EDGE \
                       (DFM COPY (DFM PROPERTY ${layer}_EDGE_TEMP $layer OVERLAP ABUT ALSO MULTI \[ -= EC(${layer}_EDGE_TEMP)/EW(${layer}_EDGE_TEMP) \] == 1) EDGE)
}

WL_RATIO P2
WL_RATIO P2_all
WL_RATIO GT_all_3
WL_RATIO GT

#---------------------------------------------------------------------------------------------------------------------------------------
# for M1.3 and 1XMn.3
proc angle_consecutive { layer } {
  SETLAYER X = CONVEX EDGE $layer ANGLE1 == 90 LENGTH1 < 0.05 ANGLE2 == 270 LENGTH2 > 0 WITH LENGTH < 0.065
  SETLAYER Y = INT X \[$layer\] < 0.002 ABUT
  SETLAYER Y_REGION = INT X $layer < 0.002 ABUT REGION
  SETLAYER Z = $layer TOUCH EDGE Y
  SETLAYER P = EXT Z \[$layer\] < 0.002 ABUT
  SETLAYER P_REGION = EXT Z $layer < 0.002 ABUT REGION
  SETLAYER Q = $layer TOUCH EDGE Y
  SETLAYER R = Y_REGION WITH EDGE (Z TOUCH EDGE P_REGION)
  SETLAYER OUT1 = X TOUCH EDGE R

#Below codes are only for waive condition
  SETLAYER WW1 = $layer TOUCH EDGE R
  SETLAYER W2 = DFM SPACE \[WW1\] $layer <= 0.16 BY EXT
  SETLAYER W3 = EXT \[WW1\] $layer <= 0.16
  SETLAYER W4 = Y_REGION WITH EDGE (W2 OR EDGE W3)

  OUTLAYER (OUT1 NOT TOUCH EDGE W4) NOT INSIDE EDGE MARKS
  
}
proc angle_consecutive_PART { layer } {
  SETLAYER X = CONVEX EDGE $layer ANGLE1 == 90 LENGTH1 < 0.05 ANGLE2 == 270 LENGTH2 > 0 WITH LENGTH < 0.065
  SETLAYER Y = INT X \[$layer\] < 0.002 ABUT
  SETLAYER Y_REGION = INT X $layer < 0.002 ABUT REGION
  SETLAYER Z = $layer TOUCH EDGE Y
  SETLAYER P = EXT Z \[$layer\] < 0.002 ABUT
  SETLAYER P_REGION = EXT Z $layer < 0.002 ABUT REGION
  SETLAYER Q = $layer TOUCH EDGE Y
  SETLAYER R = Y_REGION WITH EDGE (Z TOUCH EDGE P_REGION)
  SETLAYER OUT1 = X TOUCH EDGE R

#Below codes are only for waive condition
  SETLAYER WW1 = $layer TOUCH EDGE R
  SETLAYER W2 = DFM SPACE \[WW1\] $layer <= 0.16 BY EXT
  SETLAYER W3 = EXT \[WW1\] $layer <= 0.16
  SETLAYER W4 = Y_REGION WITH EDGE (W2 OR EDGE W3)

  SETLAYER OUT3 = OUT1 NOT TOUCH EDGE W4
}
#---------------------------------------------------------------------------------------------------------------------------------------
# for wide metal space rule without PRL constraint
proc wspace1 {layer width space} {
 SETLAYER X = $layer WITH WIDTH > $width
 OUTLAYER (EXT X $layer < $space ABUT < 90 SINGULAR REGION MEASURE ALL) NOT MARKS
}
#---------------------------------------------------------------------------------------------------------------------------------------
# for M1.16[R], 1xMn.14[R]
proc metal_jog_filled { layer } {
 SETLAYER X = CONVEX EDGE $layer ANGLE1 == 270 LENGTH1 < 0.05 ANGLE2 == 90 LENGTH2 < 0.06 WITH LENGTH < 0.12
 SETLAYER Y = EXT X $layer < 0.002 ABUT REGION
 SETLAYER Z = $layer TOUCH EDGE Y
 SETLAYER H = EXPAND EDGE Z OUTSIDE BY 0.001
 SETLAYER L = EXTENTS H
 SETLAYER L_OUT = L AND $layer
 
 SETLAYER L_EDGE = L NOT COIN EDGE Z
 SETLAYER P = EXT L_EDGE $layer < 0.05 ABUT < 90 REGION OPPOSITE
 SETLAYER Q = INT \[L_EDGE\] <= 0.002 ABUT
 SETLAYER R = EXT Q $layer < 0.05 ABUT < 90 REGION
 
 SETLAYER W = EXT L $layer < 0.002 SINGULAR REGION
 OUTLAYER (((L_OUT OR P) OR R) OR W) NOT MARKS
}

proc metal_jog_filled_PART { layer } {
 SETLAYER X = CONVEX EDGE $layer ANGLE1 == 270 LENGTH1 < 0.05 ANGLE2 == 90 LENGTH2 < 0.06 WITH LENGTH < 0.12
 SETLAYER Y = EXT X $layer < 0.002 ABUT REGION
 SETLAYER Z = $layer TOUCH EDGE Y
 SETLAYER H = EXPAND EDGE Z OUTSIDE BY 0.001
 SETLAYER L = EXTENTS H
 SETLAYER L_OUT = L AND $layer
 
 SETLAYER L_EDGE = L NOT COIN EDGE Z
 SETLAYER P = EXT L_EDGE $layer < 0.05 ABUT < 90 REGION OPPOSITE
 SETLAYER Q = INT \[L_EDGE\] <= 0.002 ABUT
 SETLAYER R = EXT Q $layer < 0.05 ABUT < 90 REGION
 
 SETLAYER W = EXT L $layer < 0.002 SINGULAR REGION
 SETLAYER OUT3 = ((L_OUT OR P) OR R) OR W
}
#---------------------------------------------------------------------------------------------------------------------------------------
# for side wall via rules
proc via_side2 { VIA METAL MTW1 MTW2 MTLEN S1 S2 ENCVALUE } {
 SETLAYER  X1_EDGE = EXT \[$METAL\] <= $S1 ABUT < 90 OPPOSITE
 SETLAYER  X2_EDGE = EXT ($METAL) <= $S2 ABUT < 90 OPPOSITE
 SETLAYER  Y_EDGE = DFM SPACE X1_EDGE X2_EDGE > $MTW1 <= $MTW2 BY INT BY LAYER X1_EDGE
 SETLAYER  Y_REGION = DFM COPY Y_EDGE REGION
 SETLAYER  Z_REGION = DFM PROPERTY Y_REGION Y_EDGE OVERLAP ABUT ALSO MULTI \[-= EC(Y_EDGE)\] > $MTLEN
 SETLAYER  P = LENGTH (Z_REGION COIN EDGE X1_EDGE) > $MTLEN
 OUTLAYER  (ENC $VIA P < $ENCVALUE ABUT < 90 REGION) NOT MARKS
}


proc VIA_4g { VLAY MTLAY MTW1 MTW2 MTSPA MTLEN ENCVIA } {
 SETLAYER MTLAY0 = $MTLAY WITH WIDTH > $MTW1 <= $MTW2
 SETLAYER MTLAY0_1 = ENC MTLAY0 \[$MTLAY\] <= $MTSPA ABUT < 90 OPPOSITE
 SETLAYER X = LENGTH (CONVEX EDGE $MTLAY == 1) < $MTSPA
 SETLAYER MTLAY1_1 = MTLAY0_1 NOT COIN EDGE (LENGTH (MTLAY0_1 NOT TOUCH EDGE (INT \[MTLAY0_1\] X < 0.001 ABUT)) <= $MTLEN)
 SETLAYER MTLAY1_2 = MTLAY0_1 NOT COIN EDGE (LENGTH (MTLAY0_1 NOT TOUCH EDGE (EXT \[MTLAY0_1\] X < 0.001 ABUT)) <= $MTLEN)
 SETLAYER MTLAY1_3 = MTLAY1_1 OR EDGE MTLAY1_2
 SETLAYER MTLAY1_4 = PATH LENGTH (X OR EDGE MTLAY1_3) > $MTLEN
 SETLAYER MTLAY1 = MTLAY1_3 COIN EDGE MTLAY1_4
 SETLAYER Y_EDGE0 = DFM SPACE $MTLAY MTLAY1 < $MTSPA BY EXT BY LAYER $MTLAY
 SETLAYER Y_EDGE0_REGION = DFM COPY Y_EDGE0 REGION
 SETLAYER Y_EDGE0_REGION1 = DFM PROPERTY Y_EDGE0_REGION Y_EDGE0 OVERLAP ABUT ALSO MULTI \[-= EC(Y_EDGE0)\ ] > $MTLEN
 SETLAYER Y_EDGE1 = (DFM COPY Y_EDGE0 EDGE) COIN EDGE Y_EDGE0_REGION1
 SETLAYER Y_EDGE = $MTLAY COIN EDGE Y_EDGE1
 SETLAYER Z = X OR EDGE Y_EDGE
 SETLAYER M = EXPAND EDGE Z INSIDE BY 0.001 corner fill
 SETLAYER L = EXPAND EDGE (Y_EDGE COIN EDGE Z) INSIDE BY 0.001
 SETLAYER P0 = DFM PROPERTY M L OVERLAP ABUT ALSO MULTI \[ -=AREA(L) \] > $MTLEN * 0.001
 SETLAYER P = L INTERACT P0
 SETLAYER Q = Z TOUCH EDGE P
 SETLAYER R = EXT \[Q\] < $MTSPA OPPOSITE

 SETLAYER T1 = R COIN EDGE (DFM SPACE $MTLAY \[MTLAY1\] < $MTSPA BY EXT BY LAYER $MTLAY)
 SETLAYER T2 = T1 OR EDGE ((X TOUCH EDGE (INT \[X\] T1 < 0.001 ABUT)) TOUCH EDGE (EXT \[X\] T1 < 0.001 ABUT))
 SETLAYER T3 = EXPAND EDGE T2 INSIDE BY 0.001 corner fill
 SETLAYER T4 = (EXTENTS T3) ENCLOSE RECTANGLE [expr $MTLEN +0.001] 0.001
 SETLAYER T = R COIN EDGE (T3 INSIDE T4)

 SETLAYER VIA_CHECK = $VLAY NOT OUTSIDE MTLAY0
 OUTLAYER (ENC VIA_CHECK T < $ENCVIA ABUT < 90 REGION OPPOSITE) NOT MARKS
}

proc VIA_4g_PART { VLAY MTLAY MTW1 MTW2 MTSPA MTLEN ENCVIA } {
 SETLAYER MTLAY0 = $MTLAY WITH WIDTH > $MTW1 <= $MTW2
 SETLAYER MTLAY0_1 = ENC MTLAY0 \[$MTLAY\] <= $MTSPA ABUT < 90 OPPOSITE
 SETLAYER X = LENGTH (CONVEX EDGE $MTLAY == 1) < $MTSPA
 SETLAYER MTLAY1_1 = MTLAY0_1 NOT COIN EDGE (LENGTH (MTLAY0_1 NOT TOUCH EDGE (INT \[MTLAY0_1\] X < 0.001 ABUT)) <= $MTLEN)
 SETLAYER MTLAY1_2 = MTLAY0_1 NOT COIN EDGE (LENGTH (MTLAY0_1 NOT TOUCH EDGE (EXT \[MTLAY0_1\] X < 0.001 ABUT)) <= $MTLEN)
 SETLAYER MTLAY1_3 = MTLAY1_1 OR EDGE MTLAY1_2
 SETLAYER MTLAY1_4 = PATH LENGTH (X OR EDGE MTLAY1_3) > $MTLEN
 SETLAYER MTLAY1 = MTLAY1_3 COIN EDGE MTLAY1_4
 SETLAYER Y_EDGE0 = DFM SPACE $MTLAY MTLAY1 < $MTSPA BY EXT BY LAYER $MTLAY
 SETLAYER Y_EDGE0_REGION = DFM COPY Y_EDGE0 REGION
 SETLAYER Y_EDGE0_REGION1 = DFM PROPERTY Y_EDGE0_REGION Y_EDGE0 OVERLAP ABUT ALSO MULTI \[-= EC(Y_EDGE0)\ ] > $MTLEN
 SETLAYER Y_EDGE1 = (DFM COPY Y_EDGE0 EDGE) COIN EDGE Y_EDGE0_REGION1
 SETLAYER Y_EDGE = $MTLAY COIN EDGE Y_EDGE1
 SETLAYER Z = X OR EDGE Y_EDGE
 SETLAYER M = EXPAND EDGE Z INSIDE BY 0.001 corner fill
 SETLAYER L = EXPAND EDGE (Y_EDGE COIN EDGE Z) INSIDE BY 0.001
 SETLAYER P0 = DFM PROPERTY M L OVERLAP ABUT ALSO MULTI \[ -=AREA(L) \] > $MTLEN * 0.001
 SETLAYER P = L INTERACT P0
 SETLAYER Q = Z TOUCH EDGE P
 SETLAYER R = EXT \[Q\] < $MTSPA OPPOSITE

 SETLAYER T1 = R COIN EDGE (DFM SPACE $MTLAY \[MTLAY1\] < $MTSPA BY EXT BY LAYER $MTLAY)
 SETLAYER T2 = T1 OR EDGE ((X TOUCH EDGE (INT \[X\] T1 < 0.001 ABUT)) TOUCH EDGE (EXT \[X\] T1 < 0.001 ABUT))
 SETLAYER T3 = EXPAND EDGE T2 INSIDE BY 0.001 corner fill
 SETLAYER T4 = (EXTENTS T3) ENCLOSE RECTANGLE [expr $MTLEN +0.001] 0.001
 SETLAYER T = R COIN EDGE (T3 INSIDE T4)

 SETLAYER VIA_CHECK = $VLAY NOT OUTSIDE MTLAY0
 OUTLAYER (ENC (VIA_CHECK NOT W4) T < $ENCVIA ABUT < 90 REGION OPPOSITE) NOT MARKS
}
proc VIA_4g_waive { VLAY MTLAY MTLAY2 } {
 SETLAYER VIA_REC = RECTANGLE $VLAY ASPECT > 1
 SETLAYER W2 = $MTLAY AND $MTLAY2
 SETLAYER W3_1 = SIZE $VLAY BY 0.055 INSIDE OF W2 STEP 0.02
 SETLAYER W3_2 = SIZE $VLAY BY 0.055 INSIDE OF W2 STEP 0.02
 SETLAYER W4_1 = W2 ENCLOSE (W3_1 INTERACT $VLAY > 1)
 SETLAYER W4_2 = W2 ENCLOSE ((W3_2 INTERACT $VLAY > 1) INTERACT VIA_REC)
 SETLAYER W4 = W4_1 OR W4_2
}
#-----The only difference between VIA_4g_CT_9d and VIA_4g_CT:
#-------1. VIA_4g_CT_9d has only 1 width while VIA_4g has 2 widths-------------------------------------------
#-------2. the order of MTLEN and MTSPA is different-------------------------------------------------------
proc VIA_4g_CT_9d { VLAY MTLAY MTW MTLEN MTSPA ENCVIA } {
 SETLAYER MTLAY0 = $MTLAY WITH WIDTH >= $MTW
 SETLAYER MTLAY0_1 = ENC MTLAY0 \[$MTLAY\] <= $MTSPA ABUT < 90 OPPOSITE
 SETLAYER X = LENGTH (CONVEX EDGE $MTLAY == 1) < $MTSPA
 SETLAYER MTLAY1_1 = MTLAY0_1 NOT COIN EDGE (LENGTH (MTLAY0_1 NOT TOUCH EDGE (INT \[MTLAY0_1\] X < 0.001 ABUT)) <= $MTLEN)
 SETLAYER MTLAY1_2 = MTLAY0_1 NOT COIN EDGE (LENGTH (MTLAY0_1 NOT TOUCH EDGE (EXT \[MTLAY0_1\] X < 0.001 ABUT)) <= $MTLEN)
 SETLAYER MTLAY1_3 = MTLAY1_1 OR EDGE MTLAY1_2
 SETLAYER MTLAY1_4 = PATH LENGTH (X OR EDGE MTLAY1_3) > $MTLEN
 SETLAYER MTLAY1 = MTLAY1_3 COIN EDGE MTLAY1_4
 SETLAYER Y_EDGE0 = DFM SPACE $MTLAY MTLAY1 < $MTSPA BY EXT BY LAYER $MTLAY
 SETLAYER Y_EDGE0_REGION = DFM COPY Y_EDGE0 REGION
 SETLAYER Y_EDGE0_REGION1 = DFM PROPERTY Y_EDGE0_REGION Y_EDGE0 OVERLAP ABUT ALSO MULTI \[-= EC(Y_EDGE0)\ ] > $MTLEN
 SETLAYER Y_EDGE1 = (DFM COPY Y_EDGE0 EDGE) COIN EDGE Y_EDGE0_REGION1
 SETLAYER Y_EDGE = $MTLAY COIN EDGE Y_EDGE1
 SETLAYER Z = X OR EDGE Y_EDGE
 SETLAYER M = EXPAND EDGE Z INSIDE BY 0.001 corner fill
 SETLAYER L = EXPAND EDGE (Y_EDGE COIN EDGE Z) INSIDE BY 0.001
 SETLAYER P0 = DFM PROPERTY M L OVERLAP ABUT ALSO MULTI \[ -=AREA(L) \] > $MTLEN * 0.001
 SETLAYER P = L INTERACT P0
 SETLAYER Q = Z TOUCH EDGE P
 SETLAYER R = EXT \[Q\] < $MTSPA OPPOSITE

 SETLAYER T1 = R COIN EDGE (DFM SPACE $MTLAY \[MTLAY1\] < $MTSPA BY EXT BY LAYER $MTLAY)
 SETLAYER T2 = T1 OR EDGE ((X TOUCH EDGE (INT \[X\] T1 < 0.001 ABUT)) TOUCH EDGE (EXT \[X\] T1 < 0.001 ABUT))
 SETLAYER T3 = EXPAND EDGE T2 INSIDE BY 0.001 corner fill
 SETLAYER T4 = (EXTENTS T3) ENCLOSE RECTANGLE [expr $MTLEN +0.001] 0.001
 SETLAYER T = R COIN EDGE (T3 INSIDE T4)

 SETLAYER VIA_CHECK = $VLAY NOT OUTSIDE MTLAY0
 OUTLAYER (ENC VIA_CHECK T < $ENCVIA ABUT < 90 REGION OPPOSITE) NOT MARKS
}

#for 1xVn.8, 1xRVn.11, 2xVn.10, 
proc via_in_H_bar { via metal hole_length hole_area bar_l bar_w } {

 SETLAYER X0 = AREA (HOLES $metal INNER) <= $hole_area
 SETLAYER X1 = (X0 NOT ENCLOSE RECTANGLE $bar_l+0.001 $hole_length) NOT ENCLOSE RECTANGLE $bar_l $hole_length+0.001
 SETLAYER Y = $metal COIN EDGE X1
 SETLAYER Z = INT Y <= $bar_w OPPOSITE REGION
 SETLAYER H = $via NOT OUTSIDE (Z INTERACT X1 == 2 )
 OUTLAYER (Z INTERACT H == 1) NOT MARKS
}
proc via_in_H_bar_new { via metal metal_down hole_length hole_area bar_l bar_w } {
 SETLAYER  metal_bar_width = $metal WITH WIDTH <= $bar_w     ;#//W
 SETLAYER  metal_hole = (HOLES $metal INNER <= $hole_area) INTERACT metal_bar_width   ;#//AREA
 SETLAYER  metal_ring = $metal INTERACT metal_hole
 SETLAYER  metal_ring_edge = metal_ring COIN OUTSIDE EDGE metal_hole
 SETLAYER  bar_narrow = ((INT metal_ring_edge <= $bar_w ABUT < 90 OPPOSITE REGION EXCLUDE SHIELDED 4) INSIDE metal_ring) INTERACT metal_hole == 2   ;#//W
 SETLAYER  bar_wide = (((INT metal_ring_edge <= $bar_l ABUT < 90 OPPOSITE REGION EXCLUDE SHIELDED 4) INSIDE metal_ring) AND metal_bar_width) INTERACT metal_hole == 2  ;#// L
 SETLAYER  metal_hole_space = EXT metal_hole <= 0.16 ABUT < 90 OPPOSITE NOTCH REGION
 SETLAYER  bar = (bar_wide NOT metal_hole_space) OR bar_narrow
 SETLAYER  CORNER_M = ((EXT bar <= $bar_w ABUT == 90 INTERSECTING ONLY REGION EXTENTS) TOUCH bar == 2) AND metal_bar_width    ;#//W
 SETLAYER  B = bar OR CORNER_M
 SETLAYER  CENTER_BAR1 = NOT ENCLOSE RECTANGLE B 0.001 $bar_l+0.001  ;#//L
 SETLAYER  CENTER_BAR2 = (CENTER_BAR1 INTERACT metal_hole == 2) INTERACT V1
 SETLAYER  C = CENTER_BAR2 COIN OUTSIDE EDGE metal_hole
 SETLAYER  D = EXT \[C\] metal_ring_edge <= $hole_length OPPOSITE    ;#// L2
 SETLAYER  E = C NOT COIN INSIDE EDGE D
 SETLAYER  CENTER_BAR3 = CENTER_BAR2 NOT WITH EDGE E
 SETLAYER  CHECK_VIA = $via NOT OUTSIDE CENTER_BAR3
 OUTLAYER  (CHECK_VIA AND (((metal_ring INTERACT CHECK_VIA) AND ($metal_down INTERACT CHECK_VIA)) INTERACT $via == 1)) NOT MARKS
}

#for 8xTVn.7, 10xTVn.7
proc two_via_within_space_in_wide_metal { via space metal_bottom metal_up metal_width } {

 SETLAYER  X1a = WITH WIDTH $metal_bottom > $metal_width
 SETLAYER  X1b = WITH WIDTH $metal_up > $metal_width
 SETLAYER  WIDE = X1a OR X1b
 SETLAYER  X2 = ($metal_bottom AND $metal_up) ENCLOSE ($via NOT OUTSIDE WIDE)
 SETLAYER  X3 =  $via INSIDE X2
 SETLAYER  X5c = WITH NEIGHBOR X3 >= 1 SPACE <= $space INSIDE OF LAYER X2 
 SETLAYER  X6c = X2 ENCLOSE X5c
 OUTLAYER  (X2 NOT X6c) NOT MARKS
}

# for single via running distance form wide metal rule
#type 1: only one size via-------2xVn.9a, 2xVn.9b, 2xVn.9c, LT.8, 8xTVn.8, 10xTVn.8
proc single_via_from_wide_metal_one { via metal_down metal_up W L D } {

 SETLAYER  WIDE_$metal_down = (WITH WIDTH $metal_down > $W) ENCLOSE RECTANGLE $W+0.001 $L+0.001
 SETLAYER  X = ((SIZE WIDE_$metal_down BY $D+0.001) NOT WIDE_$metal_down) AND $metal_down
 SETLAYER  Y = (X INTERACT WIDE_$metal_down) INTERACT $via
 SETLAYER  Z = WIDE_$metal_down COIN OUTSIDE EDGE Y
 SETLAYER  H = EXPAND EDGE Z OUTSIDE BY 0.001
 SETLAYER  L = SIZE H BY $D INSIDE OF Y STEP 0.05
 
 SETLAYER  M = (L AND $metal_up) INTERACT $via > 1
 SETLAYER  N = ($via NOT OUTSIDE L) OUTSIDE M
 SETLAYER  R = ((($metal_up INTERACT N) AND $metal_down) INTERACT N) INTERACT $via == 1      ;#only difference
 OUTLAYER  (N INTERACT R) NOT MARKS
 
 SETLAYER  WIDE_$metal_up = (WITH WIDTH $metal_up > $W) ENCLOSE RECTANGLE $W+0.001 $L+0.001
 SETLAYER  X_1 = ((SIZE WIDE_$metal_up BY $D+0.001) NOT WIDE_$metal_up) AND $metal_up
 SETLAYER  Y_1 = (X_1 INTERACT WIDE_$metal_up) INTERACT $via
 SETLAYER  Z_1 = WIDE_$metal_up COIN OUTSIDE EDGE Y_1
 SETLAYER  H_1 = EXPAND EDGE Z_1 OUTSIDE BY 0.001
 SETLAYER  L_1 = SIZE H_1 BY $D INSIDE OF Y_1 STEP 0.05
 
 SETLAYER  M_1 = (L_1 AND $metal_down) INTERACT $via > 1
 SETLAYER  N_1 = ($via NOT OUTSIDE L_1) OUTSIDE M_1
 SETLAYER  R_1 = ((($metal_down INTERACT N_1) AND $metal_up) INTERACT N_1) INTERACT $via == 1      ;#only difference
 OUTLAYER  (N_1 INTERACT R_1) NOT MARKS
}
#type 2: two size via-------1xRVn.8a, 1xRVn.8b, 1xRVn.8c
proc single_via_from_wide_metal_two { via metal_down metal_up W L D } {

 SETLAYER  WIDE_$metal_down = (WITH WIDTH $metal_down > $W) ENCLOSE RECTANGLE $W+0.001 $L+0.001
 SETLAYER  X = ((SIZE WIDE_$metal_down BY $D+0.001) NOT WIDE_$metal_down) AND $metal_down
 SETLAYER  Y = (X INTERACT WIDE_$metal_down) INTERACT $via
 SETLAYER  Z = WIDE_$metal_down COIN OUTSIDE EDGE Y
 SETLAYER  H = EXPAND EDGE Z OUTSIDE BY 0.001
 SETLAYER  L = SIZE H BY $D INSIDE OF Y STEP 0.05
 
 SETLAYER  M = ((L AND $metal_up) INTERACT ${via}N > 1) OR ((L AND $metal_up) INTERACT R${via})
 SETLAYER  N = ($via NOT OUTSIDE L) OUTSIDE M
 SETLAYER  R = ((($metal_up INTERACT N) AND $metal_down) INTERACT N) INTERACT $via == 1      ;#only difference
 OUTLAYER  Nx = (N INTERACT R) NOT MARKS
 
 SETLAYER  WIDE_$metal_up = (WITH WIDTH $metal_up > $W) ENCLOSE RECTANGLE $W+0.001 $L+0.001
 SETLAYER  X_1 = ((SIZE WIDE_$metal_up BY $D+0.001) NOT WIDE_$metal_up) AND $metal_up
 SETLAYER  Y_1 = (X_1 INTERACT WIDE_$metal_up) INTERACT $via
 SETLAYER  Z_1 = WIDE_$metal_up COIN OUTSIDE EDGE Y_1
 SETLAYER  H_1 = EXPAND EDGE Z_1 OUTSIDE BY 0.001
 SETLAYER  L_1 = SIZE H_1 BY $D INSIDE OF Y_1 STEP 0.05
 
 SETLAYER  M_1 = ((L_1 AND $metal_down) INTERACT ${via}N > 1) OR ((L_1 AND $metal_down) INTERACT R${via})
 SETLAYER  N_1 = ($via NOT OUTSIDE L_1) OUTSIDE M_1
 SETLAYER  R_1 = ((($metal_down INTERACT N_1) AND $metal_up) INTERACT N_1) INTERACT $via == 1      ;#only difference
 OUTLAYER  Ny = (N_1 INTERACT R_1) NOT MARKS
}


#for RSP rules
proc RSPMn_1_2_3_LOTA { rule_name j S1B W1B L1B L2A S2A1 S2A2 S2A3 S3C } {
 SETLAYER ${rule_name}_M${j}_WIDE = M$j INTERACT (M$j WITH WIDTH > $W1B)
 SETLAYER ${rule_name}_M${j}_WIDE_edge = INT (${rule_name}_M${j}_WIDE) <= $W1B OPPOSITE
 SETLAYER ${rule_name}_M${j}_jog = LENGTH (CONVEX EDGE ${rule_name}_M${j}_WIDE == 1) < $S1B
 SETLAYER ${rule_name}_M${j}_1 = ${rule_name}_M${j}_WIDE_edge NOT COIN EDGE (LENGTH (${rule_name}_M${j}_WIDE_edge NOT TOUCH EDGE \
                                 (INT \[${rule_name}_M${j}_WIDE_edge\] ${rule_name}_M${j}_jog < 0.001 ABUT INTERSECTING ONLY)) <= $L1B)
 SETLAYER ${rule_name}_M${j}_2 = ${rule_name}_M${j}_WIDE_edge NOT COIN EDGE (LENGTH (${rule_name}_M${j}_WIDE_edge NOT TOUCH EDGE \
                                 (EXT \[${rule_name}_M${j}_WIDE_edge\] ${rule_name}_M${j}_jog < 0.001 ABUT INTERSECTING ONLY)) <= $L1B)
 SETLAYER ${rule_name}_M${j}_3 = ${rule_name}_M${j}_1 OR EDGE ${rule_name}_M${j}_2
 SETLAYER ${rule_name}_M${j}_4 = PATH LENGTH (${rule_name}_M${j}_jog OR EDGE ${rule_name}_M${j}_3) > $L1B
 SETLAYER ${rule_name}_M${j}_edge = ${rule_name}_M${j}_3 COIN EDGE ${rule_name}_M${j}_4

 SETLAYER ${rule_name}_M${j}_S1B_edge = EXT M$j ${rule_name}_M${j}_edge < $S1B OPPOSITE EXCLUDE SHIELDED
 SETLAYER ${rule_name}_M${j}_S1B_region = EXT M$j ${rule_name}_M${j}_edge < $S1B OPPOSITE REGION EXCLUDE SHIELDED

 SETLAYER ${rule_name}_M${j}_region_S1B_L1B = DFM PROPERTY ${rule_name}_M${j}_S1B_region ${rule_name}_M${j}_S1B_edge OVERLAP ABUT ALSO MULTI \[-= EC(${rule_name}_M${j}_S1B_edge)\] > $L1B
 SETLAYER ${rule_name}_M${j}_edge_L1B_temp = (DFM COPY ${rule_name}_M${j}_S1B_edge EDGE) COIN EDGE ${rule_name}_M${j}_region_S1B_L1B
 SETLAYER ${rule_name}_M${j}_edge_L1B = M$j COIN EDGE ${rule_name}_M${j}_edge_L1B_temp
 SETLAYER ${rule_name}_M${j}_edge_L1B_with_jog = ${rule_name}_M${j}_jog OR EDGE ${rule_name}_M${j}_edge_L1B
 SETLAYER ${rule_name}_M${j}_edge_L1B_with_jog_expand = EXPAND EDGE ${rule_name}_M${j}_edge_L1B_with_jog INSIDE BY 0.001 corner fill
 SETLAYER ${rule_name}_M${j}_L = EXPAND EDGE (${rule_name}_M${j}_edge_L1B COIN EDGE ${rule_name}_M${j}_edge_L1B_with_jog) INSIDE BY 0.001
 SETLAYER ${rule_name}_M${j}_P0 = DFM PROPERTY ${rule_name}_M${j}_edge_L1B_with_jog_expand ${rule_name}_M${j}_L OVERLAP ABUT ALSO MULTI \
                                 \[ -=AREA(${rule_name}_M${j}_L) \] > $L1B * 0.001
 SETLAYER ${rule_name}_M${j}_P = ${rule_name}_M${j}_L INTERACT ${rule_name}_M${j}_P0
 SETLAYER ${rule_name}_M${j}_Q = ${rule_name}_M${j}_edge_L1B_with_jog TOUCH EDGE ${rule_name}_M${j}_P

SETLAYER ${rule_name}_M${j}_X_RSP = DFM COPY (EXT M$j ${rule_name}_M${j}_Q < $S1B OPPOSITE EXCLUDE SHIELDED) EDGE
SETLAYER ${rule_name}_M${j}_X_RSP_region = EXT M$j ${rule_name}_M${j}_Q < $S1B OPPOSITE REGION EXCLUDE SHIELDED

SETLAYER ${rule_name}_M${j}_Y_RSP = ${rule_name}_M${j}_X_RSP TOUCH EDGE (INT (CONVEX EDGE M$j <= 3) \[${rule_name}_M${j}_X_RSP\] <= 0.001 ABUT == 90 INTERSECTING ONLY MEASURE ALL)
SETLAYER ${rule_name}_M${j}_Z_RSP = EXT ${rule_name}_M${j}_Y_RSP ${rule_name}_M${j}_X_RSP < $S2A1 REGION OPPOSITE PROJ <= $L2A

CONNECT ${rule_name}_M${j}_X_RSP_region ${rule_name}_M${j}_Z_RSP
SETLAYER ${rule_name}_OUT1x = EXT (${rule_name}_M${j}_Z_RSP NOT COIN EDGE M$j) < $S3C REGION  CONNECTED   
SETLAYER ${rule_name}_q = COPY ${rule_name}_M${j}_Z_RSP
SETLAYER ${rule_name}_OUT1y = ${rule_name}_M${j}_Z_RSP INTERACT ${rule_name}_q >= 3 SINGULAR ALSO  
SETLAYER ${rule_name}_OUT1 = ${rule_name}_OUT1x OR ${rule_name}_OUT1y

SETLAYER ${rule_name}_A1 = EXT ${rule_name}_M${j}_Y_RSP ${rule_name}_M${j}_X_RSP < $S2A2 REGION OPPOSITE
SETLAYER ${rule_name}_A1_EDGE = ${rule_name}_A1 NOT COIN EDGE M$j
SETLAYER ${rule_name}_A1_REGION = INT ${rule_name}_A1_EDGE ${rule_name}_A1  <= 0.220 REGION
SETLAYER ${rule_name}_A1_E1 = ${rule_name}_A1_EDGE NOT TOUCH EDGE ${rule_name}_A1_REGION
SETLAYER ${rule_name}_OUT2 = (${rule_name}_A1 WITH EDGE ${rule_name}_A1_E1) INSIDE ${rule_name}_OUT21
SETLAYER  ${rule_name}_OUT21 =  (NOT RECTANGLE ${rule_name}_M${j}_X_RSP_region ) OR ((RECTANGLE ${rule_name}_M${j}_X_RSP_region) ENCLOSE RECTANGLE 0.001 [expr ${L1B}-0.001])

SETLAYER ${rule_name}_A2 = EXT ${rule_name}_M${j}_Y_RSP ${rule_name}_M${j}_X_RSP < $S2A3 REGION OPPOSITE
SETLAYER ${rule_name}_A2_EDGE = ${rule_name}_A2 NOT COIN EDGE M$j
SETLAYER ${rule_name}_A2_REGION = INT ${rule_name}_A2_EDGE <= 0.220 REGION
SETLAYER ${rule_name}_A2_E2 = ${rule_name}_A2_EDGE TOUCH EDGE ${rule_name}_A2_REGION
SETLAYER ${rule_name}_OUT3 = (${rule_name}_A2 WITH EDGE ${rule_name}_A2_E2) INSIDE ${rule_name}_OUT31
SETLAYER ${rule_name}_OUT31 = (NOT RECTANGLE ${rule_name}_M${j}_X_RSP_region ) OR ((RECTANGLE ${rule_name}_M${j}_X_RSP_region) ENCLOSE RECTANGLE 0.001 [expr ${L1B}-0.001]) 
}


#//=================================================
#//  Design requirements
#//=================================================

GROUP GDGR DGR_?

set layer_list_grid { DNW AA AADMP NW PSUB LVT_N LVT_P DG TG GT GTDMP GTMK2 P2 SN SP SAB CT M1i M2i M3i M4i M5i M6i M7i M8i V1i V2i V3i V4i V5i V6i V7i
                      W0i W1i B1i B2i TV1i TV2i TM1i TM2i STV1i STV2i STM1i STM2i LTi MTT2i PA NODMF BORDER }

foreach layer_grid $layer_list_grid {
RULECHECK DGR_1_$layer_grid {
@ All the geometry design must be an integer multiple of 0.005um OUTSIDE (INST OR FUSEMK1) region.
@ DRC check DNW, AA, AADMP, NW, PSUB, LVT_N, LVT_P, DG, TG, GT, GTDMP, GTMK2, P2, SN, SP, SAB, CT, M1, 1xMn, 1xVn,
@  2xMn, 2xVn, 8xTVn,8xTMn, 10xTVn, 10xTMn, LT, MTT2, PA, NODMF, BORDER layers.
@ DRC doesn’t check INDMY and OCCDB region.
SETLAYER X = $layer_grid OUTSIDE EDGE (INST OR FUSEMK1)
SETLAYER Y = INT \[X\] < 0.005 ABUT
SETLAYER Z = DFM COPY (OFFGRID Y 5) EDGE
SETLAYER H = EXPAND EDGE Z OUTSIDE BY 0.001 INSIDE BY 0.001
OUTLAYER ((NOT RECTANGLE H) NOT MARKS) NOT INSIDE (INDMY OR OCCDB) 
}
}

RULECHECK DGR_4 {
@ Only shapes of geometry that are orthogonal or 45-degree angle are allowed, DRC doesn’t check MARKS and MD region.
@ It allows 0.5-degree checking tolerance for 45-degree design in INDMY region.
SETLAYER  X = DFM COPY (DRAWN SKEW) EDGE
OUTLAYER (X NOT COIN EDGE ((ANGLE X >= 44.5 <= 45.5) NOT OUTSIDE EDGE INDMY ))  NOT INSIDE EDGE  (MARKS OR MD)
}
#---------------------------------------------------------------------------------------------------------------------------------------


VERBATIM {
//==================================
//  DNW -  Deep N-Well  DRC
//==================================

GROUP GDNW DNW_?

DNW_1 {
@ Min DNW width is 3
 OUT1 = INT DNW < 3 ABUT<90 SINGULAR REGION
 OUT1 NOT MARKS 
}

DNW_2 {
@ Min Space between DNWs is 3.5
 OUT1 = EXT DNW < 3.5 ABUT<90 SINGULAR REGION
 OUT1 NOT MARKS
}

DNW_3 {
@ Space between DNW and N+AA (N+AA outside of DNW or NW). >= 1.650um
 OUT1  = EXT DNW (NACT OUTSIDE DNW) < 1.65 ABUT<90 REGION
 OUT1  NOT MARKS 
 OUT2 = EXT DNW (NACT OUTSIDE NW) < 1.65 ABUT<90 REGION
 OUT2 NOT MARKS 
}

DNW_4 {
@ Min Overlap of NW and DNW is 0.4
 OUT1 = INT NW DNW < 0.4 ABUT<90 SINGULAR REGION
 OUT1 NOT MARKS 
}

DNW_5 {
@ Min Space between DNW and NW at different net is 2.5
 OUT1 =  EXT NW DNW < 2.5 ABUT<90 REGION MEASURE ALL NOT CONNECTED
 OUT1 NOT MARKS
}

DNW_6 {
@ N+AA enclosure by DNW. >= 0.465um
 OUT1 = ENC NACT DNW < 0.465 ABUT < 90 SINGULAR REGION
 OUT1 NOT MARKS
}

DNW_7 {
@ It is not allowed that N+AA CUT DNW
 OUT1 = NACT CUT DNW
 OUT1 NOT MARKS 
}

DNW_8 {
@ Space between ((NW hole INSIDE DNW) NOT INTERACT (DG OR TG)) and ((NW hole INSIDE DNW) NOT INTERACT (DG OR TG)) or (PW NOT DNW) at different nets.>=0.8
 X = (HOLES NW) INSIDE DNW
 Z = PW AND (X NOT INTERACT DGTG)
 H = PW AND (PW NOT DNW)

 OUT1 = EXT  Z < 0.8 ABUT < 90 REGION NOT CONNECTED
 OUT1 NOT MARKS   
 OUT2 = EXT Z H < 0.8 ABUT < 90 REGION NOT CONNECTED
 OUT2 NOT MARKS  
}

DNW_9 {
@ Space between ((NW hole INSIDE DNW) INTERACT (DG OR TG)) and (NW hole INSIDE DNW) or (PW NOT DNW) at different nets. ≥ 1um
 X = (HOLES NW) INSIDE DNW
 Y1 = PW COIN EDGE (X INTERACT DGTG) 
 Y2 = PW COIN EDGE X
 Z = PW NOT DNW

 OUT1 = EXT Y1 Y2 < 1 ABUT < 90 REGION NOT CONNECTED
 OUT1 NOT MARKS   
 OUT2 = EXT Y1 Z < 1  ABUT < 90 REGION NOT CONNECTED
 OUT2 NOT MARKS 
}




//===========================
//  AA - Active Area DRC
//===========================

GROUP GAA AA_?

IND_OR_INST = INST OR INDMY

AA_1 {
@ AA width
@ DRC doesn’t check INST region.	≥	0.05	um
  X = INT AA_with_dummy < 0.05 ABUT < 90 SINGULAR REGION
  (X NOT INSIDE INST) NOT MARKS 
}

AA_1a_R_DFM3 {
@ Recommended AA width.
@ DRC doesn’t check INST region.	≥	0.06	um
  X = INT AA_with_dummy < 0.06 ABUT < 90 SINGULAR REGION
  (X NOT INSIDE INST) NOT MARKS
}

AA_1b_R_DFM3 {
@ Recommended AA width.	≤	30	um
  (AA_with_dummy WITH WIDTH > 30) NOT MARKS
}

AA_2a {
@ Channel width for core NMOS/PMOS transistors.
@ This rule isn’t applicable for PSUB, VARMOS, ESDIO1, ESDIO2,ESDCLP,ESDPOB,CLPDMY,INST region, and AA without CT. ≥ 0.1um ≤ 3um
  X0 = OR PSUB ESDIO12 VARMOS ESDCLP ESDPOB CLPDMY INST
  X = (GATE_CORE NOT X0) NOT WITH EDGE (LENGTH GATE_WE >= 0.1 <= 3)
  OUT1 = X NOT (AA OUTSIDE CT)
  OUT1 NOT MARKS 
}

AA_2b {
@ Channel width for I/O NMOS/PMOS transistors.
@ This rule isn’t applicable for ESDIO1, ESDIO2, ESDCLP, ESDPOB, CLPDMY region, and AA without CT. ≥ 0.27um
  X0 = OR ESDIO12 ESDCLP ESDPOB CLPDMY
  X = (GATE_IO NOT X0) WITH EDGE (LENGTH GATE_WE < 0.27)
  OUT1 = X NOT (AA OUTSIDE CT)
  OUT1 NOT MARKS 
}

AA_3_30 {
@ Width of 45-degree AA. ≥ 0.45um
@ 45-degree AA edge length. ≥ 0.45um
  X = ANGLE AA_with_dummy >= 44.9 <= 45.1
  OUT1 = EXPAND EDGE (LENGTH X < 0.45) INSIDE BY 0.001
  OUT2 = INT X < 0.45 ABUT<90 REGION 
  (OUT1 OR OUT2) NOT MARKS 
}

AA_4a {
@ Space between two AAs.
@ DRC doesn’t check INDMY, INST region.	≥	0.07	um
  X0 = AA_with_dummy NOT INSIDE IND_OR_INST
  X = EXT X0 < 0.07 ABUT < 90 SINGULAR REGION
  OUT1 = X NOT INSIDE IND_OR_INST
  OUT1 NOT MARKS 
}

AA_4a_R_DFM3 {
@ Recommended space between two AAs to prevent AA bridge.
@ DRC doesn’t check INDMY, INST region.	≥	0.075	um
  X0 = AA NOT INSIDE IND_OR_INST
  X = EXT X0 < 0.075 ABUT < 90 SINGULAR REGION
  OUT1 = X NOT INSIDE IND_OR_INST
  OUT1 NOT MARKS
}

AA_4b {
@ Space between two AAs inside DG/TG.
@ DRC doesn’t check LDBK region.	≥	0.15	um
  X = EXT (AA INSIDE DGTG) < 0.15 ABUT < 90 SINGULAR REGION
  OUT1 = X NOT INSIDE LDBK
  OUT1 NOT MARKS 
}

AA_4c {
@ Space between two AAs when one or both AA widths are >0.09um, and parallel run length of two AAs is >0.
@ DRC doesn’t check INDMY, INST region.	≥	0.08	um
  WW1 = WITH WIDTH (AA_with_dummy NOT INSIDE IND_OR_INST) > 0.09
  W2 = EXT WW1 AA_with_dummy < 0.08 REGION ABUT<90  OPPOSITE
  OUT1 = W2 NOT INSIDE IND_OR_INST
  OUT1 NOT MARKS 
}

AA_4d {
@ At least one side space between (AA or AA_DMY), when
@ 1.Width of (AA or AA_DMY) W1 = 0.05um, the width is measured in parallel to space direction;
@ 2.Width of two neighboring (AA or AA_DMY) W2 > 0.09um, the width is measured in parallel to space direction;
@ 3.The parallel run length of (AA or AA_DMY) and W1 and W2 > 0um.	≥	0.09	um
  WW1_temp = AA_all INTERACT (WITH WIDTH AA_all == 0.05)
  WW1 = INT [WW1_temp] == 0.05 OPPOSITE
  W2 = INT (AA_all) <= 0.09 OPPOSITE
  err = EXT [WW1] W2 < 0.09 OPPOSITE 
  Z = DFM COPY (DFM SPACE [err] ==0.05  BY INT) 
  OUT1 = EXT Z W2 < 0.09 REGION OPPOSITE
  OUT1 NOT MARKS 
}
}

RULECHECK AA_4e {
@ Space between two (AA or AA_DMY),when
@ 1. Width of (AA or AA_DMY) W1 >0.09um;
@ 2. Width of (AA or AA_DMY) W2 >0.05um and <0.07um;
@ 3. The parallel run length > 0.3um.	≥	0.1	um
  SETLAYER WW1 = WITH WIDTH AA_all> 0.09
  SETLAYER W2 = WW1 NOT INSIDE INST
  PRL2_two_width AA_all W2 0.051 0.069 0.3 0.1
}

RULECHECK AA_4f {
@ Space between two (AA or AA_DMY),when
@ 1. Width of (AA or AA_DMY) W1 >0.09um;
@ 2. Width of (AA or AA_DMY) W2 <0.09um ,and ≥0.07um;
@ 3. The parallel run length > 0.3um.
@ DRC doesn’t check INST region.	≥	0.09	um
  SETLAYER WW1 = WITH WIDTH AA_all>0.09
  PRL2_two_width_PART AA_all WW1 0.07 0.089 0.3 0.09
  OUTLAYER (OUT3 NOT INSIDE INST) NOT MARKS 
}

VERBATIM {
AA_5 {
@ Space between 45-degree AA and AA
@ DRC doesn’t check INDMY region. ≥ 0.45um
  X = ANGLE AA_with_dummy >= 44.9 <= 45.1
  Y = EXT X AA_with_dummy < 0.45 ABUT < 90 REGION
  OUT1 = Y NOT INSIDE INDMY
  OUT1 NOT MARKS 
}

AA_6 {
@ Space between U-shape (or O-shape) AA inner edges.	≥ 0.13um
  OUT1 = CONVEX EDGE AA_OS == 0 WITH LENGTH < 0.13
  OUT1 NOT INSIDE EDGE MARKS  
  OUT2 = CONVEX EDGE AA_US == 0 WITH LENGTH < 0.13
  OUT2 NOT INSIDE EDGE MARKS 
}

AA_7 {
@ Space between U-shape (or O-shape) AA inner edges when the U-shape (or O-shape) AA interact with poly. ≥ 0.21um
  X = CONVEX EDGE AA_US == 0 WITH LENGTH < 0.21
  Y = X INSIDE EDGE GT
  (X TOUCH EDGE Y) NOT INSIDE EDGE MARKS
  X1 = CONVEX EDGE AA_OS == 0 WITH LENGTH < 0.21
  Y1 = X1 INSIDE EDGE GT
  (X1 TOUCH EDGE Y1) NOT INSIDE EDGE MARKS 
}

AA_9_R_DFM3 {
@ Space between (AA or AA_DMY)
@ DRC check maximum STI width.
@ DRC don’t check: chip corner triangle region (NODMF) sizing up 0.4um if seal ring is added by SMIC.	≤	10	um
  X = SIZE NODMF BY 0.4
  Y = (DRC:1 NOT AA_all) NOT X
  OUT1 = WITH WIDTH Y > 10
  OUT1 NOT MARKS 
}

AA_10{
@ Space between AA and (AA INTERACT poly) along channel width direction, when channel width < 0.15um, AA area < 0.0465um2, and the parallel runlength between AA and channel >0um.
@ DRC doesn’t check INST region.	≥	0.09	um
  X = AREA (AA INTERACT (GATE WITH EDGE (LENGTH GATE_WE < 0.15))) < 0.0465
  W = EXT AA (X COIN EDGE GATE) < 0.09 REGION ABUT<90 OPPOSITE
  OUT1 = W NOT INSIDE INST
  OUT1 NOT MARKS 
}

AA_13{
@ NW enclosure of N+ pickup AA.
@ DRC doesn’t check resistor NW region, LDBK and INST region.	≥	0.065	um
  X = ENC (NTAP NOT COIN EDGE NACT) NW < 0.065 ABUT<90  REGION
  W = X NOT ((NW INTERACT RESNW) OR LDBK)
  OUT1 = W NOT INSIDE INST
  OUT1 NOT MARKS 
}

AA_14{
@ Space between NW and N+AA. >= 0.065
@ DRC doesn’t check resistor NW region, LDBK and INST region.
  NW_CHECK = NW NOT INTERACT RESNW

  X = EXT (NACT NOT COIN EDGE NTAP) NW_CHECK < 0.065 ABUT<90  REGION
  W = X NOT ((NW INTERACT RESNW) OR LDBK)
  OUT1 = W NOT INSIDE INST
  OUT1 NOT MARKS 
}

AA_15 {
@ Space between N+AA corner edge and NW corner edge.
@ DRC follows below conditions to check:
@ 1. The edge of E1≤0.105um, the edge of E2≤0.065um.
@ 2. DRC only flags the opposite space between E1 and E2.
@ 3. DRC flags the space between concave corner and convex corner.
@ DRC doesn’t check resistor NW region,INST and LDBK region.	≥	0.105	um
 NW_CHECK_AA_15 = NW NOT INTERACT RESNW
 NACT_CONER_CONVEX = INT [NACT] < 0.001 ABUT INTERSECTING ONLY
 NW_CONER_CONCAVE =  EXT [NW_CHECK_AA_15] < 0.105-0.065+0.001 ABUT INTERSECTING ONLY
 ERR_1_temp = EXT [NACT_CONER_CONVEX] NW_CONER_CONCAVE < 0.105 OPPOSITE EXTENDED 0.065
 ERR_1 = INT ERR_1_temp < 0.001 ABUT REGION INTERSECTING ONLY
 (ERR_1 NOT INSIDE (LDBK OR INST)) NOT MARKS

 NW_CONER_CONVEX = INT [NW_CHECK_AA_15] < 0.001 ABUT INTERSECTING ONLY
 NACT_CONER_CONCAVE =  EXT [NACT] < 0.105-0.065+0.001 ABUT INTERSECTING ONLY
 ERR_2_temp = EXT [NW_CONER_CONVEX] NACT_CONER_CONCAVE < 0.105 OPPOSITE EXTENDED 0.065
 ERR_2 = INT ERR_2_temp < 0.001 ABUT REGION INTERSECTING ONLY
 (ERR_2 NOT INSIDE (LDBK OR INST )) NOT MARKS
}

AA_16{
@ Space between NW and (N+AA INTERCACT DG/TG)
@ DRC doesn’t check resistor NW region and LDBK.>=0.18
  NW_CHECK = NW NOT INTERACT RESNW

  X0 = NACT INTERACT DGTG
  X = EXT NW_CHECK (X0 NOT COIN EDGE NTAP) <0.18 REGION abut<90  
  OUT1 = X NOT ((NW INTERACT RESNW) OR LDBK)
  OUT1 NOT MARKS  
}

AA_17{
@ NW enclosure of P+AA.>=0.065
@ DRC doesn’t check LDBK and INST region.
  X = ENC (PACT NOT COIN EDGE PTAP) NW < 0.065 ABUT<90  REGION
  W = X NOT LDBK
  OUT1 = W NOT INSIDE INST
  OUT1 NOT MARKS 
}

AA_18 {
@ NW corner edge enclosure of P+AA corner edge.
@ DRC follows below conditions to check:
@ 1. The edge of E1≤0.105um, the edge of E2≤0.065um
@ 2. DRC only flag the opposite space between E1 and E2.
@ 3. DRC flag the enclosure between concave corner and concave corner or the enclosure between convex corner and convex corner.
@ DRC doesn’t check LDBK region.	≥	0.105	um

 PACT_CONER_CONVEX = INT [PACT] < 0.001 ABUT INTERSECTING ONLY
 NW_CONER_CONVEX =  INT [NW] < 0.105-0.065+0.001 ABUT INTERSECTING ONLY
 ERR_1_temp = ENC [PACT_CONER_CONVEX] NW_CONER_CONVEX < 0.105 OPPOSITE EXTENDED 0.065
 ERR_1 = INT ERR_1_temp < 0.001 ABUT REGION INTERSECTING ONLY
 (ERR_1 NOT INSIDE LDBK) NOT MARKS

 NW_CONER_CONCAV = EXT [NW] < 0.001 ABUT INTERSECTING ONLY
 PACT_CONER_CONCAVE =  EXT [PACT] < 0.105-0.065+0.001 ABUT INTERSECTING ONLY
 ERR_2_temp = ENC PACT_CONER_CONCAVE [NW_CONER_CONCAV] < 0.105 OPPOSITE EXTENDED 0.065
 ERR_2 = EXT ERR_2_temp < 0.001 ABUT REGION INTERSECTING ONLY
 (ERR_2 NOT INSIDE LDBK) NOT MARKS
}

AA_19 {
@ NW enclosure of (P+AA INTERACT (DG OR TG)).
@ DRC doesn’t check LDBK region.	≥	0.18	um
 X = ENC ((PACT INTERACT DGTG) NOT COIN EDGE PTAP) NW < 0.18 ABUT < 90  REGION
 OUT1 = X NOT LDBK
 OUT1 NOT MARKS 
}

AA_20 {
@ Space between NW and P+ pickup AA. >= 0.065
@ DRC doesn’t check LDBK and INST region.
 X0 = OR LDBK INST
 X = EXT NW (PTAP NOT INSIDE X0) < 0.065 ABUT < 90 SINGULAR REGION
 W = X NOT LDBK
 OUT1 = W NOT INSIDE INST
 OUT1 NOT MARKS
}

AA_21a {
@ (AA and AA_DMY) density. Density check window size: 50um*50um, step size: 25um
@ DRC don’t check: 
@ 1. NW resistor
@ 2. Chip corner triangle region (NODMF) sizing up 0.4um if seal ring is added by SMIC.
@ 3. Seal ring (MARKS) sizing up 0.4um if seal ring is added by customer.	≥	15%
 X = ((SIZE NODMF BY 0.4) OR (SIZE MARKS BY 0.4)) OR (NW INTERACT RESNW)
 Y = AA_all NOT X
 Z = DRC:1 NOT X 
 DENSITY Y Z [AREA(Y)/AREA(Z)] < 0.15 WINDOW 50 STEP 25  BACKUP PRINT density_report_AA_21a.log RDB density_report_AA_21a.rdb
}

AA_21b {
@ (AA and AA_DMY) density. Density check window size: 150um*150um, step size: 75um
@ DRC don’t check:
@ 1. NW resistor
@ 2. Chip corner triangle region (NODMF) sizing up 0.4um if seal ring is added by SMIC.
@ 3. Seal ring (MARKS) sizing up 0.4um if seal ring is added by customer.	≥	20%
 X = ((SIZE NODMF BY 0.4) OR (SIZE MARKS BY 0.4)) OR (NW INTERACT RESNW)
 Y = AA_all NOT X
 Z = DRC:1 NOT X 
 DENSITY Y Z [AREA(Y)/AREA(Z)] < 0.2 WINDOW 150 STEP 75  BACKUP PRINT density_report_AA_21b.log RDB density_report_AA_21b.rdb
}

AA_21b_R_DFM3 {
@ (AA and AA_DMY) density. Density check window size: 20um*20um, step size: 10um
@ DRC don’t check: 
@ 1. NW resistor
@ 2. Chip corner triangle region (NODMF) sizing up 0.4um if seal ring is added by SMIC.
@ 3. Seal ring (MARKS) sizing up 0.4um if seal ring is added by customer.	≥	20%
 X = ((SIZE NODMF BY 0.4) OR (SIZE MARKS BY 0.4)) OR (NW INTERACT RESNW)
 Y = AA_all NOT X
 Z = DRC:1 NOT X 
 DENSITY Y Z [AREA(Y)/AREA(Z)] < 0.2 WINDOW 20 STEP 10  BACKUP PRINT density_report_AA_21b_R.log RDB density_report_AA_21b_R.rdb
}

AA_21c {
@ (AA and AA_DMY) density for non-IO region. Density check window size: 150um*150um, step size: 75um
@ DRC don’t check: 
@ 1. NW resistor
@ 2. Chip corner triangle region (NODMF) sizing up 0.4um if seal ring is added by SMIC.
@ 3. Seal ring (MARKS) sizing up 0.4um if seal ring is added by customer.	≤	80%	
 X = ((SIZE NODMF BY 0.4) OR (SIZE MARKS BY 0.4)) OR (NW INTERACT RESNW)
 Y = (AA_all NOT X) NOT DGTG
 Z = (DRC:1 NOT X) NOT DGTG
 DENSITY Y Z [AREA(Y)/AREA(Z)] > 0.8 WINDOW 150 STEP 75  BACKUP PRINT density_report_AA_21c.log RDB density_report_AA_21c.rdb
}

AA_21d {
@ (AA and AA_DMY) for IO region. Density check window size: 150um*150um, step size: 75um
@ DRC don’t check: 
@ 1. NW resistor
@ 2. Chip corner triangle region (NODMF) sizing up 0.4um if seal ring is added by SMIC.
@ 3. Seal ring (MARKS) sizing up 0.4um if seal ring is added by customer.	≤	90%
  X = ((SIZE NODMF BY 0.4) OR (SIZE MARKS BY 0.4)) OR (NW INTERACT RESNW)
  Y = (AA_all NOT X) AND DGTG 
  Z = (DRC:1 NOT X) AND DGTG 
  DENSITY Y Z [AREA(Y)/AREA(Z)] > 0.9 WINDOW 150 STEP 75  BACKUP PRINT density_report_AA_21d.log RDB density_report_AA_21d.rdb
}

AA_21e_l {
@ (AA or AA_DMY) density in full chip >=25%  <=75%
  X = AA_all NOT MARKS 
  Y = DRC:1 NOT MARKS
  DENSITY X Y [AREA(X)/AREA(Y)]  < 0.25  PRINT density_report_AA_21e_l.log RDB density_report_AA_21e_l.rdb
}

AA_21e_h {
@ (AA or AA_DMY) density in full chip   <=75%
  X = AA_all NOT MARKS 
  Y = DRC:1 NOT MARKS
  DENSITY X Y [AREA(X)/AREA(Y)]  > 0.75  PRINT density_report_AA_21e_h.log RDB density_report_AA_21e_h.rdb
}
	
AA_21f_R_DFM3 {
@ (AA or AA_DMY) density inside of the dummy block area(DUMBA), Density check window size: 20um*20um, step size: 10um
@ DRC need check the design if DUMBA width is >5um and <20um, where density ratio= AA area/DUMBA area. >=20%
  X = ENCLOSE RECTANGLE DUMBA 20 20 ORTHOGONAL ONLY
  Y0 = AA_all NOT MARKS 
  Z0 = X NOT MARKS 
  DENSITY Y0 Z0 [AREA(Y0)/AREA(Z0)] < 0.20 WINDOW 20 STEP 10 BACKUP  PRINT density_report_AA_21f.log RDB density_report_AA_21f_1.rdb

  Y = (ENCLOSE RECTANGLE DUMBA 5.001 5.001 ORTHOGONAL ONLY) NOT (X OR MARKS)
  Z = DFM PROPERTY Y Y0 [ RATIO = AREA(Y0)/AREA(Y) ] < 0.2
  DFM RDB Z density_report_AA_21f_2.rdb
  Z NOT MARKS 
}

AA_22 {
@ AA area.>=0.018
@ DRC doesn’t check INST region.
  X = AREA (AA_with_dummy NOT INSIDE INST) < 0.018
  X NOT MARKS 
}

AA_23a {
@ AA area when AA any edge length<0.1um.
@ DRC doesn’t check INST region.	≥	0.03	um2
  X = AREA (AA_with_dummy WITH EDGE (length AA_with_dummy < 0.1)) < 0.03
  OUT1 = X NOT INSIDE INST
  OUT1 NOT MARKS 
}

AA_23b {
@ AA area when AA all of edge length <0.13um
@ DRC doesn’t check INST region and  and doesn’t check the AA pattern which can fill 0.1um * 0.3um rectangular pattern ≥ 0.04um2
  AA_ignore = (ENCLOSE RECTANGLE AA_with_dummy 0.1 0.3 ORTHOGONAL ONLY ) OR (AA_with_dummy WITH EDGE (length AA_with_dummy >= 0.13))
  X = AREA (AA_with_dummy NOT AA_ignore) < 0.04
  OUT1 = X NOT INSIDE INST
  OUT1 NOT MARKS
}

AA_24 {
@ AA enclosed area. ≥	0.0288um2
  X = (HOLES AA_with_dummy INNER) NOT AA_with_dummy 
  OUT1 = AREA X < 0.0288
  OUT1 NOT MARKS
}

AA_25 {
@ AA enclosed area when any of inner edge length < 0.13um >=0.04
  X = (HOLES (AA_with_dummy WITH EDGE (LENGTH (AA_with_dummy TOUCH EDGE (HOLES AA_with_dummy INNER)) <0.13)) INNER) NOT AA_with_dummy
  OUT1 = AREA X <0.04 
  OUT1 NOT MARKS
}

AA_SDP=((AA AND SP) INTERACT GATE_CORE) NOT ((GT or GTDMP) or GTDOP)

AA_26 {
@ Area sum of ((AA AND SP) INTERACT poly) NOT ((poly or GTDMP) or GTDOP)) in the same AA for core PMOS device.<=280
 OUT1 = DFM PROPERTY  (AA INTERACT AA_SDP) AA_SDP  OVERLAP ABUT ALSO MULTI    
 [-=AREA (AA_SDP)] >280 
 OUT1 NOT MARKS
}

AA_27a {
@ AA length between two CTs when AA width <0.1um.
@ This rule doesn’t check the region of (MOMDMY sizing up 0.9um).	≤	18	um
 AA_CHECK = WITH WIDTH AA < 0.1
 Z0 = SIZE CT BY 9 INSIDE OF AA_CHECK STEP 0.02
 Z1 = Z0 INTERACT CT < 2
 Z2 = (AA_CHECK INTERACT Z1) NOT (AA_CHECK INTERACT CT == 1)
 OUT1 = Z2 NOT (SIZE MOMDMY BY 0.9)
 OUT1 NOT MARKS
}

AA_27b {
@ AA length between one CT and this AA line-end when AA width <0.1um. 
@ AA line-end definition: AA edge <0.1um, and the AA edge is between two consecutive 90degree outer vertex.
@ This rule doesn’t check the region of (MOMDMY sizing up 0.9um).	≤	18	um
 X = CONVEX EDGE AA ANGLE1>=89.9<=90.1 ANGLE2>=89.9<=90.1 WITH LENGTH<0.1 
 Y = (AA WITH WIDTH < 0.1) INTERACT CT  
 Z = Y TOUCH EDGE X
 Z0 = SIZE CT BY 18 INSIDE OF Y STEP 0.02
 OUT1 = ((Z NOT INSIDE EDGE Z0) NOT TOUCH EDGE Z0) NOT INSIDE EDGE (SIZE MOMDMY BY 0.9) 
 OUT1 NOT INSIDE EDGE MARKS 
}

AA_28 {
@ L-shape AA edge length (L1) (AA INTERACT poly) when L-shape AA width (W1) <0.18um in source/drain direction.
@ L-shape AA edge definition: the edge is between consecutive 90degree outer vertex and 270 degree inner vertex.	≤	0.275	um
 X = VERTEX (AA_LS INTERACT GATE) == 6   
 ERR = (CONVEX EDGE X ANGLE1 == 90 ANGLE2 == 270 WITH LENGTH > 0.275) NOT touch edge GATE 
 Y = INT ERR (AA_LS INTERACT GT) < 0.005 REGION ABUT 
 OUT1 = LENGTH ((AA_LS TOUCH EDGE Y) NOT TOUCH EDGE ERR) < 0.18   
 OUT1 NOT INSIDE EDGE MARKS 
}

AA_31 {
@ Any edge length of (AA INTERACT poly) with another adjacent edge length <0.13um.>=0.13
@ DRC doesn’t check INST region.
 X = INT (LENGTH (AA_with_dummy INTERACT GT) < 0.13) < 0.005 REGION ABUT
 Y = EXT (LENGTH (AA_with_dummy INTERACT GT) < 0.13) < 0.005 REGION ABUT
 OUT1 = (X OR Y) NOT INSIDE INST
 OUT1 NOT MARKS 
}

AA_34 {
@ AA must be fully covered by (SP or SN).
@ DRC doesn’t check AA_DMY , LOGO, OCCD, OCOVL and RESNW related region
 OUT1 = ((AA NOT INTERACT RESNW) NOT (OR LOGO OCCD OCOVL AA_DMY)) NOT (SP OR SN)
 OUT1 NOT MARKS
}
}
		
RULECHECK AA_35 {
@ (AA INTERACT poly) must be rectangular, single L-, T-, or U-shape and the GATE direction must be perpendicular to the edge E) of this T- or U-shape design.
@ (45-degree edge is not allowed)
@ DRC doesn’t check INDMY, INST region and LOGO.
 SETLAYER W = (NOT RECTANGLE (AA INTERACT GT)) NOT ((AA_LS OR AA_TS) OR AA_US)
 OUTLAYER (W NOT INSIDE ((INST OR LOGO) OR INDMY)) NOT MARKS 

 SETLAYER X1 = ANGLE (CONVEX EDGE (AA_TS OR AA_US) ANGLE1 == 90 ANGLE2 == 270 WITH LENGTH > 0.001) != 45
 SETLAYER X0 = ANGLE (CONVEX EDGE AA_US ANGLE1 == 270 ANGLE2 == 270 WITH LENGTH > 0.001) != 45
 SETLAYER X2 = ANGLE (GT INSIDE EDGE (AA WITH EDGE (ANGLE X0 == 90))) != 0
 SETLAYER X3 = ANGLE (GT INSIDE EDGE (AA WITH EDGE (ANGLE X0 == 0))) != 90
 OUTLAYER (X2 NOT INSIDE EDGE ((INST OR LOGO) OR INDMY)) NOT INSIDE EDGE MARKS
 OUTLAYER (X3 NOT INSIDE EDGE ((INST OR LOGO) OR INDMY)) NOT INSIDE EDGE MARKS

 SETLAYER X4 = (CONVEX EDGE AA_TS == 2) NOT TOUCH EDGE (INT (CONVEX EDGE AA_TS == 2) < 0.005 ABUT == 90 REGION)
 SETLAYER X5 = ANGLE (GT INSIDE EDGE (AA WITH EDGE ( ANGLE X4 == 90 ))) != 0
 SETLAYER X6 = ANGLE (GT INSIDE EDGE (AA WITH EDGE ( ANGLE X4 == 0 ))) != 90 
 OUTLAYER (X5 NOT INSIDE EDGE ((INST OR LOGO) OR INDMY)) NOT INSIDE EDGE MARKS
 OUTLAYER (X6 NOT INSIDE EDGE ((INST OR LOGO) OR INDMY)) NOT INSIDE EDGE MARKS 
}


VERBATIM {		
//=============================================
//	AADMP: AA Dummy rules
//=============================================

GROUP GAADMP AADMP_?

AADMP_1	{
@ AADMP width
@ DRC doesn’t check MOMDMY region for maximum width check.	≥	0.05 	≤	0.5
  OUT1 = INT AADMP < 0.05 ABUT < 90 SINGULAR REGION
  OUT1 NOT MARKS
  OUT2 = WITH WIDTH AADMP > 0.5  
  (OUT2 NOT MOMDMY) NOT MARKS 
}

AADMP_2	{
@ AADMP width inside DG/TG ≥	0.1	um
  X = AADMP WITH WIDTH < 0.1
  OUT1 = X AND DGTG
  OUT1 NOT MARKS
}

AADMP_3 {
@ Space between AADMP and (AA or AA_DMY). (AADMP and AA overlap is not allowed)	≥ 0.08um
  OUT1  = EXT AADMP AA  < 0.08 ABUT < 90 SINGULAR REGION
  OUT1 NOT MARKS
  OUT2 = EXT AADMP AA_DMY < 0.08 ABUT < 90 SINGULAR REGION
  OUT2 NOT MARKS
  OUT3 = AADMP AND AA
  OUT3 NOT MARKS
}

AADMP_4	{
@ Space between AADMP and (AA or AA_DMY) inside DG/TG. (overlap is not allowed). ≥	0.15um
  X = AA INSIDE DGTG
  OUT1 = EXT AADMP X < 0.15 ABUT < 90 SINGULAR REGION
  OUT1 NOT MARKS 

  X1 = AA_DMY INSIDE DGTG
  OUT2 = EXT AADMP X1 < 0.15 ABUT < 90 SINGULAR REGION
  OUT2 NOT MARKS 

  OUT3 = AADMP AND ((AA OR AADUM_G) INSIDE DGTG)
  OUT3 NOT MARKS 
}

AADMP_5	{
@ Space between AADMP and 45-degree AA. ≥ 0.45um
  X = ANGLE AA >= 44.9 <= 45.1
  OUT1 = EXT AADMP X < 0.45 ABUT < 90 REGION
  OUT1 NOT MARKS 
}

AADMP_6	{
@ Space between AADMP and (poly OR GTDOP OR GTDMP) (It’s not allowed AADMP overlap with ((poly OR GTDUM) OR GTDOP). ≥ 0.025um
  OUT1 = EXT AADMP GT_all_3 < 0.025 ABUT < 90 SINGULAR REGION
  OUT1 NOT MARKS   
  OUT2 = AADMP AND (GT_all NOT GTDMP)
  OUT2 NOT MARKS 
}

AADMP_7	{
@ Space between AADMP and NW	≥	0.08	um
  OUT1 =  EXT AADMP NW < 0.08 ABUT < 90 SINGULAR REGION
  OUT1 NOT MARKS 
}

AADMP_8 {
@ Space between AADMP and RESNW (overlap is not allowed). ≥ 0.7um
  OUT1 = EXT AADMP RESNW < 0.7 ABUT < 90 SINGULAR REGION
  OUT1 NOT MARKS 
  OUT2 = AADMP AND RESNW
  OUT2 NOT MARKS 
}

AADMP_9 {
@ Space between AADMP and INDMY	≥	1.2
  X = EXT AADMP INDMY < 1.2 ABUT<90  SINGULAR REGION
  X NOT MARKS 
}

AADMP_10 {
@ Space between AADMP and PSUB (overlap is not allowed if AA inside PSUB). ≥ 0.14um
@ DRC doesn’t check MOMDMY region.
  X = EXT AADMP PSUB < 0.14 ABUT < 90 SINGULAR REGION
  Y = PSUB ENCLOSE AA
  Z = AADMP AND Y
  OUT1 = (X OR Z) NOT MOMDMY
  OUT1 NOT MARKS 
}

AADMP_11 {
@ Space between AADMP and DG/TG..
@ It's not allowed AADMP CUT DG/TG.. ≥ 0.08um
  OUT1 = EXT AADMP DGTG < 0.08 ABUT < 90 SINGULAR REGION
  OUT1 NOT MARKS  
  OUT2 =  AADMP CUT DGTG
  OUT2 NOT MARKS 
}

AADMP_12 {
@ Space between AADMP and SP. ≥	0.065um
@ It's not allowed AADMP CUT SP.
  OUT1 = EXT AADMP SP < 0.065 ABUT < 90 SINGULAR REGION
  OUT1 NOT MARKS 
  OUT2 = AADMP CUT SP
  OUT2 NOT MARKS 
}

AADMP_13 {
@ NW enclosure of AADMP	≥ 0.08um
 OUT1 =  ENC AADMP NW < 0.08 ABUT < 90 SINGULAR REGION
 OUT1 NOT MARKS 
}

AADMP_14 {
@ DG/TG enclosure of AADMP.	≥ 0.08um
 OUT1 = ENC AADMP DGTG < 0.08 ABUT < 90 SINGULAR REGION
 OUT1 NOT MARKS 
}

AADMP_15 {
@ SP enclosure of AADMP. ≥ 0.065um
  OUT1 = ENC AADMP SP < 0.065 ABUT < 90 SINGULAR REGION
  OUT1 NOT MARKS 
}

AADMP_16 {
@ AADMP area. ≥	0.03um2
  OUT1 = AREA AADMP < 0.03
  OUT1 NOT MARKS 
}

AADMP_17 {
@ AADMP length.
@ DRC doesn't check RESP1, RESAA and MOMDMY regions for the maximum length check.≥0.6 ≤	16
  X = LENGTH AADMP > 16
  (X NOT INSIDE EDGE ((RESP1 OR RESAA) OR MOMDMY)) NOT INSIDE EDGE MARKS

 M1_edge = length AADMP > 0
 M1_edge_measure = DFM PROPERTY M1_edge  [MEM = length(M1_edge)]
 M1_max_length = DFM PROPERTY AADMP M1_edge_measure overlap abut also multi [MML = max(property(M1_edge_measure,MEM))]
 M1_longest_edge = DFM PROPERTY M1_edge M1_edge_measure M1_max_length overlap abut also multi
                   [a =property(M1_edge_measure,MEM)-property(M1_max_length,MML)] == 0
 (LENGTH M1_longest_edge < 0.6) NOT INSIDE EDGE MARKS
}

AADMP_18_R_DFM3 {
@ (AA OR AA_DMY) density.
@ DRC check window follow:  ((AA OR poly) INTERACT GATE) sizing up 2um) NOT ((AA OR poly) sizing up 0.15um)) 
@ This rule doesn't check DG, TG, VARMOS, NODMF, INST and OCOVL OCCDregions.
  X = (AA OR GT) INTERACT GATE
  Y = SIZE X BY 2
  Z = SIZE (AA OR GT) BY 0.15
  H = Y NOT Z
  P = ((((VARMOS OR NODMF) OR INST) OR OCOVL) OR OCCD) OR DGTG
  R = (H NOT P) NOT MARKS 

  AA_AA_DMY = (AA OR AA_DMY) NOT MARKS 
  T = DFM PROPERTY R AA_AA_DMY [ RATIO = AREA(AA_AA_DMY)/AREA(R) ] < 0.1
  DFM RDB T density_report_AADMP_18.rdb
  COPY T 
}

AADMP_19 {
@ It’s not allowed 45-degree bent AADMP.
  OUT1 = ANGLE AADMP > 44.9 < 45.1
  OUT1 NOT INSIDE EDGE MARKS 
}
			
AADMP_20 {
@ CT is not allowed to INTERACT with AADMP
  OUT1 = CT INTERACT AADMP
  OUT1 NOT MARKS 
}
			
AADMP_21 {
@ AADMP must be rectangular.
 OUT1 = NOT RECTANGLE AADMP
 OUT1 NOT MARKS 
}			


//==================================
//  NW -  N-Well  DRC
//==================================

GROUP GNW NW_?

NW_1 {
@ Min NW width is 0.24
@ DRC doesn’t check INST region.
  X = INT NW < 0.24 ABUT<90 SINGULAR REGION OPPOSITE
  OUT1 = X NOT INSIDE INST
  OUT1 NOT MARKS 
}

NW_2 {
@ NW space >= 0.24um
  OUT1 = EXT NW < 0.24 ABUT < 90 SINGULAR REGION
  OUT1 NOT MARKS 
}

NW_3_R_DFM2 {
@ Space between NWs if at least one NW width<0.28um. >= 0.28um
@ DRC doesn’t check INST region.
  X = (NW WITH WIDTH < 0.28) COIN EDGE NW
  Y = EXT X NW < 0.28 REGION
  OUT1 = Y NOT INSIDE INST
  OUT1 NOT MARKS 
}
}

RULECHECK NW_4 {
@ Space between NWs with parallel run length >0.5um, which NWs space is on STI (NOT INTERACT AA or AA dummy) >= 0.30um
  Mn_one_width_PART NW 0.001 0.5 0.3
  OUTLAYER (OUT3 NOT INTERACT AA_all) NOT MARKS 
}

VERBATIM {
NW_5 {
@ Min Space between NWs at same net is 0.24
  OUT1 = EXT NW < 0.24 ABUT<90 SINGULAR REGION CONNECTED
  OUT1 NOT MARKS 
}

NW_6 {
@ Space between 1.05V NWs at different net.
@ DRC doesn’t check OCCD region.	≥ 0.8um
  X0 = LVNW NOT INSIDE OCCD
  OUT1 = EXT X0 < 0.8 ABUT<90 SINGULAR REGION NOT CONNECTED
  OUT1 NOT (OR OCCD MARKS)
}

NW_7 {
@ Min Space between 1.05V NW and 1.8/2.5V NW at different net is 1
 OUT1 = EXT LVNW HVNW < 1 ABUT<90 SINGULAR REGION NOT CONNECTED
 OUT1 NOT MARKS
}

NW_8 {
@ Space between 1.8V/2.5V NWs at different net ≥	1	um
  OUT1 = EXT HVNW < 1 ABUT<90 SINGULAR REGION NOT CONNECTED
  OUT1 NOT MARKS 
}
NW_9 {
@ NW area (um2)	≥ 0.4um2
  OUT1 = AREA NW < 0.4
  OUT1 NOT MARKS 
}

NW_10 {
@ NW enclosed area (um2) ≥ 0.4um2
  X = (HOLES NW INNER) NOT NW
  OUT1 = AREA X < 0.4
  OUT1 NOT MARKS 
}

NW_11 {
@ Area of (NW NOT DG), (DG AND NW), (NW NOT TG), (TG AND NW). ≥	0.35um2
  (AREA (NW NOT DG) < 0.35) NOT MARKS
  (AREA (DG AND NW) < 0.35) NOT MARKS
  (AREA (NW NOT TG) < 0.35) NOT MARKS
  (AREA (TG AND NW) < 0.35) NOT MARKS
}

NW_12 {
@ Enclosed area of (NW NOT DG), (DG AND NW), (NW NOT TG), (TG AND NW). ≥ 0.35um2
  X1 = NW NOT DG
  Y1 = (HOLES X1 INNER) NOT X1
  (AREA Y1 < 0.35) NOT MARKS

  X2 = DG AND NW
  Y2 = (HOLES X2 INNER) NOT X2
  (AREA Y2 < 0.35) NOT MARKS

  X3 = NW NOT TG
  Y3 = (HOLES X3 INNER) NOT X3
  (AREA Y3 < 0.35) NOT MARKS

  X4 = TG AND NW
  Y4 = (HOLES X4 INNER) NOT X4
  (AREA Y4 < 0.35) NOT MARKS
}



//==========================================
//  PSUB - Native NMOS blocked implant DRC
//==========================================

GROUP GPSUB PSUB_?

GATE_ZVT = (GATE INTERACT ZVT) NOT OUTSIDE PSUB
GATE_ZVT_CORE = GATE_ZVT NOT INSIDE DGTG

PSUB_1 {
@ Min PSUB width is 0.24
  OUT1 = INT PSUB < 0.24 ABUT<90 SINGULAR REGION
  OUT1 NOT MARKS 
}

PSUB_2 {
@ PSUB space >= 0.240um
  OUT1 = EXT PSUB < 0.24 ABUT < 90 SINGULAR REGION
  OUT1 NOT MARKS 
}

PSUB_3_R_DFM2 {
@ Space of PSUBsif at least one PSUB width<0.28um. >= 0.28
  X = (PSUB WITH WIDTH < 0.28) COIN EDGE PSUB
  OUT1 = EXT X PSUB < 0.28 REGION
  OUT1 NOT MARKS 
}

PSUB_4a	{
@ Channel width for core zero/native Vt NMOS
@ DRC doesn’t check INDMY region ≥ 0.5um ≤ 10um
  W = (GATE_WE NOT OUTSIDE EDGE PSUB) COIN EDGE GATE_CORE
  X = LENGTH W < 0.5
  Y = LENGTH W > 10
  Z =  X OR EDGE Y
  OUT1 = GATE_CORE WITH EDGE Z
  OUT1 NOT (OR INDMY MARKS)
}

PSUB_4b {
@ Channel width for IO native NMOS. ≥ 0.500um
  X = (GATE_IO AND PSUB) COIN EDGE GATE_LE
  OUT1 = INT X < 0.5 ABUT < 90 REGION OPPOSITE
  OUT1 NOT MARKS 
}

PSUB_5a {
@ Channel length for core zero Vt NMOS. ≥ 0.200um ≤ 6um
  W = GATE_LE COIN EDGE GATE_ZVT_CORE
  X = LENGTH W < 0.2
  Y = LENGTH W > 6
  Z =  X OR EDGE Y
  OUT1 = GATE_ZVT_CORE WITH EDGE Z
  OUT1 NOT MARKS 
}

PSUB_5b {
@ Channel length for core native Vt NMOS. ≥ 0.3um ≤ 6um
  L = ((GATE AND PSUB) NOT ZVT) NOT DGTG
  W = GATE_LE COIN EDGE L
  X = LENGTH W < 0.3
  Y = LENGTH W > 6
  Z =  X OR EDGE Y
  OUT1 = L WITH EDGE Z
  OUT1 NOT MARKS 
}

PSUB_5c {
@ Channel length for 1.8V IO NMOS	 ≥ 0.8um ≤ 6um
  L = (GATE AND PSUB) AND DG
  W = GATE_LE COIN EDGE L
  X = LENGTH W < 0.8
  Y = LENGTH W > 6
  Z =  X OR EDGE Y
  OUT1 = L WITH EDGE Z
  OUT1 NOT MARKS
}

PSUB_5d {
@ Channel length for 2.5V IO NMOS	≥ 1.2um	≤ 6um
  L = (GATE AND PSUB) AND TG
  W = GATE_LE COIN EDGE L
  X = LENGTH W < 1.2
  Y = LENGTH W > 6
  Z =  X OR EDGE Y
  OUT1 = L WITH EDGE Z
  OUT1 NOT MARKS
}

PSUB_6 {
@ Space between PSUB and N+AA or P+AA	≥	0.38	um
 OUT1 = EXT PSUB NACT < 0.38 ABUT < 90 SINGULAR REGION MEASURE ALL
 OUT1 NOT MARKS 
 OUT2 = EXT PSUB PACT < 0.38 ABUT < 90 SINGULAR REGION MEASURE ALL
 OUT2 NOT MARKS 
}

PSUB_7 {
@ MIn Space between PSUB and NW is 0.8
 OUT1 = EXT PSUB NW < 0.8 ABUT<90 SINGULAR REGION
 OUT1 NOT MARKS  
}

PSUB_8 {
@ MOS AA enclosure by PSUB.
@ DRC doesn’t check INDMY region.	=	0.16	um
  X = AA INTERACT ((GATE AND PSUB) NOT INDMY)
  Y = SIZE X BY 0.16
  OUT1 = Y NOT COIN EDGE PSUB  
  OUT1 NOT INSIDE EDGE MARKS 
}

PSUB_9 {
@ ((Poly extension outside of AA) NOT OUTSIDE PSUB) along poly length direction
@ DRC doesn’t check INDMY region.	≥	0.24	um
  X = ENC AA GT < 0.24 ABUT<90 SINGULAR REGION
  OUT1 = (X NOT OUTSIDE PSUB) NOT INSIDE INDMY
  OUT1 NOT MARKS 
}

PSUB_10	{
@ PSUB area. ≥ 0.4um2
  OUT1 = AREA PSUB < 0.4
  OUT1 NOT MARKS 
}

PSUB_11 {
@ PSUB enclosed area. ≥	0.4um2
  X = HOLES PSUB INNER
  Y = X NOT PSUB
  OUT1 = AREA Y < 0.4
  OUT1 NOT MARKS 
}

PSUB_12 {
@ PSUB must not overlap NW or DNW.
  (PSUB AND NW ) NOT MARKS 
  (PSUB AND DNW) NOT MARKS
}
			
PSUB_13 {
@ One AA shape per PSUB shape, except for NMOS capacitors, pickup region.
  OUT1 = PSUB CUT (AA NOT PTAP) > 1
  OUT1 NOT MARKS 
}

PSUB_14	{
@ It’s not allowed P+ GATE in PSUB.
@ DRC doesn’t check INDMY region.
  OUT1 = (PGATE AND PSUB) NOT INSIDE INDMY
  OUT1 NOT MARKS 
}

PSUB_15 {
@ It’s not allowed ZVT and TG on the same chip
  ((DRC:1 INTERACT ZVT) INTERACT TG) NOT MARKS 
}
}			


#//=================================================
#//  LVT_N : Low Vt NMOS design rules
#//  LVT_P : Low Vt PMOS design rules
#//================================================

set vt_list { LVT_N LVT_P }
foreach vt_layer $vt_list {

GROUP G$vt_layer ${vt_layer}_?

RULECHECK ${vt_layer}_1 {
@ $vt_layer width. Single-point-interaction is allowed. 
@ DRC doesn’t highlight the violation when $vt_layer opposite side width ≥0.135um, and <0.16um.	≥ 0.16um
  SETLAYER X = (INT $vt_layer < 0.16 ABUT < 90 REGION ) NOT MARKS 
  SETLAYER Y = INT $vt_layer < 0.16 ABUT < 90 REGION  PROJ == 0 
  OUTLAYER X NOT Y 
  OUTLAYER (INT $vt_layer < 0.135 ABUT < 90 REGION) NOT MARKS
}

RULECHECK ${vt_layer}_2 {
@ Space between ${vt_layer}s.
@ DRC doesn’t highlight the violation when ${vt_layer}s opposite side width ≥0.135um, and <0.16um. ≥ 0.16um
  SETLAYER X1 = EXT $vt_layer < 0.16 ABUT < 90 REGION 
  SETLAYER X3 = EXT $vt_layer < 0.16 ABUT < 90 REGION PROJ == 0
  OUTLAYER (X1 NOT X3) NOT MARKS 
  SETLAYER X2 = EXT $vt_layer < 0.135 ABUT < 90 REGION
  OUTLAYER  X2 NOT MARKS
}

RULECHECK ${vt_layer}_3_R_DFM3 {
@ Space between ${vt_layer}s with parallel run length >0.24um, when one $vt_layer width >0.22um. >= 0.180um
  Mn_one_width $vt_layer 0.221 0.24 0.18
}

RULECHECK ${vt_layer}_4 {
@ Space between ${vt_layer}s with parallel run length >0.33um, and ${vt_layer} space is on STI (not INTERACT AA OR AA dummy). >= 0.25um
  Mn_one_width_PART $vt_layer 0.001 0.33 0.25
  OUTLAYER (OUT3 NOT INTERACT AA_all) NOT MARKS 
}

RULECHECK ${vt_layer}_5 {
@ $vt_layer extension outside of GATE along GATE poly direction. >= 0.065um
  OUTLAYER (ENC GATE_LE $vt_layer < 0.065 ABUT < 90 REGION OPPOSITE MEASURE ALL) NOT MARKS 
}

RULECHECK ${vt_layer}_6 {
@ Space between $vt_layer and GATE along GATE poly direction. >= 0.065um
  OUTLAYER (EXT GATE_LE $vt_layer < 0.065 ABUT < 90 REGION OPPOSITE MEASURE ALL) NOT MARKS
}

RULECHECK ${vt_layer}_7 {
@ $vt_layer extension outside of GATE along source/drain direction.  >= 0.115um
  OUTLAYER (ENC GATE_WE $vt_layer < 0.115 ABUT < 90 REGION OPPOSITE MEASURE ALL) NOT MARKS
}

RULECHECK ${vt_layer}_8 {
@ Space between $vt_layer and GATE along source/drain direction. >= 0.115um
@ (((N+AA OR P+AA) OR GATE) CUT $vt_layer) is not allowed.
  OUTLAYER (EXT GATE_WE $vt_layer < 0.115 ABUT < 90 REGION OPPOSITE MEASURE ALL) NOT MARKS
  OUTLAYER (NACT CUT $vt_layer) NOT MARKS
  OUTLAYER (PACT CUT $vt_layer) NOT MARKS
  OUTLAYER (GATE CUT $vt_layer) NOT MARKS
}

RULECHECK ${vt_layer}_9	{
@ Space between $vt_layer and non-silicided AA/poly resistor	≥	0.15 	um
  OUTLAYER (EXT $vt_layer AARES_N < 0.15 ABUT < 90 SINGULAR REGION) NOT MARKS
  OUTLAYER (EXT $vt_layer GTRES_N < 0.15 ABUT < 90 SINGULAR REGION) NOT MARKS
}

RULECHECK ${vt_layer}_10 {
@ 45-degree edge length	≥ 0.52um
  OUTLAYER (LENGTH (ANGLE $vt_layer >= 44.9 <= 45.1) < 0.52) NOT INSIDE EDGE MARKS 
}

RULECHECK ${vt_layer}_11 {
if { ([string equal $vt_layer LVT_P] == 1) } {
@ $vt_layer overlap N+ AA, LVP_N, PSUB, DG, TG, RESAA, RESNW, RESP1, VARMOS, BIPOLA, LOGO is prohibited.
}
if { ([string equal $vt_layer LVT_N] == 1) } {
@ $vt_layer overlap P+AA,LVT_P, PSUB, DG, TG, RESAA, RESNW, RESP1, VARMOS, BIPOLA, LOGO is prohibited.
}
  OUTLAYER (LVT_P AND LVT_N) NOT MARKS
  OUTLAYER (LVT_N AND PACT) NOT MARKS
  OUTLAYER (LVT_P AND NACT) NOT MARKS
  OUTLAYER ($vt_layer AND PSUB) NOT MARKS
  OUTLAYER ($vt_layer AND DG) NOT MARKS
  OUTLAYER ($vt_layer AND TG) NOT MARKS
  OUTLAYER ($vt_layer AND RESAA) NOT MARKS
  OUTLAYER ($vt_layer AND RESNW) NOT MARKS
  OUTLAYER ($vt_layer AND RESP1) NOT MARKS
  OUTLAYER ($vt_layer AND VARMOS) NOT MARKS
  OUTLAYER ($vt_layer AND BIPOLA) NOT MARKS
  OUTLAYER ($vt_layer AND LOGO) NOT MARKS
}
			
RULECHECK ${vt_layer}_12 {
@ $vt_layer area. ≥ 0.1um2
  OUTLAYER (AREA $vt_layer < 0.1) NOT MARKS
}

RULECHECK ${vt_layer}_13 {
@ $vt_layer enclosed area. ≥	0.1um2
  SETLAYER X =  HOLES $vt_layer INNER
  SETLAYER Y =  X NOT $vt_layer
  OUTLAYER (AREA Y < 0.1) NOT MARKS
}
}


VERBATIM {
//============================
//   DG - Dual Gate DRC
//============================

GROUP GDG DG_?

DG_1 {
@ Min DG width is 0.32
 OUT1 = INT DG < 0.32 ABUT<90 SINGULAR REGION
 OUT1 NOT MARKS 
}

DG_2 {
@ Min Space between two DGs is 0.32.
 OUT2 = EXT DG < 0.32 ABUT<90 SINGULAR REGION
 OUT2 NOT MARKS 
}

DG_3 {
@ DG enclosure of AA. Pick-up AAs do not need to follow this rule. ≥ 0.13um
 X = AA NOT TAP
 OUT1 = ENC X DG < 0.13 ABUT<90 SINGULAR REGION
 OUT1 NOT MARKS 
}

DG_4a {
@ DG enclosure of GATE along S/D direction. ≥ 0.240um
 X = GATE INSIDE EDGE AA
 OUT1 = ENC X DG < 0.24 ABUT<90 REGION OPPOSITE
 OUT1 NOT MARKS 
}

DG_4b {
@ DG enclosure of GATE along poly length direction. ≥ 0.13um
 X = GATE INSIDE EDGE GT
 OUT1 = ENC X DG < 0.13 ABUT<90 REGION OPPOSITE
 OUT1 NOT MARKS 
}

DG_5 {
@ Space between DG and AA (except pickup AA). It is not allowed that AA CUT DG(except pickup AA).>= 0.13
 OUT1 = EXT DG (AA NOT TAP) < 0.13 ABUT<90 SINGULAR REGION
 OUT1 NOT MARKS 
 OUT2 = (AA CUT DG) NOT TAP
 OUT2 NOT MARKS 
}

DG_6a {
@ Min Space between DG and gate along S/D direction is 0.24. 
 X = GATE INSIDE EDGE AA
 OUT1 = EXT X DG < 0.24 ABUT<90 REGION OPPOSITE
 OUT1 NOT MARKS 
}

DG_6b {
@ Space between DG and GATE along poly direction. ≥ 0.13um
 X = GATE INSIDE EDGE GT
 OUT1 = EXT X DG < 0.13 ABUT<90 REGION OPPOSITE
 OUT1 NOT MARKS
}

DG_7 {
@ Space between DG and NW. Space= 0um is allowed.>= 0.24.
 OUT1 = EXT DG NW < 0.24 ABUT >0 < 90 SINGULAR REGION
 OUT1 NOT MARKS 
}

DG_8 {
@ Space between (NW NOT DG) and (NW NOT DG)	≥	0.24	um
 X = NW NOT DG
 OUT1 = EXT X < 0.24 ABUT < 90 SINGULAR REGION 
 OUT1 NOT MARKS 
}

DG_9 {
@ Space between (DG AND NW) and (DG AND NW)
 X = DG AND NW
 OUT1 =  EXT X < 0.24 ABUT < 90 SINGULAR REGION
 OUT1 NOT MARKS 
}

DG_10 {
@ DG extension outside of NW. Extension = 0um is allowed.>= 0.24.
 OUT1 = ENC NW DG < 0.24 ABUT >0 < 90 SINGULAR REGION
 OUT1 NOT MARKS 
}

DG_11 {
@ NW extension outside of DG. Extension = 0um is allowed. ≥ 0.24um
 OUT1 = ENC DG NW < 0.24 ABUT >0 < 90 SINGULAR REGION
 OUT1 NOT MARKS 
}

DG_12 {
@ Min DG overlap of NW. Overlap= 0um is allowed. >= 0.24.
 OUT1 = INT NW DG < 0.24 ABUT>0 < 90 SINGULAR REGION
 OUT1 NOT MARKS 
}

DG_13 {
@ DG area ≥	0.4	um2
 OUT1 = AREA DG < 0.4
 OUT1 NOT MARKS 
}

DG_14 {
@ DG enclosed area 	≥	0.4	um2
 X = (HOLES DG INNER) NOT DG
 OUT1 = AREA X < 0.4
 OUT1 NOT MARKS 
}

DG_15 {
@ DG and TG can't be used on same chip.
 OUT1 = (DRC:1 INTERACT DG) INTERACT TG
 OUT1 NOT MARKS 
}

DG_16 {
@ Width of  (DG OR (NW OR PSUB))	≥	0.24
@ DRC doesn’t check INST region.
 X = INT ((DG OR (NW OR PSUB)) NOT INST) < 0.24 ABUT < 90 SINGULAR REGION 
 X NOT MARKS 
}

DG_17 {
@ Space between (DG NOT (NW OR PSUB)) and (DG NOT (NW OR PSUB))	≥	0.24
 X = EXT (DG NOT (NW OR PSUB)) < 0.24 ABUT < 90 SINGULAR REGION
 X NOT MARKS 
}


//============================================================
//   TG: Dual GATE design rules to define 2.5V IO device
//============================================================

GROUP GTG TG_?

TG_1 {
@ TG width	≥	0.320	um
 OUT1 = INT TG < 0.32 ABUT < 90 SINGULAR REGION
 OUT1 NOT MARKS 
}

TG_2 {
@ Space between two TGs.	≥	0.320	um
 OUT1 = EXT TG < 0.32 ABUT < 90 SINGULAR REGION
 OUT1 NOT MARKS 
}

TG_3 {
@ AA enclosed by TG. Pick-up AAs do not need to follow this rule.	≥	0.13	um
 X = AA NOT TAP
 OUT1 = ENC X TG < 0.13 ABUT<90 SINGULAR REGION
 OUT1 NOT MARKS 
}

TG_4a {
@ GATE enclosed by TG along S/D direction.	≥	0.240	um
 X = GATE INSIDE EDGE AA
 OUT1 = ENC X TG < 0.24 ABUT<90 REGION OPPOSITE
 OUT1 NOT MARKS 
}

TG_4b {
@ GATE enclosed by TG along poly direction.	≥	0.13	um
 X = GATE INSIDE EDGE GT
 OUT2 = ENC X TG < 0.13 ABUT<90 REGION OPPOSITE
 OUT2 NOT MARKS 
}

TG_5 {
@ Space between TG and AA (except pickup AA). It is not allowed that AA CUT TG (except pickup AA). ≥ 0.13um
 OUT1 = EXT TG (AA NOT TAP) < 0.13 ABUT<90 SINGULAR REGION
 OUT1 NOT MARKS 
 OUT2 = (AA CUT TG) NOT TAP
 OUT2 NOT MARKS 
}

TG_6a {
@ Space between TG and GATE along S/D direction.	≥	0.240	um
 X = GATE INSIDE EDGE AA
 OUT1 = EXT X TG < 0.24 ABUT < 90 REGION OPPOSITE
 OUT1 NOT MARKS 
}

TG_6b {
@ Space between TG and GATE along poly direction.	≥	0.13	um
 X = GATE INSIDE EDGE GT
 OUT1 = EXT X TG < 0.13 ABUT < 90 REGION OPPOSITE
 OUT1 NOT MARKS 
}

TG_7 {
@ Space between TG and NW. Space= 0um is allowed.	≥	0.24	um
 OUT1 = EXT NW TG < 0.24 ABUT > 0 < 90 SINGULAR REGION
 OUT1 NOT MARKS 
}

TG_8 {
@ Space between (NW NOT TG) and (NW NOT TG). ≥	0.24um
 X = NW NOT TG
 OUT1 = EXT X < 0.24 ABUT < 90 SINGULAR REGION
 OUT1 NOT MARKS  
}

TG_9 {
@ Space between (TG AND NW) and (TG AND NW). ≥	0.24um
 X = TG AND NW
 OUT1 = EXT X < 0.24 ABUT < 90 SINGULAR REGION
 OUT1 NOT MARKS 
}

TG_10 {
@ TG extension outside of NW. Extension = 0um is allowed.	≥	0.24	um
 OUT1 = ENC NW TG < 0.24 ABUT > 0 < 90 SINGULAR REGION
 OUT1 NOT MARKS 
}

TG_11 {
@ NW extension outside of TG. Extension = 0um is allowed.	≥	0.24	um
 OUT1 = ENC TG NW < 0.24 ABUT > 0 < 90 SINGULAR REGION
 OUT1 NOT MARKS 
}

TG_12 {
@ TG overlap of NW. Overlap = 0um is allowed.	≥	0.24	um
 OUT1 = INT NW TG < 0.24 ABUT > 0 < 90 SINGULAR REGION
 OUT1 NOT MARKS 
}

TG_13 {
@ TG area	≥	0.4	um2
 OUT1 = AREA TG < 0.4
 OUT1 NOT MARKS 
}

TG_14 {
@ TG enclosed area	≥	0.4	um2
 X = (HOLES TG INNER) NOT TG
 OUT1 = AREA X < 0.4
 OUT1 NOT MARKS 
}

TG_15 {
@ Width of  (TG OR (NW OR PSUB))	≥	0.24
@ DRC doesn’t check INST region.
 X = INT ((TG OR (NW OR PSUB)) NOT INST) < 0.24 ABUT < 90 SINGULAR REGION 
 X NOT MARKS 
}

TG_16 {
@ Space between (TG  NOT (NW OR PSUB)) and (TG  NOT (NW OR PSUB))	≥	0.24
 X = EXT (TG  NOT (NW OR PSUB)) < 0.24 ABUT < 90 SINGULAR REGION
 X NOT MARKS 
}



//===========================
//    GT - Poly design minima
//===========================

GROUP GGT GT_?

LAYER MAP 133  DATATYPE  3  764
LAYER ESDIO2  764

VGT_edge = ANGLE GT == 90
HGT_edge = ANGLE GT == 0

GT_T = (GT INTERACT CT) AND AA
GATE_CORE = GATE NOT INSIDE (DG OR TG)

GATE_IO = GATE AND (DG OR TG)
GATE_IOD = GATE AND DG
GATE_IOT = GATE AND TG

GATE_WE = GATE COIN EDGE GT
//GATE_LE = (GATE TOUCH EDGE (INT GATE_WE GATE < 0.005 ABUT INTERSECTING ONLY REGION)) NOT COIN EDGE GATE_WE    // 1 --- 237
//GATE_LE = (GATE TOUCH EDGE (INT GATE_WE [GATE] < 0.002 ABUT INTERSECTING ONLY)) NOT COIN EDGE GATE_WE         // 2 --- 191
GATE_LE = (GATE TOUCH EDGE (INT GATE_WE [GATE] < 0.001 ABUT INTERSECTING ONLY)) NOT COIN EDGE GATE_WE         // 4 --- 188

GT_CORE = GT_all NOT (DG OR TG)
GT_real = GT NOT P2
GT_real_all = GT_all NOT P2

ESDIO12 = ESDIO1 OR ESDIO2
ESD_CLP = OR ESDIO1 ESDIO2 ESDCLP ESDPOB CLPDMY
ESD_CLP_MARKS = ESD_CLP OR MARKS

GATE_CORE_SIZE_6 = SIZE GATE_CORE BY 0.06 INSIDE OF GT STEP 0.02
GATE_IO_SIZE_6 = SIZE GATE_IO BY 0.06 INSIDE OF GT STEP 0.02

GT_1 {
@ Width. ≥ 0.03um
  X = INT GT_with_dummy < 0.03 ABUT < 90 SINGULAR REGION
  X NOT MARKS 
}

GT_2 {
@ Width of horizontal poly. ≥ 0.040um
@ DRC only check opposite side.
  OUT1 = INT HGT_edge < 0.04 REGION OPPOSITE
  OUT1 NOT MARKS 
  X = ANGLE GTDUM_G == 0
  OUT2 = INT X < 0.04 REGION OPPOSITE
  OUT2 NOT MARKS 
}

GT_3 {
@ Width of horizontal poly.
@ This rule doesn’t check rectangle or L-shape poly, and poly covered by P2.	≥	0.06	um
  X = (NOT RECTANGLE GT_real) NOT GT_real_LS
  Y = ANGLE X == 0
  OUT1 = INT Y < 0.06 ABUT < 90 REGION
  OUT1 NOT MARKS 
}

GT_4 {
@ Width of ((poly INTERACT CT) NOT OUTSIDE (DG OR TG)),when space between (poly NTERACT CT) and (AA INTERACT CT) <0.05um.
@ DRC check poly width when the width is measured in parallel to space direction.	≥	0.1	um
  X = (GT INTERACT CT) NOT OUTSIDE DGTG
  Y = AA INTERACT CT
  Z = EXT [X] Y < 0.05 ABUT < 90 SINGULAR
  OUT1 = INT Z GT < 0.1 ABUT < 90 REGION
  OUT1 NOT MARKS 
}

GT_5 {
@ Channel Length for core NMOS /PMOS transistor.
@ This rule isn’t applicable for ESDIO1, ESDIO2, ESDCLP, ESDPOB, CLPDMY, VARMOS, PSUB, LOGO, OCOVL and INST region. = 0.03/0.035/0.04/0.05/0.06/0.08/0.09-6um
 X0 = OR VARMOS PSUB LOGO INST OCOVL ESD_CLP_MARKS
 X1 = LENGTH GATE_LE == 0.03
 X2 = LENGTH GATE_LE == 0.035
 X3 = LENGTH GATE_LE == 0.04
 X4 = LENGTH GATE_LE == 0.05
 X5 = LENGTH GATE_LE == 0.06
 X6 = LENGTH GATE_LE == 0.08
 X7 = LENGTH GATE_LE >= 0.09 <= 6
 X8 = (((((X1 OR EDGE X2) OR EDGE X3) OR EDGE X4) OR EDGE X5) OR EDGE X6) OR EDGE X7
 (GATE_CORE NOT X0) NOT WITH EDGE X8
}

GT_6a {
@ Channel Length for 1.8V I/O NMOS/PMOS transistor.
@ This rule isn’t applicable for DGUD, DGV, ESDIO1, ESDIO2, ESDCLP, ESDPOB, CLPDMY, VARMOS region. ≥ 0.15um ≤ 6um
 X0 = OR DGUD DGV VARMOS ESD_CLP_MARKS
 X1 = LENGTH GATE_LE < 0.15
 X2 = LENGTH GATE_LE > 6
 (GATE_IOD NOT X0) WITH EDGE (X1 OR EDGE X2)
}

GT_6b {
@ Channel Length for 1.8V I/O NMOS/PMOS transistor (for 1.5V under drive).
@ This rule isn’t applicable for ESDIO1, ESDIO2, ESDCLP, ESDPOB, CLPDMY region. ≥ 0.11 um ≤ 6um
 X1 = LENGTH GATE_LE < 0.11
 X2 = LENGTH GATE_LE > 6
 ((GATE_IOD AND DGUD) NOT ESD_CLP_MARKS) WITH EDGE (X1 OR EDGE X2)
}

GT_6c {
@ Channel Length for 1.8V I/O NMOS/PMOS transistor (for 1.2V under drive).
@ This rule isn’t applicable for ESDIO1, ESDIO2, ESDCLP, ESDPOB, CLPDMY region. ≥ 0.11um ≤ 6um
 X1 = LENGTH GATE_LE < 0.11
 X2 = LENGTH GATE_LE > 6
 ((GATE_IOD AND DGV) NOT ESD_CLP_MARKS) WITH EDGE (X1 OR EDGE X2)
}

GT_7a {
@ Channel Length for 2.5V I/O NMOS/PMOS transistor.
@ This rule isn’t applicable for TGV, ESDIO1, ESDIO2, ESDCLP, ESDPOB, CLPDMY, VARMOS region.	≥ 0.27um ≤ 6um
 X0 = OR TGV VARMOS ESD_CLP_MARKS
 X1 = LENGTH GATE_LE < 0.27
 X2 = LENGTH GATE_LE > 6
 (GATE_IOT NOT X0) WITH EDGE (X1 OR EDGE X2)
}

GT_7b {
@ Channel Length for 2.5V I/O NMOS/PMOS transistor (for 1.8V under drive).
@ This rule isn’t applicable for ESDIO1, ESDIO2, ESDCLP, ESDPOB, CLPDMY region. ≥ 0.25um ≤ 6um
 X1 = LENGTH GATE_LE < 0.25
 X2 = LENGTH GATE_LE > 6
 ((GATE_IOT AND TGV) NOT ESD_CLP_MARKS) WITH EDGE (X1 OR EDGE X2)
}

GT_7c {
@ Channel Length for 2.5V I/O NMOS transistor (for 3.3V over drive).
@ This rule isn’t applicable for ESDIO1, ESDIO2, ESDCLP, ESDPOB, CLPDMY region. ≥ 0.55um ≤ 6um
 X1 = LENGTH GATE_LE < 0.55
 X2 = LENGTH GATE_LE > 6
 (((GATE_IOT AND SN) AND OVERDR) NOT ESD_CLP_MARKS) WITH EDGE (X1 OR EDGE X2)
}

GT_7d {
@ Channel Length for 2.5V I/O PMOS transistor (for 3.3V over drive).
@ This rule isn’t applicable for ESDIO1, ESDIO2, ESDCLP, ESDPOB, CLPDMY region. ≥ 0.44um ≤ 6um
 X1 = LENGTH GATE_LE < 0.44
 X2 = LENGTH GATE_LE > 6
 (((GATE_IOT AND SP) AND OVERDR) NOT ESD_CLP_MARKS) WITH EDGE (X1 OR EDGE X2)
}

GT_8a {
@ Width of 1st poly (or POLY_DMY) neighboring (GATE or (GTDMP AND (AA INTERACT poly))) (width = 0.03um) for core NMOS/PMOS.
@ 1st poly (or POLY_DMY) is must when the space between 1st poly (or POLY_DMY) and neighboring GATE or (GTDMP AND (AA INTERACT poly)) <0.23um.
@ The violation is allowed when the violation length is ≤0.08um.
@ This rule isn’t applicable for ESDIO1, ESDIO2,ESDCLP, ESDPOB, CLPDMY,OCCD and INST region.	=	0.03~0.04	um
 X0 = GATE_CORE WITH EDGE (LENGTH GATE_LE == 0.03)
 X1_1 = X0 NOT COIN EDGE GATE_LE
 X1_2 = (GTDMP WITH WIDTH == 0.03) INSIDE EDGE (AA INTERACT X0)
 X1 = X1_1 OR EDGE X1_2

 X2 = EXT X1 [GT_all] < 0.23 OPPOSITE EXCLUDE SHIELDED
 X3 = LENGTH (INT (X2) GT_all >= 0.03 <= 0.04 OPPOSITE) > 0.08
 X3_OUT = EXPAND EDGE X3 INSIDE BY 0.03

 X2_nopoly_1 = LENGTH (EXT (X1) GT_all < 0.23 OPPOSITE EXCLUDE SHIELDED) > 0.08
 X2_nopoly = EXPAND EDGE X2_nopoly_1 OUTSIDE BY 0.23

 OUT1 = ((X3_OUT OR X2_nopoly) NOT ESD_CLP) NOT INSIDE INST
 OUT1 NOT (OR OCCD MARKS)
}

GT_8b {
@ Width of 1st poly (or POLY_DMY) neighboring (GATE or (GTDMP AND (AA INTERACT poly))) (width = 0.035um) for core NMOS/PMOS.
@ 1st poly (or POLY_DMY) is must when the space between 1st poly (or POLY_DMY) and neighboring GATE or (GTDMP AND (AA INTERACT poly)) <0.23um.
@ The violation is allowed when the violation length is ≤0.08um.
@ This rule isn’t applicable for ESDIO1, ESDIO2, ESDCLP, ESDPOB, CLPDMY and INST region.	=	0.03~0.05	um
 X0 = GATE_CORE WITH EDGE (LENGTH GATE_LE == 0.035)
 X1_1 = X0 NOT COIN EDGE GATE_LE
 X1_2 = (GTDMP WITH WIDTH == 0.035) INSIDE EDGE (AA INTERACT X0)
 X1 = X1_1 OR EDGE X1_2

 X2 = EXT X1 [GT_all] < 0.23 OPPOSITE EXCLUDE SHIELDED
 X3 = LENGTH (INT (X2) GT_all >= 0.03 <= 0.05 OPPOSITE) > 0.08
 X3_OUT = EXPAND EDGE X3 INSIDE BY 0.03

 X2_nopoly_1 = LENGTH (EXT (X1) GT_all < 0.23 OPPOSITE EXCLUDE SHIELDED) > 0.08
 X2_nopoly = EXPAND EDGE X2_nopoly_1 OUTSIDE BY 0.23

 OUT1 = ((X3_OUT OR X2_nopoly) NOT ESD_CLP) NOT INSIDE INST
 OUT1 NOT MARKS 
}

GT_8c {
@ Width of 1st poly (or POLY_DMY) neighboring (GATE or (GTDMP AND (AA INTERACT poly))) (width = 0.04/0.045um) for core NMOS/PMOS.
@ 1st poly (or POLY_DMY) is must when the space between 1st poly (or POLY_DMY) and neighboring GATE or (GTDMP AND (AA INTERACT poly)) <0.23um.
@ The violation is allowed when the violation length is ≤0.08um.
@ This rule isn’t applicable for ESDIO1, ESDIO2, ESDCLP, ESDPOB, CLPDMY and INST region.	=	0.03~0.06	um
 X0 = GATE_CORE WITH EDGE ((LENGTH GATE_LE == 0.04) OR EDGE (LENGTH GATE_LE == 0.045))
 X1_1 = X0 NOT COIN EDGE GATE_LE
 X1_2 = ((GTDMP WITH WIDTH == 0.04) OR (GTDMP WITH WIDTH == 0.045))INSIDE EDGE (AA INTERACT X0)
 X1 = X1_1 OR EDGE X1_2

 X2 = EXT X1 [GT_all] < 0.23 OPPOSITE EXCLUDE SHIELDED
 X3 = LENGTH (INT (X2) GT_all >= 0.03 <= 0.06 OPPOSITE) > 0.08
 X3_OUT = EXPAND EDGE X3 INSIDE BY 0.03

 X2_nopoly_1 = LENGTH (EXT (X1) GT_all < 0.23 OPPOSITE EXCLUDE SHIELDED) > 0.08
 X2_nopoly = EXPAND EDGE X2_nopoly_1 OUTSIDE BY 0.23

 OUT1 = ((X3_OUT OR X2_nopoly) NOT ESD_CLP) NOT INSIDE INST
 OUT1 NOT MARKS 
}

GT_8d {
@ Width of 1st poly (or POLY_DMY) neighboring (GATE or (GTDMP AND (AA INTERACT poly))) (width ≥0.05um and ≤0.09 um) for core NMOS/PMOS.
@ 1st poly (or POLY_DMY) is must when the space between 1st poly (or POLY_DMY) and neighboring GATE or (GTDMP AND (AA INTERACT poly)) <0.23um, which excludes FUSEMK1 region. 
@ The violation is allowed when the violation length is ≤0.08um.
@ This rule isn’t applicable for ESDIO1, ESDIO2, ESDCLP, ESDPOB, CLPDMY, VARMOS and INST region.	=	0.04~0.09	um
 X0 = GATE_CORE WITH EDGE (LENGTH GATE_LE >= 0.05 <= 0.09)
 X1_1 = X0 NOT COIN EDGE GATE_LE
 X1_2 = (GTDMP WITH WIDTH >= 0.05 <= 0.09) INSIDE EDGE (AA INTERACT X0)
 X1 = X1_1 OR EDGE X1_2

 X2 = EXT X1 [GT_all] < 0.23 OPPOSITE EXCLUDE SHIELDED
 X3 = LENGTH (INT (X2) GT_all >= 0.04 <= 0.09 OPPOSITE) > 0.08
 X3_OUT = EXPAND EDGE X3 INSIDE BY 0.04

 X2_nopoly_1 = LENGTH (EXT (X1) GT_all < 0.23 OPPOSITE EXCLUDE SHIELDED) > 0.08
 X2_nopoly = EXPAND EDGE X2_nopoly_1 OUTSIDE BY 0.23
 
 OUT1 = ((X3_OUT OR (X2_nopoly NOT FUSEMK1)) NOT (ESD_CLP OR VARMOS)) NOT INSIDE INST
 OUT1 NOT MARKS 
}

GT_10 {
@ Space
@ This check doesn’t check POLY_JOG, INDMY region.	≥	0.08	um
  X = (GT_with_dummy NOT POLY_JOG) COIN EDGE GT_with_dummy
  Y1 = EXT X < 0.08 ABUT < 90 REGION

  Y2 = EXT GT_with_dummy < 0.001 ABUT < 90 SINGULAR REGION
  OUT1 = (Y1 OR Y2) NOT INSIDE INDMY
  OUT1 NOT MARKS 
}

GT_11 {
@ Space between poly inside DG/TG and poly.≥ 0.18um
  X = GT INSIDE DGTG
  OUT1 = EXT X GT < 0.18 ABUT < 90 SINGULAR REGION
  OUT1 NOT MARKS 
}
}

RULECHECK GT_12a {
@ Space between poly and (poly or POLY_DMY) if at least one (poly or POLY_DMY) width ≥ 0.03um, and ≤0.09um, and the parallel run length > 0.09um.
@ DRC doesn’t check INST region.	≥	0.100	um
 PRL2_two_width_PART GT_all GT_all 0.03 0.09 0.09 0.1
 OUTLAYER ((OUT3 INTERACT GT) NOT INSIDE INST) NOT MARKS 
}

RULECHECK GT_12b {
@ Space between poly and (poly or POLY_DMY) if at least one (poly or POLY_DMY) width >0.09um, and the parallel run length >0.09um.
@ DRC doesn’t check INST region	≥	0.120	um
 PRL2_one_width_PART GT_all GT_all 0.091 0.09 0.12
 OUTLAYER ((OUT3 INTERACT GT) NOT INSIDE INST) NOT MARKS
}


VERBATIM {
GT_13 {
@ At least one side space between (poly or POLY_DMY) and poly, when poly or POLY_DMY width <0.06um, and parallel run length of (poly or POLY_DMY) and two neighboring POLY_JOG >0um,
@    or the parallel run length of (poly or POLY_DMY) and  two neighboring poly line end >0um.
@ DRC only check:
@ 1. (poly or POLY_DMY) with width <0.06um is placed in between two neighboring POLY_JOG, the parallel run length of two POLY_JOG ≥ 0um.
@ 2. (poly or POLY_DMY) with width <0.06um is placed in between two neighboring poly line end( poly line end definition: poly width ≤  0.09um)	≥	0.1	um
  X = GT_all WITH WIDTH < 0.06
  Y = EXT [X] POLY_JOG < 0.1 OPPOSITE
  OUT1 = INT Y < 0.1 REGION OPPOSITE
  OUT1 NOT MARKS   

  H = CONVEX EDGE GT == 2 WITH LENGTH <= 0.09
  Y1 = EXT [X] H < 0.1 OPPOSITE
  OUT2 = INT Y1 < 0.1 OPPOSITE REGION
  OUT2 NOT MARKS 
}
}

RULECHECK GT_14 {
@ Space between horizontal (poly NOT INTERACT GTMK2) when
@ 1. at least one poly width>0.09um
@ 2. poly parallel run length >0.09um.
@ This rule doesn’t check rectangular (poly INTERCACT AA) NOT AA).	≥	0.15	um
SETLAYER W1 = GT NOT INTERACT GTMK2
SETLAYER W2 = RECTANGLE ((GT INTERACT AA) NOT AA)
SETLAYER W3 = W1 NOT W2
Mn_one_width_PART W3 0.091 0.09 0.15

SETLAYER W4 = W3 WITH WIDTH > 0.09
SETLAYER W5 = ANGLE W4 == 0
SETLAYER W6 = EXT W5 W3 < 0.15 OPPOSITE REGION
SETLAYER W7 = W6 WITH EDGE (PATH LENGTH (W6 COIN EDGE W4) > 0.09)

OUTLAYER ((OUT3 INTERACT W7) NOT W2) NOT MARKS
}


VERBATIM {
GT_16a {
@ Space between ((GATE sizing up 0.06um) AND poly) (channel length = 0.03um) and (neighboring ((poly or POLY_DMY) NOT POLY_JOG)) for core NMOS/PMOS.
@ Poly (or POLY_DMY) is must when the space between poly (or POLY_DMY) and neighboring GATE <0.23um.
@ The POLY_JOG E2=0.08um.(Pls refer to POLY_JOG definition in 7.1.13).  
@ This rule isn’t applicable for ESDIO1, ESDIO2, ESDCLP, ESDPOB, CLPDMY ,VARMOS,OCCD and INST region.	=	0.1/0.105/0.11	um
 GT_all_new = GT_all NOT POLY_JOG_GT_16

 X0 = LENGTH GATE_LE == 0.03
 X1 = GATE_CORE_SIZE_6 TOUCH EDGE ((GATE_CORE WITH EDGE X0) NOT COIN EDGE GATE_LE)
 X2_1 = EXT (X1) GT_all_new == 0.1 OPPOSITE
 X2_2 = EXT (X2_1) GT_all_new == 0.105 OPPOSITE
 X2 = EXT (X2_2) GT_all_new == 0.11 OPPOSITE

 OUT1 = (EXPAND EDGE X2 OUTSIDE BY 0.1) NOT (OR ESD_CLP VARMOS INST OCCD)
 OUT1 NOT MARKS 
}

GT_16b {
@ Space between ((GATE sizing up 0.06um) AND poly) (channel length = 0.035um) and (neighboring ((poly or POLY_DMY) NOT POLY_JOG)) for core NMOS/PMOS.
@ Poly (or POLY_DMY) is must when the space between poly (or POLY_DMY) and neighboring GATE <0.23um.
@ The POLY_JOG E2=0.08um.(Pls refer to POLY_JOG definition in 7.1.13).
@ This rule isn’t applicable for ESDIO1, ESDIO2, ESDCLP, ESDPOB, CLPDMY ,VARMOS and INST region.	=	0.1/0.105	um
 GT_all_new = GT_all NOT POLY_JOG_GT_16

 X0 = LENGTH GATE_LE == 0.035
 X1 = GATE_CORE_SIZE_6 TOUCH EDGE ((GATE_CORE WITH EDGE X0) NOT COIN EDGE GATE_LE)
 X2_1 = EXT (X1) GT_all_new == 0.1 OPPOSITE
 X2 = EXT (X2_1) GT_all_new == 0.105 OPPOSITE

 OUT1 = (EXPAND EDGE X2 OUTSIDE BY 0.1) NOT ((ESD_CLP OR VARMOS) OR INST)
 OUT1 NOT MARKS 
}

GT_16c {
@ Space between ((GATE sizing up 0.06um) AND poly) (0.04um ≤channel length ≤ 0.09um) and (neighboring ((poly or POLY_DMY) NOT POLY_JOG)) for core NMOS/PMOS.
@ Poly (or POLY_DMY) is must when the space between poly (or POLY_DMY) and neighboring GATE <0.23um.
@ The POLY_JOG E2=0.08um.(Pls refer to POLY_JOG definition in 7.1.13).
@ This rule isn’t applicable for ESDIO1, ESDIO2, ESDCLP, ESDPOB, CLPDMY, VARMOS, FUSEMK1 and INST region.	=	0.1	um
 GT_all_new = GT_all NOT POLY_JOG_GT_16

 X0 = LENGTH GATE_LE >= 0.04 <= 0.09
 X1 = GATE_CORE_SIZE_6 TOUCH EDGE ((GATE_CORE WITH EDGE X0) NOT COIN EDGE GATE_LE)
 X2 = EXT (X1) GT_all_new == 0.1 OPPOSITE

 OUT1 = (EXPAND EDGE X2 OUTSIDE BY 0.1) NOT (OR ESD_CLP VARMOS INST FUSEMK1)
 OUT1 NOT MARKS 
}

GT_16d {
@ Space between ((GATE sizing up 0.06um) AND poly) (channel length > 0.09um) and neighboring (poly or POLY_DMY) for core NMOS/PMOS.
@ Poly (or POLY_DMY) is must when the space between poly (or POLY_DMY) and neighboring GATE <0.23um.
@ This rule isn’t applicable for ESDIO1, ESDIO2, ESDCLP, ESDPOB, CLPDMY,VARMOS and INST region.	=	0.12	um
 GT_all_new = COPY GT_all

 X0 = LENGTH GATE_LE > 0.09
 X1 = GATE_CORE_SIZE_6 TOUCH EDGE ((GATE_CORE WITH EDGE X0) NOT COIN EDGE GATE_LE)
 X2 = EXT (X1) GT_all_new == 0.12 OPPOSITE
 OUT1 = (EXPAND EDGE X2 OUTSIDE BY 0.12) NOT ((ESD_CLP OR VARMOS) OR INST)
 OUT1 NOT MARKS 
}

GT_16e {
@ Space between ((GATE sizing up 0.06um) AND poly) and neighboring (poly or POLY_DMY) for core device in ESDIO1, ESDIO2, ESDCLP, ESDPOB, CLPDMY region.
@ Poly (or POLY_DMY) is must when the space between poly (or POLY_DMY) and neighboring GATE <0.23um.	≥	0.12	um
  X = GATE_CORE_SIZE_6 NOT OUTSIDE ESD_CLP
  OUT1 = EXT X GT_all < 0.12 ABUT < 90 SINGULAR REGION OPPOSITE
  OUT1 NOT MARKS 
}

GT_16f_R_DFM3 {
@ Space between ((GATE sizing up 0.06um) AND poly) and neighboring (poly or POLY_DMY) for I/O NMOS/PMOS.
@ Poly (or POLY_DMY) is must when the space between poly (or POLY_DMY) and neighboring GATE <0.51um.
@ This rule isn’t applicable for GATE in ESDIO1, ESDIO2,ESDCLP, ESDPOB, CLPDMY, LDBK and VARMOS region.	=	0.18	um
 R = OR ESD_CLP VARMOS LDBK

 X1 = GATE_IO_SIZE_6 TOUCH EDGE ((GATE_IO NOT R) NOT COIN EDGE GATE_LE)
 X2 = EXT (X1) (GT_all AND DGTG) == 0.18 OPPOSITE
 OUT1 = EXPAND EDGE X2 OUTSIDE BY 0.18
 OUT1 NOT MARKS 
}

GT_17 {
@ Space between 1st (poly or POLY_DMY) neighboring GATE (channel length = 0.03um/0.035um) and 2nd (poly or POLY_DMY) for core NMOS/PMOS. 
@ 2nd (poly or POLY_DMY) is must when the space between 2nd poly (or POLY_DMY) and neighboring GATE space =0.23um~0.28um.
@ The violation is allowed when the violation parallel length is ≤10% of neighboring GATE width.
@ The violation is allowed when the violation length is ≤0.08um.
@ This rule isn’t applicable for PSUB, VARMOS, ESDIO1, ESDIO2,ESDCLP, ESDPOB, CLPDMY, OCCD and INST region.	≥0.1um ≤ 0.15um
 X0_1 = LENGTH GATE_LE == 0.03
 X0_2 = LENGTH GATE_LE == 0.035
 X0 = X0_1 OR EDGE X0_2

 X1_0 = (GATE_CORE WITH EDGE X0) NOT COIN EDGE GATE_LE
 X3 = LENGTH (EXT (X1_0) GT_CORE >= 0.23 <= 0.28 OPPOSITE) > 0.08 

 X3_OUT1 = LENGTH (DFM PROPERTY X1_0 X3 OVERLAP ABUT ALSO MULTI [- = LENGTH(X3)/LENGTH(X1_0)] > 0.1) > 0.08
 X5 = EXPAND EDGE (X3 TOUCH EDGE (X3_OUT1 TOUCH EDGE Y1)) OUTSIDE BY 0.231
 X6 = CONVEX EDGE GT ANGLE1 == 270 ANGLE2 == 270 
 X7 = X5 WITH EDGE X6
 X3_OUT = (EXPAND EDGE (X3_OUT1 COIN EDGE X3) OUTSIDE BY 0.23) NOT X7

 Y1 = EXT [X1_0] GT_CORE >= 0.23 <= 0.28 OPPOSITE
 Y2_1 =  DFM PROPERTY X1_0 Y1 OVERLAP ABUT ALSO MULTI [- = LENGTH(Y1)/LENGTH(X1_0)] < 0.9  
 Y2_0 =  DFM PROPERTY X1_0 Y1 OVERLAP ABUT ALSO MULTI [- = LENGTH(Y1)/LENGTH(X1_0)] == 1
 Y2 = Y2_1 OR EDGE Y2_0
 Y3 = EXT Y2 [GT_CORE] >= 0.23 <= 0.28 OPPOSITE 

 X4 = LENGTH (EXT (Y3) GT_CORE >= 0.1 <= 0.15 OPPOSITE) > 0.08
 X4_OUT = EXPAND EDGE X4 OUTSIDE BY 0.15

 OUT1 = (X3_OUT OR X4_OUT) NOT INSIDE (OR ESD_CLP PSUB VARMOS OCCD INST)
 OUT1 NOT MARKS 
}

GT_20 {
@ Space between AA and poly (or POLY_DMY) on STI. ≥ 0.025um
@ DRC doesn’t check INST region.
 X0 = (GT_all NOT INSIDE INST) NOT INSIDE MARKS
 X1 = (X0 NOT AA_all) COIN EDGE X0
 Y = EXT [X1] AA < 0.025 ABUT < 90
 OUT1 = Y NOT INSIDE EDGE INST
 OUT1 NOT INSIDE EDGE MARKS
}
}

RULECHECK GT_21a {
@ Space between (((poly or POLY_DMY) NOT P2) INTERACT AA) and (((AA or AA_DMY) NOT INTERACT poly)) INTERACT CT), when width of (AA or AA_DMY) <0.07um,
@   and the parallel run length > 0.09um	≥	0.05	um
SETLAYER WW1 = ((GT or POLY_DMY) NOT P2) INTERACT AA
SETLAYER W2 = ((AA or AA_DMY) NOT INTERACT GT) INTERACT CT
SETLAYER W3 = W2 WITH WIDTH < 0.07
SETLAYER ERR = EXT WW1 W3 < 0.05 ABUT < 90 SINGULAR REGION OPPOSITE MEASURE ALL
OUTLAYER (ERR ENCLOSE RECTANGLE 0.091 0.001 ORTHOGONAL ONLY) NOT MARKS
}

RULECHECK GT_21b {
@ Space between (poly or POLY_DMY) and (AA or AA_DMY), when width of (AA or AA_DMY) <0.07um,and the parallel run length >0um and ≤ 0.09um.	≥	0.05	um
@ DRC doesn’t check INST region.
SETLAYER WW1 = GT or POLY_DMY
SETLAYER W2 = (AA or AA_DMY) NOT INSIDE INST
SETLAYER W3 = W2 WITH WIDTH < 0.07
SETLAYER ERR = EXT WW1 W3 < 0.05 ABUT < 90 SINGULAR REGION OPPOSITE MEASURE ALL
OUTLAYER ((ERR NOT ENCLOSE RECTANGLE 0.091 0.001 ORTHOGONAL ONLY) NOT INSIDE INST)  NOT MARKS
}

RULECHECK GT_21c {
@ Space between (poly or POLY_DMY) and AA, when
@ 1. Space between two (poly or POLY_DMY) > 0.27um;
@ 2. The parallel run length of (poly or POLY_DMY) and AA > 0.09um.
@ This rule isn’t applicable for ESDIO1, ESDIO2,ESDCLP, ESDPOB, CLPDMY region.	≥	0.035um
SETLAYER WW1 = (GT or POLY_DMY) NOT INSIDE ESD_CLP
PRL2_one_width_PART WW1 AA 0.03 0.09 0.035

SETLAYER W4 = WW1 COIN EDGE OUT3
SETLAYER W5 = W4 COIN EDGE (DFM SPACE \[W4\] WW1 <= 0.27 BY EXT)
OUTLAYER ((OUT3 NOT WITH EDGE W5) NOT ESD_CLP) NOT MARKS
}

RULECHECK GT_21d {
@ Space between poly and (AA or AA_DMY), when
@ 1. Space between poly and (poly or POLY_DMY) > 0.27um;
@ 2. The parallel run length of poly and (AA or AA_DMY) > 0.09um.
@ This rule isn’t applicable for ESDIO1, ESDIO2,ESDCLP, ESDPOB, CLPDMY region.	≥	0.035	um
SETLAYER WW1 = (AA or AA_DMY) NOT INSIDE ESD_CLP
PRL2_one_width_PART WW1 GT 0.04 0.09 0.035

SETLAYER W4 = GT COIN EDGE OUT3
SETLAYER W5 = W4 COIN EDGE (DFM SPACE \[W4\] GT_all <= 0.27 BY EXT)
OUTLAYER ((OUT3 NOT WITH EDGE W5) NOT ESD_CLP) NOT MARKS
}


VERBATIM {
GT_22 {
@ Space between (AA INTERACT CT) and ((poly NOT P2) INTERCACT CT) , when
@ 1. The parallel runlength >0um;
@ 2. AA width ≥0.07um and <0.1um;  
@ 3. (Poly NOT P2) extension outside of CT <0.08um in opposite AA site;
@ 3. AA and poly are at different net.
@ DRC doesn’t check:
@ 1.INST region;
@ 2.The edge L1 with length≤ 0.275um, which L1 is opposite to ((poly NOT P2) INTERCACT CT), and L1 and its adjencent edge formed
@  one inner vertex 270 degree angle A, and AA width = 0.07um which formed by L1 and its opposite edge L2.
@ 3 The space between poly line-end (poly edge length < 0.04um) and  AA.
  X0 = X_temp1 OR Y
  X1 = CONVEX EDGE X0 ANGLE1 == 270 ANGLE2 == 270 WITH LENGTH < 0.04 
  X2 = EXT X1 [X_temp1] < 0.001 ABUT == 90 INTERSECTING ONLY  
  X3 = X_temp1 TOUCH EDGE X2  
  X4 = LENGTH (EXT [X3] Y < 0.04 OPPOSITE ABUT< 90) < 0.275  
  X5 = INT X4 [X_temp1] == 0.07 ABUT<90 OPPOSITE

  X_temp1 = AA INTERACT CT 
  X_temp2 = (X_temp1 NOT COIN EDGE X4) NOT COIN EDGE X5
  X = (X_temp1 WITH WIDTH >= 0.07 < 0.1) COIN EDGE X_temp2

  Y = (GT NOT P2) INTERACT CT
  Y0 = EXT X [Y] < 0.04 ABUT < 90 OPPOSITE
  Z = ENC CT [Y0] < 0.08 ABUT < 90  OPPOSITE
  H =  (Y0 TOUCH EDGE Z) NOT COIN EDGE (LENGTH GT < 0.04)
  M = STAMP GT_real BY GT_raw
 ((EXT (M COIN EDGE H) (PTAP COIN EDGE X) < 0.04 ABUT < 90 REGION NOT CONNECTED) NOT INSIDE INST) NOT MARKS
 ((EXT (M COIN EDGE H) (NTAP COIN EDGE X) < 0.04 ABUT < 90 REGION NOT CONNECTED) NOT INSIDE INST) NOT MARKS
 ((EXT (M COIN EDGE H) (PSD COIN EDGE X) < 0.04 ABUT < 90 REGION NOT CONNECTED) NOT INSIDE INST) NOT MARKS
 ((EXT (M COIN EDGE H) (NSD COIN EDGE X) < 0.04 ABUT < 90 REGION NOT CONNECTED) NOT INSIDE INST) NOT MARKS
 }

GT_23a {
@ Space between L-shape or U-shape poly and AA when poly and AA in the same MOS, when L shape poly length (L) ≤ 0.03um.	≥	0.035	um
@ DRC doesn’t check INST region.
 GT_AA = GT OR AA
 GT_AA_L = CONVEX EDGE GT_AA ANGLE1 == 270 ANGLE2 == 270 WITH LENGTH < 0.035
 GT_L = (GT_AA_L COIN EDGE GT) NOT COIN EDGE (CONVEX EDGE GT == 0)
 X0 = EXPAND EDGE GT_L INSIDE BY 0.005
 Y = EXT GT < 0.005 ABUT REGION

 Z = GT TOUCH EDGE ((Y WITH EDGE GT_L) NOT COIN EDGE GT_L)
 H = LENGTH Z <= 0.03
 P = EXPAND EDGE H OUTSIDE BY 0.005
 Q = Y INTERACT P
 W = (X0 TOUCH GATE) INTERACT Q
 OUT1 = W NOT INSIDE INST
 OUT1 NOT MARKS 
}

GT_23b {
@ Space between L-shape poly and AA when poly and AA in the same MOS, when L shape poly length (L) >0.03um and ≤ 0.07um.	≥	0.07	um
 GT_AA = GT OR AA
 GT_AA_L = CONVEX EDGE GT_AA ANGLE1 == 270 ANGLE2 == 270 WITH LENGTH < 0.07
 GT_L = (GT_AA_L COIN EDGE GT) NOT COIN EDGE (CONVEX EDGE GT == 0)
 X0 = EXPAND EDGE GT_L INSIDE BY 0.005
 Y = EXT GT < 0.005 ABUT REGION

 Z = GT TOUCH EDGE ((Y WITH EDGE GT_L) NOT COIN EDGE GT_L)
 H = LENGTH Z > 0.03 <= 0.07
 P = EXPAND EDGE H OUTSIDE BY 0.005
 Q = Y INTERACT P
 OUT1 = (X0 TOUCH GATE) INTERACT Q
 OUT1 NOT MARKS 
}

LAYER MAP 999 DATATYPE 1112 4322
LAYER EMPTY2 4322
GT_EMPTY_WHOLE = EMPTY2 OR GT
GT_all_EMPTY_WHOLE = EMPTY2 OR GT_all
AA_EMPTY2 = EMPTY2 OR AA
CONNECT GT_EMPTY_WHOLE AA_EMPTY2
CONNECT GT_all_EMPTY_WHOLE AA_EMPTY2
GT_24 {
@ Space between L-shape poly and (AA AND CT) when poly and AA in the same MOS, when L shape poly length (L) ≤ 0.03um.	≥	0.065	um
@ DRC doesn’t check INST region.
 GT_AA = (GT OR AA) NOT INSIDE INST
 GT_AA_L = CONVEX EDGE GT_AA ANGLE1 == 270 ANGLE2 == 270
 GT_L = (GT_AA_L COIN EDGE GT) NOT COIN EDGE (CONVEX EDGE GT == 0)
 X0 = EXPAND EDGE GT_L INSIDE BY 0.005
 Y = EXT GT < 0.005 ABUT REGION

 Z = GT TOUCH EDGE ((Y WITH EDGE GT_L) NOT COIN EDGE GT_L)
 H = LENGTH Z <= 0.03
 W = EXT (GT_EMPTY_WHOLE COIN EDGE H) (AA_EMPTY2 AND CT) < 0.065 ABUT < 90 REGION CONNECTED
 OUT1 = W NOT INSIDE INST
 OUT1 NOT MARKS 
}

GT_25 {
@ Space between POLY_JOG.
@ DRC only check the space is  opposite  to POLY_JOG E2 direction. (Pls refer to POLY_JOG definition in 7.1.13)	≥	0.1	um
  OUT1 = EXT POLY_JOG_EDGE < 0.1 ABUT < 90 REGION
  OUT1 NOT MARKS 
}

GT_26 {
@ Space between POLY_JOG and (poly or GTDMP or GTDOP)	≥	0.07	um
  OUT1 = EXT POLY_JOG GT_all_3 < 0.07 ABUT < 90 SINGULAR REGION
  OUT1 NOT MARKS 
}

GT_27 {
@ Space between (poly or POLY_DMY) and ((poly or POLY_DMY) AND SAB)	≥	0.18	um
@ DRC doesn’t check INDMY region.
 OUT1 = EXT GT_all (GT_all AND SAB) < 0.18 ABUT < 90 SINGULAR REGION
 OUT2 = OUT1 NOT INDMY
 OUT2 NOT MARKS
}
}

RULECHECK GT_28 {
@ Space between (poly NOT P2) and ((AA INTERACT CT) NOT INSIDE (DG OR TG)), which poly connects to (1.2V or 1.5V or 1.8V or 2.5V or 3.3V) net.
@ DRC doesn’t check EFUSE region.
@ DRC check follows metal voltage marking layer for (1.2V or 1.5V or 1.8V or 2.5V or 3.3V) net.≥	0.065	um

  for { set j 1 } { $j <= [llength $inter_metal_list_with_name_mapping] } { incr j } {

SETLAYER X$j = NET AREA RATIO M1 (M$j INTERACT (OR M${j}V12 M${j}V15 M${j}V18 M${j}V25 M${j}V33)) > 0
    
   lappend GT_28_list X$j
 }
SETLAYER Y0 = STAMP GT_real BY GT_raw
SETLAYER Y1 = OR $GT_28_list
SETLAYER Y2 = M1 AND Y1
SETLAYER Y3 = NET AREA RATIO Y0 Y2 > 0
OUTLAYER ((EXT Y3 ((AA INTERACT CT) NOT INSIDE DGTG) < 0.065 ABUT < 90 SINGULAR REGION) NOT EFUSE) NOT MARKS 
}

VERBATIM {
LAYER MAP 999 DATATYPE 1111 4321
LAYER EMPTY 4321
GT_EMPTY = EMPTY OR (GT AND AA)
GT_all_EMPTY = EMPTY OR (GT_all AND AA)
AA_EMPTY = EMPTY OR AA
CONNECT GT_EMPTY AA_EMPTY
CONNECT GT_all_EMPTY AA_EMPTY

GT_29a {
@ Extension of AA outside of (poly or POLY_DMY) for core device with channel length ≤ 0.09um. 
@ This rule isn’t applicable for ESDIO1, ESDIO2, ESDCLP, ESDPOB, CLPDMY, EFUSE, OCCD and INST region. = 0.075/0.08/0.085um
 X0 = LENGTH GATE_LE <= 0.09
 X1 = GATE_CORE WITH EDGE X0
 X2 = AA INTERACT X1
 X3 = GT_all AND X2
 X30 = (X2 NOT X3) INTERACT X3 >1
 X4 = X30 OR X3
 //X4 = (EXT X3 <= 1 OPPOSITE REGION CONNECTED) OR X3
 X5 = (X3 NOT INSIDE EDGE X4) NOT TOUCH EDGE AA
 X6 = ENC (X5) X2 == 0.075 OPPOSITE 
 X7 = ENC (X6) X2 == 0.08 OPPOSITE
 X8 = ENC (X7) X2 == 0.085 OPPOSITE
 X9 = X2 COIN EDGE GT_all

 OUT1 = (X8 OR EDGE X9) NOT INSIDE EDGE (OR ESD_CLP EFUSE OCCD INST)
 OUT1 NOT INSIDE EDGE MARKS  
}

GT_29a_R_DFM3 {
@ Extension of AA outside of (poly INTERACT CT) for core device with channel length ≤ 0.09um. 
@ This rule isn’t applicable for PSUB, VARMOS, ESDIO1, ESDIO2,ESDCLP, ESDPOB, CLPDMY, EFUSE,OCCD and INST region.	≥	0.205um
 X0 = LENGTH GATE_LE <= 0.09
 X1 = GATE_CORE WITH EDGE X0
 X2 = AA INTERACT X1
 X3 = ENC (GT INTERACT CT) X2 < 0.205 ABUT < 90 SINGULAR REGION
 OUT1 = X3 NOT INSIDE (OR PSUB VARMOS ESD_CLP EFUSE OCCD INST)
 OUT1 NOT MARKS 
}

GT_29b {
@ Extension of AA outside of (poly or POLY_DMY) for core device with channel length > 0.09um. 
@ This rule isn’t applicable for ESDIO1, ESDIO2,ESDCLP,ESDPOB,CLPDMY, VARMOS,OCCD region.	=	0.095	um
 X0 = LENGTH GATE_LE > 0.09
 X1 = GATE_CORE WITH EDGE X0
 X2 = AA INTERACT X1
 X3 = GT_all AND X2
 X30 = (X2 NOT X3) INTERACT X3 >1
 X4 = X30 OR X3
 //X4 = (EXT X3 <= 1 OPPOSITE REGION CONNECTED) OR X3
 X5 = (X3 NOT INSIDE EDGE X4) NOT TOUCH EDGE AA
 X6 = ENC (X5) X2 == 0.095 OPPOSITE 
 X7 = X2 COIN EDGE GT_all

 OUT1 = (X6 OR EDGE X7) NOT INSIDE EDGE (OR ESD_CLP VARMOS OCCD)
 OUT1 NOT INSIDE EDGE MARKS 
}

GT_29c {
@ Extension of AA outside of (poly or POLY_DMY) for core device in ESDIO1, ESDIO2,ESDCLP,ESDPOB,CLPDMY region.	≥	0.095	um
 X0 = GT_CORE INTERACT ESD_CLP
 X = ENC X0 AA < 0.095 ABUT < 90 SINGULAR REGION
 OUT1 = X AND ESD_CLP
 OUT1 NOT MARKS 
}

GT_30a {
@ Extension of AA outside of (poly or POLY_DMY) for I/O device region.
@ This rule isn’t applicable for LDMOS drain site region.	≥	0.155	um
 X = ENC (GT_all AND DGTG) AA < 0.155 ABUT < 90 SINGULAR REGION
 OUT1 = X NOT ((AA NOT GATE_LD) TOUCH STI)
 OUT1 NOT MARKS 
}

GT_30a_R_DFM3 {
@ Extension of AA outside of (poly or POLY_DMY) for I/O device region.
@ This rule isn’t applicable for ESDIO1, ESDIO2, ESDCLP, ESDPOB,CLPDMY, VARMOS, LDMOS drain site region.	=	0.155	um
 X1 = ((AA AND GT_all) AND (DG OR TG)) NOT ESDIO2
 X2 = AA INTERACT X1
 X3 = GT_all AND X2
 X4 = (GT_all INTERACT X3) NOT OUTSIDE EDGE X2
 X5 = X3 COIN EDGE ((X2 NOT GT_all) TOUCH GT_all == 1)
 X6 = ENC (X5) X2 == 0.155 ABUT<90 OPPOSITE
 X7 = X2 COIN EDGE GT_all
 OUT1 = (X6 OR EDGE X7) NOT INSIDE EDGE (ESD_CLP OR (VARMOS OR ((AA NOT GATE_LD) TOUCH STI)))
 OUT1 NOT INSIDE EDGE MARKS
}

GT_30b {
@ Extension of AA outside of (poly or POLY_DMY) for I/O device in ESDIO1, ESDIO2, ESDCLP, ESDPOB,CLPDMY region.	≥	0.155	um
 X0 = (GT_all AND DGTG) INTERACT ESD_CLP
 X = ENC X0 AA < 0.155 ABUT < 90 SINGULAR REGION
 OUT1 = X AND ESD_CLP
 OUT1 NOT MARKS 
}

GT_31 {
@ Extension of poly outside of AA along channel width direction. 
@ This rule isn’t applicable for INDMY, LOGO and INST region.	≥	0.08
  X = ENC (AA TOUCH EDGE GATE_LE) GT < 0.08 ABUT < 90  REGION
  OUT1 = X NOT (OR INDMY LOGO INST)
  OUT1 NOT MARKS 
}

/*
GT_32 {
@ (The projection of ((poly OR POLY_DMY) on STI) on neighboring GATE poly) extension outside of AA.
@ DRC check for core device: the space <0.23um between ((poly OR POLY_DMY) on STI) and ((poly or GTDMP) AND AA) which is nearest to AA edge.
@ DRC check for IO device: the space <0.51um between ((poly OR POLY_DMY) on STI) and ((poly or GTDMP) AND AA) which is nearest to AA edge.
@ DRC doesn’t check DG,TG, LDBK region.	≥	0.06	um
 AA_S = AA INTERACT GATE

 X = (GT_all AND AA_S) AND DGTG
 Y = (AA_S NOT X) TOUCH X == 1
 Z = GT_all COIN EDGE Y
 H = GT_all NOT AA
 P = DFM SPACE Z [H] < 0.51 BY EXT BY LAYER H
 Q = EXPAND EDGE P INSIDE BY 0.005 EXTEND BY 0.06
 OUT1 = (Q NOT INSIDE GT_all) NOT (DGTG OR LDBK)
 OUT1 NOT MARKS 

 X1 = (GT_all AND AA_S) NOT DGTG
 Y1 = (AA_S NOT X1) TOUCH X1 == 1
 Z1 = GT_all COIN EDGE Y1
 H1 = GT_all NOT AA
 P1 = DFM SPACE Z1 [H1] < 0.23 BY EXT BY LAYER H1
 Q1 = EXPAND EDGE P1 INSIDE BY 0.005 EXTEND BY 0.06
OUT2 = (Q1 NOT INSIDE GT_all) NOT (DGTG OR LDBK)
OUT2 NOT MARKS 
}
*/

GT_33 {
@ Extension of poly outside of AA when the poly to L-shape AA (in same MOS) space <0.1um.	≥	0.095	um
@ DRC doesn’t check INST region.
 X = EXT (AA INTERACT GATE) < 0.001 ABUT REGION
 L = ENC GT AA < 0.001 ABUT == 90 REGION
 M = ((AA NOT GT) TOUCH EDGE X) TOUCH EDGE L
 N = ((AA NOT GT) TOUCH EDGE X) NOT TOUCH EDGE L
 H = LENGTH M < 0.1
 P = EXPAND EDGE H INSIDE BY 0.001 EXTEND BY 0.001
 Q = AA NOT OUTSIDE EDGE GT
 W = Q COIN EDGE P
 R = ENC W GT < 0.095 ABUT < 90 REGION OPPOSITE
 OUT1 = R NOT INSIDE INST
 OUT1 NOT MARKS 
}

GT_34_l {
@ ((Poly or POLY_DMY) NOT P2) density in full chip. ≥ 15% and ≤ 40%
 X = GT_real_all NOT MARKS 
 Y = DRC:1 NOT MARKS
 DENSITY X Y [AREA(X)/AREA(Y)] < 0.15  PRINT density_report_GT_34_l.log RDB density_report_GT_34_l.rdb
}

GT_34_h {
@ ((Poly or POLY_DMY) NOT P2) density in full chip. ≥ 15% and ≤ 40%
 X = GT_real_all NOT MARKS 
 Y = DRC:1 NOT MARKS
 DENSITY X Y [AREA(X)/AREA(Y)] > 0.4  PRINT density_report_GT_34_h.log RDB density_report_GT_34_h.rdb
}

GT_35_l {
@ ((Poly or POLY_DMY) NOT P2) density. Density check window: Window size: 20um*20um, step size: 10um.
@ For low density , DRC don’t check:
@ 1. RESAA, DSTR, and BIPOLA.
@ 2. Chip corner triangle region (NODMF) sizing up 0.4um if seal ring is added by SMIC.
@ 3. Seal ring (MARKS) sizing up 0.4um if seal ring is added by customer.
@ For high density, DRC doesn’t flag violation when all channel length>0.06um device in check window. ≥10% ≤ 65%
 X = SIZE NODMF BY 0.4
 Y = SIZE MARKS BY 0.4
 Z = OR Y X RESAA DSTR BIPOLA
 X0 = GT_real_all NOT Z 
 Y0 = DRC:1  NOT Z
 DENSITY  X0 Y0 [AREA(X0)/AREA(Y0)]  < 0.1 WINDOW 20 STEP 10 BACKUP PRINT density_report_GT_35_l.log RDB density_report_GT_35_l.rdb
}

GT_35_h {
@ ((Poly or POLY_DMY) NOT P2) density. Density check window: Window size: 20um*20um, step size: 10um.
@ For low density , DRC don’t check:
@ 1. RESAA, DSTR, and BIPOLA.
@ 2. Chip corner triangle region (NODMF) sizing up 0.4um if seal ring is added by SMIC.
@ 3. Seal ring (MARKS) sizing up 0.4um if seal ring is added by customer.
@ For high density, DRC doesn’t flag violation when all channel length>0.06um device in check window. ≥10% ≤ 65%
  X0 = GT_real_all NOT MARKS 
  Y0 = DRC:1 NOT MARKS
  T1 = GATE NOT WITH EDGE (LENGTH GATE_LE > 0.06)
  DENSITY X0 Y0 T1 > 0.65 WINDOW 20 STEP 10 BACKUP PRINT density_report_GT_35_h.log
     [ (!!area(T1)) *area(X0) / area(Y0) ] RDB density_report_GT_35_h.rdb
}
			
GT_36 {
@ ((Poly or POLY_DMY) NOT P2)) density inside of the dummy block area(DUMBP).Density check window size: 10um*10um, step size: 5um
@ DRC need check the design if DUMBP width is >3um and <10um, where density ratio= ((poly or POLY_DMY) NOT P2) area/DUMBP area.
@ This rule doesn’t check MOMDMY and OCOVL region. ≥ 10%
  X0 = ENCLOSE RECTANGLE DUMBP 10 10 ORTHOGONAL ONLY
  X = (X0 NOT MOMDMY) NOT OCOVL 
  X1 = ((GT_real_all NOT MOMDMY) NOT OCOVL) NOT MARKS
  Y1 = X NOT MARKS 
  DENSITY X1 Y1 [AREA(X1)/AREA(Y1)] < 0.10 WINDOW 10 STEP 5 BACKUP PRINT density_report_GT_36_l.log RDB density_report_GT_36_1.rdb

  Y0 = (ENCLOSE RECTANGLE DUMBP 3.001 3.001 ORTHOGONAL ONLY) NOT X 
  Y = ((Y0 NOT MOMDMY) NOT OCOVL) NOT MARKS 
  Z = DFM PROPERTY Y X1 [ RATIO = AREA(X1)/AREA(Y) ] < 0.1
  DFM RDB Z density_report_GT_36_2.rdb
  COPY Z
}

GT_37 {
@ Rectangular poly length. ≥ 0.26um
  OUT1 = RECTANGLE GT_with_dummy < 0.26 BY < 0.26
  OUT1 NOT MARKS 
}

GT_39a {
@ (Poly NOT P2) length between two CTs(the two CTs on same poly), when poly width <0.06um.
@ This rule isn’t applicable for ESDIO1, ESDIO2, ESDCLP, ESDPOB,CLPDMY, RESP1 and (poly INTERACT MOMDMY) region.	≤	18	um
 GT_real_0 = GT_real WITH WIDTH < 0.06
 GT_real_1 = (GT_real_0 NOT INTERACT MOMDMY) NOT (OR ESDIO1 ESDIO2 ESDCLP ESDPOB CLPDMY RESP1)

 Z0 = SIZE CT BY 9 INSIDE OF GT_real_1 STEP 0.04
 Z1 = Z0 INTERACT CT < 2
 Z2 = (GT_real_1 INTERACT Z1) NOT (GT_real_1 INTERACT CT == 1)
 Z2 NOT MARKS
}

GT_39b {
@ The length from the any point inside poly GATE to (the nearest CT on GATE poly) (without P2 between GATE and CT), when poly width <0.06um.
@ This rule isn’t applicable for ESDIO1, ESDIO2, ESDCLP, ESDPOB,CLPDMY and (poly INTERACT MOMDMY) region.	≤	18	um
 GT_real_1 = (WITH WIDTH GT_real < 0.06) NOT INTERACT MOMDMY
 X = GATE WITH EDGE (LENGTH GATE_LE < 0.06)
 Y = (GT_real_1 ENCLOSE X) INTERACT CT
 Z0 = SIZE CT BY 18 INSIDE OF Y STEP 0.04
 Z1 = ((X INSIDE Y) NOT INSIDE Z0) NOT INTERACT (CT NOT OUTSIDE GT)
 Z1 NOT (ESD_CLP_MARKS OR MOMDMY)
}

GT_40 {
@ Poly area.
@ DRC doesn't check rectangle (poly INTERACT AA) with length ≥ 0.32 um	≥	0.0115	um2
  GT_ignore = RECTANGLE (GT INTERACT AA) >= 0.32
  OUT1 = AREA (GT_with_dummy NOT GT_ignore) < 0.0115
  OUT1 NOT MARKS
}

GT_41 {
@ Poly enclosed area	≥	0.02	um2
  X = (HOLES GT_with_dummy INNER) NOT GT_with_dummy
  OUT1 = AREA X < 0.02
  OUT1 NOT MARKS
}

GT_42 {
@ Only axes of poly geometry at 0-degree (X), 90-degree (Y) are allowed, 45-degree poly is not allowed. 
@ This rule doesn’t check NODMF, EFUSE, LOGO and INDMY region.
  X = ANGLE GT_all > 0 < 90
  OUT1 = X NOT INSIDE EDGE (OR NODMF EFUSE LOGO INDMY)
  OUT1 NOT INSIDE EDGE MARKS
}

GT_43_R_DFM3 {
@ O-shape poly is not allowed, except the LOGO area.
@ DRC doesn’t check INST region.
  OUT1 = (GT_OS NOT LOGO) NOT INSIDE INST
  OUT1 NOT MARKS
}
	
GT_45_R_DFM3 {
@ ((Poly NOT P2) NOT INSIDE (DG OR TG)) must be rectangle.
@ This rule doesn’t check NODMF, EFUSE, LOGO and INST region.
  X = (GT NOT P2) NOT INSIDE DGTG
  Y = NOT RECTANGLE X
  OUT1 = Y NOT (((NODMF OR EFUSE) OR LOGO) OR INST)
  OUT1 NOT MARKS
}

GT_46_R_DFM3 {
@ ((((Poly NOT P2) OUTSIDE (DG OR TG)) INTERACT AA)) must be rectangle.
@ DRC doesn’t check INST region.
  X = ((GT NOT P2) OUTSIDE DGTG) INTERACT AA
  W = NOT RECTANGLE X
  OUT1 = W NOT INSIDE INST
  OUT1 NOT MARKS 
}

GT_47 {
@ Floating ((poly NOT P2) NOT INTERACT CT) must be a rectangle
@ DRC doesn’t check INST, EFUSE and LOGO region, and doesn’t check the poly with width ≥ 0.15um.
  X = (GT NOT P2) NOT INTERACT CT
  W = (NOT RECTANGLE X) NOT (GT WITH WIDTH >= 0.15)
  OUT1 = (W NOT INSIDE INST) NOT (OR EFUSE LOGO)
  OUT1 NOT MARKS 
}

GT_48 {
@ GATE of core device must be in vertical direction.
@ This rule doesn’t check VARMOS, LOGO, NODMF, GTMK2 region.
  X = ANGLE GATE_LE != 0
  Y = GATE_CORE WITH EDGE X
  OUT1 = Y NOT (((VARMOS OR LOGO) OR NODMF) OR GTMK2)
  OUT1 NOT MARKS 
}

GT_49_R_DFM3 {
@ In core device region, rectangle (poly NOT INTERACT AA) must be vertical, which is same as GATE poly direction.
@ This rule doesn’t check BIPOLA, DSTR, LOGO, and square pattern.
  X = (GT NOT INTERACT AA) NOT INSIDE DGTG
  Y = RECTANGLE X ASPECT >1
  Z = DFM COPY (ANGLE Y == 90)
  H = DFM COPY (ANGLE Y == 0)
  J = DFM PROPERTY Y Z H OVERLAP ABUT ALSO MULTI [ - = LENGTH(Z) - LENGTH(H) ] < 0
  W = Y WITH EDGE (J NOT INSIDE EDGE DGTG)
  OUT1 = W NOT ((BIPOLA OR DSTR) OR LOGO)
  OUT1 NOT MARKS
}

GT_50 {
@ (Poly or POLY_DMY) width on same AA must be same for core device region with channel length=0.03um. 
@ DRC doesn’t check ESDIO1, ESDIO2, ESDCLP, ESDPOB,CLPDMY,OCCD and INST regions.
 X1 = GATE_CORE WITH EDGE (LENGTH GATE_LE == 0.03)
 X2 = AA INTERACT X1
 X4_1 = X2 INSIDE EDGE GT_all
 X4_2 = INT X4_1 < 0.005 ABUT REGION
 X4 = X4_1 NOT TOUCH EDGE X4_2
 X5 = DFM PROPERTY X2 X4 OVERLAP ABUT ALSO MULTI
  [ X = MAX(LENGTH(X4))/MIN(LENGTH(X4)) ] != 1
 X5 NOT (OR ESD_CLP_MARKS INST OCCD)
}

GT_51_R_DFM3 {
@ Recommended poly width on same AA must be same for core device with channel length≥0.15um. 
@ DRC doesn’t check ESDIO1, ESDIO2, ESDCLP, ESDPOB,CLPDMY and INST regions.
 X1 = GATE_CORE WITH EDGE (LENGTH GATE_LE >= 0.15)
 X2 = AA INTERACT X1
 X4_1 = X2 INSIDE EDGE GT
 X4_2 = INT X4_1 < 0.005 ABUT REGION
 X4 = X4_1 NOT TOUCH EDGE X4_2
 X5 = DFM PROPERTY X2 X4 OVERLAP ABUT ALSO MULTI
  [ X = MAX(LENGTH(X4))/MIN(LENGTH(X4)) ] != 1
 X5 NOT (ESD_CLP_MARKS OR INST)
}

GT_52 {
@ Space between ((poly and (poly or POLY_DMY)) on same AA must be same for channel length =0.03/0.035um core device.
@ DRC doesn’t check PSUB, ESDIO1, ESDIO2, ESDCLP, ESDPOB, CLPDMY, INST, OCCD and VARMOS region.
 X1 = GATE_CORE WITH EDGE (OR EDGE (LENGTH GATE_LE == 0.03) (LENGTH GATE_LE == 0.035))
 X2 = (AA INTERACT X1) NOT (OR PSUB OCCD VARMOS ESD_CLP_MARKS)
 X4 = X2 INSIDE EDGE GT_all
 SD_tmp = (X2 NOT GT_all) TOUCH (AA AND GT_all) == 2
 SD_rec = SD_tmp INTERACT (RECTANGLE AA)
 SD_spe = SD_tmp NOT SD_rec
 GT_tmp_1 = SD_rec NOT TOUCH EDGE GT_all
 GT_tmp_2 = INT (SD_spe COIN EDGE GT_all) < 10 OPPOSITE
 
 space_chk_x = DFM PROPERTY X2 GT_tmp_1 X4 OVERLAP ABUT ALSO
               [y = MIN(LENGTHXP(X4)) ] > 0
               [x = max(length(GT_tmp_1))/min(length(GT_tmp_1)) ] != 1
 space_chk_x NOT INSIDE INST

 space_chk_y = DFM PROPERTY X2 GT_tmp_2 X4 OVERLAP ABUT ALSO
               [y = MIN(LENGTHXP(X4)) ] > 0  
               [x = max (EW(GT_tmp_2))/min (EW(GT_tmp_2)) ] != 1
 space_chk_y NOT INSIDE INST
}

/*
GT_52_20140924 {
@ Space between ((poly and (poly or POLY_DMY))  on same AA must be same for channel length =0.03/0.035um core device.
@ DRC doesn’t check PSUB, ESDIO1, ESDIO2, ESDCLP, ESDPOB, CLPDMY, INST, OCCD and VARMOS region.
 X1 = GATE_CORE WITH EDGE (OR EDGE (LENGTH GATE_LE == 0.03) (LENGTH GATE_LE == 0.035))
 X2 = AA INTERACT X1
 X4 = X2 INSIDE EDGE GT_all
 SD_tmp = ((AA INTERACT GATE) NOT GT_all) TOUCH (AA AND GT_all) == 2
 GT_tmp = INT (SD_tmp COIN EDGE GT_all) < 10 OPPOSITE    
 
 space_chk_y = DFM PROPERTY AA GT_tmp X4 OVERLAP ABUT ALSO
               [y = MIN(LENGTHXP(X4)) ] > 0  
               [x = max (EW(GT_tmp))/min (EW(GT_tmp)) ] != 1

 OUT1 = (space_chk_y NOT (OR PSUB ESD_CLP OCCD VARMOS)) NOT INSIDE INST
 OUT1 NOT MARKS
}

GT_52_T2 {
@ Space between ((poly and (poly or POLY_DMY)) on same AA must be same for channel length =0.03/0.035um core device.
@ DRC doesn’t check PSUB, ESDIO1, ESDIO2, ESDCLP, ESDPOB, CLPDMY, INST, OCCD and VARMOS region.
 X1 = GATE_CORE WITH EDGE (OR EDGE (LENGTH GATE_LE == 0.03) (LENGTH GATE_LE == 0.035))
 X2 = (AA INTERACT X1) NOT (OR PSUB OCCD VARMOS ESD_CLP_MARKS)
 X4 = X2 INSIDE EDGE GT_all
 SD_tmp = (X2 NOT GT_all) TOUCH (AA AND GT_all) == 2
 SD_ext = (EXTENTS SD_tmp) NOT TOUCH EDGE GT_all
 
 space_chk_y = DFM PROPERTY X2 SD_ext X4 OVERLAP ABUT ALSO
               [y = MIN(LENGTHXP(X4)) ] > 0
               [x = max(length(SD_ext))/min(length(SD_ext)) ] != 1
 space_chk_y NOT INSIDE INST
}
*/

GT_53 {
@ Poly interacting AA must separate at least two AA diffusions.
@ DRC doesn’t check (poy INTERACT INST), LDBK, LOGO, OCOVL and INDMY region.
 X = GT INTERACT AA
 Y = INT X < 0.001 ABUT INTERSECTING ONLY REGION
 Z = X INTERACT (Y AND AA)
 OUT1 = Z NOT (OR LDBK LOGO OCOVL INDMY)
 (OUT1 NOT (GT INTERACT INST)) NOT MARKS 

 H = AA INTERACT GT
 L = INT H < 0.001 ABUT INTERSECTING ONLY REGION
 W = GT INTERACT (L AND GT)
 OUT2 = W NOT (OR LDBK LOGO OCOVL INDMY)
 (OUT2 NOT (GT INTERACT INST)) NOT MARKS  

 OUT3 = ((GT TOUCH AA) NOT (GT INTERACT INST)) NOT (OR LDBK LOGO OCOVL INDMY)
 OUT3 NOT MARKS 
}

GT_54 {
@ (Poly NOT P2) must be covered by SN or SP.
@ DRC doesn’t check INDMY, LOGO, OCCD, OCOVL, EFUSE and (Poly　INTERACT MOMDMY) region.
  GT_54 = GT_real NOT INTERACT MOMDMY

  X = (GT_54 NOT SN) NOT SP
  OUT1 = (X NOT INSIDE INDMY) NOT (OR LOGO OCCD OCOVL EFUSE)
  OUT1 NOT MARKS 
}
}


foreach metal_via $total_metal_via_list_with_name_mapping {
 SETLAYER ${metal_via}_em = EMPTY7 OR ${metal_via} 
}
for { set i 0 } { $i < [expr [llength $total_metal_via_list_with_name_mapping] -2] } { incr i 2 } {
  CONNECT [lindex $total_metal_via_list_with_name_mapping $i]_em [lindex $total_metal_via_list_with_name_mapping [expr $i +2]]_em BY \
          [lindex $total_metal_via_list_with_name_mapping [expr $i +1]]_em
}

VERBATIM {
GT_em = EMPTY7 OR (GT NOT P2)
NTAP_em = EMPTY7 OR NTAP
PTAP_em = EMPTY7 OR PTAP
PSD_em =  EMPTY7 OR PSD
NSD_em =  EMPTY7 OR NSD
CT_em = EMPTY7 OR CT
ALPA_em = EMPTY7 OR ALPA
PA_em = EMPTY7 OR PA  

CONNECT M1_em GT_em NTAP_em PTAP_em PSD_em NSD_em BY CT_em
CONNECT TM2_em ALPA_em BY PA_em 
CT_em_M = NET AREA RATIO CT_em M1_em > 0 

#IFDEF CHIP_CHECK YES 
GT_55 {
@ Floating gate is prohibited if the effective source/drain are not connected together. 
@ Definition of floating GATE:
@ (1) GATE without poly CT
@ (2) GATE with poly CT but not connected to MOS AA, pickup AA or ALPA pad, which excludes GATE with poly CT connected to metal in IP level. 
@ Definition of the effective source/drain:  Source/drain is connected to differenct (MOS AA NOT poly), pickup AA, GATE or ALPA pad.
@ Resistor poly is considered as conduct poly.
@ This rule doesn’t check INST, LOGO, OCCD, OCOVL region.
@ Set DRC switch for IP level and full chip, default open switch is for chip level check. 
GATE_CONNECT = STAMP GATE BY GT_em 
 
ALPA_W = ALPA_em AND ALPAPAD
FGATE = NET AREA RATIO GATE_CONNECT PTAP_em NTAP_em PSD_em NSD_em ALPA_W > 0 [!AREA(PTAP_em)*!AREA(NTAP_em)*!AREA(PSD_em)*!AREA(NSD_em)*!AREA(ALPA_W) ]
FNSD = NET AREA RATIO NSD_em PSD_em GATE_CONNECT PTAP_em NTAP_em ALPA_W > 0 [~(COUNT(NSD_em) -1)*!AREA(PSD_em)*!AREA(GATE_CONNECT)*!AREA(PTAP_em)*!AREA(NTAP_em)*!AREA(ALPA_W)]
FPSD = NET AREA RATIO PSD_em NSD_em GATE_CONNECT PTAP_em NTAP_em ALPA_W > 0 [~(COUNT(PSD_em) -1)*!AREA(NSD_em)*!AREA(GATE_CONNECT)*!AREA(PTAP_em)*!AREA(NTAP_em)*!AREA(ALPA_W)]
ENSD = NSD NOT FNSD
EPSD = PSD NOT FPSD
FNSD_temp = FNSD NOT ((FNSD OR GATE) INTERACT ENSD > 1 BY NET)
FPSD_temp = FPSD NOT ((FPSD OR GATE) INTERACT EPSD > 1 BY NET)
FGATE_final = FGATE NOT INTERACT (OR FNSD_temp FPSD_temp)
(FGATE_final INTERACT NSD > 1 BY NET) NOT (OR INST LOGO MARKS OCOVL OCCD)
(FGATE_final INTERACT PSD > 1 BY NET) NOT (OR INST LOGO MARKS OCOVL OCCD)
}
#ENDIF

#IFDEF CHIP_CHECK NO   
GT_55 {
@ Floating gate is prohibited if the effective source/drain are not connected together. 
@ Definition of floating GATE:
@ (1) GATE without poly CT
@ (2) GATE with poly CT but not connected to MOS AA, pickup AA or ALPA pad, which excludes GATE with poly CT connected to metal in IP level. 
@ Definition of the effective source/drain:  Source/drain is connected to differenct (MOS AA NOT poly), pickup AA, GATE or ALPA pad.
@ Resistor poly is considered as conduct poly.
@ This rule doesn’t check INST, LOGO, OCCD, OCOVL region.
@ Set DRC switch for IP level and full chip, default open switch is for chip level check. 
GATE_CONNECT = STAMP GATE BY GT_em 
 
ALPA_W = ALPA_em AND ALPAPAD
FGATE = NET AREA RATIO GATE_CONNECT PTAP_em NTAP_em PSD_em NSD_em ALPA_W CT_em_M > 0 [!AREA(PTAP_em)*!AREA(NTAP_em)*!AREA(PSD_em)*!AREA(NSD_em)*!AREA(ALPA_W)*!AREA(CT_em_M)]
FNSD = NET AREA RATIO NSD_em PSD_em GATE_CONNECT PTAP_em NTAP_em ALPA_W > 0 [~(COUNT(NSD_em) -1)*!AREA(PSD_em)*!AREA(GATE_CONNECT)*!AREA(PTAP_em)*!AREA(NTAP_em)*!AREA(ALPA_W)]
FPSD = NET AREA RATIO PSD_em NSD_em GATE_CONNECT PTAP_em NTAP_em ALPA_W > 0 [~(COUNT(PSD_em) -1)*!AREA(NSD_em)*!AREA(GATE_CONNECT)*!AREA(PTAP_em)*!AREA(NTAP_em)*!AREA(ALPA_W)]
ENSD = NSD NOT FNSD
EPSD = PSD NOT FPSD
FNSD_temp = FNSD NOT ((FNSD OR GATE) INTERACT ENSD > 1 BY NET)
FPSD_temp = FPSD NOT ((FPSD OR GATE) INTERACT EPSD > 1 BY NET)
FGATE_final = FGATE NOT INTERACT (OR FNSD_temp FPSD_temp)
(FGATE_final INTERACT NSD > 1 BY NET) NOT (OR INST LOGO MARKS OCOVL OCCD)
(FGATE_final INTERACT PSD > 1 BY NET) NOT (OR INST LOGO MARKS OCOVL OCCD)
}
#ENDIF

}
foreach metal_via $total_metal_via_list_with_name_mapping {
  SETLAYER  ${metal_via}_EMPTY6 = EMPTY6 OR ${metal_via} 
}
for { set i 0 } { $i < [expr [llength $total_metal_via_list_with_name_mapping] -2] } { incr i 2 } {
  CONNECT [lindex $total_metal_via_list_with_name_mapping $i]_EMPTY6 [lindex $total_metal_via_list_with_name_mapping [expr $i +2]]_EMPTY6 BY \
          [lindex $total_metal_via_list_with_name_mapping [expr $i +1]]_EMPTY6
}
SETLAYER GT_all_EMPTY6 = EMPTY6 OR GT_all_3_real 
SETLAYER NSD_EMPTY6 = EMPTY6 OR NSD 
SETLAYER PSD_EMPTY6 = EMPTY6 OR PSD
SETLAYER NTAP_EMPTY6 = EMPTY6 OR NTAP
SETLAYER PTAP_EMPTY6 = EMPTY6 OR PTAP
SETLAYER CT_EMPTY6 = EMPTY6 OR CT
SETLAYER ALPA_EMPTY6 = EMPTY6 OR ALPA
SETLAYER PA_EMPTY6  = EMPTY6 OR PA 
SETLAYER MD_EMPTY6 = EMPTY6 OR MD
 CONNECT M1_EMPTY6 GT_all_EMPTY6 NSD_EMPTY6 PSD_EMPTY6 NTAP_EMPTY6 PTAP_EMPTY6  BY CT_EMPTY6
 CONNECT  TM2_EMPTY6  ALPA_EMPTY6 BY PA_EMPTY6
 CONNECT ALPA_EMPTY6 MD_EMPTY6
RULECHECK GT_56 { 
@ ((((poly OR GTDMP) OR GTDOP) NOT P2) NOT INSIDE (DG OR TG)) can't apply the voltage > 3.3V.

  for { set j 1 } { $j <= [llength $inter_metal_list_with_name_mapping] } { incr j } {

SETLAYER X$j = NET AREA RATIO M1_EMPTY6 (M${j}_EMPTY6 INTERACT M${j}V50) > 0
    
    lappend GT_56_list X$j
  }
SETLAYER Y1 = OR $GT_56_list
SETLAYER Y2 = M1_EMPTY6 AND Y1
SETLAYER Y3 = (NET AREA RATIO GT_all_EMPTY6 Y2 > 0) NOT INSIDE DGTG
  
OUTLAYER Y3 NOT MARKS
}

RULECHECK GT_57 {
@ L-shape (poly NOT P2) number, when
@ (1)	space between poly and AA <0.07um, 
@ (2)	poly and AA are in the same MOS
@ (3)	L-shape poly length (L) ≤ 0.03um. < 2
@ DRC doesn’t check POLY_JOG with E3>0um(Pls refer to POLY_JOG definition in 7.1.13)
@ and skip to check INST region.
SETLAYER GT_AA = GT_real OR AA
SETLAYER GT_AA_L = CONVEX EDGE GT_AA ANGLE1 == 270 ANGLE2 == 270 WITH LENGTH < 0.07
SETLAYER GT_L = GT_AA_L COIN EDGE GT_real 
SETLAYER X0 = EXPAND EDGE GT_L INSIDE BY 0.005
SETLAYER X1 = (EXPAND EDGE GT_L INSIDE BY 0.005 OUTSIDE BY 0.001) NOT (MARKS OR INST)
SETLAYER Y = EXT GT_real < 0.001 ABUT REGION INTERSECTING ONLY

SETLAYER Z = GT_real TOUCH EDGE ((Y WITH EDGE GT_L) NOT COIN EDGE GT_L)
SETLAYER H = LENGTH Z <= 0.03
SETLAYER P = EXPAND EDGE H OUTSIDE BY 0.005
SETLAYER Q = Y INTERACT P
SETLAYER OUT1 = (X1 TOUCH GATE) INTERACT Q

OUTLAYER (OUT1 NOT INTERACT POLY_JOG1) INTERACT (AA INTERACT (OUT1 NOT INTERACT POLY_JOG1)  > 1)
}



VERBATIM {
//=============================
//  GTDMP: GT Dummy rules
//=============================

GROUP GGTDMP GTDMP_?

GTDMP_1	{
@ Width	≥	0.03	um
 OUT1 = INT GTDMP < 0.03 ABUT < 90 SINGULAR REGION
 OUT1 NOT MARKS 
}

GTDMP_2	{
@ Width inside DG/TG	≥	0.1	um
 X = INT GTDMP < 0.1 ABUT < 90 SINGULAR REGION
 OUT1 = X AND DGTG
 OUT1 NOT MARKS 
}
}

RULECHECK GTDMP_3	{
@ Space between two GTDMPs if at least one GTDMP width ≥ 0.03um, and ≤ 0.09um, and the parallel run length ≥ 0.1um	≥	0.1	um
 Mn_3 GTDMP 0.029 0.09 0.099 0.1
}

RULECHECK GTDMP_4	{
@ Space between two GTDMPs if at least one GTDMP width > 0.09um, and the GTDMP parallel run length ≥ 0.1um	≥	0.12	um
 Mn_one_width GTDMP 0.091 0.099 0.12
}

VERBATIM {
GTDMP_5	{
@ Space between GTDMP and ((poly or GTDMP) or GTDOP).
@ It’s not allowed ((GTDMP interact poly) outside P2).
@ DRC doesn’t check POLY_JOG.	≥	0.08	um
 X = GT OR (GTDMP OR GTDOP)
 Y = X NOT POLY_JOG
 OUT1 = EXT GTDMP Y < 0.08 ABUT < 90 SINGULAR REGION
 OUT1 NOT MARKS  
 ((GTDMP INTERACT GT) OUTSIDE P2) NOT MARKS
}

GTDMP_6	{
@ Space between (GTDMP AND AA) and neighboring GATE or (GTDMP AND AA)	≥	0.1	um
 X = GTDMP AND AA
 OUT1 = EXT X < 0.1 ABUT < 90 SINGULAR REGION
 OUT1 NOT MARKS 
 OUT2 = EXT X GATE < 0.1 ABUT < 90 SINGULAR REGION
 OUT2 NOT MARKS 
}

GTDMP_7	{
@ Space between two (GTDMP AND AA) inside DG/TG in the same AA	≥	0.18	um
 X = GT_all_EMPTY AND (GTDMP AND AA)
 Y = X INSIDE DGTG
 OUT1 = EXT Y < 0.18 ABUT < 90 SINGULAR REGION CONNECTED
 OUT1 NOT MARKS 
}

GTDMP_8 {
@ Space between GTDMP and INDMY	≥	1.2
 (EXT GTDMP INDMY < 1.2 ABUT < 90 SINGULAR REGION) NOT MARKS
}

GTDMP_9	{
@ Space between (GTDMP AND AA) and SAB. ((GTDMP AND AA) and SAB overlap is not allowed).
@ This rule isn’t applicable for RESP1, ESDIO1, ESDIO2, ESDCLP, ESDPOB,CLPDMY region.	≥	0.38	um
 X = GTDMP AND AA
 Y = EXT X SAB < 0.38 ABUT < 90 SINGULAR REGION
 Z = X AND SAB
 OUT1 = ((Y OR Z) NOT ESD_CLP) NOT RESP1
 OUT1 NOT MARKS 
}

GTDMP_10 {
@ Space between (GTDMP AND AA) and CT for core device when GTDMP width ≤ 0.09um. ((GTDMP AND AA) and CT overlap is not allowed)	≥	0.03um
 X = GTDMP WITH WIDTH <= 0.09
 Y = X AND (AA ENCLOSE GATE_CORE)
 OUT1 = EXT (GT_all_EMPTY AND Y) (AA_EMPTY AND CT) < 0.03 ABUT < 90 SINGULAR REGION CONNECTED
 OUT1 NOT MARKS 

 OUT2 = (GTDMP AND AA) AND CT
 OUT2 NOT MARKS 
}

GTDMP_11 {
@ Space between (GTDMP AND AA) and CT for core device when GTDMP width > 0.09um. ((GTDMP AND AA) and CT overlap is not allowed)	≥	0.04	um
 X = GTDMP WITH WIDTH > 0.09
 Y = X AND (AA ENCLOSE GATE_CORE)
 OUT1 = EXT (GT_all_EMPTY AND Y) (AA_EMPTY AND CT) < 0.04 ABUT < 90 SINGULAR REGION CONNECTED
 OUT1 NOT MARKS 

 OUT2 = (GTDMP AND AA) AND CT
 OUT2 NOT MARKS 
}

GTDMP_12 {
@ Space between (GTDMP AND AA) and CT for IO device. ((GTDMP AND AA) and CT overlap is not allowed)	≥	0.07	um
 X = GTDMP AND (AA ENCLOSE GATE_IO)
 OUT1 = EXT (GT_all_EMPTY AND X) (AA_EMPTY AND CT) < 0.07 ABUT < 90 SINGULAR REGION CONNECTED
 OUT1 NOT MARKS    

 OUT2 = (GTDMP AND AA) AND CT
 OUT2 NOT MARKS 
}

GATEDMP_WE = (AA AND GTDMP) COIN EDGE GTDMP
GATEDMP_LE = (AA AND GTDMP) NOT COIN EDGE GATEDMP_WE

GTDMP_13 {
@ (Poly OR GTDMP) extension outside of AA	≥	0.08	um
 OUT1 =  ENC (AA TOUCH EDGE GATE_LE) (GTDMP OR GT) < 0.08 ABUT < 90  REGION
 OUT2 =  ENC (AA TOUCH EDGE GATEDMP_LE) (GTDMP OR GT) < 0.08 ABUT < 90  REGION
 ((OUT1 OR OUT2) NOT INSIDE INST) NOT (OR MARKS INDMY ) 
}

GTDMP_14 {
@ GTDMP extension outside of AADMP	≥	0.08	um
 OUT1 = ENC AADMP GTDMP < 0.08 ABUT < 90 SINGULAR REGION
 OUT1 NOT MARKS 
}

GTDMP_15 {
@ AADMP extension outside of GTDMP	≥	0.075	um
 OUT1 = ENC GTDMP AADMP < 0.075 ABUT < 90 SINGULAR REGION
 OUT1 NOT MARKS 
}

GTDMP_16 {
@ Rectangular GTDMP length 	≥	0.26	um
 X = RECTANGLE GTDMP
 OUT1 = X NOT WITH EDGE (LENGTH X >= 0.26)
 OUT1 NOT MARKS 
}

GTDMP_17 {
@ GTDMP area
@ DRC doesn't check rectangle (GTDMP INTERACT AA) with length ≥ 0.32 um	≥	0.0115
 X = RECTANGLE (GTDMP INTERACT AA) >= 0.32 
 OUT1 = AREA GTDMP < 0.0115
 (OUT1 NOT X) NOT MARKS 
}

GTDMP_18_R_DFM3 {
@ ((Poly or POLY_DMY) NOT P2) density.
@ DRC check region follow: (((AA OR poly) INTERACT GATE) sizing up 2um) NOT ((AA OR poly) sizing up 0.15um)) 
@ DRC doesn’t check VARMOS, NODMF, INST, DG, TG,OCOVL and OCCD region.	≥	7%
 X = (AA OR GT) INTERACT GATE
 Y = SIZE X BY 2
 Z = SIZE (AA OR GT) BY 0.15
 H = Y NOT Z
 P = ((((VARMOS OR NODMF) OR INST) OR DGTG) OR OCCD) OR OCOVL
 R = (H NOT P) NOT MARKS 

 GT_PDMY_NP = ((GT or POLY_DMY) NOT P2) NOT MARKS 
 T = DFM PROPERTY R GT_PDMY_NP [ RATIO = AREA(GT_PDMY_NP)/AREA(R) ] < 0.07
 DFM RDB T density_report_GTDMP_18.rdb
 COPY T 
}

GTDMP_19 {
@ GTDMP (NOT P2) must be rectangular.
 X = GTDMP NOT P2
 OUT1 = NOT RECTANGLE X
 OUT1 NOT MARKS 
}

GTDMP_21 {
@ GTDMP interacting AA must separate at least two AA diffusions.
@ DRC doesn't check MOMDMY region.
 X = GTDMP INTERACT AA
 Y = INT X < 0.005 ABUT INTERSECTING ONLY REGION
 Z = X INTERACT (Y AND AA)
 OUT1 = Z NOT MOMDMY
 OUT1 NOT MARKS 

 H = AA INTERACT GTDMP
 L = INT H < 0.005 ABUT INTERSECTING ONLY REGION
 W = GTDMP INTERACT (L AND GTDMP)
 OUT2 = W NOT MOMDMY
 OUT2 NOT MARKS  

 OUT3 = (GTDMP TOUCH AA) NOT MOMDMY
 OUT3 NOT MARKS 
}

GTDMP_22 {
@ (GTDMP AND AA) of core device must be vertical direction. This rule isn't applicable for the regions covered by BIPOLA, DSTR, NODMF and LOGO.
 X = AA ENCLOSE GATE_CORE
 Y = GTDMP INSIDE EDGE X
 Z = ANGLE Y == 0
 H = (GTDMP AND AA) WITH EDGE Z
 OUT1 = H NOT (BIPOLA OR (DSTR OR (NODMF OR LOGO)))
 OUT1 NOT MARKS 
}

GTDMP_24 {
@ CT is not allowed to land on GTDMP
 OUT1 = CT AND GTDMP
 OUT1 NOT MARKS 
}

GTDMP_25 {
@ CT is not allowed to be placed between GTDMP and AA edge, or two GTDMPs.
 X = AA INTERACT GTDMP
 Y = X NOT (GTDMP OR GT)
 Z = Y ENCLOSE CT
 P = GTDMP INSIDE EDGE X
 Q = GT INSIDE EDGE X
 OUT1 = Z NOT WITH EDGE Q
 OUT1 NOT MARKS 
}



//=======================================
//  GTMK2: Horizontal Gate Layout Rules
//=======================================

GROUP GGTMK2 GTMK2_?

GTMK2_1	{
@ GTMK2 is the marking layer for the horizontal gate in core region.
@ GTMK2 must be drawn for the horizontal gate in core region.
  X = ((GATE NOT DGTG) NOT GTMK2) WITH EDGE (ANGLE GATE_LE == 90)
  X NOT MARKS   

  Y = ((GATE NOT DGTG) AND GTMK2) WITH EDGE (ANGLE GATE_LE == 0)
  Y NOT MARKS 
}
			
GTMK2_2 {
@ Channel width in GTMK2. ≥ 0.3um and ≤ 3um
  X = GATE_WE NOT OUTSIDE EDGE GTMK2
  Y = (LENGTH X < 0.3) OR EDGE (LENGTH X > 3)
 OUT1 = GATE WITH EDGE Y
 OUT1 NOT MARKS 
}
		
GTMK2_3	{
@ Channel length in GTMK2	≥0.1um and ≤ 6um
  X = GATE_LE NOT OUTSIDE EDGE GTMK2
  Y = (LENGTH X < 0.1) OR EDGE (LENGTH X > 6)
  OUT1 = GATE WITH EDGE Y
  OUT1 NOT MARKS 
}
		
GTMK2_4	{
@ Width of (poly or GTDMP or GTDOP) in GTMK2.	≥	0.04	um
  X = GT OR (GTDMP OR GTDOP)
  Y = X AND GTMK2
  OUT1 = INT Y < 0.04 ABUT < 90 SINGULAR REGION
  OUT1 NOT MARKS 
}

GTMK2_5	{
@ GTMK2 enclosure of N+ AA or P+ AA	≥	0.04	um
 OUT1 = ENC NACT GTMK2 < 0.04 ABUT < 90 SINGULAR REGION
 OUT1 NOT MARKS 
 OUT2 = ENC PACT GTMK2 < 0.04 ABUT < 90 SINGULAR REGION
 OUT2 NOT MARKS 
}

GTMK2_6	{
@ GTMK2 must fully cover (GATE INTERACT GTMK2)	≥	0.08	um
  X = GATE INTERACT GTMK2
  OUT1 = ENC X GTMK2 < 0.08 ABUT < 90 SINGULAR REGION
  OUT1 NOT MARKS 
  OUT2 = X CUT GTMK2
  OUT2 NOT MARKS 
}

GTMK2_7	{
@ (AA INTERACT poly) inside GTMK2 must be rectangular.(45 degree edge is not allowed)
  X = (AA INTERACT GT) INSIDE GTMK2
  OUT1 = NOT RECTANGLE X
  OUT1 NOT MARKS 
  OUT2 = ANGLE X >= 44.9 <= 45.1
  OUT2 NOT INSIDE EDGE MARKS 
}
			
GTMK2_8	{
@ GATE inside GTMK2 must be in horizontal direction.
  X = GATE INTERACT GTMK2
  Y = ANGLE (X COIN EDGE GATE_LE) == 0
  OUT1 = X WITH EDGE Y
  OUT1 NOT MARKS 
}
			
GTMK2_9	{
@ It’s not allowed that horizontal GATE NOT INSIDE GTMK2 in core region
  X = (GATE NOT DGTG) WITH EDGE (ANGLE GATE_LE == 90) 
  OUT1 = X NOT INSIDE GTMK2
  OUT1 NOT MARKS 
}

GTMK2_10 {
@ It’s not allowed GTMK2 overlap LVT_N, LVT_P, DG, TG, ESDIO1, ESDIO2, ESDCLP, ESDPOB, CLPDMY, P2, NODMF, EFUSE, LOGO.
  (GTMK2 AND LVT_N) NOT MARKS 
  (GTMK2 AND LVT_P) NOT MARKS
  (GTMK2 AND DG) NOT MARKS
  (GTMK2 AND TG) NOT MARKS
  (GTMK2 AND ESD_CLP) NOT MARKS
  (GTMK2 AND P2) NOT MARKS
  (GTMK2 AND NODMF) NOT MARKS
  (GTMK2 AND EFUSE) NOT MARKS
  (GTMK2 AND LOGO) NOT MARKS
}

GTMK2_11 {
@ Space between ((poly or GTDMP or GTDOP) INTERACT GTMK2) and ((poly or GTDMP or GTDOP)	≥ 0.12um
  OUT1 = EXT (GT_all_3 INTERACT GTMK2) GT_all_3 < 0.12 ABUT < 90 SINGULAR REGION
  OUT1 NOT MARKS 
}

GTMK2_12 {
@ Space between GTMK2 and (GATE OUTSIDE GTMK2)	≥ 0.08um
 OUT1 = EXT GTMK2 (GATE OUTSIDE GTMK2) < 0.08 ABUT < 90 SINGULAR REGION
 OUT1 NOT MARKS 
}

GTMK2_13 {
@ Space between L shape poly and AA when poly and AA in same MOS,and L shape poly interact with GTMK2, and L shape length (L) ≤ 0.08um.  ≥ 0.16um
 GT_GTMK2 = GT INTERACT GTMK2

 GT_AA = GT_GTMK2 OR AA
 GT_AA_L = CONVEX EDGE GT_AA ANGLE1 == 270 ANGLE2 == 270 WITH LENGTH < 0.16
 GT_L = (GT_AA_L COIN EDGE GT_GTMK2) NOT COIN EDGE (CONVEX EDGE GT == 0)
 X0 = EXPAND EDGE GT_L INSIDE BY 0.005
 Y = EXT GT_GTMK2 < 0.005 ABUT REGION

 Z = GT_GTMK2 TOUCH EDGE ((Y WITH EDGE GT_L) NOT COIN EDGE GT_L)
 H = LENGTH Z <= 0.08
 P = EXPAND EDGE H OUTSIDE BY 0.005
 Q = Y INTERACT P
 OUT1 = (X0 TOUCH GATE) INTERACT Q
 OUT1 NOT MARKS 
}




//=============================
//  P2 - Poly cut design rules
//=============================

GROUP GP2 P2_?

P2_1_2_16 {
@ P2.1 P2 width
@      DRC doesn’t check INST region	=	0.08	um
@ P2.2 P2 length 
@      DRC doesn’t check INST region	≥	0.15	um
@ P2.16	P2 must be rectangular
 X = NOT RECTANGLE P2 == 0.08 BY >= 0.15
 OUT1 = X NOT INSIDE INST
 OUT1 NOT MARKS  
 OUT2 = NOT RECTANGLE P2
 OUT2 NOT MARKS 
}

P2_3 {
@ Poly width which the poly is cut by P2.
@ DRC only check P2 overlap poly region 	≤	0.5	um
 X = GT WITH WIDTH > 0.5
 OUT1 = X AND P2
 OUT1 NOT MARKS 
}

P2_4 {
@ Space between P2 and P2 is >= 0.09
 OUT1 = EXT P2 < 0.09 ABUT < 90 SINGULAR REGION
 OUT1 NOT MARKS 
}

P2_5 {
@ Space between P2 and ((poly OR GTDMP) OR GTDOP) in P2 length direction. ≥ 0.04um
 OUT1 = EXT P2_W GT_all_3 < 0.04 ABUT < 90 REGION
 OUT1 NOT MARKS 
}

P2_6 {
@ Space between P2 and ((poly OR GTDMP) OR GTDOP) excluding P2 length direction is >= 0.02
@ DRC doesn’t check INST region
 X = EXT P2_L GT_all_3 < 0.02 ABUT < 90 REGION
 OUT1 = X NOT INSIDE INST
 OUT1 NOT MARKS 
}

P2_7 {
@ Space between P2 and AA (overlap is not allowed) is >= 0.035
@ DRC doesn’t check INST region.
 X = EXT P2 AA < 0.035 ABUT < 90 SINGULAR REGION
 Y = P2 AND AA
 OUT1 = (X OR Y) NOT INSIDE INST
 OUT1 NOT MARKS 
}

P2_8 {
@ Space between P2 and GATE in P2 width direction when space between poly and L-shape AA in the same MOS < 0.1um (overlap is not allowed).
@ DRC doesn’t check INST region. ≥ 0.05um
 X = EXT (AA INTERACT GATE) < 0.001 ABUT REGION
 L = ENC GT AA < 0.001 ABUT == 90 REGION
 M = ((AA NOT GT) TOUCH EDGE X) TOUCH EDGE L
 N = ((AA NOT GT) TOUCH EDGE X) NOT TOUCH EDGE L
 H = LENGTH M < 0.1
 P = EXPAND EDGE H INSIDE BY 0.001 EXTEND BY 0.001
 Q = AA NOT OUTSIDE EDGE GT
 W = Q TOUCH EDGE P
 R = EXT W P2_L < 0.05 ABUT < 90 REGION OPPOSITE
 OUT1 = R NOT INSIDE INST
 OUT1 NOT MARKS 

 OUT2 = (P2 AND GATE) NOT INSIDE INST
 OUT2 NOT MARKS 
}

P2_9 {
@ Space between P2 and CT (overlap is not allowed) is >= 0.02
@ DRC doesn’t check INST region.
 X = EXT P2 CT < 0.02 ABUT < 90 SINGULAR REGION
 Y = P2 AND CT
 OUT1 = (X OR Y) NOT INSIDE INST
 OUT1 NOT MARKS 
}

P2_10 {
@ P2 extension outside of ((poly OR GTDMP) OR GTDOP) in P2 length direction is >= 0.05
 OUT1 = ENC GT_all_3 P2_W < 0.05 ABUT < 90 OPPOSITE REGION
 OUT1 NOT MARKS 
}

P2_11 {
@ P2 extension outside of ((poly OR GTDMP) OR GTDOP) in P2 width direction.
@ DRC doesn’t check INST region	=	0.03/0.035	um
 X = (GT_all_3 AND P2) COIN EDGE GT_all_3
 Y = COPY X
 Z_temp = Y NOT TOUCH EDGE (INT [Y] P2_L <= 0.001 ABUT)
 Z_temp2 = ENC (Z_temp) P2_L == 0.03 ABUT < 90 OPPOSITE
 Z = ENC (Z_temp2) P2_L == 0.035 ABUT < 90 OPPOSITE
 OUT1 = Z NOT INSIDE EDGE INST
 OUT1 NOT INSIDE EDGE MARKS 
 OUT2 = (P2_L COIN EDGE GT_all_3) NOT INSIDE EDGE INST
 OUT2 NOT INSIDE EDGE MARKS 
}

P2_12 {
@ ((Poly OR GTDMP) OR GTDOP) extension outside of P2.
@ DRC doesn’t check INST region.	≥	0.1	um
  X = ENC P2 GT_all_3 < 0.1 ABUT < 90 SINGULAR REGION
  OUT1 = X NOT INSIDE INST
  OUT1 NOT MARKS 
}

P2_13 {
@ It’s not allowed P2 overlap DG/TG/PSUB/AA/CT.
@ DRC doesn’t check P2 overlap AA in INST region.
 (P2_all AND DGTG) NOT MARKS
 (P2_all AND PSUB) NOT MARKS
 ((P2_all AND AA) NOT INST) NOT MARKS
 (P2_all AND CT) NOT MARKS
}

P2_14 {
@ P2 must INTERACT ((poly OR GTDMP) OR GTDOP)
 OUT1 = P2 NOT INTERACT GT_all_3
 OUT1 NOT MARKS
}

P2_15 {
@ P2 must be in the horizontal direction which is perpendicular to the core GATE length direction in a chip
 X = ANGLE P2_all_L == 90
 Y = ANGLE P2_all_L >= 44.9 <= 45.1
 (P2_all WITH EDGE X) NOT MARKS
 (P2_all WITH EDGE Y) NOT MARKS
}

P2_16 {
@ P2 must be rectangular
  OUT1 = NOT RECTANGLE P2_all 
  OUT1 NOT MARKS 
}

P2_17 {
@ It's not allowed any vertex of P2 INTERACT ((poly OR  GTDMP) OR GTDOP)
  X = INT P2 < 0.001 ABUT REGION
  OUT1 = GT_all_3 INTERACT X
  OUT1 NOT MARKS 
}
			
P2_18 {
@ (((Poly OR GTDMP) OR GTDOP) AND P2) must be rectangular except small jogs (jog ≤ 0.005um)
  X = GT_all_3 AND P2
  Y = CONVEX EDGE GT_all_3 <= 1 WITH LENGTH > 0.005
  Z = Y NOT OUTSIDE EDGE X
  OUT1 = EXT Z < 0.001 ABUT REGION
  OUT1 NOT MARKS 
}

P2_19 {
@ Area of (((poly OR GTDMP) OR GTDOP) NOT P2).
@ This rule doesn’t check rectangle ((((poly OR GTDMP) OR GTDOP) NOT P2) INTERACT AA) (any edge ≥0.23um) ≥ 0.009um2
  X = GT_all_3 NOT P2
  Y = RECTANGLE (X INTERACT AA) >= 0.23
  OUT1 = AREA (X NOT Y) < 0.009
  OUT1 NOT MARKS 
}

P2_20 {
@ Overlap area of P2 and AA_DMY. 	≤	0.01	um2
  X = P2 AND AA_DMY
  OUT1 = AREA X > 0.01
  OUT1 NOT MARKS 
}

P2_21 {
@ The outermost ((Poly OR GTDMP) INTERACT P2) must be floating when P2 length ≥18um.
@ The floating definition is: (((Poly OR GTDMP) NOT P2) NOT INTERACT CT).
  GT_all_2 = OR GT GTDMP

  P2_CHECK = P2 ENCLOSE RECTANGLE 18 0.001 ORTHOGONAL ONLY
  P2_SIDE = (P2_CHECK NOT GT_all_2) INTERACT (P2 AND GT_all_2) == 1
  P2_MID = (P2 AND GT_all_2) NOT INTERACT P2_SIDE
  GT_FLOATING = (GT_all_2 NOT P2_MID) NOT INTERACT CT
  (P2_SIDE NOT INTERACT GT_FLOATING) NOT MARKS
}
		
P2_22_R_DFM2 {
@ Recommended (P2 or P2DUM or P2DOP) density in full chip	≥	5%
  X = P2_all NOT MARKS 
  Y = DRC:1 NOT MARKS 
  Z = COPY Y 
  DENSITY X Y [AREA(X)/AREA(Y)] < 0.05 PRINT density_report_P2_22_R.log RDB density_report_P2_22_R.rdb
}




//=================================================
//  SN -N+ source/drain implantation design minima
//=================================================

GROUP GSN SN_?

PICKAA = TAP NOT ((TAP INTERACT GATE) AND VARMOS)
NON_PICKAA = AA NOT PICKAA

SN_1 {
@ Min SN width is 0.16
@ Single-point-interaction is allowed.
@ DRC doesn’t check INST region
  X = INT SN < 0.16 ABUT < 90 REGION
  OUT1 = X NOT INSIDE INST
  OUT1 NOT MARKS 
}

SN_2 {
@ Min Space between SNs is 0.16
@ Single-point-interaction is allowed.
  OUT1 = EXT SN < 0.16 ABUT < 90 REGION
  OUT1 NOT MARKS 
}
}

RULECHECK SN_3_R_DFM3 {
@ Space between SNs with parallel run length >0.24um, when one SN width >0.22um. >= 0.180um
  Mn_one_width SN 0.221 0.24 0.18
}

RULECHECK SN_4 {
@ Space between SNs, when one or both SNs width (WW1) < 0.22um.
@ DRC only check opposite sides.	≥	0.220	um
SETLAYER X = INT \[SN\] < 0.22 OPPOSITE
SETLAYER Y = EXT X \[SN\] < 0.22 OPPOSITE
SETLAYER Z1 = LENGTH (SN TOUCH EDGE Y) < 0.22
SETLAYER Z2 = INT (Z1) SN < 0.22 OPPOSITE
SETLAYER H1 = EXT \[SN\] Z2 < 0.22 OPPOSITE
SETLAYER H2 = EXT \[X\] SN < 0.22 OPPOSITE
OUTLAYER (H2 NOT COIN EDGE H1) NOT INSIDE EDGE MARKS 
}

RULECHECK SN_5 {
@ Space between SNs with parallel run length >0.33um and SN space is on STI (not INTERACT AA OR AA dummy). >= 0.250um
  Mn_one_width_PART SN 0.001 0.33 0.25
  OUTLAYER (OUT3 NOT INTERACT AA_all) NOT MARKS 
}

VERBATIM {
SN_6 {
@ Space between SN and GATE along the source/drain direction. >= 0.140um
@ DRC doesn’t check INST region.
  X = EXT GATE_WE SN < 0.14 ABUT < 90 REGION OPPOSITE MEASURE ALL
  OUT1 = X NOT INSIDE INST
  OUT1 NOT MARKS 
}

SN_7 {
@ Space between SN and GATE along GATE poly direction. >= 0.065um
@ DRC doesn’t check INST region.
  X = EXT GATE_LE SN < 0.065 ABUT < 90 REGION OPPOSITE MEASURE ALL
  OUT1 = X NOT INSIDE INST
  OUT1 NOT MARKS 
}

SN_8 {
@ Space between SN and non-butted P+AA. >= 0.065um
@ DRC doesn’t check INST region.
  X = EXT PACT SN < 0.065 ABUT > 0 < 90 REGION
  OUT1 = X NOT INSIDE INST
  OUT1 NOT MARKS 
}

SN_9 {
@ Space between SN and non-butted P+ pick-up AA. >= 0.020um
  OUT1 = EXT PTAP SN < 0.02 ABUT >0 <90 SINGULAR REGION
  OUT1 NOT MARKS 
}

SN_11 {
@ Space between butted N+ pick-up AA and PMOS GATE in the same AA.	≥	0.165	um
  X = GATE AND SP
  Y = (NTAP COIN EDGE SP) INSIDE EDGE AA
  OUT1 = EXT X Y < 0.165 ABUT < 90 REGION OPPOSITE
  OUT1 NOT MARKS 
}

SN_12 {
@ Space between butted N+ pick-up AA (in L shape AA) and PMOS GATE poly in the same AA, when this butted N+ pick-up AA extrusion: 0 < h < 0.08um ≥ 0.165um
  PAAL = PAA TOUCH INSIDE EDGE PGATE
  PAAL_EP = EXPAND EDGE PAAL OUTSIDE BY 0.08 EXTEND BY 0.01
  BUTNA_ED = NAA COIN EDGE (PAA NOT PTAP)
  BUTNA_ED_1 = BUTNA_ED INSIDE EDGE PAAL_EP
  BUTSN_1 = (NAA INTERACT NW) WITH EDGE BUTNA_ED_1
  GTSP_1 = GT INSIDE EDGE (PAA  TOUCH NAA)
  GTSP   = (GT WITH EDGE GTSP_1) TOUCH EDGE (GATE AND SP)
  OUT1 = EXT BUTSN_1 GTSP < 0.165 ABUT<90 REGION
  OUT1 NOT MARKS 
}

SN_13 {
@ SN extension outside of GATE along the source/drain direction. ≥ 0.14um
  OUT1 = ENC GATE_WE SN < 0.14 ABUT < 90 REGION OPPOSITE
  OUT1 NOT MARKS 
}

SN_14 {
@ SN extension outside of NMOS GATE along the source/drain direction where there is a butted P+ pick-up AA in the same AA
@ DRC doesn’t check INST region.	≥	0.165 	um
  X = GATE AND SN
  Y = (SN COIN EDGE PTAP) INSIDE EDGE (AA INTERACT X)
  Z = ENC GATE_WE Y < 0.165 ABUT < 90 REGION OPPOSITE
  OUT1 = Z NOT INSIDE INST
  OUT1 NOT MARKS 
}

SN_15a {
@ SN extension outside of GATE along the GATE poly direction for core device.
@ DRC doesn’t check INST region.	≥	0.065 
  X = ENC (GATE_LE TOUCH EDGE GATE_CORE) SN < 0.065 ABUT < 90 REGION OPPOSITE
  OUT1 = X NOT INSIDE INST
  OUT1 NOT MARKS
}

SN_15b {
@ SN extension outside of GATE along the GATE poly direction for IO device.
@ DRC doesn’t check INST region.	≥	0.13 
  X = ENC (GATE_LE TOUCH EDGE GATE_IO) SN < 0.13 ABUT < 90 REGION OPPOSITE
  OUT1 = X NOT INSIDE INST
  OUT1 NOT MARKS
}

SN_16 {
@ SN extension outside of NW/DG/TG. Extension=0um is allowed.
@ DRC flag the violation (INTERACT AA).	≥	0.16	um
  X = ENC NW SN < 0.16 ABUT > 0 < 90 SINGULAR REGION
  (X INTERACT AA) NOT MARKS 

  Y = ENC DG SN < 0.16 ABUT > 0< 90 SINGULAR REGION
  (Y INTERACT AA) NOT MARKS

  Z = ENC TG SN < 0.16 ABUT > 0 < 90 SINGULAR REGION
  (Z INTERACT AA) NOT MARKS
}

SN_17 {
@ Enclosure of N+ AA by SN.
@ DRC doesn’t check INST and (AA INTERACT RESNW) region. ≥ 0.065um
  X0 = NACT NOT (AA INTERACT RESNW)
  X = ENC (X0 NOT COIN EDGE PTAP) SN < 0.065 ABUT < 90 REGION
  OUT1 = X NOT INSIDE INST
  OUT1 NOT MARKS 
}

SN_18 {
@ Enclosure of non-butted N+ pickup AA by SN. >= 0.020um
 OUT1 = ENC (NTAP COIN EDGE AA) SN < 0.02 ABUT < 90 REGION
 OUT1 NOT MARKS 
}

SN_20 {
@ SN and AA overlap ≥ 0.080um
  OUT1 = INT SN AA < 0.08 ABUT > 0 < 90 SINGULAR REGION
  OUT1 NOT MARKS 
}

SN_21 {
@ SN and DG overlap.
@ DRC flag the violation (INTERACT AA).	≥	0.16	um
  X = INT SN DG < 0.16 ABUT > 0 < 90 SINGULAR REGION
  OUT1 = X INTERACT AA
  OUT1 NOT MARKS 
}

SN_22 {
@ SN and TG overlap.
@ DRC flag the violation (INTERACT AA).	≥	0.16	um
 X = INT SN TG < 0.16 ABUT > 0 < 90 SINGULAR REGION
 OUT1 = X INTERACT AA
 OUT1 NOT MARKS 
}

SN_23 {
@ Area of SN, while (((((SN NOT NW) INTERACT CT)sizing up 0.079um)sizing down 0.158um)sizing up 0.079um)
@ DRC doesn’t check INST region.
@ DRC doesn’t flag the rectangle pattern, when
@ 1. Any one of the edge length =0.33um,
@ 2. The space between any two outer vertexes =0.16um	≥	0.1	um2
  X = (SN NOT NW) INTERACT CT
  Y = SIZE (SIZE (SIZE X BY 0.079) BY -0.158) BY 0.079
  Z = AREA Y < 0.1
  ALL_CHECK = Z NOT INSIDE INST

  ALL_CHECK_R = RECTANGLE ALL_CHECK == 0.33
  R_CONER = INT ALL_CHECK_R <= 0.001 ABUT == 90 REGION INTERSECTING ONLY
  R_SPACE_EDGE = EXT [R_CONER] SN == 0.16 OPPOSITE EXTENDED 0.001 MEASURE ALL
  R_CONER_SPACE = R_CONER WITH EDGE R_SPACE_EDGE
  R_WAVIE = ALL_CHECK_R INTERACT R_CONER_SPACE >= 2

  CHECK_FINAL = ALL_CHECK NOT R_WAVIE
  CHECK_FINAL NOT MARKS 
}

SN_24 {
@ Area of SN. ≥	0.07um2
 OUT1 = AREA SN < 0.07
 OUT1 NOT MARKS 
}

SN_25 {
@ Enclosed area of SN, while (((((SN NOT NW) INTERACT CT)sizing up 0.079um)sizing down 0.158um)sizing up 0.079um)
@ DRC doesn’t check INST region.
@ DRC doesn’t flag the rectangle pattern, when
@ 1.Any one of the edge length =0.33um,
@ 2. The space between any two inner vertexes =0.16um	≥	0.1	um2
  X = (SN NOT NW) INTERACT CT
  Y = SIZE (SIZE (SIZE X BY 0.079) BY -0.158) BY 0.079
  Z0 = (HOLES Y INNER) NOT Y
  Z = AREA Z0 < 0.1
  ALL_CHECK = Z NOT INSIDE INST

  ALL_CHECK_R = RECTANGLE ALL_CHECK == 0.33
  R_CONER = INT ALL_CHECK_R <= 0.001 ABUT == 90 REGION INTERSECTING ONLY
  R_SPACE_EDGE = ENC [R_CONER] SN == 0.16 OPPOSITE EXTENDED 0.001 MEASURE ALL
  R_CONER_SPACE = R_CONER WITH EDGE R_SPACE_EDGE
  R_WAVIE = ALL_CHECK_R INTERACT R_CONER_SPACE >= 2

  CHECK_FINAL = ALL_CHECK NOT R_WAVIE
  CHECK_FINAL NOT MARKS
}

SN_26 {
@ Enclosed area of SN. ≥ 0.07um2
  X = (HOLES SN INNER) NOT SN
  OUT1 = AREA X < 0.07
  OUT1 NOT MARKS 
}

SN_27 {
@ N+ butted AA in NW area(the area interact with CT). ≥	0.024um2
  X = ((NAA TOUCH SP) AND NW) INTERACT CT
  OUT1 = AREA X < 0.024
  OUT1 NOT MARKS 
}

SN_28 {
@ SN and SP overlap is forbidden
  OUT1 = SN AND SP
  OUT1 NOT MARKS 
}

SN_29 {
@ 45-degree edge length	≥	0.52um
 X = ANGLE SN >= 44.9 <= 45.1
 OUT1 = LENGTH X < 0.52
 OUT1 NOT INSIDE EDGE MARKS 
}

SN_30 {
@ @ (SN AND (AA AND poly)) in NW is not allowed, except LDBK and VARMOS region.
 X = SN AND (AA AND GT)
 Y = X AND NW
 OUT1 = Y NOT (LDBK OR VARMOS)
 OUT1 NOT MARKS 
}




//=======================================
//  SP - P+ S/D implantation DRC
//=======================================

GROUP GSP SP_?

SP_1 {
@ SP width. >= 0.160um
@ Single-point-interaction is allowed.
  OUT1 = INT SP < 0.16 ABUT < 90 REGION
  OUT1 NOT MARKS 
}

SP_2 {
@ Space between SPs. >= 0.160um
@ Single-point-interaction is allowed.
@ DRC doesn’t check INST region.
  W = EXT SP < 0.16 ABUT < 90 REGION
  OUT1 = W NOT INSIDE INST
  OUT1 NOT MARKS 
}
}

RULECHECK SP_3_R_DFM3 {
@ Space between SPs with parallel run length >0.24um, when one SP width >0.22um. >= 0.180um
  Mn_one_width SP 0.221 0.24 0.18
}

RULECHECK SP_4 {
@ Space between SPs when one or both SPs width (W1) < 0.22um. 
@ DRC only check opposite sides.	≥	0.220	um
SETLAYER X = INT \[SP\] < 0.22 OPPOSITE
SETLAYER Y = EXT X \[SP\] < 0.22 OPPOSITE
SETLAYER Z1 = LENGTH (SP TOUCH EDGE Y) < 0.22
SETLAYER Z2 = INT (Z1) SP < 0.22 OPPOSITE
SETLAYER H1 = EXT \[SP\] Z2 < 0.22 OPPOSITE
SETLAYER H2 = EXT \[X\] SP < 0.22 OPPOSITE
OUTLAYER (H2 NOT COIN EDGE H1) NOT INSIDE EDGE MARKS 
}

RULECHECK SP_5 {
@ Space between SPs with parallel run length >0.33um and SP space on STI(not INTERACT AA OR AA dummy). >= 0.25um
  Mn_one_width_PART SP 0.001 0.33 0.25
  OUTLAYER (OUT3 NOT INTERACT AA_all) NOT MARKS
}

VERBATIM {
SP_6 {
@ Space between SP and GATE along the source/drain direction. >= 0.140um
  OUT1 = EXT GATE_WE SP < 0.14 ABUT < 90 REGION OPPOSITE MEASURE ALL
  OUT1 NOT MARKS 
}

SP_7 {
@ Space between SP and GATE along GATE poly direction. >= 0.065um
@ DRC doesn’t check INST region.
  X = EXT GATE_LE SP < 0.065 ABUT < 90 REGION OPPOSITE MEASURE ALL
  OUT1 = X NOT INSIDE INST
  OUT1 NOT MARKS 
}

SP_8 {
@ Space between SP and non-butted N+AA. >= 0.065um
@ DRC doesn’t check INST region.
  X = EXT NACT SP < 0.065 ABUT > 0 < 90 REGION
  OUT1 = X NOT INSIDE INST
  OUT1 NOT MARKS 
}

SP_9 {
@ Space between SP and non-butted N+ pickup AA. >= 0.020um
  OUT1 = EXT NTAP SP < 0.02 ABUT >0 <90 SINGULAR REGION
  OUT1 NOT MARKS 
}

SP_11 {
@ Space between a butted P+ pick-up AA and NMOS GATE in the same AA.
@ DRC doesn’t check INST region.	≥	0.165	um
  X = GATE AND SN
  Y = (PTAP COIN EDGE SN) INSIDE EDGE AA
  ERROR_temp = EXT X Y < 0.165 ABUT < 90 REGION OPPOSITE
  OUT1 = ERROR_temp NOT INSIDE INST
  OUT1 NOT MARKS 
}

SP_12 {
@ Space between a butted P+ pick-up AA (in L shape AA) and NMOS GATE poly in the same AA, when this butted P+ pick-up AA extrusion:  0 < h < 0.08um ≥ 0.165um
  NAAL = NAA TOUCH INSIDE EDGE NGATE
  NAAL_EP = EXPAND EDGE NAAL OUTSIDE BY 0.08 EXTEND BY 0.01
  BUTNA_ED = PAA COIN EDGE (NAA NOT NTAP)
  BUTNA_ED_1 = BUTNA_ED INSIDE EDGE NAAL_EP
  BUTSN_1 = (PAA INTERACT PW) WITH EDGE BUTNA_ED_1
  GTSN_1 = GT INSIDE EDGE ((NAA NOT NTAP) TOUCH PAA)
  GTSN   = (GT WITH EDGE GTSN_1) TOUCH EDGE NGATE  
  OUT1 = EXT BUTSN_1 GTSN < 0.165 ABUT<90 REGION
  OUT1 NOT MARKS 
}

SP_13 {
@ SP extension outside of GATE along the source/drain direction. >= 0.140um
@ DRC doesn’t check INST region.
  X = ENC GATE_WE SP < 0.14 ABUT < 90 REGION OPPOSITE
  OUT1 = X NOT INSIDE INST
  OUT1 NOT MARKS
}

SP_14 {
@ SP extension outside of PMOS GATE along the source/drain direction where there is a butted N+ pick-up AA in the same AA ≥ 0.165um
  X = GATE AND SP
  Y = (SP COIN EDGE NTAP) INSIDE EDGE (AA INTERACT X)
  OUT1 = ENC GATE_WE Y < 0.165 ABUT < 90 REGION OPPOSITE
  OUT1 NOT MARKS
}

SP_15a {
@ SP extension outside of GATE along the GATE poly direction for core device.
@ DRC doesn’t check INST region.	≥	0.065
  X = ENC (GATE_LE TOUCH EDGE GATE_CORE) SP < 0.065 ABUT < 90 REGION OPPOSITE
  OUT1 = X NOT INSIDE INST
  OUT1 NOT MARKS
}

SP_15b {
@ SP extension outside of GATE along the GATE poly direction for IO device.
@ DRC doesn’t check INST region.	≥	0.13
 X = ENC (GATE_LE TOUCH EDGE GATE_IO) SP < 0.13 ABUT < 90 REGION OPPOSITE
  OUT1 = X NOT INSIDE INST
  OUT1 NOT MARKS
}

SP_16 {
@ SP extension outside of DG/TG. Extension=0um is allowed.
@ DRC flag the violation (INTERACT AA).	≥	0.16	um
  X = ENC DG SP < 0.16 ABUT > 0 < 90 SINGULAR REGION
  OUT1 = X INTERACT AA
  OUT1 NOT MARKS

  Y = ENC TG SP < 0.16 ABUT > 0 < 90 SINGULAR REGION
  OUT2 = Y INTERACT AA
  OUT2 NOT MARKS
}

SP_17 {
@ Enclosure of P+ AA by SP	≥	0.065	um
@ DRC doesn’t check INST region.
 X = ENC (PACT NOT COIN EDGE NTAP) SP < 0.065 ABUT < 90 REGION
 OUT1 = X NOT INSIDE INST
 OUT1 NOT MARKS 
}

SP_18 {
@ Enclosure of non-butted P+ pickup AA by SP. >= 0.020um
 OUT1 = ENC (PTAP COIN EDGE AA) SP < 0.02 ABUT < 90 REGION
 OUT1 NOT MARKS
}

SP_20 {
@ SP and AA overlap. ≥	0.080um
 OUT1 = INT SP AA < 0.08 ABUT > 0 < 90 SINGULAR REGION
 OUT1 NOT MARKS 
}

SP_21 {
@ SP and NW overlap.
@ DRC flag the violation (INTERACT AA).	≥	0.16	um
  X = INT SP NW < 0.16 ABUT > 0 < 90 SINGULAR REGION
  OUT1 = X INTERACT AA
  OUT1 NOT MARKS
}

SP_22 {
@ SP and DG overlap.
@ DRC flag the violation (INTERACT AA).	≥	0.16	um
  X = INT SP DG < 0.16 ABUT > 0 < 90 SINGULAR REGION
  OUT1 = X INTERACT AA
  OUT1 NOT MARKS
}

SP_23 {
@ SP and TG overlap.
@ DRC flag the violation (INTERACT AA).	≥	0.16	um
  X = INT SP TG < 0.16 ABUT > 0 < 90 SINGULAR REGION
  OUT1 = X INTERACT AA
  OUT1 NOT MARKS
}

SP_24 {
@ Area of SP, while (((((SP AND NW) INTERACT CT) sizing up 0.079um) sizing down 0.158um) sizing up 0.079um).
@ DRC doesn’t check INST region.
@ DRC doesn’t flag the rectangle pattern, when
@ 1.Any one of the edge length =0.33um,
@ 2. The space between any two outer vertexes =0.16um.	≥	0.1	um2
  X = (SP AND NW) INTERACT CT
  Y = SIZE (SIZE (SIZE X BY 0.079) BY -0.158) BY 0.079
  Z = AREA Y < 0.1
  WW1 = Z NOT INSIDE INST
  ALL_CHECK = Z NOT INSIDE INST

  ALL_CHECK_R = RECTANGLE ALL_CHECK == 0.33
  R_CONER = INT ALL_CHECK_R <= 0.001 ABUT == 90 REGION INTERSECTING ONLY
  R_SPACE_EDGE = EXT [R_CONER] SP == 0.16 OPPOSITE EXTENDED 0.001 MEASURE ALL
  R_CONER_SPACE = R_CONER WITH EDGE R_SPACE_EDGE
  R_WAVIE = ALL_CHECK_R INTERACT R_CONER_SPACE >= 2

  CHECK_FINAL = ALL_CHECK NOT R_WAVIE
  CHECK_FINAL NOT MARKS
}

SP_25 {
@ Area of SP. ≥	0.07um2
  OUT1 = AREA SP < 0.07
  OUT1 NOT MARKS 
}

SP_26 {
@ Enclosed area of SP, while (((((SP AND NW) INTERACT CT) sizing up 0.079um) sizing down 0.158um) sizing up 0.079um).
@ DRC doesn’t check INST region.
@ DRC doesn’t flag the rectangle pattern, when
@ 1.Any one of the edge length =0.33um,
@ 2. The space between any two inner vertexes =0.16um.	≥	0.1	um2
  X = (SP AND NW) INTERACT CT
  Y = SIZE (SIZE (SIZE X BY 0.079) BY -0.158) BY 0.079
  Z0 = (HOLES Y INNER) NOT Y
  Z = AREA Z0 < 0.1
  ALL_CHECK = Z NOT INSIDE INST

  ALL_CHECK_R = RECTANGLE ALL_CHECK == 0.33
  R_CONER = INT ALL_CHECK_R <= 0.001 ABUT == 90 REGION INTERSECTING ONLY
  R_SPACE_EDGE = ENC [R_CONER] SP == 0.16 OPPOSITE EXTENDED 0.001 MEASURE ALL
  R_CONER_SPACE = R_CONER WITH EDGE R_SPACE_EDGE
  R_WAVIE = ALL_CHECK_R INTERACT R_CONER_SPACE >= 2

  CHECK_FINAL = ALL_CHECK NOT R_WAVIE

  CHECK_FINAL NOT MARKS
}

SP_27 {
@ Enclosed area of SP. ≥ 0.07um2
  X = (HOLES SP INNER) NOT SP
  OUT1 = AREA X < 0.07
  OUT1 NOT MARKS 
}

SP_28 {
@ P+ butted AA in P-well area(the area interact with CT).
@ DRC doesn’t check INST region.	≥	0.024	um2
  X = ((PAA TOUCH SN) AND PW) INTERACT CT
  OUT1 = (AREA X < 0.024) NOT INSIDE INST
  OUT1 NOT MARKS
}

SP_29 {
@ 45-degree edge length	≥	0.52	um
 X = ANGLE SP >= 44.9 <= 45.1
 OUT1 = LENGTH X < 0.52
 OUT1 NOT INSIDE EDGE MARKS
}

SP_30 {
@ (SP AND (AA AND poly)) in PW is not allowed.
@ DRC doesn’t check LDBK, VARMOS and INST region.
  X = SP AND (AA AND GT)
  Y = X AND PW
  W = Y NOT (LDBK OR VARMOS)
  OUT1 = W NOT INSIDE INST
  OUT1 NOT MARKS
}			



//=====================================
//  SAB - Salicide Block design minima
//=====================================

GROUP GSAB SAB_?

SAB_1 {
@ Min SAB width is 0.32um
  OUT1 = INT SAB < 0.32 ABUT < 90 SINGULAR REGION
  OUT1 NOT MARKS 
}

SAB_2 {
@ Min Space between SABs is 0.32
 OUT1 = EXT SAB < 0.32 ABUT < 90 SINGULAR REGION
 OUT1 NOT MARKS
}

SAB_3 {
@ Min Extension of a related AA outside of an SAB is 0.22
 OUT1 = ENC SAB AA < 0.22 ABUT < 90 SINGULAR REGION
 OUT1 NOT MARKS
}

SAB_4 {
@ Min Space between SAB and AA is 0.22um
  OUT1 = EXT SAB AA < 0.22 ABUT < 90 SINGULAR REGION
  OUT1 NOT MARKS 
}

SAB_5 {
@ Space between SAB and GATE.
@ Overlap of SAB and GATE is not allowed.
@ This rule isn’t applicable for ESDIO1, ESDIO2, ESDCLP, ESDPOB, CLPDMY, OCOVL, INDMY region.	≥	0.38	um
  X = EXT SAB GATE < 0.38 ABUT < 90 SINGULAR REGION
  Y = SAB AND GATE
  OUT1 = (X OR Y) NOT (OR ESD_CLP OCOVL INDMY)
  OUT1 NOT MARKS
}

SAB_6a {
@ Extension of SAB outside of unsilicided AA resistor or non-silicide poly resistor. 
@ This rule isn’t applicable for ESDIO1, ESDIO2, ESDCLP, ESDPOB, CLPDMY region. 	≥	0.22	um
  X = ENC AARES_N_L SAB < 0.22 ABUT < 90 REGION
  Y = ENC GTRES_N_L SAB < 0.22 ABUT < 90 REGION
  OUT1 = (X OR Y) NOT ESD_CLP
  OUT1 NOT MARKS
}

SAB_6b {
@ Extension of SAB outside of unsilicided AA resistor or non-silicide poly resistor when SAB width and length >10um.
@ This rule isn’t applicable for ESDIO1, ESDIO2, ESDCLP, ESDPOB, CLPDMY region.	≥	0.3	um
  SAB_CHECK = SAB WITH WIDTH > 10

  X = ENC AARES_N_L SAB_CHECK < 0.3 ABUT < 90 REGION
  Y = ENC GTRES_N_L SAB_CHECK < 0.3 ABUT < 90 REGION
  OUT1 = (X OR Y) NOT ESD_CLP
  OUT1 NOT MARKS
}

SAB_6c {
@ Extension of SAB outside of unsilicided AA resistor or non-silicide poly resistor when SAB width ≤ 0.43um.
@ This rule isn’t applicable for ESDIO1, ESDIO2, ESDCLP, ESDPOB, CLPDMY region.	≥	0.3	um
  SAB_CHECK = SAB WITH WIDTH <= 0.43

  X = ENC AARES_N_L SAB_CHECK < 0.3 ABUT < 90 REGION
  Y = ENC GTRES_N_L SAB_CHECK < 0.3 ABUT < 90 REGION
  OUT1 = (X OR Y) NOT ESD_CLP
  OUT1 NOT MARKS
}

SAB_7 {
@ Min Space between SAB and CT is 0.12
  OUT1 = EXT SAB CT < 0.12 ABUT < 90 SINGULAR REGION
  OUT1 NOT MARKS
}

SAB_9 {
@ SAB area	≥	0.9	um2
 OUT1 =  AREA SAB < 0.9
 OUT1 NOT MARKS
}

SAB_10 {
@ SAB enclosed area	≥	0.9	um2
  X = (HOLES SAB INNER) NOT SAB
  OUT1 = AREA X < 0.9
  OUT1 NOT MARKS
}

SAB_11 {
@ Space between SAB and (poly on STI).	≥	0.3	um
  X0 = GT NOT AA_all
  X1 = EXT SAB X0 <= 0.001 ABUT < 90 SINGULAR REGION
  X2 = EXT SAB (X0 COIN EDGE GT) < 0.3 ABUT < 90 REGION
  OUT1 = X1 OR X2
  OUT1 NOT MARKS
}

SAB_12 {
@ SAB and poly must not overlap one another, except poly interact with RESP1, ESDIO1, ESDIO2, ESDCLP, ESDPOB, CLPDMY, INDMY.
@ DRC ignore the violation poly without CT.
  X = GT NOT INTERACT ((RESP1 OR ESD_CLP)OR INDMY)
  Y = X INTERACT CT
  OUT1 = Y AND SAB
  OUT1 NOT MARKS
}

SAB_13 {
@ AA_DMY extension outside of SAB	≥	0.12	um
  OUT1 = ENC SAB AA_DMY < 0.12 ABUT < 90 SINGULAR REGION
  OUT1 NOT MARKS 
}


//============================
//  PSR -Strained Source/Drain (PSR) design rules 
//============================

PSR_1 {
@ Strained source/drain open ratio.
@ DRC checking method:
@((((((((((((SP AND NW) NOT ((((((((DG OR TG) OR RESAA) OR RESNW) OR BIPOLA) OR DSTR) OR RESP1) OR VARMOS) OR INST)) AND (((SP AND NW) AND AA) sizing up 0.065um)) NOT PSRBL) sizing up 0.079um) sizing down 0.079um) sizing down 0.089um) sizing up 0.089um)) OR ((SP AND NW) AND INST)) OR PSRDUM) AND (AA OR AA _DMY)) NOT (GT OR POLY_DMY)) full chip density. 	≥	5.8%
  X1 = SP AND NW
  X2 = (((((((DG OR TG) OR RESAA) OR RESNW) OR BIPOLA) OR DSTR) OR RESP1) OR VARMOS) OR INST
  X3 = SIZE (X1 AND AA) BY 0.065
  X4 = ((X1 NOT X2) AND X3) NOT PSRBL
  X5 = SIZE X4 BY 0.079 OVERUNDER
  X6 = ((SIZE X5 BY 0.089 UNDEROVER) OR (X1 AND INST)) OR PSRDUM
  X7 = (X6 AND (AA OR AA_DMY)) NOT (GT OR POLY_DMY)
  
  X = X7 NOT MARKS 
  Y = DRC:1 NOT MARKS 
  
  DENSITY X Y [AREA(X)/AREA(Y)]  < 0.058 PRINT density_report_PSR_1_h.log RDB density_report_PSR_1_h.rdb
}

//============================
//  CT -Contact design minima
//============================

GROUP GCT CT_?

CTN = CT AND (RECTANGLE CT ASPECT == 1)

CT_1 {
@ Fixed contact size (square shape)
@ DRC don't check share CT in SRAM, CT in EFUSE region and OCOVL.	=	0.04um

  X = NOT RECTANGLE CT == 0.04 BY == 0.04
  ((X NOT INST) NOT EFUSE) NOT (OR OCOVL MARKS)
}

CT_2a {
@ Space between contacts is >= 0.070
@ DRC doesn’t check INST region.
  OUT1 = (EXT CTN < 0.07 ABUT < 90 SINGULAR REGION) NOT INSIDE INST
  OUT1 NOT MARKS
} 
 
CT_2b {
@ Space between CT and its neighboring CT (T). 
@ The definition of neighboring CT (T) ：
@ 1.CT ( T) is in a CT group
@ 2.The number of this CT group is ≥4, there are at least 3 CTs neighboring to CT (T)
@ 3.The space between CT (T) to other CTs in this group <0.09um
@ DRC doesn’t check INST, EFUSE region.	≥	0.085	um
  X = WITH NEIGHBOR CTN >= 3 SPACE < 0.09
  W = EXT CTN X < 0.085 ABUT < 90 SINGULAR REGION
  OUT1 = W NOT INSIDE INST
  OUT1 NOT (OR EFUSE MARKS)
}

CT_2c {
@ Space between CT on different nets is >= 0.080
@ DRC doesn’t check INST region.
  X = EXT CTN < 0.08 ABUT<90 SINGULAR REGION NOT CONNECTED
  OUT1 = X NOT INSIDE INST
  OUT1 NOT MARKS
}

CT_3 {
@ Space between AA and contact on poly is >= 0.035
@ DRC doesn’t check INST region.
  X = EXT (CTN INTERACT GT) AA < 0.035 ABUT<90 SINGULAR REGION
  OUT1 = X NOT INSIDE INST
  OUT1 NOT MARKS
}

CT_4a {
@ Space between GATE and contact on AA for core device when channel length of core device <=0.09um is >= 0.030.
@ DRC doesn’t check INST region.
  X = GATE_CORE WITH EDGE (LENGTH GATE_LE <= 0.09)
  Y = EXT X (CTN AND ACT_CT) < 0.03 ABUT < 90 SINGULAR REGION
  OUT1 = Y NOT INSIDE INST
  OUT1 NOT MARKS
}

CT_4b {
@ Space between GATE and contact on AA for core device when channel length of core device >0.09um is >= 0.040.
  X = GATE_CORE WITH EDGE (LENGTH GATE_LE > 0.09)
  OUT1 = EXT X (CTN AND ACT_CT) < 0.04 ABUT < 90 SINGULAR REGION
  OUT1 NOT MARKS
}

CT_4c {
@ Space between GATE and contact on AA for IO device is >= 0.070
  OUT1 = EXT GATE_IO (CTN AND ACT_CT) < 0.07 ABUT < 90 SINGULAR REGION
  OUT1 NOT MARKS 
}
 
CT_4d {
@ Space between (poly or GTDMP or GTDOP) and CT on AA in vertical direction.
@ DRC doesn’t check INST region.	≥	0.04 	um
  X = ANGLE GT_all_3 == 0
  OUT1 = EXT X (CTN AND ACT_CT) < 0.04 REGION
  (OUT1 NOT INSIDE INST) NOT MARKS
}

CT_5 {
@ Space between (CT AND INST) and (CT NOT INST)	≥	0.2um
 OUT1 = EXT (CTN AND INST) (CTN NOT INST) < 0.2 ABUT < 90 SINGULAR REGION
 OUT1 NOT MARKS
}

CT_6_6a_6b_6c {
@ CT.6	CT must be fully covered by AA. AA Enclosure by AA must follow (CT.6a and CT.6b) or CT.6c or CT.6d[R] or CT.6d[R] as below.DRC doesn’t check OCOVL region.			
@ CT.6a	Enclosure by AA for a CT landed on AA.	≥	0.005 	um
@       DRC doesn’t check INST AND OCOVL region
@ CT.6b	Enclosure by AA for a CT landed on AA when enclosure by AA on either perpendicular direction ≥0.005um.	≥	0.030 	um
@       DRC doesn’t check INST AND OCOVL region
@ CT.6c	Enclosure by AA, when
@       1. AA width W1: 0.07um ≤ W1≤ 0.09um, 
@       2. Space between AA and ((AA OR AADMP) OR AADOP) is 0.07um, and width of ((AA OR AADMP) OR AADOP) is 0.05um
@ DRC doesn’t check INST AND OCOVL region.	≥	0.01	um
//only for CT_6a, CT_6b
  X = RECTANGLE ENC (CTN INTERACT AA) AA ABUT < 90 SINGULAR OUTSIDE ALSO
      GOOD 0.005 OPPOSITE 0.03 OPPOSITE 0.005 OPPOSITE 0.03 OPPOSITE

  Y = (CTN INTERACT AA) NOT AA
  Z = (X OR Y) NOT INSIDE (INST OR OCOVL)

//only for CT_6c
  WW1 = AA WITH WIDTH >= 0.07 <= 0.09
  WW2 = Z NOT OUTSIDE WW1
  W3_1 = ENC WW2 [AA] < 0.01 ABUT < 90 SINGULAR
  W3 = AA TOUCH EDGE W3_1
  W4 = AA_all_3 WITH WIDTH == 0.05
  W5 = EXT [W3] W4 == 0.07 ABUT < 90 MEASURE ALL
  OUT1 = ENC WW2 W5 < 0.01 ABUT < 90 REGION
  OUT1 NOT MARKS
  (Z OUTSIDE WW1) NOT MARKS
}

CT_6a_R_DFM3 {
@ CT.6a[R] Enclosure by AA for a CT landed on AA when channel length > 0.09um to avoid high resistance.
@          DRC doesn’t check INST AND OCOVL region.	≥	0.015	um
  X = AA INTERACT (GATE WITH EDGE (LENGTH GATE_LE > 0.09))
  Y = ENC CTN X < 0.015 ABUT < 90 SINGULAR REGION
  OUT1 = Y NOT INSIDE (INST OR OCOVL)
  OUT1 NOT MARKS
}

CT_6b_R_DFM3 {
@ CT.6b[R] Enclosure by AA for a CT landed on AA when enclosure by AA on either perpendicular direction ≥ 0.005um to avoid high resistance.
@          DRC doesn’t check INST AND OCOVL region.	≥	0.04	um
  X = RECTANGLE ENC (CTN INTERACT AA) AA ABUT < 90 SINGULAR OUTSIDE ALSO
      GOOD 0.005 OPPOSITE 0.04 OPPOSITE 0.005 OPPOSITE 0.04 OPPOSITE
  OUT1 = X NOT INSIDE (INST OR OCOVL) 
  OUT1 NOT MARKS
}

CT_7_7a_7b {
@ CT.7	CT must be fully covered by ((poly sizing up 0.005um) NOT P2).
@       Enclosure by (poly or GTDMP or GTDOP) must follow (CT.7a and CT.7c) or (CT.7b and CT.7d) or (CT.7b and CT.7e) or CT.7f or (CT.7g and CT.7h) as below.@ CT.7a Enclosure by (poly or GTDMP or GTDOP) when (poly or GTDMP or GTDOP) width <0.04um.	≥	-0.005	um
@ CT.7b	Enclosure by (poly or GTDMP or GTDOP) when (poly or GTDMP or GTDOP) width ≥0.04um.
@ This rule doesn’t check poly jog region. The poly jog is defined as the rectangular with size 0.06 *0.08um.	≥	0	um
  OUT1 = (CTN INTERACT GT) NOT ((SIZE GT BY 0.005) NOT P2)
  (OUT1 NOT CT_ON_GT_JOG) NOT MARKS
  
  CT_ON_GT_JOG = CTN NOT OUTSIDE (EXPAND EDGE POLY_JOG_EDGE1 INSIDE BY 0.06) 

  X0 = CTN INTERACT GT_all_3
  X = SIZE X0 BY -0.005
  OUT2 = (X NOT INSIDE GT_all_3) NOT CT_ON_GT_JOG
  OUT2 NOT MARKS

  Y1 = INT [GT_all_3] < 0.04 OPPOSITE
  Y2 = GT_all_3 TOUCH EDGE Y1
  Z = ENC Y2 X0 <= 0.005 OPPOSITE REGION
  OUT3 = ((X0 NOT GT_all_3) NOT Z) NOT CT_ON_GT_JOG
  OUT3 NOT MARKS
}

CT_7_7c_7d_7e_7f_7g_7h {
@ CT.7 CT must be fully covered by ((poly sizing up 0.005um) NOT P2). Enclosure by (poly or GTDMP or GTDOP) must follow
@      (CT.7a and CT.7c) or (CT.7b and CT.7d) or (CT.7b and CT.7e) or CT.7f or (CT.7g and CT.7h) as below.
@ CT.7c Enclosure by (poly or GTDMP or GTDOP) when enclosure by (poly or GTDMP or GTDOP) on either perpendicular direction ≥-0.005um,
@       and (poly or GTDMP or GTDOP) width <0.04um. 	≥	0.05	um
@ CT.7d Enclosure by (poly or GTDMP or GTDOP) when enclosure by (poly or GTDMP or GTDOP) on either perpendicular direction ≥0um,
@       and (poly or GTDMP or GTDOP) width ≥0.04um and ≤0.09um. DRC doesn’t check EFUSE region.	≥ 0.05um
@ CT.7e Enclosure by (poly or GTDMP or GTDOP) when enclosure by (poly or GTDMP or GTDOP) on either perpendicular direction ≥0um, 
@       and (poly or GTDMP or GTDOP) width >0.09um.	≥	0.02	um
@ CT.7f	Enclosure by poly in the four sides when the poly width >0.09um	≥	0.015	um
@ CT. 7g Enclosure by poly jog along poly width direction 
@        The poly jog is defined as the rectangular with size 0.06 *0.08um	≥	-0.005	um
@ CT.7h	Enclosure by poly jog along poly length direction
@       The poly jog is defined as the rectangular with size 0.06 *0.08um	≥	0.020	um

//for CT_7f
  GT_FOUR = GT WITH WIDTH > 0.09
  CT_FOUR = CTN INSIDE ((SIZE (CTN NOT OUTSIDE GT_FOUR) BY 0.015) INSIDE GT)
  

//for CT.7d
  Y = GT_all_3 WITH WIDTH >= 0.04 <= 0.09
  Z = ((CTN INTERACT Y) INSIDE GT_all_3) NOT CT_FOUR
  W_temp = RECTANGLE ENC Z GT_all_3 ABUT < 90 SINGULAR
           GOOD 0 0.05 OPPOSITE 0 0.05 OPPOSITE       //bad CT for CT.7d
  W = W_temp NOT EFUSE

//for CT_7e,CT_7f
  Y1 = GT_all_3 WITH WIDTH > 0.09
  Z1 = ((CTN INSIDE Y1) INSIDE GT_all_3) NOT CT_FOUR
  OUT1 = RECTANGLE ENC Z1 GT_all_3 ABUT < 90 SINGULAR
  GOOD 0 0.02 OPPOSITE 0 0.02 OPPOSITE
  GOOD 0.015 OPPOSITE 0.015 OPPOSITE 0.015 OPPOSITE 0.015 OPPOSITE
  OUT1 NOT MARKS 

//for CT_7c
  L = (CTN INTERACT (GT_all_3 INTERACT N)) NOT INSIDE GT_all_3
  M = SIZE L BY -0.005
  N = GT_all_3 WITH WIDTH < 0.04
  OUT2 = RECTANGLE ENC (M NOT OUTSIDE N) GT_all_3 ABUT < 90 SINGULAR
  GOOD 0 0.055 OPPOSITE 0 0.055 OPPOSITE
  OUT2 NOT MARKS
 
//for CT.7g, CT.7h
  GT_REC_JOG_1 = LENGTH GT == 0.08
  GT_REC_JOG = INT GT_REC_JOG_1 GT == 0.06 REGION OPPOSITE
  Q1 = CTN NOT OUTSIDE GT_REC_JOG
  Q2 = SIZE Q1 BY -0.005
  Q3_W = (INT [GT_REC_JOG] == 0.08 OPPOSITE) COIN EDGE GT
  Q3_L = (GT_REC_JOG NOT COIN EDGE Q3_W) COIN EDGE GT
  Q4_g = Q2 OUTSIDE EDGE GT_REC_JOG
  Q4_h = ENC [Q2] Q3_W < 0.025 ABUT < 90 OPPOSITE
  Q5 = Q2 NOT WITH EDGE (Q4_g OR EDGE Q4_h)    // good CT for CT.7g, CT.7h
  OUT3 = Q2 WITH EDGE (Q4_g OR EDGE ((SIZE (CTN NOT INSIDE GT_REC_JOG) BY -0.005) COIN EDGE Q4_h ))
  OUT3 NOT MARKS  
  OUT4 = W NOT INTERACT Q5
  OUT4 NOT MARKS
}

CT_7e_R_DFM3 {
@ Recommended enclosure by poly when enclosure by poly on either perpendicular direction ≥0um, and poly width >0.09um.	≥	0.03	um
  Y1 = GT WITH WIDTH > 0.09
  Z1 = (CTN NOT OUTSIDE Y1) INSIDE GT
  OUT1 = RECTANGLE ENC Z1 GT ABUT < 90 SINGULAR
  GOOD 0 0.03 OPPOSITE 0 0.03 OPPOSITE
  OUT1 NOT MARKS
  OUT2 = (CTN NOT OUTSIDE Y1) NOT GT
  OUT2 NOT MARKS
}

CT_8a {
@ CT enclosure by AA in IO region, when space between AA and poly < 0.05um and the parallel run length between CT and S1 >0um	≥	0.015	um
  X = CTN INTERACT DGTG
  Y = EXT [AA] GT < 0.05 ABUT < 90 OPPOSITE
  OUT1 = ENC X Y < 0.015 ABUT < 90 OPPOSITE REGION
  OUT1 NOT MARKS
}

CT_8b {
@ CT enclosure by poly in IO region with the paralel run length >0um, when space between poly and AA < 0.05um and the parallel run length between CT and S1 >0um. ≥ 0.015um
  X = CTN INTERACT DGTG
  Y = EXT [GT] AA < 0.05 ABUT < 90 OPPOSITE
  OUT1 =  ENC X Y < 0.015 ABUT < 90 OPPOSITE REGION
  OUT1 NOT MARKS
}

CT_9_9a_9b_9c {
@ CT.9	CT must be fully covered by M1. Enclosure by M1 must follow (CT.9a and CT.9b) or CT.9c, and CT.9d, and CT.9f as below.			
@ CT.9a	Enclosure by M1.
@       DRC doesn’t check INST and OCOVL region.	≥	0	um
@ CT.9b	Enclosure by M1 when enclosure by M1 on either perpendicular direction ≥0um and <0.015um.
@       DRC doesn’t check INST and OCOVL region.	≥	0.02	um
@ CT.9c	Enclosure by M1 in the four sides.
@       DRC doesn’t check INST and OCOVL region.	≥	0.015	um
@ DRC doesn’t check OCCD region.
  X = RECTANGLE ENC CTN M1 ABUT > 0 < 90 SINGULAR OUTSIDE ALSO
      GOOD 0 0.02 OPPOSITE 0 0.02 OPPOSITE
      GOOD 0.015 OPPOSITE 0.015 OPPOSITE 0.015 OPPOSITE 0.015 OPPOSITE


  OUT1 = X NOT INSIDE INST
  OUT1 NOT (OR MARKS OCOVL OCCD)

  (CTN NOT M1) NOT (OR MARKS INST OCOVL OCCD)
}

CT_9_9a_9b_9c_R_DFM3 {
@ CT.9[R] CT must be fully covered by M1. Enclosure by M1 must follow (CT.9a[R] and CT.9b[R]) or CT.9c[R], and CT.9d[R], and CT.9e[R] as below.			
@ CT.9a[R] Recommended enclosure by M1.
@          DRC doesn’t check INST region.	≥	0.01	um
@ CT.9b[R] Recommended enclosure by M1 when enclosure by M1 on either perpendicular direction ≥0.01um and <0.02um.
@          DRC doesn’t check INST region.	≥	0.035	um
@ CT.9c[R] Recommended enclosure by M1 in the four sides.
@          DRC doesn’t check INST region.	≥	0.02	um
  X = RECTANGLE ENC CTN M1 ABUT < 90 SINGULAR OUTSIDE ALSO
      GOOD 0.01 OPPOSITE 0.035 OPPOSITE 0.01 OPPOSITE 0.035 OPPOSITE
      GOOD 0.02 OPPOSITE 0.02 OPPOSITE 0.02 OPPOSITE 0.02 OPPOSITE
  OUT1 = X NOT INSIDE INST
  OUT1 NOT MARKS
}}

RULECHECK CT_9d {
@ Enclosure by M1 in adjacent S1 side (M1 width ≥0.08um, M1 and M1 space S1 <0.06um, and the parallel run length >0.18um)
@ This rule doesn’t check two CTs (when CTs space <0.08um).	≥	0.015	um
  SETLAYER CT_SPECIAL = CTN NOT (WITH NEIGHBOR CTN >= 1 SPACE < 0.08 INSIDE OF LAYER M1)
  VIA_4g_CT_9d CT_SPECIAL M1 0.08 0.18 0.06 0.015
}

VERBATIM {
CT_9d_R_DFM3 {
@ Recommended enclosure by M1(M1 width ≥0.08um, M1 and M1 space <0.06um)
@ This rule doesn’t check two CTs (when CTs space <0.08um)	≥	0.015	um
  CT_SPECIAL = CTN NOT (WITH NEIGHBOR CTN >= 1 SPACE < 0.08 INSIDE OF LAYER M1)

  X = M1 WITH WIDTH >= 0.08
  Y = CT_SPECIAL NOT OUTSIDE X
  Z = ENC Y [M1] < 0.015 ABUT < 90 SINGULAR
  H = EXT (M1 WITH EDGE Z) M1 < 0.06 ABUT < 90 REGION 
  H NOT MARKS
}

CT_9e_R_DFM2 {
@ Enclosure by M1 (metal width >= 0.33um and <= 0.7um) when enclosure by M1 on either perpendicular direction >= 0.015um.
@ DRC violation is allowed if only one CT meets this rule for the redundant CTs pattern. >= 0.02um
  X0 = M1 WITH WIDTH >= 0.33 <= 0.7
  X = X0 COIN EDGE M1
  Y = RECTANGLE ENC (CTN NOT OUTSIDE X0) M1 ABUT < 90 SINGULAR
      GOOD 0.015 OPPOSITE 0.02 OPPOSITE 0.015 OPPOSITE 0.02 OPPOSITE
  Z = ENC (Y) X < 0.015 ABUT < 90 OPPOSITE
  L = Y WITH EDGE Z
  M = ((M1 INTERACT X0) AND (AA OR GT)) CUT (CTN NOT Y)
  OUT1 = L OUTSIDE M
  OUT1 NOT MARKS
}

CT_9f {
@ CT.9f	Enclosure by M1 (metal width >0.7um) in the four sides.
@       DRC violation is allowed if only one CT meets this rule for the redundant CTs pattern.	≥	0.03	um
  X0 = M1 WITH WIDTH > 0.7
  X = X0 COIN EDGE M1
  Y = RECTANGLE ENC (CTN NOT OUTSIDE X0) M1 ABUT < 90 SINGULAR
      GOOD 0.03 OPPOSITE 0.03 OPPOSITE 0.03 OPPOSITE 0.03 OPPOSITE
  Z = ENC [Y] X < 0.03 ABUT < 90 OPPOSITE
  L = Y WITH EDGE Z
  M = ((M1 INTERACT X0) AND (AA OR GT)) CUT (CTN NOT Y)
  OUT1 = L OUTSIDE M
  OUT1 NOT MARKS
}

CT_9g {
@ Enclosure by M1 when enclosure by M1 on either perpendicular direction ≥0, and M1 area < 0.014um2.	≥	0.03	um
@ DRC doesn’t check INST region.
  X = AREA M1 < 0.014
  W = RECTANGLE ENC (CTN INTERACT X) X ABUT < 90 SINGULAR OUTSIDE ALSO
      GOOD 0 0.03 OPPOSITE 0 0.03 OPPOSITE
  OUT1 = W NOT INSIDE INST
  OUT1 NOT MARKS
}

CT_10_R_DFM3 {
@ Recommended inner vertex AA enclosure of CT.
@ This rule doesn’t check the N+/P+ pickup regions	≥	0.04	um
  X = CTN NOT TAP
  Y = EXT [AA] <= 0.04 ABUT INTERSECTING ONLY
  Z = (EXPAND EDGE Y INSIDE BY 0.04 CORNER FILL) AND AA

  OUT1 = X NOT OUTSIDE Z
  OUT1 NOT MARKS
}

CT_11 {
@ CT is not allowed to land on GATE.
@ DRC doesn’t check INDMY and INST region.
  OUT1 = (CTN AND GATE) NOT INSIDE (INST OR INDMY)
  OUT1 NOT MARKS
}
		
CT_12 {
@ CT is not allowed to land on SAB, and can’t land on STI without Poly. 
@ This rule isn’t applicable for SRAM,INDMY and OCOVL region.
  X1 = CTN AND SAB
  X2 = (CTN NOT INTERACT GT) NOT AA
  OUT1 = (X1 OR X2) NOT INSIDE INST
  OUT1 NOT (OR MARKS INDMY OCOVL)
}

CT_13 {
@ CT enclosed by butted SN/SP edge on AA	≥	0.035	um
  OUT1 = ENC CTN ((SN COIN EDGE SP) NOT OUTSIDE EDGE AA) < 0.035 ABUT < 90 REGION
  OUT1 NOT MARKS
  OUT2 = ENC CTN ((SP COIN EDGE SN) NOT OUTSIDE EDGE AA) < 0.035 ABUT < 90 REGION
  OUT2 NOT MARKS
}

CT_14 {
@ 45-degree rotated CT is not allowed.
  OUT2 = CTN WITH EDGE (ANGLE CTN > 0 < 90)
  OUT2 NOT MARKS
}
			
CT_15 {
@ CT can't overlap with SN/SP boundary (for CTs on AA).
  ((CTN AND ACT_CT) CUT SN) NOT MARKS
  ((CTN AND ACT_CT) CUT SP) NOT MARKS
}

CT_17 {
@ It’s not allowed CT overlap with AA/poly silicided resistor.
@ Pls refer the deinfition of AA/poly silicided resistor in AA/poly resistor section.
  (CTN AND AARES_S) NOT MARKS
  (CTN AND GTRES_S) NOT MARKS
}
}

RULECHECK CT_18 {
@ It’s not allowed CT connects to ≥5V net outside DG/TG region.

  for { set j 1 } { $j <= [llength $inter_metal_list_with_name_mapping] } { incr j } {

SETLAYER X$j = NET AREA RATIO M1 (M${j} INTERACT M${j}V50) > 0
    
    lappend CT_18_list X$j
  }

SETLAYER Y1 = OR $CT_18_list
SETLAYER Y2 = M1 AND Y1
SETLAYER Y3 = CTN OUTSIDE DGTG
OUTLAYER (Y3 INTERACT Y2) NOT MARKS
}
		



#//===========================
#// M1 - Metal 1 design rules
#//===========================

GROUP GM1 M1_?

SETLAYER M1_all_noinst = M1_all NOT INSIDE INST

RULECHECK M1_1 {
@ Mn width. >= 0.050um and <= 4.5
  OUTLAYER (M1_all WITH WIDTH > 4.5) NOT MARKS
  OUTLAYER (INT M1_all < 0.05 ABUT < 90 SINGULAR REGION) NOT MARKS
}

RULECHECK M1_2a {
@ Width of 45-degree M1.
@ The vertex of 45-degree pattern should be on 0.005um grid.
@ DRC doesn’t check INDMY region for the vertex of 45-degree pattern grid.	≥	0.170	um
  SETLAYER X = ANGLE M1 >= 44.9 <= 45.1
  OUTLAYER (INT X < 0.17 OPPOSITE REGION) NOT MARKS

  OUTLAYER (DFM COPY (OFFGRID (X NOT INSIDE EDGE INDMY) 5) REGION ) NOT MARKS 
}

RULECHECK M1_2b {
@ Length of 45-degree M1. ≥ 0.5um
 SETLAYER X = ANGLE M1 >= 44.9 <= 45.1
 OUTLAYER (LENGTH X < 0.5) NOT INSIDE EDGE MARKS   
}

RULECHECK M1_3 {
@ M1 edge length when the adjacent edge < 0.05um, and these two edges formed by 3 consecutive 270 degree inner vertex-90 degree outer vertex-270 degree inner vertex.
@ DRC doesn't flag if there is M1 in the region which is formed by 0.16um extension from these two edges and the 90-degree outer vertex.
@ DRC doesn’t check INST region.	≥	0.065	um
 angle_consecutive_PART M1_all_noinst
 OUTLAYER (OUT3 NOT INSIDE EDGE INST) NOT INSIDE EDGE MARKS
}

RULECHECK M1_4_R_DFM3 {
@ Recommended M1 width, when
@ 1. Space between M1 and two side-wall M1 is 0.05 um, with parallel run length> 0.16um;
@ 2. CT/V1 enclosure by this M1: 0.02um≤E1≤0.03um;
@ 3. Space between this M1 line end and M1: 0.07um≤S≤ 0.08um.	≥	0.06	um
SETLAYER  X_EDGE = EXT M1 == 0.05 ABUT < 90 OPPOSITE
SETLAYER  X_REGION = EXT M1 == 0.05 ABUT < 90 OPPOSITE REGION
SETLAYER  Y_REGION = DFM PROPERTY X_REGION X_EDGE OVERLAP ABUT ALSO MULTI \[-= EC(X_EDGE)\] > 0.16
SETLAYER  Y_EDGE = (M1 COIN EDGE (DFM COPY X_EDGE EDGE)) COIN EDGE Y_REGION
SETLAYER  Z_EDGE = INT Y_EDGE < 0.06 ABUT < 90 OPPOSITE
SETLAYER  Z_REGION = INT Y_EDGE < 0.06 ABUT < 90 OPPOSITE REGION
SETLAYER  H_REGION = DFM PROPERTY Z_REGION Z_EDGE OVERLAP ABUT ALSO MULTI \[-= EC(Z_EDGE)\] > 0.16

SETLAYER  P = (M1 INTERACT H_REGION) NOT COIN EDGE ((DFM COPY Z_EDGE EDGE) COIN EDGE H_REGION)
SETLAYER  Q1 = ENC CT \[P\] >= 0.02 <= 0.03 OPPOSITE
SETLAYER  Q2 = ENC V1 \[P\] >= 0.02 <= 0.03 OPPOSITE
SETLAYER  R = P TOUCH EDGE (Q1 OR EDGE Q2)
SETLAYER  T = EXT \[R\] M1 >= 0.07 <= 0.08
OUTLAYER  (H_REGION WITH EDGE T) NOT MARKS
}

RULECHECK M1_5a	{
@ Space between two M1s. >= 0.050um
@ DRC doesn’t check INST region.
  OUTLAYER ((EXT M1_all_noinst < 0.05 ABUT < 90 SINGULAR REGION) NOT INSIDE INST) NOT MARKS
}

RULECHECK M1_5b	{
@ Space between two M1s when one or both M1s widths are>0.1um, and parallel run length of two M1s is >0.22um. >= 0.060um
 Mn_one_width M1_all 0.101 0.22 0.06 
}

RULECHECK M1_5c	{
@ Space between two M1s when one or both M1s widths are>0.18um, and parallel run length of two M1s is >0.22um. >= 0.1um
 Mn_one_width M1_all 0.181 0.22 0.1
}

RULECHECK M1_5d {
@ Space between two M1s when one or both M1 widths are>0.47um, and parallel run length of two M1s is >0.47um.	≥ 0.13um
 Mn_one_width M1_all 0.471 0.47 0.13
}
RULECHECK M1_5e {
@ Space between two M1s when one or both M1 widths are>0.63um, and parallel run length of two M1s is >0.63um.	≥	0.15um
 Mn_one_width M1_all 0.631 0.63 0.15
}

RULECHECK M1_5f {
@ Space between two M1s when one or both M1s width are >1.5um, and parallel run length of two M1s is >1.5um. >= 0.500um
  Mn_one_width M1_all 1.501 1.5 0.5
}

RULECHECK M1_6a {
@ Space between M1 and M1 line end, and the parallel run length is >-0.025um. 
@ M1 line-end definition: M1 edge with length < 0.07um (W) between two outer vertex, ANGLE1=ANGLE2=90, adjacent edge A1/A2 ≥ 0.05um.
@ DRC doesn’t check INST region.	≥	0.06	um
 SETLAYER M1_end = CONVEX EDGE M1_all_noinst ANGLE1 == 90 LENGTH1 >= 0.05 ANGLE2 == 90 LENGTH2 >= 0.05 WITH LENGTH < 0.07
 SETLAYER W = EXT M1_end M1_all < 0.06 REGION OPPOSITE EXTENDED 0.025
 OUTLAYER (W NOT INSIDE INST) NOT MARKS
}

RULECHECK M1_6b {
@ Space between M1 and dense M1 line-end, when parallel run length >-0.025um.
@ 1. M1 line-end definition: M1 edge with length < 0.07um (W) between two outer vertex, ANGLE1=ANGLE2=90, adjacent edge A1/A2 ≥ 0.05um;
@ 2. Dense M1 line end definition: (W+S) <0.12um, other metal must be in the region R, L1 and L2 is the extension from metal line end, 
@    L1< 0.025um, L2 <0.07um, S should be the space between separate metal.
@ DRC doesn’t check INST region.	≥	0.07	um
 SETLAYER M1_end_s = CONVEX EDGE M1_all_noinst ANGLE1 == 90 LENGTH1 >= 0.05 ANGLE2 == 90 LENGTH2 >= 0.05 WITH LENGTH < 0.07
 SETLAYER X0 = EXT M1_all \[M1_end_s\] < 0.07 OPPOSITE EXTENDED 0.025
 SETLAYER X = M1_end_s TOUCH EDGE X0
 SETLAYER Y = INT X \[M1_all\] < 0.001 ABUT INTERSECTING ONLY
 SETLAYER Y1 = INT X M1_all < 0.001 ABUT INTERSECTING ONLY REGION

 SETLAYER T1 = EXPAND EDGE X INSIDE BY 0.069-0.024
 SETLAYER Y2 = T1 TOUCH EDGE Y
 SETLAYER Z0 = ENC M1_all \[Y2\] < 0.12 MEASURE ALL OPPOSITE EXTENDED 0.025
 SETLAYER Z1 = (ENC M1_all Y2 < 0.12 MEASURE ALL OPPOSITE EXTENDED 0.025 REGION) INTERACT M1_all > 1
 SETLAYER Z = Z0 COIN EDGE Z1
 SETLAYER W = Y2 TOUCH EDGE Z
 OUTLAYER ((X TOUCH EDGE (Y1 WITH EDGE W)) NOT INSIDE EDGE INST) NOT INSIDE EDGE MARKS
}

RULECHECK M1_7_R_DFM3 {
@ Space between (M1 or dummy M1).
@ DRC check maximum width of (NOT (M1 or dummy M1)) in chip region.
@ DRC doen’t check chip corner triangle region (NODMF) sizing up 0.4um and LOGO AND INDMY.	≤	4.5	um
  SETLAYER X = ((DRC:1 NOT M1_all) NOT (SIZE NODMF BY 0.4)) NOT (LOGO OR INDMY)
  OUTLAYER (X WITH WIDTH > 4.5) NOT MARKS
}

RULECHECK M1_9 {
@ Space between 45-degree bent M1 and M1 >= 0.17um
  SETLAYER X = ANGLE M1_all >= 44.9 <= 45.1
  OUTLAYER (EXT X M1_all < 0.17 REGION) NOT MARKS
}

RULECHECK M1_10 {
@ Space between two M1s when one or both of M1 connects to 3.3V net 	≥	0.07um
  OUTLAYER (EXT M1_voltage_33 M1 < 0.07 ABUT < 90 SINGULAR REGION) NOT MARKS
}

RULECHECK M1_11a {
@ Space between M1 line and line when one or both of M1 connects to 5V net, parallel run length>-0.11um.
@ M1 line definition: M1 edge ≥ 0.08um.	≥	0.11	um
  SETLAYER M1_line = LENGTH M1 >= 0.08
  SETLAYER X = M1_voltage_50 COIN EDGE M1_line
  OUTLAYER (EXT X M1_line < 0.11 REGION OPPOSITE EXTENDED 0.11) NOT MARKS
}

RULECHECK M1_11b {
@ Space between M1 line and line end when one or both of M1 connects to 5V net, parallel run length >-0.14um.
@ M1 line end definition: M1 edge < 0.08um between two outer vertex.
@ M1 line definition: NOT M1 line end.	≥	0.14	um
  SETLAYER M1_line = M1 NOT COIN EDGE M1_end
  SETLAYER M1_end = CONVEX EDGE M1 == 2 WITH LENGTH < 0.08
  SETLAYER X = M1 INTERACT M1_voltage_50
  SETLAYER Y1 = M1_line COIN EDGE X
  SETLAYER Y2 = M1_end COIN EDGE X
  OUTLAYER (EXT Y1 M1_end < 0.14 REGION OPPOSITE EXTENDED 0.14) NOT MARKS
  OUTLAYER (EXT Y2 M1_line < 0.14 REGION OPPOSITE EXTENDED 0.14) NOT MARKS
}

RULECHECK M1_11c {
@ Space between M1 line end and line end when one or both of M1 connects to 5V net, parallel run length >-0.12um.
@ M1 line end definition: M1 edge < 0.08um between two outer vertex.	≥	0.12	um
  SETLAYER M1_end = CONVEX EDGE M1 == 2 WITH LENGTH < 0.08
  SETLAYER X = (M1 INTERACT M1_voltage_50) COIN EDGE M1_end
  OUTLAYER (EXT X M1_end < 0.12 REGION OPPOSITE EXTENDED 0.12) NOT MARKS
}

RULECHECK M1_12 {
@ Space between M1 and neighboring V1 when either V1 or M1 connects to 1.5V net.	≥	0.06	um
@ DRC doesn't check M1 which the neighboring V1 is landed
OUTLAYER ((EXT M1_voltage_15 V1 < 0.06 ABUT < 90 SINGULAR REGION MEASURE ALL) INTERACT M1>1 ) NOT MARKS
OUTLAYER ((EXT V1_voltage_15 M1 < 0.06 ABUT < 90 SINGULAR REGION MEASURE ALL) INTERACT M1>1 ) NOT MARKS
}

RULECHECK M1_13 {
@ Space between M1 and neighboring V1 when either V1 or M1 connects to 1.8V and 2.5V net. ≥ 0.08um
@ DRC doesn't check M1 which the neighboring V1 is landed
OUTLAYER ((EXT (M1_voltage_18 OR M1_voltage_25) V1 < 0.08 ABUT < 90 SINGULAR REGION MEASURE ALL) INTERACT M1>1 ) NOT MARKS
OUTLAYER ((EXT (V1_voltage_18 OR V1_voltage_25) M1 < 0.08 ABUT < 90 SINGULAR REGION MEASURE ALL) INTERACT M1>1 ) NOT MARKS
}

RULECHECK M1_14 {
@ Space between M1 and neighboring V1 when either V1 or M1 connects to 3.3V net. ≥ 0.087um
@ DRC doesn't check M1 which the neighboring V1 is landed
OUTLAYER ((EXT M1_voltage_33 V1 < 0.087 ABUT < 90 SINGULAR REGION MEASURE ALL) INTERACT M1>1 ) NOT MARKS
OUTLAYER ((EXT V1_voltage_33 M1 < 0.087 ABUT < 90 SINGULAR REGION MEASURE ALL) INTERACT M1>1 ) NOT MARKS
}

RULECHECK M1_15 {
@ Space between M1 and neighboring V1 when either V1 or M1 connects to 5V net.	≥ 0.165um
@ DRC doesn't check M1 which the neighboring V1 is landed
OUTLAYER ((EXT M1_voltage_50 V1 < 0.165 ABUT < 90 SINGULAR REGION MEASURE ALL) INTERACT M1>1 ) NOT MARKS
OUTLAYER ((EXT V1_voltage_50 M1 < 0.165 ABUT < 90 SINGULAR REGION MEASURE ALL) INTERACT M1>1 ) NOT MARKS
}

RULECHECK M1_17a {
@ M1 area.
@ DRC doesn’t check INST region. ≥ 0.0115um2
  SETLAYER X = AREA M1_all_noinst < 0.0115
  OUTLAYER X NOT MARKS
}

RULECHECK M1_17a_R_DFM3 {
@ Recommended M1 area	≥	0.023um2
  OUTLAYER (AREA M1 < 0.023) NOT MARKS
}

RULECHECK M1_17b {
@ M1 area when all of M1 edge length < 0.2um, any M1 edge length≥ 0.13um
@ This rule doesn’t check the patterns which can fill 0.05um * 0.2um rectangular pattern and doesn’t check INST region.≥	0.014	um2
  SETLAYER M1_ignore = ENCLOSE RECTANGLE M1_all 0.05 0.2 ORTHOGONAL ONLY
  SETLAYER M1_check_temp = AREA M1_all < 0.014
  OUTLAYER (((M1_check_temp WITH EDGE (LENGTH M1_check_temp >= 0.13)) NOT WITH EDGE (LENGTH M1_check_temp >= 0.2)) NOT M1_ignore) NOT (OR INST MARKS)
}

RULECHECK M1_17c {
@ M1 area when all of M1 edge length < 0.13um.
@ This rule doesn’t check the patterns which can fill 0.05um*0.13um rectangular pattern, and doesn’t check INST region.≥	0.04	um2
  SETLAYER M1_ignore = ENCLOSE RECTANGLE M1_all 0.05 0.13 ORTHOGONAL ONLY 
  SETLAYER M1_check_temp = AREA M1_all  < 0.04
  OUTLAYER ((M1_check_temp NOT WITH EDGE (LENGTH M1_check_temp >= 0.13)) NOT M1_ignore) NOT (OR INST MARKS)
}

RULECHECK M1_18 {
@ Dielectric area enclosed by M1	≥	0.2	um2
  SETLAYER X = (HOLES M1_all INNER) NOT M1_all
  OUTLAYER (AREA X < 0.2) NOT MARKS
}

RULECHECK M1_19_l {
@ M1 density (including dummy). Density check window size: 125um*125um, step size: 62.5um. ≥ 10% and ≤ 85%
  SETLAYER X = M1_all NOT MARKS 
  SETLAYER Y = DRC:1 NOT MARKS 
  SETLAYER Z = COPY Y 
  OUTLAYER DENSITY X Y \[AREA(X)/AREA(Y)\] < 0.1 WINDOW 125 STEP 62.5  BACKUP PRINT density_report_M1_19_l.log RDB density_report_M1_19_l.rdb
}

RULECHECK M1_19_h {
@ M1 density (including dummy). Density check window size: 125um*125um, step size: 62.5um. ≥ 10% and ≤ 85%
  SETLAYER X = M1_all NOT MARKS
  SETLAYER Y = DRC:1 NOT MARKS 
  SETLAYER Z = COPY Y
  OUTLAYER DENSITY X Y \[AREA(X)/AREA(Y)\]  > 0.85 WINDOW 125 STEP 62.5  BACKUP PRINT density_report_M1_19_h.log RDB density_report_M1_19_h.rdb 
}
	
RULECHECK M1_20 {
@ The density difference between any two neighboring checking windows (window 200*200, stepping 200um).
@ DRC don’t check: chip corner triangle region (NODMF) sizing up 0.4um if seal ring is added by SMIC.	≤	50%
 SETLAYER X = (M1_all NOT MARKS) NOT (SIZE NODMF BY 0.4)
 SETLAYER Y = (DRC:1 NOT MARKS) NOT (SIZE NODMF BY 0.4)
 SETLAYER Z = COPY Y 
 OUTLAYER  DENSITY X Y \[AREA(X)/AREA(Y)\] >= 0 WINDOW 200 GRADIENT > 0.5 ABSOLUTE BACKUP  PRINT density_report_M1_20.log RDB density_report_M1_20.rdb
}
	
RULECHECK M1_21_R_DFM2 {
@ M1 density (including dummy) in DUMBM and M1DUB region. Density check window size: 125um*125um, step size: 62.5um.
@ DRC need check the design if DUMBM/M1DUB width is >5um and<125um, where density ratio= M1 area/(DUMBM/M1DUB)area. ≥ 10% ≤ 85%
 SETLAYER  DUMBMP = DUMBM OR M1DUB
 SETLAYER  X = ENCLOSE RECTANGLE DUMBMP 125 125 ORTHOGONAL ONLY
 SETLAYER  X1 =  M1_all NOT MARKS 
 SETLAYER  X2 = X NOT MARKS 
 SETLAYER  X3 = COPY X2 
 OUTLAYER  DENSITY X1 X2 \[AREA(X1)/AREA(X2)\] < 0.10 WINDOW 125 STEP 62.5 BACKUP  PRINT density_report_M1_21_l.log RDB density_report_M1_21_l_1.rdb
 OUTLAYER  DENSITY X1 X2 \[AREA(X1)/AREA(X2)\] > 0.85 WINDOW 125 STEP 62.5 BACKUP  PRINT density_report_M1_21_h.log RDB density_report_M1_21_h_1.rdb
 SETLAYER  Y = (ENCLOSE RECTANGLE DUMBMP 5.001 5.001 ORTHOGONAL ONLY) NOT (X OR MARKS)
 SETLAYER  Z1 = DFM PROPERTY Y X1 \[ RATIO = AREA(X1)/AREA(Y) \] < 0.1
 SETLAYER  Z2 = DFM PROPERTY Y X1 \[ RATIO = AREA(X1)/AREA(Y) \] > 0.85
 OUTLAYER  DFM RDB Z1 density_report_M1_21_l_2.rdb
 OUTLAYER  DFM RDB Z2 density_report_M1_21_h_2.rdb
 OUTLAYER  (Z1 OR Z2) NOT MARKS 
}

RULECHECK M1_22 {
@ M1 density (including dummy).Density check window size:  80um*80umum, step size 40um
@ DRC don’t check:  
@ 1. Chip corner triangle region(NODMF) sizing up 0.4um if seal ring is added by SMIC.
@ 2. The region covered by LDNMK1.
@ DRC only check the region with width of (checking window NOT above excluding region) ≥ 40um 	≥ 	1%.
  SETLAYER X0 = (SIZE NODMF BY 0.4) OR (LDNMK1 OR MARKS )  
  SETLAYER X1 = M1_all NOT X0
  SETLAYER X2 = DRC:1 NOT X0 
  SETLAYER X3 = COPY X2 
  SETLAYER X = DENSITY X1 X2 \[AREA(X1)/AREA(X2)\] < 0.01 WINDOW 80 STEP 40  BACKUP PRINT density_report_M1_22.log RDB density_report_M1_22.rdb
  OUTLAYER X WITH WIDTH >= 40
}

RULECHECK M1_23 {
@ Maximum M1 area of merged low density windows must follow item (1) and (2).
@ The definition of low density window: window size 10um*10um, step size: 5um, density <1%
@ (1) Maximum area of merged low density window ≤ 6000um2, except merged low density windows width ≤ 30um.
@ (2) Maximum area of merged low density window ≤ 16000um2.
@ DRC don’t check: 
@ 1. Chip corner triangle region (NODMF) sizing up 0.4um if seal ring is added by SMIC.
@ 2. The region covered by LDNMK1.
@ DRC only check the region with width of (checking window NOT above excluding region) ≥ 5um
  SETLAYER X0 = (SIZE NODMF BY 0.4) OR (LDNMK1 OR MARKS)
  SETLAYER X1 = M1_all NOT X0
  SETLAYER X2 = DRC:1 NOT X0
  SETLAYER X3 = COPY X2
  SETLAYER X = DENSITY X1 X2 \[AREA(X1)/AREA(X2)\] < 0.01 WINDOW 10 STEP 5  BACKUP PRINT density_report_M1_23.log RDB density_report_M1_23.rdb
  OUTLAYER (AREA X > 6000) WITH WIDTH > 30
  OUTLAYER (AREA X > 16000) WITH WIDTH >= 5
}

RSPMn_1_2_3_LOTA RSP_M1_25 1 0.29 0.25 0.3 0.22 0.08 0.1 0.06 0.3
RULECHECK M1_25 {
@ Space of metal space segments with S2 < 0.08 and L2 ≤ 0.22um.
@ Metal space segments definition:
@ 1). at least one metal line width > 0.25um (W1) and the parallel run length > 0.3um (L1) in metal space < 0.29um (S1) region;
@ 2). metal space segments within metal space (S1) region and are generated by space cut line which is perpendicular with L1 direction formed by
@     all vertex in metal space region (S1); 
@ 3). metal space segments at least abut one metalwith width > 0.25um (W1);
@ 4). L2 is the width of metal space segments which is parallel with L1 direction;
@ 5). S2 is the width of metal space segments which is perpendicular with L1 direction.	≥	0.3	um
OUTLAYER RSP_M1_25_OUT1 NOT MARKS 
}

RULECHECK M1_25a {
@ Width (S2) of metal space segments with L2 > 0.22um
@ Metal space segments definition:
@ 1). at least one metal line width > 0.25um (W1) and the parallel run length > 0.3um (L1) in metal space < 0.29um (S1) region;
@ 2). metal space segments within metal space (S1) region and are generated by space cut line which is perpendicular with L1 direction formed by
@     all vertex in metal space region (S1); 
@ 3). metal space segments at least abut one metalwith width > 0.25um (W1);
@ 4). L2 is the width of metal space segments which is parallel with L1 direction;
@ 5). S2 is the width of metal space segments which is perpendicular with L1 direction.	≥	0.1	um
OUTLAYER RSP_M1_25_OUT2 NOT MARKS 
}

RULECHECK M1_25b {
@ Width (S2) of metal space segments with L2 ≤ 0.22um
@ Metal space segments definition:
@ 1). at least one metal line width > 0.25um (W1) and the parallel run length > 0.3um (L1) in metal space < 0.29um (S1) region;
@ 2). metal space segments within metal space (S1) region and are generated by space cut line which is perpendicular with L1 direction formed by
@     all vertex in metal space region (S1); 
@ 3). metal space segments at least abut one metalwith width > 0.25um (W1);
@ 4). L2 is the width of metal space segments which is parallel with L1 direction;
@ 5). S2 is the width of metal space segments which is perpendicular with L1 direction.	≥	0.06	um
OUTLAYER RSP_M1_25_OUT3 NOT MARKS 
}

RSPMn_1_2_3_LOTA RSP_M1_25c 1 0.19 0.25 0.3 0.22 0.1 0.1 0.06 0.3
RULECHECK M1_25c {
@ Space of metal space segments with S2 < 0.1 and L2 ≤ 0.22um.
@ Metal space segments definition:
@ 1). at least one metal line width > 0.25um (W1) and the parallel run length > 0.3um (L1) in metal space < 0.19um (S1) region;
@ 2). metal space segments within metal space (S1) region and are generated by space cut line which is perpendicular with L1 direction formed by
@     all vertex in metal space region (S1); 
@ 3). metal space segments at least abut one metalwith width > 0.25um (W1);
@ 4). L2 is the width of metal space segments which is parallel with L1 direction;
@ 5). S2 is the width of metal space segments which is perpendicular with L1 direction.	≥	0.3	um
OUTLAYER  RSP_M1_25c_OUT1 NOT MARKS 
}

RSPMn_1_2_3_LOTA RSP_M1_26 1 0.32 0.47 0.5 0.22 0.13 0.13 0.06 0.3
RULECHECK M1_26 {
@ Space of metal space segments with S2 < 0.13 and L2 ≤ 0.22um.
@ Metal space segments definition:
@ 1). at least one metal line width > 0.47um (W1) and the parallel run length > 0.5um (L1) in metal space < 0.32um (S1) region;
@ 2). metal space segments within metal space (S1) region and are generated by space cut line which is perpendicular with L1 direction formed by
@     all vertex in metal space region (S1); 
@ 3). metal space segments at least abut one metalwith width > 0.47um (W1);
@ 4). L2 is the width of metal space segments which is parallel with L1 direction;
@ 5). S2 is the width of metal space segments which is perpendicular with L1 direction.	≥	0.3	um
OUTLAYER RSP_M1_26_OUT1 NOT MARKS 
}

RULECHECK M1_26a {
@ Width (S2) of metal space segments with L2 > 0.22um
@ Metal space segments definition:
@ 1). at least one metal line width > 0.47um (W1) and the parallel run length > 0.5um (L1) in metal space < 0.32um (S1) region;
@ 2). metal space segments within metal space (S1) region and are generated by space cut line which is perpendicular with L1 direction formed by
@     all vertex in metal space region (S1); 
@ 3). metal space segments at least abut one metalwith width > 0.47um (W1);
@ 4). L2 is the width of metal space segments which is parallel with L1 direction;
@ 5). S2 is the width of metal space segments which is perpendicular with L1 direction.	≥	0.13	um
OUTLAYER RSP_M1_26_OUT2 NOT MARKS 
}

RULECHECK M1_26b {
@ Width (S2) of metal space segments with L2 ≤ 0.22um
@ Metal space segments definition:
@ 1). at least one metal line width > 0.47um (W1) and the parallel run length > 0.5um (L1) in metal space < 0.32um (S1) region;
@ 2). metal space segments within metal space (S1) region and are generated by space cut line which is perpendicular with L1 direction formed by
@     all vertex in metal space region (S1); 
@ 3). metal space segments at least abut one metalwith width > 0.47um (W1);
@ 4). L2 is the width of metal space segments which is parallel with L1 direction;
@ 5). S2 is the width of metal space segments which is perpendicular with L1 direction.	≥	0.06	um
OUTLAYER RSP_M1_26_OUT3 NOT MARKS
}

RSPMn_1_2_3_LOTA RSP_M1_27 1 0.34 0.63 0.7 0.22 0.15 0.15 0.06 0.3
RULECHECK M1_27 {
@ Space of metal space segments with S2 < 0.15 and L2 ≤ 0.22um.
@ Metal space segments definition:
@ 1). at least one metal line width > 0.63um (W1) and the parallel run length > 0.7um (L1) in metal space < 0.34um (S1) region;
@ 2). metal space segments within metal space (S1) region and are generated by space cut line which is perpendicular with L1 direction formed by
@     all vertex in metal space region (S1); 
@ 3). metal space segments at least abut one metalwith width > 0.63um (W1);
@ 4). L2 is the width of metal space segments which is parallel with L1 direction;
@ 5). S2 is the width of metal space segments which is perpendicular with L1 direction.	≥	0.3	um
OUTLAYER  RSP_M1_27_OUT1 NOT MARKS
}

RULECHECK M1_27a {
@ Width (S2) of metal space segments with L2 > 0.22um
@ Metal space segments definition:
@ 1). at least one metal line width > 0.63um (W1) and the parallel run length > 0.7um (L1) in metal space < 0.34um (S1) region;
@ 2). metal space segments within metal space (S1) region and are generated by space cut line which is perpendicular with L1 direction formed by
@     all vertex in metal space region (S1); 
@ 3). metal space segments at least abut one metalwith width > 0.63um (W1);
@ 4). L2 is the width of metal space segments which is parallel with L1 direction;
@ 5). S2 is the width of metal space segments which is perpendicular with L1 direction.	≥	0.15	um
OUTLAYER RSP_M1_27_OUT2 NOT MARKS 
}

RULECHECK M1_27b {
@ Width (S2) of metal space segments with L2 ≤ 0.22um
@ Metal space segments definition:
@ 1). at least one metal line width > 0.63um (W1) and the parallel run length > 0.7um (L1) in metal space < 0.34um (S1) region;
@ 2). metal space segments within metal space (S1) region and are generated by space cut line which is perpendicular with L1 direction formed by
@     all vertex in metal space region (S1); 
@ 3). metal space segments at least abut one metalwith width > 0.63um (W1);
@ 4). L2 is the width of metal space segments which is parallel with L1 direction;
@ 5). S2 is the width of metal space segments which is perpendicular with L1 direction.	≥	0.06	um
OUTLAYER RSP_M1_27_OUT3 NOT MARKS 
}

RSPMn_1_2_3_LOTA RSP_M1_28 1 0.5 1.5 1.5 0.22 0.3 0.3 0.06 0.3
RULECHECK M1_28 {
@ Space of metal space segments with S2 < 0.3 and L2 ≤ 0.22um.
@ Metal space segments definition:
@ 1). at least one metal line width > 1.5um (W1) and the parallel run length > 1.5um (L1) in metal space < 0.5um (S1) region;
@ 2). metal space segments within metal space (S1) region and are generated by space cut line which is perpendicular with L1 direction formed by
@     all vertex in metal space region (S1); 
@ 3). metal space segments at least abut one metalwith width > 1.5um (W1);
@ 4). L2 is the width of metal space segments which is parallel with L1 direction;
@ 5). S2 is the width of metal space segments which is perpendicular with L1 direction.	≥	0.3	um
OUTLAYER RSP_M1_28_OUT1 NOT MARKS 
}

RULECHECK M1_28a {
@ Width (S2) of metal space segments with L2 > 0.22um
@ Metal space segments definition:
@ 1). at least one metal line width > 1.5um (W1) and the parallel run length > 1.5um (L1) in metal space < 0.5um (S1) region;
@ 2). metal space segments within metal space (S1) region and are generated by space cut line which is perpendicular with L1 direction formed by
@     all vertex in metal space region (S1); 
@ 3). metal space segments at least abut one metalwith width > 1.5um (W1);
@ 4). L2 is the width of metal space segments which is parallel with L1 direction;
@ 5). S2 is the width of metal space segments which is perpendicular with L1 direction.	≥	0.3	um
OUTLAYER RSP_M1_28_OUT2 NOT MARKS 
}

RULECHECK M1_28b {
@ Width (S2) of metal space segments with L2 ≤ 0.22um
@ Metal space segments definition:
@ 1). at least one metal line width > 1.5um (W1) and the parallel run length > 1.5um (L1) in metal space < 0.5um (S1) region;
@ 2). metal space segments within metal space (S1) region and are generated by space cut line which is perpendicular with L1 direction formed by
@     all vertex in metal space region (S1); 
@ 3). metal space segments at least abut one metalwith width > 1.5um (W1);
@ 4). L2 is the width of metal space segments which is parallel with L1 direction;
@ 5). S2 is the width of metal space segments which is perpendicular with L1 direction.	≥	0.06	um
OUTLAYER RSP_M1_28_OUT3 NOT MARKS 
}

RULECHECK M1_29 {
@ It is not allowed for M1 zone, and M1 Zone definition as below:
@ 1), W1, W3 and W5 are same polygons, W2 and W4 are same polygons;
@ 2), Width of M1 (W2,W3,W4) = 0.05um;
@ 3), Space of M1 (S1,S2,S3,S4) =0.05um;
@ 4), Space of M1 line-end to opposite M1(S5) < 0.08um;
@ 5), parallel run length of 5 M1 lines L1 <= 0.4um.
SETLAYER X0 = INT M1 == 0.05 REGION OPPOSITE 
SETLAYER X2 = (EXT X0 M1 == 0.05 REGION OPPOSITE) NOT WITH EDGE (LENGTH X20 > 0.4) 
SETLAYER X20 = EXT \[X0\] M1 == 0.05 OPPOSITE
SETLAYER X3 = X0 TOUCH X2 == 2 
SETLAYER X4 = X3 OR (X2 TOUCH X3) 
SETLAYER X5 = EXT M1 == 0.15 REGION OPPOSITE NOTCH EXCLUDE SHIELDED 
SETLAYER X6 = EXT \[M1\] == 0.15  OPPOSITE NOTCH EXCLUDE SHIELDED 
SETLAYER X7 = (M1 NOT (X0 TOUCH X5 == 3)) TOUCH EDGE  (X0 TOUCH X5 == 3)  
SETLAYER X8 = EXT X0 X7 <= 0.08 OPPOSITE  REGION 
SETLAYER X9 = ((X0 TOUCH X5 == 3) NOT TOUCH EDGE X6) TOUCH EDGE X5 
SETLAYER X10 = (X5 WITH EDGE X9) NOT TOUCH EDGE ( EXT X9 M1 <= 0.08 REGION OPPOSITE)  
SETLAYER X11 = EXPAND EDGE (X0 TOUCH EDGE X10) INSIDE BY 0.05   
SETLAYER X12 = ((M1 WITH EDGE ( EXT X9 \[M1\] <= 0.08 OPPOSITE)) NOT  X11) TOUCH EDGE X11 
SETLAYER XS2 =  EXT X12 \[M1\] <= 0.08  OPPOSITE 
OUTLAYER  (X4 ENCLOSE ((X0 WITH EDGE XS2) TOUCH ((X5 TOUCH (M1 WITH EDGE XS2)) ENCLOSE X8) == 2))  NOT MARKS 
}

RULECHECK M1_30 {
@ It’s not allowed DUMBM(GDS No: 90/0) layer in design excluding RFDEV region.
OUTLAYER (DRC:1 INTERACT DUMBM ) NOT INTERACT RFDEV 
}


#//===================================
#// 1x Mn: 1x Metal design rules
#//===================================

for { set j 2 } { $j <= $M1_and_1XMn_metal_counts } { incr j } {

GROUP G1XM${j} 1XM${j}_?
SETLAYER M${j}_all_noinst = M${j}_all NOT INSIDE INST
RULECHECK 1XM${j}_1 {
@ 1xMn width. >= 0.050um and <= 4.5
@ DRC doesn’t check INST region. For maximum rule, DRC doesn’t check DUPMK1 region
  SETLAYER X = (M${j}_all NOT INST) NOT DUPMK1
  OUTLAYER (X WITH WIDTH > 4.5) NOT MARKS
  OUTLAYER ((INT M${j}_all_noinst < 0.05 ABUT < 90 SINGULAR REGION) NOT INSIDE INST) NOT MARKS
}

RULECHECK 1XM${j}_2a {
@ Width of 45-degree bent 1xMn. >= 0.170um
  SETLAYER X = ANGLE M$j >= 44.9 <= 45.1
  OUTLAYER (INT X < 0.17 OPPOSITE REGION) NOT MARKS
}

RULECHECK 1XM${j}_2b {
@ Length of 45-degree 1xMn. ≥	0.5um
   SETLAYER X = ANGLE M$j >= 44.9 <= 45.1
   OUTLAYER (LENGTH X < 0.5) NOT INSIDE EDGE MARKS
}

RULECHECK 1XM${j}_3 {
@ 1xMn edge length when the adjacent edge < 0.05um, and these two edges formed by 3 consecutive 270 degree inner vertex-90 degree outer vertex-270 degree inner vertex.
@ DRC doesn't flag if there is 1xMn in the region which is formed by 0.16um extension from these two edges and the 90-degree outer vertex.	≥	0.065	um
 angle_consecutive  M${j}_all
}

RULECHECK 1XM${j}_4a {
@ Space between two 1xMns. ≥ 0.05um
  OUTLAYER (EXT M${j}_all < 0.05 ABUT < 90 SINGULAR REGION) NOT MARKS 
}

RULECHECK 1XM${j}_4b {
@ Space between two 1xMns when one or both 1xMn widths are>0.09um, and parallel run length of two 1xMns is >0.22um. >= 0.060um
 Mn_one_width M${j}_all 0.091 0.22 0.06 
}

RULECHECK 1XM${j}_4c {
@ Space between two 1xMns when one or both 1xMn widths are>0.13um, and parallel run length of two 1xMns is >0.22um. >= 0.08um
 Mn_one_width M${j}_all 0.131 0.22 0.08
}

RULECHECK 1XM${j}_4d {
@ Space between two 1xMns when one or both 1xMn widths are>0.16um, and parallel run length of two 1xMns is >0.22um. >= 0.100um
 Mn_one_width M${j}_all 0.161 0.22 0.1
}

RULECHECK 1XM${j}_4e {
@ Space between two 1xMns when one or both 1xMn widths are>0.47um, and parallel run length of two 1xMns is >0.47um. ≥ 0.13um
 Mn_one_width M${j}_all 0.471 0.47 0.13
}

RULECHECK 1XM${j}_4f {
@ Space between two 1xMns when one or both 1xMns width are >0.63um, and parallel run length of two 1xMns is >0.63um. ≥ 0.15um
 Mn_one_width M${j}_all 0.631 0.63 0.15
}

RULECHECK 1XM${j}_4g {
@ Space between two 1xMns when one or both 1xMns width are >1.5um, and parallel run length of two 1xMns is >1.5um. >= 0.500um
  Mn_one_width M${j}_all 1.501 1.5 0.5
}

RULECHECK 1XM${j}_5a {
@ Space between 1xMn end to 1xMn, and the parallel run length is >-0.025um.
@ 1xMn line-end definition: 1xMn edge with length < 0.07um (W) between two outer vertex, ANGLE1=ANGLE2=90, adjacent edge A1/A2 ≥ 0.05um.
@ DRC doesn’t check INST region.	≥	0.07	um
SETLAYER M${j}_end = CONVEX EDGE M${j}_all_noinst ANGLE1 == 90 LENGTH1 >= 0.05 ANGLE2 == 90 LENGTH2 >= 0.05 WITH LENGTH < 0.07
SETLAYER W = EXT M${j}_end M${j}_all < 0.07 REGION OPPOSITE EXTENDED 0.025
OUTLAYER (W NOT INSIDE INST) NOT MARKS 
}

RULECHECK 1XM${j}_5b {
@ Space between 1xMn line end and end, and the parallel run length is >-0.025um.
@ 1xMn line definition: 1xMn edge ≥ 0.07um.
@ 1xMn line-end definition: 1xMn edge with length < 0.07um (W) between two outer vertex, ANGLE1=ANGLE2=90, adjacent edge A1/A2 ≥ 0.05um.
@ DRC doesn’t check INST region.	≥	0.08	um
SETLAYER M${j}_end = CONVEX EDGE M${j}_all_noinst ANGLE1 == 90 LENGTH1 >= 0.05 ANGLE2 == 90 LENGTH2 >= 0.05 WITH LENGTH < 0.07
SETLAYER W = EXT M${j}_end < 0.08 REGION OPPOSITE EXTENDED 0.025
OUTLAYER (W NOT INSIDE INST) NOT MARKS
}

RULECHECK 1XM${j}_5c {
@ Space between 1xMn line and dense 1xMn line-end with 1xVn-1/or 1xRVn-1(E ≤ 0.05um) (the parallel run length >-0.025um).
@ 1xMn line definition: 1xMn edge ≥ 0.07um.
@ 1xMn line-end definition: 1xMn edge with length < 0.07um (W) between two outer vertex, ANGLE1=ANGLE2=90, adjacent edge A1/A2 ≥ 0.05um
@ Dense 1xMn line end definition: (W+S) <0.115um, other metal must be in the region R, L1 and L2 is the extension from metal line end,
@ L1< 0.025um, L2 <0.07um, S should be the space between separate metal.	≥	0.08	um
  SETLAYER M${j}_line = LENGTH M$j >= 0.07
  SETLAYER M${j}_end_s = CONVEX EDGE M$j ANGLE1 == 90 LENGTH1 >= 0.05 ANGLE2 == 90 LENGTH2 >= 0.05 WITH LENGTH < 0.07
  SETLAYER X0 = EXT M${j}_line \[M${j}_end_s\] < 0.08 OPPOSITE EXTENDED 0.025
  SETLAYER X_temp1 = M${j}_end_s TOUCH EDGE X0
  SETLAYER X_temp2 = ENC V[expr $j -1] \[X_temp1\] <= 0.05 ABUT < 90 OPPOSITE
  SETLAYER X = M${j}_end_s TOUCH EDGE X_temp2
  SETLAYER Y = INT X \[M$j\] < 0.001 ABUT INTERSECTING ONLY
  SETLAYER Y1 = INT X M$j < 0.001 ABUT INTERSECTING ONLY REGION

  SETLAYER T1 = EXPAND EDGE X INSIDE BY 0.069-0.024
  SETLAYER Y2 = T1 TOUCH EDGE Y
  SETLAYER Z0 = ENC M$j \[Y2\] < 0.115 MEASURE ALL OPPOSITE EXTENDED 0.025
  SETLAYER Z1 = (ENC M$j Y2 < 0.115 MEASURE ALL OPPOSITE EXTENDED 0.025 REGION) INTERACT M$j > 1
  SETLAYER Z = Z0 COIN EDGE Z1
  SETLAYER W = M$j TOUCH EDGE Z
  OUTLAYER (X TOUCH EDGE (Y1 WITH EDGE W)) NOT INSIDE EDGE MARKS 
}

RULECHECK 1XM${j}_5d {
@ Space between 1xMn line and 1xVn-1 or 1xRVn-1 (dense 1xMn line-end enclosure of 1xVn-1 or 1xRVn-1 E≤ 0.05um),
@ the parallel run length of 1xMn line and dense 1xMn line-end >-0.025um.
@ 1xMn line definition: 1xMn edge ≥ 0.07um.
@ 1xMn line-end definition: 1xMn edge with length < 0.07um (W) between two outer vertex, ANGEL1=ANGEL2=90, adjacent edge A1/A2 ≥ 0.05um
@ Dense 1xMn line end definition: (W+S) <0.115um, other metal must be in the region R, L1 and L2 is the extension from metal line end, L1< 0.025um, L2 <0.07um,
@ S should be the space between separate metal.	≥	0.13	um
  SETLAYER M${j}_line = LENGTH M$j >= 0.07
  SETLAYER M${j}_end_s = CONVEX EDGE M$j ANGLE1 == 90 LENGTH1 >= 0.05 ANGLE2 == 90 LENGTH2 >= 0.05 WITH LENGTH < 0.07
  SETLAYER M${j}_line_s = (CONVEX EDGE M$j >= 1  WITH LENGTH >= 0.05) NOT COIN EDGE M${j}_end_s

  SETLAYER X0 = M${j}_end_s TOUCH EDGE (ENC V[expr $j -1] \[M${j}_end_s\] <= 0.05 ABUT < 90 OPPOSITE)
  SETLAYER X1 =  M${j}_end_s TOUCH EDGE (EXT \[X0\] M${j}_line < 0.13 OPPOSITE EXTENDED 0.025)
  SETLAYER X2 =  EXT V[expr $j -1] \[M${j}_line\] < 0.13
  SETLAYER X =  M${j}_end_s TOUCH EDGE (EXT \[X1\] X2 < 0.13 OPPOSITE EXTENDED 0.025)
  SETLAYER Y = INT X \[M$j\] < 0.001 ABUT INTERSECTING ONLY
  SETLAYER Y1 = INT X M$j < 0.001 ABUT INTERSECTING ONLY REGION
  
  SETLAYER T1 = EXPAND EDGE X INSIDE BY 0.069-0.024
  SETLAYER Y2 = T1 TOUCH EDGE Y
  SETLAYER Z0 = ENC M$j \[Y2\] < 0.115 MEASURE ALL OPPOSITE EXTENDED 0.025
  SETLAYER Z1 = (ENC M$j Y2 < 0.115 MEASURE ALL OPPOSITE EXTENDED 0.025 REGION) INTERACT M$j > 1
  SETLAYER Z = Z0 COIN EDGE Z1
  SETLAYER W = Y2 TOUCH EDGE Z
  SETLAYER P = X TOUCH EDGE (Y1 WITH EDGE W)
  SETLAYER Q = ENC \[V[expr $j -1]\] P <= 0.05 ABUT < 90 OPPOSITE
  SETLAYER R1 = EXPAND EDGE (V[expr $j -1] TOUCH EDGE Q) OUTSIDE BY 0.001
  SETLAYER R =  ENC R1 M${j}_line_s < 0.07 OPPOSITE REGION     
  SETLAYER M = (M$j NOT (R OR R1)) COIN EDGE ((R OR R1) TOUCH EDGE Q) 
  SETLAYER T = M${j}_line TOUCH EDGE (EXT P \[M${j}_line\] < 0.13 OPPOSITE EXTENDED 0.025)
  OUTLAYER (EXT M T < 0.13 ABUT < 90 OPPOSITE EXTENDED 0.025 REGION ) NOT MARKS  
}

RULECHECK 1XM${j}_6_R_DFM3 {
@ Space between (1xMn or dummy 1xMn).
@ DRC check maximum width of (NOT (1xMn or dummy 1xMn)) in chip region.
@ DRC doesn’t check chip corner triangle region (NODMF) sizing up 0.4um and LOGO AND INDMY.	≤	4.5	um
  SETLAYER X = ((DRC:1 NOT M${j}_all) NOT (SIZE NODMF BY 0.4)) NOT (LOGO OR INDMY)
  OUTLAYER (X WITH WIDTH > 4.5) NOT MARKS 
}

RULECHECK 1XM${j}_7 {
@ Space between 45-degree bent 1xMn and 1xMn	≥	0.17	um
  SETLAYER X = ANGLE M${j}_all >= 44.9 <= 45.1
  OUTLAYER (EXT X M${j}_all < 0.17 REGION) NOT MARKS 
}

RULECHECK 1XM${j}_8 {
@ Space between two 1xMns when one or both of 1xMn connects to 3.3V net	≥ 0.07um
  OUTLAYER (EXT M${j}_voltage_33 M$j < 0.07 ABUT < 90 SINGULAR REGION) NOT MARKS 
}

RULECHECK 1XM${j}_9a {
@ Space between 1xMns line and line when one or both of 1xMn connects to 5V net, the parallel run length>-0.11um.
@ 1xMns line definition: 1xMns edge with length ≥ 0.08um	≥	0.11	um
  SETLAYER M${j}_line = LENGTH M$j >= 0.08
  SETLAYER X = (M$j INTERACT M${j}_voltage_50) COIN EDGE M${j}_line
  OUTLAYER (EXT X M${j}_line < 0.11 REGION OPPOSITE EXTENDED 0.11) NOT MARKS 
}

RULECHECK 1XM${j}_9b {
@ Space between 1xMns line and line end when one or both of 1xMn connects to 5V net, the parallel run length>-0.14um.
@ 1xMns line-end definition: 1xMns edge with length < 0.08um (W) between two outer vertex, ANGLE1=ANGLE2=90, adjacent edge A1/A2 ≥ 0.05um.
@ 1xMns line definition: 1xMns edge with length ≥ 0.08um	≥	0.14	um
  SETLAYER M${j}_end = CONVEX EDGE M$j ANGLE1 == 90 LENGTH1 >= 0.05 ANGLE2 == 90 LENGTH2 >= 0.05 WITH LENGTH < 0.08
  SETLAYER M${j}_line = LENGTH M$j >= 0.08
  SETLAYER X = M$j INTERACT M${j}_voltage_50
  OUTLAYER (EXT (M${j}_line COIN EDGE X) M${j}_end < 0.14 REGION OPPOSITE EXTENDED 0.14) NOT MARKS 
  OUTLAYER (EXT M${j}_line (M${j}_end COIN EDGE X) < 0.14 REGION OPPOSITE EXTENDED 0.14) NOT MARKS
}

RULECHECK 1XM${j}_9c {
@ Space between 1xMns line ends when one or both of 1xMn connects to 5V net, the parallel run length>-0.12um. 
@ 1xMns line-end definition: 1xMns edge with length < 0.08um (W) between two outer vertex, ANGLE1=ANGLE2=90, adjacent edge A1/A2 ≥ 0.05um. ≥ 0.12um
  SETLAYER M${j}_end = CONVEX EDGE M$j ANGLE1 == 90 LENGTH1 >= 0.05 ANGLE2 == 90 LENGTH2 >= 0.05 WITH LENGTH < 0.08
  SETLAYER X = (M$j INTERACT M${j}_voltage_50) COIN EDGE M${j}_end
  OUTLAYER (EXT X M${j}_end < 0.12 REGION OPPOSITE EXTENDED 0.12) NOT MARKS 
}

RULECHECK 1XM${j}_10 {
@ Space between 1xMn and neighboring (Vn or Vn-1) when either (Vn or Vn-1) or 1xMn connects to 1.5V net.	≥	0.06
  OUTLAYER ((EXT M${j}_voltage_15 V[expr $j -1] < 0.06 ABUT < 90 SINGULAR REGION MEASURE ALL) INTERACT M${j} >1 )  NOT MARKS
  OUTLAYER ((EXT M$j V[expr $j -1]_voltage_15 < 0.06 ABUT < 90 SINGULAR REGION MEASURE ALL) INTERACT M${j} >1 ) NOT MARKS

  if { $j < [llength $inter_metal_list_with_name_mapping] } {
  OUTLAYER ((EXT M${j}_voltage_15 V$j < 0.06 ABUT < 90 SINGULAR REGION MEASURE ALL) INTERACT M${j} >1 ) NOT MARKS
  OUTLAYER ((EXT M$j V${j}_voltage_15 < 0.06 ABUT < 90 SINGULAR REGION MEASURE ALL) INTERACT M${j} >1 ) NOT MARKS
}
}

RULECHECK 1XM${j}_11 {
@ Space between 1xMn and neighboring (Vn or Vn-1) when either (Vn or Vn-1) or 1xMn connects to 1.8V and 2.5V net. ≥	0.08um
  OUTLAYER ((EXT M${j}_voltage_18 V[expr $j -1] < 0.08 ABUT < 90 SINGULAR REGION MEASURE ALL) INTERACT M${j} >1 ) NOT MARKS
  OUTLAYER ((EXT M${j}_voltage_25 V[expr $j -1] < 0.08 ABUT < 90 SINGULAR REGION MEASURE ALL) INTERACT M${j} >1 ) NOT MARKS
  OUTLAYER ((EXT M$j V[expr $j -1]_voltage_18 < 0.08 ABUT < 90 SINGULAR REGION MEASURE ALL) INTERACT M${j} >1 ) NOT MARKS
  OUTLAYER ((EXT M$j V[expr $j -1]_voltage_25 < 0.08 ABUT < 90 SINGULAR REGION MEASURE ALL) INTERACT M${j} >1 ) NOT MARKS

  if { $j < [llength $inter_metal_list_with_name_mapping] } {
  OUTLAYER ((EXT M${j}_voltage_18 V$j < 0.08 ABUT < 90 SINGULAR REGION MEASURE ALL) INTERACT M${j} >1 ) NOT MARKS
  OUTLAYER ((EXT M${j}_voltage_25 V$j < 0.08 ABUT < 90 SINGULAR REGION MEASURE ALL) INTERACT M${j} >1 ) NOT MARKS
  OUTLAYER ((EXT M$j V${j}_voltage_18 < 0.08 ABUT < 90 SINGULAR REGION MEASURE ALL) INTERACT M${j} >1 ) NOT MARKS
  OUTLAYER ((EXT M$j V${j}_voltage_25 < 0.08 ABUT < 90 SINGULAR REGION MEASURE ALL) INTERACT M${j} >1 ) NOT MARKS
}
}

RULECHECK 1XM${j}_12 {
@ Space between 1xMn and neighboring (Vn or Vn-1) when either (Vn or Vn-1) or 1xMn connects to 3.3V net. ≥ 0.087um
  OUTLAYER ((EXT M${j}_voltage_33 V[expr $j -1] < 0.087 ABUT < 90 SINGULAR REGION MEASURE ALL) INTERACT M${j} >1 ) NOT MARKS
  OUTLAYER ((EXT M$j V[expr $j -1]_voltage_33 < 0.087 ABUT < 90 SINGULAR REGION MEASURE ALL) INTERACT M${j} >1 ) NOT MARKS

  if { $j < [llength $inter_metal_list_with_name_mapping] } {
  OUTLAYER ((EXT M${j}_voltage_33 V$j < 0.087 ABUT < 90 SINGULAR REGION MEASURE ALL) INTERACT M${j} >1 ) NOT MARKS
  OUTLAYER ((EXT M$j V${j}_voltage_33 < 0.087 ABUT < 90 SINGULAR REGION MEASURE ALL) INTERACT M${j} >1 ) NOT MARKS
}
}

RULECHECK 1XM${j}_13 {
@ Space between 1xMn and neighboring (Vn or Vn-1) when either (Vn or Vn-1) or 1xMn connects to 5V net.	≥ 0.165um
  OUTLAYER ((EXT M${j}_voltage_50 V[expr $j -1] < 0.165 ABUT < 90 SINGULAR REGION MEASURE ALL) INTERACT M${j} >1 ) NOT MARKS
  OUTLAYER ((EXT M$j V[expr $j -1]_voltage_50 < 0.165 ABUT < 90 SINGULAR REGION MEASURE ALL) INTERACT M${j} >1 ) NOT MARKS

  if { $j < [llength $inter_metal_list_with_name_mapping] } {
  OUTLAYER ((EXT M$j V${j}_voltage_50 < 0.165 ABUT < 90 SINGULAR REGION MEASURE ALL) INTERACT M${j} >1 ) NOT MARKS
  OUTLAYER ((EXT M${j}_voltage_50 V$j < 0.165 ABUT < 90 SINGULAR REGION MEASURE ALL) INTERACT M${j} >1 ) NOT MARKS
}
}


  if { $j > 2 } {
RULECHECK 1XM${j}_15a {
@ 1xMn area ( except M2)
@ DRC doesn’t check OCOVL region.	≥	0.017	um2
  OUTLAYER (AREA (M${j}_all NOT INSIDE OCOVL) < 0.017) NOT MARKS
}
}


RULECHECK 1XM${j}_15a_R_DFM3 {
@ Recommended 1xMn area	≥	0.023	um2
@ DRC doesn’t check INST region.
  OUTLAYER (AREA (M$j NOT INSIDE INST) < 0.023) NOT MARKS
}

RULECHECK 1XM${j}_15b {
@ 1xMn area when all of 1xMn edge length < 0.13um.
@ DRC doesn’t check INST, 2PSRAM and RFSRAM region, and this rule doesn’t check the patterns which can fill 0.05um*0.13um rectangular pattern.≥	0.045	um2
  SETLAYER M${j}_ignore = ENCLOSE RECTANGLE M${j}_all 0.05 0.13  ORTHOGONAL ONLY
  SETLAYER M${j}_check_temp = (AREA M${j}_all < 0.045) NOT WITH EDGE (LENGTH M${j}_all >= 0.13)
  OUTLAYER ((M${j}_check_temp NOT M${j}_ignore) NOT (OR INST 2PSRAM RFSRAM)) NOT MARKS
}


  if { $j == 2 } {
RULECHECK 1XM${j}_16 {
@ M2 area.
@ DRC doesn’t check INST and OCOVL region.	≥	0.014	um2
  SETLAYER X = AREA M2_all_noinst < 0.014
  OUTLAYER X NOT (OR MARKS OCOVL)
}
}


RULECHECK 1XM${j}_17 {
@ Dielectric area enclosed by 1xMn (um2).	≥	0.2	um2
SETLAYER X = (HOLES M${j}_all INNER) NOT M${j}_all
OUTLAYER (AREA X < 0.2) NOT MARKS
}

RULECHECK 1XM${j}_18_l {
@ 1xMn density (including dummy). Density check window size: 125um*125um, step size: 62.5um.	≥ 10% 	≤ 85%
SETLAYER X = M${j}_all NOT MARKS 
SETLAYER Y = DRC:1 NOT MARKS  
OUTLAYER  DENSITY X Y \[AREA(X) / AREA(Y)\] < 0.1 WINDOW 125 STEP 62.5 BACKUP PRINT density_report_M${j}_18_l.log RDB density_report_M${j}_18_l.rdb
}

RULECHECK 1XM${j}_18_h {
@ 1xMn density (including dummy). Density check window size: 125um*125um, step size: 62.5um.	≥ 10% 	≤ 85%
SETLAYER X = M${j}_all NOT MARKS
SETLAYER Y = DRC:1 NOT MARKS 
OUTLAYER  DENSITY X Y \[AREA(X) / AREA(Y)\] > 0.85 WINDOW 125 STEP 62.5 BACKUP PRINT density_report_M${j}_18_h.log RDB density_report_M${j}_18_h.rdb
}	
	
RULECHECK 1XM${j}_19 {
@ The density difference between any two neighboring checking windows (window 200*200, stepping 200um).	≤	50%
SETLAYER X = M${j}_all NOT MARKS
SETLAYER Y =  DRC:1 NOT MARKS 
OUTLAYER DENSITY X Y \[AREA(X) / AREA(Y)\] >= 0 WINDOW 200 GRADIENT > 0.5 ABSOLUTE BACKUP  PRINT density_report_M${j}_19.log RDB density_report_M${j}_19.rdb 
}
	
RULECHECK 1XM${j}_20_R_DFM2 {
@ 1xMn density (including dummy) in DUMBM and MnDUB region. Density check window size: 125um*125um, step size: 62.5um.
@ DRC need check the design if DUMBM/MnDUB width is >5um and<125um, where density ratio= 1xMn area/(DUMBM/MnDUB)area.	≥ 10% and ≤ 85%
SETLAYER  DUMBMP = DUMBM OR M${j}DUB
SETLAYER  X = ENCLOSE RECTANGLE DUMBMP 125 125 ORTHOGONAL ONLY
SETLAYER  Y0 = M${j}_all NOT MARKS
SETLAYER  Z = X NOT MARKS    
OUTLAYER  DENSITY  Y0 Z \[AREA(Y0) / AREA(Z)\] < 0.10 WINDOW 125 STEP 62.5 BACKUP  PRINT density_report_M${j}_20_l.log RDB density_report_M${j}_20_l_1.rdb
OUTLAYER  DENSITY  Y0 Z \[AREA(Y0) / AREA(Z)\] > 0.85 WINDOW 125 STEP 62.5 BACKUP  PRINT density_report_M${j}_20_h.log RDB density_report_M${j}_20_h_1.rdb

SETLAYER  Y = (ENCLOSE RECTANGLE DUMBMP 5.001 5.001 ORTHOGONAL ONLY) NOT (X OR MARKS)
SETLAYER  Z1 = DFM PROPERTY Y Y0 \[ RATIO = AREA(Y0)/AREA(Y) \] < 0.1
SETLAYER  Z2 = DFM PROPERTY Y Y0 \[ RATIO = AREA(Y0)/AREA(Y) \] > 0.85
OUTLAYER  DFM RDB Z1 density_report_M${j}_20_l_2.rdb
OUTLAYER  DFM RDB Z2 density_report_M${j}_20_h_2.rdb
OUTLAYER   (Z1 OR Z2) NOT MARKS 
}

RULECHECK 1XM${j}_21 {
@ 1xMn density (including dummy).Density check window size:  80um*80umum, step size 40um
@ DRC does’t check:  
@ 1. Chip corner triangle region(NODMF) sizing up 0.4um if seal ring is added by SMIC.
@ 2. The region covered by LDNMK1.
@ DRC only check the region with width of (checking window NOT above excluding region) ≥ 40um 	≥ 	1%. 
SETLAYER X0 = (SIZE NODMF BY 0.4) OR (LDNMK1 OR MARKS)
SETLAYER X1 = M${j}_all NOT X0 
SETLAYER X2 = DRC:1 NOT X0 
SETLAYER X = DENSITY X1 X2 \[AREA(X1) / AREA(X2)\] < 0.01 WINDOW 80 STEP 40 BACKUP PRINT density_report_M${j}_21.log RDB density_report_M${j}_21.rdb
OUTLAYER X WITH WIDTH >= 40
}

RULECHECK 1XM${j}_22 {
@ Maxmum 1x Mn area of merged low density windows must follow item (1) and (2).
@ The definition of low density window: window size 10um*10um, step size: 5um, density <1%
@ (1) Maximum area of merged low density window ≤ 6000um2, except merged low density windows width ≤ 30um.
@ (2) Maximum area of merged low density window ≤ 16000um2.
@ DRC does’t check: 
@ 1. Chip corner triangle region (NODMF) sizing up 0.4um if seal ring is added by SMIC.
@ 2. The region covered by LDNMK1.
@ DRC only check the region with width of (checking window NOT above excluding region) ≥ 5um
  SETLAYER X0 = (SIZE NODMF BY 0.4) OR (LDNMK1 OR MARKS)
  SETLAYER X1 = M${j}_all NOT X0 
  SETLAYER X2 = DRC:1 NOT X0 
  SETLAYER X = DENSITY X1 X2 \[AREA(X1) / AREA(X2)\] < 0.01 WINDOW 10 STEP 5 BACKUP PRINT density_report_M${j}_22.log RDB density_report_M${j}_22.rdb
  OUTLAYER (AREA X > 6000) WITH WIDTH > 30
  OUTLAYER (AREA X > 16000) WITH WIDTH >= 5
}


  if { $j <= [expr $M1_and_1XMn_metal_counts -2] } {
     if { $j == 2 } {
RULECHECK 1XM${j}_23_M1M2M3 {
@ It is not allowed to havel local density > 85% of all 3 consecutive metal (1xMn, 1xMn+1 and 1xMn+2) over any window size 60*60um (stepping size 30um).
@ The metal layers include M1/1xMn and dummy metals.
@ DRC doesn't check: chip corner triangle region (NODMF) sizing up 0.4um if seal ring is added by SMIC, seal ring region. 
SETLAYER  X0 = (SIZE NODMF BY 0.4) OR MARKS
SETLAYER  Y =  M${j}_all NOT X0
SETLAYER  Z = M[expr $j +1]_all NOT X0
SETLAYER  M = M[expr $j -1]_all NOT X0
SETLAYER  N = DRC:1 NOT X0
OUTLAYER  DENSITY Y Z M N > 0 WINDOW 60 STEP 30 BACKUP PRINT density_report_1XM${j}_23_M1M2M3.log RDB density_report_1XM${j}_23_M1M2M3.rdb \
               \[(~~(AREA(Y)/AREA(N) -0.85))&&(~~(AREA(Z)/AREA(N) -0.85))&&(~~(AREA(M)/AREA(N) -0.85))\]
}}

RULECHECK 1XM${j}_23 {
@ It is not allowed to havel local density > 85% of all 3 consecutive metal (1xMn, 1xMn+1 and 1xMn+2) over any window size 60*60um (stepping size 30um).
@ The metal layers include M1/1xMn and dummy metals.
@ DRC doesn't check: chip corner triangle region (NODMF) sizing up 0.4um if seal ring is added by SMIC, seal ring region. 
SETLAYER  X0 = (SIZE NODMF BY 0.4) OR MARKS
SETLAYER  Y =  M${j}_all NOT X0
SETLAYER  Z = M[expr $j +1]_all NOT X0
SETLAYER  M = M[expr $j +2]_all NOT X0
SETLAYER  N = DRC:1 NOT X0

OUTLAYER   DENSITY Y Z M N > 0 WINDOW 60 STEP 30  BACKUP PRINT density_report_1XM${j}_23.log RDB density_report_1XM${j}_23.rdb \
               \[(~~(AREA(Y)/AREA(N) -0.85))&&(~~(AREA(Z)/AREA(N) -0.85))&&(~~(AREA(M)/AREA(N) -0.85))\]
}

     if { $j == 2 } {
RULECHECK 1XM${j}_24_M1M2M3 {
@ It is not allowed to havel local density < 5% of all 3 consecutive metal (1xMn, 1xMn+1 and 1xMn+2) over any window 30*30um (stepping 15um).
@ The metal layers include M1/1xMn and dummy metals.
@ DRC does’t check: 
@ 1. Chip corner triangle region (NODMF) sizing up 0.4um if seal ring is added by SMIC.
@ 2. The region covered by LDNMK1 and INDMY..
@ DRC only check the region with width of (checking window NOT above excluding region) ≥ 15um
SETLAYER  CHECK_REGION = (((DRC:1 NOT NODMF_SIZE_0.4) NOT LDNMK1) NOT INDMY) WITH WIDTH >= 15
SETLAYER  X0 = NODMF_SIZE_0.4 OR MARKS  
SETLAYER  Y =  M${j}_all NOT X0
SETLAYER  Z = M[expr $j +1]_all NOT X0
SETLAYER  M = M[expr $j -1]_all NOT X0
SETLAYER  N = CHECK_REGION NOT MARKS

SETLAYER  X1 = DENSITY Y Z M  N > 0 WINDOW 30 STEP 15  BACKUP PRINT density_report_1XM${j}_24_M1M2M3.log \
                RDB density_report_1XM${j}_24_M1M2M3.rdb \
               \[(~~(0.05 -AREA(Y)/AREA(N) ))&&(~~(0.05 -AREA(Z)/AREA(N) ))&&(~~(0.05 -AREA(M)/AREA(N) ))\]

OUTLAYER  X1 NOT (NODMF_SIZE_0.4 OR MARKS) 
}
    }
RULECHECK 1XM${j}_24 {
@ It is not allowed to havel local density < 5% of all 3 consecutive metal (1xMn, 1xMn+1 and 1xMn+2) over any window 30*30um (stepping 15um).
@ The metal layers include M1/1xMn and dummy metals.
@ DRC does’t check: 
@ 1. Chip corner triangle region (NODMF) sizing up 0.4um if seal ring is added by SMIC.
@ 2. The region covered by LDNMK1 and INDMY.
@ DRC only check the region with width of (checking window NOT above excluding region) ≥ 15um
SETLAYER  CHECK_REGION = (((DRC:1 NOT NODMF_SIZE_0.4) NOT LDNMK1) NOT INDMY) WITH WIDTH >= 15
SETLAYER  X0 = NODMF_SIZE_0.4 OR MARKS  
SETLAYER  Y =  M${j}_all NOT X0
SETLAYER  Z = M[expr $j +1]_all NOT X0
SETLAYER  M = M[expr $j +2]_all NOT X0
SETLAYER  N = CHECK_REGION NOT MARKS
OUTLAYER   DENSITY Y Z M N> 0 WINDOW 30 STEP 15 INSIDE OF LAYER CHECK_REGION BACKUP PRINT density_report_1XM${j}_24.log \
                RDB density_report_1XM${j}_24.rdb \
               \[(~~(0.05 -AREA(Y)/AREA(N) ))&&(~~(0.05 -AREA(Z)/AREA(N) ))&&(~~(0.05 -AREA(M)/AREA(N) ))\]
}
}

RSPMn_1_2_3_LOTA RSP_1XM${j}_26 $j 0.29 0.25 0.3 0.22 0.08 0.1 0.06 0.3
RULECHECK 1XM${j}_26 {
@ Space of metal space segments with S2 < 0.08 and L2 ≤ 0.22um.
@ Metal space segments definition:
@ 1). at least one metal line width > 0.25um (W1) and the parallel run length > 0.3um (L1) in metal space < 0.29um (S1) region;
@ 2). metal space segments within metal space (S1) region and are generated by space cut line which is perpendicular with L1 direction formed by
@     all vertex in metal space region (S1); 
@ 3). metal space segments at least abut one metalwith width > 0.25um (W1);
@ 4). L2 is the width of metal space segments which is parallel with L1 direction;
@ 5). S2 is the width of metal space segments which is perpendicular with L1 direction.	≥	0.3	um
OUTLAYER RSP_1XM${j}_26_OUT1 NOT MARKS 
}

RULECHECK 1XM${j}_26a {
@ Width (S2) of metal space segments with L2 > 0.22um
@ Metal space segments definition:
@ 1). at least one metal line width > 0.25um (W1) and the parallel run length > 0.3um (L1) in metal space < 0.29um (S1) region;
@ 2). metal space segments within metal space (S1) region and are generated by space cut line which is perpendicular with L1 direction formed by
@     all vertex in metal space region (S1); 
@ 3). metal space segments at least abut one metalwith width > 0.25um (W1);
@ 4). L2 is the width of metal space segments which is parallel with L1 direction;
@ 5). S2 is the width of metal space segments which is perpendicular with L1 direction.	≥	0.1	um
OUTLAYER RSP_1XM${j}_26_OUT2 NOT MARKS 
}

RULECHECK 1XM${j}_26b {
@ Width (S2) of metal space segments with L2 ≤ 0.22um
@ Metal space segments definition:
@ 1). at least one metal line width > 0.25um (W1) and the parallel run length > 0.3um (L1) in metal space < 0.29um (S1) region;
@ 2). metal space segments within metal space (S1) region and are generated by space cut line which is perpendicular with L1 direction formed by
@     all vertex in metal space region (S1); 
@ 3). metal space segments at least abut one metalwith width > 0.25um (W1);
@ 4). L2 is the width of metal space segments which is parallel with L1 direction;
@ 5). S2 is the width of metal space segments which is perpendicular with L1 direction.	≥	0.06	um
OUTLAYER RSP_1XM${j}_26_OUT3 NOT MARKS 
}

RSPMn_1_2_3_LOTA RSP_1XM${j}_26c $j 0.19 0.25 0.3 0.22 0.1 0.1 0.06 0.3
RULECHECK 1XM${j}_26c {
@ Space of metal space segments with S2 < 0.1 and L2 ≤ 0.22um.
@ Metal space segments definition:
@ 1). at least one metal line width > 0.25um (W1) and the parallel run length > 0.3um (L1) in metal space < 0.19um (S1) region;
@ 2). metal space segments within metal space (S1) region and are generated by space cut line which is perpendicular with L1 direction formed by
@     all vertex in metal space region (S1); 
@ 3). metal space segments at least abut one metalwith width > 0.25um (W1);
@ 4). L2 is the width of metal space segments which is parallel with L1 direction;
@ 5). S2 is the width of metal space segments which is perpendicular with L1 direction.	≥	0.3	um
OUTLAYER RSP_1XM${j}_26c_OUT1 NOT MARKS 
}

RSPMn_1_2_3_LOTA RSP_1XM${j}_27 $j 0.32 0.47 0.5 0.22 0.13 0.13 0.06 0.3
RULECHECK 1XM${j}_27 {
@ Space of metal space segments with S2 < 0.13 and L2 ≤ 0.22um.
@ Metal space segments definition:
@ 1). at least one metal line width > 0.47um (W1) and the parallel run length > 0.5um (L1) in metal space < 0.32um (S1) region;
@ 2). metal space segments within metal space (S1) region and are generated by space cut line which is perpendicular with L1 direction formed by
@     all vertex in metal space region (S1); 
@ 3). metal space segments at least abut one metalwith width > 0.47um (W1);
@ 4). L2 is the width of metal space segments which is parallel with L1 direction;
@ 5). S2 is the width of metal space segments which is perpendicular with L1 direction.
OUTLAYER  RSP_1XM${j}_27_OUT1 NOT MARKS 
}

RULECHECK 1XM${j}_27a {
@ Width (S2) of metal space segments with L2 > 0.22um
@ Metal space segments definition:
@ 1). at least one metal line width > 0.47um (W1) and the parallel run length > 0.5um (L1) in metal space < 0.32um (S1) region;
@ 2). metal space segments within metal space (S1) region and are generated by space cut line which is perpendicular with L1 direction formed by
@     all vertex in metal space region (S1); 
@ 3). metal space segments at least abut one metalwith width > 0.47um (W1);
@ 4). L2 is the width of metal space segments which is parallel with L1 direction;
@ 5). S2 is the width of metal space segments which is perpendicular with L1 direction.	≥	0.13	um
OUTLAYER RSP_1XM${j}_27_OUT2 NOT MARKS 
}

RULECHECK 1XM${j}_27b {
@ Width (S2) of metal space segments with L2 ≤ 0.22um
@ Metal space segments definition:
@ 1). at least one metal line width > 0.47um (W1) and the parallel run length > 0.5um (L1) in metal space < 0.32um (S1) region;
@ 2). metal space segments within metal space (S1) region and are generated by space cut line which is perpendicular with L1 direction formed by
@     all vertex in metal space region (S1); 
@ 3). metal space segments at least abut one metalwith width > 0.47um (W1);
@ 4). L2 is the width of metal space segments which is parallel with L1 direction;
@ 5). S2 is the width of metal space segments which is perpendicular with L1 direction.	≥	0.06	um
OUTLAYER RSP_1XM${j}_27_OUT3 NOT MARKS 
}

RSPMn_1_2_3_LOTA RSP_1XM${j}_28 $j 0.34 0.63 0.7 0.22 0.15 0.15 0.06 0.3
RULECHECK 1XM${j}_28 {
@ Space of metal space segments with S2 < 0.15 and L2 ≤ 0.22um.
@ Metal space segments definition:
@ 1). at least one metal line width > 0.63um (W1) and the parallel run length > 0.7um (L1) in metal space < 0.34um (S1) region;
@ 2). metal space segments within metal space (S1) region and are generated by space cut line which is perpendicular with L1 direction formed by
@     all vertex in metal space region (S1); 
@ 3). metal space segments at least abut one metalwith width > 0.63um (W1);
@ 4). L2 is the width of metal space segments which is parallel with L1 direction;
@ 5). S2 is the width of metal space segments which is perpendicular with L1 direction.	≥	0.3	um
OUTLAYER RSP_1XM${j}_28_OUT1 NOT MARKS
}

RULECHECK 1XM${j}_28a {
@ Width (S2) of metal space segments with L2 > 0.22um
@ Metal space segments definition:
@ 1). at least one metal line width > 0.63um (W1) and the parallel run length > 0.7um (L1) in metal space < 0.34um (S1) region;
@ 2). metal space segments within metal space (S1) region and are generated by space cut line which is perpendicular with L1 direction formed by
@     all vertex in metal space region (S1); 
@ 3). metal space segments at least abut one metalwith width > 0.63um (W1);
@ 4). L2 is the width of metal space segments which is parallel with L1 direction;
@ 5). S2 is the width of metal space segments which is perpendicular with L1 direction.	≥	0.15	um
OUTLAYER RSP_1XM${j}_28_OUT2 NOT MARKS
}

RULECHECK 1XM${j}_28b {
@ Width (S2) of metal space segments with L2 ≤ 0.22um
@ Metal space segments definition:
@ 1). at least one metal line width > 0.63um (W1) and the parallel run length > 0.7um (L1) in metal space < 0.34um (S1) region;
@ 2). metal space segments within metal space (S1) region and are generated by space cut line which is perpendicular with L1 direction formed by
@     all vertex in metal space region (S1); 
@ 3). metal space segments at least abut one metalwith width > 0.63um (W1);
@ 4). L2 is the width of metal space segments which is parallel with L1 direction;
@ 5). S2 is the width of metal space segments which is perpendicular with L1 direction.	≥	0.06	um
OUTLAYER RSP_1XM${j}_28_OUT3 NOT MARKS
}

RSPMn_1_2_3_LOTA RSP_1XM${j}_29 $j 0.5 1.5 1.5 0.22 0.3 0.3 0.06 0.3
RULECHECK 1XM${j}_29 {
@ Space of metal space segments with S2 < 0.3 and L2 ≤ 0.22um.
@ Metal space segments definition:
@ 1). at least one metal line width > 1.5um (W1) and the parallel run length > 1.5um (L1) in metal space < 0.5um (S1) region;
@ 2). metal space segments within metal space (S1) region and are generated by space cut line which is perpendicular with L1 direction formed by
@     all vertex in metal space region (S1); 
@ 3). metal space segments at least abut one metalwith width > 1.5um (W1);
@ 4). L2 is the width of metal space segments which is parallel with L1 direction;
@ 5). S2 is the width of metal space segments which is perpendicular with L1 direction.	≥	0.3	um
OUTLAYER RSP_1XM${j}_29_OUT1 NOT MARKS
}

RULECHECK 1XM${j}_29a {
@ Width (S2) of metal space segments with L2 > 0.22um
@ Metal space segments definition:
@ 1). at least one metal line width > 1.5um (W1) and the parallel run length > 1.5um (L1) in metal space < 0.5um (S1) region;
@ 2). metal space segments within metal space (S1) region and are generated by space cut line which is perpendicular with L1 direction formed by
@  all vertex in metal space region (S1); 
@ 3). metal space segments at least abut one metalwith width > 1.5um (W1);
@ 4). L2 is the width of metal space segments which is parallel with L1 direction;
@ 5). S2 is the width of metal space segments which is perpendicular with L1 direction.	≥	0.3	um
OUTLAYER RSP_1XM${j}_29_OUT2 NOT MARKS
}

RULECHECK 1XM${j}_29b {
@ Width (S2) of metal space segments with L2 ≤ 0.22um
@ Metal space segments definition:
@ 1). at least one metal line width > 1.5um (W1) and the parallel run length > 1.5um (L1) in metal space < 0.5um (S1) region;
@ 2). metal space segments within metal space (S1) region and are generated by space cut line which is perpendicular with L1 direction formed by
@     all vertex in metal space region (S1); 
@ 3). metal space segments at least abut one metalwith width > 1.5um (W1);
@ 4). L2 is the width of metal space segments which is parallel with L1 direction;
@ 5). S2 is the width of metal space segments which is perpendicular with L1 direction.	≥	0.06	um
OUTLAYER RSP_1XM${j}_29_OUT3 NOT MARKS
}

RULECHECK 1XM${j}_30 {
@ It is not allowed for 1xMn zone, and 1xMn Zone definition as below:
@ 1), W1, W3 and W5 are same polygons, W2 and W4 are same polygons;
@ 2), Width of 1xMn (W2,W3,W4) = 0.05um;
@ 3), Space of 1xMn (S1,S2,S3,S4) =0.05um;
@ 4), Space of 1xMn line-end to opposite 1xMn (S5) < 0.08um;
@ 5), parallel run length of 5 1xMn lines L1 <= 0.4um.
SETLAYER X0 = INT M${j} == 0.05 REGION OPPOSITE 
SETLAYER X2 = (EXT X0 M${j} == 0.05 REGION OPPOSITE) NOT WITH EDGE (LENGTH X20 > 0.4) 
SETLAYER X20 = EXT \[X0\] M${j} == 0.05 OPPOSITE
SETLAYER X3 = X0 TOUCH X2 == 2 
SETLAYER X4 = X3 OR (X2 TOUCH X3) 
SETLAYER X5 = EXT M${j} == 0.15 REGION OPPOSITE NOTCH EXCLUDE SHIELDED 
SETLAYER X6 = EXT \[M${j}\] == 0.15  OPPOSITE NOTCH EXCLUDE SHIELDED 
SETLAYER X7 = (M${j} NOT (X0 TOUCH X5 == 3)) TOUCH EDGE  (X0 TOUCH X5 == 3)  
SETLAYER X8 = EXT X0 X7 <= 0.08 OPPOSITE  REGION 
SETLAYER X9 = ((X0 TOUCH X5 == 3) NOT TOUCH EDGE X6) TOUCH EDGE X5 
SETLAYER X10 = (X5 WITH EDGE X9) NOT TOUCH EDGE ( EXT X9 M${j} <= 0.08 REGION OPPOSITE)  
SETLAYER X11 = EXPAND EDGE (X0 TOUCH EDGE X10) INSIDE BY 0.05   
SETLAYER X12 = ((M${j} WITH EDGE ( EXT X9 \[M${j}\] <= 0.08 OPPOSITE)) NOT  X11) TOUCH EDGE X11 
SETLAYER XS2 =  EXT X12 \[M${j}\] <= 0.08  OPPOSITE 
OUTLAYER  (X4 ENCLOSE ((X0 WITH EDGE XS2) TOUCH ((X5 TOUCH (M${j} WITH EDGE XS2)) ENCLOSE X8) == 2)) NOT MARKS 
}
}




#//======================================================
#// 1X Vn(n = 1,2,3,4,5,6,7): 1X Via design minima
#//======================================================

for { set j 1 } { $j < $M1_and_1XMn_metal_counts } { incr j } {

VERBATIM {
//==================================
// 1X Vn : 1X Via design minima
//==================================
}
GROUP G1XV${j} 1XV${j}_?

SETLAYER V${j}N_FIX = V${j} AND (RECTANGLE V$j == 0.05 BY == 0.05)
SETLAYER RV${j}_FIX = V${j} AND (RECTANGLE V$j == 0.05 BY == 0.13)

SETLAYER V${j}N = V${j} AND (RECTANGLE V$j ASPECT == 1)
SETLAYER RV$j = V${j} AND (RECTANGLE V$j ASPECT != 1)

SETLAYER V${j}N_all = RECTANGLE V${j}_all ASPECT == 1
SETLAYER V${j}N_all_NOINST = V${j}N_all NOT INSIDE INST
SETLAYER V${j}N_NOINST = V${j}N NOT INSIDE INST

RULECHECK 1XV${j}_1 {
@ Fixed 1x Vn size (square shape)
@ DRC don't check rectangular 1xVn, MARKG (0.15um 1xVn ring in MARKG region).	=	0.05	um
SETLAYER X = WITH WIDTH (DONUT (V${j} AND MARKG)) >= 0.149 <= 0.151
OUTLAYER ((V${j} NOT V${j}N_FIX) NOT RV${j}_FIX) NOT (MARKS OR X)
}

RULECHECK 1XV${j}_2a_2b {
@ 1xVn.2a Space between 1x Vns when the run length ≤ -0.04um. 	≥	0.070	um
@ 1xVn.2b Space between 1x Vns when the run length >-0.04um.
@         DRC doesn’t check INST and FUSEMK1 region.	≥	0.08	um
OUTLAYER (EXT V${j}N_all < 0.07 ABUT < 90 SINGULAR REGION) NOT MARKS 
OUTLAYER (EXT (V${j}N_all_NOINST NOT INTERACT FUSEMK1) < 0.08 ABUT < 90 SINGULAR REGION OPPOSITE EXTENDED 0.04) NOT MARKS
}

#RULECHECK 1XV${j}_2c {
#@ Space between 1X Vns at different nets for parallel parallel run length > 0um	is >= 0.080
#OUTLAYER EXT V${j}N < 0.08 ABUT < 90 OPPOSITE REGION NOT CONNECTED
#}

RULECHECK 1XV${j}_3_3a_3b_3c_3d {
@ 1xVn.3 1x Vn must be fully covered by M1 or 1xMn. Enclosure by M1 or 1xMn must follow (1x Vn.3a and 1x Vn.3b) or 1x Vn.3d as below.
@        DRC doesn’t check INST region.			
@ 1xVn.3a Enclosure by M1 or 1xMn, where 1xMn is the metal layer directly underneath 1x Vn.	≥	0	um
@ 1xVn.3b Enclosure by M1 or 1xMn when enclosure by 1xMn on either perpendicular direction ≥ 0um and < 0.01um and 1xMn is the metal layer directly underneath 1x Vn.≥	0.03um
@ 1xVn.3c Enclosure by M1 or 1xMn when enclosure by 1xMn on either perpendicular direction ≥ 0.01um and 1xMn is the metal layer directly underneath 1x Vn. ≥ 0.025um
@ 1xVn.3d Enclosure by M1 or 1xMn in four sides, and 1xMn is the metal layer directly underneath 1x Vn.	≥	0.02	um
SETLAYER X = RECTANGLE ENCLOSURE V${j}N_all_NOINST M${j}_all ABUT > 0 < 90 SINGULAR OUTSIDE ALSO \
           GOOD 0 0.03 OPPOSITE 0 0.03 OPPOSITE \
           GOOD 0.01 OPPOSITE 0.025 OPPOSITE 0.01 OPPOSITE 0.025 OPPOSITE \
           GOOD 0.02 OPPOSITE 0.02 OPPOSITE 0.02 OPPOSITE 0.02 OPPOSITE

SETLAYER Y = V${j}N_all_NOINST NOT M${j}_all
OUTLAYER (X OR Y) NOT MARKS 
}

RULECHECK 1XV${j}_3_3a_3b_3d_R_DFM3 {
@ 1xVn.3.R 1x Vn must be fully covered by M1 or 1xMn. Enclosure by 1xMn must follow (1x Vn.3a\[R\] and 1x Vn.3b\[R\]) or 1x Vn.3d\[R\], and 1x Vn.3e\[R\],
@         and 1x Vn.3f \[R\]as below.
@         DRC doesn’t check INST region.			
@ 1xVn.3a.R Enclosure by M1 or 1xMn, where 1xMn is the metal layer directly underneath 1x Vn.	≥	0.01	um
@ 1xVn.3b.R Enclosure by M1 or 1xMn when enclosure by 1xMn on either perpendicular direction ≥0.01um and <0.025um and 1xMn is the metal layer directly underneath 1x Vn.
@ 	     ≥	0.05	um
@ 1xVn.3d.R Enclosure by M1 or 1xMn in four sides, and 1xMn is the metal layer directly underneath 1x Vn. ≥ 0.025um
SETLAYER X = RECTANGLE ENCLOSURE V${j}N_NOINST M${j} ABUT > 0 < 90 SINGULAR OUTSIDE ALSO \
           GOOD 0.01 OPPOSITE 0.05 OPPOSITE 0.01 OPPOSITE 0.05 OPPOSITE \
           GOOD 0.025 OPPOSITE 0.025 OPPOSITE 0.025 OPPOSITE 0.025 OPPOSITE

SETLAYER Y = V${j}N_NOINST NOT M${j}
OUTLAYER (X OR Y) NOT MARKS 
}

RULECHECK 1XV${j}_3e_R_DFM2 {
@ Enclosure by M1 or 1xMn in the four sides when 1xMn width ≥ 0.33um and ≤0.7um, 1xMn is the metal layer directly underneath 1x Vn.
@ DRC violation is allowed if only one 1xVn or rectangular 1x Vn meets this rule for the redundant 1xVn pattern.	≥	0.03	um
  SETLAYER X0 = M${j} WITH WIDTH >= 0.33 <= 0.7
  SETLAYER X = X0 COIN EDGE M${j}
  SETLAYER Y = RECTANGLE ENC (V${j}N NOT OUTSIDE X0) M${j} ABUT < 90 SINGULAR OUTSIDE ALSO\
      GOOD 0.03 OPPOSITE 0.03 OPPOSITE 0.03 OPPOSITE 0.03 OPPOSITE
  SETLAYER Z = M${j} CUT (V${j} NOT Y)
  OUTLAYER (Y OUTSIDE Z) NOT MARKS
}

RULECHECK 1XV${j}_3f_R_DFM2 {
@ Enclosure by M1 or 1xMn in the four sides when 1xMn width >0.7um, 1xMn is the metal layer directly underneath 1x Vn.
@ DRC violation is allowed if only one 1xVn or rectangular 1x Vn meets this rule for the redundant 1xVn pattern.	≥	0.04	um
  SETLAYER X0 = M${j} WITH WIDTH > 0.7
  SETLAYER X = X0 COIN EDGE M${j}
  SETLAYER Y = RECTANGLE ENC (V${j}N NOT OUTSIDE X0) M${j} ABUT < 90 SINGULAR OUTSIDE ALSO\
      GOOD 0.04 OPPOSITE 0.04 OPPOSITE 0.04 OPPOSITE 0.04 OPPOSITE
  SETLAYER Z = M${j} CUT (V${j} NOT Y)
  OUTLAYER (Y OUTSIDE Z) NOT MARKS
}

RULECHECK 1XV${j}_4_4a_4b_4c_4d {
@ 1xVn.4 1x Vn must be fully covered by 1xMn+1. 1xMn+1 enclosure 1x Vn must follow (1x Vn.4a and 1x Vn.4b) or 1x Vn.4c or 1x Vn.4d as below.
@        DRC doesn’t check INST region.			
@ 1xVn.4a Enclosure by 1xMn+1, where 1xMn+1 is the metal layer directly above 1x Vn.	≥	0	um
@ 1xVn.4b Enclosure by 1xMn+1 when enclosure by 1xMn+1 on either perpendicular direction ≥ 0um and < 0.01um and 1xMn+1 is the metal layer directly above 1x Vn.	≥	0.03	um
@ 1xVn.4c Enclosure by 1xMn+1 when enclosure by 1xMn+1 on either perpendicular direction ≥ 0.01um and 1xMn+1 is the metal layer directly above 1x Vn.	≥	0.025	um
@ 1xVn.4d Enclosure by 1xMn+1 in four sides and 1xMn+1  is the metal layer directly above 1x Vn.	≥	0.02	um
SETLAYER X = RECTANGLE ENCLOSURE V${j}N_all_NOINST M[expr $j+ 1]_all ABUT > 0 < 90 SINGULAR OUTSIDE ALSO \
           GOOD 0 0.03 OPPOSITE 0 0.03 OPPOSITE \
           GOOD 0.01 OPPOSITE 0.025 OPPOSITE 0.01 OPPOSITE 0.025 OPPOSITE \
           GOOD 0.02 OPPOSITE 0.02 OPPOSITE 0.02 OPPOSITE 0.02 OPPOSITE

SETLAYER Y = V${j}N_all_NOINST NOT M[expr $j+ 1]_all
OUTLAYER (X OR Y) NOT MARKS
}

RULECHECK 1XV${j}_4_4a_4b_4c_4d_R_DFM3 {
@ 1xVn.4\[R\] 1x Vn must be fully covered by 1xMn+1. 1xMn+1 enclosure 1x Vn must follow (1x Vn.4a\[R\] and 1x Vn.4b\[R\])or 1x Vn.4d\[R\],
@           and 1x Vn.4e\[R\] , and 1x Vn.4f\[R\] as below.
@           DRC doesn’t check INST region.			
@ 1xVn.4a\[R\] Enclosure by 1xMn+1, where 1xMn+1 is the metal layer directly above 1x Vn.	≥	0.01	um
@ 1xVn.4b\[R\] Enclosure by 1xMn+1 when enclosure by 1xMn+1 on either perpendicular direction ≥0.01um and <0.025um and 1xMn+1 is the metal layer directly above 1x Vn.
@              ≥ 0.05um
@ 1xVn.4d\[R\] Enclosure by 1xMn+1 in four sides and 1xMn+1  is the metal layer directly above 1x Vn.	≥	0.025	um
SETLAYER X = RECTANGLE ENCLOSURE V${j}N_NOINST M[expr $j+ 1] ABUT > 0 < 90 SINGULAR OUTSIDE ALSO \
           GOOD 0.01 OPPOSITE 0.05 OPPOSITE 0.01 OPPOSITE 0.05 OPPOSITE \
           GOOD 0.025 OPPOSITE 0.025 OPPOSITE 0.025 OPPOSITE 0.025 OPPOSITE

SETLAYER Y = V${j}N_NOINST NOT M[expr $j+ 1]
OUTLAYER (X OR Y) NOT MARKS

}

RULECHECK 1XV${j}_4e_R_DFM2 {
@ Enclosure by 1xMn+1 in the four sides when 1xMn+1 width ≥ 0.33um and ≤0.7um, 1xMn+1 is the metal layer directly above 1x Vn.
@ DRC violation is allowed if only one 1xVn or rectangular 1x Vn meets this rule for the redundant 1xVn pattern.	≥	0.03	um
  SETLAYER X0 = M[expr $j +1] WITH WIDTH >= 0.33 <= 0.7
  SETLAYER X = X0 COIN EDGE M[expr $j +1]
  SETLAYER Y = RECTANGLE ENC (V${j}N NOT OUTSIDE X0) M[expr $j +1] ABUT < 90 SINGULAR OUTSIDE ALSO\
      GOOD 0.03 OPPOSITE 0.03 OPPOSITE 0.03 OPPOSITE 0.03 OPPOSITE
  SETLAYER Z = M[expr $j +1] CUT (V${j} NOT Y)
  OUTLAYER (Y OUTSIDE Z) NOT MARKS
}

RULECHECK 1XV${j}_4f_R_DFM2 {
@ Enclosure by 1xMn+1 in the four sides when 1xMn+1 width >0.7um, 1xMn+1 is the metal layer directly above 1x Vn.
@ DRC violation is allowed if only one 1xVn or rectangular 1x Vn meets this rule for the redundant 1xVn pattern.	≥	0.04	um
  SETLAYER X0 = M[expr $j +1] WITH WIDTH > 0.7
  SETLAYER X = X0 COIN EDGE M[expr $j +1]
  SETLAYER Y = RECTANGLE ENC (V${j}N NOT OUTSIDE X0) M[expr $j +1] ABUT < 90 SINGULAR OUTSIDE ALSO \
      GOOD 0.04 OPPOSITE 0.04 OPPOSITE 0.04 OPPOSITE 0.04 OPPOSITE
  SETLAYER Z = M[expr $j +1] CUT (V${j} NOT Y)
  OUTLAYER (Y OUTSIDE Z) NOT MARKS
}

if { $j >= 2 } {
RULECHECK 1XV${j}_5a {
@ Enclosure by 1xMn(n=2-8) in adjacent S1 side, where 1xMn is the metal layer directly underneath 1x Vn., when
@ 1. 1xMn width W: 0.05um<W≤0.055um 
@ 2. Space S1≤0.055um, S2>0.055um, the parallel run length > 0.1um.
@ DRC doesn’t check INST region.	≥	0.005um
via_side2 V${j}N_NOINST M$j 0.05 0.055 0.1 0.055 0.055 0.005
}

RULECHECK 1XV${j}_5b {
@ Enclosure by 1xMn(n=2-8) in adjacent S1 side, where 1xMn is the metal layer directly underneath 1x Vn., when
@ 1. 1xMn width W: 0.055um<W≤0.07um 
@ 2. Space S1 < 0.065um, the parallel run length > 0.1um.
@ DRC doesn’t check INST region.	≥	0.005	um
  VIA_4g V${j}N_NOINST M$j 0.055 0.07 0.065 0.1 0.005
}

RULECHECK 1XV${j}_5c {
@ Enclosure by 1xMn(n=2-8) in adjacent S1 side, where 1xMn is the metal layer directly underneath 1x Vn., when
@ 1. 1xMn width W: 0.07um<W≤0.16um
@ 2. Space S1 < 0.1um, the parallel run length > 0.1um.
@ DRC doesn’t check 1xVn:
@ a) Two 1xVn with space ≤0.11um in 1xMn and 1xMn+1 intersection region.
@ b) One 1xVn and one rectangular with space ≤0.11um in 1xMn and 1xMn+1 intersection region.
@ DRC doesn’t check INST region.	≥	0.01	um
  VIA_4g_PART V${j}N_NOINST M$j 0.07 0.16 0.1 0.1 0.01
  VIA_4g_waive V$j M$j M[expr $j +1]
}

RULECHECK 1XV${j}_5d {
@ Enclosure by 1xMn(n=2-8) in adjacent S1 side, where 1xMn is the metal layer directly underneath 1x Vn., when
@ 1. 1xMn width W: 0.16um<W≤4.5um
@ 2. Space S1 < 0.13um, the parallel run length > 0.1um.
  VIA_4g V${j}N M$j 0.16 4.5 0.13 0.1 0.015
}
}

RULECHECK 1XV${j}_6a {
@ Enclosure by 1xMn+1 in adjacent S1 side, where 1xMn+1 is the metal layer directly above 1x Vn, when
@ 1. 1xMn+1 width W: 0.05um<W≤0.055um
@ 2. Space S1≤0.055um, S2>0.055um, the parallel run length > 0.1um.
@ DRC doesn’t check INST region.	≥	0.005	um
via_side2 V${j}N_NOINST M[expr $j +1] 0.05 0.055 0.1 0.055 0.055 0.005
}

RULECHECK 1XV${j}_6b {
@ Enclosure by 1xMn+1 in adjacent S1 side, where 1xMn+1 is the metal layer directly above 1x Vn, when
@ 1. 1xMn+1 width W: 0.055um<W≤0.07um 
@ 2. Space S1 < 0.065um, the parallel run length > 0.1um.
@ DRC doesn’t check INST region.	≥	0.005	um
  VIA_4g V${j}N_NOINST M[expr $j +1] 0.055 0.07 0.065 0.1 0.005
}

RULECHECK 1XV${j}_6c {
@ Enclosure by 1xMn+1 in adjacent S1 side, where 1xMn+1 is the metal layer directly above 1x Vn,  when
@ 1. 1xMn+1 width W: 0.07um<W≤0.16um 
@ 2. Space S1 < 0.1um, the parallel run length > 0.1um.
@ DRC doesn’t check 1xVn:
@ a) Two 1xVn with space ≤0.11um in 1xMn and 1xMn+1 intersection region. 
@ b) One 1xVn and one rectangular with space ≤0.11um in 1xMn and 1xMn+1 intersection region.
@ c) INST region. ≥	0.01	um
  VIA_4g_PART V${j}N_NOINST M[expr $j +1] 0.07 0.16 0.1 0.1 0.01
  VIA_4g_waive V$j M$j M[expr $j +1]
}

RULECHECK 1XV${j}_6d {
@ Enclosure by 1xMn+1 in adjacent S1 side, where 1xMn+1 is the metal layer directly above 1x Vn, when
@ 1. 1xMn +1 width W: 0.16um<W≤4.5um 
@ 2. Space S1 < 0.13um, the parallel run length >0.1um.
  VIA_4g V${j}N M[expr $j +1] 0.16 4.5 0.13 0.1 0.015
}

RULECHECK 1XV${j}_7 {
@ 45-degree rotated 1x Vn is not allowed.
  OUTLAYER (ANGLE V${j}N >= 44.9 <= 45.1) NOT INSIDE EDGE MARKS 
}

RULECHECK 1XV${j}_8 {
@ Single 1xVn is not allowed  in "H-shape" 1xMn+1 when:
@ 1. The 1xMn+1 has "H-shape" interact with two metal holes: both two metal holes length ≤ 6um (L2) and two metal hole area ≤6um2.
@ 2. The 1xVn overlaps on the center metal bar of this "H-shape" 1xMn+1.
@ 3. The center metal bar length ≤ 1um (L) and the metal bar width ≤ 0.16um.
  via_in_H_bar V${j}N_all M[expr $j +1]_all 6 6 1 0.16
}

if { [expr $M1_and_1XMn_metal_counts -1  -$j -4] >= 0 } {				
RULECHECK 1XV${j}_9_R_DFM3 {
@ Recommended consecutive stacked 1x Vn layer, which has only one 1x Vn for each 1x Vn layer to avoid high Rc.
@ This rule doesn’t check MARKS and DUPMK1 region.	≤	4
  SETLAYER X = V${j}N INTERACT (V[expr $j +1]N INTERACT (V[expr $j +2]N INTERACT (V[expr $j +3]N INTERACT V[expr $j +4]N)))
  OUTLAYER X NOT (MARKS OR DUPMK1)
}}

if { $j < [expr $M1_and_1XMn_metal_counts -1] } {		
RULECHECK 1XV${j}_10_R_DFM3 {
@ Recommended space between 1x Vn and 1xVn+1,where 1xVn and 1xVn+1 at different net and parallel run length > 0.02um	≥	0.06	um
  OUTLAYER  (EXT V${j}N V[expr $j +1]N < 0.06 ABUT < 90 SINGULAR REGION NOT CONNECTED PROJ > 0.02) NOT MARKS 

}}


VERBATIM {
//==========================================
// 1XRVn : rectangle 1X via design minima
//==========================================
}
GROUP G1XRV${j} 1XRV${j}_?

SETLAYER RV${j}_NOINST = RV$j NOT INSIDE INST

RULECHECK 1XRV${j}_1a_1b {
@ 1xRVn.1a Fixed width of rectangular 1x Vn
@          DRC don't check square 1xVn, MARKG (0.15um 1xVn ring in MARKG region).	=	0.05 	um
@ 1xRVn.1b Fixed length of rectangular 1x Vn
@          DRC don't check square 1xVn and MARKG (0.15um 1xVn ring in MARKG region).	=	0.13 	um
SETLAYER X = WITH WIDTH (DONUT (V${j} AND MARKG)) >= 0.149 <= 0.151
OUTLAYER ((V${j} NOT V${j}N_FIX) NOT RV${j}_FIX) NOT (MARKS OR X)
}

RULECHECK 1XRV${j}_2a {
@ Space between rectangular 1X Vns is >= 0.080
OUTLAYER (EXT RV$j < 0.08 ABUT < 90 SINGULAR REGION) NOT MARKS 
}

RULECHECK 1XRV${j}_2b {
@ Space between rectangular 1x Vn and square Vn	≥	0.075	um
OUTLAYER (EXT RV$j V${j}N < 0.075 ABUT < 90 SINGULAR REGION) NOT MARKS
}

RULECHECK 1XRV${j}_2c {
@ Space between rectangular 1x Vns when the run length >-0.04um.	≥	0.080	um
OUTLAYER (EXT RV$j < 0.08 ABUT < 90 SINGULAR REGION OPPOSITE EXTENDED 0.04) NOT MARKS
}

RULECHECK 1XRV${j}_3_3a_3b_3c_3d {
@ 1xRVn.3 Rectangular 1x Vn must be fully covered by M1 or 1xMn. Enclosure by 1xMn must follow (1x RVn.3a and 1x RVn.3c) or 1x RVn.3b or 1x RVn.3d,
@         or 1x RVn.3e_R, or 1x RVn.3f_R as below.			
@ 1xRVn.3a Enclosure by M1 or 1xMn, where 1xMn is the metal layer directly underneath rectangular 1x Vn.
@          DRC doesn’t check INST region.	≥	0.01	um
@ 1xRVn.3b Enclosure by M1 or 1xMn at rectangular 1xVn width side when enclosure by 1xMn (D1) at rectangular 1xVn length side is ≥0um,
@          where 1xMn is the metal layer directly underneath rectangular 1x Vn.
@          DRC doesn’t check INST region.	≥	0.04	um
@ 1xRVn.3c Enclosure by M1 or 1xMn when enclosure by 1xMn on either perpendicular direction ≥0.01um and <0.02um,
@          where 1xMn is the metal layer directly underneath rectangular 1x Vn.
@          DRC doesn’t check INST region.	≥	0.030	um
@ 1xRVn.3d Enclosure by M1 or 1xMn when enclosure by 1xMn in four sides, where 1xMn is the metal layer directly underneath rectangular 1x Vn.
@          DRC doesn’t check INST region.	≥	0.020	um
SETLAYER X = RECTANGLE ENCLOSURE RV${j}_NOINST M$j ABUT < 90 SINGULAR OUTSIDE ALSO \
             GOOD 0.01 OPPOSITE 0.03 OPPOSITE 0.01 OPPOSITE 0.03 OPPOSITE \
             GOOD 0.02 OPPOSITE 0.02 OPPOSITE 0.02 OPPOSITE 0.02 OPPOSITE

#for 1XRVn.3b only
SETLAYER Y_W = LENGTH X == 0.05
SETLAYER Z = (EXPAND EDGE Y_W OUTSIDE BY 0.04) INSIDE M$j
SETLAYER L = X WITH EDGE (Z COIN EDGE X) == 2

OUTLAYER (X NOT L) NOT MARKS
OUTLAYER (RV${j}_NOINST NOT M$j) NOT MARKS
}

RULECHECK 1XRV${j}_3e_R_DFM2 {
@ Enclosure by M1 or 1x Mn (1x Mn width ≥ 0.33um and ≤0.7um), when enclosure by 1xMn on either perpendicular direction ≥0.015um.
@ 1xMn is the metal layer directly underneath rectangular 1x Vn.
@ DRC violation is allowed if only one 1xVn or one rectangle 1xVn meets this rule for the redundant rectangle 1xVn pattern.	≥	0.03	um
  SETLAYER X0 = M${j} WITH WIDTH >= 0.33 <= 0.7
  SETLAYER X = X0 COIN EDGE M${j}
  SETLAYER Y = RECTANGLE ENC (RV$j NOT OUTSIDE X0) M${j} ABUT < 90 SINGULAR OUTSIDE ALSO\
      GOOD 0.015 OPPOSITE 0.03 OPPOSITE 0.015 OPPOSITE 0.03 OPPOSITE
  SETLAYER Z = ENC (Y) X < 0.01 ABUT < 90 OPPOSITE
  SETLAYER L = Y WITH EDGE Z
  SETLAYER M = M${j} CUT (V$j NOT Y)
  OUTLAYER (L OUTSIDE M) NOT MARKS
}

RULECHECK 1XRV${j}_3f_R_DFM2 {
@ Enclosure by M1 or 1x Mn (1x Mn width >0.7um), when enclosure by 1x Mn on either perpendicular direction ≥0.03um.
@ 1xMn is the metal layer directly underneath rectangular 1x Vn.
@ DRC violation is allowed if only one 1xVn or one rectangle 1xVn meets this rule for the redundant rectangle 1xVn pattern.	≥	0.04	um
  SETLAYER X0 = M${j} WITH WIDTH > 0.7
  SETLAYER X = X0 COIN EDGE M${j}
  SETLAYER Y = RECTANGLE ENC (RV$j NOT OUTSIDE X0) M${j} ABUT < 90 SINGULAR OUTSIDE ALSO \
      GOOD 0.03 OPPOSITE 0.04 OPPOSITE 0.03 OPPOSITE 0.04 OPPOSITE
  SETLAYER M = M${j} CUT (RV$j NOT Y)
  OUTLAYER (Y OUTSIDE M) NOT MARKS
}

RULECHECK 1XRV${j}_4_4a_4b_4c_4d {
@ 1xRVn.4 Rectangular 1x Vn must be fully covered by 1xMn+1. Enclosure by 1xMn+1 must follow (1x RVn.4a and 1x RVn.4c) or 1X RVn.4b or 1x RVn.4d, and 1x RVn.4e_R,
@         and 1x RVn.4f_R as below.			
@ 1xRVn.4a Enclosure by 1xMn+1, where 1xMn+1 is the metal layer directly above rectangular 1x Vn.
@          DRC doesn’t check INST region.	≥	0.01	um
@ 1xRVn.4b Enclosure by 1xMn+1 at rectangular 1xVn width side when enclosure by 1xMn+1 (D1) at rectangular 1xVn length side is ≥0um,
@          where 1xMn+1 is the metal layer directly above rectangular 1x Vn.
@          DRC doesn’t check INST region.	≥	0.04	um
@ 1xRVn.4c Enclosure by 1xMn+1 when enclosure by 1xMn+1 on either perpendicular direction ≥0.01um and <0.02um, 
@          where 1xMn+1 is the metal layer directly above rectangular 1x Vn.
@          DRC doesn’t check INST region.	≥	0.030	um
@ 1xRVn.4d Enclosure by 1xMn+1 when enclosure by 1xMn+1in four sides, where 1xMn+1 is the metal layer directly above rectangular 1x Vn.
@          DRC doesn’t check INST region.	≥	0.020	um
SETLAYER X = RECTANGLE ENCLOSURE RV${j}_NOINST M[expr $j+ 1] ABUT > 0 < 90 SINGULAR OUTSIDE ALSO \
             GOOD 0.01 OPPOSITE 0.03 OPPOSITE 0.01 OPPOSITE 0.03 OPPOSITE \
             GOOD 0.02 OPPOSITE 0.02 OPPOSITE 0.02 OPPOSITE 0.02 OPPOSITE

#for 1XRVn.4b only
SETLAYER Y_W = LENGTH X == 0.05
SETLAYER Z = (EXPAND EDGE Y_W OUTSIDE BY 0.04) INSIDE M[expr $j+ 1]
SETLAYER L = X WITH EDGE (Z COIN EDGE X) == 2

OUTLAYER (X NOT L) NOT MARKS
OUTLAYER (RV${j}_NOINST NOT M[expr $j+ 1]) NOT MARKS
}

RULECHECK 1XRV${j}_4e_R_DFM2 {
@ Enclosure by 1x Mn+1 (1x Mn+1 width ≥ 0.33um and ≤0.7um), when enclosure by 1x Mn+1 on either perpendicular direction ≥0.015um.
@ 1x Mn+1 is the metal layer directly above rectangular 1x Vn.
@ DRC violation is allowed if only one 1xVn or one rectangle 1xVn meets this rule for the redundant rectangle 1xVn pattern.	≥	0.03	um
  SETLAYER X0 = M[expr $j +1] WITH WIDTH >= 0.33 <= 0.7
  SETLAYER X = X0 COIN EDGE M[expr $j +1]
  SETLAYER Y = RECTANGLE ENC (RV$j NOT OUTSIDE X0) M[expr $j +1] ABUT < 90 SINGULAR OUTSIDE ALSO \
      GOOD 0.015 OPPOSITE 0.03 OPPOSITE 0.015 OPPOSITE 0.03 OPPOSITE
  SETLAYER Z = ENC (Y) X < 0.015 ABUT < 90 OPPOSITE
  SETLAYER L = Y WITH EDGE Z
  SETLAYER M = M[expr $j +1] CUT (V$j NOT Y)
  OUTLAYER (L OUTSIDE M) NOT MARKS
}

RULECHECK 1XRV${j}_4f_R_DFM2 {
@ Enclosure by 1x Mn+1 (1x Mn+1 width >0.7um), when enclosure by 1x Mn+1 on either perpendicular direction ≥0.03um.
@ 1x Mn+1 is the metal layer directly above rectangular 1x Vn.
@ DRC violation is allowed if only one 1xVn or one rectangle 1xVn meets this rule for the redundant rectangle 1xVn pattern.	≥	0.04	um
  SETLAYER X0 = M[expr $j +1] WITH WIDTH > 0.7
  SETLAYER X = X0 COIN EDGE M[expr $j +1]
  SETLAYER Y = RECTANGLE ENC (RV$j NOT OUTSIDE X0) M[expr $j +1] ABUT < 90 SINGULAR OUTSIDE ALSO \
      GOOD 0.03 OPPOSITE 0.04 OPPOSITE 0.03 OPPOSITE 0.04 OPPOSITE
  SETLAYER M = M[expr $j +1] CUT (V$j NOT Y)
  OUTLAYER (Y OUTSIDE M) NOT MARKS
}

if { $j >= 2 } {
RULECHECK 1XRV${j}_5a {
@ Enclosure by 1xMn(n=2-8) in adjacent S1 side, where 1xMn is the metal layer directly underneath rectangle 1x Vn., when
@ 1. 1xMn width W: 0.05um<W≤0.055um 
@ 2. Space S1≤0.055um, S2>0.055um, the parallel run length > 0.1um.
@ DRC doesn’t check INST region.	≥	0.005um
 via_side2 RV${j}_NOINST M$j 0.05 0.055 0.1 0.055 0.055 0.005
}

RULECHECK 1XRV${j}_5b {
@ Enclosure by 1xMn(n=2-8) in adjacent S1 side, where 1xMn is the metal layer directly underneath rectangle 1x Vn., when
@ 1. 1xMn width W: 0.055um<W≤0.07um 
@ 2. Space S1 < 0.065um, the parallel run length > 0.1um.
@ DRC doesn’t check INST region.	≥	0.005	um
  VIA_4g RV${j}_NOINST M$j 0.055 0.07 0.065 0.1 0.005
}

RULECHECK 1XRV${j}_5c {
@ Enclosure by 1xMn(n=2-8) in adjacent S1 side, where 1xMn is the metal layer directly underneath rectanglular 1x Vn., when
@ 1. 1xMn width W: 0.07um<W≤0.16um 
@ 2. Space S1 < 0.1um, the parallel run length > 0.1um.
@ DRC doesn’t check 1xRVn:
@ a) Two rectangular 1x Vns with space ≤0.11um in 1xMn and 1xMn+1 intersection region. 
@ b) One 1xVn and one rectangular with space ≤0.11um in 1xMn and 1xMn+1 intersection region.
@ c) INST region.	≥	0.01	um
  VIA_4g_PART RV${j}_NOINST M$j 0.07 0.16 0.1 0.1 0.01
  VIA_4g_waive V$j M$j M[expr $j +1]
}

RULECHECK 1XRV${j}_5d {
@ Enclosure by 1xMn(n=2-8) in adjacent S1 side, where 1xMn is the metal layer directly underneath rectangle 1x Vn., when
@ 1. 1xMn width W: 0.16um<W≤4.5um 
@ 2. Space S1 < 0.13um, the parallel run length > 0.1um.
  VIA_4g RV$j M$j 0.16 4.5 0.13 0.1 0.015
}
}

RULECHECK 1XRV${j}_6a {
@ Enclosure by 1xMn+1 in adjacent S1 side, where 1xMn+1 is the metal layer directly above rectangle 1x Vn., when
@ 1. 1xMn+1 width W: 0.05um<W≤0.055um 
@ 2. Space S1≤0.055um, S2>0.055um, the parallel run length > 0.1um. ≥	0.005um
 via_side2 RV${j} M[expr $j +1] 0.05 0.055 0.1 0.055 0.055 0.005
}

RULECHECK 1XRV${j}_6b {
@ Enclosure by 1xMn+1 in adjacent S1 side, where 1xMn+1 is the metal layer directly above rectangle 1x Vn., when
@ 1. 1xMn+1 width W: 0.055um<W≤0.07um 
@ 2. Space S1 < 0.065um, the parallel run length > 0.1um.	≥	0.005	um
   VIA_4g RV${j} M[expr $j +1] 0.055 0.07 0.065 0.1 0.005
}

RULECHECK 1XRV${j}_6c {
@ Enclosure by 1xMn+1 in adjacent S1 side, where 1xMn+1 is the metal layer directly above rectangle 1x Vn., when
@ 1. 1xMn+1 width W: 0.07um<W≤0.16um 
@ 2. Space S1 < 0.1um, the parallel run length > 0.1um.
@ DRC doesn’t check 1xRVn:
@ a) Two 1x Vns with space ≤0.11um in 1xMn and 1xMn+1 intersection region. 
@ b) One 1xVn and one rectangular with space ≤0.11um in 1xMn and 1xMn+1 intersection region	≥	0.01	um
  VIA_4g_PART RV$j M[expr $j +1] 0.07 0.16 0.1 0.1 0.01
  VIA_4g_waive V$j M$j M[expr $j +1]
}

RULECHECK 1XRV${j}_6d {
@ Enclosure by 1xMn+1 in adjacent S1 side, where 1xMn+1 is the metal layer directly above rectangle 1x Vn., when
@ 1. 1xMn+1 width W: 0.16um<W≤4.5um 
@ 2. Space S1 < 0.13um, the parallel run length > 0.1um.
  VIA_4g RV$j M[expr $j +1] 0.16 4.5 0.13 0.1 0.015
}

#RULECHECK 1XRV${j}_4g {
#@ Enclosure by 1xMn+1, when 1xMn+1 metal width > 0.16um and ≤ 4.5 um, metal space < 0.13um and the parallel run length > 0.1um. 
#@ 1x Mn+1 is the metal layer directly above rectangular 1x Vn. ≥ 0.015um
#  VIA_4g RV$j M[expr $j +1] 0.16 4.5 0.13 0.1 0.015
#}

RULECHECK 1XRV${j}_7 {
@ Redundant via requirement must be obeyed by one of following condition of via number and space for 1xMn and 1xMn+1 condition (one of 1xMn or 1xMn+1 width and length W1> 0.18um):
@ 1. when W1>0.18 and ≤0.44um:
@  a) At least one rectangular via; 
@  b) At least two square vias with space ≤0.1um; 
@  c) At least 4 square vias with space≤0.6um
@ 2. when W1>0.44um:
@  a) At least 4 square vias with space ≤0.1um, which two square vias can be replaced by one rectangular via.
@ space between (two rectangular vias) or  (rectangular and square via) or  (two square vias) ≤0.13um when two square vias is replaced by one rectangular via.
@  b) At least 9 square vias with space≤0.85um, which two square vias can be replaced one rectangular via(at least 5 rectangular vias are equal to this 9 square vias. 
@ Rectangular via is prior to square via. 
SETLAYER X1a = WITH WIDTH M$j > 0.18 <= 0.44
SETLAYER X1b = WITH WIDTH M[expr $j+ 1] > 0.18 <= 0.44
SETLAYER WIDE = X1a OR X1b
SETLAYER X2 = (M$j AND M[expr $j+ 1]) ENCLOSE V${j}N
SETLAYER X3 = V${j}N INSIDE X2
SETLAYER X5c = WITH NEIGHBOR V${j}N >= 1 SPACE <= 0.1 INSIDE OF LAYER (X2 NOT OUTSIDE WIDE) 
SETLAYER X5d = (SIZE X3 BY 0.3 BEVEL 2 INSIDE OF X2 STEP 0.03) INTERACT V${j}N >= 4
SETLAYER X6c = (X2 INTERACT X5c) OR (X2 INTERACT X5d)
#OUTLAYER ((((X2 NOT X6c) ENCLOSE (V${j}N NOT OUTSIDE WIDE)) NOT ENCLOSE RV$j) NOT Y6c) NOT MARKS 
OUTLAYER (((X2 NOT X6c) ENCLOSE (V${j}N NOT OUTSIDE WIDE)) NOT ENCLOSE RV$j) NOT MARKS

SETLAYER Y1a = WITH WIDTH M$j > 0.44
SETLAYER Y1b = WITH WIDTH M[expr $j+ 1] > 0.44
SETLAYER WIDEY = Y1a OR Y1b
SETLAYER Y2 = (M$j AND M[expr $j+ 1]) ENCLOSE (V${j}N OR RV$j)
SETLAYER Y3 = V${j}N INSIDE Y2
SETLAYER Y3_V_RV = V${j} INSIDE Y2

SETLAYER Y5t1 = SIZE Y3 BY 0.05 BEVEL 2 INSIDE OF Y2 STEP 0.025
SETLAYER Y5t2 = SIZE Y3_V_RV BY 0.065 BEVEL 2 INSIDE OF Y2 STEP 0.025
SETLAYER Y5c = Y5t1 INTERACT V${j}N >= 4
SETLAYER Y5c1 = Y5t2 INTERACT RV${j} >=2
SETLAYER Y5c2 = (Y5t2 INTERACT RV${j}) INTERACT V${j}N
SETLAYER Y5c3 =  Y5c2 INTERACT V${j}N >=2

SETLAYER Y5d_1 = (SIZE Y3 BY 0.425 BEVEL 2 INSIDE OF Y2 STEP 0.025) INTERACT V${j}N >= 9
SETLAYER Y5d_via_space_V_RV = SIZE Y3_V_RV BEVEL 2 BY 0.425 INSIDE OF Y2 STEP 0.025
SETLAYER Y5d_2 = Y5d_via_space_V_RV INTERACT RV${j} >= 5
SETLAYER Y5d_3 = (Y5d_via_space_V_RV INTERACT RV${j} >= 1) INTERACT V${j}N >= 7
SETLAYER Y5d_4 = (Y5d_via_space_V_RV INTERACT RV${j} >= 2) INTERACT V${j}N >= 5
SETLAYER Y5d_5 = (Y5d_via_space_V_RV INTERACT RV${j} >= 3) INTERACT V${j}N >= 3
SETLAYER Y5d_6 = (Y5d_via_space_V_RV INTERACT RV${j} >= 4) INTERACT V${j}N >= 1

SETLAYER Y5e = COPY Y5c1
SETLAYER Y6c = OR (Y2 INTERACT Y5c) (Y2 INTERACT Y5c1) (Y2 INTERACT Y5c2) (Y2 INTERACT Y5c3) (Y2 INTERACT Y5d_1) (Y2 INTERACT Y5d_2) (Y2 INTERACT Y5d_3) (Y2 INTERACT Y5d_4) (Y2 INTERACT Y5d_5) (Y2 INTERACT Y5d_6) ((Y2 INTERACT Y5e) ENCLOSE V${j}N)
OUTLAYER ((Y2 NOT Y6c) ENCLOSE ((V${j}N OR RV$j) NOT OUTSIDE WIDEY)) NOT MARKS
}

SETLAYER M${j}_wide = WITH WIDTH  M$j > 0.18
SETLAYER M[expr $j +1]_wide_1 = WITH WIDTH  M[expr $j +1] > 0.18

SETLAYER M${j}_EMPTY4 = EMPTY4 OR M$j
SETLAYER M[expr $j +1]_EMPTY4_1 = EMPTY4 OR M[expr $j +1]
SETLAYER V${j}_EMPTY4 = EMPTY4 OR V$j 

CONNECT  V${j}_EMPTY4 M${j}_EMPTY4 
CONNECT  M${j}_wide M${j}_EMPTY4 
CONNECT  V${j}_EMPTY4 M[expr $j +1]_EMPTY4_1
CONNECT  M[expr $j +1]_wide_1  M[expr $j +1]_EMPTY4_1

SETLAYER  Nxa_V${j} = DFM COPY (DFM SPACE M${j}_wide V${j}_EMPTY4 < 1.65 BY EXT CONNECTED) REGION  
SETLAYER  Nya_V${j} = DFM COPY (DFM SPACE M[expr $j +1]_wide_1 V${j}_EMPTY4 < 1.65 BY EXT CONNECTED ) REGION
SETLAYER  Nxb_V${j} = DFM COPY (DFM SPACE M${j}_wide V${j}_EMPTY4 < 5 BY EXT CONNECTED ) REGION
SETLAYER  Nyb_V${j} = DFM COPY (DFM SPACE M[expr $j +1]_wide_1 V${j}_EMPTY4 < 5 BY EXT CONNECTED ) REGION
SETLAYER  Nxc_V${j} = DFM COPY (DFM SPACE M${j}_wide V${j}_EMPTY4 < 12 BY EXT CONNECTED ) REGION
SETLAYER  Nyc_V${j} = DFM COPY (DFM SPACE M[expr $j +1]_wide_1 V${j}_EMPTY4 < 12 BY EXT CONNECTED ) REGION

RULECHECK 1XRV${j}_8a {
@ There should be at least one rectangular 1x Vn or two square 1x Vns in the intersection area of 1xMn and 1xMn+1,
@ when either wide metal of 1xMn or 1xMn+1 with both length L>0.18um and width W>0.18um,
@ the space between either via and wide metal is <1.65um (D3, D3 is the shortest running path length from Via to the wide metal).
@ DRC doesn't check INST region.
single_via_from_wide_metal_two V$j M$j M[expr $j +1] 0.18 0.18 1.65-0.001
OUTLAYER (NX NOT INSIDE INST) NOT MARKS  
OUTLAYER (Ny NOT INSIDE INST) NOT MARKS 
}

RULECHECK 1XRV${j}_8b {
@ There should be at least one rectangular 1x Vn or two square 1x Vns in the intersection area of 1xMn and 1xMn+1,
@ when either wide metal of 1xMn or 1xMn+1 with both length L>1um and width W>1um, the space between either via and wide metal is ≤ 5um
@ (D3, D3 is the distance ≤ 5um away from this wide metal).
single_via_from_wide_metal_two V$j M$j M[expr $j +1] 1 1 5
OUTLAYER NX NOT MARKS
OUTLAYER Ny NOT MARKS
}

RULECHECK 1XRV${j}_8c {
@ There should be at least one rectangular 1x Vn or two square 1x Vns in the intersection area of 1xMn and 1xMn+1,
@ when either wide metal of 1xMn or 1xMn+1 with both length L>5um and width W>1.5um, the space between either via and wide metal is ≤ 12um
@ (D3, D3 is the distance ≤ 12um away from this wide metal).
single_via_from_wide_metal_two V$j M$j M[expr $j +1] 1.5 5 12
OUTLAYER NX NOT MARKS
OUTLAYER Ny NOT MARKS
}

RULECHECK 1XRV${j}_10 {
@ 45-degree rotated rectangular 1x Vn is not allowed.
  OUTLAYER (ANGLE RV$j >= 44.9 <= 45.1) NOT INSIDE EDGE MARKS
}

RULECHECK 1XRV${j}_11 {
@ Single rectangular 1xVn is not allowed in "H-shape" 1xMn+1 when:
@ 1. The 1xMn+1 has "H-shape" interact with two metal holes: both two metal holes length ≤ 6um (L2) and two metal hole area ≤ 6um2.
@ 2. The rectangular 1xVn overlaps on the center metal bar of this "H-shape" 1xMn+1.
@ 3. The center metal bar length≤ 1um (L) and the metal bar width ≤ 0.16um.
via_in_H_bar RV$j M[expr $j +1] 6 6 1 0.16
}

if { [expr $M1_and_1XMn_metal_counts -1  -$j -4] >= 0 } {
RULECHECK 1XRV${j}_12_R_DFM3 {
@ Recommended consecutive stacked rectangular 1x Vn layer, which has only one rectangular 1x Vn for each rectangular 1x Vn layer to avoid high Rc.
@ This rule doesn’t check MARKS and DUPMK1 region.	≤	4
  SETLAYER X = RV$j INTERACT (RV[expr $j +1] INTERACT (RV[expr $j +2] INTERACT (RV[expr $j +3] INTERACT RV[expr $j +4])))
  OUTLAYER X NOT (MARKS OR DUPMK1)
}
}

if { $j < [expr $M1_and_1XMn_metal_counts -1] } {	
RULECHECK 1XRV${j}_13_R_DFM3 {
@ Recommended space between rectangular 1x Vn and 1xVn+1,where rectangular 1xVn and 1xVn+1 at different net and parallel run length > 0.02um	≥	0.06	um
  OUTLAYER  (EXT RV$j RV[expr $j +1] < 0.06 ABUT < 90 SINGULAR REGION NOT CONNECTED PROJ > 0.02) NOT MARKS 
}
}
}

######################################################################################################



#//=======================================
#// 2x Mn:  2x Metal design rules
#//=======================================

if { $2X_metal_counts > 0 } {

  foreach j $2X_metal_with_name_mapping_Mn_j {

GROUP G2XM$j 2XM${j}_?

RULECHECK 2XM${j}_1 {
@ 2xMn width.	≥	0.1um ≤	12um
@ DRC doesn’t check DUPMK1 region for maximum rule check.
  OUTLAYER (M${j}_all WITH WIDTH > 12) NOT (MARKS OR DUPMK1)
  OUTLAYER (INT M${j}_all < 0.1 ABUT < 90 SINGULAR REGION) NOT MARKS
}

RULECHECK 2XM${j}_2a {
@ Width of 45-degree 2xMn	≥	0.34	um
  SETLAYER X = ANGLE M${j} >= 44.9 <= 45.1
  OUTLAYER (INT X < 0.34 OPPOSITE REGION) NOT MARKS
}

RULECHECK 2XM${j}_2b {
@ Length of 45-degree 2xMn	≥	1	um
  SETLAYER X = ANGLE M${j} >= 44.9 <= 45.1
  OUTLAYER (LENGTH X < 1) NOT INSIDE EDGE MARKS
}

RULECHECK 2XM${j}_3a {
@ Space between two 2xMns. 	≥	0.1	um
  OUTLAYER (EXT M${j}_all < 0.1 ABUT < 90 SINGULAR REGION) NOT MARKS
}

RULECHECK 2XM${j}_3b {
@ Space between two 2xMns when one or both 2xMn widths are >0.2um, and parallel run length of two 2xMns is >0.38um.	≥	0.12	um
 Mn_one_width M${j}_all 0.201 0.38 0.12
}

RULECHECK 2XM${j}_3c {
@ Space between two 2xMns when one or both 2xMn widths are >0.4um, and parallel run length of two 2xMns is >0.4um.	≥	0.16	um
 Mn_one_width M${j}_all 0.401 0.4 0.16
}

RULECHECK 2XM${j}_3d {
@ Space between two 2xMns when one or both 2xMn widths are >1.5um, and parallel run length of two 2xMns is >1.5um.	≥	0.5	um
 Mn_one_width M${j}_all 1.501 1.5 0.5
}

RULECHECK 2XM${j}_3e {
@ Space between two 2xMns when one or both 2xMn widths are >4.5um, and parallel run length of two 2xMns is >4.5um.	≥	1.5	um
 Mn_one_width M${j}_all 4.501 4.5 1.5
}

RULECHECK 2XM${j}_4_5 {
@ 2XM${j}_4:
@ Space between 2xMns and 2xMn dense line end (the parallel run length >-0.035um).
@ 1. 2xMn line-end definition: 2xMn edge with length < 0.12um (W) between two outer vertex, ANGLE1=ANGLE2=90, adjacent edge A1/A2≥ 0.1um;
@ 2. 2xMn dense line end definition:  the space(S1) is <0.12um between any one adjacent edge of 2xMn line end  and other 2xMn, 
@    other metal must be in the  L1 and L2 extension region from metal line end, L1< 0.035um, L2 <0.12um. S1 should be the space between separate metal. ≥ 0.12	um
@ 2XM${j}_5:
@ Space between 2xMn(M) and 2xMn(N) with th parallel runlength>-0.035um, when space(S2) is <0.12um between 2xMn(N) line end and other 2xMn.
@ 1. 2xMn line-end definition: 2xMn edge with length < 0.12um (W) between two outer vertex, ANGLE1=ANGLE2=90, adjacent edge A1/A2 ≥ 0.1um;
@ 2. 2xMn(M) must be in the L1 and L2 extension region from metal line end, L1< 0.035um, L2 <0.12um.	≥	0.12	um
  SETLAYER M${j}_end_s = CONVEX EDGE M${j}_all ANGLE1 == 90 LENGTH1 >= 0.1 ANGLE2 == 90 LENGTH2 >= 0.1 WITH LENGTH < 0.12
  SETLAYER X0 = EXT M${j}_all \[M${j}_end_s\] < 0.12 OPPOSITE EXTENDED 0.035
  SETLAYER X = M${j}_end_s TOUCH EDGE X0
  SETLAYER Y = INT X \[M${j}_all\] < 0.001 ABUT INTERSECTING ONLY
  SETLAYER Y1 = INT X M${j}_all < 0.001 ABUT INTERSECTING ONLY REGION

  SETLAYER T1 = EXPAND EDGE X INSIDE BY 0.119-0.034
  SETLAYER Y2 = T1 TOUCH EDGE Y
  SETLAYER Z0 = EXT M${j}_all \[Y2\] < 0.12 MEASURE ALL OPPOSITE EXTENDED 0.035
  SETLAYER Z1 = (EXT M${j}_all Y2 < 0.12 MEASURE ALL OPPOSITE EXTENDED 0.035 REGION) INTERACT M${j}_all > 1
  SETLAYER Z = Z0 COIN EDGE Z1
  SETLAYER W = Y2 TOUCH EDGE Z
  OUTLAYER (X TOUCH EDGE (Y1 WITH EDGE W)) NOT INSIDE EDGE MARKS 
}

RULECHECK 2XM${j}_6_R_DFM3 {
@ Space between (2xMn or dummy 2xMn).
@ DRC check maximum width of (NOT (2xMn or dummy 2xMn)) in chip region.
@ DRC doen’t check chip corner triangle region (NODMF) sizing up 0.4um and LOGO.	≤	4.5	um
  SETLAYER X = ((DRC:1 NOT M${j}_all) NOT (SIZE NODMF BY 0.4)) NOT LOGO
  OUTLAYER (X WITH WIDTH > 4.5) NOT MARKS
}

RULECHECK 2XM${j}_7 {
@ Space between 45-degree 2xMn and 2xMn	≥	0.34	um
  SETLAYER X = ANGLE M${j}_all >= 44.9 <= 45.1
  OUTLAYER (EXT X M${j}_all < 0.34 REGION) NOT MARKS
}

RULECHECK 2XM${j}_8 {
@ Space between two 2xMns when one or both of 2xMn connects to 5V net	≥	0.16	um
  OUTLAYER (EXT M${j}_voltage_50 M$j < 0.16 ABUT < 90 SINGULAR REGION) NOT MARKS
}

RULECHECK 2XM${j}_9 {
@ 2xMn area	≥	0.06	um2
  OUTLAYER (AREA M${j}_all < 0.06) NOT MARKS
}

RULECHECK 2XM${j}_10 {
@ Enclosed dielectric area by 2xMn	≥	0.26	um2
  SETLAYER X = (HOLES M${j}_all INNER) NOT M${j}_all
  OUTLAYER (AREA X < 0.26) NOT MARKS
}

RULECHECK 2XM${j}_11_l {
@ 2xMn density (including dummy). Density check window size: 125um*125um, step size: 62.5um.	≥	10% <=	85%
  SETLAYER X = M${j}_all NOT MARKS 
  SETLAYER Y = DRC:1 NOT MARKS 
  OUTLAYER  DENSITY X Y \[AREA(X)/AREA(Y)\] < 0.1 WINDOW 125 STEP 62.5 BACKUP PRINT density_report_2XM${j}_11_l.log RDB density_report_2XM${j}_11_l.rdb
}

RULECHECK 2XM${j}_11_h {
@ 2xMn density (including dummy). Density check window size: 125um*125um, step size: 62.5um.	≥	10% <=	85%
  SETLAYER X = M${j}_all NOT MARKS 
  SETLAYER Y = DRC:1 NOT MARKS
  OUTLAYER  DENSITY X Y \[AREA(X)/AREA(Y)\] > 0.85 WINDOW 125 STEP 62.5 BACKUP PRINT density_report_2XM${j}_11_h.log RDB density_report_2XM${j}_11_h.rdb
}
	
RULECHECK 2XM${j}_12 {
@ The density difference between any two neighboring checking windows (window 200*200, stepping 200um).
@ DRC don’t check: chip corner triangle region (NODMF) sizing up 0.4um if seal ring is added by SMIC.	≥	50%
 SETLAYER X0 =  (SIZE NODMF BY 0.4) OR MARKS 
 SETLAYER X = M${j}_all NOT X0 
 SETLAYER Y = DRC:1 NOT X0
 OUTLAYER  DENSITY X Y \[AREA(X)/AREA(Y)\]  >= 0 WINDOW 200 GRADIENT > 0.5 ABSOLUTE BACKUP PRINT density_report_2XM${j}_12.log RDB density_report_2XM${j}_12.rdb 
}
	
RULECHECK 2XM${j}_13_R_DFM2 {
@ 2xMn density (including dummy) in DUMBM and 2xMnDUB region. Density check window size: 125um*125um, step size: 62.5um.
@ DRC need check the design if DUMBM/2xMnDUB width is >5um and<125um, where density ratio= 2xMn  area/DUMBM/2xMnDUB area.	≥ 10%	<= 85%
SETLAYER  DUMBMP = DUMBM OR M${j}DUB
SETLAYER  X = ENCLOSE RECTANGLE DUMBMP 125 125 ORTHOGONAL ONLY
SETLAYER  Y0 = M${j}_all NOT MARKS 
SETLAYER  Z = X NOT MARKS 
OUTLAYER  DENSITY Y0 Z \[AREA(Y0)/AREA(Z)\] < 0.10 WINDOW 125 STEP 62.5 BACKUP  PRINT density_report_2XM${j}_13_l.log RDB density_report_2XM${j}_13_l_1.rdb
OUTLAYER   DENSITY Y0 Z \[AREA(Y0)/AREA(Z)\]  > 0.85 WINDOW 125 STEP 62.5 BACKUP  PRINT density_report_2XM${j}_13_h.log RDB density_report_2XM${j}_13_h_1.rdb
SETLAYER  Y = (ENCLOSE RECTANGLE DUMBMP 5.001 5.001 ORTHOGONAL ONLY) NOT (X OR MARKS)
SETLAYER  Z1 = DFM PROPERTY Y Y0 \[ RATIO = AREA(Y0)/AREA(Y) \] < 0.1
SETLAYER  Z2 = DFM PROPERTY Y Y0 \[ RATIO = AREA(Y0)/AREA(Y) \] > 0.85
OUTLAYER  DFM RDB Z1 density_report_2XM${j}_13_l_2.rdb
OUTLAYER  DFM RDB Z2 density_report_2XM${j}_13_h_2.rdb
OUTLAYER  (Z1 OR Z2) NOT MARKS 
}	
}



  foreach j $2X_via_with_name_mapping_Vn_j {
#//=======================================
#// 2x Vn:  2x Via design rules
#//=======================================

GROUP G2XV${j} 2XV${j}_?

RULECHECK 2XV${j}_1 {
@ Fixed 2x Vn size (square shape)	=	0.1	um
OUTLAYER (NOT RECTANGLE V${j} == 0.1 BY == 0.1) NOT MARKS 
}

RULECHECK 2XV${j}_2 {
@ Space between 2x Vns	≥	0.1	um
OUTLAYER (EXT V${j} < 0.1 ABUT < 90 SINGULAR REGION) NOT MARKS
}

RULECHECK 2XV${j}_3 {
@ Space between 2x Vn and its neighboring 2x Vn (T). 
@ The definition of neighboring 2x Vn (T) ：
@ 1. 2x Vn ( T) is in a 2x Vn group
@ 2.The number of this 2x Vn group is ≥4, there are at least three 2x Vns neighboring to 2x Vn (T)
@ 3.The space between 2x Vn (T) to other 2x Vns in this group <0.14um	≥	0.13	um
SETLAYER X = WITH NEIGHBOR V${j} >= 3 SPACE < 0.14
OUTLAYER (EXT V${j} X < 0.13 ABUT < 90 SINGULAR REGION) NOT MARKS
}

RULECHECK 2XV${j}_4 {
@ Space between two neighbor 2xVns at different net with the parallel run length>0)	≥	0.13	um
OUTLAYER (EXT V${j} < 0.13 ABUT < 90 OPPOSITE REGION NOT CONNECTED) NOT MARKS
}

RULECHECK 2XV${j}_5 {
@ Space between two 2xVns when at least one 2xVn connects to 5V	≥	0.16	um
OUTLAYER (EXT V${j}_voltage_50 V$j < 0.16 ABUT < 90 SINGULAR REGION) NOT MARKS
}

RULECHECK 2XV${j}_6_6a_6b_6c_6d {
@ 2XV${j}_6:
@ 2x Vn must be fully covered by 2xMn or 1xMn. Enclosure by 2xMn or 1xMn must follow (2x Vn.6a or 2x Vn.6c or 2x Vn.6d) or  (2x Vn.6b) or 2x Vn.6c or 2x Vn.6d)as below.
@ 2XV${j}_6a:
@ Enclosure by 2xMn, where 2xMn is the metal layer directly underneath 2x Vn.	≥	0	um
@ 2XV${j}_6b:
@ Enclosure by 1xMn, where 1xMn is the metal layer directly underneath 2x Vn.	≥	0.02	um
@ 2XV${j}_6c:
@ Enclosure by  1xMn or 2xMn when enclosure by  1xMn or 2xMn on either perpendicular direction ≥0um and <0.03um and 1xMn or 2xMn is the metal layer directly underneath 2x Vn. ≥ 0.04um
@ 2XV${j}_6d:
@ Enclosure by 1xMn or 2xMn in four sides, and 1xMn or 2xMn is the metal layer directly underneath 2x Vn.	≥	0.03	um

if { (($2X_metal_counts > 1) && ($j < [lindex $2X_via_with_name_mapping_Vn_j 1])) || ($2X_metal_counts == 1) } {
SETLAYER X = RECTANGLE ENCLOSURE V${j} M${j} ABUT > 0 < 90 SINGULAR OUTSIDE ALSO \
           GOOD 0.02 OPPOSITE 0.04 OPPOSITE 0.02 OPPOSITE 0.04 OPPOSITE \
           GOOD 0.03 OPPOSITE 0.03 OPPOSITE 0.03 OPPOSITE 0.03 OPPOSITE
} else {
SETLAYER X = RECTANGLE ENCLOSURE V${j} M${j} ABUT > 0 < 90 SINGULAR OUTSIDE ALSO \
           GOOD 0 0.04 OPPOSITE 0 0.04 OPPOSITE \
           GOOD 0.03 OPPOSITE 0.03 OPPOSITE 0.03 OPPOSITE 0.03 OPPOSITE
}


SETLAYER Y = V${j} NOT M${j}
OUTLAYER (X OR Y) NOT MARKS
}

RULECHECK 2XV${j}_7 {
@ 2XV${j}_7:
@ 2x Vn must be fully covered by 2xMn+1. Enclosure by 2xMn+1must follow (2x Vn.7a or 2x Vn.7b or 2x Vn.7c)as below.
@ 2XV${j}_7a:
@ Enclosure by 2xMn+1, where 2xMn+1 is the metal layer directly above 2x Vn.	≥	0	um
@ 2XV${j}_7b:
@ Enclosure by  2xMn+1 when enclosure by  2xMn+1 on either perpendicular direction ≥0um and <0.03um and 1xMn is the metal layer directly above 2x Vn.	≥	0.04	um
@ 2XV${j}_7c:
@ Enclosure by 2xMn+1 in four sides, and 2xMn+1 is the metal layer directly above 2x Vn.	≥	0.03	um
SETLAYER X = RECTANGLE ENCLOSURE V${j} M[expr $j +1] ABUT > 0 < 90 SINGULAR OUTSIDE ALSO \
           GOOD 0 0.04 OPPOSITE 0 0.04 OPPOSITE \
           GOOD 0.03 OPPOSITE 0.03 OPPOSITE 0.03 OPPOSITE 0.03 OPPOSITE
SETLAYER Y = V${j} NOT M[expr $j +1]
OUTLAYER (X OR Y) NOT MARKS
}

  if { $j > [lindex $2X_via_with_name_mapping_Vn_j 0] } {
RULECHECK 2XV${j}_8a_8b {
@ 2XV${j}_8a:
@ There should be at least two 2x Vns with space ≤0.2um (S1) or at least four 2xVns with space ≤0.25um (S2)  in 2x Mn and  2x Mn+1 intersection area,
@ when either 2x Mn and 2x Mn+1 width and length (W1) >0.3um and ≤0.7um.
@ 2XV${j}_8b:
@ There should be at least two 2x Vns with space ≤0.2um (S1) or at least four 2xVns with space ≤0.35um (S2)  in 2x Mn and  2x Mn+1 intersection area,
@ when either 2x Mn and  2x Mn+1 width and length (W1) >0.7um.
SETLAYER X1a = WITH WIDTH M$j > 0.3 <= 0.7
SETLAYER X1b = WITH WIDTH M[expr $j+ 1] > 0.3 <= 0.7
SETLAYER WIDE = X1a OR X1b
SETLAYER X2 = (M$j AND M[expr $j+ 1]) ENCLOSE V${j}
SETLAYER X3 = V${j} INSIDE X2
SETLAYER X5c = (SIZE X3 BY 0.1 INSIDE OF X2 STEP 0.025) INTERACT V${j} >= 2
SETLAYER X5d = (SIZE X3 BY 0.125 INSIDE OF X2 STEP 0.025) INTERACT V${j} >= 4
SETLAYER X6c = (X2 ENCLOSE X5c) OR (X2 ENCLOSE X5d)
OUTLAYER (((X2 NOT X6c) ENCLOSE (V${j} NOT OUTSIDE WIDE)) NOT Y6c) NOT MARKS

SETLAYER Y1a = WITH WIDTH M$j > 0.7
SETLAYER Y1b = WITH WIDTH M[expr $j+ 1] > 0.7
SETLAYER WIDEY = Y1a OR Y1b
SETLAYER Y2 = (M$j AND M[expr $j+ 1]) ENCLOSE V${j}
SETLAYER Y3 = V${j} INSIDE Y2
SETLAYER Y3_V_RV = V${j} INSIDE Y2

SETLAYER Y5c = (SIZE Y3 BY 0.1 INSIDE OF Y2 STEP 0.025) INTERACT V${j} >= 2
SETLAYER Y5d = (SIZE Y3 BY 0.175 INSIDE OF Y2 STEP 0.025) INTERACT V${j} >= 4

SETLAYER Y6c = (OR (Y2 ENCLOSE Y5c) (Y2 ENCLOSE Y5d)) INTERACT WIDEY
OUTLAYER ((Y2 NOT Y6c) ENCLOSE (V${j} NOT OUTSIDE WIDEY)) NOT MARKS
}
}

RULECHECK 2XV${j}_9a { 
@ There should be at least two 2x Vn in the intersection area of 2xMn and 2xMn+1, when either wide metal of 2xMn or 2xMn+1 with both length L>0.3um and width W>0.3um,
@ the space between either via and wide metal is ≤0.8um (D3, D3 is the shortest running path length from 2xVn to the wide metal).
single_via_from_wide_metal_one V$j M$j M[expr $j +1] 0.3 0.3 0.8
}

RULECHECK 2XV${j}_9b { 
@ There should be at least two 2x Vn in the intersection area of 2xMn and 2xMn+1, when either wide metal of 2xMn or 2xMn+1 with both length L>2um and width W>2um,
@ the space between either via and wide metal is ≤ 2um (D3, D3 is the shortest running path length from 2xVn to the wide metal).
single_via_from_wide_metal_one V$j M$j M[expr $j +1] 2 2 2
}

RULECHECK 2XV${j}_9c { 
@ There should be at least two 2x Vn in the intersection area of 2xMn and 2xMn+1, when either wide metal of 2xMn or 2xMn+1 with both length L>10um and width W>3um,
@ the space between either via and wide metal is ≤ 5um (D3, D3 is the shortest running path length from 2xVn to the wide metal).
single_via_from_wide_metal_one V$j M$j M[expr $j +1] 3 10 5
}

RULECHECK 2XV${j}_10 {
@ Single 2xVn is not allowed  in "H-shape" 2xMn+1 when:
@ 1. The 2xMn+1 has "H-shape" interact with two metal holes: both two metal holes length ≤ 6um (L2) and two metal hole area ≤6um2.
@ 2. The 1xVn overlaps on the center metal bar of this "H-shape" 2xMn+1.
@ 3. The center metal bar length ≤ 1um (L) and the metal bar width ≤ 0.3um.
via_in_H_bar V$j M[expr $j +1] 6 6 1 0.3
}

RULECHECK 2XV${j}_12 {
@ 45-degree rotated 2x Vn is not allowed.
OUTLAYER (V$j WITH EDGE (ANGLE V$j > 44.9 < 45.1)) NOT MARKS
}
}
}





##################################################top metal and via##############################################################################################


##################################################8XTM begin##############################################################################################


#//=======================================
#// 8X TVn : 8X Via(TV1/TV2) design minima
#//=======================================

if { $8X_top_metal_counts > 0 } {
  if { $8X_top_metal_counts == 2 } {
    set 8xmetal_j { 1 2 } 
  } elseif { ($8X_top_metal_counts == 1) && ($MTT2_top_metal_counts == 1) } {
    set 8xmetal_j { 1 }
  } elseif { ($8X_top_metal_counts == 1) && ($MTT2_top_metal_counts == 0) } {
    set 8xmetal_j { 2 }
  }

foreach j $8xmetal_j {

GROUP G8XTV${j} 8XTV${j}_?

RULECHECK 8XTV${j}_1 {
@ Fixed 8x TVn size (square shape). =	0.36	um
OUTLAYER (NOT RECTANGLE TV$j == 0.36 BY == 0.36) NOT MARKS
}

RULECHECK 8XTV${j}_2a {
@ Space between single 8x TVns.	≥	0.34	um
OUTLAYER (EXT TV$j < 0.34 ABUT < 90 SINGULAR REGION) NOT MARKS
}

RULECHECK 8XTV${j}_2b {
@ Space between 8x TVn and its neighboring 8x TVn (T). 
@ The definition of neighboring 8x TVn (T) ：
@ 1. 8x TVn ( T) is in a 8x TVn group
@ 2.The number of this 8x TVn group is ≥4, there are at least 3 8x TVn s neighboring to 8x TVn (T)
@ 3.The space between 8x TVn (T) to other 8x TVn s in this group <0.56um	≥	0.54	um
SETLAYER X = WITH NEIGHBOR TV$j >= 3 SPACE < 0.56
OUTLAYER (EXT TV$j X < 0.54 ABUT < 90 SINGULAR REGION) NOT MARKS
}

RULECHECK 8XTV${j}_3_4 {
@ 8xTVn.3 8x TVn fully enclosure by 1x Mn/2x Mn/8x TM, where 1x Mn/2x Mn/8x TM is the metal layer directly underneath 8x TVn.
@         8x TVn must be fully enclosed by 1x Mn/2x Mn/8x TM	≥	0.02	um
@ 8xTVn.4 Enclosure by 1x Mn/2x Mn/8x TM when enclosure by 1x Mn/2x Mn/8x TM on either perpendicular direction ≥0.02um,
@         and 1x Mn/2x Mn/8x TM is the metal layer directly underneath 8x TVn.	≥	0.08 um
SETLAYER  OUT1 = RECTANGLE ENC TV$j TV${j}_underneath_metal ABUT < 90  SINGULAR OUTSIDE ALSO \
          GOOD 0.02 OPPOSITE 0.08 OPPOSITE 0.02 OPPOSITE 0.08 OPPOSITE
OUTLAYER OUT1 NOT MARKS 
OUTLAYER  (TV${j} NOT TV${j}_underneath_metal) NOT MARKS 
}

RULECHECK 8XTV${j}_5_6 {
@ 8xTVn.5 8x TVn fully enclosure by 8x TM , where 8x TM is the metal layer directly above 8x TVn. 8x TVn must be fully enclosed by 8x TM ≥ 0.02um
@ 8xTVn.6 Enclosure by 8x TM when enclosure by 8x TM on either perpendicular direction ≥ 0.02um, and 8x TM is the metal layer directly above 8x TVn. ≥ 0.08um
SETLAYER  OUT1 = RECTANGLE ENC TV$j TM$j ABUT < 90 SINGULAR OUTSIDE ALSO \
          GOOD 0.02 OPPOSITE 0.08 OPPOSITE 0.02 OPPOSITE 0.08 OPPOSITE
OUTLAYER OUT1 NOT MARKS 
OUTLAYER ( TV$j NOT TM$j) NOT MARKS
}

RULECHECK 8XTV${j}_7 {
@ There should be at least two 8x TVns with space  ≤1.6um (S1) in 8x TMn and 8x TMn+1 intersection area, when either 8x TMn or 8x TMn+1 width and length (W1) >1.7um.
two_via_within_space_in_wide_metal TV${j} 1.6 TV${j}_underneath_metal TM${j} 1.7
}

RULECHECK 8XTV${j}_8 {
@ There should be at least two 8x TVns in the intersection area of 8xMn and 8xMn+1, when either wide metal of 8xTMn or 8xTMn+1 with both length L>10um and width W>3um,
@ the space between either via and wide metal is ≤ 6um (D3, D3 is the shortest running path length from 8xTVn to the wide metal).
single_via_from_wide_metal_one TV${j} TV${j}_underneath_metal TM${j} 3 10 6
}
			
RULECHECK 8XTV${j}_9 {
@ 45-degree rotated 8x TVn is not allowed.
OUTLAYER  (ANGLE TV${j} >= 44.9 <= 45.1) NOT INSIDE EDGE MARKS 
}



#//==============================================
#//  8X TMn  -  8X Metal(TM1 /TM2) design minima
#//==============================================

GROUP G8XTM${j} 8XTM${j}_?

RULECHECK 8XTM${j}_1 {
@ 8x TMn width.
@ Maximum width DRC doesn’t check PAD, DUPMK1 and INDMY region. ≥ 0.4um  ≤ 12um
  OUTLAYER (INT TM${j}_all < 0.4 ABUT < 90 SINGULAR REGION) NOT MARKS
  SETLAYER Y = TM${j}_all WITH WIDTH > 12
  OUTLAYER (Y NOT (OR ALPAPAD DUPMK1 INDMY)) NOT MARKS
}

RULECHECK 8XTM${j}_2a {
@ Space between 8x TMns. ≥ 0.4um
  OUTLAYER (EXT TM${j}_all < 0.4 ABUT < 90 SINGULAR REGION) NOT MARKS 
}

RULECHECK 8XTM${j}_2b {
@ Space between two 8x TMns that have a parallel run length >1.5um when at least one 8x TMn widths are >1.5um.	≥ 0.5um
  Mn_one_width TM${j}_all 1.501 1.5 0.5 
}

RULECHECK 8XTM${j}_2c {
@ Space between two 8x TMns that have a parallel run length >4.5um when at least one 8x TMn widths is >4.5um.	≥ 1.5um
  Mn_one_width TM${j}_all 4.501 4.5 1.5
}

RULECHECK 8XTM${j}_2d_R_DFM3 {
@ Space between (8x TMn or dummy 8x TMn).
@ DRC doesn’t check chip corner triangle region (NODMF) sizing up 0.4um if seal ring is added by SMIC	≤	12	um
  SETLAYER X = DRC:1 NOT TM${j}_all
  OUTLAYER ((X WITH WIDTH > 12) NOT (SIZE NODMF BY 0.4)) NOT MARKS 
}

RULECHECK 8XTM${j}_3 {
@ 8x TMn area	≥	0.56um2
  OUTLAYER (AREA TM${j}_all < 0.56) NOT MARKS
}

RULECHECK 8XTM${j}_4 {
@ Dielectric area enclosed by 8x TMn	≥	0.572	um2
  SETLAYER X = (HOLES TM${j}_all INNER) NOT TM${j}_all
  OUTLAYER (AREA X < 0.572) NOT MARKS
}

RULECHECK 8XTM${j}_5_l {
@ 8xTMn density (including dummy).Density check window size: 125um*125um, step size: 62.5um (exclude DUPMK1 region). ≥ 10% ≤ 85%
  SETLAYER X0 = DUPMK1 OR MARKS
  SETLAYER X = TM${j}_all NOT X0 
  SETLAYER Y = DRC:1 NOT X0
  OUTLAYER  DENSITY X Y \[AREA(X)/AREA(Y)\] < 0.1 WINDOW 125 STEP 62.5 BACKUP PRINT density_report_8XTM${j}_5_l.log
}

RULECHECK 8XTM${j}_5_h {
@ 8xTMn density (including dummy).Density check window size: 125um*125um, step size: 62.5um (exclude DUPMK1 region). ≥ 10% ≤ 85%
  SETLAYER X0 = DUPMK1 OR MARKS
  SETLAYER X = TM${j}_all NOT X0 
  SETLAYER Y = DRC:1 NOT X0
  OUTLAYER  DENSITY  X Y \[AREA(X)/AREA(Y)\] > 0.85 WINDOW 125 STEP 62.5 BACKUP PRINT density_report_8XTM${j}_5_h.log
}

RULECHECK 8XTM${j}_5_l_R_DFM2 {
@ 8xTMn density (including dummy) in DUMBM and TMnDUB. Density check window size: 125um*125um, step size: 62.5um (exclude DUPMK1 region).
@ DRC need check the design if DUMBM/TMnDUB width is >5um and <125um, where density ratio= 8xTMn area/( TMnDUB)area. ≥ 10% ≤ 85%
  SETLAYER DUMBMB = (DUMBM OR TM${j}DUB) NOT DUPMK1
  SETLAYER X = ENCLOSE RECTANGLE DUMBMB 125 125 ORTHOGONAL ONLY
  SETLAYER X0 = TM${j}_all NOT MARKS 
  SETLAYER Y0 = X NOT MARKS
  OUTLAYER (DENSITY X0 Y0 \[AREA(X0)/AREA(Y0)\] < 0.10 WINDOW 125 STEP 62.5 BACKUP PRINT density_report_8XTM${j}_5_R_l_1.log RDB density_report_8XTM${j}_5_R_l_1.rdb) NOT MARKS
  
  SETLAYER Y = (ENCLOSE RECTANGLE DUMBMB 5.001 5.001 ORTHOGONAL ONLY) NOT (X OR MARKS)
  OUTLAYER Z = DFM PROPERTY Y X0 \[ RATIO = AREA(X0)/AREA(Y) \] < 0.1
  DFM RDB Z density_report_8XTM${j}_5_R_l_2.rdb
}

RULECHECK 8XTM${j}_5_h_R_DFM2 {
@ 8xTMn density (including dummy) in DUMBM and TMnDUB. Density check window size: 125um*125um, step size: 62.5um (exclude DUPMK1 region).
@ DRC need check the design if DUMBM/TMnDUB width is >5um and <125um, where density ratio= 8xTMn area/TMnDUB area. ≥ 10% ≤ 85%
  SETLAYER DUMBMB = (DUMBM OR TM${j}DUB) NOT DUPMK1
  SETLAYER X = ENCLOSE RECTANGLE DUMBMB 125 125 ORTHOGONAL ONLY
  SETLAYER X0 = TM${j}_all NOT MARKS 
  SETLAYER Y0 = X NOT MARKS
  OUTLAYER (DENSITY X0 Y0 \[AREA(X0)/AREA(Y0)\] > 0.85 WINDOW 125 STEP 62.5 BACKUP  PRINT density_report_8XTM${j}_5_R_h_1.log RDB density_report_8XTM${j}_5_R_h_1.rdb) NOT MARKS

  SETLAYER  Y = (ENCLOSE RECTANGLE DUMBMB 5.001 5.001 ORTHOGONAL ONLY) NOT (X OR MARKS)
  OUTLAYER  Z = DFM PROPERTY Y X0 \[ RATIO = AREA(X0)/AREA(Y) \] > 0.85
  DFM RDB Z density_report_8XTM${j}_5_R_h_2.rdb
}

RULECHECK 8XTM${j}_6_R_DFM2 {
@ TMn density (including dummy) in full chip	≥	20%
  SETLAYER X = TM${j}_all NOT MARKS 
  SETLAYER Y = DRC:1 NOT MARKS  
  OUTLAYER DENSITY X Y \[AREA(X)/AREA(Y)\] < 0.2 PRINT density_report_8XTM${j}_6.log
}

RULECHECK 8XTM${j}_7 {
@ The density difference between any two neighbouring checking windows (window 200*200, stepping 200um). <= 50%	
  SETLAYER X = TM${j}_all NOT MARKS 
  SETLAYER Y = DRC:1 NOT MARKS 
  OUTLAYER  DENSITY X Y \[AREA(X)/AREA(Y)\] >= 0 WINDOW 200 GRADIENT > 0.5 ABSOLUTE BACKUP INSIDE OF LAYER DRC:1 PRINT density_report_8XTM${j}_7.log
}
}
}


####################################################8XTM end############################################################################################


##################################################10XTM begin##############################################################################################

#//==================================================
#// 10X TVn : 10X Via(TV1/TV2) design minima
#//==================================================

if { $10X_top_metal_counts > 0 } {
  if { $10X_top_metal_counts == 2 } {
    set 10xmetal_j { 1 2 } 
  } elseif { ($10X_top_metal_counts == 1) && ($MTT2_top_metal_counts == 0) } {
    set 10xmetal_j { 2 }
  }

foreach j $10xmetal_j {

GROUP G10XTV${j} 10XTV${j}_?

RULECHECK 10XTV${j}_1 {
@ Fixed 10x TVn size (square shape).	=	0.46	um
OUTLAYER  (NOT RECTANGLE TV${j} == 0.46 BY == 0.46) NOT MARKS
}

RULECHECK 10XTV${j}_2a {
@ Space between single 10x TVns.	≥	0.440	um
OUTLAYER  (EXT TV${j} < 0.44 ABUT < 90 SINGULAR REGION) NOT MARKS
}

RULECHECK 10XTV${j}_2b {
@ Space between10x TVns in 2x2 10x TVns array at the same net. Two Vias whose space ≤0.55um are considered to be in the same array. ≥ 0.54um
SETLAYER  X = SIZE TV${j} BY 0.275 OVERUNDER
SETLAYER  Y = SIZE X BY 0.6 UNDEROVER
SETLAYER  Z = TV${j} INTERACT Y
OUTLAYER  (EXT Z < 0.54 ABUT < 90 SINGULAR REGION CONNECTED) NOT MARKS
}

RULECHECK 10XTV${j}_2c {
@ Space between 10x TVn and its neighboring 10x TVn (T). 
@ The definition of neighboring 10x TVn (T) ：
@ 1. 10x TVn ( T) is in a 10x TVn group
@ 2.The number of this 10x TVn group is ≥4, there are at least 3 10x TVn s neighboring to 10x TVn (T)
@ 3.The space between 10x TVn (T) to other 10x TVn s in this group ≤0.66um	≥	0.66	um
SETLAYER  X = WITH NEIGHBOR TV${j} >= 3 SPACE <= 0.66
OUTLAYER (EXT TV${j} X < 0.66 ABUT < 90 SINGULAR REGION) NOT MARKS
}

RULECHECK 10XTV${j}_3_4 {
@ 10xTVn.3 10x TVn enclosure by 1x Mn/2x Mn/10x TMn, where 1x Mn/2x Mn/10x TMn is the metal layer directly underneath 10x TVn.
@          10x TVn must be fully covered by 1x Mn/2x Mn/10x TMn.	≥	0.02um
@ 10xTVn.4 Enclosure by 1x Mn/2x Mn/10x TMn when enclosure by 1x Mn/2x Mn/10x TMn on either perpendicular direction ≥0.02um,
@          and 1x Mn/2x Mn/10x TMn is the metal layer directly underneath 10x TVn. ≥ 0.08um
SETLAYER   OUT1 = RECTANGLE ENC TV${j} TV${j}_underneath_metal ABUT < 90  SINGULAR OUTSIDE ALSO \
          GOOD 0.02 OPPOSITE 0.08 OPPOSITE 0.02 OPPOSITE 0.08 OPPOSITE
OUTLAYER  OUT1 NOT MARKS 
OUTLAYER  (TV${j} NOT TV${j}_underneath_metal) NOT MARKS 
}

RULECHECK 10XTV${j}_5_6 {
@ 10xTVn.5 10x TVn enclosure by 10x TMn , where 10x TMn  is the metal layer directly above 10x TVn. 10x TVn must be fully covered by 10x TMn. ≥	0.02um
@ 10xTVn.6 Enclosure by 10x TMn when enclosure by 10x TMn on either perpendicular direction ≥0.02um, and 10x TMn is the metal layer directly above 10xTVn.≥ 0.08um
SETLAYER OUT1 = RECTANGLE ENC TV${j} TM${j} ABUT < 90 SINGULAR OUTSIDE ALSO \
          GOOD 0.02 OPPOSITE 0.08 OPPOSITE 0.02 OPPOSITE 0.08 OPPOSITE
OUTLAYER OUT1 NOT MARKS 
OUTLAYER  (TV${j} NOT TM${j}) NOT MARKS
}

  if { $10X_top_metal_counts == 2 } {
RULECHECK 10XTV${j}_7 {
@ At least two 10xTVns with space ≤1.6um (S1) in 10x TMn and 10x TMn+1 intersection area, when either 10x TMn or 10x TMn+1 width and length (W1) >1.7um.
two_via_within_space_in_wide_metal TV${j} 1.6 TV${j}_underneath_metal TM${j} 1.7
}
}

RULECHECK 10XTV${j}_8 {
@ There should be at least two 10xTVn in the intersection area of 10xTM and 10xTM+1, when either wide metal of 10xTM or 10xTM+1with both length L>10um and width W>3um,
@ the space between either via and wide metal is ≤6um (D3, D3 is the distance 5um away from this wide metal).
single_via_from_wide_metal_one TV${j} TV${j}_underneath_metal TM${j} 3 10 6
}
			
RULECHECK 10XTV${j}_9 {
@ 45-degree rotated 10x TVn is not allowed.
OUTLAYER (ANGLE TV${j} >= 44.9 <= 45.1) NOT INSIDE EDGE MARKS 
}


#//==============================================
#//  10X TMn  -  10X Metal(TM1 /TM2) design minima
#//==============================================

GROUP G10XTM${j} 10XTM${j}_?

RULECHECK 10XTM${j}_1 {
@ 10x TMn width.
@ Maximum width DRC doesn’t check PAD, DUPMK1 and INDMY region.	≥ 0.5 um ≤ 12um
  OUTLAYER (INT TM${j}_all < 0.5 ABUT < 90 SINGULAR REGION) NOT MARKS
  SETLAYER Y = TM${j}_all WITH WIDTH > 12
  OUTLAYER (Y NOT (OR ALPAPAD DUPMK1 INDMY)) NOT MARKS
}

RULECHECK 10XTM${j}_2a {
@ Space between 10x TMns. >= 0.500um
  OUTLAYER (EXT TM${j}_all < 0.5 ABUT < 90 SINGULAR REGION) NOT MARKS
}

RULECHECK 10XTM${j}_2b {
@ Space between two 10x TMns that have a parallel run length >1.5um when at least one 10x TMn widths are >1.5um. ≥ 0.65um
  Mn_one_width TM${j}_all 1.501 1.5 0.65 
}

RULECHECK 10XTM${j}_2c {
@ Space between two 10x TMns that have a parallel run length >4.5um when at least one 10x TMn widths is >4.5um.	≥ 1.5um
  Mn_one_width TM${j}_all 4.501 4.5 1.5
}

RULECHECK 10XTM${j}_2d_R_DFM3 {
@ Space between (10xTMn or dummy 10xTMn)
@ DRC doesn’t check chip corner triangle region (NODMF) sizing up 0.4um if seal ring is added by SMIC. ≤ 12um
  SETLAYER X = (DRC:1 NOT TM${j}_all) NOT (SIZE NODMF BY 0.4)
  OUTLAYER (X WITH WIDTH > 12) NOT MARKS
}

RULECHECK 10XTM${j}_3 {
@ 10x TMn area	≥ 1um2
  OUTLAYER (AREA TM${j}_all < 1) NOT MARKS
}

RULECHECK 10XTM${j}_4 {
@ Dielectric area enclosed by 10x TMn	≥ 2.5um2
  SETLAYER X = (HOLES TM${j}_all INNER) NOT TM${j}_all
  OUTLAYER (AREA X < 2.5) NOT MARKS
}

RULECHECK 10XTM${j}_5_l {
@ 10xTMn density (including dummy).Density check window size: 125um*125um, step size: 62.5um (exclude DUPMK1 region). ≥	10% and ≤ 85%
  SETLAYER X = TM${j}_all NOT (DUPMK1 OR MARKS)
  SETLAYER Y = DRC:1 NOT (DUPMK1 OR MARKS)
  OUTLAYER  DENSITY X Y \[AREA(X)/AREA(Y)\] < 0.1 WINDOW 125 STEP 62.5 BACKUP PRINT density_report_10XTM${j}_5_l.log
}
RULECHECK 10XTM${j}_5_h {
@ 10xTMn density (including dummy).Density check window size: 125um*125um, step size: 62.5um (exclude DUPMK1 region). ≥	10% and ≤ 85%
  SETLAYER X = TM${j}_all NOT (DUPMK1 OR MARKS)
  SETLAYER Y = DRC:1 NOT (DUPMK1 OR MARKS)
  OUTLAYER DENSITY X Y \[AREA(X)/AREA(Y)\] > 0.85 WINDOW 125 STEP 62.5 BACKUP PRINT density_report_10XTM${j}_5_h.log
}

RULECHECK 10XTM${j}_6_l_R_DFM2 {
@ 10xTMn density (including dummy) in DUMBM and TMnDUB. Density check window size: 125um*125um, step size: 62.5um (exclude DUPMK1 region).
@ DRC need check the design if DUMBM/TMnDUB width is >5um and <125um, where density ratio= 10xTMn area/ TMnDUB area. ≥	10% ≤ 85%
  SETLAYER DUMBMB = (DUMBM OR STM${j}DB) NOT DUPMK1
  SETLAYER X = ENCLOSE RECTANGLE DUMBMB 125 125 ORTHOGONAL ONLY
  SETLAYER X0 = TM${j}_all NOT MARKS 
  SETLAYER Y0 = X NOT MARKS 
  OUTLAYER DENSITY X0 Y0 \[AREA(X0)/AREA(Y0)\] < 0.10 WINDOW 125 STEP 62.5 BACKUP PRINT density_report_10XTM${j}_6_l.log RDB density_report_10XTM${j}_6_l_1.rdb

  SETLAYER Y = (ENCLOSE RECTANGLE DUMBMB 5.001 5.001 ORTHOGONAL ONLY) NOT (X OR MARKS)
  SETLAYER Z = DFM PROPERTY Y X0 \[ RATIO = AREA(X0)/AREA(Y) \] < 0.1
  DFM RDB Z density_report_10XTM${j}_6_l_2.rdb
  OUTLAYER COPY Z 
}

RULECHECK 10XTM${j}_6_h_R_DFM2 {
@ 10xTMn density (including dummy) in DUMBM and TMnDUB. Density check window size: 125um*125um, step size: 62.5um (exclude DUPMK1 region).
@ DRC need check the design if DUMBM/TMnDUB width is >5um and <125um, where density ratio= 10xTMn area/ TMnDUB area. ≥	10% ≤ 85%
  SETLAYER DUMBMB = (DUMBM OR STM${j}DB) NOT DUPMK1
  SETLAYER X = ENCLOSE RECTANGLE DUMBMB 125 125 ORTHOGONAL ONLY
  SETLAYER X0 = TM${j}_all NOT MARKS
  SETLAYER Y0 = X NOT MARKS  
  OUTLAYER DENSITY X0 Y0 \[AREA(X0)/AREA(Y0)\] > 0.85 WINDOW 125 STEP 62.5 BACKUP  PRINT density_report_10XTM${j}_6_h.log RDB density_report_10XTM${j}_6_h_1.rdb

  SETLAYER  Y = (ENCLOSE RECTANGLE DUMBMB 5.001 5.001 ORTHOGONAL ONLY) NOT (X OR MARKS)
  SETLAYER  Z =  DFM PROPERTY Y X0 \[ RATIO = AREA(X0)/AREA(Y) \] > 0.85
  DFM RDB Z density_report_10XTM${j}_6_h_2.rdb
  OUTLAYER COPY Z 
}
	
RULECHECK 10XTM${j}_7 {
@ The density difference between any two neighbouring checking windows (window 200*200, stepping 200um). <= 50%	
  SETLAYER X = TM${j}_all NOT MARKS
  SETLAYER Y = DRC:1 NOT MARKS 
  OUTLAYER DENSITY X Y \[AREA(X)/AREA(Y)\] >= 0 WINDOW 200 GRADIENT > 0.5 ABSOLUTE BACKUP  PRINT density_report_10XTM${j}_7.log
}
}
}




if { $MTT2_top_metal_counts != 0 } {
#//=================================================
#//  8x UTV: 8x UTV(LT) design rules
#//=================================================

RULECHECK LT_1 {
@ Fixed LT size (square shape).	=	0.36	um
OUTLAYER  (NOT RECTANGLE TV2 == 0.36 BY == 0.36) NOT MARKS
}

RULECHECK LT_2a {
@ Space between single LTs.	≥	0.34	um
OUTLAYER  (EXT TV2 < 0.34 ABUT < 90 SINGULAR REGION) NOT MARKS
}

RULECHECK LT_2b {
@ Space between LT and its neighboring LT (T). 
@ The definition of neighboring LT (T) ：
@ 1. LT ( T) is in a LT group
@ 2.The number of this LT group is ≥4, there are at least 3 LT s neighboring to LT (T)
@ 3.The space between LT (T) to other LT s in this group <0.56um	≥	0.54	um
SETLAYER X = WITH NEIGHBOR TV2 >= 3 SPACE < 0.56
OUTLAYER (EXT TV2 X < 0.54 ABUT < 90 SINGULAR REGION) NOT MARKS
}

RULECHECK LT_4 {
@ Enclosure by  1x Mn/2x Mn/8x TM1, 1x Mn/2x Mn/8x TM1 is the metal layer directly underneath LT. ≥ 0.08um
OUTLAYER  (ENC TV2 TV2_underneath_metal < 0.08 ABUT < 90 SINGULAR REGION) NOT MARKS
OUTLAYER  (TV2 NOT TV2_underneath_metal) NOT MARKS
}
	
RULECHECK LT_6 {
@ Enclosure by MTT2 when enclosure by MTT2	≥	0.3	um
OUTLAYER  (ENC TV2 TM2 < 0.3 ABUT < 90 SINGULAR REGION) NOT MARKS
OUTLAYER  (TV2 NOT TM2) NOT MARKS
}

RULECHECK LT_7 {
@ There should be at least two LTs with space  ≤1.6um (S1) in 8x TM1 and MTT2 intersection area, when either 8x TM1 or MTT2 width and length (W1) >1.7um.
two_via_within_space_in_wide_metal TV2 1.6 TV2_underneath_metal TM2 1.7
}
			
RULECHECK LT_8 {
@ There should be at least two LTs in the intersection area of 8x TM1 and MTT2, when either wide metal of 8x TM1 or MTT2 with both length L>10um and width W>3um,
@ the space between either via and wide metal is ≤ 6um (D3, D3 is the shortest running path length from Via to the wide metal).
single_via_from_wide_metal_one TV2 TV2_underneath_metal TM2 3 10 6
}
		
RULECHECK LT_9 {
@ 45-degree rotated LT is not allowed.
OUTLAYER ( ANGLE TV2 >= 44.9 <= 45.1) NOT INSIDE EDGE MARKS 
}		


#//=================================================
#//  MTT  -  MTT design minima (ultra-thick metal)
#//=================================================

GROUP GMTT2 MTT2_?

RULECHECK MTT2_1 {
@ Metal width. >= 2um
OUTLAYER  (INT TM2_all < 2 ABUT < 90 SINGULAR REGION) NOT MARKS
}

RULECHECK MTT2_2a {
@ Space between two MTT2 regions. >= 1um
OUTLAYER  (EXT TM2_all < 1 ABUT < 90 SINGULAR REGION) NOT MARKS
}

RULECHECK MTT2_2b {
@ Space between two MTT2s that have a parallel run length >4.5um when at least one MTT2 width is >4.5um.	≥	1.5	um
Mn_one_width_special TM2_all 4.5 4.5 1.5
}

RULECHECK MTT2_6_IND_32_G {
@ MTT2 Area (um2). ≥ 9um2
@ It allows 0.06um2 checking tolerance in INDMY region for  MTT2.6 and MTT2.7.
OUTLAYER  ((AREA TM2_all < 8.94 ) NOT OUTSIDE INDMY) NOT MARKS
OUTLAYER  ((AREA TM2_all < 9 ) NOT INSIDE INDMY) NOT MARKS
}

RULECHECK MTT2_7_IND_32_G {
@ Dielectric area enclosed by MTT2 (in um2). ≥	9um2
@ It allows 0.06um2 checking tolerance in INDMY region for  MTT2.6 and MTT2.7.
SETLAYER  X = (HOLES TM2_all INNER) NOT TM2_all
OUTLAYER  ((AREA X < 8.94 ) NOT OUTSIDE INDMY ) NOT MARKS
SETLAYER  Y = (HOLES TM2_all INNER) NOT TM2_all
OUTLAYER  ((AREA Y < 9 ) NOT INSIDE INDMY ) NOT MARKS
}

#IFDEF Guidelines_rules_CHECK NO
RULECHECK MTT2_6 {
@ MTT2 Area (um2). ≥ 9um2
OUTLAYER  (AREA TM2_all < 9) NOT MARKS
}

RULECHECK MTT2_7 {
@ Dielectric area enclosed by MTT2 (in um2). ≥	9um2
SETLAYER  X = (HOLES TM2_all INNER) NOT TM2_all
OUTLAYER  (AREA X < 9) NOT MARKS
}
#ENDIF
RULECHECK MTT2_8_l {
@ Density of MTT2 (including dummy). Density check window size: 125um*125um, step size: 62.5um,exclude:
@ 1. DUPMK1.
@ 2. Chip corner and seal ring.
@ 3. LOGO.	≥ 10% ≤	85%
SETLAYER  X0 =  ((DUPMK1 OR MARKS) OR CORN) OR LOGO
SETLAYER  X = (TM2 OR MTT2DM) NOT X0
SETLAYER  Y =  DRC:1 NOT X0  
OUTLAYER  DENSITY X Y \[AREA(X)/AREA(Y)\] < 0.1 WINDOW 125 STEP 62.5 BACKUP PRINT density_report_MTT2_8_l.log
}

RULECHECK MTT2_8_h {
@ Density of MTT2 (including dummy). Density check window size: 125um*125um, step size: 62.5um,exclude:
@ 1. DUPMK1.
@ 2. Chip corner and seal ring.
@ 3. LOGO.	≥ 10% ≤	85%
SETLAYER  X0 =  ((DUPMK1 OR MARKS) OR CORN) OR LOGO
SETLAYER  X = (TM2 OR MTT2DM) NOT X0
SETLAYER  Y =  DRC:1 NOT X0
OUTLAYER   DENSITY X Y \[AREA(X)/AREA(Y)\] > 0.85 WINDOW 125 STEP 62.5 BACKUP PRINT density_report_MTT2_8_h.log
}
	
RULECHECK MTT2_9_l {
@ MTT2 density in full chip(including dummy). >= 20% and <= 55%
SETLAYER  X = (TM2 OR MTT2DM) NOT MARKS
SETLAYER  Y = DRC:1 NOT MARKS 
OUTLAYER  DENSITY X Y \[AREA(X)/AREA(Y)\] < 0.2 PRINT density_report_MTT2_9_l.log
}

RULECHECK MTT2_9_h {
@ MTT2 density in full chip(including dummy). >= 20% and <= 55%
SETLAYER  X = (TM2 OR MTT2DM) NOT MARKS
SETLAYER  Y = DRC:1 NOT MARKS
OUTLAYER   DENSITY X Y \[AREA(X)/AREA(Y)\] > 0.55 PRINT density_report_MTT2_9_h.log
}

RULECHECK MTT2_14 {
@ MTT2 line width allowed.
@ DRC doesn’t check the MTT2 underneath of MD, DUPMK1 and INDMY region	≤	12	um
SETLAYER  X  = TM2_all WITH WIDTH > 12
OUTLAYER  (X NOT (OR DUPMK1 MD INDMY)) NOT MARKS  
}
}



VERBATIM {
//=============================================
//  PA1 -  Passivation one (PA1) design minima
//=============================================

GROUP GPA PA_?

PA_1_IND_32_G {
@ PA width. >=2um
@ It allows 0.01um checking tolerance in INDMY region for rule PA.1-4, ALPA.1-2.
 OUT1 = INT PA < 1.99 ABUT < 90 SINGULAR REGION
 (OUT1 NOT OUTSIDE INDMY) NOT MARKS
 OUT2 = INT PA < 2 ABUT < 90 SINGULAR REGION
 (OUT2 NOT INSIDE INDMY) NOT MARKS  
}

PA_2_IND_32_G {
@ Space between two PA. >= 2um
@ It allows 0.01um checking tolerance in INDMY region for rule PA.1-4, ALPA.1-2.
 OUT1 = EXT PA <1.99  ABUT < 90 SINGULAR REGION
 (OUT1 NOT OUTSIDE INDMY) NOT MARKS
 OUT2 = EXT PA < 2 ABUT < 90 SINGULAR REGION
 (OUT2 NOT INSIDE INDMY) NOT MARKS
}

PA_3_IND_32_G {
@ PA enclosed by ALPA. >= 0.5um
@ It allows 0.01um checking tolerance in INDMY region for rule PA.1-4, ALPA.1-2.
 OUT1 = ENC PA ALPA <0.49 ABUT < 90 SINGULAR REGION
 (OUT1 NOT OUTSIDE INDMY) NOT MARKS
 OUT2 = ENC PA ALPA < 0.5 ABUT < 90 SINGULAR REGION
 (OUT2 NOT INSIDE INDMY) NOT MARKS
}

PA_4_IND_32_G {
@ PA enclosed by TM2, MTT2. >= 0.5um
@ It allows 0.01um checking tolerance in INDMY region for rule PA.1-4, ALPA.1-2.
 OUT1 =  ENC PA TM2 < 0.49 ABUT < 90 SINGULAR REGION
 (OUT1 NOT OUTSIDE INDMY)  NOT MARKS
 OUT2 =  ENC PA TM2 < 0.5 ABUT < 90 SINGULAR REGION
 (OUT2 NOT INSIDE INDMY) NOT MARKS
 (PA NOT TM2) NOT MARKS
}

#IFDEF Guidelines_rules_CHECK NO
PA_1 {
@ PA width. >=2um 
 OUT1 = INT PA < 2 ABUT < 90 SINGULAR REGION
 OUT1 NOT MARKS 
}

PA_2 {
@ Space between two PA. >= 2um
 OUT1 = EXT PA < 2 ABUT < 90 SINGULAR REGION
 OUT1 NOT MARKS
}

PA_3 {
@ PA enclosed by ALPA. >= 0.5um
 OUT1 = ENC PA ALPA < 0.5 ABUT < 90 SINGULAR REGION
 OUT1 NOT MARKS
}

PA_4 {
@ PA enclosed by TM2, MTT2. >= 0.5um
 OUT1 =  ENC PA TM2 < 0.5 ABUT < 90 SINGULAR REGION
 OUT1 NOT MARKS
 (PA NOT TM2) NOT MARKS
}
#ENDIF
PA_5 {
@ PA without ALPA above it is not allowed.
 OUT1 = PA NOT ALPA
 OUT1 NOT MARKS
}

PA_6 {
@ 45-degree rotated PA is not allowed (except INDMY)
 X = (ANGLE PA == 0) OR EDGE (ANGLE PA == 90)
 Y = PA NOT WITH EDGE X
 OUT1 = Y NOT INSIDE INDMY
 OUT1 NOT MARKS
}			




//=======================================================
//  ALPA - ALPA design rules
//======================================================= 

GROUP GALPA ALPA_?

ALRDL = ALPA WITH WIDTH <= 35
ALPAPAD = ALPA NOT ALRDL

ALPA_1_IND_23_G {
@ ALPA width. >= 2um
@ It allows 0.01um checking tolerance in INDMY region for rule PA.1-4, ALPA.1-2.
  OUT1 = INT ALPA_all <1.99 ABUT < 89.9 SINGULAR REGION
  (OUT1 NOT OUTSIDE INDMY)  NOT MARKS 
  OUT2 = INT ALPA_all < 2 ABUT < 89.9 SINGULAR REGION
  (OUT2 NOT INSIDE INDMY)  NOT MARKS
}

ALPA_2_IND_23_G {
@ ALPA space.
@ This rule doesn’t check the space in the same polygon.	≥	2	um
@ It allows 0.01um checking tolerance in INDMY region for rule PA.1-4, ALPA.1-2.
  OUT1 = EXT ALPA_all <1.99 ABUT < 90 SINGULAR REGION SPACE
  (OUT1 NOT OUTSIDE INDMY)  NOT MARKS
  OUT2 = EXT ALPA_all < 2 ABUT < 90 SINGULAR REGION SPACE
  (OUT2 NOT INSIDE INDMY) NOT MARKS
}

#IFDEF Guidelines_rules_CHECK NO
ALPA_1 {
@ ALPA width. >= 2um
  OUT1 = INT ALPA_all < 2 ABUT < 89.9 SINGULAR REGION
  OUT1 NOT MARKS 
}

ALPA_2 {
@ ALPA space.
@ This rule doesn’t check the space in the same polygon.	≥	2	um
  OUT1 = EXT ALPA_all < 2 ABUT < 90 SINGULAR REGION SPACE
  OUT1 NOT MARKS
}
#ENDIF 

ALPA_3_R_DFM2 {
@ ALPA density with 100um*100um window, with exemption of interacting inductor. >= 10%
  checkregion = BORDER NOT INDMY
  X = ALPA_all NOT (MARKS OR INDMY)  
  Y = checkregion NOT MARKS 
  DENSITY X Y [AREA(X)/AREA(Y)] < 0.10 WINDOW 100 BACKUP PRINT density_report_ALPA_3.log
}
	
ALPA_5 {
@ ALPA density. >= 10%
  X = ALPA_all NOT MARKS 
  Y = DRC:1 NOT MARKS 
  DENSITY X Y [AREA(X)/AREA(Y)]  < 0.1 PRINT density_report_ALPA_5.log RDB density_report_ALPA_5.rdb
}

ALPA_6 {
@ ALPA density. <= 70%
  X = ALPA_all NOT MARKS 
  Y = DRC:1 NOT MARKS
  DENSITY X Y [AREA(X)/AREA(Y)]  > 0.7 PRINT density_report_ALPA_6.log RDB density_report_ALPA_6.rdb
}

ALPA_7 {
@ Space between (ALPA AND (MD sizing up 3um)) and (ALPA AND (MD sizing up 3um)) or ALRDL.
@ ALRDL is defined as ALPA layer width equal or smaller than 35um.
@ This rule doesn’t check the space in the same polygon.	≥	2.5	um
  X = ALPA AND (SIZE MD BY 3)
  OUT1 = EXT X < 2.5 ABUT >0 < 90 SINGULAR REGION SPACE
  OUT1 NOT MARKS 

  OUT2 =  (EXT X ALRDL < 2.5 ABUT >0 < 90 SINGULAR REGION) NOT (EXT ALPA < 2.5 ABUT >0 < 90 SINGULAR REGION NOTCH)
  OUT2 NOT MARKS
}
			


//===========================
//  MD (passivation-2) DRC
//===========================

GROUP GMD MD_?

MD_1 {
@ MD enclosure by ALPA. >= 1um
  OUT1 =  ENC MD ALPA < 1 ABUT<90 SINGULAR REGION OUTSIDE ALSO
  OUT1 NOT MARKS 
}

MD_2 {
@ MD width. >= 14um
  OUT1 = INT MD < 14 ABUT<90 SINGULAR REGION
  OUT1 NOT MARKS 
}

MD_3 {
@ MD space. >= 5um
  OUT1 = EXT MD < 5 ABUT < 90 SINGULAR REGION
  OUT1 NOT MARKS
}

MD_4_R_DFM2 {
@ MD must be within BORDER (chip edge). >= 3um
  OUT1 = ENC MD BORDER < 3 ABUT < 90 SINGULAR REGION OUTSIDE ALSO
  OUT1 NOT MARKS
}

MD_5 {
@ Space between MD and PA when MD doesn't touch with PA. >= 1.7um
  OUT1 = EXT MD PA < 1.7 ABUT > 0 < 90 SINGULAR REGION
  OUT1 NOT MARKS
}

/*
MD_6_R_DFM2 {
@ BORDER (chip edge) enclosure MD. <= 200um
  X = SIZE BORDER BY -200
  X AND MD
}
*/

MD_7 {
@ Inductor is prohibited under MD wire-bond pad opening
  OUT1 = INDMY AND MD
  OUT1 NOT MARKS
}

MD_9 {
@ MD is prohibited to interact with PA(PA size <3um)
  OUT1 = MD INTERACT (PA WITH WIDTH < 3)
  OUT1 NOT MARKS
}



//=============================================
// DUP  (Device Under Pad) design rules
//=============================================

GROUP GDUP DUP_?

DUP_area = DUPMK1 AND MD
			
DUP_1 {
@ For MD that interacts with DUPMK1, this piece of MD must be fully covered by DUPMK1.
  OUT1 = (MD INTERACT DUPMK1) NOT DUPMK1
  OUT1 NOT MARKS
}

DUP_2 {
@ Two metal layers (TM and TM-1) are needed between DUP pad and device, where the metal design must be solid.
  X = TM2 OR MTT2i  
  (DUP_area NOT X) NOT MARKS 
  (DUP_area NOT TV2_underneath_metal) NOT MARKS
  (HOLES (X AND DUP_area)) NOT MARKS
  (HOLES (TV2_underneath_metal AND DUP_area)) NOT MARKS
}
}

RULECHECK DUP_4 {
@ TV-1 pattern is not allowed under the DUP pad opening area.
  OUTLAYER (DUP_area AND [lindex $total_via_list end-1]i) NOT MARKS
}

if { ($8X_top_metal_counts >= 1) && ($MTT2_top_metal_counts == 0) } {
RULECHECK DUP_5 {
@ TV array (minimum 3*3) must be drawn between TM and TM-1 layer under the DUP pad opening area. 
@ Two Via areas whose space is within 0.70um are considered to be in the same array for 8xTV or 10xTV process.
@ It's required to follow TV space general rule 8xTVn.2b or 10xTVn.2c to draw TV array at the DUP pad opening area.
  SETLAYER TV2array = SIZE (SIZE (TV2 INSIDE DUP_area)  BY 0.35 OVERUNDER) BY 0.87 UNDEROVER
  OUTLAYER (DUP_area NOT ENCLOSE TV2array) NOT MARKS
}
}

if { ($8X_top_metal_counts <= 1) && ($MTT2_top_metal_counts != 0) } {
RULECHECK DUP_5 {
@ TV array (minimum 3*3) must be drawn between TM and TM-1 layer under the DUP pad opening area. 
@ Two Via areas whose space is within 0.70um are considered to be in the same array for 8xTV or 10xTV process.
@ It's required to follow TV space general rule 8xTVn.2b or 10xTVn.2c to draw TV array at the DUP pad opening area.
  SETLAYER TV2array = SIZE (SIZE (TV2 INSIDE DUP_area)  BY 0.35 OVERUNDER) BY 0.87 UNDEROVER
  OUTLAYER (DUP_area NOT ENCLOSE TV2array) NOT MARKS
}
}

if { ($10X_top_metal_counts >= 1) && ($MTT2_top_metal_counts == 0) } {
RULECHECK DUP_5 {
@ TV array (minimum 3*3) must be drawn between TM and TM-1 layer under the DUP pad opening area. 
@ Two Via areas whose space is within 0.70um are considered to be in the same array for 8xTV or 10xTV process.
@ It's required to follow TV space general rule 8xTVn.2b or 10xTVn.2c to draw TV array at the DUP pad opening area.
  SETLAYER TV2array = SIZE (SIZE (TV2 INSIDE DUP_area)  BY 0.35 OVERUNDER) BY 1.12 UNDEROVER
  OUTLAYER (DUP_area NOT ENCLOSE TV2array) NOT MARKS
}
}


VERBATIM {
#IFDEF CORN_CHECK YES

//================================
// Chip corner Rules
//================================

GROUP GCORN CORN_?

CORN_1 {
@ NODMF is dummy block layer for chip corner chamfer area A, and must fully cover chamfer area A.
 ( CORN NOT NODMF) NOT MARKS
}

CORN_2_5 {
@ CORN.2 Chamfer area A size at the chip corner. ≥ 70um
@ CORN.5 The layers (listed in Note1) should not overlap with chamfer area A
  (CORN AND AA) NOT MARKS
  (CORN AND AADMP) NOT MARKS
  (CORN AND DNW) NOT MARKS
  (CORN AND NW) NOT MARKS
  (CORN AND PSUB) NOT MARKS
  (CORN AND LVT_N) NOT MARKS
  (CORN AND LVT_P) NOT MARKS
  (CORN AND DG) NOT MARKS
  (CORN AND TG) NOT MARKS
  (CORN AND GT) NOT MARKS
  (CORN AND GTDMP) NOT MARKS
  (CORN AND GTMK2) NOT MARKS
  (CORN AND P2) NOT MARKS
  (CORN AND SN) NOT MARKS
  (CORN AND SP) NOT MARKS
  (CORN AND SAB) NOT MARKS
  (CORN AND CT) NOT MARKS
  (CORN AND M1i) NOT MARKS
  (CORN AND M2i) NOT MARKS
  (CORN AND M3i) NOT MARKS
  (CORN AND M4i) NOT MARKS
  (CORN AND M5i) NOT MARKS
  (CORN AND M6i) NOT MARKS
  (CORN AND M7i) NOT MARKS
  (CORN AND M8i) NOT MARKS
  (CORN AND V1i) NOT MARKS
  (CORN AND V2i) NOT MARKS
  (CORN AND V3i) NOT MARKS
  (CORN AND V4i) NOT MARKS
  (CORN AND V5i) NOT MARKS
  (CORN AND V6i) NOT MARKS
  (CORN AND V7i) NOT MARKS
  (CORN AND B1i) NOT MARKS
  (CORN AND B2i) NOT MARKS
  (CORN AND W0i) NOT MARKS
  (CORN AND W1i) NOT MARKS
  (CORN AND TV1i) NOT MARKS
  (CORN AND TV2i) NOT MARKS
  (CORN AND TM1i) NOT MARKS
  (CORN AND TM2i) NOT MARKS
  (CORN AND STV1i) NOT MARKS
  (CORN AND STV2i) NOT MARKS
  (CORN AND STM1i) NOT MARKS
  (CORN AND STM2i) NOT MARKS
  (CORN AND LTi) NOT MARKS
  (CORN AND MTT2i) NOT MARKS
  (CORN AND PA) NOT MARKS
  (CORN AND ALPA) NOT MARKS
  (CORN AND MD) NOT MARKS
  (CORN AND BORDER) NOT MARKS
}

CORN_3_4 {
@ NODMF size must be same as chamfer area A size. >= 70um
@ Space between NODMF and BORDER (127;0). = 0um
  (NODMF NOT ENCLOSE CORN) NOT MARKS
  ((NODMF INTERACT CORN) NOT TOUCH BORDER) NOT MARKS
  ((NODMF INTERACT CORN) AND BORDER) NOT MARKS
  ((ANGLE (NODMF NOT BORDER) >= 44.9 <= 45.1) NOT COIN EDGE BORDER) NOT INSIDE EDGE MARKS
}
#ENDIF


#IFDEF BORDER_CHECK YES
//================================================          
//  BORDER -  BORDER(Chip edge) layer design rule
//================================================ 

GROUP GBD BD_?

BD_1 {
@ The BORDER layer must cover the layers layout patterns (listed in Note1), which all chip layout patterns include seal ring if seal ring has been added by designers.
// Also refer to CORN.1,CORN.3,CORN.4
  ((DRC:1 NOT NODMF) NOT BORDER) NOT MARKS
}
			
BD_2 {
@ BORDER must fully cover the layers layout patterns except DNW (listed in Note1) if it needs SMIC to add seal ring.	≥	0.32	um
  (ENC AA BORDER < 0.32 ABUT < 90 REGION OPPOSITE) NOT MARKS
  (ENC AADMP BORDER < 0.32 ABUT < 90 REGION OPPOSITE) NOT MARKS
  (ENC DNW BORDER < 0.32 ABUT < 90 REGION OPPOSITE) NOT MARKS
  (ENC NW BORDER < 0.32 ABUT < 90 REGION OPPOSITE) NOT MARKS
  (ENC PSUB BORDER < 0.32 ABUT < 90 REGION OPPOSITE) NOT MARKS
  (ENC LVT_N BORDER < 0.32 ABUT < 90 REGION OPPOSITE) NOT MARKS
  (ENC LVT_P BORDER < 0.32 ABUT < 90 REGION OPPOSITE) NOT MARKS
  (ENC DG BORDER < 0.32 ABUT < 90 REGION OPPOSITE) NOT MARKS
  (ENC TG BORDER < 0.32 ABUT < 90 REGION OPPOSITE) NOT MARKS
  (ENC GT BORDER < 0.32 ABUT < 90 REGION OPPOSITE) NOT MARKS
  (ENC GTDMP BORDER < 0.32 ABUT < 90 REGION OPPOSITE) NOT MARKS
  (ENC GTMK2 BORDER < 0.32 ABUT < 90 REGION OPPOSITE) NOT MARKS
  (ENC P2 BORDER < 0.32 ABUT < 90 REGION OPPOSITE) NOT MARKS
  (ENC SN BORDER < 0.32 ABUT < 90 REGION OPPOSITE) NOT MARKS
  (ENC SP BORDER < 0.32 ABUT < 90 REGION OPPOSITE) NOT MARKS
  (ENC SAB BORDER < 0.32 ABUT < 90 REGION OPPOSITE) NOT MARKS
  (ENC CT BORDER < 0.32 ABUT < 90 REGION OPPOSITE) NOT MARKS
  (ENC M1i BORDER < 0.32 ABUT < 90 REGION OPPOSITE) NOT MARKS
  (ENC M2i BORDER < 0.32 ABUT < 90 REGION OPPOSITE) NOT MARKS
  (ENC M3i BORDER < 0.32 ABUT < 90 REGION OPPOSITE) NOT MARKS
  (ENC M4i BORDER < 0.32 ABUT < 90 REGION OPPOSITE) NOT MARKS
  (ENC M5i BORDER < 0.32 ABUT < 90 REGION OPPOSITE) NOT MARKS
  (ENC M6i BORDER < 0.32 ABUT < 90 REGION OPPOSITE) NOT MARKS
  (ENC M7i BORDER < 0.32 ABUT < 90 REGION OPPOSITE) NOT MARKS
  (ENC M8i BORDER < 0.32 ABUT < 90 REGION OPPOSITE) NOT MARKS
  (ENC V1i BORDER < 0.32 ABUT < 90 REGION OPPOSITE) NOT MARKS
  (ENC V2i BORDER < 0.32 ABUT < 90 REGION OPPOSITE) NOT MARKS
  (ENC V3i BORDER < 0.32 ABUT < 90 REGION OPPOSITE) NOT MARKS
  (ENC V4i BORDER < 0.32 ABUT < 90 REGION OPPOSITE) NOT MARKS
  (ENC V5i BORDER < 0.32 ABUT < 90 REGION OPPOSITE) NOT MARKS
  (ENC V6i BORDER < 0.32 ABUT < 90 REGION OPPOSITE) NOT MARKS
  (ENC V7i BORDER < 0.32 ABUT < 90 REGION OPPOSITE) NOT MARKS
  (ENC B1i BORDER < 0.32 ABUT < 90 REGION OPPOSITE) NOT MARKS
  (ENC B2i BORDER < 0.32 ABUT < 90 REGION OPPOSITE) NOT MARKS
  (ENC W0i BORDER < 0.32 ABUT < 90 REGION OPPOSITE) NOT MARKS
  (ENC W1i BORDER < 0.32 ABUT < 90 REGION OPPOSITE) NOT MARKS
  (ENC TM1i BORDER < 0.32 ABUT < 90 REGION OPPOSITE) NOT MARKS
  (ENC TM2i BORDER < 0.32 ABUT < 90 REGION OPPOSITE) NOT MARKS
  (ENC TV1i BORDER < 0.32 ABUT < 90 REGION OPPOSITE) NOT MARKS
  (ENC TV2i BORDER < 0.32 ABUT < 90 REGION OPPOSITE) NOT MARKS
  (ENC STM1i BORDER < 0.32 ABUT < 90 REGION OPPOSITE) NOT MARKS
  (ENC STM2i BORDER < 0.32 ABUT < 90 REGION OPPOSITE) NOT MARKS
  (ENC STV1i BORDER < 0.32 ABUT < 90 REGION OPPOSITE) NOT MARKS
  (ENC STV2i BORDER < 0.32 ABUT < 90 REGION OPPOSITE) NOT MARKS
  (ENC MTT2i BORDER < 0.32 ABUT < 90 REGION OPPOSITE) NOT MARKS
  (ENC LTi BORDER < 0.32 ABUT < 90 REGION OPPOSITE) NOT MARKS
  (ENC PA BORDER < 0.32 ABUT < 90 REGION OPPOSITE) NOT MARKS
  (ENC ALPA BORDER < 0.32 ABUT < 90 REGION OPPOSITE) NOT MARKS
  (ENC MD BORDER < 0.32 ABUT < 90 REGION OPPOSITE) NOT MARKS
}

BD_3 {
@ BORDER must fully cover DNW if it needs SMIC to add seal ring.	≥	0.45	um
  OUT1 = ENC DNW BORDER < 0.45 ABUT < 90 SINGULAR REGION OUTSIDE ALSO
  OUT1 NOT MARKS
}

BD_5 {
@ Enclosure of seal ring outer ring outline edge by BORDER layer if seal ring has been added by designers. = 5um
 BD_EXTENT = EXTENT DRAWN ORIGINAL
 BD_EXTENT_OTHER = EXTENT DRAWN ORIGINAL IGNORE BORDER
 BD_OTHER_OUTSIDE = BD_EXTENT_OTHER NOT BORDER

 MS_OUT_TEMP1 = (((((((M1i AND MARKS) OR (M2i AND MARKS)) OR (M3i AND MARKS)) OR (M4i AND MARKS)) OR (M5i AND MARKS)) OR (M6i AND MARKS)) OR (M7i AND MARKS))  OR (M8i AND MARKS)
 MS_OUT_TEMP2 = OR (TM1i AND MARKS) (TM2i AND MARKS) (STM1i AND MARKS) (STM2i AND MARKS) (MTT2i AND MARKS)
 MS_OUT = MS_OUT_TEMP1 OR MS_OUT_TEMP2

 X = SIZE BORDER BY -5
 Y = HOLES MS_OUT
 Z = SIZE MS_OUT BY 20 OVERUNDER
 (Z NOT COIN EDGE Y) NOT COIN EDGE X
}
#ENDIF



//===================================================================
//  AA Resistor Guidelines
//===================================================================

GROUP GRESAA RESAA_?

AARES = AA AND DIFRES
AARES_N = AARES AND SAB
AARES_S = AARES NOT SAB

AARES_W = DIFRES INSIDE EDGE AA
AARES_L = AARES NOT COIN EDGE AARES_W

AARES_N_W = (DIFRES INTERACT AARES_N) INSIDE EDGE AA
AARES_N_L = AARES_N NOT COIN EDGE AARES_N_W

//GTDMP_RESAA = GTDMP AND RESAA

RESAA_1 {
@ Non-sicilided resistor width, suggest resistor square number (length/width ratio) >= 1 for stable resistance. >= 0.4um
  OUT1 = DFM PROPERTY AARES_N AARES_N_L AARES_N_W OVERLAP ABUT ALSO MULTI [SQUARES = LENGTH(AARES_N_L)/LENGTH(AARES_N_W)] < 1
  OUT1 NOT MARKS 
  OUT2 = INT AARES_N_L < 0.4 OPPOSITE REGION
  OUT2 NOT MARKS 
}

RESAA_2 {
@ Non-sicilided resistor length. >= 0.4um
  OUT1 = INT AARES_N_W < 0.4 OPPOSITE REGION
  OUT1 NOT MARKS
}

RESAA_3 {
@ RESAA enclosure of resistor AA. >= 0.19um
@ (RESAA CUT resistor AA) is not allowed.
  OUT1 = ENC (AA INTERACT AARES) RESAA < 0.19 ABUT < 90 SINGULAR REGION
  OUT1 NOT MARKS 
  OUT2 = (AA INTERACT AARES) CUT RESAA
  OUT2 NOT MARKS 
}

/*
RESAA_4 {
@ SAB extension outside of non-sicilided AA resistor along resistor length direction. >= 0.22um
  ENC (AARES_N COIN EDGE AA) SAB < 0.22 ABUT < 90 REGION
}*/

RESAA_5 {
@ (SN or SP) enclosure resistor AA
@ Resistor AA CUT (SN OR SP) is not allowed.	≥	0.1	um
  X = AA INTERACT AARES
  (ENC X SN < 0.1 ABUT < 90 SINGULAR REGION) NOT MARKS
  (ENC X SP < 0.1 ABUT < 90 SINGULAR REGION) NOT MARKS
  (X CUT SN) NOT MARKS
  (X CUT SP) NOT MARKS
}

RESAA_6 {
@ DIFRES enclose AA resistor in width direction (both for non-silicide resistor and silicide resistor). >= 0um
  (AARES NOT WITH EDGE AARES_W == 2) NOT MARKS
  (INT AARES_W < 0.005 ABUT REGION) NOT MARKS
}

RESAA_7 {
@ DIFRES edge should align with SAB edge along non-silicide AA resistor length direction.
  X = AARES_N COIN EDGE AARES_W
  ((DIFRES TOUCH EDGE X) NOT COIN EDGE SAB) NOT INSIDE EDGE  MARKS

  Y = (SAB INTERACT AARES_N) INSIDE EDGE AA
  (Y NOT COIN EDGE AARES_W) NOT INSIDE EDGE  MARKS
}
			
RESAA_8 {
@ DIFRES edge should align with CT edge along silicide AA resistor length direction.
@ //refer to CT.1,CT.2a,AA.4a
  X = AARES_S COIN EDGE AARES_W
  Y = EXPAND EDGE X INSIDE BY 0.001
  (Y NOT TOUCH CT) NOT MARKS
  (AARES_S AND CT) NOT MARKS
  (EXT (CT AND (AA INTERACT AARES_S)) X < 0.04+0.07 ABUT > 0 < 90 REGION OPPOSITE EXCLUDE SHIELDED) NOT MARKS
}

RESAA_9_R_DFM2 {
@ It’s strongly recommended space between CT and SAB for non-sicilided AA resistor for spice model accuracy = 0.12um
@ //refer to CT.1,CT.2a,AA.4a
  X = AARES_N COIN EDGE AARES_W
  Y = EXPAND EDGE X OUTSIDE BY 0.12
  (Y NOT TOUCH CT) NOT MARKS
  (Y CUT CT) NOT MARKS
  (EXT (CT AND (AA INTERACT AARES_N)) X > 0.12 < 0.12+0.04+0.07 ABUT < 90 REGION OPPOSITE EXCLUDE SHIELDED) NOT MARKS
}

RESAA_10 {
@ Space between SAB and non-related AA. >= 0.22um
  (EXT (SAB INTERACT RESAA) AA < 0.22 ABUT < 90 SINGULAR REGION) NOT MARKS
}

RESAA_11 {
@ Space between SAB and non-related poly	≥	0.3	um
  (EXT (SAB INTERACT RESAA) GT < 0.3 ABUT < 90 SINGULAR REGION) NOT MARKS
}

/*
RESAA_12 {
@ Space between RESAA and non-related SAB	≥	0.22	um
  (EXT RESAA SAB < 0.22 ABUT < 90 SINGULAR REGION) NOT MARKS
}

RESAA_13 {
@ Space between AA resistor and (SN or SP).	≥	0.1	um
  EXT AARES SN < 0.1 ABUT < 90 SINGULAR REGION
  EXT AARES SP < 0.1 ABUT < 90 SINGULAR REGION
}*/

RESAA_13 {
@ Space between P+ non-silicided AA resistor and SN
@ Space between N+ non-silicided AA resistor and SP	≥	0.1
 (EXT (((AA AND DIFRES) AND SAB) AND SP) SN < 0.1 ABUT<90 REGION SINGULAR) NOT MARKS 
 (EXT (((AA AND DIFRES) AND SAB) AND SN) SP < 0.1 ABUT<90 REGION SINGULAR) NOT MARKS
}

RESAA_14 {
@ For non-silicide AA resistor, make sure the AA is covered by SAB and implanted by either SN or SP.
  ((AARES INTERACT SAB) NOT SAB) NOT MARKS
  ((AARES_N NOT OUTSIDE SN) NOT SN) NOT MARKS
  ((AARES_N NOT OUTSIDE SP) NOT SP) NOT MARKS
  ((AARES_N NOT SN) NOT SP) NOT MARKS
}
			
RESAA_15 {
@ AA non-silicide resistor with SP must lay on NW.
  ((AARES_N INTERACT SP) NOT NW) NOT MARKS
}
			
RESAA_16_R_DFM3 {
@ AA resistor must be rectangular.
  (NOT RECTANGLE AARES) NOT MARKS
}
			
RESAA_17_R_DFM3 {
@ Recommended not use dog-bone design at the end of AA resistor for contact pick-up
  X = AA TOUCH EDGE AARES_L
  Y = CONVEX EDGE AA < 2
  (X COIN EDGE Y) NOT INSIDE EDGE MARKS
}

RESAA_18 {
@ It’s not allowed butted SN and SP on non-silicide AA resistor. 		
  X = SN COIN EDGE SP
  Y = X NOT OUTSIDE EDGE AARES_N
  Y NOT INSIDE EDGE MARKS
}


//===================================================================
//  NW resistor under AA guidelines
//===================================================================

GROUP GRESNWAA RESNWAA_?

NWAARES = (RESNW AND AA) AND NW
NWAARES_W = NWAARES INSIDE EDGE NW
NWAARES_L = NWAARES NOT COIN EDGE NWAARES_W

NW_AARES = NW INTERACT NWAARES

RESNWAA_1 {
@ NW-resistor width. Suggest resistor square number (length/width ratio) ≥1 for stable resistance.	≥	1.8	um
  OUT1 = DFM PROPERTY NWAARES NWAARES_L NWAARES_W OVERLAP ABUT ALSO MULTI [SQUARES = LENGTH(NWAARES_L)/LENGTH(NWAARES_W)] < 1
  OUT1 NOT MARKS 
  OUT2 = INT NWAARES_L < 1.8 OPPOSITE REGION
  OUT2 NOT MARKS 
}

RESNWAA_2 {
@ Space between resistor NW and (resistor NW or NW).	≥	1	um
  (EXT NW_AARES NW < 1 ABUT < 90 SINGULAR REGION) NOT MARKS
}

RESNWAA_3 {
@ AA enclosure of resistor NW.	≥	1	um
  (ENC NW_AARES AA < 1 ABUT < 90 SINGULAR REGION) NOT MARKS
}

RESNWAA_4 {
@ Resistor NW enclosure of CT.	≥ 0.3um
  (ENC CT NW_AARES < 0.3 ABUT < 90 SINGULAR REGION) NOT MARKS
}

RESNWAA_5 {
@ Space between SAB and resistor NW. ≥	0.3um
  X = SAB INTERACT NW_AARES
  Y = HOLES X
  (ENC NW_AARES Y < 0.3 ABUT < 90 SINGULAR REGION) NOT MARKS
}

RESNWAA_6 {
@ It’s not allowed (AA AND RESNW) overlap with other implant layers (LVT_N/LVT_P/SP/SN) in the NW-resistor area.
  X = AA AND RESNW
  (X AND LVT_N) NOT MARKS
  (X AND LVT_P) NOT MARKS
  (X AND SP) NOT MARKS
  (X AND SN) NOT MARKS
}

/*		
RESNWAA_7_G {
@ Space between RESNW and CT.	=	0.03	um
@ //refer to CT.1,CT.2a,AA.4a
  X = NWAARES COIN EDGE NWAARES_W
  Y = EXPAND EDGE X OUTSIDE BY 0.03
  Y NOT TOUCH CT
  Y CUT CT
  EXT (CT AND NW_AARES) X > 0.03 < 0.03+0.04+0.07 ABUT < 90 REGION OPPOSITE EXCLUDE SHIELDED
}
*/

RESNWAA_7 {
@ Extension of RESNW outside of NW resistor along resistor width direction. ≥ 0.19um ≤ 0.5um
  (NWAARES NOT WITH EDGE NWAARES_W == 2) NOT MARKS
  (INT NWAARES_W < 0.005 ABUT REGION) NOT MARKS

  X = NWAARES_L NOT COIN EDGE RESNW
  (ENC (X) RESNW >= 0.19 <= 0.5 OPPOSITE) NOT INSIDE EDGE MARKS
}

RESNWAA_8 {
@ SAB must overlap with NW resistor except CT area.
 ( NWAARES NOT SAB) NOT  MARKS
  (NW_AARES NOT (SAB OR (HOLES SAB INNER))) NOT  MARKS
  ((SAB INTERACT NWAARES) AND CT) NOT  MARKS
}

/*
RESNWAA_9 {
@ Space between (NW AND RESNW) with SAB and other unrelated implant ( LVT/SN/SP). ≥ 0.1um
  X = (NW AND RESNW) INTERACT SAB
  EXT X LVT < 0.1 ABUT > 0 < 90 SINGULAR REGION
  EXT X (SN NOT COIN EDGE NWAARES_W) < 0.1 ABUT > 0 < 90 REGION
  EXT X SP < 0.1 ABUT > 0 < 90 SINGULAR REGION
}
*/

RESNWAA_10 {
@ SAB enclosure of (AA NOT OUTSIDE RESNW).	≥	0.22um
 ( ENC (AA NOT OUTSIDE RESNW) SAB < 0.22 ABUT < 90 SINGULAR REGION) NOT  MARKS
}

RESNWAA_11 {
@ SAB overlap of SN	=	0.4	um
  H = NW WITH EDGE (ANGLE NWAARES_L == 0)
  X = (HOLES (SAB INTERACT RESNW)) INTERACT H
  Y = ANGLE X == 90
  Z = ENC [Y] SN == 0.4 ABUT < 90 OPPOSITE
  (Y NOT TOUCH EDGE Z) NOT INSIDE EDGE MARKS

  V = NW WITH EDGE (ANGLE NWAARES_L != 0)
  X1 = (HOLES (SAB INTERACT RESNW)) INTERACT V
  Y1 = ANGLE X1 != 90
  Z1 = ENC [Y1] SN == 0.4 ABUT < 90 OPPOSITE
  (Y1 NOT TOUCH EDGE Z1) NOT INSIDE EDGE MARKS
}

RESNWAA_12 {
@ NW resistor must be rectangle.
  (NOT RECTANGLE NWAARES) NOT MARKS
}

RESNWAA_13 {
@ Only one (NW INTERACT RESNW) is allowed in one AA
  X = NW INTERACT RESNW
  (AA INTERACT X > 1) NOT MARKS
}
			
RESNWAA_14 {
@ Only two resistor N+ pickups are allowed in one NW resistor under AA.
@ Only one SAB hole in each resistor N+ pickup region is allowed.
@ The definition of resistor N+ pickup: ((AA AND SN) AND (NW INTERACT RESNW))
  X = (AA AND SN) AND (NW INTERACT RESNW)
  Y = HOLES SAB INNER
  (X INTERACT Y > 1) NOT MARKS

  ((AA INTERACT NWAARES) NOT ENCLOSE X == 2) NOT MARKS
}

RESNWAA_15_R_DFM3 {
@ Recommended space between SAB and CT 	=	0.3	um
  ((SAB INTERACT RESNW) AND CT) NOT MARKS

  X = HOLES (SAB INTERACT RESNW) INNER
  Y = X AND CT
  (DFM COPY (DFM SPACE Y X > 0.3 < 5 BY ENC BY LAYER Y) REGION) NOT MARKS
  (ENC Y X < 0.3 ABUT < 90 SINGULAR REGION) NOT MARKS
}




//===================================================================
//  NW resistor under STI guidelines
//===================================================================

GROUP GRESNWST RESNWST_?

NWSTRES = (RESNW AND NW) NOT AA
NWSTRES_W = NWSTRES INSIDE EDGE NW
NWSTRES_L = NWSTRES NOT COIN EDGE NWSTRES_W

NW_STRES = NW INTERACT NWSTRES

RESNWST_1 {
@ NW-resistor width. Suggest resistor square number length/width ratio）≥1 for stable resistance.	≥	1.8	um
  OUT1 = DFM PROPERTY NWSTRES NWSTRES_L NWSTRES_W OVERLAP ABUT ALSO MULTI [SQUARES = LENGTH(NWSTRES_L)/LENGTH(NWSTRES_W)] < 1
  OUT1 NOT MARKS 
  OUT2 = INT NWSTRES_L < 1.8 OPPOSITE REGION
  OUT2 NOT MARKS 
}

RESNWST_2 {
@ Space between resistor NW and adjacent AA.	≥	0.44	um
  (EXT NW_STRES AA < 0.44 ABUT < 90 REGION MEASURE ALL ) NOT MARKS 
}

RESNWST_3 {
@ Space between resistor NW and (resistor NW or NW).	≥	1	um
  (EXT NW_STRES NW < 1 ABUT < 90 SINGULAR REGION) NOT MARKS
}

RESNWST_4 {
@ Space between RESNW and silicided AA area.	=	0	um
  (NWSTRES_W NOT COIN OUTSIDE EDGE AA) NOT INSIDE EDGE MARKS
  (((RESNW INTERACT NWSTRES) INSIDE EDGE NW) NOT COIN OUTSIDE EDGE AA) NOT INSIDE EDGE MARKS
}

/*
RESNWST_5 {
@ Space between (NW AND RESNW) with SAB and other un-related implant LVT/SP.	≥	0.1	um
  X = (NW AND RESNW) INTERACT SAB
  EXT X LVT < 0.1 ABUT > 0 < 90 SINGULAR REGION
  EXT X SP < 0.1 ABUT > 0 < 90 SINGULAR REGION
}
*/

RESNWST_6 {
@ It’s not allowed (SN INTERACT RESNW) overlap with LVT_P in the resistor area.
  X = (SN INTERACT RESNW) AND NWSTRES
  (X AND LVT_P) NOT MARKS 
}

/*		
RESNWST_7 {
@ Extension of RESNW outside of NW resistor along resistor width direction.	≥ 0um and ≤ 0.2um
  NWSTRES NOT WITH EDGE NWSTRES_W == 2
  INT NWSTRES_W < 0.005 ABUT REGION
  ENC (NWSTRES_L) RESNW <= 0.2 ABUT < 90 OPPOSITE
}
*/
RESNWST_7 {
@ Extension of RESNW outside of NW resistor along resistor width direction. ≥ 0.19um ≤ 0.5um
  (NWSTRES NOT WITH EDGE NWSTRES_W == 2) NOT MARKS
  (INT NWSTRES_W < 0.005 ABUT REGION) NOT MARKS

  (ENC (NWSTRES_L) RESNW >= 0.19 <= 0.5 ABUT < 90 OPPOSITE) NOT INSIDE EDGE MARKS
}

RESNWST_8 {
@ AA enclosure of CT (AA INTERACT RESNW).	≥	0.3	um
@ It’s strongly recommended AA enclosure of CT (AA INTERACT RESNW) =0.3um for spice model accuracy.
  (ENC CT (AA INTERACT NWSTRES) < 0.3 ABUT < 90 SINGULAR REGION) NOT MARKS
}

RESNWST_8_R_DFM3 {
@ It’s strongly recommended AA enclosure of CT (AA INTERACT RESNW) =0.3um along resistor length direction for spice model accuracy. == 0.3um
  X = AA INTERACT (RESNW INTERACT NWSTRES)
  Y = X AND CT
  Z = X NOT OUTSIDE EDGE NWSTRES
  H1 = DFM SPACE Y [X] > 0.3 < 5 BY ENC BY LAYER Y
  (Z COIN EDGE H1) NOT INSIDE EDGE MARKS

  (ENC Y Z < 0.3 ABUT < 90 REGION) NOT MARKS
}

RESNWST_9 {
@ Resistor NW enclosure of CT.	≥	0.3	um
  (ENC CT NW_STRES < 0.3 ABUT < 90 SINGULAR REGION) NOT MARKS
}

RESNWST_10 {
@ AA enclosure of resistor NW	≥	0.3	um
  (ENC NW_STRES AA < 0.3 ABUT < 90 SINGULAR REGION) NOT MARKS
}

RESNWST_11 {
@ SN enclosure of AA.	≥	0.4	um
  (ENC (AA INTERACT NWSTRES) SN < 0.4 ABUT < 90 SINGULAR REGION) NOT MARKS
}

RESNWST_12 {
@ NW resistor must be rectangle.
  (NOT RECTANGLE NWSTRES) NOT MARKS
}


//===================================================================
//  Poly Resistor Guidelines
//===================================================================

GROUP GRESP1 RESP1_?

GTRES = GT AND PLRES
GTRES_N = GTRES AND SAB
GTRES_S = GTRES NOT SAB

GTRES_W = PLRES INSIDE EDGE GT
GTRES_L = GTRES NOT COIN EDGE GTRES_W

GTRES_N_W = (PLRES INTERACT GTRES_N) INSIDE EDGE GT
GTRES_N_L = GTRES_N NOT COIN EDGE GTRES_N_W

//GTDMP_RESP1 = GTDMP AND RESP1

RESP1_1 {
@ Non-sicilided resistor width, suggest resistor square number (length/width ratio) >= 1 for stable resistance. >= 0.4um
  OUT1 = DFM PROPERTY GTRES_N GTRES_N_L GTRES_N_W OVERLAP ABUT ALSO MULTI [SQUARES = LENGTH(GTRES_N_L)/LENGTH(GTRES_N_W)] < 1
  OUT1 NOT MARKS 
  OUT2 = INT GTRES_N_L < 0.4 OPPOSITE REGION
  OUT2 NOT MARKS 
}

RESP1_2 {
@ Non-sicilided resistor length. >= 0.4um
  (INT GTRES_N_W < 0.4 OPPOSITE REGION) NOT MARKS
}

RESP1_3 {
@ RESP1 enclosure of resistor poly. >= 0.19um
@ (RESP1 CUT resistor poly) is not allowed.
  (ENC (GT INTERACT GTRES) RESP1 < 0.19 ABUT < 90 SINGULAR REGION) NOT MARKS
  ((GT INTERACT GTRES) CUT RESP1) NOT MARKS
}

RESP1_4 {
@ SAB extension outside of non-sicilided poly resistor along resistor width direction. >= 0.22um
  (ENC (GTRES_N COIN EDGE GT) SAB < 0.22 ABUT < 90 REGION) NOT MARKS
}

RESP1_5 {
@ (SN or SP) enclosure resistor poly. >= 0.1um
@ (SN or SP CUT resistor poly) is not allowed.
  X = GT INTERACT GTRES
  (ENC X SN < 0.1 ABUT < 90 SINGULAR REGION) NOT MARKS
  (ENC X SP < 0.1 ABUT < 90 SINGULAR REGION) NOT MARKS
  (X CUT SN) NOT MARKS
  (X CUT SP) NOT MARKS
}

RESP1_6 {
@ PLRES enclose poly resistor in width direction (both for non-silicide resistor and silicide resistor). >= 0um
  (GTRES NOT WITH EDGE GTRES_W == 2) NOT MARKS
  (INT GTRES_W < 0.005 ABUT REGION) NOT MARKS
}

RESP1_7 {
@ PLRES edge should align with SAB edge along non-silicide poly resistor length direction.
  X = GTRES_N COIN EDGE GTRES_W
  ((GTRES TOUCH EDGE X) NOT COIN EDGE SAB) NOT INSIDE EDGE MARKS

  Y = (SAB INTERACT GTRES_N) INSIDE EDGE GT
  (Y NOT COIN EDGE GTRES_W) NOT INSIDE EDGE MARKS
}
			
RESP1_8 {
@ PLRES edge should align with CT edge along (silicide poly resistor length direction.
@ //refer to CT.1,CT.2a,GT.10
  X = GTRES_S COIN EDGE GTRES_W
  Y = EXPAND EDGE X INSIDE BY 0.001
  (Y NOT TOUCH CT) NOT MARKS
  (GTRES_S AND CT) NOT MARKS
  (EXT (CT AND (GT INTERACT GTRES_S)) X < 0.04+0.08 ABUT > 0 < 90 REGION OPPOSITE EXCLUDE SHIELDED) NOT MARKS
}

RESP1_9_R_DFM2 {
@ It’s strongly recommended space between CT and SAB for non-sicilided poly resistor for spice model accuracy.	= 0.12um
@ //refer to CT.1,CT.2a,GT.10
  X = GTRES_N COIN EDGE GTRES_W
  Y = EXPAND EDGE X OUTSIDE BY 0.12
  (Y NOT TOUCH CT) NOT MARKS
  (Y CUT CT) NOT MARKS
  (EXT (CT AND (GT INTERACT GTRES_N)) X > 0.12 < 0.12+0.04+0.08 ABUT < 90 REGION OPPOSITE EXCLUDE SHIELDED) NOT MARKS
}

RESP1_10 {
@ Space between SAB and non-related AA	≥	0.22	um
  (EXT (SAB INTERACT RESP1) AA < 0.22 ABUT < 90 SINGULAR REGION) NOT MARKS
}

RESP1_13 {
@ Space between RESP1 and GATE in source/drain direction (overlap is not allowed)	≥	0.165	um
  (RESP1 AND GATE) NOT MARKS
  (EXT RESP1 GATE_WE < 0.165 ABUT < 90 REGION) NOT MARKS
}

/*
RESP1_14 {
@ Space between poly resistor and (SN or SP).	≥	0.1	um
  EXT GTRES SN < 0.1 ABUT < 90 SINGULAR REGION
  EXT GTRES SP < 0.1 ABUT < 90 SINGULAR REGION
}
*/
RESP1_14 {
@ Space between P+ non-silicided poly resistor and SN
@ Space between N+ non-silicided poly resistor and SP	≥	0.1
  (EXT (((GT AND PLRES) AND SAB) AND SP) SN < 0.1 ABUT<90 REGION SINGULAR) NOT MARKS 
  (EXT (((GT AND PLRES) AND SAB) AND SN) SP < 0.1 ABUT<90 REGION SINGULAR) NOT MARKS
}

RESP1_15 {
@ For an non-salicide poly resistor, make sure the poly is covered by SAB and implanted by either SN or SP.
  ((GTRES INTERACT SAB) NOT SAB) NOT MARKS
  ((GTRES_N NOT OUTSIDE SN) NOT SN) NOT MARKS
  ((GTRES_N NOT OUTSIDE SP) NOT SP) NOT MARKS
  ((GTRES_N NOT SN) NOT SP) NOT MARKS
}

RESP1_16_R_DFM3 {
@ poly resistor must be rectangular.
  (NOT RECTANGLE GTRES) NOT MARKS
}

RESP1_17 {
@ Dog-bone design at the end of POLY resistor for contact pick-up is not suggested
  X = GT TOUCH EDGE GTRES_L
  Y = CONVEX EDGE GT < 2
  (X COIN EDGE Y) NOT INSIDE EDGE MARKS
}

RESP1_18 {
@ It’s not allowed butted SN and SP on non-silicide poly resistor. 
  X = SN COIN EDGE SP
  Y = X NOT OUTSIDE EDGE GTRES_N
  Y NOT INSIDE EDGE MARKS
}



//===================================================================
//  Poly E-Fuse layout guidelines
//===================================================================

GROUP GEFU EFU_?

EFU_1b {
@ FUSEMK1 (81;152) Must interact wtih EFUSE (81;2) region.
  (FUSEMK1 NOT INTERACT EFUSE) NOT  MARKS
}

EFU_1c {
@ FUSEMK1 (81;152) Must fully cover EFUSE (81;2) region.
  (EFUSE NOT FUSEMK1) NOT  MARKS
}

EFU_2b {
@ EFUSE (81;2) must interact with GTFUSE(81;1).
  (EFUSE NOT INTERACT GTFUSE) NOT  MARKS
}

EFU_2c {
@ EFUSE (81;2) must fully cover GTFUSE(81;1).
  (GTFUSE NOT EFUSE) NOT  MARKS
}

EFU_6 {
@ Space between ((GATE sizing up 0.06um) AND poly) (0.04um ≤channel length ≤ 0.09um) 
@ and (neighboring ((poly or POLY_DMY) NOT POLY_JOG)) for core NMOS/PMOS in FUSEMK1 region.=	0.1/0.11	um
 GT_all_new = GT_all NOT POLY_JOG

 X0 = LENGTH GATE_LE >= 0.04 <= 0.09
 X1 = GATE_CORE_SIZE_6 TOUCH EDGE ((GATE_CORE WITH EDGE X0) NOT COIN EDGE GATE_LE)
 X2 =  EXT (X1) GT_all_new == 0.1 OPPOSITE 
 X3 = (EXT (X2) GT_all_new == 0.11 OPPOSITE) NOT OUTSIDE EDGE FUSEMK1

 OUT1 = EXPAND EDGE X3 OUTSIDE BY 0.1
 OUT1 NOT MARKS
}

EFU_7 {
@ Space between CT and its neighboring CT (T) in EFUSE region. 
@ The definition of neighboring CT (T) ：
@ 1.CT ( T) is in a CT group
@ 2.The number of this CT group is ≥4, there are at least 3 CTs neighboring to CT (T)
@ 3.The space between CT (T) to other CTs in this group <0.09um.	≥	0.07	um
  X = (WITH NEIGHBOR CT >= 3 SPACE < 0.09) NOT OUTSIDE EFUSE
  W = EXT CT X < 0.07 ABUT < 90 SINGULAR REGION
  W NOT MARKS
}

EFU_8 {
@ CT enclosure by (poly or GTDMP or GTDOP) when enclosure by (poly or GTDMP or GTDOP) on either perpendicular direction ≥0um in EFUSE region.	≥ 0.022um
  X = CT NOT OUTSIDE EFUSE
  Y = RECTANGLE ENC X GT_all_3 ABUT > 0 <= 90 SINGULAR
      GOOD 0 0.022 OPPOSITE 0 0.022 OPPOSITE
  Y NOT MARKS
}
}

for { set j 1 } { $j < $M1_and_1XMn_metal_counts } { incr j } {
RULECHECK EFU_9_V$j {
@ Space between 1x Vns when the run length >-0.04um in FUSEMK1 region.	≥	0.07	um
OUTLAYER ((EXT V$j < 0.07 ABUT < 90 SINGULAR REGION OPPOSITE EXTENDED 0.04) AND FUSEMK1) NOT MARKS
}
}


VERBATIM {
//===================================================
//  Diode design rules
//===================================================

GROUP GDSTR DSTR_?

DSTR_PACT = DSTR INTERACT PACT

DSTR_1 {
@ Width of (DSTR INTERACT P+AA)	≥	0.16	um
 (INT DSTR_PACT < 0.16 ABUT < 90 SINGULAR REGION) NOT MARKS
}

DSTR_2 {
@ Space between two (DSTR INTERACT P+AA) ≥ 0.16um
 (EXT DSTR_PACT < 0.16 ABUT < 90 SINGULAR REGION) NOT MARKS
}

DSTR_3 {
@ Space between (DSTR INTERACT P+AA) and P+AA.
@ It’s not allowed P+AA CUT DSTR. ≥ 0.065um
 (EXT DSTR_PACT PACT < 0.065 ABUT < 90 SINGULAR REGION) NOT MARKS
 (PACT CUT DSTR) NOT MARKS
}

DSTR_4 {
@ DSTR enclosure of P+AA,when
@ 1. P+AA NOT INTERACT ((poly OR GTDMP) OR GTDOP),
@ 2. P+AA NOT INTERACT RESAA,
@ 3. P+AA INTERACT CT. 	≥	0.065	um
  PACT_CHECK = ((PACT NOT INTERACT GT_all_3) NOT INTERACT RESAA) INTERACT CT
  (ENC PACT_CHECK DSTR < 0.065 ABUT < 90 SINGULAR REGION) NOT MARKS
}

DSTR_5 {
@ Area of (DSTR INTERACT P+AA) 	≥	0.1um
  (AREA DSTR_PACT < 0.1) NOT MARKS
}

DSTR_6 {
@ Enclosed of (DSTR INTERACT P+AA)	≥	0.1um
  X = (HOLES DSTR_PACT INNER) NOT DSTR_PACT
  (AREA X < 0.1) NOT MARKS
}

DSTR_7 {
@ P+AA must be fully covered by DSTR in core region,when
@ 1. P+AA NOT INTERACT ((poly OR GTDMP) OR GTDOP),
@ 2. P+AA NOT INTERACT RESAA,
@ 3. P+AA INTERACT CT.
@ DRC doesn't check BIPOLA and CLPDMY region.
  PACT_CHECK = ((PACT NOT INTERACT GT_all_3) NOT INTERACT RESAA) INTERACT CT
  ((((PACT_CHECK NOT DGTG) NOT DSTR) NOT BIPOLA) NOT CLPDMY) NOT MARKS
}
		
DSTR_8 {
@ DSTR overlap (AA INTERACT ((poly OR GTDMP) OR GTDOP)) and AADUM is prohibited.
  X = AA INTERACT GT_all_3
  (DSTR AND X) NOT MARKS
  (DSTR AND AADUM) NOT MARKS
}			
}


#//===================================================
#//  MOM design rules
#//===================================================

GROUP GMOM MOM_?

foreach metal $M1_and_1XMn_list {

RULECHECK MOM_1_$metal {
@ Space between M1/1xMn line-end and M1/1xMn in MOMDMY region
@ M1/1x Mn line-end definition: M1/1x Mn edge with length < 0.07um (W) between two outer vertex, ANGLE1=ANGLE2=90, adjacent edge A1/A2 ≥ 0.05um. ≥ 0.1um
SETLAYER ${metal}_end = CONVEX EDGE $metal ANGLE1 == 90 LENGTH1 >= 0.05 ANGLE2 == 90 LENGTH2 >= 0.05 WITH LENGTH < 0.07
SETLAYER X = EXT ${metal}_end ($metal INTERACT MOMDMY) < 0.1 ABUT < 90 REGION
OUTLAYER (X NOT OUTSIDE MOMDMY) NOT MARKS
}
}

RULECHECK MOM_7 {
@ Sidewall area of total metals (M1 and 1xMn) in MOMDMY.
@ For the definition of the sidewall area:  (metal length in MOMDMY (L)) * metal thickness. (Pls refer metal option table for metal thickness);
@ Total sidewall area is to calculate  the area of (finger number-1).
@ DRC check MOM sidewall area when metal space S<0.15um.	≤	9.00E+06

  foreach metal $M1_and_1XMn_list {
SETLAYER M_REGION_$metal = $metal AND MOMDMY
SETLAYER M_EDGE_$metal = ($metal COIN EDGE M_REGION_$metal) NOT COIN EDGE (CONVEX EDGE $metal == 2)
SETLAYER M_EDGE_${metal}_END = EXT \[M_EDGE_$metal\] < 0.15 ABUT < 90 OPPOSITE
   lappend MOM_6_list_length LENGTH(M_EDGE_${metal}_END)
   lappend MOM_6_list_layer_edge M_EDGE_${metal}_END
}

set MOM_6_list_length [join $MOM_6_list_length +]

SETLAYER OUT1 = DFM PROPERTY MOMDMY $MOM_6_list_layer_edge OVERLAP ABUT ALSO MULTI \[SIDE_WALL_AREA = ($MOM_6_list_length)*0.1/2\] > 9.00E+06
OUTLAYER OUT1 NOT MARKS

#2X:0.225
#8X:0.9
#10X:1.25
#MTT2: 3.5
}




#//===================================================
#//  LOGO design rules
#//===================================================

GROUP GLOGO LOGO_?

foreach metal [ concat $total_metal_list_with_name_mapping { AA GT ALPA } ] {
RULECHECK LOGO_1_$metal {
@ Space between LOGO and (AA/poly/M1/1xMn/2xMn/8xTMn/10TMn/MTT2/ALPA OUTSIDE LOGO).	≥	10	um
SETLAYER X = ($metal INTERACT (SIZE LOGO BY 10)) OUTSIDE LOGO
OUTLAYER (EXT LOGO X < 10 ABUT < 90 SINGULAR REGION) NOT MARKS
}
}

RULECHECK LOGO_2 {
@ It's not allowed LOGO overlap with PA.
OUTLAYER (LOGO AND PA) NOT MARKS
}		



#//===================================================
#//  Metal low density design rules
#//===================================================

GROUP GLDNMK1 LDNMK1_?

RULECHECK LDNMK1_1 {
@ Width of M1 or M1DOP within LDNMK1 region. 	≥	0.14um
SETLAYER X = OR (M1 NOT OUTSIDE LDNMK1) (M1DOP NOT OUTSIDE LDNMK1)
SETLAYER Y = INT X < 0.14 ABUT < 90 SINGULAR REGION
OUTLAYER (Y AND LDNMK1) NOT MARKS
}

RULECHECK LDNMK1_2 {
@ Width of M1DUM within LDNMK1 region. 	≥	0.12	um
SETLAYER X = M1DUM NOT OUTSIDE LDNMK1
SETLAYER Y = INT X < 0.12 ABUT < 90 SINGULAR REGION
OUTLAYER (Y AND LDNMK1) NOT MARKS
}

foreach metal [ lrange $M1_and_1XMn_list 1 end ] {
RULECHECK LDNMK1_3_$metal {
@ Width of 1xMn or MnDOP within LDNMK1 region. 	≥	0.14	um
SETLAYER X = OR ($metal NOT OUTSIDE LDNMK1) (${metal}DOP NOT OUTSIDE LDNMK1)
SETLAYER Y = INT X < 0.14 ABUT < 90 SINGULAR REGION
OUTLAYER (Y AND LDNMK1) NOT MARKS
}

RULECHECK LDNMK1_4_$metal {
@ Width of 1xMn dummy within LDNMK1 region. ≥ 0.12um
SETLAYER X = ${metal}DUM NOT OUTSIDE LDNMK1
SETLAYER Y = INT X < 0.12 ABUT < 90 SINGULAR REGION
OUTLAYER (Y AND LDNMK1) NOT MARKS
}
}

RULECHECK LDNMK1_5 {
@ Space between M1/M1DOP and M1/M1DOP within LDNMK1 region 	≥	0.14	um
SETLAYER X = OR M1 M1DOP
SETLAYER Y = EXT X < 0.14 ABUT < 90 SINGULAR REGION
OUTLAYER (Y NOT OUTSIDE LDNMK1) NOT MARKS
}

RULECHECK LDNMK1_6 {
@ Space between M1DUM and M1DUM within LDNMK1 region 	≥	0.12	um
SETLAYER Y = EXT M1DUM < 0.12 ABUT < 90 SINGULAR REGION
OUTLAYER (Y NOT OUTSIDE LDNMK1) NOT MARKS
}

foreach metal [ lrange $M1_and_1XMn_list 1 end ] {
RULECHECK LDNMK1_7_$metal {
@ Space between 1xMn/1xMnDOP (n=2~8) and  1xMn/1xMnDOP (n=2~8) within LDNMK1 region.	≥	0.14	um
SETLAYER X = OR $metal ${metal}DOP
SETLAYER Y = EXT X < 0.14 ABUT < 90 SINGULAR REGION
OUTLAYER (Y NOT OUTSIDE LDNMK1) NOT MARKS
}

RULECHECK LDNMK1_8_$metal {
@ Space between 1xMnDUM(n=2~8) and 1xMnDUM(n=2~8)  within LDNMK1 region.	≥	0.12	um
SETLAYER Y = EXT ${metal}DUM < 0.12 ABUT < 90 SINGULAR REGION
OUTLAYER (Y NOT OUTSIDE LDNMK1) NOT MARKS
}
}

RULECHECK LDNMK1_9 {
@ Guardring(MARKG) must be put in the region (LDNMK1 NOT (LDNMK1 sizing down 1um))
SETLAYER X = LDNMK1 NOT (SIZE LDNMK1 BY -1)
OUTLAYER (MARKG NOT INSIDE X) NOT MARKS
}

for { set j 1 } { $j <= [ llength $1XVn_list ] } {incr j } {
RULECHECK LDNMK1_10_V$j {
@ 1xVn bar must be continuous as a ring within (LDNMK1 NOT (LDNMK1 sizing down 4um)). DRC doesn’t check when (LDNMK1 INTERACT INDMY)).
SETLAYER X = LDNMK1 NOT INTERACT INDMY
SETLAYER Y = (X NOT (SIZE LDNMK1 BY -4)) NOT OUTSIDE V$j
SETLAYER Y_hole = HOLES Y INNER 
SETLAYER Z_hole = HOLES (1XV${j}_BAR AND LDNMK1) INNER
OUTLAYER (Y_hole NOT INSIDE Z_hole) NOT MARKS
OUTLAYER ((1XV${j}_BAR NOT OUTSIDE X) NOT X) NOT MARKS
}

SETLAYER 1XV${j}_BAR = (WITH WIDTH V$j == 0.15) INTERACT LDNMK1

RULECHECK LDNMK1_11_V$j {
@ 1xVn bar is allowed in (LDNMK1 NOT (LDNMK1  sizing down 4um)).
SETLAYER X = LDNMK1 NOT (SIZE LDNMK1 BY -4)
OUTLAYER (X NOT ENCLOSE 1XV${j}_BAR) NOT MARKS
}

RULECHECK LDNMK1_12_V$j {
@ Width of 1xVn bar in guard ring = 0.15um
OUTLAYER (NOT WITH WIDTH (V${j} AND LDNMK1) == 0.15) NOT MARKS
}

RULECHECK LDNMK1_13_V$j {
@ Space between 1xVn bar in LDNMK1 and 1xVn/1xRVn	≥	0.35	um
OUTLAYER (EXT 1XV${j}_BAR V$j < 0.35 ABUT < 90 SINGULAR REGION) NOT MARKS
}

RULECHECK LDNMK1_14_V$j {
@ Space between 1xVn  bar and 1xVn  bar within LDNMK1 	≥	0.6	um
OUTLAYER (EXT 1XV${j}_BAR < 0.6 ABUT < 90 SINGULAR REGION) NOT MARKS
}

RULECHECK LDNMK1_15_V$j {
@ 1xVn bar enclosure by M1/1xMn(n=1~8) within LDNMK1	≥	0.1	um
OUTLAYER (ENC 1XV${j}_BAR M$j < 0.1 ABUT < 90 SINGULAR REGION) NOT MARKS
OUTLAYER (ENC 1XV${j}_BAR M[expr $j +1] < 0.1 ABUT < 90 SINGULAR REGION) NOT MARKS
}
}




VERBATIM {
//===================================================
//  SRAM marking layer design rules
//===================================================

GROUP GSRAM SRAM_?

SHARE_CT = CT AND ((((NOT RECTANGLE CT ASPECT == 1) INTERACT INST) INTERACT GT) INTERACT AA)

SRAM_7 {
@ Edges of bit cell marking layer (STSRAM, DPSRAM, LRSRAM,2PSRAM) are required to be aligned with INST layer edges.
  (STSRAM NOT COIN EDGE INST) NOT INSIDE EDGE MARKS
  (DPSRAM NOT COIN EDGE INST) NOT INSIDE EDGE MARKS
  (LRSRAM NOT COIN EDGE INST) NOT INSIDE EDGE MARKS
  (2PSRAM NOT COIN EDGE INST) NOT INSIDE EDGE MARKS
  ((((INST NOT COIN EDGE STSRAM) NOT COIN EDGE DPSRAM) NOT COIN EDGE LRSRAM) NOT COIN EDGE 2PSRAM) NOT INSIDE EDGE MARKS
}

SRAM_8 {
@ If the gate is enclosed by INST layer, it should be also covered by bit cell marking layers (STSRAM, DPSRAM, LRSRAM, 2PSRAM).
  X = GATE NOT OUTSIDE INST
  (X NOT (((STSRAM OR DPSRAM) OR LRSRAM) OR 2PSRAM)) NOT MARKS
  ((X NOT OUTSIDE STSRAM) NOT STSRAM) NOT MARKS
  ((X NOT OUTSIDE DPSRAM) NOT DPSRAM) NOT MARKS
  ((X NOT OUTSIDE LRSRAM) NOT LRSRAM) NOT MARKS
  ((X NOT OUTSIDE 2PSRAM) NOT 2PSRAM) NOT  MARKS
}
		
SRAM_9 {
@ If the area is enclosed by bit cell marking layers (STSRAM, DPSRAM, LRSRAM, 2PSRAM), it should be also covered by INST layer.
  (STSRAM NOT INST) NOT MARKS
  (DPSRAM NOT INST) NOT  MARKS
  (LRSRAM NOT INST) NOT  MARKS
  (2PSRAM NOT INST) NOT  MARKS
}
		
SRAM_10 {
@ HPBL is the marking layer for low voltage SRAM, the edge of HPBL layer must be aligned with the boundary of STSRAM, DPSRAM, LRSRAM, 2PSRAM.
  ((((HPBL NOT COIN EDGE STSRAM) NOT COIN EDGE DPSRAM) NOT COIN EDGE LRSRAM) NOT COIN EDGE 2PSRAM) NOT  INSIDE EDGE MARKS
}
			
SRAM_11 {
@ INST width	≥	0.16	um
  (INT INST < 0.16 ABUT < 90 SINGULAR REGION) NOT  MARKS
}

SRAM_12 {
@ INST space	≥	0.16	um
  (EXT INST < 0.16 ABUT < 90 SINGULAR REGION) NOT  MARKS
}

SRAM_13 {
@ Space between INST and (GATE NOT INTERACT INST)	≥	0.115	um
  (EXT INST (GATE NOT INTERACT INST) < 0.115 ABUT < 90 SINGULAR REGION) NOT  MARKS
}

SRAM_14 {
@ INST enclosure GATE along source/drain direction	≥	0.115	um
  (ENC GATE_WE INST < 0.115 ABUT < 90 REGION OPPOSITE) NOT  MARKS
}

SRAM_15 {
@ INST enclosure GATE along poly length direction	≥	0.065	um
  (ENC GATE_LE INST < 0.065 ABUT < 90 REGION OPPOSITE) NOT  MARKS
}

SRAM_16 {
@ INST extension outside of NW (NW interact AA).Extension=0um is allowed.	≥	0.16	um
  (ENC (NW INTERACT AA) INST < 0.16 ABUT > 0 < 90 SINGULAR REGION) NOT  MARKS
}

SRAM_17 {
@ Overlap of INST and NW (NW interact AA). Extension=0um is allowed.	≥	0.16	um
  (INT (NW INTERACT AA) INST < 0.16 ABUT > 0 < 90 SINGULAR REGION) NOT  MARKS
}

SRAM_18 {
@ It’s not allowed (AA, CT and V1) cut INST.
  (AA CUT INST) NOT  MARKS
  (CT CUT INST) NOT  MARKS
  (V1 CUT INST) NOT  MARKS
}
			
SRAM_19 {
@ It’s not allowed P2 cut INST.
 ( P2 CUT INST) NOT  MARKS
}
		
SRAM_20 {
@ GATE direction must be same in INST region.
  X = GATE NOT OUTSIDE INST
  Y = ANGLE (GATE_LE COIN EDGE X) == 0
  Z = X WITH EDGE Y
  H = X NOT Z
  ((INST CUT H) CUT Z) NOT  MARKS
}		




//========================================================
// Varactor design rules
//========================================================

GROUP GVAR VAR_?

VAR_1_G {
@ Channel length of core varactor MOS	≥ 0.2um	≤ 10um

  ((LENGTH GATE_LE < 0.2) INSIDE EDGE (VARMOS NOT DGTG)) NOT INSIDE EDGE  MARKS
  ((LENGTH GATE_LE > 10) INSIDE EDGE (VARMOS NOT DGTG)) NOT INSIDE EDGE  MARKS
}
		
VAR_2_G {
@ Channel length of I/O varactor MOS	≥ 0.2um	≤ 10um

  ((LENGTH GATE_LE < 0.2) INSIDE EDGE (VARMOS AND DGTG)) NOT INSIDE EDGE  MARKS
  ((LENGTH GATE_LE > 10) INSIDE EDGE (VARMOS AND DGTG)) NOT INSIDE EDGE  MARKS
}


VAR_3_G {
@ Channel width of varactor MOS	≥ 0.4um
  (LENGTH (GATE_WE INSIDE EDGE VARMOS) < 0.4) NOT INSIDE EDGE  MARKS
}

VAR_4_G {
@ Space between (poly or POLY_DMY) and neighboring GATE for core device in VARMOS	≥	0.12	um
 ( EXT GT_all (GATE_CORE AND VARMOS) < 0.12 ABUT < 90 SINGULAR REGION MEASURE ALL) NOT  MARKS
}

VAR_7_G {
@ Space between VARMOS and GATE ≥ 0.16um.
 ( EXT VARMOS GATE < 0.16 ABUT < 90 SINGULAR REGION) NOT  MARKS
}

VAR_8_G {
@ VARMOS enclosure AA ≥ 0.16um.
  (ENC AA VARMOS < 0.16 ABUT < 90 SINGULAR REGION) NOT  MARKS
}

VAR_9_G {
@ SN fully enclosure (GATE AND VARMOS) AND NW) along the channel length direction ≥ 0.32um
  X = (GATE AND VARMOS) AND NW
  (ENC (GATE_WE TOUCH EDGE X) SN < 0.32 ABUT < 90 REGION) NOT  MARKS
  (X CUT SN) NOT  MARKS
}

VAR_10_G {
@ SN fully enclosure (GATE AND VARMOS) AND NW) along the channel width direction	≥	0.13	um
  X = (GATE AND VARMOS) AND NW
  Y = GATE_LE TOUCH EDGE X
  (ENC Y SN < 0.13 ABUT < 90 REGION) NOT  MARKS
  (X CUT SN) NOT  MARKS
}

VAR_11_G {
@ SP fully enclosure (GATE AND VARMOS) NOT NW) along the channel length direction ≥ 0.32um
  X = (GATE AND VARMOS) NOT NW
 ( ENC (GATE_WE TOUCH EDGE X) SP < 0.32 ABUT < 90 REGION) NOT  MARKS
 ( X CUT SP) NOT  MARKS
}

VAR_12_G {
@ SP fully enclosure (GATE AND VARMOS) NOT NW) along the channel width direction	≥	0.13	um
  X = (GATE AND VARMOS) NOT NW
  Y = GATE_LE TOUCH EDGE X
  (ENC Y SP < 0.13 ABUT < 90 REGION) NOT  MARKS
  (X CUT SP) NOT  MARKS
}

VARAA = AA NOT OUTSIDE VARMOS
VARGTall = GT_all INTERACT VARMOS

VAR_14_G {
@ AA extension outside of (poly or POLY_DMY) for VARMOS core device	≥	0.095	um
  X = VARAA INTERACT GATE_CORE
  (ENC GT_all X < 0.095 ABUT < 90 SINGULAR REGION) NOT  MARKS
}

VAR_16_G {
@ SN extension outside of VARMOS. Extension = 0um is allowed.	≥	0.16	um
  (ENC VARMOS SN < 0.16 ABUT > 0 < 90  SINGULAR REGION) NOT  MARKS
}

VAR_17_G {
@ SP extension outside of VARMOS. Extension = 0um is allowed.	≥	0.16	um
 ( ENC VARMOS SP < 0.16 ABUT > 0 < 90  SINGULAR REGION) NOT  MARKS
}

VAR_18_G {
@ VARMOS marking layer must be drawn to fully cover the varactor devices.
@ Definition of varactor devices: GATE NOT OUTSIDE VARMOS.
  ((GATE NOT OUTSIDE VARMOS) CUT VARMOS) NOT  MARKS
}

VAR_19_G {
@ It’s not allowed VARMOS overlap LVT_N,LVT_P, PSUB, SAB.
  (AND VARMOS (OR LVT_N LVT_P PSUB SAB)) NOT  MARKS
}

VAR_20_G {
@ It’s not allowed SP overlap (GATE AND NW) AND VARMOS).
  (AND SP ((GATE AND NW) AND VARMOS)) NOT  MARKS
}

VAR_21_G {
@ It’s not allowed SN overlap (GATE NOT NW) AND VARMOS).
 ( AND SN ((GATE NOT NW) AND VARMOS)) NOT  MARKS
}
}




#//========================================================
#//  BIPOLA layout guidelines
#//========================================================

GROUP GBJT BJT_?

SETLAYER PTAP_BJT = PTAP AND BIPOLA
SETLAYER NTAP_BJT = NTAP AND BIPOLA

SETLAYER EMITTER_AA_PNP = (PACT INSIDE BIPOLA) INSIDE ((HOLES NTAP_BJT ) INSIDE (HOLES PTAP_BJT))
SETLAYER EMITTER_AA_NPN = (NACT INSIDE BIPOLA) INSIDE ((HOLES PTAP_BJT) INSIDE (HOLES NTAP_BJT))
SETLAYER EMITTER_AA = OR EMITTER_AA_PNP EMITTER_AA_NPN

SETLAYER COLLECTOR_AA_PNP = PTAP_BJT TOUCH ((HOLES PTAP_BJT) ENCLOSE EMITTER_AA_PNP)
SETLAYER COLLECTOR_AA_NPN = NTAP_BJT TOUCH ((HOLES NTAP_BJT) ENCLOSE EMITTER_AA_NPN)
SETLAYER COLLECTOR_AA = OR COLLECTOR_AA_PNP COLLECTOR_AA_NPN

RULECHECK BJT_1_G {
@ SAB enclosure Emitter AA	≥	0.3	um
OUTLAYER (ENC EMITTER_AA SAB < 0.3 ABUT < 90 SINGULAR REGION) NOT  MARKS
}

RULECHECK BJT_2_G {
@ BIPOLA enclosure of Collector AA	≥	1	um
OUTLAYER (ENC COLLECTOR_AA BIPOLA < 1 ABUT < 90 SINGULAR REGION) NOT  MARKS
}

RULECHECK BJT_3_G {
@ BIPOLA overlap of PSUB, poly, LVT_N,LVT_P, VARMOS, and INST is prohibited.
OUTLAYER (BIPOLA AND PSUB) NOT  MARKS
OUTLAYER (BIPOLA AND GT) NOT  MARKS
OUTLAYER (BIPOLA AND LVT_N) NOT  MARKS
OUTLAYER (BIPOLA AND LVT_P) NOT  MARKS
OUTLAYER (BIPOLA AND VARMOS) NOT  MARKS
OUTLAYER (BIPOLA AND INST) NOT  MARKS
}
		


#//===================================================
#//  Inductor design rules
#//===================================================

GROUP GIND IND_?


RULECHECK IND_1_G {
@ M1, M1DUM, and M1DOP width in INDMY.	≥	0.28
@ IND31_G It allows 0.01um checking tolerance in INDMY region for rule IND.1-26.
OUTLAYER ((INT (M1 NOT OUTSIDE INDMY) < 0.27 ABUT < 90 SINGULAR REGION) AND INDMY) NOT MARKS            
OUTLAYER ((INT (M1DUM NOT OUTSIDE INDMY) < 0.27 ABUT < 90 SINGULAR REGION) AND INDMY) NOT MARKS
OUTLAYER ((INT (M1DOP NOT OUTSIDE INDMY) < 0.27 ABUT < 90 SINGULAR REGION) AND INDMY) NOT MARKS
}

for { set j 2 } { $j <= $M1_and_1XMn_metal_counts } { incr j } {
RULECHECK IND_2_M${j}_G {
@ 1xMn 1xMnDUM, and 1xMnDOP width in INDMY	≥	0.28
@ IND31_G It allows 0.01um checking tolerance in INDMY region for rule IND.1-26.
OUTLAYER ((INT (M$j NOT OUTSIDE INDMY) < 0.27 ABUT < 90 SINGULAR REGION) AND INDMY) NOT MARKS            
OUTLAYER ((INT (M${j}DUM NOT OUTSIDE INDMY) < 0.27 ABUT < 90 SINGULAR REGION ) AND INDMY) NOT MARKS
OUTLAYER ((INT (M${j}DOP NOT OUTSIDE INDMY) < 0.27 ABUT < 90 SINGULAR REGION ) AND INDMY) NOT MARKS
}
}

for { set j 1 } { $j <= 2 } { incr j } {
RULECHECK IND_3_B${j}_G {
@ 2xMn 1xMnDUM, and 2xMnDOP width in INDMY	≥	0.8
@ IND31_G It allows 0.01um checking tolerance in INDMY region for rule IND.1-26.
OUTLAYER ((INT (B${j}i NOT OUTSIDE INDMY) < 0.79 ABUT < 90 SINGULAR REGION) AND INDMY) NOT MARKS
OUTLAYER ((INT (B${j}DUM NOT OUTSIDE INDMY) < 0.79 ABUT < 90 SINGULAR REGION) AND INDMY) NOT MARKS
OUTLAYER ((INT (B${j}DOP NOT OUTSIDE INDMY) < 0.79 ABUT < 90 SINGULAR REGION) AND INDMY) NOT MARKS
}
}

foreach metal $top_metal_list_with_name_mapping_TMn  {
RULECHECK IND_4_5_6_${metal}_G {
@ 8xTMn and 8xTMnDUM width in INDMY	≥	0.75 ≤	30
@ 10xTMn and 10xTMnDUM width in INDMY	≥	0.75 ≤	30
@ MTT2 and MTT2DM width in INDMY	≥	2 ≤	30
@ IND31_G It allows 0.01um checking tolerance in INDMY region for rule IND.1-26.
OUTLAYER  ((WITH WIDTH (${metal}_all NOT OUTSIDE INDMY)  > 30.01 ) AND INDMY) NOT MARKS
OUTLAYER  ((WITH WIDTH (${metal}_all NOT OUTSIDE INDMY)  < 0.74 ) AND INDMY) NOT MARKS
if { $MTT2_top_metal_counts != 0 } {
OUTLAYER  ((WITH WIDTH (${metal}_all NOT OUTSIDE INDMY)  < 1.99 ) AND INDMY) NOT MARKS
}
}
}

RULECHECK IND_7_G {
@ INDMY width or length	≤	580　
@ IND31_G It allows 0.01um checking tolerance in INDMY region for rule IND.1-26.
OUTLAYER (INDMY ENCLOSE RECTANGLE 580.011  0.001) NOT MARKS      
}

RULECHECK IND_8_G {
@ M1, M1DUM, and M1DOP space in INDMY	≥	0.28　
@ IND31_G It allows 0.01um checking tolerance in INDMY region for rule IND.1-26.
SETLAYER  M1_IN = M1 NOT OUTSIDE INDMY 
SETLAYER  M1DUM_IN = M1DUM NOT OUTSIDE INDMY
SETLAYER  M1DOP_IN = M1DOP NOT OUTSIDE INDMY  
OUTLAYER  ((EXT M1_IN < 0.27 ABUT < 90 SINGULAR REGION) AND INDMY) NOT MARKS
OUTLAYER  ((EXT M1DUM_IN < 0.27 ABUT < 90 SINGULAR REGION) AND INDMY) NOT MARKS
OUTLAYER  ((EXT M1DOP_IN < 0.27 ABUT < 90 SINGULAR REGION) AND INDMY) NOT MARKS
OUTLAYER  ((EXT M1_IN M1DUM_IN < 0.27 ABUT < 90 SINGULAR REGION) AND INDMY) NOT MARKS        
OUTLAYER  ((EXT M1_IN M1DOP_IN < 0.27 ABUT < 90 SINGULAR REGION)  AND INDMY) NOT MARKS
OUTLAYER  ((EXT M1DOP_IN M1DUM_IN < 0.27 ABUT < 90 SINGULAR REGION)  AND INDMY) NOT MARKS
}

for { set j 2 } { $j <= $M1_and_1XMn_metal_counts } { incr j } {
RULECHECK IND_9_M${j}_G {
@ 1xMn, 1xMnDUM, and 1xMnDOP space in INDMY	≥	0.28
@ IND31_G It allows 0.01um checking tolerance in INDMY region for rule IND.1-26.
SETLAYER  M${j}_IN = M$j  NOT OUTSIDE INDMY
SETLAYER  M${j}DUM_IN = M${j}DUM NOT OUTSIDE INDMY
SETLAYER  M${j}DOP_IN = M${j}DOP NOT OUTSIDE INDMY  
OUTLAYER  ((EXT M${j}_IN < 0.27 ABUT < 90 SINGULAR REGION) AND INDMY) NOT MARKS
OUTLAYER  ((EXT M${j}DUM_IN < 0.27 ABUT < 90 SINGULAR REGION) AND INDMY) NOT MARKS
OUTLAYER  ((EXT M${j}DOP_IN < 0.27 ABUT < 90 SINGULAR REGION)  AND INDMY) NOT MARKS
OUTLAYER  ((EXT M${j}_IN M${j}DUM_IN < 0.27 ABUT < 90 SINGULAR REGION) AND INDMY) NOT MARKS        
OUTLAYER  ((EXT M${j}_IN M${j}DOP_IN < 0.27 ABUT < 90 SINGULAR REGION)  AND INDMY) NOT MARKS
OUTLAYER  ((EXT M${j}DOP_IN M${j}DUM_IN < 0.27 ABUT < 90 SINGULAR REGION)  AND INDMY) NOT MARKS
}
}


for { set j 1 } { $j <= 2 } { incr j } {
RULECHECK IND_10_B${j}_G {
@ 2xMn, 2xMnDUM, and 2xMnDOP space in INDMY 	≥	0.4
@ IND31_G It allows 0.01um checking tolerance in INDMY region for rule IND.1-26.
SETLAYER B${j}i_IN = B${j}i  NOT OUTSIDE INDMY
SETLAYER B${j}DUM_IN = B${j}DUM NOT OUTSIDE INDMY
SETLAYER B${j}DOP_IN = B${j}DOP NOT OUTSIDE INDMY 
OUTLAYER  ((EXT B${j}i_IN < 0.39 ABUT < 90 SINGULAR REGION) AND INDMY) NOT MARKS
OUTLAYER  ((EXT B${j}DUM_IN < 0.39 ABUT < 90 SINGULAR REGION) AND INDMY) NOT MARKS
OUTLAYER  ((EXT B${j}DOP_IN < 0.39 ABUT < 90 SINGULAR REGION)  AND INDMY) NOT MARKS
OUTLAYER  ((EXT B${j}i_IN B${j}DUM_IN < 0.39 ABUT < 90 SINGULAR REGION) AND INDMY) NOT MARKS        
OUTLAYER  ((EXT B${j}i_IN B${j}DOP_IN < 0.39 ABUT < 90 SINGULAR REGION)  AND INDMY) NOT MARKS
OUTLAYER  ((EXT B${j}DOP_IN B${j}DUM_IN < 0.39 ABUT < 90 SINGULAR REGION)  AND INDMY) NOT MARKS
}
}


foreach metal $top_metal_list_with_name_mapping_TMn  {
RULECHECK IND_11_12_13_${metal}_G {
@ 8xTMn, 8xTMnDUM space in INDMY	≥	0.75
@ 10xTMn and 10xTMnDUM space in INDMY 	≥	0.75
@ MTT2 and MTT2DM space in INDMY	≥	1
SETLAYER  ${metal}_all_IN = ${metal}_all NOT OUTSIDE INDMY
OUTLAYER  ((EXT ${metal}_all_IN < 0.74 ABUT < 90 SINGULAR REGION) AND INDMY) NOT MARKS
if { $MTT2_top_metal_counts != 0 } {
SETLAYER  ${metal}_all_INX = ${metal}_all NOT OUTSIDE INDMY
OUTLAYER  ((EXT ${metal}_all_INX < 0.99 ABUT < 90 SINGULAR REGION) AND INDMY) NOT MARKS
}
}
}

foreach metal $top_metal_list_with_name_mapping_TMn {
RULECHECK IND_14_${metal}_G {
@  8xTMn and 8xTMnDUM /10xTMn and 10xTMnDUM /MTT2 and MTT2DM space in INDMY when at least one metal line width > 12um and the parallel run length > 1@ 2um	≥	2
@ IND31_G It allows 0.01um checking tolerance in INDMY region for rule IND.1-26.
SETLAYER ${metal}_all_IN = ${metal}_all NOT OUTSIDE INDMY
Mn_one_width_PART ${metal}_all 12.001 12 1.99
OUTLAYER (OUT3 AND INDMY) NOT MARKS
}
}

foreach metal [ concat $top_metal_list_with_name_mapping_TMn { ALPA } ] {
RULECHECK IND_15_${metal}_G {
@ Space between MTT2/8xTMn /10xTMn / ALPA (as Inductor) and other MTT2/8xTMn /10xTMn/ALPA outside of INDMY.	≥	30
@ IND31_G It allows 0.01um checking tolerance in INDMY region for rule IND.1-26.
SETLAYER INDMY_SIZE = (SIZE INDMY BY 29.99) NOT INDMY
SETLAYER X = (($metal INTERACT INDMY_SIZE) NOT INDMY) COIN EDGE $metal
SETLAYER Y = ($metal AND INDMY) COIN EDGE $metal
OUTLAYER (EXT X Y < 29.99 ABUT < 90 REGION) NOT MARKS
}
}

foreach metal [ concat $total_metal_list_with_name_mapping {  ALPA } ] {
RULECHECK IND_16_${metal}_G {
@ INDMY extension outside of M1/1xMn/2xMn/MTT2/8xTMn/10xTMn/ALPA metal designs.	≥	15
@ IND31_G It allows 0.01um checking tolerance in INDMY region for rule IND.1-26.
OUTLAYER (ENC ($metal INTERACT INDMY) INDMY  < 14.99 ABUT < 90 SINGULAR REGION) NOT MARKS
}
}

RULECHECK IND_17_G {
@ Space between active device and INDMY.Active device is all devices in device truth table.	≥	10
@ IND31_G It allows 0.01um checking tolerance in INDMY region for rule IND.1-26.
SETLAYER GATE0 = GT AND AA
SETLAYER AA1 = (AA INTERACT GATE0) NOT GATE0
SETLAYER MOS = GATE0 TOUCH AA1 == 2

  foreach device { MOS INST RESP1 RESAA RESNW BIPOLA DSTR VARMOS LDBK MOMDMY EFUSE } {
OUTLAYER  (EXT $device INDMY < 9.99 ABUT < 90 SINGULAR REGION) NOT MARKS
  }
}

RULECHECK IND_18_G {
@ INDMY density in full chip	≤	4%
@ IND31_G It allows 0.01um checking tolerance in INDMY region for rule IND.1-26.
 SETLAYER X = INDMY NOT MARKS 
 SETLAYER Y = DRC:1 NOT MARKS 
 SETLAYER Z = COPY Y 
 OUTLAYER DENSITY X Y \[area(X) / area(Y)\] > 0.05 PRINT density_report_IND_18_G.log RDB density_report_IND_18_G.rdb 
}
for { set j 1 } { $j <= $M1_and_1XMn_metal_counts } { incr j } {

RULECHECK IND_19_M${j}_G {
@ M1/1xMx/2xMn/8xTMn/10xTMn metal density(include dummy pattern) in full chip 	≥	20%
@ IND31_G It allows 0.01um checking tolerance in INDMY region for rule IND.1-26.
SETLAYER X = M${j}_all NOT MARKS 
SETLAYER Y = DRC:1 NOT MARKS 
SETLAYER Z = COPY Y 
OUTLAYER DENSITY X Y \[area(X) / area(Y)\] < 0.19  PRINT density_report_IND_19_G.log RDB density_report_IND_19_G.rdb 
}
}

if { $2X_metal_counts > 0 } {

  foreach j $2X_metal_with_name_mapping_Mn_j {
RULECHECK IND_19_M${j}_G {
@ M1/1xMx/2xMn/8xTMn/10xTMn metal density(include dummy pattern) in full chip 	≥	20%
@ IND31_G It allows 0.01um checking tolerance in INDMY region for rule IND.1-26.
SETLAYER X = M${j}_all NOT MARKS 
SETLAYER Y = DRC:1 NOT MARKS 
SETLAYER Z = COPY Y 
OUTLAYER DENSITY X Y \[area(X) / area(Y)\] < 0.19  PRINT density_report_IND_19_G.log RDB density_report_IND_19_G.rdb 
}
}
}
if { $MTT2_top_metal_counts == 0 } {
   foreach metal $top_metal_list_with_name_mapping_TMn {
RULECHECK IND_19_${metal}_G {
@ M1/1xMx/2xMn/8xTMn/10xTMn metal density in full chip (include dummy pattern)in full chip≥	20%
@ IND31_G It allows 0.01um checking tolerance in INDMY region for rule IND.1-26.
SETLAYER X = ${metal}_all NOT MARKS 
SETLAYER Y = DRC:1 NOT MARKS 
SETLAYER Z = COPY Y
OUTLAYER DENSITY X Y \[area(X) / area(Y)\] < 0.19 PRINT density_report_IND_19_G.log RDB density_report_IND_19_G.rdb 
}
}
}

RULECHECK IND_20_G {
@ INDMY density. DRc check window size 1600*1600um, step size: 800um	≤	10%　
SETLAYER X = INDMY NOT MARKS 
SETLAYER Y = DRC:1 NOT MARKS 
SETLAYER Z = COPY Y 
OUTLAYER DENSITY X Y \[area(X) / area(Y)\] > 0.11 WINDOW 1600  STEP 800  PRINT density_report_IND_20_G.log RDB density_report_IND_20_G.rdb
}


  if { $top_metal_counts == 2 } {
    set nxmetal_j { 1 2 } 
  } elseif { $top_metal_counts == 1} {
    set nxmetal_j { 2 }
  }

foreach j $nxmetal_j {
RULECHECK IND_21_22_23_TV${j}_G {
@ There should be at least four 8xTVn with space ≤ 1.7um to connect (two 8xTMn layers) or (8xTMn to 1xMn) or (8xTMn to 2xMn) in INDMY	
@ There should be at least four 10xTVn with space ≤ 1.7um to connect (two 10xTMn layers) or (10xTMn to 1xMn) or (10xTMn to 1xMn) in INDMY
@ There should be at least four UTV(LT) with space ≤ 1.7um to connect (MTT2 to 8xTMn) or (MTT2 to 2xMn) or (MTT2 to 1xMn) in INDMY
@ IND31_G It allows 0.01um checking tolerance in INDMY region for rule IND.1-26.
SETLAYER TV${j}_underneath_metal_IN = TV${j}_underneath_metal NOT OUTSIDE INDMY 
SETLAYER X = (TV${j}_underneath_metal_IN AND TM$j) INTERACT TV${j} 
SETLAYER Y = SIZE TV${j} BY 0.85 INSIDE OF X STEP 0.005    
SETLAYER Z = Y INTERACT TV${j} >= 4
OUTLAYER ((X NOT INTERACT Z) AND INDMY) NOT MARKS    
}
}

#for { set j 2 } { $j < $M1_and_1XMn_metal_counts } { incr j } {    
#SETLAYER Y${j} = M$j AND ((LDNMK1 NOT (SIZE LDNMK1 BY -5)) INTERACT 1XV${j}_BAR)
#    lappend Mn_list Y${j}
#  }
#set inter_metal_list_1 [lrange $inter_metal_list  1 [expr $inter_metal_counts -2]]
#foreach Mn-1 $inter_metal_list_1 {
#foreach TOPMETAL $top_metal_list_with_name_mapping_TMn {
#RULECHECK IND_24_${Mn-1}_${TOPMETAL}_G {
#@ In the (INDMY AND DUMBM) region, except the 1xMn or 2xMn layer (one layer only) directly below (8xMn or 10xMn or MTT2), 
#@ any other inter-metal layer (1xMn/2xMn) is prohibited. 
#@ This rule doesn't check 1xMn  in ((LDNMK1 NOT (LDNMK1 sizing down 5um) INTERACT 1xVn bar)
#SETLAYER X = ${Mn-1}i AND $TOPMETAL  

#SETLAYER Y = OR $Mn_list
#OUTLAYER ((X NOT Y ) AND (INDMY AND DUMBM)) NOT MARKS 
#}
#}	
#}

RULECHECK IND_25_G {
@ All devices listed in device table inside INDMY region are prohibited.
@ IND31_G It allows 0.01um checking tolerance in INDMY region for rule IND.1-26.
SETLAYER GATE0 = GT AND AA
SETLAYER AA1 = (AA INTERACT GATE0) NOT GATE0
SETLAYER MOS = GATE0 TOUCH AA1 == 2

  foreach device { MOS INST RESP1 RESAA RESNW BIPOLA DSTR VARMOS LDBK MOMDMY EFUSE } {
OUTLAYER  (AND $device INDMY) NOT MARKS
  }
}	
	
RULECHECK IND_26_G_R_DFM3 {
@ It is recommended PSUB fully covers the inductor coil and guardring to achieve the high quality.
@ DRC check method:
@ PSUB fully cover ((AA INTERACT INDMY) INTERACT SP)).
@ IND31_G It allows 0.01um checking tolerance in INDMY region for rule IND.1-26.
OUTLAYER (((AA INTERACT INDMY) INTERACT SP) NOT PSUB ) NOT MARKS 
}


VERBATIM {
//===============================================================
// LDMOS design Guideline for IO 1.8V gate OX device
//===============================================================

GROUP GLD LD_?

LDMOS = LDBK AND DG
GATE_LD = GATE AND LDMOS
PGATE_LD = PGATE AND LDMOS
NGATE_LD = NGATE AND LDMOS

PGATE_LDE = PGATE_LD AND NW
NGATE_LDE = NGATE_LD NOT NW

STI_1 = (GATE_LD INSIDE EDGE AA) COIN EDGE GT
STI_2 = INT STI_1 GATE_LD < 0.005 ABUT INTERSECTING ONLY REGION
STI_3 = GATE_LD NOT TOUCH EDGE STI_2
STI = EXPAND EDGE STI_3 OUTSIDE BY 0.15  //refer to rule LD.3

LD_1a_G {
@ Min Effective Channel length for NLDMOS transistors is 0.22
X = INT NGATE_LDE < 0.22 ABUT < 90 SINGULAR REGION
X NOT MARKS
}

LD_1b_G {
@ Min Effective Channel length for PLDMOS transistors is 0.2
X = INT PGATE_LDE < 0.2 ABUT < 90 SINGULAR REGION
X NOT MARKS
}

LD_2_G {
@ Min Drain AA width along source/drain direction for LDMOS transistors is 0.2
X = (AA NOT GATE_LD) COIN EDGE STI
Y = INT X < 0.2 OPPOSITE REGION
Y NOT MARKS 
}

LD_3_G {
@ Fixed STI width along source/drain direction is 0.15
X = STI NOT TOUCH (AA NOT GATE_LD) == 1
X NOT MARKS 
}

LD_4_G {
@ Min Overlap of GT and STI along source/drain direction is 0.05
X = ENC STI_3 GT < 0.05 ABUT < 90 REGION OPPOSITE
X NOT MARKS 
}

LD_5_G {
@ Fixed N LDMOS gate overlaps with NW in source/drain direction length is 0.2.
@ Fixed P LDMOS gate not in NW in source/drain direction length is 0.2
X = NGATE_LD AND NW
(SIZE X BY 0.1 UNDEROVER) NOT MARKS
(INT X < 0.2 SINGULAR REGION) NOT MARKS

Y = PGATE_LD NOT NW
(SIZE Y BY 0.1 UNDEROVER) NOT MARKS
(INT Y < 0.2 SINGULAR REGION) NOT MARKS
}

LD_6_G {
@ Min LDMOS channel width is 2
X = GATE_LD COIN EDGE GT
(LENGTH X < 2) NOT INSIDE EDGE MARKS
}

LD_7a_G {
@ Min Space between LDMOS source side AA and pickup AA along source/drain direction is 0.6
X = AA ENCLOSE GATE_LD
Y = X INSIDE EDGE GT
Z = X NOT TOUCH EDGE Y
(EXT Z TAP < 0.6 ABUT < 90 REGION) NOT MARKS
}

LD_7b_G {
@ Space between LDMOS source/drain side AA and pickup AA along GATE poly direction	≥	0.8
X = GATE_LD COIN EDGE GT
Y = INT X GATE_LD < 0.005 ABUT INTERSECTING ONLY REGION
Z = ((AA ENCLOSE GATE_LD) TOUCH EDGE Y) NOT TOUCH EDGE GT
(EXT Z (TAP NOT COIN EDGE GATE) < 0.8 ABUT < 90 REGION) NOT MARKS
M = ((AA NOT INTERACT GATE_LD ) TOUCH STI) NOT TOUCH EDGE STI 
(EXT M (TAP NOT COIN EDGE GATE) < 0.8 ABUT < 90 REGION ) NOT MARKS 
}

LD_8_G {
@ Min NW extension outside of N LDMOS AA along gate poly direction is 0.25.
@ Min NW space to P LDMOS AA along gate poly direction is 0.25
  X = AA TOUCH EDGE STI
Y = INT X AA < 0.005 ABUT INTERSECTING ONLY REGION
Z = AA TOUCH EDGE Y
M = Z NOT TOUCH EDGE X

(ENC M NW < 0.25 ABUT < 90 REGION) NOT MARKS
(EXT M NW < 0.25 ABUT < 90 REGION) NOT MARKS
}

LD_9a_G {
@ Space between NW in LDBK region and P+ pickup AA.  	≥	0.065
X = EXT (NW AND LDBK) PTAP < 0.065 ABUT >0< 90 REGION SINGULAR
X NOT MARKS
}

LD_9b_G {
@ Space between ((NW hole INSIDE DNW) in LDBK region and  N+ pickup AA.  	≥	0.25
X = EXT (((HOLES NW) INSIDE DNW) AND LDBK) NTAP  < 0.25 ABUT< 90 REGION SINGULAR
X NOT MARKS 
}

LD_10_G { 
@ LDMOS block layer (LDBK) is used to identify LDMOS function area.
@ Min LDBK extension outside of (gate, source, drain)'s AA is 0.4
X = HOLES (NW INTERACT PGATE_LD)
Y = NW INTERACT NGATE_LD
Z = AA INTERACT (X OR Y)
(ENC Z LDBK < 0.4 ABUT < 90 REGION) NOT MARKS
}

LD_11_G {
@ Space between one LDMOS GATE poly to another LDMOS GATE poly on source side	≥	0.18
(EXT STI_1 < 0.18 REGION) NOT MARKS
}

LD_12_G {
@ "One LDMOS unit must has two polys and a common drain. 
@ Single poly structure is not allowed."
((AA NOT GATE_LD) TOUCH STI < 2 ) NOT MARKS
}

GT_EM8 = OR EMPTY8 GT_raw 
CT_EM8 = OR EMPTY8 CT
NGATE_EM8 = OR EMPTY8 NGATE_LD  
PGATE_EM8 = OR EMPTY8 PGATE_LD
NS_EM8 = OR EMPTY8 ((NACT NOT GATE_LD) TOUCH GATE_LD)
ND_EM8 = OR EMPTY8 ((NTAP NOT GATE_LD) TOUCH STI)
PS_EM8 = OR EMPTY8 ((PACT NOT GATE_LD) TOUCH GATE_LD)
PD_EM8 = OR EMPTY8 ((PTAP NOT GATE_LD) TOUCH STI)
NACT_EM8 = OR EMPTY8 (NSD NOT NS_EM8) 
NTAP_EM8 = OR EMPTY8 (NTAP NOT ND_EM8) 
PACT_EM8 = OR EMPTY8 (PSD NOT PS_EM8) 
PTAP_EM8 = OR EMPTY8 (PTAP NOT PD_EM8)
ALPA_EM8 = OR EMPTY8 ALPA
PA_EM8 = OR EMPTY8 PA
MD_EM8 = OR EMPTY8 MD
mark_e1 = OR EMPTY8 LDBK 
mark_e2 = OR LDBK mark_e1
mark_e3 = OR LDBK mark_e2

sconnect NS_EM8 mark_e1
sconnect ND_EM8 mark_e2
sconnect NGATE_EM8 mark_e3

sconnect PS_EM8 mark_e1
sconnect PD_EM8 mark_e2
sconnect PGATE_EM8 mark_e3
}

foreach metal_via $total_metal_via_list_with_name_mapping {
 SETLAYER ${metal_via}_EM8 = EMPTY8 OR ${metal_via} 
}
for { set i 0 } { $i < [expr [llength $total_metal_via_list_with_name_mapping] -2] } { incr i 2 } {
  CONNECT [lindex $total_metal_via_list_with_name_mapping $i]_EM8 [lindex $total_metal_via_list_with_name_mapping [expr $i +2]]_EM8 BY \
          [lindex $total_metal_via_list_with_name_mapping [expr $i +1]]_EM8
}

VERBATIM {
CONNECT M1_EM8 NS_EM8 ND_EM8 PS_EM8 PD_EM8 GT_EM8 BY CT_EM8  
CONNECT M1_EM8 NACT_EM8 NTAP_EM8 PACT_EM8 PTAP_EM8 BY CT_EM8 
CONNECT GT_EM8 NGATE_EM8 
CONNECT GT_EM8 PGATE_EM8
CONNECT ALPA_EM8 TM2_EM8 BY PA_EM8
CONNECT ALPA_EM8 MD_EM8 

LD_13_G_R_DFM2 {
@ Common source is allowed only for multi-finger LDMOS structure in LDBK region.(Drain/Source/GATE is connected together respectively.)
Ns_error = net area ratio NS_EM8 mark_e1 == 0 
Nd_error = net area ratio ND_EM8 mark_e2 == 0 
Ng_error = net area ratio NGATE_EM8 mark_e3 == 0 
Ps_error = net area ratio PS_EM8 mark_e1 == 0 
Pd_error = net area ratio PD_EM8 mark_e2 == 0 
Pg_error = net area ratio PGATE_EM8 mark_e3 == 0
X = ((AA TOUCH STI) OR STI) ENCLOSE ((AA NOT GATE_LD) TOUCH GATE_LD ==2  )
(((X INTERACT Ns_error) OR (X INTERACT Nd_error)) OR (X INTERACT Ng_error)) NOT MARKS
(((X INTERACT Ps_error) OR (X INTERACT Pd_error)) OR (X INTERACT Pg_error)) NOT MARKS
}
}

#//========================================================
#//  Seal Rring Design Guideline
#//========================================================

GROUP seal_ring SR_?

SETLAYER CTS = CT AND MARKS
SETLAYER CTS_SL = CTS NOT CTS_SQ 
SETLAYER CTS_SQ = RECTANGLE CTS

foreach slot $total_via_list_with_name_mapping {
SETLAYER ${slot}S = ${slot} AND MARKS
SETLAYER ${slot}S_SL = ${slot}S NOT ${slot}S_SQ
SETLAYER ${slot}S_SQ = RECTANGLE ${slot}S
}

#parameter "layer" must be slot
proc slot_width_one_value { layer value } {
  SETLAYER ${layer}_V_edge = ANGLE $layer >= 89 <= 90
  SETLAYER ${layer}_H_edge = ANGLE $layer >= 0 <= 1
  SETLAYER ${layer}_D_edge = ANGLE $layer >= 44.9 <= 45.1

  SETLAYER X_V = INT ${layer}_V_edge <= 10 ABUT < 90 OPPOSITE REGION EXCLUDE SHIELDED
  SETLAYER X_H = INT ${layer}_H_edge <= 10 ABUT < 90 OPPOSITE REGION EXCLUDE SHIELDED
  SETLAYER X_D = INT ${layer}_D_edge <= 10 ABUT < 90 OPPOSITE REGION EXCLUDE SHIELDED

  OUTLAYER INT $layer < $value -0.001 ABUT < 90 SINGULAR REGION
  OUTLAYER X_V WITH WIDTH > $value
  OUTLAYER X_H WITH WIDTH > $value
  OUTLAYER X_D WITH WIDTH > $value *1.414
}

#parameter "layer" must be slot, value1 < value2
proc slot_width_two_value { layer value1 value2 } {
  if { $value1 < $value2 } { set value $value1 } else { set value $value2 }
  SETLAYER ${layer}_V_edge = ANGLE $layer >= 89 <= 90
  SETLAYER ${layer}_H_edge = ANGLE $layer >= 0 <= 1
  SETLAYER ${layer}_D_edge = ANGLE $layer >= 44.9 <= 45.1

  SETLAYER X_V = INT ${layer}_V_edge <= 10 ABUT < 90 OPPOSITE REGION
  SETLAYER X_H = INT ${layer}_H_edge <= 10 ABUT < 90 OPPOSITE REGION
  SETLAYER X_D = INT ${layer}_D_edge <= 10 ABUT < 90 OPPOSITE REGION EXCLUDE SHIELDED

  OUTLAYER INT $layer < $value -0.001 ABUT < 90 SINGULAR REGION
  OUTLAYER (X_V WITH WIDTH != $value1) WITH WIDTH != $value2
  OUTLAYER (X_H WITH WIDTH != $value1) WITH WIDTH != $value2
  OUTLAYER (X_D NOT WITH WIDTH >= $value1-0.001 <= $value1*1.414) NOT WITH WIDTH >= $value2-0.001 <= $value2*1.414  
}


proc square_width { layer value } {
  OUTLAYER NOT RECTANGLE $layer == $value by == $value
}

RULECHECK SR_1_G {
@ Fixed width of contact slot, it is allowed  variation at 45 degree angle area. 	=	0.06um
slot_width_one_value CTS_SL 0.06
}
 
foreach via $1XVn_list {
RULECHECK SR_2a_2b_${via}_G {
@ Fixed width of 1x Vn slot, it is allowed  variation at 45 degree angle area.  	=	0.56 or 0.1	um
slot_width_two_value ${via}S_SL 0.56 0.1
}
}

foreach via $2X_via_with_name_mapping_Vn {
RULECHECK SR_3a_3b_${via}_G {
@ Fixed width of 2x Vn slot, it is allowed  variation at 45 degree angle area.  	=	0.56 or 0.1	um
slot_width_two_value ${via}S_SL 0.56 0.1
}
}


set top_via_list_with_name_mapping_TVtmp [lrange $top_via_list_with_name_mapping_TVn 0 end-1]

if { $MTT2_top_metal_counts == 0} {
foreach via $top_via_list_with_name_mapping_TVn {
RULECHECK SR_4a_4b_5a_5b_${via}_G {
@ Fixed width of 8x TVn slot at straight direction	=	0.56 	um
@ Fixed width of 8x TVn slot at 45 degree angle area	=	0.56~0.56* 2 um
@ Fixed width of 10x TVn slot at straight direction	=	0.56 	um
@ Fixed width of 10x TVn slot at 45 degree angle area	=	0.56~0.56* 2um
slot_width_one_value ${via}S_SL 0.56
}
}
}

if { $MTT2_top_metal_counts != 0} {
foreach via $top_via_list_with_name_mapping_TVtmp {
RULECHECK SR_4a_4b_5a_5b_${via}_G {
@ Fixed width of 8x TVn slot at straight direction	=	0.56 	um
@ Fixed width of 8x TVn slot at 45 degree angle area	=	0.56~0.56* 2 um
@ Fixed width of 10x TVn slot at straight direction	=	0.56 	um
@ Fixed width of 10x TVn slot at 45 degree angle area	=	0.56~0.56* 2um
slot_width_one_value ${via}S_SL 0.56
}
}
}


#foreach via $top_via_list_with_name_mapping_TVn {
#RULECHECK SR_4a_4b_5a_5b_${via}_G {
#@ Fixed width of 8x TV slot, it is allowed  variation at 45 degree angle area.	=	0.56 	um
#@ Fixed width of 10x TV slot, it is allowed  variation at 45 degree angle area.	=0.56	um
#slot_width_one_value ${via}S_SL 0.56
#}}


RULECHECK SR_6_G {
@ Fixed square CT size	=	0.04	um
square_width CTS_SQ 0.04
}

foreach via $1XVn_list {
RULECHECK SR_7_${via}_G {
@ Fixed width of square 1xVn size	=	0.05	um
square_width ${via}S_SQ 0.05
}
}

foreach via $2X_via_with_name_mapping_Vn {
RULECHECK SR_8_${via}_G {
@ Fixed width of square 2x Vn size	=	0.1	um
square_width ${via}S_SQ 0.1
}
}


#if { $10X_top_metal_counts > 0 && ($MTT2_top_metal_counts == 0)} {
#foreach via $top_via_list_with_name_mapping_TVn {
#RULECHECK SR_9_10_${via}_G {
#@ Fixed width of square 8x TV size	=	0.4	um
#@ Fixed width of square 10x TV size	=	0.51	um
#square_width ${via}S_SQ 0.51
#}
#}
#}
#if { $8X_top_metal_counts > 0 && ($MTT2_top_metal_counts == 0)} {
#foreach via $top_via_list_with_name_mapping_TVn {
#RULECHECK SR_9_10_${via}_G {
#@ Fixed width of square 8x TV size	=	0.4	um
#@ Fixed width of square 10x TV size	=	0.51	um
#square_width ${via}S_SQ 0.4
#}
#}
#}


if { $10X_top_metal_counts > 0 } {

foreach via $top_via_list_with_name_mapping_TVn {
RULECHECK SR_9_10_${via}_G {
@ Fixed width of square 8x TV size	=	0.4	um
@ Fixed width of square 10x TV size	=	0.51	um
square_width ${via}S_SQ 0.51
}
}
}
if { $8X_top_metal_counts > 0 && ($MTT2_top_metal_counts == 0)} {
foreach via $top_via_list_with_name_mapping_TVn {
RULECHECK SR_9_10_${via}_G {
@ Fixed width of square 8x TV size	=	0.4	um
@ Fixed width of square 10x TV size	=	0.51	um
square_width ${via}S_SQ 0.4
}
}
}

if { $8X_top_metal_counts > 0 && ($MTT2_top_metal_counts != 0)} {
foreach via $top_via_list_with_name_mapping_TVtmp {
RULECHECK SR_9_10_${via}_G {
@ Fixed width of square 8x TV size	=	0.4	um
@ Fixed width of square 10x TV size	=	0.51	um
square_width ${via}S_SQ 0.4
}
}
}


foreach via [ concat { CT } $total_via_list_with_name_mapping ] {
RULECHECK SR_11_${via} {
@ CT slot, 1xVn slot, 2xVn slot, 8xTVn, 10xTVn slot are be drawn in seal ring region (slot pattern is NOT square pattern).
OUTLAYER MARKS NOT ENCLOSE (NOT RECTANGLE $via ASPECT == 1 )
}
}
			
RULECHECK SR_12 {
@ CT slot enclosure by M1 ≥ 0.1um
OUTLAYER ENC CTS_SL M1  < 0.1 REGION ABUT < 90 SINGULAR
}

for { set j 0 } { $j < [llength $total_via_list_with_name_mapping] } { incr j } {
RULECHECK SR_13_[lindex $total_via_list_with_name_mapping $j] {
@ Via slot enclosure by metal	≥ 0.05um
OUTLAYER ENC [lindex $total_via_list_with_name_mapping $j]S_SL [lindex $total_metal_list_with_name_mapping $j] < 0.05  ABUT < 90 SINGULAR REGION
OUTLAYER ENC [lindex $total_via_list_with_name_mapping $j ]S_SL [lindex $total_metal_list_with_name_mapping [expr $j +1] ] < 0.05  ABUT < 90 SINGULAR REGION 
}

}
RULECHECK SR_14 {
@ Seal ring must be a close ring excluding RF device(RFDEV region)
OUTLAYER (MARKS NOT TOUCH (HOLES MARKS)) NOT RFDEV  
}





#//*******************************************************************************************************************************
#//          ESD Design Rules and Guideline
#//*******************************************************************************************************************************

SETLAYER ESD = ESD1 AND ESDIO2

SETLAYER ENACT = NAA AND ESDIO2
SETLAYER EPACT = PAA AND ESDIO2
SETLAYER ENTAP = ENACT AND NW
SETLAYER EPTAP = EPACT NOT NW

SETLAYER EGATE = GATE AND ESDIO2
SETLAYER ENGATE = EGATE AND ENACT
SETLAYER EPGATE = EGATE AND EPACT

SETLAYER EGATEHV = EGATE AND TG 
SETLAYER ENGATEHV = ENGATE AND TG
SETLAYER EPGATEHV = EPGATE AND TG
SETLAYER EGATEMV = EGATE AND DG                          //1.8V or 1.5V
SETLAYER EGATELV = EGATE NOT INSIDE (DG OR TG)                          //1.05V

SETLAYER EGATE_CASCODED = (EGATE AND ESDIO2) AND ESDHV   //Cascoded 1.8V/2.5V NMOS
SETLAYER ENGATE_CASCODED = (ENGATE AND ESDIO2) AND ESDHV
SETLAYER ENGATE_CASCODED_INSID = ENGATE_CASCODED INSIDE ESAB
SETLAYER ENGATE_CASCODED_OVLAP = ENGATE_CASCODED CUT ESAB

SETLAYER EGATE_CASCODED_OVLAP = EGATE_CASCODED CUT ESAB
SETLAYER EGATE_CASCODED_INSID = EGATE_CASCODED INSIDE ESAB

SETLAYER EGATE_W = EGATE COIN EDGE GATE_WE
SETLAYER EGATE_L = EGATE COIN EDGE GATE_LE

SETLAYER EGATE_POLY = GT ENCLOSE EGATE
SETLAYER ENGATE_POLY = GT ENCLOSE ENGATE
SETLAYER EPGATE_POLY = GT ENCLOSE EPGATE

SETLAYER ECT = CT AND ESDIO2
SETLAYER ESAB = SAB AND ESDIO2
SETLAYER ESAB_HO = HOLES ESAB INNER EMPTY
SETLAYER ECT_S = ECT OUTSIDE ESAB_HO
SETLAYER ECT_D = ECT INSIDE ESAB_HO

SETLAYER ENMOS = ENACT ENCLOSE EGATE
SETLAYER EPMOS = EPACT ENCLOSE EGATE
SETLAYER ENMOS_SD = ENMOS NOT EGATE
SETLAYER EPMOS_SD = EPMOS NOT EGATE

SETLAYER ENMOS_S = ENMOS_SD ENCLOSE ECT_S
SETLAYER ENMOS_D = ENMOS_SD ENCLOSE ECT_D
SETLAYER EPMOS_S = EPMOS_SD ENCLOSE ECT_S
SETLAYER EPMOS_D = EPMOS_SD ENCLOSE ECT_D
SETLAYER EMOS_D = ENMOS_D OR EPMOS_D
SETLAYER EMOS_S = ENMOS_S OR EPMOS_S

SETLAYER ENGUARDRING = HOLES ENTAP INNER
SETLAYER EPGUARDRING = HOLES EPTAP INNER
SETLAYER ENGUARDHOLE_2 = (HOLES ENTAP INNER) ENCLOSE EPGUARDRING
SETLAYER EPGUARDHOLE_2 = (HOLES EPTAP INNER) ENCLOSE ENGUARDRING

SETLAYER ESD3C_1 = EXPAND EDGE ((EGATE NOT EGATE_CASCODED) INSIDE EDGE AA) INSIDE BY 0.001
SETLAYER ESD3C_2 = EXPAND EDGE ((EGATE_CASCODED NOT INSIDE SAB) INSIDE EDGE AA) INSIDE BY 0.001
SETLAYER ESD3C = ESD3C_1 OR ESD3C_2


LAYER MAP 9998 DATATYPE 1234 5432
LAYER EMPTY1 5432
SETLAYER ENGATE_D_EMPTY = EMPTY1 OR (ESDIO2 AND ENMOS_D)
SETLAYER EPGATE_D_EMPTY = EMPTY1 OR (ESDIO2 AND EPMOS_D)
SETLAYER ESD3C_EMPTY = EMPTY1 OR ESD3C

#use the list "total_metal_via_list_with_name_mapping" for layer logic operation
foreach metal_via $total_metal_via_list_with_name_mapping {
  SETLAYER E${metal_via}_EMPTY = EMPTY1 OR (ESDIO2 AND $metal_via)
}

SETLAYER ECT_EMPTY = EMPTY1 OR (ESDIO2 AND ECT)
SETLAYER EALPA_EMPTY = EMPTY1 OR (ESDIO2 AND ALPA)
SETLAYER EPA_EMPTY = EMPTY1 OR (ESDIO2 AND PA)
SETLAYER EMD_EMPTY = EMPTY1 OR (ESDIO2 AND MD)


#use the list "total_metal_via_list_with_name_mapping" to establish the special conncection for ESD parts
for { set i 0 } { $i < [expr [llength $total_metal_via_list_with_name_mapping] -2] } { incr i 2 } {
  CONNECT E[lindex $total_metal_via_list_with_name_mapping $i]_EMPTY E[lindex $total_metal_via_list_with_name_mapping [expr $i +2]]_EMPTY BY \
          E[lindex $total_metal_via_list_with_name_mapping [expr $i +1]]_EMPTY
}

CONNECT ENGATE_D_EMPTY ESD3C_EMPTY
CONNECT EPGATE_D_EMPTY ESD3C_EMPTY
CONNECT ENGATE_D_EMPTY EM1_EMPTY BY ECT_EMPTY
CONNECT EPGATE_D_EMPTY EM1_EMPTY BY ECT_EMPTY 

CONNECT ETM2_EMPTY EALPA_EMPTY BY EPA_EMPTY
CONNECT EALPA_EMPTY EMD_EMPTY




#//==============================================
#//  ESD design and layout guideline
#//==============================================

GROUP GESD ESD_?

RULECHECK ESD_2_G {
@ Unit finger width (F) of NMOS and PMOS for ESD protection device (Fig.2). >= 5um and <= 30um
 OUTLAYER ((LENGTH EGATE_W < 5) NOT COIN EDGE EGATE_NOSAB) NOT INSIDE EDGE MARKS
 OUTLAYER ((LENGTH EGATE_W > 30) NOT COIN EDGE EGATE_NOSAB) NOT INSIDE EDGE MARKS
}

RULECHECK ESD_3a_G {
@ Channel width (W) of NMOS for ESD protection device (Channel width = Finger width x Finger No.). >= 360um
@ Note: The total channel width is calculated by the ESD MOS in the same Drain connection. The connectivity is not broken by resistor for this check.
@ SAB is used for drain recognition in DRC runset.
 SETLAYER X = NET AREA RATIO ENGATE_D_EMPTY ESD3C_EMPTY \[AREA(ESD3C_EMPTY)/0.001\] < 360
 OUTLAYER ((X INTERACT ENGATE) NOT INTERACT (EGATE_NOSAB OR EGATE_SAB) ) NOT MARKS
}

RULECHECK ESD_3b_G {
@ Channel width (W) of PMOS for ESD protection device (Channel width=Finger width x Finger No.)
@ Note: The total channel width is calculated by the ESD MOS in the same Drain connection. The connectivity is not broken by resistor for this check.
@ SAB is used for drain recognition in DRC runset.	≥	450	um
 SETLAYER X = NET AREA RATIO EPGATE_D_EMPTY ESD3C_EMPTY \[AREA(ESD3C_EMPTY)/0.001\] < 450
 OUTLAYER ((X INTERACT EPGATE) NOT INTERACT (EGATE_NOSAB OR EGATE_SAB)) NOT MARKS
}

RULECHECK ESD_4a_G {
@ Channel length of core N/PMOS for protection device	≥	0.08
 SETLAYER X = EGATELV COIN EDGE GATE_LE
 OUTLAYER (LENGTH X < 0.08) NOT INSIDE EDGE MARKS 
}

RULECHECK ESD_4b_G {
@ Channel length of 1.8V/1.5V (under drive) I/O N/PMOS for protection device	≥	0.15
 SETLAYER X = EGATEMV COIN EDGE GATE_LE
 OUTLAYER ((EGATEMV AND DGUD) WITH EDGE (LENGTH X < 0.15)) NOT MARKS
}

RULECHECK ESD_4c_G {
@ Channel length of 2.5V/1.8V (under drive) I/O N/PMOS for protection device	≥	0.27
 SETLAYER X = EGATEHV COIN EDGE GATE_LE
 OUTLAYER ((EGATEHV AND TGV) WITH EDGE (LENGTH X < 0.27)) NOT MARKS
}

RULECHECK ESD_4d_G {
@ Channel length of 2.5V overdrive 3.3V I/O NMOS for protection device	≥	0.55
 SETLAYER X = ENGATEHV COIN EDGE GATE_LE
 OUTLAYER ((ENGATEHV AND OVERDR) WITH EDGE (LENGTH X < 0.55)) NOT MARKS
}

RULECHECK ESD_4e_G {
@ Channel length of 2.5V overdrive 3.3V I/O PMOS for protection device	≥	0.44
 SETLAYER X = EPGATEHV COIN EDGE GATE_LE
 OUTLAYER ((EPGATEHV AND OVERDR) WITH EDGE (LENGTH X < 0.44)) NOT MARKS
}

#RULECHECK ESD_5_G {
#@ Space from poly edge to CT edge on source side (SCP) for NMOS and PMOS (Fig. 4 and Fig.6). >= 0.2um
# OUTLAYER ((EXT EGATE_W ECT_S < 0.2 ABUT< 90 REGION) NOT INTERACT EGATE_NOSAB) NOT  MARKS
#}

#RULECHECK ESD_6_G {
#@ Space from poly edge to CT edge on drain side (DCP) (Fig. 4 and Fig.6). >= 1um
# OUTLAYER ((EXT EGATE_W ECT_D < 1 ABUT< 90 REGION)  NOT INTERACT EGATE_NOSAB) NOT  MARKS
#}

RULECHECK ESD_7_G {
@ SAB should block on drain side of NMOS and PMOS (contact region should be kept silicided.)
@ SAB drawn on source side is not necessary.
 OUTLAYER ((EGATE NOT INTERACT ESAB) NOT INTERACT EGATE_NOSAB) NOT MARKS
 OUTLAYER (ECT AND ESAB) NOT MARKS
 OUTLAYER (EMOS_S AND ESAB) NOT MARKS
}
			
RULECHECK ESD_8_G {
@ Width of SAB on the drain side (A) for 1.0/1.2/1.8 NMOS and PMOS, note: A does not include the overlap of SAB area and GT(Fig. 4 and Fig.6). >= 0.6um
 OUTLAYER ((EXT ESAB_HO EGATE_W < 0.6 ABUT < 90 REGION) NOT INTERACT EGATE_NOSAB) NOT MARKS
}

RULECHECK ESD_9_G {
@ ESD protection devices should be surrounded by guard ring, this guard ring also can be designed as the pickup of the ESD device. (Fig.2)
 OUTLAYER (NOT EPGATE ENGUARDRING) NOT MARKS
 OUTLAYER (NOT ENGATE EPGUARDRING) NOT MARKS
}			

RULECHECK ESD_14a_G {
@ The overlap (Sd) of SAB and poly for all I/O ESD N/PMOS (Fig. 4). >= 0.05um
 OUTLAYER ((INT EGATEHV ESAB < 0.05 ABUT < 90 SINGULAR REGION) NOT INTERACT (EGATE_NOSAB OR EGATE_SAB)) NOT MARKS
 OUTLAYER ((INT EGATEMV ESAB < 0.05 ABUT < 90 SINGULAR REGION) NOT INTERACT (EGATE_NOSAB OR EGATE_SAB)) NOT MARKS
}

RULECHECK ESD_14b_G {
@ The overlap (Sd) of the SAB and poly for core I/O ESD N/PMOS. >= 0.02um
 OUTLAYER ((INT EGATELV ESAB < 0.02 ABUT < 90 SINGULAR REGION) NOT INTERACT (EGATE_NOSAB OR EGATE_SAB)) NOT MARKS
}

RULECHECK ESD_15_G {
@ For high voltage tolerant I/O using Cascoded I/O NMOS, ESD implant is required. (refer to Fig.5& 6)
 #OUTLAYER ((EGATE_CASCODED NOT ESD1) NOT INTERACT (EGATE_NOSAB OR EGATE_SAB)) NOT MARKS
 #OUTLAYER ((ESDHV NOT ESD) NOT INTERACT (EGATE_NOSAB OR EGATE_SAB)) NOT MARKS

 SETLAYER X = (ENACT AND ESDHV) ENCLOSE ENGATE_CASCODED
 SETLAYER Y = X AND ESD1
 OUTLAYER ((((ESDIO2 AND ESDHV) ENCLOSE X) NOT ENCLOSE Y) NOT INTERACT (EGATE_NOSAB OR EGATE_SAB)) NOT  MARKS
}

RULECHECK ESD_16a_G {
@ Channel length for 2.5V tolerant I/O using 1.8V cascoded N/PMOS	≥	0.15	um
 SETLAYER X = EGATEMV COIN EDGE GATE_LE
 OUTLAYER (((EGATEMV AND ESDHV) NOT (EGATE_NOSAB OR EGATE_SAB))  WITH EDGE (LENGTH X < 0.15)) NOT MARKS
}

RULECHECK ESD_16b_G {
@ Channel length for 3.3V tolerant I/O using 2.5V cascoded N/PMOS	≥	0.27	um
 SETLAYER X = EGATEHV COIN EDGE GATE_LE
 OUTLAYER (((EGATEHV AND ESDHV) NOT (EGATE_NOSAB OR EGATE_SAB))  WITH EDGE (LENGTH X < 0.27)) NOT MARKS
}

RULECHECK ESD_16c_G {
@ Channel length for 5V tolerant I/O using 3.3V (2.5V overdrive) cascoded N/PMOS	≥	0.55	um
 SETLAYER X = EGATEHV COIN EDGE GATE_LE
 OUTLAYER ((((EGATEHV AND ESDHV) AND OVERDR) NOT (EGATE_NOSAB OR EGATE_SAB)) WITH EDGE (LENGTH X < 0.55)) NOT MARKS			
}

RULECHECK ESD_17_G {
@ The space (S) between active poly gate and inactive poly gate of cascoded NMOS should be (Fig.6). <= 0.3um
# SETLAYER X = EGATE_CASCODED_OVLAP NOT (EGATE_NOSAB OR EGATE_SAB)
# OUTLAYER (DFM COPY (DFM SPACE X EGATE_CASCODED_INSID > 0.3 <10 BY EXT) REGION) NOT MARKS
# OUTLAYER (X COIN OUTSIDE EDGE EGATE_CASCODED_INSID) NOT INSIDE EDGE MARKS
 SETLAYER X = (ENGATE_CASCODED_OVLAP NOT (EGATE_NOSAB OR EGATE_SAB))COIN EDGE EGATE_W
 OUTLAYER (DFM COPY (DFM SPACE X ENGATE_CASCODED_INSID > 0.3 <10 BY EXT) REGION)  NOT MARKS
 OUTLAYER (X COIN OUTSIDE EDGE ENGATE_CASCODED_INSID) NOT INSIDE EDGE MARKS
}

RULECHECK ESD_18_G {
@ For high voltage tolerant I/O designed by cascoded N/PMOS, SAB should cover all top poly gates and extend to overlap the second poly gate by (Fig. 6). >= 0.05um
 SETLAYER X = EGATE_CASCODED INTERACT ESAB
 OUTLAYER ((INT X ESAB < 0.05 ABUT < 90 SINGULAR REGION) NOT INTERACT (EGATE_NOSAB OR EGATE_SAB)) NOT MARKS 
 OUTLAYER ((EGATE_CASCODED OUTSIDE ESAB) NOT (EGATE_NOSAB OR EGATE_SAB)) NOT MARKS
}



#//===================================
#//  ESD1 implant layer rules
#//===================================

GROUP GESD1 ESD1_?



RULECHECK ESD1_1 {
@ ESD1 width. >= 0.5um
 OUTLAYER (INT ESD1 < 0.5 ABUT < 90 SINGULAR REGION) NOT MARKS
}

RULECHECK ESD1_2 {
@ Space between two ESD1s. Merge if space is less than this value. >= 0.5um
 OUTLAYER (EXT ESD1 < 0.5 ABUT < 90 SINGULAR REGION) NOT MARKS
}

RULECHECK ESD1_3 {
@ ESD1 area. >= 1um2
 OUTLAYER (AREA ESD1 < 1) NOT MARKS
}

RULECHECK ESD1_4 {
@ ESD1 enclosed area. >= 1um2
 OUTLAYER (AREA ((HOLES ESD1 INNER) NOT ESD1) < 1) NOT MARKS
}

RULECHECK ESD1_5 {
@ CT enclosure by ESD1. >= 0.2um
 OUTLAYER (ENC CT ESD1 < 0.2 ABUT < 90 SINGULAR REGION) NOT MARKS
}

RULECHECK ESD1_5a_R_DFM2 {
@ The recommended CT enclosure by ESD1. >= 0.4um
 OUTLAYER (ENC CT ESD1 < 0.4 ABUT < 90 SINGULAR REGION) NOT MARKS
}

RULECHECK ESD1_6 {
@ Space between an ESD1 implant to an N-channel Poly gate. >= 0.2um
 OUTLAYER (EXT NGATE ESD1 < 0.2 ABUT<90 SINGULAR REGION) NOT MARKS
}

RULECHECK ESD1_7 {
@ ESD1 must be enclosed by AA at least. >= 0.2um
 OUTLAYER (ENC ESD1 AA < 0.2 ABUT<90 SINGULAR REGION OUTSIDE ALSO) NOT MARKS
}

RULECHECK ESD1_8 {
@ ESD1 implant region is not allowed to overlap with SP.
 OUTLAYER (ESD1 AND SP) NOT MARKS
}

RULECHECK ESD1_10 {
@ ESD1 isn’t allowed to interact with poly in drain side.
 SETLAYER AA_drain = (((AA AND ESDIO2) INTERACT GATE) NOT GATE) NOT OUTSIDE SAB
 OUTLAYER ((ESD1 AND AA_drain) INTERACT GT) NOT MARKS
}

#//===========================================
#//  Power Clamp guidelines
#//===========================================

SETLAYER NESDCLP_NOSAB = ((NACT AND ESDCLP) AND ESDIO2) NOT INTERACT SAB
SETLAYER NESDCLP_SAB = ((NACT AND ESDCLP) AND ESDIO2) INTERACT SAB
SETLAYER PESDCLP_NOSAB = ((PACT AND ESDCLP) AND ESDIO2) NOT INTERACT SAB
SETLAYER PESDCLP_SAB = ((PACT AND ESDCLP) AND ESDIO2) INTERACT SAB

SETLAYER ENGATE_NOSAB = GATE AND NESDCLP_NOSAB
SETLAYER ENGATE_SAB = GATE AND NESDCLP_SAB
SETLAYER EPGATE_NOSAB = GATE AND PESDCLP_NOSAB
SETLAYER EPGATE_SAB = GATE AND PESDCLP_SAB
SETLAYER EGATE_NOSAB = ENGATE_NOSAB OR EPGATE_NOSAB
SETLAYER EGATE_SAB = ENGATE_SAB OR EPGATE_SAB

SETLAYER EGATE_NOSAB_W = EGATE_NOSAB COIN EDGE GATE_WE

SETLAYER EGATEHV_NOSAB = EGATE_NOSAB AND TG
SETLAYER EGATEHV_SAB = EGATE_SAB AND TG
SETLAYER EGATEMV_NOSAB = EGATE_NOSAB AND DG                          //1.8V or 1.5V
SETLAYER EGATEMV_SAB = EGATE_SAB AND DG
SETLAYER EGATELV_NOSAB = EGATE_NOSAB NOT INSIDE (DG OR TG)                          //1.05V

SETLAYER ENMOSHV_NOSAB = NESDCLP_NOSAB ENCLOSE EGATEHV_NOSAB
SETLAYER EPMOSHV_NOSAB = PESDCLP_NOSAB ENCLOSE EGATEHV_NOSAB
SETLAYER ENMOSMV_NOSAB = NESDCLP_NOSAB ENCLOSE EGATEMV_NOSAB
SETLAYER EPMOSMV_NOSAB = PESDCLP_NOSAB ENCLOSE EGATEMV_NOSAB
SETLAYER ENMOSLV_NOSAB = NESDCLP_NOSAB ENCLOSE EGATELV_NOSAB
SETLAYER EPMOSLV_NOSAB = PESDCLP_NOSAB ENCLOSE EGATELV_NOSAB

SETLAYER ENMOSHV_SAB = NESDCLP_SAB ENCLOSE EGATEHV_SAB
SETLAYER EPMOSHV_SAB = PESDCLP_SAB ENCLOSE EGATEHV_SAB
SETLAYER ENMOSMV_SAB = NESDCLP_SAB ENCLOSE EGATEMV_SAB
SETLAYER EPMOSMV_SAB = PESDCLP_SAB ENCLOSE EGATEMV_SAB

SETLAYER EMOSHV_NOSAB = ENMOSHV_NOSAB OR EPMOSHV_NOSAB
SETLAYER EMOSMV_NOSAB = ENMOSMV_NOSAB OR EPMOSMV_NOSAB
SETLAYER EMOSLV_NOSAB = ENMOSLV_NOSAB OR EPMOSLV_NOSAB

SETLAYER EMOSHV_SAB = ENMOSHV_SAB OR EPMOSHV_SAB
SETLAYER EMOSMV_SAB = ENMOSMV_SAB OR EPMOSMV_SAB

SETLAYER EMOSHV_SD_NOSAB = EMOSHV_NOSAB NOT EGATE
SETLAYER EMOSMV_SD_NOSAB = EMOSMV_NOSAB NOT EGATE
SETLAYER EMOSLV_SD_NOSAB = EMOSLV_NOSAB NOT EGATE

SETLAYER EMOSHV_SD_SAB = EMOSHV_SAB NOT EGATE
SETLAYER EMOSMV_SD_SAB = EMOSMV_SAB NOT EGATE

SETLAYER EMOSHV_D_SAB = EMOSHV_SD_SAB ENCLOSE ECT_D
SETLAYER EMOSMV_D_SAB = EMOSMV_SD_SAB ENCLOSE ECT_D

SETLAYER EMOSLV_DS_NOSAB = EMOSLV_SD_NOSAB ENCLOSE ECT_S 
SETLAYER EMOSMV_DS_NOSAB = EMOSMV_SD_NOSAB ENCLOSE ECT_S
SETLAYER EMOSHV_DS_NOSAB = EMOSHV_SD_NOSAB ENCLOSE ECT_S

SETLAYER EGATEHV_D_EMPTY3 = EMPTY3 OR (ESDCLP AND EMOSHV_D_SAB)
SETLAYER EGATEMV_D_EMPTY3 = EMPTY3 OR (ESDCLP AND EMOSMV_D_SAB)
SETLAYER EGATEHV_DS_EMPTY3 = EMPTY3 OR (ESDCLP AND EMOSHV_DS_NOSAB)
SETLAYER EGATEMV_DS_EMPTY3 = EMPTY3 OR (ESDCLP AND EMOSMV_DS_NOSAB)
SETLAYER EGATELV_DS_EMPTY3 = EMPTY3 OR (ESDCLP AND EMOSLV_DS_NOSAB)

SETLAYER ESD3C_EMPTY3 = EMPTY3 OR ESD3C
#use the list "total_metal_via_list_with_name_mapping" for layer logic operation
foreach metal_via $total_metal_via_list_with_name_mapping {
  SETLAYER E${metal_via}_EMPTY3 = EMPTY3 OR (ESDCLP AND $metal_via)
}

SETLAYER ECT_EMPTY3 = EMPTY3 OR (ESDCLP AND CT)
SETLAYER EALPA_EMPTY3 = EMPTY3 OR (ESDCLP AND ALPA)
SETLAYER EPA_EMPTY3 = EMPTY3 OR (ESDCLP AND PA)
SETLAYER EMD_EMPTY3 = EMPTY3 OR (ESDCLP AND MD)  

CONNECT EGATEHV_D_EMPTY3 ESD3C_EMPTY3
CONNECT EGATEHV_D_EMPTY3 EM1_EMPTY3 BY ECT_EMPTY3
CONNECT EGATEMV_D_EMPTY3 ESD3C_EMPTY3
CONNECT EGATEMV_D_EMPTY3 EM1_EMPTY3 BY ECT_EMPTY3

CONNECT EGATEHV_DS_EMPTY3 ESD3C_EMPTY3
CONNECT EGATEHV_DS_EMPTY3 EM1_EMPTY3 BY ECT_EMPTY3
CONNECT EGATEMV_DS_EMPTY3 ESD3C_EMPTY3
CONNECT EGATEMV_DS_EMPTY3 EM1_EMPTY3 BY ECT_EMPTY3
CONNECT EGATELV_DS_EMPTY3 ESD3C_EMPTY3
CONNECT EGATELV_DS_EMPTY3 EM1_EMPTY3 BY ECT_EMPTY3


#use the list "total_metal_via_list_with_name_mapping" to establish the special conncection for ESD parts
for { set i 0 } { $i < [expr [llength $total_metal_via_list_with_name_mapping] -2] } { incr i 2 } {
  CONNECT E[lindex $total_metal_via_list_with_name_mapping $i]_EMPTY3 E[lindex $total_metal_via_list_with_name_mapping [expr $i +2]]_EMPTY3 BY \
          E[lindex $total_metal_via_list_with_name_mapping [expr $i +1]]_EMPTY3
}

CONNECT ETM2_EMPTY3 EALPA_EMPTY3 BY EPA_EMPTY3
CONNECT EALPA_EMPTY3 EMD_EMPTY3

 
RULECHECK ESD_31a_G {
@ Channel width (W) of core non-SAB type power clamp N/PMOS (Channel width=Finger width x Finger No.)	≥	1500
SETLAYER X = NET AREA RATIO EGATELV_DS_EMPTY3 ESD3C_EMPTY3 \[AREA(ESD3C_EMPTY3)/0.001\] < 1500
OUTLAYER (X INTERACT (EGATELV_NOSAB INTERACT X ==2) ) NOT MARKS
}

RULECHECK ESD_31b_G {
@ Channel width (W) of 1.8V/2.5V (and all underdrive or overdrive) I/O non-SAB type power clamp N/PMOS (Channel width=Finger width x Finger No.)≥1000
SETLAYER X = NET AREA RATIO EGATEMV_DS_EMPTY3 ESD3C_EMPTY3 \[AREA(ESD3C_EMPTY3)/0.001\] < 1000
OUTLAYER (X INTERACT (EGATEMV_NOSAB INTERACT X == 2) ) NOT MARKS
 
SETLAYER Y = NET AREA RATIO EGATEHV_DS_EMPTY3 ESD3C_EMPTY3 \[AREA(ESD3C_EMPTY3)/0.001\] < 1000
OUTLAYER (Y INTERACT (EGATEHV_NOSAB INTERACT Y == 2)) NOT MARKS
}

RULECHECK ESD_31c_G {
@ Channel width (W) of 1.8V/2.5V (and all underdrive or overdrive) I/O SAB type power clamp N/PMOS (Channel width=Finger width x Finger No.)≥1000
SETLAYER X = NET AREA RATIO EGATEMV_D_EMPTY3 ESD3C_EMPTY3 \[AREA(ESD3C_EMPTY3)/0.001\] < 1000
OUTLAYER (X INTERACT EGATEMV_SAB) NOT MARKS
SETLAYER Y = NET AREA RATIO EGATEHV_D_EMPTY3 ESD3C_EMPTY3 \[AREA(ESD3C_EMPTY3)/0.001\] < 1000
OUTLAYER (Y INTERACT EGATEHV_SAB) NOT MARKS
}

RULECHECK ESD_32_G {
@ For non-SAB type power clamp, the spacing of source/drain CT to poly	≥	0.2
OUTLAYER (EXT EGATE_NOSAB_W ECT_S < 0.2 ABUT< 90 REGION) NOT MARKS
}



#//===========================================
#//  Latch-Up Prevention Layout Guidelines
#//===========================================

GROUP GLU LU_?

SETLAYER NOIO_PAD = VSSMK1 OR VDDMK1 
SETLAYER ALL_RES =  (AA ENCLOSE (AARES OR NWAARES)) OR (GT ENCLOSE GTRES) 

SETLAYER all_top_pad = inside cell ALPA calibre_top_cell primary only
SETLAYER all_pad = with text all_top_pad "?"
SETLAYER all_pad_vdd1 =  with text  ALPA "?VDD?"   ALPATXT primary only  
SETLAYER all_pad_vss1 =  with text  ALPA  "?VSS?"  ALPATXT  primary only 
SETLAYER all_pad_vcc1 =  with text  ALPA "?VCC?"   ALPATXT  primary only 
SETLAYER all_pad_gnd1 =  with text  ALPA "?GND?"   ALPATXT  primary only
SETLAYER all_pad_TXT = (all_pad_vdd1 OR all_pad_vss1) OR (all_pad_vcc1 OR all_pad_gnd1)

SETLAYER NACT_0 = (SN AND AA) NOT GT    
SETLAYER PACT_0 = (SP AND AA) NOT GT  


if { ($CONNECT_ALL_RESISTOR == 0) && ($DEFINE_PAD_BY_TEXT == 1) } {
foreach metal_via $total_metal_via_list_with_name_mapping {
  SETLAYER  ${metal_via}_EMPTY5 = EMPTY5 OR ${metal_via} 
}
SETLAYER  NACT_1 = EMPTY5 OR (NACT_0 NOT ALL_RES) 
SETLAYER  PACT_1 = EMPTY5 OR (PACT_0 NOT ALL_RES) 
SETLAYER  GT_1  =  EMPTY5 OR (GT_raw NOT GTRES )
SETLAYER  MD_1  = EMPTY5 OR MD_IO_PAD
SETLAYER  ALPA_1 = EMPTY5 OR (ALPA NOT all_pad_TXT)
}


if { ($CONNECT_ALL_RESISTOR == 0) && ($DEFINE_PAD_BY_TEXT == 0) } {
foreach metal_via $total_metal_via_list_with_name_mapping {
  SETLAYER  ${metal_via}_EMPTY5 = EMPTY5 OR ${metal_via}
}
SETLAYER  NACT_1 = EMPTY5 OR (NACT_0 NOT ALL_RES) 
SETLAYER  PACT_1 = EMPTY5 OR (PACT_0 NOT ALL_RES) 
SETLAYER  GT_1  =  EMPTY5 OR (GT_raw NOT GTRES )
SETLAYER  MD_1  = EMPTY5 OR MD_IO_PAD 
SETLAYER  ALPA_1 = EMPTY5 OR ALPA 
}


if { ($CONNECT_ALL_RESISTOR == 1) && ($DEFINE_PAD_BY_TEXT == 1) } {
foreach metal_via $total_metal_via_list_with_name_mapping {
  SETLAYER  ${metal_via}_EMPTY5 = EMPTY5 OR ${metal_via} 
}
SETLAYER  NACT_1 = EMPTY5 OR NACT_0  
SETLAYER  PACT_1 = EMPTY5 OR PACT_0  
SETLAYER  GT_1 = EMPTY5 OR GT_raw 
SETLAYER  MD_1  = EMPTY5 OR MD_IO_PAD 
SETLAYER  ALPA_1 = EMPTY5 OR (ALPA NOT all_pad_TXT)
}

if { ($CONNECT_ALL_RESISTOR == 1) && ($DEFINE_PAD_BY_TEXT == 0) } {
foreach metal_via $total_metal_via_list_with_name_mapping {
  SETLAYER  ${metal_via}_EMPTY5 = EMPTY5 OR ${metal_via} 
}
SETLAYER  NACT_1 = EMPTY5 OR NACT_0  
SETLAYER  PACT_1 = EMPTY5 OR PACT_0 
SETLAYER  GT_1 = EMPTY5 OR GT_raw
SETLAYER  MD_1  = EMPTY5 OR MD_IO_PAD 
SETLAYER  ALPA_1 = EMPTY5 OR ALPA 
}
SETLAYER CT_1 = EMPTY5 OR CT
SETLAYER PA_1 = EMPTY5 OR PA

SETLAYER MD_IO_PAD = MD NOT NOIO_PAD
SETLAYER NMOS = NACT ENCLOSE GATE 
SETLAYER PMOS = PACT ENCLOSE GATE 


for { set i 0 } { $i < [expr [llength $total_metal_via_list_with_name_mapping] -2] } { incr i 2 } {
  CONNECT [lindex $total_metal_via_list_with_name_mapping $i]_EMPTY5 [lindex $total_metal_via_list_with_name_mapping [expr $i +2]]_EMPTY5 BY \
          [lindex $total_metal_via_list_with_name_mapping [expr $i +1]]_EMPTY5
}


CONNECT M1_EMPTY5 GT_1 NACT_1 PACT_1  BY CT_1
CONNECT TM2_EMPTY5 ALPA_1 BY PA_1
CONNECT ALPA_1 MD_1

SETLAYER NMOS_PAD = NMOS INTERACT (NET AREA RATIO NACT_1  MD_1 > 0) 
SETLAYER PMOS_PAD = PMOS INTERACT (NET AREA RATIO PACT_1  MD_1 > 0) 

SETLAYER NAA_PAD = NET AREA RATIO NACT_1  MD_1 > 0 
SETLAYER PAA_PAD = NET AREA RATIO PACT_1  MD_1 > 0 

SETLAYER PMOS1 = PAA ENCLOSE GATE
SETLAYER NMOS1 = NAA ENCLOSE GATE
SETLAYER NGUARDRING = HOLES NTAP INNER
SETLAYER PGUARDRING = HOLES PTAP INNER
SETLAYER NGUARDHOLE_2 = (HOLES NTAP INNER) ENCLOSE PGUARDRING
SETLAYER PGUARDHOLE_2 = (HOLES PTAP INNER) ENCLOSE NGUARDRING

SETLAYER GATEHV = GATE AND TG 
SETLAYER NGATEHV = NGATE AND TG
SETLAYER PGATEHV = PGATE AND TG
SETLAYER GATEMV = GATE AND DG                          //1.8V or 1.5V
SETLAYER GATELV = GATE NOT INSIDE (DG OR TG)   

RULECHECK LU_1_G {
@ Guard ring should be used to surround AA injector or a group of AA injectors which are connected to an I/O pad.
@ N+ injector must be surrounded by a P+ guard-ring.
@ P+ injector must be surrounded by a N+ guard-ring.
 OUTLAYER (NAA_PAD NOT PGUARDRING) NOT (MARKS OR LUWMK1)
 OUTLAYER (PAA_PAD NOT NGUARDRING) NOT (MARKS OR LUWMK1)
}
			
RULECHECK LU_2_G {
@ Guard-ring width for AA injector connected to an I/O pad.>= 0.2um
 OUTLAYER (INT ((DONUT NTAP) TOUCH ((HOLES NTAP) ENCLOSE (PAA_PAD OR NAA_PAD))) < 0.2 ABUT<90 SINGULAR REGION) NOT (MARKS OR LUWMK1)
 OUTLAYER (INT ((DONUT PTAP) TOUCH ((HOLES PTAP) ENCLOSE (PAA_PAD OR NAA_PAD))) < 0.2 ABUT<90 SINGULAR REGION) NOT (MARKS OR LUWMK1)
}
#//LU_3_G LU.3a-LU.3d define minimum space (S1) between NMOS and PMOS with either one of NMOS or PMOS AA connected to I/O pad. (Fig.1). 


VERBATIM { 
#IFDEF LU_3_CHECK FAST
} 
RULECHECK LU_3_3a_G {
@ For core N/PMOS connected to an I/O pad
@ Spacing between NMOS and PMOS. >= 2um
 SETLAYER  X = (NMOS_PAD ENCLOSE GATELV) NOT (MARKS OR LUWMK1)
 SETLAYER  Y = (PMOS_PAD ENCLOSE GATELV) NOT (MARKS OR LUWMK1)
 SETLAYER  M = (NMOS ENCLOSE GATELV) NOT (MARKS OR LUWMK1)
 SETLAYER  N = (PMOS ENCLOSE GATELV) NOT (MARKS OR LUWMK1)
 SETLAYER  Z1 = SIZE X BY 1.036 BEVEL 3
 SETLAYER  Z2 = SIZE N BY 1.036 BEVEL 3
 OUTLAYER  Z1 AND Z2     
 SETLAYER   Z3 = SIZE M BY 1.036 BEVEL 3
 SETLAYER   Z4 = SIZE Y BY 1.036 BEVEL 3
 OUTLAYER   Z3 AND Z4 
}

RULECHECK LU_3_3b_G {
@ For 1.8V N/PMOS AA connected to an I/O pad
@ Spacing between 1.8V NMOS and 1.8V/Core PMOS and Spacing between 1.8V PMOS and 1.8V/Core NMOS. >= 2.3um
 SETLAYER X = NMOS_PAD ENCLOSE GATEMV
 SETLAYER Y = PMOS_PAD ENCLOSE GATEMV
 SETLAYER M = NMOS ENCLOSE (GATELV OR GATEMV)
 SETLAYER N = PMOS ENCLOSE (GATELV OR GATEMV)

 SETLAYER Z1 = SIZE X BY 1.191 BEVEL 3
 SETLAYER Z2 = SIZE N BY 1.191 BEVEL 3
 OUTLAYER (Z1 AND Z2) NOT (MARKS OR LUWMK1)
 SETLAYER Z3 = SIZE M BY 1.191 BEVEL 3
 SETLAYER Z4 = SIZE Y BY 1.191 BEVEL 3
 OUTLAYER (Z3 AND Z4) NOT (MARKS OR LUWMK1)
}

RULECHECK LU_3_3c_G {
@ For 2.5V N/PMOS AA connected to an I/O pad
@ Spacing between 2.5V NMOS and 2.5V/Core PMOS and Spacing between 2.5V PMOS and 2.5V/Core NMOS. >= 3.2um
 SETLAYER X = NMOS_PAD ENCLOSE GATEHV
 SETLAYER Y = PMOS_PAD ENCLOSE GATEHV
 SETLAYER M = NMOS ENCLOSE (GATELV OR GATEHV )
 SETLAYER N = PMOS ENCLOSE (GATELV OR GATEHV)

 SETLAYER Z1 = SIZE X BY 1.657 BEVEL 3
 SETLAYER Z2 = SIZE N BY 1.657 BEVEL 3
 OUTLAYER (Z1 AND Z2) NOT (MARKS OR LUWMK1)
 SETLAYER Z3 = SIZE M BY 1.657 BEVEL 3
 SETLAYER Z4 = SIZE Y BY 1.657 BEVEL 3
 OUTLAYER  (Z3 AND Z4) NOT (MARKS OR LUWMK1)
}

RULECHECK LU_3_3d_G {
@ For 3.3 V N/PMOS AA (2.5V overdrive) connected to an I/O pad
@ Spacing between 3.3V NMOS and 3.3V/Core PMOS and Spacing between 3.3V PMOS and 3.3V/Core NMOS.	≥	5
 SETLAYER X = NMOS_PAD ENCLOSE (GATEHV AND OVERDR)
 SETLAYER Y = PMOS_PAD ENCLOSE (GATEHV AND OVERDR)
 SETLAYER M = NMOS ENCLOSE (GATELV OR (GATEHV AND OVERDR))
 SETLAYER N = PMOS ENCLOSE (GATELV OR (GATEHV AND OVERDR))

 SETLAYER  Z1 = SIZE X BY 2.589 BEVEL 3
 SETLAYER  Z2 = SIZE N BY 2.589 BEVEL 3
 OUTLAYER  (Z1 AND Z2) NOT (MARKS OR LUWMK1)
 SETLAYER  Z3 = SIZE M BY 2.589 BEVEL 3
 SETLAYER  Z4 = SIZE Y BY 2.589 BEVEL 3
 OUTLAYER  (Z3 AND Z4) NOT (MARKS OR LUWMK1)
}
VERBATIM {
#ENDIF 


#IFDEF LU_3_CHECK ACCURATE 
}
RULECHECK LU_3_3a_G {
@ For core N/PMOS connected to an I/O pad
@ Spacing between NMOS and PMOS. >= 2um
 SETLAYER X = NMOS_PAD ENCLOSE GATELV
 SETLAYER Y = PMOS_PAD ENCLOSE GATELV
 SETLAYER M = NMOS ENCLOSE GATELV
 SETLAYER N = PMOS ENCLOSE GATELV
 OUTLAYER (EXT X N < 2 ABUT<90 SINGULAR REGION) NOT (MARKS OR LUWMK1)
 OUTLAYER (EXT M Y < 2 ABUT<90 SINGULAR REGION) NOT (MARKS OR LUWMK1)
}

RULECHECK LU_3_3b_G {
@ For 1.8V N/PMOS AA connected to an I/O pad
@ Spacing between 1.8V NMOS and 1.8V/Core PMOS and Spacing between 1.8V PMOS and 1.8V/Core NMOS. >= 2.3um
 SETLAYER X = NMOS_PAD ENCLOSE GATEMV
 SETLAYER Y = PMOS_PAD ENCLOSE GATEMV
 SETLAYER M = NMOS ENCLOSE (GATELV OR GATEMV)
 SETLAYER N = PMOS ENCLOSE (GATELV OR GATEMV)
 OUTLAYER (EXT M Y < 2.3 ABUT<90 SINGULAR REGION) NOT (MARKS OR LUWMK1)
 OUTLAYER (EXT X  N < 2.3 ABUT<90 SINGULAR REGION) NOT (MARKS OR LUWMK1)
}

RULECHECK LU_3_3c_G {
@ For 2.5V N/PMOS AA connected to an I/O pad
@ Spacing between 2.5V NMOS and 2.5V/Core PMOS and Spacing between 2.5V PMOS and 2.5V/Core NMOS. >= 3.2um
 SETLAYER X = NMOS_PAD ENCLOSE GATEHV
 SETLAYER Y = PMOS_PAD ENCLOSE GATEHV
 SETLAYER M = NMOS ENCLOSE (GATELV OR GATEHV )
 SETLAYER N = PMOS ENCLOSE (GATELV OR GATEHV)
 OUTLAYER (EXT M Y < 3.2 ABUT<90 SINGULAR REGION) NOT (MARKS OR LUWMK1)
 OUTLAYER (EXT X N < 3.2 ABUT<90 SINGULAR REGION) NOT (MARKS OR LUWMK1)
}

RULECHECK LU_3_3d_G {
@ For 3.3 V N/PMOS AA (2.5V overdrive) connected to an I/O pad
@ Spacing between 3.3V NMOS and 3.3V/Core PMOS and Spacing between 3.3V PMOS and 3.3V/Core NMOS.	≥	5
 SETLAYER X = NMOS_PAD ENCLOSE (GATEHV AND OVERDR)
 SETLAYER Y = PMOS_PAD ENCLOSE (GATEHV AND OVERDR)
 SETLAYER M = NMOS ENCLOSE (GATELV OR (GATEHV AND OVERDR))
 SETLAYER N = PMOS ENCLOSE (GATELV OR (GATEHV AND OVERDR))
 OUTLAYER (EXT X N < 5 ABUT<90 SINGULAR REGION) NOT (MARKS OR LUWMK1)
 OUTLAYER (EXT Y M < 5 ABUT<90 SINGULAR REGION) NOT (MARKS OR LUWMK1)
}
VERBATIM {
#ENDIF 
}

RULECHECK LU_4_NTAP_G {
@ Space (S2) from any point within the Source/Drain region to the nearest pickup AA region inside the same well for I/O and internal circuits. (Fig.2). 
@ DRC doesn’t check OCCD region. <= 35um
 SETLAYER A = INT NTAP < 0.005 ABUT INTERSECTING ONLY REGION
 SETLAYER B = (NTAP INTERACT A) NOT A
 SETLAYER C = INT B < 0.001 ABUT INTERSECTING ONLY REGION
 SETLAYER D = (B INTERACT C) NOT C
 #SETLAYER NW_MINUS_NTAP = SIZE D BY 35 INSIDE OF NW STEP 0.38
 #SETLAYER X = PMOS1 AND NW
 #OUTLAYER (OUTSIDE EDGE X NW_MINUS_NTAP) NOT INSIDE EDGE (MARKS OR OCCD)

 SETLAYER NW_MINUS_NTAP_0 = SIZE D BY 15 INSIDE OF NW STEP 0.38 TRUNCATE 0.1
 SETLAYER MAYBE_BAD_b = NW NOT NW_MINUS_NTAP_0
 SETLAYER NW_FILTER = NW INTERACT MAYBE_BAD_b
 SETLAYER NW_MINUS_NTAP_1 = NW_MINUS_NTAP_0 AND NW_FILTER
 SETLAYER NW_MINUS_NTAP = SIZE NW_MINUS_NTAP_1 BY 20 INSIDE OF NW_FILTER STEP 0.38 TRUNCATE 0.1
 SETLAYER X = PMOS1 AND NW_FILTER
 OUTLAYER (OUTSIDE EDGE X NW_MINUS_NTAP) NOT INSIDE EDGE (MARKS OR OCCD)
}

RULECHECK LU_4_PTAP_G {
@ Space (S2) from any point within the Source/Drain region to the nearest pickup AA region inside the same well for I/O and internal circuits. (Fig.2). 
@ DRC doesn’t check OCCD region. <= 35um
 SETLAYER A = INT PTAP < 0.005 ABUT INTERSECTING ONLY REGION
 SETLAYER B = (PTAP INTERACT A) NOT A
 SETLAYER C = INT B < 0.001 ABUT INTERSECTING ONLY REGION
 SETLAYER D = (B INTERACT C) NOT C
 #SETLAYER PW_MINUS_PTAP = SIZE D BY 35 INSIDE OF PW STEP 0.38
 #SETLAYER X = NMOS1 AND PW
 #OUTLAYER (OUTSIDE EDGE X PW_MINUS_PTAP) NOT INSIDE EDGE (MARKS OR OCCD)

 SETLAYER PW_MINUS_PTAP_0 = SIZE D BY 15 INSIDE OF PW STEP 0.38 TRUNCATE 0.1
 SETLAYER MAYBE_BAD_b = PW NOT PW_MINUS_PTAP_0
 SETLAYER PW_FILTER = PW INTERACT MAYBE_BAD_b
 SETLAYER PW_MINUS_PTAP_1 = PW_MINUS_PTAP_0 AND PW_FILTER
 SETLAYER PW_MINUS_PTAP = SIZE PW_MINUS_PTAP_1 BY 20 INSIDE OF PW_FILTER STEP 0.38 TRUNCATE 0.1
 SETLAYER X = NMOS1 AND PW_FILTER
 OUTLAYER (OUTSIDE EDGE X PW_MINUS_PTAP) NOT INSIDE EDGE (MARKS OR OCCD)
}






#//========================================================
#//  OCCD On chip CD cell guidelines
#//========================================================

GROUP GOCCD OCCD_?

RULECHECK OCCD_2_G {
@ Space between two OCCDFH structures,
@ Space between two OCCDFV structures,
@ Space between OCCDFH and OCCDFV structures,
@ Space between two OCCDB structures,
@ which each OCCDFH/OCCDFV/OCCDB structure in each 2000um x 2000um window. 	≥	150
@ refer to OCCD.1
OUTLAYER (EXT OCCDFH < 150 ABUT < 90 SINGULAR REGION) NOT MARKS
OUTLAYER (EXT OCCDFV < 150 ABUT < 90 SINGULAR REGION) NOT MARKS
OUTLAYER (EXT OCCDFH OCCDFV < 150 ABUT < 90 SINGULAR REGION) NOT MARKS
OUTLAYER (EXT OCCDB < 150 ABUT < 90 SINGULAR REGION) NOT MARKS
}


foreach layer { AA GT SN SP LOGO MARKS MARKG DUMBA DUMBP } {
RULECHECK OCCD_3_${layer}_G {
@ Space between OCCDFH/OCCDFV to AA, poly, SN, SP,LOGO, MARKS, MARKG, DUMBA, DUMBP outside of OCCD	≥	2	um
SETLAYER X = $layer OUTSIDE OCCD

OUTLAYER (EXT OCCDFH X < 2 ABUT < 90 SINGULAR REGION) NOT MARKS
OUTLAYER (EXT OCCDFV X < 2 ABUT < 90 SINGULAR REGION) NOT MARKS
}
}

RULECHECK OCCD_4_G {
@ At least insert one OCCD structure in two neighboring 2000um x 2000um window of chip.
@ refer to OCCD.1
SETLAYER CHECK_REGION = DRC:1 ENCLOSE RECTANGLE 2000+1000 2000 ORTHOGONAL ONLY
SETLAYER CHECK_REGION_EXPAND = GROW CHECK_REGION RIGHT BY 2000 TOP BY 2000 SEQUENTIAL
SETLAYER RECTANGLE_G = (RECTANGLES 2000-1 2000-1 1 INSIDE OF LAYER CHECK_REGION_EXPAND) AND CHECK_REGION
SETLAYER WINDOW_real = RECTANGLE_G ENCLOSE RECTANGLE 1000 1000
SETLAYER WINDOW_without_OCCD = WINDOW_real OUTSIDE OCCD
SETLAYER ERROR_WINDOW_SPACE = EXT WINDOW_without_OCCD <= 1 OPPOSITE REGION
SETLAYER ERROR_WINDOW = (WINDOW_without_OCCD INTERACT ERROR_WINDOW_SPACE) OR ERROR_WINDOW_SPACE
OUTLAYER ERROR_WINDOW NOT MARKS
}

foreach layer { DG PSUB EFUSE SAB RESAA RESP1 VARMOS LVT_N LVT_P INST ESDIO1 ESDIO2 BIPOLA INDMY MOMDMY } {	
RULECHECK OCCD_5_${layer}_G {
@ OCCDFH/OCCDFV overlap of DG, PSUB, EFUSE, SAB, RESAA, RESP1,  VARMOS, LVT_N, LVT_P, INST, ESDIO1, ESDIO2, BIPOLA, INDMY, MOMDMY is not allowed.
OUTLAYER (OCCDFH AND $layer) NOT MARKS
OUTLAYER (OCCDFV AND $layer) NOT MARKS
}
}

foreach layer { CT M1DUM M1DOP M2DUM M2DOP M3DUM M3DOP M4DUM M4DOP M5DUM M5DOP M6DUM M6DOP M7DUM M7DOP M8DUM M8DOP V1DUM V2DUM V3DUM V4DUM V5DUM V6DUM V7DUM INDMY } {
RULECHECK OCCD_6_${layer}_G {
@ OCCDB can't overlap with CT, MnDUM(n=1~8), MnDOP(n=1~8), VnDUM(n=1~7), or INDMY
OUTLAYER (OCCDB AND $layer) NOT MARKS
}
}

RULECHECK OCCD_7_G {
@ OCCDFH and OCCDFV can't overlap each other
OUTLAYER (OCCDFH AND OCCDFV) NOT MARKS
}

RULECHECK OCCD_8_G {
@ OCCDFH and OCCDFV can't interact with OCOVL
OUTLAYER (OCCDFH INTERACT OCOVL) NOT MARKS
OUTLAYER (OCCDFV INTERACT OCOVL) NOT MARKS
}

RULECHECK OCCD_9_G {
@ Poly in OCCDFH/OCCDFV must be in vertical direction.
OUTLAYER (ANGLE (GT_L INSIDE EDGE OCCDFH) != 90) NOT INSIDE EDGE MARKS
OUTLAYER (ANGLE (GT_L INSIDE EDGE OCCDFV) != 90) NOT INSIDE EDGE MARKS
}	



#//========================================================
#//  OCOVL On chip cell guidelines
#//========================================================

GROUP GOCOVL OCOVL_?

RULECHECK OCOVL_2_G {
@ Space between two OCOVL structures 
@ DRC check methodology for the maximum space: (((NOT (OCOVL) ) sd 6500um) su 6500um) ≥ 2000um ≤ 13000um
OUTLAYER (EXT OCOVL < 2000 ABUT < 90 SINGULAR REGION) NOT MARKS

SETLAYER X = (DRC:1 NOT OCOVL) NOT MARKS
OUTLAYER SIZE X BY 6500 UNDEROVER
}

foreach layer { AA GT SN SP CT M1 LOGO MARKS MARKG DUMBA DUMBP DUMBM } {
RULECHECK OCOVL_3_${layer}_G {
@ Space between OCOVL to AA, Poly, SN, SP, CT, M1, LOGO, MARKS, MARKG, DUMBA, DUMBP, DUMBM outside of OCOVL	≥ 2um
OUTLAYER (EXT ($layer OUTSIDE OCOVL) OCOVL < 2 ABUT < 90 SINGULAR REGION) NOT MARKS
}
}




#//========================================================
#// Dummy pattern Check Rules for SMIC dummy
#//========================================================

GROUP GDUMC DUMC?_?

#//=========================
#// AA dummy check rules
#//=========================

GROUP GDUMCAA DUMC_AA_?

SETLAYER DUMAA = AADUM OR AADOP

RULECHECK DUMC_AA_01 {
@ (AADUM or AADOP) width.	≥	0.1um
OUTLAYER (INT DUMAA < 0.1 ABUT < 90 SINGULAR REGION) NOT MARKS
}

RULECHECK DUMC_AA_02 {
@ Space between AADUM and AADUM.	≥	0.19	um
OUTLAYER (EXT AADUM < 0.19 ABUT < 90 SINGULAR REGION) NOT MARKS
}

RULECHECK DUMC_AA_03 {
@ Space between AADUM and AADOP.	≥	0.2	um
OUTLAYER (EXT AADUM AADOP < 0.2 ABUT < 90 SINGULAR REGION) NOT MARKS
}

RULECHECK DUMC_AA_04 {
@ Space between AADUM and GTDUM.	≥	0.025	um
OUTLAYER (EXT AADUM GTDUM < 0.025 ABUT < 90 SINGULAR REGION) NOT MARKS
}

RULECHECK DUMC_AA_05 {
@ Space between AADUM and GTDOP.	≥	0.2	um
OUTLAYER (EXT AADUM GTDOP < 0.2 ABUT < 90 SINGULAR REGION) NOT MARKS
}

RULECHECK DUMC_AA_06 {
@ Space between AADOP and AADOP outside DG/TG	≥	0.13	um
SETLAYER X = AADOP OUTSIDE DG
OUTLAYER (EXT X AADOP < 0.13 ABUT < 90 SINGULAR REGION) NOT MARKS

SETLAYER X1 = AADOP OUTSIDE TG
OUTLAYER (EXT X1 AADOP < 0.13 ABUT < 90 SINGULAR REGION) NOT MARKS
}

RULECHECK DUMC_AA_07 {
@ Space between AADOP and AADOP not outside DG/TG	≥	0.15	um
SETLAYER X = AADOP NOT OUTSIDE DG
OUTLAYER (EXT X AADOP < 0.15 ABUT < 90 SINGULAR REGION) NOT MARKS

SETLAYER X1 = AADOP NOT OUTSIDE TG
OUTLAYER (EXT X1 AADOP < 0.15 ABUT < 90 SINGULAR REGION) NOT MARKS
}

RULECHECK DUMC_AA_08 {
@ Space between AADOP and GTDOP.	≥	0.025	um
OUTLAYER (EXT AADOP GTDOP < 0.025 ABUT < 90 SINGULAR REGION) NOT MARKS
}

RULECHECK DUMC_AA_09 {
@ Space between AADOP and GTDUM.	≥	0.2	um
OUTLAYER (EXT AADOP GTDUM < 0.2 ABUT < 90 SINGULAR REGION) NOT MARKS
}

RULECHECK DUMC_AA_10 {
@ (AADUM or AADOP) area (in um2).	≥	0.03	um2
OUTLAYER (AREA AADUM < 0.03) NOT MARKS
OUTLAYER (AREA AADOP < 0.03) NOT MARKS
}

foreach layer { AA GT AADMP GTDMP P2 GTFUSE DUMBA NODMF RESNW RESP1 MARKG MARKS INST 2PSRAM } {
RULECHECK DUMC_AA_11_$layer {
@ (AADUM or AADOP) must not interact (AA, Poly, AADMP, GTDMP, P2, GTFUSE, DUMBA, NODMF, RESNW, RESP1, MARKG, MARKS, INST, 2PSRAM) layers.
OUTLAYER DUMAA INTERACT $layer
}
}

foreach layer { DUMBA NODMF RESP1 MARKG MARKS INST 2PSRAM } {
RULECHECK DUMC_AA_12_$layer {
@ Space between (AADUM or AADOP) and (DUMBA, NODMF, RESP1, MARKG, MARKS, INST, 2PSRAM) layers.	≥	0.4	um
OUTLAYER EXT AADUM $layer < 0.4 ABUT < 90 SINGULAR REGION
OUTLAYER EXT AADOP $layer < 0.4 ABUT < 90 SINGULAR REGION
}
}

foreach layer { AA GT AADMP GTDMP } {
RULECHECK DUMC_AA_13_$layer {
@ Space between (AADUM or AADOP) and (AA, poly, AADMP, GTDMP).	≥	0.15	um
OUTLAYER (EXT AADUM $layer < 0.15 ABUT < 90 SINGULAR REGION) NOT MARKS
OUTLAYER (EXT AADOP $layer < 0.15 ABUT < 90 SINGULAR REGION) NOT MARKS
}
}

RULECHECK DUMC_AA_14 {
@ Space between (AADUM or AADOP) and GTFUSE.	≥	1	um
OUTLAYER (EXT AADUM GTFUSE < 1 ABUT < 90 SINGULAR REGION) NOT MARKS
OUTLAYER (EXT AADOP GTFUSE < 1 ABUT < 90 SINGULAR REGION) NOT MARKS
}

RULECHECK DUMC_AA_15 {
@ (AADUM or AADOP) overlap with CT is not allowed.
OUTLAYER (DUMAA AND CT) NOT MARKS
}

RULECHECK DUMC_AA_16 {
@ Space between (AADUM or AADOP) and SAB.	≥	0.22	um
OUTLAYER (EXT AADUM SAB < 0.22 ABUT < 90 SINGULAR REGION) NOT MARKS
OUTLAYER (EXT AADOP SAB < 0.22 ABUT < 90 SINGULAR REGION) NOT MARKS
}

RULECHECK DUMC_AA_17 {
@ (AADUM or AADOP) enclosed by SAB, (AADUM or AADOP) cut SAB is not permitted	≥	0.22	um
OUTLAYER (ENC AADUM SAB < 0.22 ABUT < 90 SINGULAR REGION) NOT MARKS
OUTLAYER (ENC AADOP SAB < 0.22 ABUT < 90 SINGULAR REGION) NOT MARKS
OUTLAYER (DUMAA CUT SAB) NOT MARKS
}

RULECHECK DUMC_AA_18 {
@ Space between (AADUM or AADOP) and P2	≥	0.04	um
OUTLAYER (EXT AADUM P2 < 0.04 ABUT < 90 SINGULAR REGION) NOT MARKS
OUTLAYER (EXT AADOP P2 < 0.04 ABUT < 90 SINGULAR REGION) NOT MARKS
}

RULECHECK DUMC_AA_19 {
@ Space between (AADUM or AADOP) and RESNW	≥	0.5	um
OUTLAYER (EXT AADUM RESNW < 0.5 ABUT < 90 SINGULAR REGION) NOT MARKS
OUTLAYER (EXT AADOP RESNW < 0.5 ABUT < 90 SINGULAR REGION) NOT MARKS
}

RULECHECK DUMC_AA_20 {
@ Space between AADUM and NW.	≥	0.16	um
OUTLAYER (EXT AADUM NW < 0.16 ABUT < 90 SINGULAR REGION) NOT MARKS
}

RULECHECK DUMC_AA_21 {
@ AADUM enclosed by NW, AADUM cut NW is not permitted.	≥	0.16	um
OUTLAYER (ENC AADUM NW < 0.16 ABUT < 90 SINGULAR REGION) NOT MARKS
OUTLAYER (AADUM CUT NW) NOT MARKS
}

RULECHECK DUMC_AA_22 {
@ Space between AADOP and NW.	≥	0.1	um
OUTLAYER (EXT AADOP NW < 0.1 ABUT < 90 SINGULAR REGION) NOT MARKS
}

RULECHECK DUMC_AA_23 {
@ AADOP enclosed by NW, AADOP cut NW is not permitted.	≥	0.1	um
OUTLAYER (ENC AADOP NW < 0.1 ABUT < 90 SINGULAR REGION) NOT MARKS
OUTLAYER (AADOP CUT NW) NOT MARKS
}

RULECHECK DUMC_AA_24 {
@ Space between 45-degree AA and (AADUM or AADOP).	≥	0.45	um
SETLAYER X = ANGLE AA >= 44.9 <= 45.1
OUTLAYER (EXT X AADUM < 0.45 ABUT < 90 REGION) NOT MARKS
OUTLAYER (EXT X AADOP < 0.45 ABUT < 90 REGION) NOT MARKS
}

RULECHECK DUMC_AA_25 {
@ Space between AADOP and PSUB.	≥	0.15	um
OUTLAYER (EXT AADOP PSUB < 0.15 ABUT < 90 SINGULAR REGION) NOT MARKS
}

RULECHECK DUMC_AA_26 {
@ Space between AADUM and DUMBA.	≥	0.6	um
OUTLAYER (EXT AADUM DUMBA < 0.6 ABUT < 90 SINGULAR REGION) NOT MARKS
}

RULECHECK DUMC_AA_27 {
@ Space between (AADUM or AADOP) and DG/TG.	≥	0.08	um
OUTLAYER (EXT AADUM DG < 0.08 ABUT < 90 SINGULAR REGION) NOT MARKS
OUTLAYER (EXT AADUM TG < 0.08 ABUT < 90 SINGULAR REGION) NOT MARKS

OUTLAYER (EXT AADOP DG < 0.08 ABUT < 90 SINGULAR REGION) NOT MARKS
OUTLAYER (EXT AADOP TG < 0.08 ABUT < 90 SINGULAR REGION) NOT MARKS
}

RULECHECK DUMC_AA_28 {
@ (AADUM or AADOP) enclosed by DG/TG, (AADUM or AADOP) cut DG/TG is not permitted.	≥	0.08	um
OUTLAYER (ENC AADUM DG < 0.08 ABUT < 90 SINGULAR REGION) NOT MARKS
OUTLAYER (ENC AADUM TG < 0.08 ABUT < 90 SINGULAR REGION) NOT MARKS
OUTLAYER (AADUM CUT DG) NOT MARKS
OUTLAYER (AADUM CUT TG) NOT MARKS

OUTLAYER (ENC AADOP DG < 0.08 ABUT < 90 SINGULAR REGION) NOT MARKS
OUTLAYER (ENC AADOP TG < 0.08 ABUT < 90 SINGULAR REGION) NOT MARKS
OUTLAYER (AADOP CUT DG) NOT MARKS
OUTLAYER (AADOP CUT TG) NOT MARKS
}

RULECHECK DUMC_AA_29 {
@ Space between (AADUM or AADOP) and SP.	≥	0.07	um
OUTLAYER (EXT AADUM SP < 0.07 ABUT < 90 SINGULAR REGION) NOT MARKS
OUTLAYER (EXT AADOP SP < 0.07 ABUT < 90 SINGULAR REGION) NOT MARKS
}

RULECHECK DUMC_AA_30 {
@ (AADUM or AADOP) enclosed by SP, (AADUM or AADOP) cut SP is not permitted.	≥	0.07	um
OUTLAYER (ENC AADUM SP < 0.07 ABUT < 90 SINGULAR REGION) NOT MARKS
OUTLAYER (ENC AADOP SP < 0.07 ABUT < 90 SINGULAR REGION) NOT MARKS
OUTLAYER (AADUM CUT SP) NOT MARKS
OUTLAYER (AADOP CUT SP) NOT MARKS
}

RULECHECK DUMC_AA_31 {
@ Space between (AADUM or AADOP) and INDMY.	≥	1.2	um
OUTLAYER (EXT AADUM INDMY < 1.2 ABUT < 90 SINGULAR REGION) NOT MARKS
OUTLAYER (EXT AADOP INDMY < 1.2 ABUT < 90 SINGULAR REGION) NOT MARKS
}

RULECHECK DUMC_AA_32 {
@ AADUM extension GTDUM	≥	0.095	um
OUTLAYER (ENC GTDUM AADUM < 0.095 ABUT < 90 SINGULAR REGION) NOT MARKS
}

RULECHECK DUMC_AA_33 {
@ AADOP extension GTDOP	≥	0.075	um
OUTLAYER (ENC GTDOP AADOP < 0.075 ABUT < 90 SINGULAR REGION) NOT MARKS
}

RULECHECK DUMC_AA_34 {
@ Space between (AADUM or AADOP) and (OCCDFH, OCCDFV, OCOVL) mark layer. ≥ 0.6um
OUTLAYER (EXT AADUM OCCDFH < 0.6 ABUT < 90 SINGULAR REGION) NOT MARKS
OUTLAYER (EXT AADOP OCCDFH < 0.6 ABUT < 90 SINGULAR REGION) NOT MARKS

OUTLAYER (EXT AADUM OCCDFV < 0.6 ABUT < 90 SINGULAR REGION) NOT MARKS
OUTLAYER (EXT AADOP OCCDFV < 0.6 ABUT < 90 SINGULAR REGION) NOT MARKS

OUTLAYER (EXT AADUM OCOVL < 0.6 ABUT < 90 SINGULAR REGION) NOT MARKS
OUTLAYER (EXT AADOP OCOVL < 0.6 ABUT < 90 SINGULAR REGION) NOT MARKS
}

RULECHECK DUMC_AA_35 {
@ Space between (AADUM or AADOP) and CT	≥	0.05	um
OUTLAYER (EXT AADUM CT < 0.05 ABUT < 90 SINGULAR REGION) NOT MARKS
OUTLAYER (EXT AADOP CT < 0.05 ABUT < 90 SINGULAR REGION) NOT MARKS
}





#//=========================
#// GT dummy check rules
#//=========================

GROUP GDUMCGT DUMC_GT_?

SETLAYER DUMGT = GTDUM OR GTDOP

RULECHECK DUMC_GT_01 {
@ (GTDUM or GTDOP) width.	≥	0.03	um
OUTLAYER (INT GTDUM < 0.03 ABUT < 90 SINGULAR REGION) NOT MARKS
OUTLAYER (INT GTDOP < 0.03 ABUT < 90 SINGULAR REGION) NOT MARKS
}

RULECHECK DUMC_GT_02 {
@ (GTDUM or GTDOP) length.	≥	0.3	um
OUTLAYER (NOT ENCLOSE RECTANGLE GTDUM 0.001 0.3 ORTHOGONAL ONLY) NOT MARKS
OUTLAYER (NOT ENCLOSE RECTANGLE GTDOP 0.001 0.3 ORTHOGONAL ONLY) NOT MARKS
}

RULECHECK DUMC_GT_03 {
@ Space between (GTDUM or GTDOP) and (GTDUM or GTDOP) if at least one (GTDUM or GTDOP) width ≥ 0.03um, and ≤0.09um, and the parallel run length >0.09um. ≥	0.1um
SETLAYER WIDE_DUMGT = DUMGT WITH WIDTH >= 0.03 <= 0.09
OUTLAYER ((EXT DUMGT WIDE_DUMGT < 0.1 OPPOSITE REGION) ENCLOSE RECTANGLE 0.001 0.091 ORTHOGONAL ONLY) NOT MARKS
}

RULECHECK DUMC_GT_04 {
@ Space between (GTDUM or GTDOP) and (GTDUM or GTDOP) if at least one (GTDUM or GTDOP) width > 0.09um, and the parallel run length >0.09um.	≥	0.12	um
SETLAYER WIDE_DUMGT = DUMGT WITH WIDTH > 0.09
SETLAYER TEMP = EXT DUMGT WIDE_DUMGT < 0.12 OPPOSITE REGION
OUTLAYER (TEMP WITH EDGE (LENGTH (TEMP COIN EDGE DUMGT) > 0.09)) NOT MARKS
}

RULECHECK DUMC_GT_05 {
@ Space between GTDOP and GTDOP.	≥	0.1	um
OUTLAYER (EXT GTDOP < 0.1 ABUT < 90 SINGULAR REGION) NOT MARKS
}

RULECHECK DUMC_GT_06 {
@ Space between GTDUM and GTDOP.	≥	0.2	um
OUTLAYER (EXT GTDUM GTDOP < 0.2 ABUT < 90 SINGULAR REGION) NOT MARKS
}

RULECHECK DUMC_GT_07 {
@ (GTDUM or GTDOP) area (in um2).	≥	0.0138	um2
OUTLAYER (AREA GTDUM < 0.0138) NOT MARKS
OUTLAYER (AREA GTDOP < 0.0138) NOT MARKS
}

foreach layer { AA GT AADMP GTDMP P2 GTFUSE SAB DUMBP NODMF RESAA RESNW MARKG MARKS INST 2PSRAM } {
RULECHECK DUMC_GT_08_$layer {
@ (GTDUM or GTDOP) must not interact (AA, Poly, AADMP, GTDMP, P2, GTFUSE, SAB, DUMBP, NODMF, RESAA, RESNW, MARKG, MARKS, INST, 2PSRAM) layers.
OUTLAYER DUMGT INTERACT $layer
}
}

foreach layer { DUMBP NODMF RESAA RESNW MARKG MARKS INST 2PSRAM } {	
RULECHECK DUMC_GT_09_$layer {
@ Space between (GTDUM or GTDOP) and (DUMBP, NODMF, RESAA, RESNW, MARKG, MARKS, INST, 2PSRAM) layers.	≥	0.4	um
OUTLAYER EXT GTDUM $layer < 0.4 ABUT < 90 SINGULAR REGION
OUTLAYER EXT GTDOP $layer < 0.4 ABUT < 90 SINGULAR REGION
}
}

foreach layer { AA GT AADMP GTDMP } {
RULECHECK DUMC_GT_10_$layer {
@ Space between (GTDUM or GTDOP) and (AA, poly, AADMP, GTDMP).	≥	0.15	um
OUTLAYER (EXT GTDUM $layer < 0.15 ABUT < 90 SINGULAR REGION) NOT MARKS
OUTLAYER (EXT GTDOP $layer < 0.15 ABUT < 90 SINGULAR REGION) NOT MARKS
}
}

RULECHECK DUMC_GT_11 {
@ Space between (GTDUM or GTDOP) and GTFUSE.	≥	1.30	um
OUTLAYER (EXT GTDUM GTFUSE < 1.3 ABUT < 90 SINGULAR REGION) NOT MARKS
OUTLAYER (EXT GTDOP GTFUSE < 1.3 ABUT < 90 SINGULAR REGION) NOT MARKS
}

RULECHECK DUMC_GT_12 {
@ Space between (AADUM or AADOP) and (GTDUM or GTDOP) on field oxide (On STI).	≥	0.025	um
OUTLAYER (EXT DUMGT DUMAA < 0.025 ABUT < 90 SINGULAR REGION) NOT MARKS
}

RULECHECK DUMC_GT_13 {
@ (GTDUM or GTDOP) overlap with CT is not allowed.
OUTLAYER (DUMGT AND CT) NOT MARKS
}
			
RULECHECK DUMC_GT_14 {
@ Space between (GTDUM or GTDOP) and SAB	≥	0.38	um
OUTLAYER (EXT GTDUM SAB < 0.38 ABUT < 90 SINGULAR REGION) NOT MARKS
OUTLAYER (EXT GTDOP SAB < 0.38 ABUT < 90 SINGULAR REGION) NOT MARKS
}

RULECHECK DUMC_GT_15 {
@ Space between GTDOP and P2	≥	0.04	um
OUTLAYER (EXT GTDOP P2 < 0.04 ABUT < 90 SINGULAR REGION) NOT MARKS
}

RULECHECK DUMC_GT_16 {
@ Space between GTDUM and P2.	≥	0.3	um
OUTLAYER (EXT GTDUM P2 < 0.3 ABUT < 90 SINGULAR REGION) NOT MARKS
}

RULECHECK DUMC_GT_17 {
@ Space between (GTDUM or GTDOP) and INDMY	≥	1.2	um
OUTLAYER (EXT GTDUM INDMY < 1.2 ABUT < 90 SINGULAR REGION) NOT MARKS
OUTLAYER (EXT GTDOP INDMY < 1.2 ABUT < 90 SINGULAR REGION) NOT MARKS
}

RULECHECK DUMC_GT_18 {
@ Space between (GTDUM or GTDOP) and CT	≥	0.08	um
OUTLAYER (EXT GTDUM CT < 0.08 ABUT < 90 SINGULAR REGION) NOT MARKS
OUTLAYER (EXT GTDOP CT < 0.08 ABUT < 90 SINGULAR REGION) NOT MARKS
}

RULECHECK DUMC_GT_19 {
@ Space between (GTDUM or GTDOP) and Poly_JOG	≥	0.17	um
OUTLAYER (EXT GTDUM POLY_JOG < 0.17 ABUT < 90 SINGULAR REGION) NOT MARKS
OUTLAYER (EXT GTDOP POLY_JOG < 0.17 ABUT < 90 SINGULAR REGION) NOT MARKS
}

RULECHECK DUMC_GT_20 {
@ GTDUM extension AADUM 	≥	0.085	um
OUTLAYER (ENC AADUM GTDUM < 0.085 ABUT < 90 SINGULAR REGION) NOT MARKS
}

RULECHECK DUMC_GT_21 {
@ GTDOP extension AADOP	≥	0.08	um
OUTLAYER (ENC AADOP GTDOP < 0.08 ABUT < 90 SINGULAR REGION) NOT MARKS
}

RULECHECK DUMC_GT_23 {
@ Space between (GTDUM or GTDOP) and (OCCDFH, OCCDFV, OCOVL) mark layer. ≥ 0.6um
OUTLAYER (EXT GTDUM OCCDFH < 0.6 ABUT < 90 SINGULAR REGION) NOT MARKS
OUTLAYER (EXT GTDOP OCCDFH < 0.6 ABUT < 90 SINGULAR REGION) NOT MARKS

OUTLAYER (EXT GTDUM OCCDFV < 0.6 ABUT < 90 SINGULAR REGION) NOT MARKS
OUTLAYER (EXT GTDOP OCCDFV < 0.6 ABUT < 90 SINGULAR REGION) NOT MARKS

OUTLAYER (EXT GTDUM OCOVL < 0.6 ABUT < 90 SINGULAR REGION) NOT MARKS
OUTLAYER (EXT GTDOP OCOVL < 0.6 ABUT < 90 SINGULAR REGION) NOT MARKS
}





#//=========================
#// P2 dummy check rules
#//=========================

GROUP GDUMCP2 DUMC_P2_?

SETLAYER DUMP2 = P2DUM OR P2DOP


RULECHECK DUMC_P2_01 {
@ P2DUM width.	≥	0.08	um
OUTLAYER (INT P2DUM < 0.08 ABUT < 90 SINGULAR REGION) NOT MARKS
}

RULECHECK DUMC_P2_02 {
@ P2DUM length.	≥	0.15	um
OUTLAYER (NOT ENCLOSE RECTANGLE P2DUM 0.001 0.15 ORTHOGONAL ONLY) NOT MARKS
}

RULECHECK DUMC_P2_03 {
@ Space between P2DUM and (P2, P2DUM).	≥	0.09	um
OUTLAYER (EXT P2DUM P2 < 0.09 ABUT < 90 SINGULAR REGION) NOT MARKS
OUTLAYER (EXT P2DUM < 0.09 ABUT < 90 SINGULAR REGION) NOT MARKS
}

RULECHECK DUMC_P2_04 {
@ Space between P2DUM and ((poly or GTDMP) or (GTDUM or GTDOP)). Overlap between P2DUM and ((poly or GTDMP) or (GTDUM or GTDOP)) is not allowed. ≥	0.04um
OUTLAYER (EXT P2DUM GT_all < 0.04 ABUT < 90 SINGULAR REGION) NOT MARKS
OUTLAYER (P2DUM AND GT_all) NOT MARKS
}

RULECHECK DUMC_P2_05 {
@ Space between P2DUM and ((AA or AADMP) or (AADUM or AADOP)) ≥0.035um. overlap between P2DUM and ((AA or AADMP) or (AADUM or AADOP)) is not allowed.
OUTLAYER (EXT P2DUM AA_all < 0.035 ABUT < 90 SINGULAR REGION) NOT MARKS
OUTLAYER (P2DUM AND AA_all) NOT MARKS
}

RULECHECK DUMC_P2_06 {
@ Space between P2DUM and CT (overlap is not allowed).	≥	0.02	um
OUTLAYER  (EXT P2DUM CT < 0.02 ABUT < 90 SINGULAR REGION) NOT MARKS
OUTLAYER  (P2DUM AND CT) NOT MARKS
}

RULECHECK DUMC_P2_07 {
@ Space between P2DUM and (DG or PSUB or TG).	≥	0.06	um
OUTLAYER  (EXT P2DUM DG < 0.06 ABUT < 90 SINGULAR REGION) NOT MARKS
OUTLAYER  (EXT P2DUM TG < 0.06 ABUT < 90 SINGULAR REGION) NOT MARKS
OUTLAYER  (EXT P2DUM PSUB < 0.06 ABUT < 90 SINGULAR REGION) NOT MARKS
}

foreach layer { AA GT GTDMP AADMP GTDUM AADUM GTDOP AADOP P2 DG PSUB TG } {
RULECHECK DUMC_P2_08_$layer {
@ P2DUM must not interact (AA, Poly, GTDMP, AADMP, GTDUM, AADUM, GTDOP, AADOP, P2, DG, PSUB, TG) layers.
OUTLAYER (P2DUM INTERACT $layer) NOT MARKS
}
}
			
RULECHECK DUMC_P2_09 {
@ Area of P2DUM.	≥	0.01	um2
OUTLAYER (AREA P2DUM < 0.01) NOT MARKS
}

RULECHECK DUMC_P2_10_l {
@ (P2 or P2DUM) full chip density	≥ 5% ≤ 12%
SETLAYER X = P2_all NOT MARKS
SETLAYER Y = DRC:1 NOT MARKS 
OUTLAYER DENSITY X Y \[AREA(X)/AREA(Y)\] < 0.05 PRINT density_report_DUMCP2_10_l.log RDB density_report_DUMCP2_10_l.rdb
}
RULECHECK DUMC_P2_10_h {
@ (P2 or P2DUM) full chip density	≥ 5% ≤ 12%
SETLAYER X = P2_all NOT MARKS
SETLAYER Y = DRC:1 NOT MARKS
OUTLAYER DENSITY X Y \[AREA(X)/AREA(Y)\]  > 0.12 PRINT density_report_DUMCP2_10_h.log RDB density_report_DUMCP2_10_h.rdb
}

RULECHECK DUMC_P2_11 {
@ Space between P2DUM and (OCCDFH, OCCDFV, OCOVL) mark layer. ≥ 0.6um
OUTLAYER (EXT P2DUM OCCDFH < 0.6 ABUT < 90 SINGULAR REGION) NOT MARKS
OUTLAYER (EXT P2DUM OCCDFV < 0.6 ABUT < 90 SINGULAR REGION) NOT MARKS
OUTLAYER (EXT P2DUM OCOVL < 0.6 ABUT < 90 SINGULAR REGION) NOT MARKS
}



#//=========================
#// M1 dummy check rules
#//=========================


GROUP GDUMCM1 DUMC_M1_?

SETLAYER DUMM1 = M1DUM OR M1DOP

RULECHECK DUMC_M1_01 {
@ (M1DUM or M1DOP) width.	≥	0.07	um
OUTLAYER (INT M1DUM < 0.07 ABUT < 90 SINGULAR REGION) NOT MARKS
OUTLAYER (INT M1DOP < 0.07 ABUT < 90 SINGULAR REGION) NOT MARKS
}

RULECHECK DUMC_M1_02 {
@ Space between two (M1DUM or M1DOP).	≥	0.08	um
OUTLAYER (EXT DUMM1 < 0.08 ABUT < 90 SINGULAR REGION) NOT MARKS
}

RULECHECK DUMC_M1_03 {
@ Dummy M1 area (um2).	≥	0.0238	 um2
OUTLAYER (AREA DUMM1 < 0.0238) NOT MARKS
}

RULECHECK DUMC_M1_04 {
@ Space between (M1DUM or M1DOP) and (M1, V1).	≥	0.16	um
OUTLAYER (EXT DUMM1 M1 < 0.16 ABUT < 90 SINGULAR REGION) NOT MARKS
OUTLAYER (EXT DUMM1 V1 < 0.16 ABUT < 90 SINGULAR REGION) NOT MARKS
}

RULECHECK DUMC_M1_05 {
@ (M1DUM or M1DOP) can not interact GTFUSE\; Space between dummy M1 and GTFUSE.	≥	1	um
OUTLAYER (DUMM1 INTERACT GTFUSE) NOT MARKS
OUTLAYER (EXT DUMM1 GTFUSE < 1 ABUT < 90 SINGULAR REGION) NOT MARKS
}

foreach layer { M1 V1 DUMBM NODMF M1DUB MARKG MARKS INST 2PSRAM OCCDB } {
RULECHECK DUMC_M1_06_$layer {
@ (M1DUM or M1DOP) must not interact (M1, V1,DUMBM, NODMF, M1DUB, MARKG, MARKS, INST, 2PSRAM, OCCDB) layers.
OUTLAYER DUMM1 INTERACT $layer
}
}

foreach layer {DUMBM NODMF M1DUB MARKG MARKS INST 2PSRAM OCCDB } {		
RULECHECK DUMC_M1_07_$layer {
@ Space between (M1DUM or M1DOP) and (DUMBM,NODMF, M1DUB, MARKG, MARKS, INST, 2PSRAM, OCCDB) layers.≥ 0.6um
OUTLAYER EXT DUMM1 $layer < 0.6 ABUT < 90 SINGULAR REGION
}
}




#//============================================
#// 1x Mn: 1x Metal (M2~ M8) dummy check rules
#//============================================

for { set j 2 } { $j <= 8 } { incr j } {

GROUP GDUMCM$j DUMC_M${j}_?


SETLAYER DUMM$j = M${j}DUM OR M${j}DOP

RULECHECK DUMC_M${j}_01 {
@ (MnDUM or MnDOP (n=2~8)) width.	≥	0.07	um
OUTLAYER (INT M${j}DUM < 0.07 ABUT < 90 SINGULAR REGION) NOT MARKS
OUTLAYER (INT M${j}DOP < 0.07 ABUT < 90 SINGULAR REGION) NOT MARKS
}

RULECHECK DUMC_M${j}_02 {
@ Space between two (MnDUM or MnDOP (n=2~8)).	≥	0.08	um
OUTLAYER (EXT DUMM$j < 0.08 ABUT < 90 SINGULAR REGION) NOT MARKS
}

RULECHECK DUMC_M${j}_03 {
@ (MnDUM or MnDOP (n=2~8)) area (um2).	≥	0.0238	um2
OUTLAYER (AREA M${j}DUM < 0.0238) NOT MARKS
OUTLAYER (AREA M${j}DOP < 0.0238) NOT MARKS
}

RULECHECK DUMC_M${j}_04 {
@ Space between (MnDUM or MnDOP (n=2~8)) and Mn ((M2~M8), Vn (n=2~7), Vn-1 (n=2~8)).	≥	0.16	um
OUTLAYER (EXT DUMM$j M${j}i < 0.16 ABUT < 90 SINGULAR REGION) NOT MARKS

  if { $j <= 7 } {
OUTLAYER (EXT DUMM$j V${j}i < 0.16 ABUT < 90 SINGULAR REGION) NOT MARKS
  }

OUTLAYER (EXT DUMM$j V[expr $j -1]i < 0.16 ABUT < 90 SINGULAR REGION) NOT MARKS
}
if { $j  >= 2 && $j <= 3 } {
RULECHECK DUMC_M${j}_05 {
@ (MnDUM or MnDOP (n=2,3)) can not interact GTFUSE\; Space between (MnDUM or MnDOP (n=2)) and GTFUSE.	≥	1	um
OUTLAYER (DUMM$j INTERACT GTFUSE) NOT MARKS
OUTLAYER (EXT DUMM$j GTFUSE < 1 ABUT < 90 SINGULAR REGION) NOT MARKS
}
}
RULECHECK DUMC_M${j}_06 {
@ (MnDUM or MnDOP (n=2~8)) must not interact (Mn (M2~M8), Vn (V2~V7), Vn-1 (n=2~8),DUMBM, NODMF, MnDUB (n=2~8), MARKG, MARKS, (INST, 2PSRAM, only for M2~M3), OCCDB) layers.
  if { $j  >= 2 && $j <= 3 } {
OUTLAYER DUMM$j INTERACT (INST OR 2PSRAM)
}
 
OUTLAYER DUMM$j INTERACT M${j}i

  if { $j <= 7 } {
OUTLAYER DUMM$j INTERACT V${j}i
  }

OUTLAYER DUMM$j INTERACT V[expr $j -1]i
OUTLAYER DUMM$j INTERACT DUMBM
OUTLAYER DUMM$j INTERACT OCCDB

OUTLAYER DUMM$j INTERACT NODMF
OUTLAYER DUMM$j INTERACT M${j}DUBi
OUTLAYER DUMM$j INTERACT MARKG
OUTLAYER DUMM$j INTERACT MARKS
}
			
RULECHECK DUMC_M${j}_07 {
@ Space between (MnDUM or MnDOP, n=2~8) and (NODMF, MnDUB (n=2~8), MARKG, MARKS, (INST, 2PSRAM, only for M2~M3), OCCDB,DUMBM) layers.≥ 0.6um
if { $j  >= 2 && $j <= 3 } {
OUTLAYER EXT DUMM$j INST < 0.6 ABUT < 90 SINGULAR REGION
OUTLAYER EXT DUMM$j 2PSRAM < 0.6 ABUT < 90 SINGULAR REGION
}
OUTLAYER EXT DUMM$j DUMBM < 0.6 ABUT < 90 SINGULAR REGION
OUTLAYER EXT DUMM$j NODMF < 0.6 ABUT < 90 SINGULAR REGION

OUTLAYER EXT DUMM$j M${j}DUBi < 0.6 ABUT < 90 SINGULAR REGION
OUTLAYER EXT DUMM$j MARKG < 0.6 ABUT < 90 SINGULAR REGION
OUTLAYER EXT DUMM$j MARKS < 0.6 ABUT < 90 SINGULAR REGION
OUTLAYER EXT DUMM$j OCCDB < 0.6 ABUT < 90 SINGULAR REGION
}
}



#//============================================
#// 2x Bn: 2x Metal (B1, B2) dummy check rules
#//============================================

for { set j 1 } { $j <= 2 } { incr j } {

GROUP GDUMCB$j DUMC_B${j}_?

SETLAYER DUMB$j = B${j}DUM OR B${j}DOP

RULECHECK DUMC_B${j}_01 {
@ Dummy Bn (B1DUM, B1DOP, B2DUM, B2DOP) width.	≥	0.20	um
OUTLAYER (INT B${j}DUM < 0.2 ABUT < 90 SINGULAR REGION) NOT MARKS
OUTLAYER (INT B${j}DOP < 0.2 ABUT < 90 SINGULAR REGION) NOT MARKS
}

RULECHECK DUMC_B${j}_02 {
@ Space between two dummy Bn (B1DUM, B1DOP, B2DUM, B2DOP).	≥	0.20	um
OUTLAYER (EXT DUMB$j < 0.2 ABUT < 90 SINGULAR REGION) NOT MARKS
}

RULECHECK DUMC_B${j}_03 {
@ Dummy Bn (B1DUM, B1DOP, B2DUM, B2DOP) area (um2).	≥	0.16	um2
OUTLAYER (AREA B${j}DUM < 0.16) NOT MARKS
OUTLAYER (AREA B${j}DOP < 0.16) NOT MARKS
}

RULECHECK DUMC_B${j}_04 {
@ Space between dummy Bn (B1DUM, B1DOP, B2DUM, B2DOP) and Bn (B1, B2) pattern.	≥	0.30	um
OUTLAYER (EXT B${j}DUM B${j}i < 0.3 ABUT < 90 SINGULAR REGION) NOT MARKS
OUTLAYER (EXT B${j}DOP B${j}i < 0.3 ABUT < 90 SINGULAR REGION) NOT MARKS
}

RULECHECK DUMC_B${j}_05 {
@ Dummy Bn (B1DUM, B1DOP, B2DUM, B2DOP) must not interact (Bn (B1, B2), BnDUB (B1DUB, B2DUB), DUMBM, NODMF, MARKG, MARKS) layers.
OUTLAYER DUMB$j INTERACT B${j}i
OUTLAYER DUMB$j INTERACT B${j}DUBi
OUTLAYER DUMB$j INTERACT DUMBM
OUTLAYER DUMB$j INTERACT NODMF
OUTLAYER DUMB$j INTERACT MARKG
OUTLAYER DUMB$j INTERACT MARKS
}
			
RULECHECK DUMC_B${j}_06 {
@ Space between dummy Bn (B1DUM, B1DOP, B2DUM, and B2DOP) and (BnDUB (B1DUB, B2DUB), DUMBM, NODMF) layers.	≥	0.50	um
OUTLAYER (EXT DUMB$j B${j}DUBi < 0.5 ABUT < 90 SINGULAR REGION) NOT MARKS
OUTLAYER (EXT DUMB$j DUMBM < 0.5 ABUT < 90 SINGULAR REGION) NOT MARKS 
OUTLAYER (EXT DUMB$j NODMF < 0.5 ABUT < 90 SINGULAR REGION) NOT MARKS
}

RULECHECK DUMC_B${j}_07 {
@ Space between dummy Bn (B1DUM, B1DOP, B2DUM, and B2DOP) and (MARKG, MARKS) layers.	≥	1.00	um
OUTLAYER EXT DUMB$j MARKG < 1 ABUT < 90 SINGULAR REGION
OUTLAYER EXT DUMB$j MARKS < 1 ABUT < 90 SINGULAR REGION
}
}




#//===============================================
#// 8x TMn: 8x Metal (TM1, TM2) dummy check rules
#//===============================================

for { set j 1 } { $j <= 2 } { incr j } {

GROUP GDUMCTM$j DUMC_TM${j}_?

RULECHECK DUMC_TM${j}_1 {
@ Dummy TMn (TM1, TM2) width.	≥	0.75um
OUTLAYER (INT TM${j}DUM < 0.75 ABUT < 90 SINGULAR REGION) NOT MARKS 
}

RULECHECK DUMC_TM${j}_2 {
@ Space between two dummy TMn (TM1, TM2).	≥	0.75	um
OUTLAYER (EXT TM${j}DUM < 0.75 ABUT < 90 SINGULAR REGION) NOT MARKS
}

RULECHECK DUMC_TM${j}_3 {
@ Dummy TMn (TM1, TM2) area (um2).	≥	1.5	um2
OUTLAYER (AREA TM${j}DUM < 1.5) NOT MARKS
}

RULECHECK DUMC_TM${j}_4 {
@ Space between dummy TMn (TM1, TM2) and TMn (TM1, TM2) pattern.	≥	0.75	um
OUTLAYER (EXT TM${j}DUM TM${j}i < 0.75 ABUT < 90 SINGULAR REGION) NOT MARKS
}

RULECHECK DUMC_TM${j}_5 {
@ Dummy TMn (TM1, TM2) must not interact (TMn (TM1, TM2), TVn (TV1, TV2), DUMBM, NODMF, TMnDUB (n=1, 2), MARKG, MARKS) layers.
OUTLAYER TM${j}DUM INTERACT TM${j}i
OUTLAYER TM${j}DUM INTERACT TV${j}i

  if { $j == 1 } {
OUTLAYER TM${j}DUM INTERACT TV[expr $j +1]i
  }

OUTLAYER TM${j}DUM INTERACT DUMBM
OUTLAYER TM${j}DUM INTERACT NODMF
OUTLAYER TM${j}DUM INTERACT TM${j}DUB
OUTLAYER TM${j}DUM INTERACT MARKG
OUTLAYER TM${j}DUM INTERACT MARKS
}
		
RULECHECK DUMC_TM${j}_6 {
@ Space between dummy TMn (TM1, TM2) and (DUMBM, NODMF, TMnDUB (n=1, 2), MARKG, MARKS) layers.	≥	0.7	um
OUTLAYER EXT TM${j}DUM DUMBM < 0.7 ABUT < 90 SINGULAR REGION
OUTLAYER EXT TM${j}DUM NODMF < 0.7 ABUT < 90 SINGULAR REGION
OUTLAYER EXT TM${j}DUM TM${j}DUB < 0.7 ABUT < 90 SINGULAR REGION
OUTLAYER EXT TM${j}DUM MARKG < 0.7 ABUT < 90 SINGULAR REGION
OUTLAYER EXT TM${j}DUM MARKS < 0.7 ABUT < 90 SINGULAR REGION
}
}




#//=========================================================
#// 10x STMn: 10x Metal (STM1, STM2) dummy check rules
#//=========================================================

for { set j 1 } { $j <= 2 } { incr j } {

GROUP GDUMCSTM$j DUMC_STM${j}_?

RULECHECK DUMC_STM${j}_01 {
@ Dummy STMn (STM1DM, STM2DM) width.	≥	0.75	um
OUTLAYER (INT STM${j}DM < 0.75 ABUT < 90 SINGULAR REGION) NOT MARKS 
}

RULECHECK DUMC_STM${j}_02 {
@ Space between two dummy STMn (STM1DM, STM2DM).	≥	0.75	um
OUTLAYER (EXT STM${j}DM < 0.75 ABUT < 90 SINGULAR REGION) NOT MARKS
}

RULECHECK DUMC_STM${j}_03 {
@ Dummy STMn (STM1DM, STM2DM) area (um2).	≥	1.5	um2
OUTLAYER (AREA STM${j}DM < 1.5) NOT MARKS
}

RULECHECK DUMC_STM${j}_04 {
@ Space between dummy STMn (STM1DM, STM2DM) and STMn (STM1DM, STM2DM) pattern.	≥	0.75	um
OUTLAYER (EXT STM${j}DM STM${j}i < 0.75 ABUT < 90 SINGULAR REGION) NOT MARKS
}

RULECHECK DUMC_STM${j}_05 {
@ Dummy STMn (STM1DM, STM2DM) must not interact (STMn (STM1, STM2), STVn (STV1, STV2), DUMBM, NODMF, STMnDB (n=1, 2), MARKG, MARKS) layers.
OUTLAYER STM${j}DM INTERACT STM${j}i
OUTLAYER STM${j}DM INTERACT STV${j}i

  if { $j == 1 } {
OUTLAYER STM${j}DM INTERACT STV[expr $j +1]i
  }

OUTLAYER STM${j}DM INTERACT DUMBM
OUTLAYER STM${j}DM INTERACT NODMF
OUTLAYER STM${j}DM INTERACT STM${j}DB
OUTLAYER STM${j}DM INTERACT MARKG
OUTLAYER STM${j}DM INTERACT MARKS
}
			
RULECHECK DUMC_STM${j}_06 {
@ Space between dummy STMn (STM1DM, STM2DM) and (DUMBM, NODMF, STMnDB (n=1, 2), MARKG, MARKS) layers.	≥	0.7	um
OUTLAYER EXT STM${j}DM DUMBM < 0.7 ABUT < 90 SINGULAR REGION
OUTLAYER EXT STM${j}DM NODMF < 0.7 ABUT < 90 SINGULAR REGION
OUTLAYER EXT STM${j}DM STM${j}DB < 0.7 ABUT < 90 SINGULAR REGION
OUTLAYER EXT STM${j}DM MARKG < 0.7 ABUT < 90 SINGULAR REGION
OUTLAYER EXT STM${j}DM MARKS < 0.7 ABUT < 90 SINGULAR REGION
}
}




#//=========================================================
#// V1 dummy check rules
#//=========================================================

GROUP DUMCV1 DUMC_V1_?

RULECHECK DUMC_V1_01 {
@ V1DUM exact width (square shape).	=	0.05	um
OUTLAYER (NOT RECTANGLE V1DUM == 0.05 BY == 0.05) NOT MARKS
}

RULECHECK DUMC_V1_02 {
@ Space between two V1DUM.	≥	0.35	um
OUTLAYER (EXT V1DUM < 0.35 ABUT < 90 SINGULAR REGION) NOT MARKS
}

RULECHECK DUMC_V1_03 {
@ Enclosure by M1DUM\; overlap with M1DOP is not permitted\; and must be fully cover by M1DUM.	≥	0.055	um
OUTLAYER (ENC V1DUM M1DUM < 0.055 ABUT < 90 SINGULAR REGION OUTSIDE ALSO) NOT MARKS
OUTLAYER (V1DUM AND M1DOP) NOT MARKS
}

RULECHECK DUMC_V1_04 {
@ Enclosure by M2DUM\; overlap with M2DOP is not permitted\; and must be fully cover by M2DUM.	≥	0.055	um
OUTLAYER (ENC V1DUM M2DUM < 0.055 ABUT < 90 SINGULAR REGION OUTSIDE ALSO) NOT MARKS
OUTLAYER (V1DUM AND M2DOP) NOT MARKS
}

RULECHECK DUMC_V1_05 {
@ V1DUM must not interact (V1, M1, M2, V1DUB, MARKG, MARKS, NODMF, DUMBM, INDMY, OCCDBDB) layers.
OUTLAYER V1DUM INTERACT V1i
OUTLAYER V1DUM INTERACT M1i
OUTLAYER  V1DUM INTERACT M2i
OUTLAYER  V1DUM INTERACT V1DUB
OUTLAYER  V1DUM INTERACT MARKG
OUTLAYER  V1DUM INTERACT MARKS
OUTLAYER  V1DUM INTERACT NODMF
OUTLAYER  V1DUM INTERACT DUMBM
OUTLAYER  V1DUM INTERACT INDMY
OUTLAYER  V1DUM INTERACT OCCDBDB
}			




#//=========================================================
#// 1x Vn: 1x Via (V2~ V7) dummy check rules
#//=========================================================

for { set j 2 } { $j <= 7 } { incr j } {

GROUP DUMCV$j DUMC_1XV${j}_?

RULECHECK DUMC_1XV${j}_01 {
@ VnDUM (n=2~7) exact width (square shape).	=	0.05	um
OUTLAYER (NOT RECTANGLE V${j}DUM == 0.05 BY == 0.05) NOT MARKS
}

RULECHECK DUMC_1XV${j}_02 {
@ Space between two VnDUM (n=2~7).	≥	0.35	um
OUTLAYER (EXT V${j}DUM < 0.35 ABUT < 90 SINGULAR REGION) NOT MARKS
}

RULECHECK DUMC_1XV${j}_03 {
@ Enclosure by MnDUM (n=2~7) and MnDUM (n=2~7) is the metal layer directly underneath VnDUM (n=2~7)\; overlap with MnDOP (n=2~7) is not permitted;
@ and must be fully cover by MnDUM (n=2~7).	≥	0.055	um
OUTLAYER (ENC V${j}DUM M${j}DUM < 0.055 ABUT < 90 SINGULAR REGION OUTSIDE ALSO) NOT MARKS
OUTLAYER (V${j}DUM AND M${j}DOP) NOT MARKS
}

RULECHECK DUMC_1XV${j}_04 {
@ Enclosure by MnDUM (n=3~8) and MnDUM (n=3~8) is the metal layer directly above VnDUM (n=2~7)\; overlap with MnDOP (n=2~7) is not permitted;
@ and must be fully cover by MnDUM (n=3~8).	≥	0.055	um
OUTLAYER (ENC V${j}DUM M[expr $j +1]DUM < 0.055 ABUT < 90 SINGULAR REGION OUTSIDE ALSO) NOT MARKS
OUTLAYER (V${j}DUM AND M[expr $j +1]DOP) NOT MARKS
}

RULECHECK DUMC_1XV${j}_05 {
@ VnDUM (n=2~7) must not interact (1x Vn, 1x Mn, 1x Mn+1, VnDUB (n=2~7), MARKG, MARKS, NODMF, DUMBM, OCCDBDB, INDMY) layers.
OUTLAYER V${j}DUM INTERACT V${j}i
OUTLAYER V${j}DUM INTERACT M${j}i
OUTLAYER V${j}DUM INTERACT M[expr $j +1]i
OUTLAYER V${j}DUM INTERACT V${j}DUB
OUTLAYER V${j}DUM INTERACT MARKG
OUTLAYER V${j}DUM INTERACT MARKS
OUTLAYER V${j}DUM INTERACT NODMF
OUTLAYER V${j}DUM INTERACT DUMBM
OUTLAYER V${j}DUM INTERACT INDMY
OUTLAYER V${j}DUM INTERACT OCCDBDB
}
}			




#//=========================================================
#// MTT2 dummy check rules
#//=========================================================

GROUP DUMCMTT2 DUMC_MTT2_?

RULECHECK DUMC_MTT2_01 {
@ MTT2DM width.	≥	3.6	um
OUTLAYER (INT MTT2DM < 3.6 ABUT < 90 SINGULAR REGION) NOT MARKS
}

RULECHECK DUMC_MTT2_02 {
@ Space between MTT2DM and MTT2DM.	≥	1.78	um
OUTLAYER (EXT MTT2DM < 1.78 ABUT < 90 SINGULAR REGION) NOT MARKS
}

RULECHECK DUMC_MTT2_03 {
@ MTT2DM must not interact (MTT2, DUMBM, NODMF, MTT2DB, MARKG, MARKS) layers.
OUTLAYER MTT2DM INTERACT MTT2i
OUTLAYER MTT2DM INTERACT DUMBM
OUTLAYER MTT2DM INTERACT NODMF
OUTLAYER MTT2DM INTERACT MTT2DB
OUTLAYER MTT2DM INTERACT MARKG
OUTLAYER MTT2DM INTERACT MARKS
}

RULECHECK DUMC_MTT2_04 {
@ Space between d MTT2DM and (MTT2, DUMBM NODMF MTT2DB, MARKG, MARKS) layers.	≥ 1.78um
OUTLAYER EXT MTT2DM MTT2i < 1.78 ABUT < 90 SINGULAR REGION
OUTLAYER EXT MTT2DM DUMBM < 1.78 ABUT < 90 SINGULAR REGION
OUTLAYER EXT MTT2DM NODMF < 1.78 ABUT < 90 SINGULAR REGION
OUTLAYER EXT MTT2DM MTT2DB < 1.78 ABUT < 90 SINGULAR REGION
OUTLAYER EXT MTT2DM MARKG < 1.78 ABUT < 90 SINGULAR REGION
OUTLAYER EXT MTT2DM MARKS < 1.78 ABUT < 90 SINGULAR REGION
}



#//=========================================================
#// ALPA dummy check rules
#//=========================================================

GROUP GDUMCALPA DUMC_ALPA_?

RULECHECK DUMC_ALPA_01 {
@ ALDUM width.	≥	7	um
OUTLAYER (INT ALDUM < 7 ABUT < 90 SINGULAR REGION) NOT MARKS
}

RULECHECK DUMC_ALPA_02 {
@ Space between ALDUM and ALDUM.	≥	3.6	um
OUTLAYER (EXT ALDUM < 3.6 ABUT < 90 SINGULAR REGION) NOT MARKS
}

RULECHECK DUMC_ALPA_03 {
@ ALDUM must not interact (ALPA, DUMBM, NODMF, ALDUB, MARKG, MARKS) layers.
OUTLAYER  ALDUM INTERACT ALPA
OUTLAYER  ALDUM INTERACT DUMBM
OUTLAYER  ALDUM INTERACT NODMF
OUTLAYER  ALDUM INTERACT ALDUB
OUTLAYER  ALDUM INTERACT MARKG
OUTLAYER  ALDUM INTERACT MARKS
}

RULECHECK DUMC_ALPA_04 {
@ Space between ALDUM and (ALPA, DUMBM, NODMF ALDUB, MARKG, MARKS,) layers.	≥	2.85	um
OUTLAYER EXT ALDUM ALPA < 2.85 ABUT < 90 SINGULAR REGION
OUTLAYER EXT ALDUM DUMBM < 2.85 ABUT < 90 SINGULAR REGION
OUTLAYER EXT ALDUM NODMF < 2.85 ABUT < 90 SINGULAR REGION
OUTLAYER EXT ALDUM ALDUB < 2.85 ABUT < 90 SINGULAR REGION
OUTLAYER EXT ALDUM MARKG < 2.85 ABUT < 90 SINGULAR REGION
OUTLAYER EXT ALDUM MARKS < 2.85 ABUT < 90 SINGULAR REGION
}


#Vaild metal option setting control
set combinations {
{5 0 1 0 0}
{6 1 1 0 0}
{7 2 1 0 0}
{6 0 2 0 0}
{7 1 2 0 0}
{8 2 2 0 0}
{6 0 1 0 0}
{7 1 1 0 0}
{8 2 1 0 0}
{7 0 2 0 0}
{8 1 2 0 0}
{9 2 2 0 0}
{7 0 1 0 0}
{8 1 1 0 0}
{9 2 1 0 0}
{8 0 2 0 0}
{9 1 2 0 0}
{10 2 2 0 0}
{8 0 1 0 0}
{9 1 1 0 0}
{10 2 1 0 0}
{9 0 2 0 0}
{10 1 2 0 0}
{11 2 2 0 0}
{9 0 1 0 0}
{10 1 1 0 0}
{11 2 1 0 0}
{10 0 2 0 0}
{11 1 2 0 0}
{12 2 2 0 0}
{5 0 0 1 0}
{6 1 0 1 0}
{7 2 0 1 0}
{6 0 0 2 0}
{7 1 0 2 0}
{8 2 0 2 0}
{6 0 0 1 0}
{7 1 0 1 0}
{8 2 0 1 0}
{7 0 0 2 0}
{8 1 0 2 0}
{9 2 0 2 0}
{7 0 0 1 0}
{8 1 0 1 0}
{9 2 0 1 0}
{8 0 0 2 0}
{9 1 0 2 0}
{10 2 0 2 0}
{8 0 0 1 0}
{9 1 0 1 0}
{10 2 0 1 0}
{9 0 0 2 0}
{10 1 0 2 0}
{11 2 0 2 0}
{9 0 0 1 0}
{10 1 0 1 0}
{11 2 0 1 0}
{10 0 0 2 0}
{11 1 0 2 0}
{12 2 0 2 0}
{5 0 0 0 1}
{6 0 0 0 1}
{7 0 0 0 1}
{8 0 0 0 1}
{9 0 0 0 1}
{6 0 1 0 1}
{7 0 1 0 1}
{8 0 1 0 1}
{9 0 1 0 1}
{10 0 1 0 1}
{8 1 1 0 1}
}
if { [lsearch -start 0 -all -inline $combinations "$total_metal_counts $2X_metal_counts $8X_top_metal_counts $10X_top_metal_counts $MTT2_top_metal_counts"] eq "" } {
  puts "\nWrong metal option combination. Please check the setting for metal options.\n"
  exit
}

