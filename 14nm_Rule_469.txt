//FIN
Q: FIN must be an orthogonal rectangle
A: 
FIN_R_1 {
@ FIN must be an orthogonal rectangle
 err1 = NOT RECTANGLE FIN ORTHOGONAL ONLY
 err1 NOT INSIDE SealR_NOT_BULK

 err2 = INT FIN < 0.001 ABUT<90 SINGULAR REGION
 err2 NOT INSIDE SealR_NOT_BULK
}

Q: FIN must inside CELLB, except INST region
A: 
FIN_R_2 {
@ FIN must inside CELLB, except INST region
 err1 = FIN_ouT_SRAM NOT CELLB
 err1 NOT INSIDE INST
}

//CELLB

Q: ALL_AA must be fully covered by CELLB, except DMCMK1, INST and MARKS regions
A: 
CELLB_R_1 {
@ ALL_AA must be fully covered by CELLB, except DMCMK1, INST and MARKS regions
 err1 = ((ALL_AA NOT CELLB) NOT INSIDE DMCMK1) NOT INSIDE MARKS_INST
 err1 NOT INSIDE SealR_NOT_BULK
}

Q: CELLB interact with INST is not allowed
A: 
CELLB_R_2 {
@ CELLB interact with INST is not allowed
 err1 = CELLB NOT OUTSIDE EDGE INST
 err2 = INST NOT OUTSIDE EDGE CELLB
 err1 NOT INSIDE EDGE SealR_NOT_BULK
 err2 NOT INSIDE EDGE SealR_NOT_BULK
}

Q: CELLB edge must be orthogonal to grid, and 45-degree bent CELLB is not allowed
A: 
CELLB_R_3 {
@ CELLB edge must be orthogonal to grid, and 45-degree bent CELLB is not allowed
 err1 = ANGLE CELLB > 0 < 90
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

//AA

Q: ALL_AA must be fully covered by (SN OR SP), except DMCMK1 and MARKS regions
A: 
AA_R_1 {
@ ALL_AA must be fully covered by (SN OR SP), except DMCMK1 and MARKS regions
 err1 = ALL_AA NOT ALL_SN_SP
 err1 NOT INSIDE DMCMK1_MARKS
}

Q: NPAA in chip design is not allowed
A: 
AA_R_2 {
@ NPAA in chip design is not allowed
 err1 = NPAA INTERACT DRC:1
 err1 NOT INSIDE SealR_NOT_BULK
}

Q: DOP_AA overlap AA, GT is not allowed
A: 
AA_R_3 {
@ DOP_AA overlap AA, GT is not allowed
 err1 = DOP_AA AND AA_OR_GT
 err1 NOT INSIDE SealR_NOT_BULK
}

Q: AA must be orthogonal to grid (Single Z-shape AA is not allowed)
A: 
AA_R_5 {
@ AA must be orthogonal to grid (Single Z-shape AA is not allowed)
 err1 = ANGLE AA > 0 < 90
 err1 NOT INSIDE EDGE SealR_NOT_BULK

 single_z_shape_TMP = ((AA VERTEX == 8) WITH EDGE AA_convex_90_90_edge == 4) WITH EDGE AA_convex_90_270_edge == 4
 single_z_shape_TOP = (ANGLE AA_convex_90_270_edge == 0) TOUCH EDGE (((GROW single_z_shape_TMP TOP BY 0.0001) NOT AA) WITH EDGE AA_convex_90_270_edge == 2)
 single_z_shape_BOTTOM = (ANGLE AA_convex_90_270_edge == 0) TOUCH EDGE (((GROW single_z_shape_TMP BOTTOM BY 0.0001) NOT AA) WITH EDGE AA_convex_90_270_edge == 2)
 err2 = (single_z_shape_TMP WITH EDGE single_z_shape_TOP) WITH EDGE single_z_shape_BOTTOM
 err2 NOT INSIDE SealR_NOT_BULK
}

Q: AA interact with GT (width >= 0.032um) must be rectangular
A: 
AA_R_6 {
@ AA interact with GT (width >= 0.032um) must be rectangular
 err1 = NOT RECTANGLE (AA INTERACT GT_eqgt_032) ORTHOGONAL ONLY
 err1 NOT INSIDE SealR_NOT_BULK
}

Q: DUM_AA must be rectangle
A: 
AA_R_7 {
@ DUM_AA must be rectangle
 err1 = NOT RECTANGLE DUM_AA ORTHOGONAL ONLY
 err1 NOT INSIDE SealR_NOT_BULK
}

//AR

Q: AR vertical edge must align with GT, except small GT jog <= 0.004um, except OCOVL region
A: 
AR_R_1 {
@ AR vertical edge must align with GT, except small GT jog <= 0.004um, except OCOVL region
//; WAIVE_AREA = OR EDGE (ENC GT [AR_v_edges] <= 0.004 OPPOSITE) (ENC [AR_v_edges] GT <= 0.004 OPPOSITE)
 err1 = AR_v_edges NOT TOUCH INSIDE EDGE GT  //;) NOT COIN EDGE WAIVE_AREA
 err1 NOT INSIDE EDGE OCOVL
}

Q: M0G overlap ((GT NOT P2) INTERACT AR) is not allowed
A: 
AR_R_2 {
@ M0G overlap ((GT NOT P2) INTERACT AR) is not allowed
 err1 = (GT_0 INTERACT AR) AND M0G
 err1 NOT INSIDE SealR_NOT_BULK
}

Q: AR must inside CELLB, except OCOVL region
A: 
AR_R_3 {
@ AR must inside CELLB, except OCOVL region
 err1 = AR NOT CELLB
 err1 NOT INSIDE OCOVL
}

Q: AR interact pick-up AA, DSTR, DMCMK1, DG or INST is not allowed
A: 
AR_R_4 {
@ AR interact pick-up AA, DSTR, DMCMK1, DG or INST is not allowed
 err1 = AR INTERACT (OR TAP_RAW DSTR DMCMK1 DG INST)
 err1 NOT INSIDE SealR_NOT_BULK
}

Q: AR must be vertical rectangle
A: 
AR_R_5 {
@ AR must be vertical rectangle
 err1 = AR NOT RECTANGLE ORTHOGONAL ONLY
 err2 = INT AR_h_edges <= 0.02 ABUT<90 OPPOSITE REGION //;based on AR.W.1
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

Q: Maximum delta V > 1.15V between two S/D active beside AR is not allowed
A: 
AR_R_6 {
@ Maximum delta V > 1.15V between two S/D active beside AR is not allowed
 err1_TMP = DFM DV (AA_c INTERACT AR) < AR_MaxiWidth_PLUS DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" > 1.15 ANNOTATE NOT CONNECTED SINGULAR
 err1 = (DFM COPY err1_TMP REGION) AND AR
 err1 NOT INSIDE SealR_NOT_BULK
}

Q: AR must overlap AOP_GT, except OCOVL region
A: 
AR_R_7 {
@ AR must overlap AOP_GT, except OCOVL region
 err1 = AR NOT INTERACT (AR AND AOP_GT)
 err1 NOT INSIDE OCOVL
}

//DNW

Q: N+AA cut DNW is not allowed
A: 
DNW_R_1 {
@ N+AA cut DNW is not allowed
 err1 = DNW INSIDE EDGE NACT
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

Q: Floating NW hole in DNW is not recommended to avoid unstable device performance
A: 
DNW_R_2_NC {
@ Floating NW hole in DNW is not recommended to avoid unstable device performance
 err1 = HOLES_NW AND DNW
 err2 = HOLES_NW_INNER AND DNW
 err1 NOT INSIDE MARKS
 err2 NOT INSIDE MARKS
}

VARIABLE DNW_R_3_val 5

Q: Maximum delta V >= 5.6V is not allowed, when:
    1. Space between DNW and DNW/NW is < 5um
    2. Space between RW and RW/PW is < 5um
A: 
DNW_R_3_DNW_2_DNW {
@ Maximum delta V >= 5.6V is not allowed, when:
@ 1. Space between DNW and DNW/NW is < 5um
@ 2. Space between RW and RW/PW is < 5um
 err1 = DFM DV DNW < DNW_R_3_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" >= 5.6 ANNOTATE NOT CONNECTED SINGULAR
 DFM COPY err1
}

Q: Maximum delta V >= 5.6V is not allowed, when:
    1. Space between DNW and DNW/NW is < 5um
    2. Space between RW and RW/PW is < 5um
A: 
DNW_R_3_DNW_2_NW {
@ Maximum delta V >= 5.6V is not allowed, when:
@ 1. Space between DNW and DNW/NW is < 5um
@ 2. Space between RW and RW/PW is < 5um
 err1 = DFM DV DNW NW < DNW_R_3_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" >= 5.6 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err1
}

Q: Maximum delta V >= 5.6V is not allowed, when:
    1. Space between DNW and DNW/NW is < 5um
    2. Space between RW and RW/PW is < 5um
A: 
DNW_R_3_RW_2_RW {
@ Maximum delta V >= 5.6V is not allowed, when:
@ 1. Space between DNW and DNW/NW is < 5um
@ 2. Space between RW and RW/PW is < 5um
 err1 = DFM DV RW < DNW_R_3_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" >= 5.6 ANNOTATE NOT CONNECTED SINGULAR
 DFM COPY err1
}

Q: Maximum delta V >= 5.6V is not allowed, when:
    1. Space between DNW and DNW/NW is < 5um
    2. Space between RW and RW/PW is < 5um
A: 
DNW_R_3_RW_2_PW {
@ Maximum delta V >= 5.6V is not allowed, when:
@ 1. Space between DNW and DNW/NW is < 5um
@ 2. Space between RW and RW/PW is < 5um
 err1 = DFM DV PW_0 RW < DNW_R_3_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" >= 5.6 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err1
}


//NW

Q: Maximum delta V >= 5.6V is not allowed, When:
    1. Space between NWs is < 1.8um
    2. Space between NW and N+AA/P+ pick-up AA is < 1.65um
    3. Space between PW and P+AA/N+ pick-up AA is < 1.65um
A: 
NW_R_2_NW_2_NW {
@ Maximum delta V >= 5.6V is not allowed, When:
@ 1. Space between NWs is < 1.8um
@ 2. Space between NW and N+AA/P+ pick-up AA is < 1.65um
@ 3. Space between PW and P+AA/N+ pick-up AA is < 1.65um
 err1 = DFM DV NW < NW_R_2_NW_2_NW_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" >= 5.6 ANNOTATE NOT CONNECTED SINGULAR
 DFM COPY err1
}

Q: Maximum delta V >= 5.6V is not allowed, When:
    1. Space between NWs is < 1.8um
    2. Space between NW and N+AA/P+ pick-up AA is < 1.65um
    3. Space between PW and P+AA/N+ pick-up AA is < 1.65um
A: 
NW_R_2_NW_2_pickup {
@ Maximum delta V >= 5.6V is not allowed, When:
@ 1. Space between NWs is < 1.8um
@ 2. Space between NW and N+AA/P+ pick-up AA is < 1.65um
@ 3. Space between PW and P+AA/N+ pick-up AA is < 1.65um
 err1 = DFM DV NSD NW < NW_R_2_NW_2_pickup_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" >= 5.6 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 err2 = DFM DV PTAP NW < NW_R_2_NW_2_pickup_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" >= 5.6 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err1 err2
}

Q: Maximum delta V >= 5.6V is not allowed, When:
    1. Space between NWs is < 1.8um
    2. Space between NW and N+AA/P+ pick-up AA is < 1.65um
    3. Space between PW and P+AA/N+ pick-up AA is < 1.65um
A: 
NW_R_2_PW_2_pickup {
@ Maximum delta V >= 5.6V is not allowed, When:
@ 1. Space between NWs is < 1.8um
@ 2. Space between NW and N+AA/P+ pick-up AA is < 1.65um
@ 3. Space between PW and P+AA/N+ pick-up AA is < 1.65um
 err1 = DFM DV NTAP PW_0 < NW_R_2_PW_2_pickup_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" >= 5.6 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 err2 = DFM DV PSD PW_0 < NW_R_2_PW_2_pickup_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" >= 5.6 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err1 err2
}


//PSUB

Q: PSUB overlap (NW OR DNW) is not allowed
A: 
PSUB_R_1 {
@ PSUB overlap (NW OR DNW) is not allowed
 err1 = PSUB AND (NW OR DNW)
 err1 NOT INSIDE SealR_NOT_BULK
}

Q: PSUB overlap (GATE NOT GTMK2) is not allowed, except ESD region
A: 
PSUB_R_2 {
@ PSUB overlap (GATE NOT GTMK2) is not allowed, except ESD region
 err1 = (PSUB AND (GATE NOT GTMK2)) NOT INSIDE ESDIO_all
 err1 NOT INSIDE SealR_NOT_BULK
}

Q: AA cut PSUB is not allowed
A: 
PSUB_R_3 {
@ AA cut PSUB is not allowed
 err1 = PSUB INSIDE EDGE AA
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

//SVT_N

Q: (ALL_AA interact GT (width >= 0.032um)) CUT SVT_N is not allowed
A: 
SVT_N_R_1 {
@ (ALL_AA interact GT (width >= 0.032um)) CUT SVT_N is not allowed
 err1 = ALL_AA_INTERACT_GT_eqgt_032 CUT SVT_N
 err1 NOT INSIDE SealR_NOT_BULK
}

Q: SVT_N overlap with P+AA, SVT_P, HVT_N, HVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, DG, PSUB, INST, RESNW, VARMOS, DMPNP, MARKS is not allowed, exclude OCCD region
A: 
SVT_N_R_2 {
@ SVT_N overlap with P+AA, SVT_P, HVT_N, HVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, DG, PSUB, INST, RESNW, VARMOS, DMPNP, MARKS is not allowed, exclude OCCD region
 err1 = SVT_N AND (OR PACT SVT_P HVT_N HVT_P LVT_N LVT_P LFN_N LFN_P ULVT_N ULVT_P DG PSUB INST RESNW VARMOS DMPNP MARKS)
 err1 NOT INSIDE OCCD
}

Q: (ALL_AA NOT AR) straddle on SVT_N horizontal edge is not allowed
A: 
SVT_N_R_3 {
@ (ALL_AA NOT AR) straddle on SVT_N horizontal edge is not allowed
 err1 = SVT_N_h_edges COIN EDGE ((SVT_N CUT ALL_AA_NOT_AR) INSIDE EDGE ALL_AA_NOT_AR)
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

Q: Vertical edge of (SVT_N, LVT_N, ULVT_N, HVT_N, LFN_N) abut (SVT_P, LVT_P, ULVT_P, HVT_P, LFN_P) interact GT is not allowed
A: 
SVT_N_R_4 {
@ Vertical edge of (SVT_N, LVT_N, ULVT_N, HVT_N, LFN_N) abut (SVT_P, LVT_P, ULVT_P, HVT_P, LFN_P) interact GT is not allowed
 chk_EDGE = ANGLE (ALL_VT_N_IMP COIN EDGE ALL_VT_P_IMP) == 90
 err1 = chk_EDGE NOT OUTSIDE EDGE GT
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

Q: (SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, HVT_N, HVT_P, LFN_N, LFN_P) overlap with MARKS is not allowed
A: 
SVT_N_R_5 {
@ (SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, HVT_N, HVT_P, LFN_N, LFN_P) overlap with MARKS is not allowed
 err1 = ALL_VT_IMP AND MARKS
 err1 NOT INSIDE SealR_NOT_BULK
}

Q:  ((GT NOT P2) NOT INTERACT (GTMK1 OR AR) (channel length <= 0.024um)) straddle on vertical edge of SVT_N, SVT_P, LVT_N, LVT_P, HVT_N, HVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P is not allowed
A: 
SVT_N_R_6 {
@ ((GT NOT P2) NOT INTERACT (GTMK1 OR AR) (channel length <= 0.024um)) straddle on vertical edge of SVT_N, SVT_P, LVT_N, LVT_P, HVT_N, HVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P is not allowed
 chk_GT = WITH WIDTH (GT_0 NOT INTERACT gtmk1_or_ar) <= 0.024
 err1 = SVT_N_v_edges INSIDE EDGE chk_GT
 err2 = SVT_P_v_edges INSIDE EDGE chk_GT
 err3 = LVT_N_v_edges INSIDE EDGE chk_GT
 err4 = LVT_P_v_edges INSIDE EDGE chk_GT
 err5 = HVT_N_v_edges INSIDE EDGE chk_GT
 err6 = HVT_P_v_edges INSIDE EDGE chk_GT
 err7 = LFN_N_v_edges INSIDE EDGE chk_GT
 err8 = LFN_P_v_edges INSIDE EDGE chk_GT
 err9 = ULVT_N_v_edges INSIDE EDGE chk_GT
 err0 = ULVT_P_v_edges INSIDE EDGE chk_GT

 err1 NOT INSIDE EDGE SealR_NOT_BULK
 err2 NOT INSIDE EDGE SealR_NOT_BULK
 err3 NOT INSIDE EDGE SealR_NOT_BULK
 err4 NOT INSIDE EDGE SealR_NOT_BULK
 err5 NOT INSIDE EDGE SealR_NOT_BULK
 err6 NOT INSIDE EDGE SealR_NOT_BULK
 err7 NOT INSIDE EDGE SealR_NOT_BULK
 err8 NOT INSIDE EDGE SealR_NOT_BULK
 err9 NOT INSIDE EDGE SealR_NOT_BULK
 err0 NOT INSIDE EDGE SealR_NOT_BULK
}
 
Q: (DUM_GT NOT P2) CUT SVT_N, SVT_P, HVT_N, HVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N or LFN_P is not allowed
A: 
SVT_N_R_7_SVT_N {
@ (DUM_GT NOT P2) CUT SVT_N, SVT_P, HVT_N, HVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N or LFN_P is not allowed
 err1_TMP = DUM_GT_NOT_P2 CUT SVT_N
 err1 = SVT_N INSIDE EDGE err1_TMP
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
Q: (DUM_GT NOT P2) CUT SVT_N, SVT_P, HVT_N, HVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N or LFN_P is not allowed
A: 
SVT_N_R_7_SVT_P {
@ (DUM_GT NOT P2) CUT SVT_N, SVT_P, HVT_N, HVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N or LFN_P is not allowed
 err1_TMP = DUM_GT_NOT_P2 CUT SVT_P
 err1 = SVT_P INSIDE EDGE err1_TMP
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
Q: (DUM_GT NOT P2) CUT SVT_N, SVT_P, HVT_N, HVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N or LFN_P is not allowed
A: 
SVT_N_R_7_HVT_N {
@ (DUM_GT NOT P2) CUT SVT_N, SVT_P, HVT_N, HVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N or LFN_P is not allowed
 err1_TMP = DUM_GT_NOT_P2 CUT HVT_N
 err1 = HVT_N INSIDE EDGE err1_TMP
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
Q: (DUM_GT NOT P2) CUT SVT_N, SVT_P, HVT_N, HVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N or LFN_P is not allowed
A:
SVT_N_R_7_HVT_P {
@ (DUM_GT NOT P2) CUT SVT_N, SVT_P, HVT_N, HVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N or LFN_P is not allowed
 err1_TMP = DUM_GT_NOT_P2 CUT HVT_P
 err1 = HVT_P INSIDE EDGE err1_TMP
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
Q: (DUM_GT NOT P2) CUT SVT_N, SVT_P, HVT_N, HVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N or LFN_P is not allowed
A: 
SVT_N_R_7_LVT_N {
@ (DUM_GT NOT P2) CUT SVT_N, SVT_P, HVT_N, HVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N or LFN_P is not allowed
 err1_TMP = DUM_GT_NOT_P2 CUT LVT_N
 err1 = LVT_N INSIDE EDGE err1_TMP
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
Q: (DUM_GT NOT P2) CUT SVT_N, SVT_P, HVT_N, HVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N or LFN_P is not allowed
A: 
SVT_N_R_7_LVT_P {
@ (DUM_GT NOT P2) CUT SVT_N, SVT_P, HVT_N, HVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N or LFN_P is not allowed
 err1_TMP = DUM_GT_NOT_P2 CUT LVT_P
 err1 = LVT_P INSIDE EDGE err1_TMP
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
Q: (DUM_GT NOT P2) CUT SVT_N, SVT_P, HVT_N, HVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N or LFN_P is not allowed
A: 
SVT_N_R_7_ULVT_N {
@ (DUM_GT NOT P2) CUT SVT_N, SVT_P, HVT_N, HVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N or LFN_P is not allowed
 err1_TMP = DUM_GT_NOT_P2 CUT ULVT_N
 err1 = ULVT_N INSIDE EDGE err1_TMP
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
Q: (DUM_GT NOT P2) CUT SVT_N, SVT_P, HVT_N, HVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N or LFN_P is not allowed
A: 
SVT_N_R_7_ULVT_P {
@ (DUM_GT NOT P2) CUT SVT_N, SVT_P, HVT_N, HVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N or LFN_P is not allowed
 err1_TMP = DUM_GT_NOT_P2 CUT ULVT_P
 err1 = ULVT_P INSIDE EDGE err1_TMP
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
Q: (DUM_GT NOT P2) CUT SVT_N, SVT_P, HVT_N, HVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N or LFN_P is not allowed
A: 
SVT_N_R_7_LFN_N {
@ (DUM_GT NOT P2) CUT SVT_N, SVT_P, HVT_N, HVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N or LFN_P is not allowed
 err1_TMP = DUM_GT_NOT_P2 CUT LFN_N
 err1 = LFN_N INSIDE EDGE err1_TMP
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
Q: (DUM_GT NOT P2) CUT SVT_N, SVT_P, HVT_N, HVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N or LFN_P is not allowed
A: 
SVT_N_R_7_LFN_P {
@ (DUM_GT NOT P2) CUT SVT_N, SVT_P, HVT_N, HVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N or LFN_P is not allowed
 err1_TMP = DUM_GT_NOT_P2 CUT LFN_P
 err1 = LFN_P INSIDE EDGE err1_TMP
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

Q: ALL_GT must be covered by (SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, HVT_N, HVT_P, LFN_N, LFN_P), except INST, DSTR, DMPNP, VARMOS, DG, RESNW, RESP1, DMCMK1, MARKS, OCCD, OCOVL, RESP3t region for 3t resistor bulk region
A: 
SVT_N_R_8 {
@ ALL_GT must be covered by (SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, HVT_N, HVT_P, LFN_N, LFN_P), except INST, DSTR, DMPNP, VARMOS, DG, RESNW, RESP1, DMCMK1, MARKS, OCCD, OCOVL, RESP3t region for 3t resistor bulk region
 except_area = OR INST DSTR DMPNP VARMOS DG_RESNW RESP1 MARKS_DMCMK1 ALL_GT_NWR OCCD OCOVL RESP3T
 err1 = (ALL_GT NOT except_area) NOT ALL_VT_IMP
 err1 NOT INSIDE SealR_NOT_BULK
}

Q: ACTIVE must be covered by (SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, HVT_N, HVT_P, LFN_N, LFN_P), except INST DSTR, DMPNP, VARMOS, DG, RESNW, DMCMK1, MARKS, OCCD regions
A: 
SVT_N_R_9 {
@ ACTIVE must be covered by (SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, HVT_N, HVT_P, LFN_N, LFN_P), except INST DSTR, DMPNP, VARMOS, DG, RESNW, DMCMK1, MARKS, OCCD regions
 except_area = OR INST DSTR DMPNP VARMOS DG_RESNW MARKS_DMCMK1 (AA INTERACT AA_NWR) OCCD
 err1 = (ACT NOT except_area) NOT ALL_VT_IMP
 err1 NOT INSIDE SealR_NOT_BULK
}

Q: ALL_AA CUT (SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, HVT_N, HVT_P, LFN_N, LFN_P) horizontal edge is not allowed
A: 
SVT_N_R_10 {
@ ALL_AA CUT (SVT_N, SVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, HVT_N, HVT_P, LFN_N, LFN_P) horizontal edge is not allowed
 err1 = OR (EXPAND EDGE (SVT_N_h_edges INSIDE EDGE ALL_AA) INSIDE BY 0.001) (EXPAND EDGE (SVT_P_h_edges INSIDE EDGE ALL_AA) INSIDE BY 0.001)
 err2 = OR (EXPAND EDGE (LVT_N_h_edges INSIDE EDGE ALL_AA) INSIDE BY 0.001) (EXPAND EDGE (LVT_P_h_edges INSIDE EDGE ALL_AA) INSIDE BY 0.001)
 err3 = OR (EXPAND EDGE (ULVT_N_h_edges INSIDE EDGE ALL_AA) INSIDE BY 0.001) (EXPAND EDGE (ULVT_P_h_edges INSIDE EDGE ALL_AA) INSIDE BY 0.001)
 err4 = OR (EXPAND EDGE (HVT_N_h_edges INSIDE EDGE ALL_AA) INSIDE BY 0.001) (EXPAND EDGE (HVT_P_h_edges INSIDE EDGE ALL_AA) INSIDE BY 0.001)
 err5 = OR (EXPAND EDGE (LFN_N_h_edges INSIDE EDGE ALL_AA) INSIDE BY 0.001) (EXPAND EDGE (LFN_P_h_edges INSIDE EDGE ALL_AA) INSIDE BY 0.001)
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
 err4 NOT INSIDE SealR_NOT_BULK
 err5 NOT INSIDE SealR_NOT_BULK
}



//SVT_P

Q: (ALL_AA interact GT (width >= 0.032um)) CUT SVT_P is not allowed
A: 
SVT_P_R_1 {
@ (ALL_AA interact GT (width >= 0.032um)) CUT SVT_P is not allowed
 err1 = ALL_AA_INTERACT_GT_eqgt_032 CUT SVT_P
 err1 NOT INSIDE SealR_NOT_BULK
}

Q: SVT_P overlap with N+AA, SVT_N, HVT_N, HVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, DG, PSUB, INST, RESNW, VARMOS, DMPNP, MARKS is not allowed, exclude OCCD region
A: 
SVT_P_R_2 {
@ SVT_P overlap with N+AA, SVT_N, HVT_N, HVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, DG, PSUB, INST, RESNW, VARMOS, DMPNP, MARKS is not allowed, exclude OCCD region
 err1 = SVT_P AND (OR NACT SVT_N HVT_N HVT_P LVT_N LVT_P ULVT_N ULVT_P LFN_N LFN_P DG PSUB INST RESNW VARMOS DMPNP MARKS)
 err1 NOT INSIDE OCCD
}

Q: (ALL_AA NOT AR) straddle on SVT_P horizontal edge is not allowed
A: 
SVT_P_R_3 {
@ (ALL_AA NOT AR) straddle on SVT_P horizontal edge is not allowed
 err1 = SVT_P_h_edges COIN EDGE ((SVT_P CUT ALL_AA_NOT_AR) INSIDE EDGE ALL_AA_NOT_AR)
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}


//HVT_N

Q: (ALL_AA interact GT (width >= 0.032um)) CUT HVT_N is not allowed
A: 
HVT_N_R_1 {
@ (ALL_AA interact GT (width >= 0.032um)) CUT HVT_N is not allowed
 err1 = ALL_AA_INTERACT_GT_eqgt_032 CUT HVT_N
 err1 NOT INSIDE SealR_NOT_BULK
}

Q: HVT_N overlap with P+AA, SVT_N, SVT_P, HVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, DG, PSUB, INST, RESNW, VARMOS, DMPNP, MARKS is not allowed, exclude OCCD region
A: 
HVT_N_R_2 {
@ HVT_N overlap with P+AA, SVT_N, SVT_P, HVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, DG, PSUB, INST, RESNW, VARMOS, DMPNP, MARKS is not allowed, exclude OCCD region
 err1 = HVT_N AND (OR PACT SVT_N SVT_P HVT_P LVT_N LVT_P ULVT_N ULVT_P LFN_N LFN_P DG PSUB INST RESNW VARMOS DMPNP MARKS)
 err1 NOT INSIDE OCCD
}

Q: (ALL_AA NOT AR) straddle on HVT_N horizontal edge is not allowed
A: 
HVT_N_R_3 {
@ (ALL_AA NOT AR) straddle on HVT_N horizontal edge is not allowed
 err1 = HVT_N_h_edges COIN EDGE ((HVT_N CUT ALL_AA_NOT_AR) INSIDE EDGE ALL_AA_NOT_AR)
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

//HVT_P

Q: (ALL_AA interact GT (width >= 0.032um)) CUT HVT_P is not allowed
A: 
HVT_P_R_1 {
@ (ALL_AA interact GT (width >= 0.032um)) CUT HVT_P is not allowed
 err1 = ALL_AA_INTERACT_GT_eqgt_032 CUT HVT_P
 err1 NOT INSIDE SealR_NOT_BULK
}

Q: HVT_P overlap with N+AA, SVT_N, SVT_P, HVT_N, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, DG, PSUB, INST, RESNW, VARMOS, DMPNP, MARKS is not allowed, exclude OCCD region
A: 
HVT_P_R_2 {
@ HVT_P overlap with N+AA, SVT_N, SVT_P, HVT_N, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, DG, PSUB, INST, RESNW, VARMOS, DMPNP, MARKS is not allowed, exclude OCCD region
 err1 = HVT_P AND (OR NACT SVT_N SVT_P HVT_N LVT_N LVT_P ULVT_N ULVT_P LFN_N LFN_P DG PSUB INST RESNW VARMOS DMPNP MARKS)
 err1 NOT INSIDE OCCD
}

Q: (ALL_AA NOT AR) straddle on HVT_P horizontal edge is not allowed
A: 
HVT_P_R_3 {
@ (ALL_AA NOT AR) straddle on HVT_P horizontal edge is not allowed
 err1 = HVT_P_h_edges COIN EDGE ((HVT_P CUT ALL_AA_NOT_AR) INSIDE EDGE ALL_AA_NOT_AR)
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}


//LVT_N

Q: (ALL_AA interact GT (width >= 0.032um)) CUT LVT_N is not allowed
A: 
LVT_N_R_1 {
@ (ALL_AA interact GT (width >= 0.032um)) CUT LVT_N is not allowed
 err1 = ALL_AA_INTERACT_GT_eqgt_032 CUT LVT_N
 err1 NOT INSIDE SealR_NOT_BULK
}

Q: LVT_N overlap with P+AA, SVT_N, SVT_P, HVT_N, HVT_P, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, DG, PSUB, INST, RESNW, VARMOS, DMPNP, MARKS is not allowed, exclude OCCD region
A: 
LVT_N_R_2 {
@ LVT_N overlap with P+AA, SVT_N, SVT_P, HVT_N, HVT_P, LVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, DG, PSUB, INST, RESNW, VARMOS, DMPNP, MARKS is not allowed, exclude OCCD region
 err1 = LVT_N AND (OR PACT SVT_N SVT_P HVT_N HVT_P LVT_P LFN_N LFN_P ULVT_N ULVT_P DG PSUB INST RESNW VARMOS DMPNP MARKS)
 err1 NOT INSIDE OCCD
}

Q: (ALL_AA NOT AR) straddle on LVT_P horizontal edge is not allowed
A: 
LVT_N_R_3 {
@ (ALL_AA NOT AR) straddle on LVT_P horizontal edge is not allowed
 err1 = LVT_N_h_edges COIN EDGE ((LVT_N CUT ALL_AA_NOT_AR) INSIDE EDGE ALL_AA_NOT_AR)
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}


//LVT_P

Q: (ALL_AA interact GT (width >= 0.032um)) CUT LVT_P is not allowed
A: 
LVT_P_R_1 {
@ (ALL_AA interact GT (width >= 0.032um)) CUT LVT_P is not allowed
 err1 = ALL_AA_INTERACT_GT_eqgt_032 CUT LVT_P
 err1 NOT INSIDE SealR_NOT_BULK
}

Q: LVT_P overlap with N+AA, SVT_N, SVT_P, HVT_N, HVT_P, LVT_N, ULVT_N, ULVT_P, LFN_N, LFN_P, DG, PSUB, INST, RESNW, VARMOS, DMPNP, MARKS is not allowed, exclude OCCD region
A: 
LVT_P_R_2 {
@ LVT_P overlap with N+AA, SVT_N, SVT_P, HVT_N, HVT_P, LVT_N, ULVT_N, ULVT_P, LFN_N, LFN_P, DG, PSUB, INST, RESNW, VARMOS, DMPNP, MARKS is not allowed, exclude OCCD region
 err1 = LVT_P AND (OR NACT SVT_N SVT_P HVT_N HVT_P LVT_N ULVT_N ULVT_P LFN_N LFN_P DG PSUB INST RESNW VARMOS DMPNP MARKS)
 err1 NOT INSIDE OCCD
}

Q: (ALL_AA NOT AR) straddle on LVT_P horizontal edge is not allowed
A: 
LVT_P_R_3 {
@ (ALL_AA NOT AR) straddle on LVT_P horizontal edge is not allowed
 err1 = LVT_P_h_edges COIN EDGE ((LVT_P CUT ALL_AA_NOT_AR) INSIDE EDGE ALL_AA_NOT_AR)
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}


//ULVT_N


Q: (ALL_AA interact GT (width >= 0.032um)) CUT ULVT_N is not allowed
A: 
ULVT_N_R_1 {
@ (ALL_AA interact GT (width >= 0.032um)) CUT ULVT_N is not allowed
 err1 = ALL_AA_INTERACT_GT_eqgt_032 CUT ULVT_N
 err1 NOT INSIDE SealR_NOT_BULK
}

Q: ULVT_N overlap with P+AA, SVT_N, SVT_P, HVT_N, HVT_P, LVT_N, LVT_P, ULVT_P, LFN_N, LFN_P, DG, PSUB, INST, RESNW, VARMOS, DMPNP, MARKS is not allowed, exclude OCCD region
A: 
ULVT_N_R_2 {
@ ULVT_N overlap with P+AA, SVT_N, SVT_P, HVT_N, HVT_P, LVT_N, LVT_P, ULVT_P, LFN_N, LFN_P, DG, PSUB, INST, RESNW, VARMOS, DMPNP, MARKS is not allowed, exclude OCCD region
 err1 = ULVT_N AND (OR PACT SVT_N SVT_P HVT_N HVT_P LVT_P LVT_N ULVT_P LFN_N LFN_P DG PSUB INST RESNW VARMOS DMPNP MARKS)
 err1 NOT INSIDE OCCD
}

Q: (ALL_AA NOT AR) straddle on ULVT_N horizontal edge is not allowed
A: 
ULVT_N_R_3 {
@ (ALL_AA NOT AR) straddle on ULVT_N horizontal edge is not allowed
 err1 = ULVT_N_h_edges COIN EDGE ((ULVT_N CUT ALL_AA_NOT_AR) INSIDE EDGE ALL_AA_NOT_AR)
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

//ULVT_P

Q: (ALL_AA interact GT (width >= 0.032um)) CUT ULVT_P is not allowed
A:
ULVT_P_R_1 {
@ (ALL_AA interact GT (width >= 0.032um)) CUT ULVT_P is not allowed
 err1 = ALL_AA_INTERACT_GT_eqgt_032 CUT ULVT_P
 err1 NOT INSIDE SealR_NOT_BULK
}

Q: ULVT_P overlap with N+AA, SVT_N, SVT_P, HVT_N, HVT_P, LVT_N, LVT_P, ULVT_N, LFN_N, LFN_P, DG, PSUB, INST, RESNW, VARMOS, DMPNP, MARKS is not allowed, exclude OCCD region
A: 
ULVT_P_R_2 {
@ ULVT_P overlap with N+AA, SVT_N, SVT_P, HVT_N, HVT_P, LVT_N, LVT_P, ULVT_N, LFN_N, LFN_P, DG, PSUB, INST, RESNW, VARMOS, DMPNP, MARKS is not allowed, exclude OCCD region
 err1 = ULVT_P AND (OR NACT SVT_N SVT_P HVT_N HVT_P ULVT_N LVT_N LVT_P LFN_N LFN_P DG PSUB INST RESNW VARMOS DMPNP MARKS)
 err1 NOT INSIDE OCCD
}

Q: (ALL_AA NOT AR) straddle on ULVT_P horizontal edge is not allowed
A: 
ULVT_P_R_3 {
@ (ALL_AA NOT AR) straddle on ULVT_P horizontal edge is not allowed
 err1 = ULVT_P_h_edges COIN EDGE ((ULVT_P CUT ALL_AA_NOT_AR) INSIDE EDGE ALL_AA_NOT_AR)
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}


//LFN_N

Q: (ALL_AA interact GT (width >= 0.032um)) CUT LFN_N is not allowed
A: 
LFN_N_R_1 {
@ (ALL_AA interact GT (width >= 0.032um)) CUT LFN_N is not allowed
 err1 = ALL_AA_INTERACT_GT_eqgt_032 CUT LFN_N
 err1 NOT INSIDE SealR_NOT_BULK
}

Q: LFN_N overlap with P+AA, SVT_N, SVT_P, HVT_N, HVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_P, DG, PSUB, INST, RESNW, VARMOS, DMPNP, MARKS is not allowed, exclude OCCD region
A: 
LFN_N_R_2 {
@ LFN_N overlap with P+AA, SVT_N, SVT_P, HVT_N, HVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_P, DG, PSUB, INST, RESNW, VARMOS, DMPNP, MARKS is not allowed, exclude OCCD region
 err1 = LFN_N AND (OR PACT SVT_N SVT_P HVT_N HVT_P LVT_N LVT_P ULVT_N ULVT_P LFN_P DG PSUB INST RESNW VARMOS DMPNP MARKS)
 err1 NOT INSIDE OCCD
}

Q: (ALL_AA NOT AR) straddle on LFN_N horizontal edge is not allowed
A: 
LFN_N_R_3 {
@ (ALL_AA NOT AR) straddle on LFN_N horizontal edge is not allowed
 err1 = LFN_N_h_edges COIN EDGE ((LFN_N CUT ALL_AA_NOT_AR) INSIDE EDGE ALL_AA_NOT_AR)
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}


//LFN_P

Q: (ALL_AA interact GT (width >= 0.032um)) CUT LFN_P is not allowed
A: 
LFN_P_R_1 {
@ (ALL_AA interact GT (width >= 0.032um)) CUT LFN_P is not allowed
 err1 = ALL_AA_INTERACT_GT_eqgt_032 CUT LFN_P
 err1 NOT INSIDE SealR_NOT_BULK
}

Q: LFN_P overlap with N+AA, SVT_N, SVT_P, HVT_N, HVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, DG, PSUB, INST, RESNW, VARMOS, DMPNP, MARKS is not allowed, exclude OCCD region
A: 
LFN_P_R_2 {
@ LFN_P overlap with N+AA, SVT_N, SVT_P, HVT_N, HVT_P, LVT_N, LVT_P, ULVT_N, ULVT_P, LFN_N, DG, PSUB, INST, RESNW, VARMOS, DMPNP, MARKS is not allowed, exclude OCCD region
 err1 = LFN_P AND (OR NACT SVT_N SVT_P HVT_N HVT_P LVT_N LVT_P ULVT_N ULVT_P LFN_N DG PSUB INST RESNW VARMOS DMPNP MARKS)
 err1 NOT INSIDE OCCD
}

Q: (ALL_AA NOT AR) straddle on LFN_P horizontal edge is not allowed
A: 
LFN_P_R_3 {
@ (ALL_AA NOT AR) straddle on LFN_P horizontal edge is not allowed
 err1 = LFN_P_h_edges COIN EDGE ((LFN_P CUT ALL_AA_NOT_AR) INSIDE EDGE ALL_AA_NOT_AR)
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}


//DG

Q: 1.8V, 1.2V and 1.5V GATE cannot inside the same NW
A: 
DG_R_1 {
@ 1.8V, 1.2V and 1.5V GATE cannot inside the same NW
 nw_18v_gate = NW INTERACT GATE_18
 nw_12v_gate = NW INTERACT GATE_12
 nw_15v_gate = NW INTERACT GATE_15

 err1 = AND nw_18v_gate nw_12v_gate
 err2 = AND nw_18v_gate nw_15v_gate
 err3 = AND nw_12v_gate nw_15v_gate
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
}

Q: (GATE AND DGUD), (GATE AND DGV) must inside DG
A: 
DG_R_2 {
@ (GATE AND DGUD), (GATE AND DGV) must inside DG
 err1 = (GATE AND DGUD) NOT DG
 err2 = (GATE AND DGV) NOT DG
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

Q: GATE cut DG, DGUD or DGV is not allowed
A: 
DG_R_3 {
@ GATE cut DG, DGUD or DGV is not allowed
 err1 = GATE CUT DG
 err2 = GATE CUT DGUD
 err3 = GATE CUT DGV
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
}

Q: AOP_GT CUT DGV is not allowed
A: 
DG_R_4 {
@ AOP_GT CUT DGV is not allowed
 err1 = DGV INSIDE EDGE (AOP_GT CUT DGV)
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

Q: DGUD overlap DGV is not allowed
A: 
DG_R_5 {
@ DGUD overlap DGV is not allowed
 err1 = DGUD AND DGV
 err1 NOT INSIDE SealR_NOT_BULK
}

Q: (DGV or DGUD) overlap VARMOS is not allowed
A: 
DG_R_6 {
@ (DGV or DGUD) overlap VARMOS is not allowed
 err1 = DGV AND VARMOS
 err2 = DGUD AND VARMOS
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}


//GT

Q: ALL_GT (width >= 0.032um) must be a rectangle orthogonal to grid, except MARKS and LOGO regions
A: 
GT_R_1 {
@ ALL_GT (width >= 0.032um) must be a rectangle orthogonal to grid, except MARKS and LOGO regions
 chk_ALL_GT = ALL_GT INTERACT ALL_GT_eqgt_032
 err1 = (chk_ALL_GT NOT INSIDE MARKS_LOGO) NOT RECTANGLE ORTHOGONAL ONLY
 err1 NOT INSIDE MARKS_LOGO
}

Q: ALL_GT (width < 0.032um) must be a rectangle orthogonal to grid, except small jogs <= 0.004um
A: 
GT_R_2 {
@ ALL_GT (width < 0.032um) must be a rectangle orthogonal to grid, except small jogs <= 0.004um
 chk_ALL_GT = ALL_GT_lt_032 NOT COIN EDGE (LENGTH ALL_GT_convex_equal_one_edge <= 0.004)  //;redundant
 err1 = ANGLE chk_ALL_GT > 0 < 90
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

Q: O-shape GT is not allowed, except LOGO region
A:
GT_R_3 {
@ O-shape GT is not allowed, except LOGO region
 err1 = (DONUT GT) NOT INSIDE LOGO
 err1 NOT INSIDE SealR_NOT_BULK
}

Q: AOP_GT (width < 0.032um) interact AOP_GT (width >= 0.032um) is not allowed
A: 
GT_R_4 {
@ AOP_GT (width < 0.032um) interact AOP_GT (width >= 0.032um) is not allowed
 err1 = AOP_GT_lt_032 INTERACT AOP_GT_eqgt_032
 err1 NOT INSIDE SealR_NOT_BULK
}

ALL_GT_jog = ALL_GT_convex_90_270_edge TOUCH EDGE ALL_GT_h_edges
ALL_GT_jog_in_P2 = ALL_GT_jog INSIDE EDGE P2
ALL_GT_v_jog_edge = ANGLE ALL_GT_convex_90_270_edge == 90

ALL_GT_center_iso = NOT RECTANGLE ((NOT RECTANGLE ALL_GT) NOT (OR edge_gate_AA_all GTMK1 GT_and_GTMK1))
ALL_GT_center_iso_region = DFM SPACE ALL_GT_center_iso <= 0.086 BY INT HORIZONTAL
ALL_GT_center = DFM COPY ALL_GT_center_iso_region CENTERLINE
ALL_GT_center_jog = EXPAND EDGE ALL_GT_center INSIDE BY 0.001 OUTSIDE BY 0.001

Q: Different jog width on the same ALL_GT is not allowed, except LOGO region
A: 
GT_R_5 {
@ Different jog width on the same ALL_GT is not allowed, except LOGO region
//;jog will be splitted by using expand edge with extending operation
 err1 = NOT RECTANGLE ALL_GT_center_jog ORTHOGONAL ONLY
 err2 = ALL_GT_center_jog INTERACT (ALL_GT_center_iso INTERACT ALL_GT_center_jog > 1)
 err3 = EXT ALL_GT_center_jog < 0.001 ABUT==90 INTERSECTING ONLY REGION
 err1 NOT INSIDE LOGO
 err2 NOT INSIDE LOGO
 err3 NOT INSIDE LOGO
}

Q: Different ALL_GT jog height inside the same P2 is not allowed
A: 
GT_R_6 {
@ Different ALL_GT jog height inside the same P2 is not allowed
 GT_WITH_JOGS = (ALL_GT WITH EDGE ALL_GT_jog_in_P2) AND P2
 GT_JOGS_inP2 = ALL_GT_v_jog_edge INSIDE EDGE P2
 GT_JOGS_neq = DFM PROPERTY GT_WITH_JOGS GT_JOGS_inP2 OVERLAP ABUT ALSO MULTI [-= MAX(LENGTH(GT_JOGS_inP2)) - MIN(LENGTH(GT_JOGS_inP2))] != 0
 GT_JOGS_neq_EXP = EXPAND EDGE ALL_GT_jog OUTSIDE BY 0.001
 GT_JOGS_neq_FOUND = GT_JOGS_neq COIN EDGE GT_JOGS_inP2   //; jog height in the same ALL_GT
 err1 = GT_JOGS_neq_EXP WITH EDGE GT_JOGS_neq_FOUND
 err1 NOT INSIDE SealR_NOT_BULK

 RVS_GT_inP2 = (P2 INTERACT ALL_GT) NOT ALL_GT
 RVS_GT_inP2_H = RVS_GT_inP2 COIN EDGE P2_h_edges
 RVS_GT_in_LEGS = CONVEX EDGE RVS_GT_inP2 ANGLE1 == 90 ANGLE2 == 270
 RVS_GT_in_LEGS_V = RVS_GT_in_LEGS COIN EDGE ALL_GT_v_edges
 RVS_GT_in_LEGS_V_inP2_CORNER = INT [RVS_GT_in_LEGS_V] RVS_GT_inP2_H < 0.005 ABUT==90 INTERSECTING ONLY
 RVS_GT_in_LEGS_V_inP2 = RVS_GT_in_LEGS_V TOUCH EDGE RVS_GT_in_LEGS_V_inP2_CORNER
 RVS_GT_JOGS_neq = DFM PROPERTY RVS_GT_inP2 RVS_GT_in_LEGS_V_inP2 OVERLAP ABUT ALSO MULTI [-= MAX(LENGTH(RVS_GT_in_LEGS_V_inP2)) - MIN(LENGTH(RVS_GT_in_LEGS_V_inP2))] != 0
 RVS_GT_JOGS_neq_EXP = EXPAND EDGE ALL_GT_jog INSIDE BY 0.001
 RVS_GT_JOGS_neq_FOUND = RVS_GT_JOGS_neq COIN EDGE RVS_GT_in_LEGS_V_inP2   //; jog height between two ALL_GTs
 err2 = RVS_GT_JOGS_neq_EXP WITH EDGE RVS_GT_JOGS_neq_FOUND
 err2 NOT INSIDE SealR_NOT_BULK
}

Q: Different jog height on the same ALL_GT and Z-shape GT jog are not allowed, except LOGO region
A: 
GT_R_7 {
@ Different jog height on the same ALL_GT and Z-shape GT jog are not allowed, except LOGO region
 ALL_GT_lend_END = ANGLE ALL_GT_convex_90_90_edge == 0
 ALL_GT_lend_EXP = EXPAND EDGE ALL_GT_lend_END INSIDE BY 0.005
 ALL_GT_legs = EXPAND EDGE ALL_GT_v_jog_edge INSIDE BY 0.005
 ALL_GT_lend_WITH_twoLegs = ALL_GT_lend_EXP INTERACT ALL_GT_legs == 2
 ALL_GT_legs_NEAR_lend = ALL_GT_v_jog_edge TOUCH EDGE ALL_GT_lend_WITH_twoLegs
 ALL_GT_lend_EXP_ERROR = DFM PROPERTY ALL_GT_lend_WITH_twoLegs ALL_GT_legs_NEAR_lend OVERLAP ABUT ALSO MULTI [-= MAX(LENGTH(ALL_GT_legs_NEAR_lend)) - MIN(LENGTH(ALL_GT_legs_NEAR_lend))] != 0
 err1 = ALL_GT_v_jog_edge TOUCH EDGE ALL_GT_lend_EXP_ERROR   //; jog height in the same ALL_GT
 err1 NOT INSIDE EDGE LOGO

 ALL_GT_lend_WITH_oneLegs = ALL_GT_lend_EXP INTERACT ALL_GT_legs == 1
 ALL_GT_WITH_oneLegs_ERROR = ALL_GT INTERACT ALL_GT_lend_WITH_oneLegs > 1
 err2 = ALL_GT_v_jog_edge TOUCH EDGE (ALL_GT_lend_WITH_oneLegs INTERACT ALL_GT_WITH_oneLegs_ERROR)
 err2 NOT INSIDE EDGE LOGO   //; Z-shape ALL_GT
}

Q: ALL_GT jog height must be the same when interact the same AA. DRC check the region of the AA horizontal edge sizing 0.1um
A: 
GT_R_8 {
@ ALL_GT jog height must be the same when interact the same AA. DRC check the region of the AA horizontal edge sizing 0.1um
 SETP_1 = (edge_gate_AA_all INTERACT (GATE INTERACT (AA INTERACT GATE))) NOT ALL_GT
 SETP_2 = SETP_1 OR (EXPAND EDGE (SETP_1 INSIDE EDGE edge_gate_AA_all) OUTSIDE BY 0.003)
 SETP_3 = ANGLE SETP_2 == 0
 err1_a = ENC SETP_3 ALL_GT_jog <= 0.100 OPPOSITE EXTENDED 0.005 EXCLUDE SHIELDED
 err1_b = EXT SETP_3 ALL_GT_jog <= 0.100 OPPOSITE EXTENDED 0.005 EXCLUDE SHIELDED
 err1_c = DFM COPY err1_a err1_b

 err1_TMP = DFM PROPERTY SETP_3 err1_a err1_b err1_c ABUT ALSO OVERLAP MULTI
 [jog_e = (COUNT(err1_c) > 1) ? 1 : 0] > 0
 [jog_h = (MIN(EWYP(err1_c)) == MAX(EWYP(err1_c))) ? 1 : 0 ] == 0
 err1 = EXPAND EDGE err1_TMP OUTSIDE BY 0.005
 err1 NOT INSIDE SealR_NOT_BULK
}

Q: ALL_GT must be vertical direction, except DMCMK1, LOGO and MARKS regions
A: 
GT_R_9 {
@ ALL_GT must be vertical direction, except DMCMK1, LOGO and MARKS regions
 chk_GT = ALL_GT NOT INSIDE (OR DMCMK1 LOGO MARKS)
 v_sides_gt = ANGLE chk_GT == 90
 h_sides_gt = ANGLE chk_GT == 0
 err1 = DFM PROPERTY chk_GT v_sides_gt h_sides_gt OVERLAP [diff_len_h = MAX(LENGTH(h_sides_gt)) - MAX(LENGTH(v_sides_gt))] > 0
 err1 NOT INSIDE (OR DMCMK1 LOGO MARKS)
}

Q: (((ALL_GT NOT P2) NOT (DUM_GT INSIDE DMCB1)) CUT (DG OR ((DMPNP OR DSTR) OR VARMOS))) is not alllowed
A: 
GT_R_10 {
@ (((ALL_GT NOT P2) NOT (DUM_GT INSIDE DMCB1)) CUT (DG OR ((DMPNP OR DSTR) OR VARMOS))) is not alllowed
 Check_Layers = OR DG DMPNP DSTR VARMOS
 Layer_Cutted = ALL_GT_NOT_P2 NOT (DUM_GT INSIDE DMCB1)
 err1 = Check_Layers INSIDE EDGE Layer_Cutted
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

TRGATE_CORE_wlt_020 = TRGATE_LE_LT_20 NOT INSIDE DG
TRGATE_CORE_wlt_020_EXP = (SIZE TRGATE_CORE_wlt_020 BY 0.035) AND GT
TRGATE_CORE_wlt_024 = TRGATE_LE_LT_24 NOT INSIDE DG
TRGATE_CORE_wlt_024_EXP = (SIZE TRGATE_CORE_wlt_024 BY 0.035) AND GT

TRGATE_2gt_024 = TRGATE_CORE_wlt_024_EXP ENCLOSE (TRGATE_CORE_wlt_024 INTERACT (AA INTERACT TRGATE_CORE_wlt_024 == 2))
TRGATE_2gt_020 = TRGATE_CORE_wlt_020_EXP ENCLOSE (TRGATE_CORE_wlt_020 INTERACT (AA INTERACT TRGATE_CORE_wlt_020 == 2))
TRGATE_1gt_024 = TRGATE_CORE_wlt_024_EXP ENCLOSE (TRGATE_CORE_wlt_024 INTERACT (AA INTERACT TRGATE_CORE_wlt_024 == 1))
TRGATE_1gt_020 = TRGATE_CORE_wlt_020_EXP ENCLOSE (TRGATE_CORE_wlt_020 INTERACT (AA INTERACT TRGATE_CORE_wlt_020 == 1))

TRGATE_2gt_gap_080 = EXT (TRGATE_2gt_024 TOUCH EDGE GATE_raw) <= 0.080 OPPOSITE REGION
TRGATE_2gt_gap_076 = EXT (TRGATE_2gt_020 TOUCH EDGE GATE_raw) <= 0.076 OPPOSITE REGION
TRGATE_2gt_gap_074 = EXT (TRGATE_2gt_020 TOUCH EDGE GATE_raw) <= 0.074 OPPOSITE REGION

VARIABLE Trgate_three_pitch 0.096*3
VARIABLE Trgate_four_pitch 0.096*4
VARIABLE AOP_GT_MinSpace 0.080

GT_P96_EMPTY = GT_P96 NOT DRC:1

Q: The number of AOP_GT in one group >= 7
    1) AA with only one or two GATE (width <= 0.024um)
    2) AOP_GT space <= 0.08um
    3) AOP_GT has same PRL as ((GATE su 0.035um) AND GT)
A: 
GT_R_11_1 {
@ The number of AOP_GT in one group >= 7
@ 1) AA with only one or two GATE (width <= 0.024um)
@ 2) AOP_GT space <= 0.08um
@ 3) AOP_GT has same PRL as ((GATE su 0.035um) AND GT)
//;DRC flag the AA with only one or two GATE
 Tr_1gt_com_Trgate = TRGATE_1gt_024 NOT INSIDE GT_P96_EMPTY
 Tr_1gt_com_Three_Body = Tr_1gt_com_Trgate TOUCH EDGE GTEIAA
 Tr_1gt_com_Three_Body_ERRS_near = EXT (Tr_1gt_com_Three_Body) AOP_GT <= AOP_GT_MinSpace ABUT<90 OPPOSITE
 Tr_1gt_com_Three_Body_ERRS = EXT (Tr_1gt_com_Three_Body) AOP_GT <= AOP_GT_MinSpace ABUT<90 OPPOSITE
 err1 = EXPAND EDGE Tr_1gt_com_Three_Body_ERRS OUTSIDE BY 0.0005
 err1 NOT INSIDE GT_P96_EMPTY

 Tr_1gt_com = Tr_1gt_com_Trgate NOT INSIDE (EXT Tr_1gt_com_Three_Body <= Trgate_four_pitch ABUT<90 OPPOSITE REGION)
 Tr_1gt_com_edge = Tr_1gt_com TOUCH EDGE GTEIAA
 Tr_1gt_com_iso_side = EXT (Tr_1gt_com_edge) <= Trgate_four_pitch ABUT<90 OPPOSITE
 Tr_1gt_com_den_area = EXT (TRGATE_CORE_wlt_024_EXP TOUCH EDGE Tr_1gt_com_edge) <= Trgate_four_pitch ABUT<90 OPPOSITE REGION

 Tr_1gt_com_L_side = (EXPAND EDGE Tr_1gt_com_edge OUTSIDE BY 0.005) AND (GROW Tr_1gt_com LEFT BY 0.005)
 Tr_1gt_com_R_side = (EXPAND EDGE Tr_1gt_com_edge OUTSIDE BY 0.005) AND (GROW Tr_1gt_com RIGHT BY 0.005)
 Tr_1gt_com_L_edge = Tr_1gt_com_edge COIN EDGE Tr_1gt_com_L_side  //;TRGATE left side
 Tr_1gt_com_R_edge = Tr_1gt_com_edge COIN EDGE Tr_1gt_com_R_side
 Tr_1gt_com_L_edge_est = Tr_1gt_com_L_edge COIN EDGE Tr_1gt_com_iso_side
 Tr_1gt_com_R_edge_est = Tr_1gt_com_R_edge COIN EDGE Tr_1gt_com_iso_side
 Tr_1gt_com_L_area_est = GROW Tr_1gt_com_L_edge_est LEFT BY Trgate_four_pitch
 Tr_1gt_com_R_area_est = GROW Tr_1gt_com_R_edge_est RIGHT BY Trgate_four_pitch

 Tr_1gt_gap_L_est = Tr_1gt_com_L_area_est NOT AOP_GT_eqlt_024
 Tr_1gt_gap_R_est = Tr_1gt_com_R_area_est NOT AOP_GT_eqlt_024
 Tr_1gt_gap_L_est_raw = DFM SPACE Tr_1gt_gap_L_est <= AOP_GT_MinSpace BY INT HORIZONTAL
 Tr_1gt_gap_R_est_raw = DFM SPACE Tr_1gt_gap_R_est <= AOP_GT_MinSpace BY INT HORIZONTAL
 Tr_1gt_gap_L_est_chk = DFM COPY (DFM PROPERTY Tr_1gt_gap_L_est_raw AOP_GT_eqlt_024 ABUT ALSO OVERLAP MULTI [-= count(AOP_GT_eqlt_024)] == 2) REGION
 Tr_1gt_gap_R_est_chk = DFM COPY (DFM PROPERTY Tr_1gt_gap_R_est_raw AOP_GT_eqlt_024 ABUT ALSO OVERLAP MULTI [-= count(AOP_GT_eqlt_024)] == 2) REGION
 Tr_1gt_gap_L_est_err = Tr_1gt_gap_L_est NOT Tr_1gt_gap_L_est_chk
 Tr_1gt_gap_R_est_err = Tr_1gt_gap_R_est NOT Tr_1gt_gap_R_est_chk

 Tr_1gt_gap_L_est_real = Tr_1gt_gap_L_est_chk NOT INTERACT Tr_1gt_gap_L_est_err
 Tr_1gt_gap_R_est_real = Tr_1gt_gap_R_est_chk NOT INTERACT Tr_1gt_gap_R_est_err
 Tr_1gt_com_L_est_pass = Tr_1gt_com_L_area_est ENCLOSE Tr_1gt_gap_L_est_real > 3
 Tr_1gt_com_R_est_pass = Tr_1gt_com_R_area_est ENCLOSE Tr_1gt_gap_R_est_real > 3
 Tr_1gt_com_pass = (Tr_1gt_com NOT INTERACT Tr_1gt_com_L_est_pass) NOT INTERACT Tr_1gt_com_R_est_pass

 Tr_1gt_com_edge_est = OR EDGE Tr_1gt_com_L_edge_est Tr_1gt_com_R_edge_est
 Tr_1gt_com_edge_est_all = OR Tr_1gt_com (EXPAND EDGE Tr_1gt_com_edge_est OUTSIDE BY Trgate_three_pitch)
 Tr_1gt_com_gaps_est = Tr_1gt_com_edge_est_all NOT AOP_GT_eqlt_024
 Tr_1gt_com_gaps_est_sps_raw = DFM SPACE Tr_1gt_com_gaps_est <= AOP_GT_MinSpace BY INT HORIZONTAL
 Tr_1gt_com_gaps_est_sps_chk = DFM COPY (DFM PROPERTY Tr_1gt_com_gaps_est_sps_raw AOP_GT_eqlt_024 ABUT ALSO OVERLAP MULTI [-= count(AOP_GT_eqlt_024)] == 2) REGION
 Tr_1gt_com_gaps_est_sps_err = Tr_1gt_com_gaps_est NOT Tr_1gt_com_gaps_est_sps_chk
 Tr_1gt_com_gaps_est_sps_real = Tr_1gt_com_gaps_est_sps_chk NOT INTERACT Tr_1gt_com_gaps_est_sps_err
 Tr_1gt_com_gaps_est_sps_pass = Tr_1gt_com_edge_est_all ENCLOSE Tr_1gt_com_gaps_est_sps_real >= 6

 err2_TMP = (Tr_1gt_com_pass NOT INTERACT Tr_1gt_com_gaps_est_sps_pass) NOT WITH EDGE Tr_1gt_com_Three_Body_ERRS
 err2_waive = (EXPAND EDGE Tr_1gt_com_edge OUTSIDE BY 0.005) INSIDE Tr_1gt_com_den_area
 err2 = err2_TMP NOT INTERACT err2_waive
 err2 NOT INSIDE GT_P96_EMPTY
}

Q: The number of AOP_GT in one group >= 7
    1) AA with only one or two GATE (width <= 0.024um)
    2) AOP_GT space <= 0.08um
    3) AOP_GT has same PRL as ((GATE su 0.035um) AND GT)
A: 
GT_R_11_2 {
@ The number of AOP_GT in one group >= 7
@ 1) AA with only one or two GATE (width <= 0.024um)
@ 2) AOP_GT space <= 0.08um
@ 3) AOP_GT has same PRL as ((GATE su 0.035um) AND GT)
//;DRC flag the AA with only one or two GATE
 Tr_2gt_com_Trgate = TRGATE_2gt_024 NOT INSIDE GT_P96_EMPTY
 Tr_2gt_com_Four_Body = Tr_2gt_com_Trgate TOUCH EDGE GTEIAA
 Tr_2gt_com_Four_Body_ERRS = EXT (Tr_2gt_com_Four_Body) AOP_GT <= AOP_GT_MinSpace ABUT<90 OPPOSITE
 err1 = EXPAND EDGE Tr_2gt_com_Four_Body_ERRS OUTSIDE BY 0.0005
 err1 NOT INSIDE GT_P96_EMPTY

 Tr_2gt_gap_all = OR TRGATE_2gt_024 TRGATE_2gt_gap_080
 Tr_2gt_gap_all_v_edge = Tr_2gt_gap_all COIN EDGE AOP_GT_v_edges
 Tr_2gt_gap_all_v_edge_L = Tr_2gt_gap_all_v_edge COIN EDGE ((GROW Tr_2gt_gap_all LEFT BY 0.005) NOT Tr_2gt_gap_all)
 Tr_2gt_gap_all_v_edge_R = Tr_2gt_gap_all_v_edge COIN EDGE ((GROW Tr_2gt_gap_all RIGHT BY 0.005) NOT Tr_2gt_gap_all)
 Tr_2gt_gap_sti = EXT Tr_2gt_gap_all_v_edge <= Trgate_three_pitch OPPOSITE REGION

 Tr_2gt_est_L_EDG = Tr_2gt_gap_all_v_edge_L OUTSIDE EDGE Tr_2gt_gap_sti
 Tr_2gt_est_R_EDG = Tr_2gt_gap_all_v_edge_R OUTSIDE EDGE Tr_2gt_gap_sti
 Tr_2gt_est_L_EDG_3p = EXPAND EDGE Tr_2gt_est_L_EDG OUTSIDE BY Trgate_three_pitch
 Tr_2gt_est_R_EDG_3p = EXPAND EDGE Tr_2gt_est_R_EDG OUTSIDE BY Trgate_three_pitch
 Tr_2gt_gap_L_3p = Tr_2gt_est_L_EDG_3p NOT AOP_GT_eqlt_024
 Tr_2gt_gap_R_3p = Tr_2gt_est_R_EDG_3p NOT AOP_GT_eqlt_024

 Tr_2gt_gap_L_sps_raw = DFM SPACE Tr_2gt_gap_L_3p <= AOP_GT_MinSpace BY INT HORIZONTAL
 Tr_2gt_gap_R_sps_raw = DFM SPACE Tr_2gt_gap_R_3p <= AOP_GT_MinSpace BY INT HORIZONTAL
 Tr_2gt_gap_L_sps_chk = DFM COPY (DFM PROPERTY Tr_2gt_gap_L_sps_raw AOP_GT_eqlt_024 ABUT ALSO OVERLAP MULTI [-= count(AOP_GT_eqlt_024)] == 2) REGION
 Tr_2gt_gap_R_sps_chk = DFM COPY (DFM PROPERTY Tr_2gt_gap_R_sps_raw AOP_GT_eqlt_024 ABUT ALSO OVERLAP MULTI [-= count(AOP_GT_eqlt_024)] == 2) REGION
 Tr_2gt_gap_L_sps_err = Tr_2gt_gap_L_3p NOT Tr_2gt_gap_L_sps_chk
 Tr_2gt_gap_R_sps_err = Tr_2gt_gap_R_3p NOT Tr_2gt_gap_R_sps_chk

 Tr_2gt_gap_L_sps_real = Tr_2gt_gap_L_sps_chk NOT INTERACT Tr_2gt_gap_L_sps_ERR
 Tr_2gt_gap_R_sps_real = Tr_2gt_gap_R_sps_chk NOT INTERACT Tr_2gt_gap_R_sps_ERR
 Tr_2gt_gap_L_sps_pass = Tr_2gt_est_L_EDG_3p ENCLOSE Tr_2gt_gap_L_sps_REAL > 2
 Tr_2gt_gap_R_sps_pass = Tr_2gt_est_R_EDG_3p ENCLOSE Tr_2gt_gap_R_sps_REAL > 2

 err2_TMP = ((Tr_2gt_gap_all NOT INTERACT Tr_2gt_gap_L_sps_pass) NOT INTERACT Tr_2gt_gap_R_sps_pass) NOT WITH EDGE Tr_2gt_com_Four_Body_ERRS
 err2_waive = (EXPAND EDGE Tr_2gt_gap_all_v_edge OUTSIDE BY 0.005) INSIDE Tr_2gt_gap_sti
 err2 = err2_TMP NOT INTERACT err2_waive
 err2 NOT INSIDE GT_P96_EMPTY
}

Q: The number of AOP_GT inside P96_Group >= 7
    Definition of P96_Group:
    (((AOP_GT INSIDE GT_P96) with width <= 0.024um) su 0.04um) sd 0.04
    DRC flags width of P96_Group <= 0.504um in S/D direction
A: 
GT_R_12 {
@ The number of AOP_GT inside P96_Group >= 7
@ Definition of P96_Group:
@ (((AOP_GT INSIDE GT_P96) with width <= 0.024um) su 0.04um) sd 0.04
@ DRC flags width of P96_Group <= 0.504um in S/D direction
 AOP_GT_INSIDE_p96 = AOP_GT_eqlt_024 INSIDE GT_P96
 AOP_GT_GROUP_080 = SIZE AOP_GT_INSIDE_p96 BY 0.04 OVERUNDER   //; P96_Group
 AOP_GT_ERROR = AOP_GT_GROUP_080 INTERACT AOP_GT_INSIDE_p96 < 7
 err1 = DFM COPY (DFM SPACE AOP_GT_ERROR <= 0.504 BY INT HORIZONTAL) REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

Q: Floating GATE is not allowed if the effective S/D are not connected together, for chip level purpose
    Floating GATE definition:
    (1) GATE not connected to M0G
    (2) GATE connected to M0G but not connected to MOS AA, pick-up or MD
    (3) It is not a floating GATE if the GATE is connected to AA by M0G in SRAM bit cell
    (4) HR resistor is treated as a conductor between the two HR terminal
    DRC check methodology for effective S/D:
   (1) S/D is connected to different (MOS AA NOT GT), pick-up, Gate, or MD
A: 
GT_R_13 {
@ Floating GATE is not allowed if the effective S/D are not connected together, for chip level purpose
@ Floating GATE definition:
@ (1) GATE not connected to M0G
@ (2) GATE connected to M0G but not connected to MOS AA, pick-up or MD
@ (3) It is not a floating GATE if the GATE is connected to AA by M0G in SRAM bit cell
@ (4) HR resistor is treated as a conductor between the two HR terminal
@ DRC check methodology for effective S/D:
@ (1) S/D is connected to different (MOS AA NOT GT), pick-up, Gate, or MD
//;source/drain not connect other source/drain, gate, tap and md
 FNSD = NET AREA RATIO NSD_em PSD_em GATE_CONNECT PTAP_em NTAP_em MD_em > 0 [~(count(NSD_em) -1)*!AREA(PSD_em)*!AREA(GATE_CONNECT)*!AREA(PTAP_em)*!AREA(NTAP_em)*!AREA(MD_em)]
 FPSD = NET AREA RATIO PSD_em NSD_em GATE_CONNECT PTAP_em NTAP_em MD_em > 0 [~(count(PSD_em) -1)*!AREA(NSD_em)*!AREA(GATE_CONNECT)*!AREA(PTAP_em)*!AREA(NTAP_em)*!AREA(MD_em)]
 NSD_effective_TMP = NSD_em NOT INTERACT FNSD
 PSD_effective_TMP = PSD_em NOT INTERACT FPSD
 NSD_effective = (FNSD OR GATE_em) INTERACT NSD_effective_TMP > 1 BY NET
 PSD_effective = (FPSD OR GATE_em) INTERACT PSD_effective_TMP > 1 BY NET

 NSD_floating_real = FNSD NOT NSD_effective
 PSD_floating_real = FPSD NOT PSD_effective
 FGATE_real = FGATE_raw NOT INTERACT (NSD_floating_real OR PSD_floating_real)  //;floating gate with (SD connected to MOS AA/pick-up/GATE/MD)
 err1 = FGATE_real INTERACT real_NSD_em > 1 BY NET  //;floating gate with SD connected to different MOS AA/pick-up/GATE/MD
 err2 = FGATE_real INTERACT real_PSD_em > 1 BY NET  //;floating gate with SD connected to different MOS AA/pick-up/GATE/MD
 err1 NOT INSIDE INST
 err2 NOT INSIDE INST
}

Q: ALL_GT must be fully covered by (SN OR SP), except DMCMK1, RESNW, MARKS and OCOVL regions
A:
GT_R_14 {
@ ALL_GT must be fully covered by (SN OR SP), except DMCMK1, RESNW, MARKS and OCOVL regions
 err1 = (ALL_GT NOT (OR DMCMK1 RESNW MARKS OCOVL)) NOT ALL_SN_SP
 err1 NOT INSIDE SealR_NOT_BULK
}

Q: AOP_GT extension outside of AOP_AA in S/D direction equal to the half width of the same AOP_GT, except AOP_GT both side space to neighboring AOP_GT on the same AOP_AA, INST, and LDBK region
    DRC flags the vertical edge of AOP_AA (INTERACT AOP_GT) NOT fully abut the centerline of AOP_GT
A: 
GT_R_15 {
@ AOP_GT extension outside of AOP_AA in S/D direction equal to the half width of the same AOP_GT, except AOP_GT both side space to neighboring AOP_GT on the same AOP_AA, INST, and LDBK region
@ DRC flags the vertical edge of AOP_AA (INTERACT AOP_GT) NOT fully abut the centerline of AOP_GT
 WAIVE_AREA = OR LDBK INST
 CHK_AOP_GT = AOP_GT INTERACT AOP_AA
 CHK_AOP_AA = AOP_AA INTERACT CHK_AOP_GT
 CHK_AOP_AA_EDGE = (ANGLE CHK_AOP_AA == 90) COIN EDGE (CHK_AOP_AA NOT OUTSIDE EDGE CHK_AOP_GT)
 err1 = CHK_AOP_AA_EDGE NOT COIN EDGE AOP_GT_center_even
 err1 NOT INSIDE EDGE WAIVE_AREA //;waive odd AOP_GT
}

Q: Space between P90_Group (AOP_GT number < 7, width < 0.556um in S/D direction) to AOP_GT (width >= 0.032um, PRL > -0.03um) <= 0.079um in S/D direction at both sides is not allowed, except GT_P96 region
    Definition of P90_Group: ((AOP_GT (width <= 0.02um) su 0.037um) sd -0.037um)
A: 
GT_R_17 {
@ Space between P90_Group (AOP_GT number < 7, width < 0.556um in S/D direction) to AOP_GT (width >= 0.032um, PRL > -0.03um) <= 0.079um in S/D direction at both sides is not allowed, except GT_P96 region
@ Definition of P90_Group: ((AOP_GT (width <= 0.02um) su 0.037um) sd -0.037um)
 AOP_GT_CHECK_032_v_edges = AOP_GT_v_edges COIN EDGE AOP_GT_eqgt_032
 AOP_GT_GROUP_078 = SIZE AOP_GT_eqlt_020 BY 0.037 OVERUNDER
 AOP_GT_GROUP_p90 = (AOP_GT_GROUP_078 INTERACT AOP_GT_eqlt_020 <= 7) NOT INSIDE GT_P96  //;6pitch*0.09 = 0.540,7pitch*0.09 = 0.630, reduce runtime
 AOP_GT_GROUP_p90_SPACE_eqlt_079 = EXT [AOP_GT_GROUP_p90] AOP_GT_CHECK_032_v_edges <= 0.079 ABUT<90 OPPOSITE EXTENDED 0.03
 err1 = (INT AOP_GT_GROUP_p90_SPACE_eqlt_079 < 0.556 ABUT<90 OPPOSITE REGION) NOT INSIDE GT_P96
 err1 NOT INSIDE SealR_NOT_BULK
}

Q: GT fully cover AA is not allowed
A: 
GT_R_18 {
@ GT fully cover AA is not allowed
 err1 = AA INSIDE GT
 err1 NOT INSIDE SealR_NOT_BULK
}


//EGATE


GTMK1_v_edges = ANGLE GTMK1 == 90
GTMK2_v_edges = ANGLE GTMK2 == 90
GTMK1_h_edges = ANGLE GTMK1 == 0
GTMK2_h_edges = ANGLE GTMK2 == 0
GT_and_GTMK1 = GT AND GTMK1
GT_and_GTMK2 = GT AND GTMK2

Q: GTMK1 must be fully covered by AOP_GT
A: 
EGATE_R_1 {
@ GTMK1 must be fully covered by AOP_GT
 err1 = GTMK1 NOT AOP_GT
 err1 NOT INSIDE SealR_NOT_BULK
}

Q: GTMK2 both two vertical edges must fully abut GT vertical edge
A: 
EGATE_R_2 {
@ GTMK2 both two vertical edges must fully abut GT vertical edge
 err1 = GTMK2_v_edges NOT COIN EDGE GT
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

Q: GTMK1 and GTMK2 must be rectangles and orthogoral to grid
A: 
EGATE_R_3 {
@ GTMK1 and GTMK2 must be rectangles and orthogoral to grid
 err1 = NOT RECTANGLE GTMK1 ORTHOGONAL ONLY
 err2 = NOT RECTANGLE GTMK2 ORTHOGONAL ONLY
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

Q: (GTMK2 AND AA) must be rectangles and orthogoral to grid
A: 
EGATE_R_4 {
@ (GTMK2 AND AA) must be rectangles and orthogoral to grid
 err1 = NOT RECTANGLE (GTMK2 AND AA) ORTHOGONAL ONLY
 err1 NOT INSIDE SealR_NOT_BULK
}

Q: GTMK2 both two horizontal edges must abut AA horizontal edges
A: 
EGATE_R_5 {
@ GTMK2 both two horizontal edges must abut AA horizontal edges
 err1 = GTMK2_h_edges NOT TOUCH EDGE AA
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

Q: GTMK2 at least one horizontal edge must abut GTMK1 horizontal edge
A: 
EGATE_R_6 {
@ GTMK2 at least one horizontal edge must abut GTMK1 horizontal edge
 err1 = GTMK2 NOT WITH EDGE (GTMK2 COIN EDGE GTMK1_h_edges)
 err1 NOT INSIDE SealR_NOT_BULK
}

Q: (GT AND GTMK1) width in S/D and outside AA direction must be the same as LAST GATE of 0.032um, when neighboring to LAST GATE (channel length = 0.032um, (GT AND GTMK1) to LAST GATE space = 0.074um)
     LAST GATE definition: the closest GATE to AA edge in S/D direction (AA on LAST GATE extension <= 0.318um)
A: 
EGATE_R_7 {
@ (GT AND GTMK1) width in S/D and outside AA direction must be the same as LAST GATE of 0.032um, when neighboring to LAST GATE (channel length = 0.032um, (GT AND GTMK1) to LAST GATE space = 0.074um)
@ LAST GATE definition: the closest GATE to AA edge in S/D direction (AA on LAST GATE extension <= 0.318um)
 CHK_Range = GATE_LE_32 WITH EDGE (ENC [GATE] AA_v_edges <= 0.318 ABUT<90 OPPOSITE EXCLUDE SHIELDED)
 GOOD_side_A = EXT [GT_and_GTMK1] CHK_Range == 0.074 ABUT<90 OPPOSITE
 GOOD_side_B = INT (GOOD_side_A) GT_and_GTMK1 == 0.032 ABUT<90 OPPOSITE
 err1 = GT_and_GTMK1 WITH EDGE GOOD_side_B
 err1 NOT INSIDE SealR_NOT_BULK
}

gtmk_all = OR (GT_and_GTMK1 INTERACT GT_and_GTMK2) (GT_and_GTMK2 INTERACT GT_and_GTMK1) (GT_and_GTMK1 NOT INTERACT GT_and_GTMK2)
last_trgate_edges = ENC [GATE] AA_v_edges <= 0.358 ABUT<90 OPPOSITE EXCLUDE SHIELDED

Q: (GT AND GTMK1) width in S/D and outside AA direction must be the same as LAST GATE, or 0.072um, when neighboring to LAST GATE (channel length >= 0.07um, (GT AND GTMK1) to LAST GATE space = 0.118 or 0.119um), in core region
     LAST GATE definition: the closest GATE to AA edge in S/D direction (AA on LAST GATE extension <= 0.358um)
A: 
EGATE_R_8 {
@ (GT AND GTMK1) width in S/D and outside AA direction must be the same as LAST GATE, or 0.072um, when neighboring to LAST GATE (channel length >= 0.07um, (GT AND GTMK1) to LAST GATE space = 0.118 or 0.119um), in core region
@ LAST GATE definition: the closest GATE to AA edge in S/D direction (AA on LAST GATE extension <= 0.358um)
 CHK_Range = (GATE_LE_GT_70 WITH EDGE last_trgate_edges) NOT INSIDE DG
 GOOD_side_A = EXT [GT_and_GTMK1] CHK_Range >= 0.118 <= 0.119 ABUT<90 OPPOSITE
 GOOD_side_B = INT (GOOD_side_A) GT_and_GTMK1 == 0.072 ABUT<90 OPPOSITE

 CHK_SD = (((AA_SD_all INTERACT CHK_Range) WITH EDGE GOOD_side_A) WITH EDGE GOOD_side_B) NOT INSIDE DG
 ERR_SD = DFM PROPERTY CHK_SD CHK_Range gtmk_all ABUT ALSO OVERLAP MULTI [two_gt = (count(CHK_Range) > 0 && count(gtmk_all) > 0) ? 1 : 0] > 0 [diff_wl = abs(area(CHK_Range) - area(gtmk_all))] > 0
 err1 = (GT_and_GTMK1 WITH EDGE (ERR_SD COIN EDGE GT_and_GTMK1)) WITH EDGE GOOD_side_B
 err1 NOT INSIDE DG
}

Q: (GT AND GTMK1) width in S/D and outside AA direction must be the same as LAST GATE, or 0.086um, or 0.134um, when neighboring to LAST GATE ((GT AND GTMK1) to LAST GATE space = 0.118 or 0.119um) INSIDE DG, except DGV region
     LAST GATE definition: the closest GATE to AA edge in S/D direction (AA on LAST GATE extension <= 0.358um)
A: 
EGATE_R_9 {
@ (GT AND GTMK1) width in S/D and outside AA direction must be the same as LAST GATE, or 0.086um, or 0.134um, when neighboring to LAST GATE ((GT AND GTMK1) to LAST GATE space = 0.118 or 0.119um) INSIDE DG, except DGV region
@ LAST GATE definition: the closest GATE to AA edge in S/D direction (AA on LAST GATE extension <= 0.358um)
 CHK_Range = ((GATE WITH EDGE last_trgate_edges) INTERACT DG) NOT INSIDE DGV
 GOOD_side_A = EXT [GT_and_GTMK1] CHK_Range >= 0.118 <= 0.119 ABUT<90 OPPOSITE
 GOOD_side_B = INT (GOOD_side_A) GT_and_GTMK1 == 0.134 ABUT<90 OPPOSITE
 GOOD_side_C = INT (GOOD_side_B) GT_and_GTMK1 == 0.086 ABUT<90 OPPOSITE

 CHK_SD = (((AA_SD_all INTERACT CHK_Range) WITH EDGE GOOD_side_A) INTERACT DG) NOT INSIDE DGV
 ERR_SD = DFM PROPERTY CHK_SD CHK_Range gtmk_all ABUT ALSO OVERLAP MULTI [two_gt = (count(CHK_Range) > 0 && count(gtmk_all) > 0) ? 1 : 0] > 0 [diff_wl = abs(area(CHK_Range) - area(gtmk_all))] > 0
 err1 = (GT_and_GTMK1 WITH EDGE (ERR_SD COIN EDGE GT_and_GTMK1)) WITH EDGE GOOD_side_C
 err1 NOT INSIDE DGV
}

Q: (GT AND GTMK1) width in S/D and outside AA direction must be the same as LAST GATE, or 0.08um, or 0.086um, or 0.134um, when neighboring to LAST GATE
    (GT AND GTMK1) to LAST GATE space = 0.118 or 0.119um), inside DGV region
    LAST GATE definition: the closest GATE to AA edge in S/D direction (AA on LAST GATE extension <= 0.358um)
A: 
EGATE_R_10 {
@ (GT AND GTMK1) width in S/D and outside AA direction must be the same as LAST GATE, or 0.08um, or 0.086um, or 0.134um, when neighboring to LAST GATE
@ (GT AND GTMK1) to LAST GATE space = 0.118 or 0.119um), inside DGV region
@ LAST GATE definition: the closest GATE to AA edge in S/D direction (AA on LAST GATE extension <= 0.358um)
 CHK_Range = (GATE WITH EDGE last_trgate_edges) INTERACT DGV
 GOOD_side_A = EXT [GT_and_GTMK1] CHK_Range >= 0.118 <= 0.119 ABUT<90 OPPOSITE
 GOOD_side_B = INT (GOOD_side_A) GT_and_GTMK1 == 0.080 ABUT<90 OPPOSITE
 GOOD_side_C = INT (GOOD_side_B) GT_and_GTMK1 == 0.086 ABUT<90 OPPOSITE
 GOOD_side_D = INT (GOOD_side_C) GT_and_GTMK1 == 0.134 ABUT<90 OPPOSITE

 CHK_SD = ((AA_SD_all INTERACT CHK_Range) WITH EDGE GOOD_side_A) INTERACT DGV
 ERR_SD = DFM PROPERTY CHK_SD CHK_Range gtmk_all ABUT ALSO OVERLAP MULTI [two_gt = (count(CHK_Range) > 0 && count(gtmk_all) > 0) ? 1 : 0] > 0 [diff_wl = abs(area(CHK_Range) - area(gtmk_all))] > 0
 err1_TMP = (GT_and_GTMK1 WITH EDGE (ERR_SD COIN EDGE GT_and_GTMK1)) WITH EDGE GOOD_side_D
 err1 = err1_TMP INTERACT DGV
 err1 NOT INSIDE SealR_NOT_BULK
}

Q: AA vertical edge must align both GT and (GTMK1 or AR) centerline, except INST and MARKS regions
    The value of (GT AND GTMK1) width must be a even number
A: 
EGATE_R_11 {
@ AA vertical edge must align both GT and (GTMK1 or AR) centerline, except INST and MARKS regions
@ The value of (GT AND GTMK1) width must be a even number
 chk_aa = AA_v_edges NOT INSIDE EDGE MARKS_INST
 err1 = chk_aa NOT COIN EDGE GT_center_even
 err2 = chk_aa NOT INSIDE EDGE gtmk1_or_ar

 err1 NOT INSIDE EDGE MARKS_INST
 err2 NOT INSIDE EDGE MARKS_INST
}

Q: GTMK2 overlap more than one GATE is not allowed
A: 
EGATE_R_12 {
@ GTMK2 overlap more than one GATE is not allowed
 err1 = GTMK2 INTERACT (GTMK2 AND GATE_raw) >= 2
 err1 NOT INSIDE SealR_NOT_BULK
}

Q: ((GT NOT P2) INTERACT (GTMK1 AND NW)) must connect to (N+ pick-up AA inside VARMOS)
A: 
EGATE_R_13 {
@ ((GT NOT P2) INTERACT (GTMK1 AND NW)) must connect to (N+ pick-up AA inside VARMOS)
 chk_GT = (GT_0 INTERACT (GTMK1 AND NW)) AND VARMOS
 good_GT = NET AREA RATIO chk_GT NTAP [!!AREA(chk_GT)*!!AREA(NTAP)] > 0
 err1 = chk_GT NOT good_GT
 err1 NOT INSIDE SealR_NOT_BULK
}

aa_with_gate_el_024 = (edge_gate_AA_all INTERACT (edge_gate_AA_all AND GT_eqlt_024)) INTERACT gtmk1_or_ar >= 2
aa_gate_gt_024 = edge_gate_AA_all AND GT_gt_024
aa_gate_el_024 = aa_with_gate_el_024 NOT INTERACT (aa_gate_gt_024 NOT gtmk1_or_ar) //;GT <= 0.024 only

Q: Width of GATE (channel length <= 0.024um) between two adjacent (GTMK1 OR AR) on the same AA must be the same
A: 
EGATE_R_14 {
@ Width of GATE (channel length <= 0.024um) between two adjacent (GTMK1 OR AR) on the same AA must be the same
 chk_SD = (aa_gate_el_024 NOT GT) INTERACT GATE == 2
 err1 = OR ((chk_SD INTERACT GT_014) INTERACT GT_gt_014) ((chk_SD INTERACT GT_015) INTERACT GT_gt_015)
 err2 = OR ((chk_SD INTERACT GT_016) INTERACT GT_gt_016) ((chk_SD INTERACT GT_017) INTERACT GT_gt_017)
 err3 = OR ((chk_SD INTERACT GT_018) INTERACT GT_gt_018) ((chk_SD INTERACT GT_019) INTERACT GT_gt_019)
 err4 = OR ((chk_SD INTERACT GT_020) INTERACT GT_gt_020) ((chk_SD INTERACT GT_021) INTERACT GT_gt_021) ((chk_SD INTERACT GT_022) INTERACT GT_gt_022) ((chk_SD INTERACT GT_023) INTERACT GT_gt_023)
 err5 = (GT_gt_024 AND (aa_with_gate_el_024 INTERACT aa_gate_gt_024)) NOT gtmk1_or_ar

 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
 err4 NOT INSIDE SealR_NOT_BULK
 err5 NOT INSIDE SealR_NOT_BULK
}

Q: GTMK2 interact the vertical edge (between 90-90 degree corners) of AA is not allowed
A: 
EGATE_R_15 {
@ GTMK2 interact the vertical edge (between 90-90 degree corners) of AA is not allowed
 chk_aa = AA_v_edges COIN EDGE AA_convex_90_90_edge
 err1 = GTMK2 INTERACT (EXPAND EDGE chk_aa INSIDE BY 0.001)
 err1 NOT INSIDE SealR_NOT_BULK
}

AA_INTERACT_RESNW_OR_DOP_AA = AA_INTERACT_RESNW OR DOP_AA
AA_INTERACT_RESNW_OR_DOP_AA_v_edge = ANGLE AA_INTERACT_RESNW_OR_DOP_AA == 90

Q: The vertical edge of ((AA INTERACT RESNW) OR DOP_AA) must align with AOP_GT centerline
A: 
EGATE_R_16 {
@ The vertical edge of ((AA INTERACT RESNW) OR DOP_AA) must align with AOP_GT centerline
 err1 = AA_INTERACT_RESNW_OR_DOP_AA_v_edge NOT COIN EDGE AOP_GT_center_even
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

Q: (AA AND GT) (INSIDE (pick-up NOT VARMOS), (DIOMK1 OR DIOMK2), DIR, DMPNP, or DSTR) must interact GTMK1, except INST region
A: 
EGATE_R_17 {
@ (AA AND GT) (INSIDE (pick-up NOT VARMOS), (DIOMK1 OR DIOMK2), DIR, DMPNP, or DSTR) must interact GTMK1, except INST region
//;GT inside pick-up, diomk1/diomk2, nw diode, rw diode should not be GATE
 err1 = (GATE_raw INSIDE TAP_NOT_VARMOS) NOT INTERACT GTMK1
 err2 = (GATE_raw INSIDE (DIOMK1 OR DIOMK2)) NOT INTERACT GTMK1
 err3 = (((GATE_raw INSIDE DIR) OR (GATE_raw INSIDE DMPNP)) OR (GATE_raw INSIDE DSTR)) NOT INTERACT GTMK1

 err1 NOT INSIDE INST
 err2 NOT INSIDE INST
 err3 NOT INSIDE INST
}

Q: GTMK1 (width > 0.032um in S/D direction) centerline must align (AA NOT INTERACT RESNW) vertical edge, except (pick-up NOT VARMOS), (DIOMK1 OR DIOMK2), DIR, DMPNP and DSTR regions
A: 
EGATE_R_18 {
@ GTMK1 (width > 0.032um in S/D direction) centerline must align (AA NOT INTERACT RESNW) vertical edge, except (pick-up NOT VARMOS), (DIOMK1 OR DIOMK2), DIR, DMPNP and DSTR regions
//;based on GTMK1 shape
 waive_area = OR TAP_NOT_VARMOS DIOMK1 DIOMK2 DIR DMPNP DSTR
 check_gtmk1 = (GTMK1 NOT INSIDE (OR waive_area AA_INTERACT_RESNW)) INTERACT (GTMK1 WITH WIDTH > 0.032) //; exclude nw resistor terminal
 check_area = GROW (EXTENTS check_gtmk1 CENTERS 0.0001) TOP BY 0.01 BOTTOM BY 0.01  //;DFM COPY (DFM SPACE Y1 < 0.250 BY INT HORIZONTAL) CENTERLINE
 err1 = ANGLE (check_area NOT TOUCH EDGE (EXPAND EDGE AA_v_edges BY 0.0001)) == 90
 err1 NOT INSIDE EDGE waive_area
}

Q: GTMK1 must be drawn identically to (GT AND AA (vertical edge extend 1/2 GT width) NOT GTMK2)
A: 
EGATE_R_19 {
@ GTMK1 must be drawn identically to (GT AND AA (vertical edge extend 1/2 GT width) NOT GTMK2)
 GTMK1_edge_gate = GATE_raw INTERACT AA_v_edges_exp001
 GTMK1_edge_side = GTMK1 INTERACT GTMK1_edge_gate

 err1 = (GTMK1_edge_side NOT GT) NOT GTMK2
 err2 = ((GTMK1_edge_side AND GT) TOUCH (GT NOT GTMK1_edge_side) == 1) NOT GTMK2
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK

 err3 = AA_v_edges COIN EDGE GTMK1
 err3 NOT INSIDE EDGE SealR_NOT_BULK

//; GTMK1 horizontal edge must be align with AA horizontal edge
//; Vertical edge must coin with GT when GTMK1 interact (GT AND AA)
 chk_GTMK1 = GTMK1 INTERACT GATE_raw
 err4 = (chk_GTMK1 COIN EDGE GTMK1_h_edges) NOT TOUCH EDGE AA
 err5 = (chk_GTMK1 COIN EDGE GTMK1_v_edges) NOT COIN EDGE GT
 err4 NOT INSIDE EDGE SealR_NOT_BULK
 err5 NOT INSIDE EDGE SealR_NOT_BULK
}

Q: GTMK1 overlap GTMK2 is not allowed
A: 
EGATE_R_20 {
@ GTMK1 overlap GTMK2 is not allowed
 err1 = GTMK1 AND GTMK2
 err1 NOT INSIDE SealR_NOT_BULK
}

Q: GTMK2 must be rectangle orthogonal to grid
A: 
EGATE_R_21 {
@ GTMK2 must be rectangle orthogonal to grid
 err1 = COPY (NOT RECTANGLE GTMK2 ORTHOGONAL ONLY)
 err1 NOT INSIDE SealR_NOT_BULK
}


//GT_P96

Q: GT_P96 INTERACT DG is not allowed
A: 
GT_P96_R_1 {
@ GT_P96 INTERACT DG is not allowed
 err1 = GT_P96 INTERACT DG
 err1 NOT INSIDE SealR_NOT_BULK
}

Q: AOP_AA or AOP_GT CUT GT_P96 is not allowed
A: 
GT_P96_R_2 {
@ AOP_AA or AOP_GT CUT GT_P96 is not allowed
 err1 = GT_P96 INSIDE EDGE (AOP_AA OR AOP_GT)
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}


//GTDMP

Q: Rectangle GTDMP outside AA must be GATE poly direction and the same with the device channel width direction of core area in a chip (GTDMP length/width > 1 and width < 0.1um)
A: 
GTDMP_R_1 {
@ Rectangle GTDMP outside AA must be GATE poly direction and the same with the device channel width direction of core area in a chip (GTDMP length/width > 1 and width < 0.1um)
//; DRC only check if GTDMP width < 0.1um, it should be in GATE poly direction
 chk_dop_gt = WITH WIDTH (RECTANGLE (GTDMP OUTSIDE AA) ORTHOGONAL ONLY) < 0.100
 v_sides_gt = ANGLE chk_dop_gt == 90
 h_sides_gt = ANGLE chk_dop_gt == 0
 err1 = DFM PROPERTY chk_dop_gt v_sides_gt h_sides_gt OVERLAP [diff_len_h = MAX(LENGTH(h_sides_gt)) - MAX(LENGTH(v_sides_gt))] > 0
 err1 NOT INSIDE SealR_NOT_BULK
}

AA_interact_GT_v_edges = edge_gate_AA_all_v_edges COIN EDGE (edge_gate_AA_all INTERACT AA_INTERACT_GT)
AA_sd_all_dum = (AA NOT AOP_GT) INTERACT GTDMP >= 2

Q: GTDMP form device is not allowed
    1) Maximum two AOP_GTs must be placed beside AA edge (AA INTERACT GT)
    2) M0 be placed between GTDMP and AA edge, and between two GTDMPs are not allowed, except MOMDMY, ESDIO1, ESDIO2 regions
A: 
GTDMP_R_2 {
@ GTDMP form device is not allowed
@ 1) Maximum two AOP_GTs must be placed beside AA edge (AA INTERACT GT)
@ 2) M0 be placed between GTDMP and AA edge, and between two GTDMPs are not allowed, except MOMDMY, ESDIO1, ESDIO2 regions
 waive_area = OR MOMDMY ESDIO_all
 err1 = (GTDMP AND AA) NOT INSIDE waive_area
 err1 NOT INSIDE SealR_NOT_BULK  //; GTDMP is used for device

 err2 = ((M0 INTERACT AA_sd_all_dum) OR AA_sd_all_dum) NOT INSIDE waive_area
 err2 NOT INSIDE SealR_NOT_BULK  //; AOP_GTs are placed in between

 GTDMP_AA_in_between = EXT AA_interact_GT_v_edges (GTDMP NOT INSIDE waive_area) < 0.180 OPPOSITE REGION EXCLUDE SHIELDED  //;based on GT pitch
 GTDMP_M0_in_between = EXT (GTDMP NOT INSIDE waive_area) < 0.180 OPPOSITE REGION EXCLUDE SHIELDED
 err3 = (M0 AND (OR GTDMP_AA_in_between GTDMP_M0_in_between)) NOT INSIDE waive_area
 err3 NOT INSIDE SealR_NOT_BULK
}


//P2

Q: P2 must be a rectangle, horizontal T- and crosstype-shape, square-wave-shape, L-shape, except OCOVL region
    1. Every segment of L-, T-, crosstype- or square-wave-shape P2 INTERACT at least two AOP_GT
    2. L- or square-wave-shape P2 width must be combination of 0.048/0.068um and jog must = 0.020um
    3. Horizontal T-shape, crosstype-shape P2 must be symmetric in GATE poly direction
A: 
P2_R_1 {
@ P2 must be a rectangle, horizontal T- and crosstype-shape, square-wave-shape, L-shape, except OCOVL region
@ 1. Every segment of L-, T-, crosstype- or square-wave-shape P2 INTERACT at least two AOP_GT
@ 2. L- or square-wave-shape P2 width must be combination of 0.048/0.068um and jog must = 0.020um
@ 3. Horizontal T-shape, crosstype-shape P2 must be symmetric in GATE poly direction
 P2_check = P2 NOT INSIDE OCOVL
 P2_R_shape = RECTANGLE P2_check
 P2_NR_shape = NOT RECTANGLE P2_check
 P2_concave_corner = EXT P2_check < 0.005 ABUT==90 INTERSECTING ONLY REGION
 err1 = ANGLE P2_check > 0 < 90
 err2 = DONUT P2_check
 err1 NOT INSIDE EDGE OCOVL //;non-orthogonal P2
 err2 NOT INSIDE OCOVL  //;ring type P2

//;P2 each width parts
 Y1 = (ANGLE P2_convex_90_90_edge == 0) COIN EDGE P2_check
 Y2 = (ANGLE P2_convex_90_270_edge == 90) COIN EDGE P2_check
 Y3 = (ANGLE P2_convex_270_270_edge == 90) COIN EDGE P2_check
 Y4 = EXPAND EDGE Y1 OUTSIDE BY 0.005
 Y5 = EXPAND EDGE Y2 INSIDE BY 0.005

 P2_CONVEX_90_90_real = Y1 COIN EDGE (Y4 INTERACT Y5)
 P2_WHOLE_NR_SHAPE = INT P2_CONVEX_90_90_real P2 <= P2_MaxiWidth ABUT<90 OPPOSITE REGION  //;whole big part in non-R shape
 P2_WHOLE_NR_SHAPE_OPP = INT P2_CONVEX_90_90_real (P2 NOT COIN EDGE P2_CONVEX_90_90_real) <= P2_MaxiWidth ABUT<90 OPPOSITE REGION  //;1.whole big part in R shape 2.opposite part
 P2_CORSS_SHAPE_OPP = INT P2_CONVEX_90_90_real <= P2_MaxiWidth ABUT<90 OPPOSITE REGION  //;opposite portion in the corss part

//;P2_L_SHAPE: only can be 0.048/0.068
 P2_L_SHAPE_TMP = P2_NR_shape INTERACT P2_concave_corner == 1
 P2_L_SHAPE_CHK = ((P2_L_SHAPE_TMP WITH EDGE P2_convex_90_90_edge == 4) WITH EDGE P2_convex_90_270_edge == 2) NOT WITH EDGE P2_convex_270_270_edge
 P2_L_SHAPE = ((P2_L_SHAPE_CHK INTERACT P2_W_048) INTERACT P2_W_068) NOT INTERACT (OR P2_W_036 P2_W_110 P2_W_130)  //;good L-shape

//;P2_T_SHAPE (symmetry along S/D direction): can be any size
 P2_T_SHAPE_TMP = P2_NR_shape INTERACT P2_concave_corner == 2
 P2_T_SHAPE_CHK = ((P2_T_SHAPE_TMP WITH EDGE P2_convex_90_90_edge == 4) WITH EDGE P2_convex_90_270_edge == 4) NOT WITH EDGE P2_convex_270_270_edge
 P2_T_SHAPE_VER_E = EXPAND EDGE (P2_T_SHAPE_CHK COIN EDGE (ANGLE P2_convex_90_90_edge == 90)) INSIDE BY 0.001
 P2_T_SHAPE_VER_P = P2_T_SHAPE_VER_E WITH EDGE (P2_T_SHAPE_VER_E COIN EDGE P2_convex_90_270_edge) == 2
 P2_T_SHAPE = (P2_T_SHAPE_CHK INTERACT P2_T_SHAPE_VER_P) INTERACT P2_WHOLE_NR_SHAPE == 1

//;P2_S_SHAPE: only can be 0.048/0.068
 P2_S_SHAPE = (((P2 WITH EDGE Y2 == 2) NOT WITH EDGE P2_convex_270_270_edge) INTERACT P2_W_068 == 2) INTERACT P2_W_048 == 1
 P2_S_SHAPE_JOG_PART = P2_W_068 AND P2_S_SHAPE

//;P2_CROSSTYPE_SHAPE (single cross shape): can be any size
 P2_C_SHAPE_TMP = P2_NR_shape INTERACT P2_concave_corner == 4
 P2_C_SHAPE_CHK = ((P2_C_SHAPE_TMP WITH EDGE P2_convex_90_90_edge == 4) WITH EDGE P2_convex_90_270_edge == 8) NOT WITH EDGE P2_convex_270_270_edge
 P2_C_SHAPE = P2_C_SHAPE_CHK INTERACT P2_WHOLE_NR_SHAPE == 1

//;ALL L-shape R-shape T-shape C-shape P2
 P2_RLTC_SHAP = OR P2_R_shape P2_L_SHAPE P2_L_SHAPE_CHK P2_T_SHAPE P2_C_SHAPE

//;P2_SQUARE_WAVE_SHAPE
 P2_SQUARE_WAVE_SHAPE = P2_NR_shape NOT P2_RLTC_SHAP
 P2_SQUARE_WAVE_SHAPE_JOG = P2_SQUARE_WAVE_SHAPE COIN EDGE Y2

//;P2 width check
 err3 = P2_L_SHAPE_CHK NOT P2_L_SHAPE
 err3 NOT INSIDE OCOVL  //;L-shape P2 width must be 0.048/0.068

 err4 = LENGTH (P2_WHOLE_NR_SHAPE_OPP COIN EDGE Y2) != 0.02
 err4 NOT INSIDE EDGE OCOVL  //;wave jog length must be 0.02

 P2_MULTI_CORSS_SHAPE_OPP = P2_CORSS_SHAPE_OPP ENCLOSE (INT (P2 INTERACT P2_CORSS_SHAPE_OPP) < 0.001 ABUT==90 INTERSECTING ONLY REGION) == 4
 err5 = P2 INTERACT (P2_MULTI_CORSS_SHAPE_OPP INTERACT (P2 INTERACT P2_MULTI_CORSS_SHAPE_OPP > 1))
 err5 NOT INSIDE OCOVL  //;multi cross shape is not allowed

//;AOP_GT count check
 P2_L_SHAPE_B = SIZE (P2_L_SHAPE AND P2_WHOLE_NR_SHAPE) BY -0.001
 P2_L_SHAPE_S = SIZE (P2_L_SHAPE NOT P2_L_SHAPE_B) BY -0.001
 err6 = OR (P2_L_SHAPE_B INTERACT AOP_GT < 2) (P2_L_SHAPE_S INTERACT AOP_GT < 2)
 err6 NOT INSIDE OCOVL  //;AOP_GT < 2 for any part

 P2_T_SHAPE_C = INT (P2_T_SHAPE TOUCH EDGE P2_h_edges) <= P2_MaxiWidth ABUT<90 OPPOSITE REGION CENTERLINE 0.001 EXCLUDE SHIELDED
 P2_T_SHAPE_B = SIZE ((P2_T_SHAPE INTERACT P2_T_SHAPE_C == 1) AND P2_WHOLE_NR_SHAPE) BY -0.001
 P2_T_SHAPE_S = SIZE ((P2_T_SHAPE INTERACT P2_T_SHAPE_C == 1) NOT P2_T_SHAPE_B) BY -0.001
 err7 = OR (P2_T_SHAPE_B INTERACT AOP_GT < 2) (P2_T_SHAPE_S INTERACT AOP_GT < 2) (P2_T_SHAPE_B NOT INTERACT AOP_GT) (P2_T_SHAPE_S NOT INTERACT AOP_GT)
 err7 NOT INSIDE OCOVL  //;no AOP_GT/AOP_GT < 2 for any part

 P2_C_SHAPE_C = INT (P2_C_SHAPE TOUCH EDGE P2_h_edges) <= P2_MaxiWidth ABUT<90 OPPOSITE REGION CENTERLINE 0.001 EXCLUDE SHIELDED
 P2_C_SHAPE_B = SIZE ((P2_C_SHAPE INTERACT P2_C_SHAPE_C == 1) AND P2_WHOLE_NR_SHAPE) BY -0.001
 P2_C_SHAPE_S = SIZE ((P2_C_SHAPE INTERACT P2_C_SHAPE_C == 1) NOT P2_C_SHAPE_B) BY -0.001
 err8 = OR (P2_C_SHAPE_B INTERACT AOP_GT < 2) (P2_C_SHAPE_S INTERACT AOP_GT < 2) (P2_C_SHAPE_B NOT INTERACT AOP_GT) (P2_C_SHAPE_S NOT INTERACT AOP_GT)
 err8 NOT INSIDE OCOVL  //;no AOP_GT/AOP_GT < 2 for any part

 P2_SQUARE_WAVE_SHAPE_C = P2_SQUARE_WAVE_SHAPE NOT INTERACT (NOT RECTANGLE P2_WHOLE_NR_SHAPE)
 P2_SQUARE_WAVE_SHAPE_B = SIZE (P2_SQUARE_WAVE_SHAPE AND P2_WHOLE_NR_SHAPE) BY -0.001
 P2_SQUARE_WAVE_SHAPE_S = SIZE (P2_SQUARE_WAVE_SHAPE NOT P2_SQUARE_WAVE_SHAPE_B) BY -0.001
 err9 = OR (P2_SQUARE_WAVE_SHAPE_B INTERACT AOP_GT < 2) (P2_SQUARE_WAVE_SHAPE_S INTERACT AOP_GT < 2)
 err9 NOT INSIDE OCOVL  //;AOP_GT < 2 for any part

 err10 = OR (P2_NR_shape INTERACT AOP_GT < 2) (P2_NR_shape NOT INTERACT AOP_GT)
 err10 NOT INSIDE OCOVL  //;no AOP_GT/single AOP_GT for whole P2

 err11 = OR (P2_S_SHAPE_JOG_PART INTERACT AOP_GT < 2) (P2_S_SHAPE_JOG_PART NOT INTERACT AOP_GT)
 err11 NOT INSIDE OCOVL  //;no AOP_GT/single AOP_GT for JOG part of S-shape P2

//;Check symmetrical relation in GATE poly direction
 P2_WHOLE_NR_SHAPE_R_PART = RECTANGLE P2_WHOLE_NR_SHAPE
 P2_WHOLE_NR_SHAPE_R_PART_JOG = Y2 COIN EDGE P2_WHOLE_NR_SHAPE_R_PART
 P2_WHOLE_NR_SHAPE_R_PART_CHK = DFM PROPERTY P2_WHOLE_NR_SHAPE_R_PART P2_WHOLE_NR_SHAPE_R_PART_JOG OVERLAP ABUT ALSO MULTI
 [-= MAX(LENGTH(P2_WHOLE_NR_SHAPE_R_PART_JOG)) - MIN(LENGTH(P2_WHOLE_NR_SHAPE_R_PART_JOG))] > 0
 err12 = P2_WHOLE_NR_SHAPE_R_PART_JOG COIN EDGE P2_WHOLE_NR_SHAPE_R_PART_CHK
 err12 NOT INSIDE EDGE OCOVL

 err13 = NOT RECTANGLE P2_WHOLE_NR_SHAPE
 err13 NOT INSIDE OCOVL  //;whole big part should be rectangle

 err14 = P2_T_SHAPE_C INTERACT (P2_T_SHAPE INTERACT P2_T_SHAPE_C > 1)
 err14 NOT INSIDE OCOVL  //;P2_T_SHAPE centerline must be aligned

 err15 = INT (P2_h_edges) <= P2_MaxiWidth OPPOSITE
 err15 NOT INSIDE EDGE OCOVL  //;width > P2_MaxiWidth P2
}

VARIABLE MAXIMUM_2nd_DummySpace 0.481
VARIABLE MIMIMUM_2nd_DummySpace 0.180

Q: Width of P2 (INTERACT the second AOP_GT neighboring of GATE) in S/D direction = 0.048, 0.068um
A: 
P2_R_2 {
@ Width of P2 (INTERACT the second AOP_GT neighboring of GATE) in S/D direction = 0.048, 0.068um
//;P2 number > 1 is allowed
 neighboring_TRGATE_TEMP = TRGATE INTERACT (SD INTERACT (GATE_raw INTERACT AA_v_edges_exp001))
 neighboring_TRGATE_side = ENC [neighboring_TRGATE_TEMP] AA_v_edges < MAXIMUM_2nd_DummySpace/2 ABUT>0<90 OPPOSITE EXCLUDE SHIELDED
 neighboring_TRGATE_bulk = TRGATE WITH EDGE neighboring_TRGATE_side
 neighboring_TRGATE = neighboring_TRGATE_bulk AND GT

 neighboring_TRGATE_side_all = (neighboring_TRGATE TOUCH EDGE neighboring_TRGATE_side) NOT TOUCH OUTSIDE EDGE GTMK2  //;exclude the 1st GT in L-shape-AA corner
 neighboring_TRGATE_side_070 = neighboring_TRGATE_side_all TOUCH EDGE TRGATE_LE_GT_70
 neighboring_TRGATE_CheckAll = (EXPAND EDGE neighboring_TRGATE_side_all OUTSIDE BY MIMIMUM_2nd_DummySpace) OR (EXPAND EDGE neighboring_TRGATE_side_070 OUTSIDE BY MAXIMUM_2nd_DummySpace)
 err1 = (P2 INTERACT neighboring_TRGATE_CheckAll) NOT (OR P2_W_048 P2_W_068)
 err1 NOT INSIDE SealR_NOT_BULK
}

Q: P2 INTERACT DG is not allowed
A: 
P2_R_3 {
@ P2 INTERACT DG is not allowed
 err1 = P2 INTERACT DG
 err1 NOT INSIDE SealR_NOT_BULK
}

Q: ALL_GT line end (width <= 0.024um) must fully INTERACT P2
A: 
P2_R_4 {
@ ALL_GT line end (width <= 0.024um) must fully INTERACT P2
 chk_ALL_GT = LENGTH ALL_GT_convex_90_90_edge <= 0.024
 err1 = (chk_ALL_GT NOT COIN EDGE P2) NOT INSIDE EDGE P2
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

Q: (P2 not INTERACT ALL_GT) is not allowed, except OCOVL region
A: 
P2_R_5 {
@ (P2 not INTERACT ALL_GT) is not allowed, except OCOVL region
 err1 = P2 NOT INTERACT ALL_GT
 err1 NOT INSIDE OCOVL
}

Q: Any vertex of P2 INTERACT AOP_GT is not allowed
A: 
P2_R_6 {
@ Any vertex of P2 INTERACT AOP_GT is not allowed
 err1 = P2_v_edges NOT OUTSIDE EDGE AOP_GT  //;To reduce runtime
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

VARIABLE P2_R_7_P2Length 3.1

P2_and_GT = P2 AND AOP_GT
P2_l_gt_max = P2 ENCLOSE RECTANGLE 0.005 P2_R_7_P2Length ORTHOGONAL ONLY
P2_l_gt_max_and_GT = P2_l_gt_max AND AOP_GT

AOP_GT_NOT_P2_l_gt_max = (AOP_GT INTERACT P2_l_gt_max_and_GT) NOT P2
AOP_GT_NOT_P2_l_gt_max_good = (AOP_GT_NOT_P2_l_gt_max INTERACT M0G) INTERACT GTMK1

Q: Floating AOP_GT must be placed beside P2 edge if P2 length >= 3.1um
    Floating AOP_GT definition: (AOP_GT NOT P2) NOT INTERACT M0G
    Except the ((floating AOP_GT interact M0G) INTERACT GTMK1)
A: 
P2_R_7 {
@ Floating AOP_GT must be placed beside P2 edge if P2 length >= 3.1um
@ Floating AOP_GT definition: (AOP_GT NOT P2) NOT INTERACT M0G
@ Except the ((floating AOP_GT interact M0G) INTERACT GTMK1)
 P2_has_2_GT = (P2_l_gt_max NOT P2_l_gt_max_and_GT) INTERACT P2_l_gt_max_and_GT >= 2
 P2_has_1_GT = (P2_l_gt_max NOT P2_l_gt_max_and_GT) INTERACT P2_l_gt_max_and_GT < 2
 P2_and_2_GT = (P2_l_gt_max_and_GT INTERACT P2_has_2_GT) NOT INTERACT P2_has_1_GT //; inner intersecting area
 P2_and_1_GT = (P2_l_gt_max_and_GT INTERACT P2_has_1_GT) NOT INTERACT P2_and_2_GT
 AOP_GT_float = AOP_GT_NOT_P2_l_gt_max NOT INTERACT M0G
 AOP_GT_float_non = AOP_GT_NOT_P2_l_gt_max INTERACT M0G
 AOP_GT_float_non_P2 = P2_and_GT INTERACT AOP_GT_float_non

 P2_not_GT_beside_est = (P2_has_1_GT NOT INTERACT AOP_GT_float) INTERACT AOP_GT_float_non_P2
 P2_and_GT_beside_est = P2_and_GT INTERACT P2_not_GT_beside_est
 P2_and_GT_beside_est_v_edges = P2_and_GT_beside_est COIN EDGE P2_not_GT_beside_est
 err1_TMP = P2_and_GT_beside_est OR (EXPAND EDGE P2_and_GT_beside_est_v_edges OUTSIDE BY 0.01)
 err1 = err1_TMP NOT INTERACT AOP_GT_NOT_P2_l_gt_max_good
 err1 NOT INSIDE SealR_NOT_BULK
}

//SN

Q: SP and SN interact the same ALL_AA is not allowed, except DIOMK2 region
A: 
SN_R_1 {
@ SP and SN interact the same ALL_AA is not allowed, except DIOMK2 region
 err1 = (ALL_AA INTERACT SN) INTERACT SP
 err1 NOT INSIDE DIOMK2  //; please refer GATED.R.4
}

Q: SN and SP overlap is not allowed
A: 
SN_R_2 {
@ SN and SP overlap is not allowed
 err1 = AND SN SP
 err1 NOT INSIDE SealR_NOT_BULK
}

//M0DMP

Q: M0DMP INTERACT M0 is not allowed
A: 
M0DMP_R_1 {
@ M0DMP INTERACT M0 is not allowed
 err1 = M0DMP NOT OUTSIDE EDGE M0
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

//M0GDMP

Q: M0GDMP INTERACT M0G or P2 is not allowed
A: 
M0GDMP_R_1 {
@ M0GDMP INTERACT M0G or P2 is not allowed
 err1 = M0GDMP INTERACT (OR P2 M0G)
 err1 NOT INSIDE SealR_NOT_BULK
}

Q: M0GDMP INTERACT AA or GT is not allowed
A: 
M0GDMP_R_2 {
@ M0GDMP INTERACT AA or GT is not allowed
 err1 = M0GDMP INTERACT AA_OR_GT
 err1 NOT INSIDE SealR_NOT_BULK
}


//M0

Q: ALL_M0 must be rectangular and orthogonal to grid, except MARKS region
A: 
M0_R_1 {
@ ALL_M0 must be rectangular and orthogonal to grid, except MARKS region
 err1 = (NOT RECTANGLE ALL_M0 ORTHOGONAL ONLY) NOT MARKS
 err1 NOT INSIDE SealR_NOT_BULK
}

Q: ALL_M0 must be GATE poly direction and parallel to GT, except OCOVL region
A: 
M0_R_2 {
@ ALL_M0 must be GATE poly direction and parallel to GT, except OCOVL region
 waive_bar = (DONUT ALL_M0) INSIDE MARKS
 err1 = (ANGLE ALL_M0_L_edges != 90) NOT COIN EDGE waive_bar
 err1 NOT INSIDE EDGE OCOVL
}

Q: M0 (width = 0.04/0.042um) overlap with (DG OR NW resistor) is not allowed
A: 
M0_R_3 {
@ M0 (width = 0.04/0.042um) overlap with (DG OR NW resistor) is not allowed
 err1 = M0_040_042 AND DG_RESNW
 err2 = (M0 INTERACT DG_RESNW) NOT (M0_054 INTERACT DG_RESNW)
 err3 = (M0 INTERACT AA_NWR) NOT (M0_054 INTERACT AA_NWR) //;M0_040 can be used for NW resistor terminal

 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
}

ALL_M0_040_L_eqlt_150 = ALL_M0_040 NOT WITH EDGE (LENGTH ALL_M0_L_edges > 0.148)
ALL_M0_040_042_L_eqlt_150 = ALL_M0_040_042 NOT WITH EDGE (LENGTH ALL_M0_L_edges > 0.148)

Q: The number of ALL_M0 (width = 0.04/0.042um and at least one ALL_M0 length <= 0.148um) in one group >= 5
    ALL_M0 group definition:
    1) ALL_M0 space <= 0.066um
    2) ALL_M0 PRL >= 0.065um
A: 
M0_R_4 {
@ The number of ALL_M0 (width = 0.04/0.042um and at least one ALL_M0 length <= 0.148um) in one group >= 5
@ ALL_M0 group definition:
@ 1) ALL_M0 space <= 0.066um
@ 2) ALL_M0 PRL >= 0.065um
@ DRC flags ((ALL_M0 SIZING 0.043um) SIZING -0.043um) in ALL_M0 short side direction
 M0_EXP_all = (EXPAND EDGE ALL_M0_W_edges OUTSIDE BY 0.043) OR ALL_M0_040_042
 M0_EXP_all_END = (LENGTH M0_EXP_all == 0.04) OR EDGE (LENGTH M0_EXP_all == 0.042)
 M0_EXP_all_SRK = M0_EXP_all NOT (EXPAND EDGE M0_EXP_all_END INSIDE BY 0.043)

 M0_EXP_sps = EXT M0_EXP_all_SRK <= 0.066 ABUT<90 OPPOSITE REGION
 M0_EXP_sps_EDG = EXT [M0_EXP_all_SRK] <= 0.066 ABUT<90 OPPOSITE
 M0_EXP_sps_PRL = M0_EXP_sps WITH EDGE (LENGTH M0_EXP_sps_EDG < 0.065)
 M0_EXP_grp_TMP = (M0_EXP_sps NOT M0_EXP_sps_PRL) OR ALL_M0_040_042
 err1 = (M0_EXP_grp_TMP INTERACT ALL_M0_040_042_L_eqlt_150) INTERACT ALL_M0_040_042 >= 1 < 5
 err1 NOT INSIDE SealR_NOT_BULK
}

Q: (AOP_M0 INTERACT AOP_GT) is not allowed
A: 
M0_R_6 {
@ (AOP_M0 INTERACT AOP_GT) is not allowed
 err1 = (AOP_M0 AND AOP_GT) OR (EXPAND EDGE (AOP_M0 COIN EDGE AOP_GT) BY 0.001)
 err1 NOT INSIDE SealR_NOT_BULK
}

Q: ((AA INTERACT GT) NOT GT) must INTERACT M0, except INST region
A: 
M0_R_7 {
@ ((AA INTERACT GT) NOT GT) must INTERACT M0, except INST region
 err1 = ((AA_INTERACT_GT NOT GT) NOT INSIDE INST) NOT INTERACT M0
 err1 NOT INSIDE INST
}

Q: Only one M0 is allowed on single S/D region, except ESDIO1 and ESDIO2 regions
A: 
M0_R_8 {
@ Only one M0 is allowed on single S/D region, except ESDIO1 and ESDIO2 regions
 except_area = COPY ESDIO_ALL
 err1 = SD INTERACT M0 > 1
 err1 NOT INSIDE except_area

 A = SD INTERACT M0
 B = M0 INTERACT A
 C = (M0_L_edges TOUCH EDGE B) NOT INSIDE EDGE except_area
 D = GTEIAA NOT INSIDE EDGE except_area
 C_90 = ANGLE C == 90
 C_00 = ANGLE C == 0
 D_90 = ANGLE D == 90
 D_00 = ANGLE D == 0
 D_random = ANGLE D > 0 < 90

 err2 = DFM PROPERTY SD C_00 D_90 OVERLAP ABUT ALSO MULTI [-= LENGTH(C_00)/LENGTH(D_90)] > 0
 err3 = DFM PROPERTY SD C_90 D_00 OVERLAP ABUT ALSO MULTI [-= LENGTH(C_90)/LENGTH(D_00)] > 0
 err4 = DFM PROPERTY SD C_00 D_random OVERLAP ABUT ALSO MULTI [-= LENGTH(C_00)/LENGTH(D_random)] > 0
 err5 = DFM PROPERTY SD C_90 D_random OVERLAP ABUT ALSO MULTI [-= LENGTH(C_90)/LENGTH(D_random)] > 0
 err2 NOT INSIDE except_area
 err3 NOT INSIDE except_area
 err4 NOT INSIDE except_area
 err5 NOT INSIDE except_area
}

Q: M0 (width = 0.042um) must inside GT_P96
A: 
M0_R_9 {
@ M0 (width = 0.042um) must inside GT_P96
 err1 = M0_042 NOT GT_P96
 err1 NOT INSIDE SealR_NOT_BULK
}

M0_040_L_edges = M0_L_edges COIN EDGE M0_040
M0_040_L_edges_gt_1_pitch = EXT (M0_040_L_edges) M0 <= 0.120 ABUT<90 OPPOSITE EXCLUDE SHIELDED
M0_040_L_edges_eq_1_pitch = EXT [M0_040_L_edges] M0 <= 0.120 ABUT<90 OPPOSITE EXCLUDE SHIELDED
M0_040_L_edges_lt_3_pitch = (EXT [M0_040_L_edges] M0 < 0.300 ABUT<90 OPPOSITE EXCLUDE SHIELDED) NOT COIN EDGE M0_040_L_edges_eq_1_pitch

M0_040_042_L_edges = M0_L_edges COIN EDGE (OR M0_040 M0_042)
M0_040_042_L_edges_gt_1_pitch = EXT (M0_040_042_L_edges) M0 <= 0.120 ABUT<90 OPPOSITE EXCLUDE SHIELDED
M0_040_042_L_edges_eq_1_pitch = EXT [M0_040_042_L_edges] M0 <= 0.120 ABUT<90 OPPOSITE EXCLUDE SHIELDED
M0_040_042_L_edges_lt_3_pitch = (EXT [M0_040_042_L_edges] M0 < 0.300 ABUT<90 OPPOSITE EXCLUDE SHIELDED) NOT COIN EDGE M0_040_042_L_edges_eq_1_pitch

M0_054_L_edges = M0_L_edges COIN EDGE M0_054
M0_054_L_edges_gt_1_pitch = EXT (M0_054_L_edges) M0 <= 0.200 ABUT<90 OPPOSITE EXCLUDE SHIELDED
M0_054_L_edges_eq_1_pitch = EXT [M0_054_L_edges] M0 <= 0.200 ABUT<90 OPPOSITE EXCLUDE SHIELDED
M0_054_L_edges_lt_3_pitch = (EXT [M0_054_L_edges] M0 < 0.360 ABUT<90 OPPOSITE EXCLUDE SHIELDED) NOT COIN EDGE M0_054_L_edges_eq_1_pitch

adjacent_M0 = (OR M0_040 M0_042) INSIDE EDGE (AA_SD_all INTERACT edge_gate)
adjacent_sd = ((((AA_SD_all INTERACT edge_gate) NOT M0) OR (edge_gate AND AA)) WITH EDGE adjacent_M0) NOT TAP_RAW
adjacent_sd_v_edges = AA_v_edges COIN EDGE adjacent_sd
adjacent_M0_end_inside_AA_EXP = EXPAND EDGE (M0_W_edges COIN EDGE (CONVEX EDGE adjacent_sd == 0)) OUTSIDE BY 0.010

M0_R_11_waive_one_M0_pkup = M0 INTERACT ((TAP_RAW INTERACT M0 == 1) INTERACT GT == 2)

Q: It's not recommended to use M0 P-to-N routing with M0G on adjacent GT, except INST
    DRC flag condition:
    (M0 not M0C) electrically connect both P+AA and N+AA and with M0G on adjacent GT
    DRC waive if M0G and M0 PRL < 0um in GATE poly direction
A: 
M0_R_10_DFM1 {
@ It's not recommended to use M0 P-to-N routing with M0G on adjacent GT, except INST
@ DRC flag condition:
@ (M0 not M0C) electrically connect both P+AA and N+AA and with M0G on adjacent GT
@ DRC waive if M0G and M0 PRL < 0um in GATE poly direction
 chk_po = GT_0 AND M0G
 chk_mn = (M0_NOT_M0C INTERACT NACT) INTERACT PACT
 chk_mn_v_edges = ANGLE ((M0_NOT_M0C INTERACT NACT) INTERACT PACT) == 90
 err1 = chk_mn WITH EDGE (EXT [chk_mn_v_edges] chk_po < 0.05 ABUT<90 OPPOSITE)
 err1 NOT INSIDE INST
}

Q: It is not allowed M0 (M0 width = 0.04/0.042um) ΔL > 0.1um, except single M0 pickup case
    DRC highlight M0 segment (length > 0.1um) without an adjacent M0
A: 
M0_R_11_DFM1 {
@ It is not allowed M0 (M0 width = 0.04/0.042um) ΔL > 0.1um, except single M0 pickup case
@ DRC highlight M0 segment (length > 0.1um) without an adjacent M0
 iso_m0_a = INT M0_040_042_L_edges_eq_1_pitch M0_040_042_L_edges_lt_3_pitch >= 0.040 <= 0.042 ABUT<90 OPPOSITE REGION
 iso_m0_b = INT M0_040_042_L_edges_gt_1_pitch >= 0.040 <= 0.042 ABUT<90 OPPOSITE REGION
 err1 = (iso_m0_a ENCLOSE RECTANGLE 0.002 0.100+GLOBAL_TOLERANCE ORTHOGONAL ONLY) NOT M0_R_11_waive_one_M0_pkup
 err2 = (iso_m0_b ENCLOSE RECTANGLE 0.002 0.100+GLOBAL_TOLERANCE ORTHOGONAL ONLY) NOT M0_R_11_waive_one_M0_pkup
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

Q: It is not allowed the outmost (M0 on AA) (M0 width = 0.04/0.042um) without an adjacent (M0 on STI)
    DRC searching region: 0~0.12um from AA in S/D direction, except pick-up and DSTR region
A: 
M0_R_12_DFM1 {
@ It is not allowed the outmost (M0 on AA) (M0 width = 0.04/0.042um) without an adjacent (M0 on STI)
@ DRC searching region: 0~0.12um from AA in S/D direction, except pick-up and DSTR region
 waive_end_cut_aa = LENGTH (ENC adjacent_M0_end_inside_AA_EXP [adjacent_sd_v_edges] < 0.100 ABUT<90 OPPOSITE EXCLUDE SHIELDED) <= 0.007 //;based on M0.EX.1
 waive_l_aa = LENGTH (ANGLE (CONVEX EDGE AA == 1) == 90) <= 0.100 //;waive L-shape corner M0 of good M0_R_11_DFM1
 err1 = ((EXT (adjacent_sd_v_edges) M0 <= 0.120 ABUT<90 OPPOSITE MEASURE ALL) NOT COIN EDGE waive_l_aa) NOT COIN EDGE waive_end_cut_aa
 err1 NOT INSIDE EDGE DSTR
}


//M0C

Q: (ALL_M0 AND (ALL_AA (expanding horizontal edge by -0.01um))) overlap with ALL_M0C is not allowed, except INST region
A: 
M0C_R_1 {
@ (ALL_M0 AND (ALL_AA (expanding horizontal edge by -0.01um))) overlap with ALL_M0C is not allowed, except INST region
 chk_M0 = ALL_M0 AND (SHRINK ALL_AA TOP BY 0.01 BOTTOM BY 0.01)
 err1 = chk_M0 AND ALL_M0C
 err1 NOT INSIDE INST
}

Q: Any vertex of AOP_M0C inside ALL_M0 is not allowed, except OCOVL region
A: 
M0C_R_2 {
@ Any vertex of AOP_M0C inside ALL_M0 is not allowed, except OCOVL region
 err1 = AOP_M0C_v_edges NOT OUTSIDE EDGE ALL_M0
 err1 NOT INSIDE EDGE OCOVL
}

Q: ALL_M0C point touch is not allowed
A: 
M0C_R_3 {
@ ALL_M0C point touch is not allowed
 err1 = EXT ALL_M0C < 0.001 ABUT<90 SINGULAR REGION
 err1 NOT INSIDE SealR_NOT_BULK
}

ltu_M0C = NOT RECTANGLE ALL_M0C
ltu_M0C_convex_90_90_v_edges = ANGLE (ltu_M0C CONVEX EDGE == 2) == 90
ltu_M0C_convex_90_270_v_edges = ANGLE (ltu_M0C CONVEX EDGE == 1) == 90

VARIABLE M0C_R_4_W1 0.052
VARIABLE M0C_R_4_W2 0.108
VARIABLE M0C_R_4_JOG1 M0C_R_4_W2-M0C_R_4_W1+0.001
VARIABLE M0C_R_4_JOG2 M0C_R_4_W2-M0C_R_4_W1+0.002

Q: ALL_M0C must be a rectangle orthogonal to grid or single L-, T-, U-, or combined L/T/U shape and at least two ALL_M0 INTERACT every segment of single L-, T-, U-, or combined L/T/U shape M0C. Single L-, T-, U-, or combined L/T/U shape M0C jog must = 0.056/0um or 0.057/0.001um or 0.058/0.002um for M0C width = 0.052/0.108um, except OCOVL region
A: 
M0C_R_4 {
@ ALL_M0C must be a rectangle orthogonal to grid or single L-, T-, U-, or combined L/T/U shape and at least two ALL_M0 INTERACT every segment of single L-, T-, U-, or combined L/T/U shape M0C. Single L-, T-, U-, or combined L/T/U shape M0C jog must = 0.056/0um or 0.057/0.001um or 0.058/0.002um for M0C width = 0.052/0.108um, except OCOVL region
//;all segment must combined with M0C width = 0.052/0.108um
//;rectangular M0C with one M0 is ok
//;pure L with >= 2 ALL_M0 on any one of the segment is ok
//;non-pure L: each segment must interact with >= 2 ALL_M0
//;each jog length must = 0.058/0um or 0.059/0.001um or 0.060/0.002um
//;each segment with >= 1 jog must interact with >= 2 ALL_M0
 ltu_052_branch = ltu_M0C AND M0C_052
 ltu_108_branch = (ltu_M0C NOT ltu_052_branch) AND M0C_108
 ltu_v_edges_eq_052 = LENGTH ltu_M0C_convex_90_90_v_edges == M0C_R_4_W1
 ltu_v_edges_eq_108 = LENGTH ltu_M0C_convex_90_90_v_edges == M0C_R_4_W2
 ltu_v_edges_eq_all = OR EDGE ltu_v_edges_eq_052 ltu_v_edges_eq_108

 ltu_good_edges_jog = (ltu_052_branch TOUCH EDGE ltu_108_branch) NOT COIN EDGE ltu_108_branch
 ltu_good_edges_108 = (ltu_108_branch TOUCH EDGE ltu_052_branch) LENGTH == M0C_R_4_W2
 ltu_good_edges_001 = LENGTH ltu_good_edges_jog == 0.001
 ltu_good_edges_002 = LENGTH ltu_good_edges_jog == 0.002
 ltu_good_edges_all = OR EDGE ltu_good_edges_108 (ltu_good_edges_001 OR EDGE ltu_good_edges_002)
 ltu_good_width_all = ((ltu_M0C INTERACT ltu_052_branch) INTERACT ltu_108_branch) NOT INTERACT (ltu_M0C NOT (OR M0C_052 M0C_108))
 ltu_good_width_052 = ltu_052_branch INTERACT ltu_good_width_all
 ltu_good_width_108 = ltu_108_branch INTERACT ltu_good_width_all

//;whole branch with jog
 ltu_108_branch_stagger_a = (ltu_good_width_108 WITH EDGE (LENGTH ltu_M0C_convex_90_270_v_edges >= M0C_R_4_JOG1 <= M0C_R_4_JOG2) == 1) WITH EDGE ltu_v_edges_eq_108
 ltu_108_branch_stagger_b = ltu_good_width_108 WITH EDGE (LENGTH ltu_M0C_convex_90_270_v_edges >= M0C_R_4_JOG1 <= M0C_R_4_JOG2) == 2
 ltu_108_branch_stagger = OR ltu_108_branch_stagger_a ltu_108_branch_stagger_b

 ltu_052_branch_stagger_a = (ltu_good_width_052 WITH EDGE (LENGTH ltu_M0C_convex_90_270_v_edges <= 0.002) == 1) WITH EDGE ltu_v_edges_eq_052
 ltu_052_branch_stagger_b = ltu_good_width_052 WITH EDGE (LENGTH ltu_M0C_convex_90_270_v_edges <= 0.002) == 2
 ltu_052_branch_stagger = OR ltu_052_branch_stagger_a ltu_052_branch_stagger_b

//;whole branch without any jog
 ltu_orth_part_a = (ltu_good_width_all INTERACT ltu_108_branch_stagger) NOT ltu_108_branch_stagger
 ltu_orth_part_b = (ltu_good_width_all INTERACT ltu_052_branch_stagger) NOT ltu_052_branch_stagger

 err1 = ltu_M0C NOT (OR M0C_052 M0C_108) //;segment width != 0.052/108
 err1 NOT INSIDE OCOVL

 err2 = (ltu_M0C COIN EDGE (M0C_v_edges COIN EDGE (OR M0C_052 M0C_108))) NOT COIN EDGE (ltu_v_edges_eq_all OR EDGE ltu_good_edges_all) //;segment width != 0.052/108/0.001/0.002
 err2 NOT INSIDE EDGE OCOVL

 err3 = ltu_108_branch WITH EDGE (LENGTH ltu_M0C_convex_90_270_v_edges < 0.056)  //;the 0.108um segment jog length != 0.056/0.060
 err3 NOT INSIDE OCOVL

 err4 = ltu_good_width_all NOT (ltu_good_width_all INTERACT ALL_M0 >= 2)  //;not interact any M0
 err4 NOT INSIDE OCOVL

 err5 = (ltu_good_width_052 INTERACT ALL_M0 == 1) OR (ltu_good_width_108 INTERACT ALL_M0 == 1)  //;each segment interact one M0
 err5 NOT INSIDE OCOVL

 err6 = ltu_108_branch_stagger NOT (ltu_108_branch_stagger INTERACT ALL_M0 >= 2)
 err6 NOT INSIDE OCOVL

 err7 = ltu_052_branch_stagger NOT (ltu_052_branch_stagger INTERACT ALL_M0 >= 2)
 err7 NOT INSIDE OCOVL

 err8 = ltu_orth_part_a NOT (ltu_orth_part_a INTERACT ALL_M0 >= 2)
 err9 = ltu_orth_part_b NOT (ltu_orth_part_b INTERACT ALL_M0 >= 2)
 err8 NOT INSIDE OCOVL
 err9 NOT INSIDE OCOVL

 err0 = NOT RECTANGLE (ALL_M0C NOT M0C) ORTHOGONAL ONLY
 err0 NOT INSIDE OCOVL

 ALL_M0C_h_edges_corner = ALL_M0C_h_edges COIN EDGE (EXT [ALL_M0C] < 0.0001 ABUT==90 INTERSECTING ONLY)
 ALL_M0C_h_edges_insideExtend = EXPAND EDGE ALL_M0C_h_edges_corner INSIDE BY 0.001
 ALL_M0C_h_edges_insideExtend_T = ALL_M0C_h_edges_insideExtend TOUCH ((GROW ALL_M0C TOP BY 0.001) NOT ALL_M0C)
 ALL_M0C_h_edges_insideExtend_B = ALL_M0C_h_edges_insideExtend TOUCH ((GROW ALL_M0C BOTTOM BY 0.001) NOT ALL_M0C)
 ALL_M0C_JOINT_A = ENC ALL_M0C_h_edges_insideExtend_T ALL_M0C_h_edges < 0.2 OPPOSITE REGION EXCLUDE SHIELDED
 ALL_M0C_JOINT_B = ENC ALL_M0C_h_edges_insideExtend_B ALL_M0C_h_edges < 0.2 OPPOSITE REGION EXCLUDE SHIELDED
 ALL_M0C_TP = ltu_M0C NOT (OR ALL_M0C_JOINT_A ALL_M0C_JOINT_B ALL_M0C_h_edges_insideExtend)
 err11 = OR (ALL_M0C_TP NOT INTERACT ALL_M0) (ALL_M0C_TP INTERACT ALL_M0 < 2)
 err11 NOT INSIDE OCOVL
}

Q: DUM_M0C must be a rectangle orthogonal to grid
A: 
M0C_R_5 {
@ DUM_M0C must be a rectangle orthogonal to grid
 err1 = NOT RECTANGLE DUM_M0C ORTHOGONAL ONLY
 err1 NOT INSIDE SealR_NOT_BULK
}

Q: AOP_M0 (width = 0.04/0.042um, length <= 0.17um) line-end must interact AOP_M0C, except INST region
A: 
M0C_R_6 {
@ AOP_M0 (width = 0.04/0.042um, length <= 0.17um) line-end must interact AOP_M0C, except INST region
 chk_M0_040 = CONVEX EDGE AOP_M0 ANGLE1 == 90 LENGTH1 <= 0.17 ANGLE2 == 90 LENGTH2 <= 0.17 WITH LENGTH == 0.040
 chk_M0_042 = CONVEX EDGE AOP_M0 ANGLE1 == 90 LENGTH1 <= 0.17 ANGLE2 == 90 LENGTH2 <= 0.17 WITH LENGTH == 0.042
 err1 = (OR EDGE chk_M0_040 chk_M0_042) OUTSIDE EDGE AOP_M0C
 err1 NOT INSIDE EDGE INST
}

Q: M0C (width = 0.051um) must interact RSPMK1
A: 
M0C_R_7 {
@ M0C (width = 0.051um) must interact RSPMK1
 err1 = M0C_051 NOT INTERACT RSPMK1
 err1 NOT INSIDE SealR_NOT_BULK
}

Q: M0C must interact M0, floating M0C is not allowed, except OCOVL region
A: 
M0C_R_8 {
@ M0C must interact M0, floating M0C is not allowed, except OCOVL region
 err1 = M0C NOT INTERACT M0
 err1 NOT INSIDE OCOVL
}


//M0G

Q: ALL_M0G (width = 0.04um) must be horizontal
A: 
M0G_R_1 {
@ ALL_M0G (width = 0.04um) must be horizontal
 err1 = INT [ALL_M0G_v_edges] == 0.04 ABUT<90 OPPOSITE
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

Q: M0G (width/length = 0.05/0.057~0.058, 0.05/0.06~0.061, 0.088/0.102~0.104, 0.088/0.108~0.11um) must be horizontal direction
A: 
M0G_R_2a {
@ M0G (width/length = 0.05/0.057~0.058, 0.05/0.06~0.061, 0.088/0.102~0.104, 0.088/0.108~0.11um) must be horizontal direction
 bad_1 = ANGLE (LENGTH M0G_W050_L057 == 0.057) == 90
 bad_2 = ANGLE (LENGTH M0G_W050_L058 == 0.058) == 90
 bad_3 = ANGLE (LENGTH M0G_W050_L060 == 0.060) == 90
 bad_4 = ANGLE (LENGTH M0G_W050_L061 == 0.061) == 90
 bad_5 = ANGLE (LENGTH M0G_W088_L102_To_L104 >= 0.102 <= 0.104) == 90
 bad_6 = ANGLE (LENGTH M0G_W088_L108_To_L110 >= 0.108 <= 0.110) == 90
 err1 = OR EDGE ((bad_1 OR EDGE bad_2) OR EDGE (bad_3 OR EDGE bad_4)) (bad_5 OR EDGE bad_6)
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

Q: M0G (width/length = 0.051~0.053/0.09~0.091, 0.054~0.055/0.09~0.091, 0.06/0.095~0.096um) must be vertical direction
A: 
M0G_R_2b {
@ M0G (width/length = 0.051~0.053/0.09~0.091, 0.054~0.055/0.09~0.091, 0.06/0.095~0.096um) must be vertical direction
 bad_1 = ANGLE (LENGTH M0G_W051To053_L090To091_W054To055_L090To091 >= 0.09 <= 0.091) == 0
 bad_2 = ANGLE (LENGTH (OR M0G_W060_L095 M0G_W060_L096) >= 0.095 <= 0.096) == 0
 err1 = bad_1 OR EDGE bad_2
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

Q: M0G interact with AA is not allowed, except M0G (INTERACT (M0 AND AA)) and INST region
A: 
M0G_R_3 {
@ M0G interact with AA is not allowed, except M0G (INTERACT (M0 AND AA)) and INST region
 err1 = (M0G NOT INTERACT M0_AND_AA) INTERACT AA
 err1 NOT INSIDE INST
}

Q: M0G (width = 0.06um) interact with AA is not allowed, except pickup and VARMOS region
A: 
M0G_R_3a {
@ M0G (width = 0.06um) interact with AA is not allowed, except pickup and VARMOS region
 err1 = M0G_060 INTERACT (AA NOT (OR TAP_RAW VARMOS))
 err1 NOT INSIDE SealR_NOT_BULK
}

Q: ALL_M0G must be rectangular, and orthogonal to grid
A: 
M0G_R_4 {
@ ALL_M0G must be rectangular, and orthogonal to grid
 err1 = NOT RECTANGLE ALL_M0G ORTHOGONAL ONLY
 err1 NOT INSIDE SealR_NOT_BULK
}

Q: M0G (width/length = 0.05/0.057~0.058, 0.05/0.06~0.061um) and M0G (width/length = 0.051~0.053/0.09~0.091, 0.054~0.055/0.09~0.091um and INTERACT AA) must INTERACT both GT (width <= 0.024um) and (M0 NOT M0C) (M0 width = 0.04/0.042um)
A: 
M0G_R_5 {
@ M0G (width/length = 0.05/0.057~0.058, 0.05/0.06~0.061um) and M0G (width/length = 0.051~0.053/0.09~0.091, 0.054~0.055/0.09~0.091um and INTERACT AA) must INTERACT both GT (width <= 0.024um) and (M0 NOT M0C) (M0 width = 0.04/0.042um)
 out1 = (M0G_W050_L057_L058 INTERACT GT_eqlt_024) INTERACT M0_NOT_M0C_040_042
 out2 = (M0G_W050_L060_L061 INTERACT GT_eqlt_024) INTERACT M0_NOT_M0C_040_042
 err1 = M0G_W050_L057_L058 NOT out1
 err2 = M0G_W050_L060_L061 NOT out2

 out3_TMP = M0G_W051To053_L090To091_W054To055_L090To091 INTERACT AA
 out3 = (out3_TMP INTERACT GT_eqlt_024) INTERACT M0_NOT_M0C_040_042
 err3 = out3_TMP NOT out3

 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
}

Q: The maximum number of M0G (width/length = 0.05/0.057~0.058, 0.05/0.06~0.061um) within M0G su 0.0615um, except INST region <= 2
A: 
M0G_R_6 {
@ The maximum number of M0G (width/length = 0.05/0.057~0.058, 0.05/0.06~0.061um) within M0G su 0.0615um, except INST region <= 2
 chk_M0G = OR M0G_W050_L057 M0G_W050_L058 M0G_W050_L060 M0G_W050_L061
 err1 = ((SIZE M0G_W050_L057_L058 BY 0.0615) INTERACT chk_M0G > 2) ENCLOSE (chk_M0G NOT INSIDE INST)
 err2 = ((SIZE M0G_W050_L060_L061 BY 0.0615) INTERACT chk_M0G > 2) ENCLOSE (chk_M0G NOT INSIDE INST)
 err1 NOT INSIDE INST
 err2 NOT INSIDE INST
}

Q: The number of M0G (width/length = 0.06/0.095~0.096um) within M0G su 0.21um. >= 2
A: 
M0G_R_6_1 {
@ The number of M0G (width/length = 0.06/0.095~0.096um) within M0G su 0.21um. >= 2
 err1 = (SIZE M0G_W060_L095_L096 BY 0.21) INTERACT M0G_W060_L095_L096 < 2
 err1 NOT INSIDE SealR_NOT_BULK
}

Q: M0G (width = 0.05um) INTERACT GT (width >= 0.07um) is not allowed
A: 
M0G_R_7 {
@ M0G (width = 0.05um) INTERACT GT (width >= 0.07um) is not allowed
 err1 = M0G_050 INTERACT GT_eqgt_070
 err1 NOT INSIDE SealR_NOT_BULK
}

Q: M0G (width/length = 0.088/0.102~0.104, 0.088/0.108~0.11um) must overlap AA
A: 
M0G_R_8 {
@ M0G (width/length = 0.088/0.102~0.104, 0.088/0.108~0.11um) must overlap AA
 err1 = M0G_W088_L102_To_L104 NOT INTERACT (M0G_W088_L102_To_L104 AND AA)
 err2 = M0G_W088_L108_To_L110 NOT INTERACT (M0G_W088_L108_To_L110 AND AA)
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

Q: (M0G (width/length = 0.088/0.102~0.104, 0.088/0.108~0.11um) NOT M0) interact V0 is not allowed
A: 
M0G_R_9 {
@ (M0G (width/length = 0.088/0.102~0.104, 0.088/0.108~0.11um) NOT M0) interact V0 is not allowed
 err1 = V0 AND ((M0G_W088_L102_To_L104 NOT M0) INTERACT V0)
 err2 = V0 AND ((M0G_W088_L108_To_L110 NOT M0) INTERACT V0)
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

Q: M0G (width/length = 0.088/0.102~0.104, 0.088/0.108~0.11um) must INTERACT two (M0 NOT M0C) (M0 width = 0.04/0.042um)
A: 
M0G_R_10 {
@ M0G (width/length = 0.088/0.102~0.104, 0.088/0.108~0.11um) must INTERACT two (M0 NOT M0C) (M0 width = 0.04/0.042um)
 err1 = (M0G_W088_L102_To_L104 INTERACT M0_NOT_M0C_040_042 != 2) OR (M0G_W088_L102_To_L104 NOT INTERACT M0_NOT_M0C_040_042)
 err2 = (M0G_W088_L108_To_L110 INTERACT M0_NOT_M0C_040_042 != 2) OR (M0G_W088_L108_To_L110 NOT INTERACT M0_NOT_M0C_040_042)
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

M0G_W060_VERTICAL = M0G_060 WITH EDGE (LENGTH M0G_v_edges > 0.06)
M0G_W060_VERTICAL_with_M0 = M0G_W060_VERTICAL INTERACT M0_NOT_M0C
M0G_W060_VERTICAL_with_M0_centerline = DFM COPY (DFM SPACE M0G_W060_VERTICAL_with_M0 <= 0.096 BY INT HORIZONTAL) CENTERLINE

Q: M0G (width = 0.06um) extension outside of (M0 NOT M0C) must be equal at both side of M0, when M0G and M0 are both in vertical direction
A: 
M0G_R_11 {
@ M0G (width = 0.06um) extension outside of (M0 NOT M0C) must be equal at both side of M0, when M0G and M0 are both in vertical direction
 M0C_errorLayer = DFM SPACE (M0_NOT_M0C INTERACT M0G_W060_VERTICAL) <= 0.096 BY INT HORIZONTAL
 M0C_centerline = DFM COPY (DFM PROPERTY M0C_errorLayer [-= ABS(REMAINDER(EW(M0C_errorLayer), 0.002))] == 0) CENTERLINE
 err1 = M0G_W060_VERTICAL_with_M0_centerline NOT TOUCH EDGE M0C_centerline
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

M0G_W060_L096_with_GT = M0G_W060_L096 INTERACT GT_0
M0G_W060_L095_L096_with_GT = M0G_W060_L095_L096 INTERACT GT_0
M0G_W060_L096_with_GT_centerline = DFM COPY (DFM SPACE M0G_W060_L096_with_GT <= 0.096 BY INT HORIZONTAL) CENTERLINE
M0G_W060_L095_L096_with_GT_centerline = DFM COPY (DFM SPACE M0G_W060_L095_L096_with_GT <= 0.096 BY INT HORIZONTAL) CENTERLINE

Q: M0G (width/length = 0.06/0.095~0.096um) extension on (GT NOT P2) must be equal at both side of GT, when M0G and GT are both in vertical direction
A: 
M0G_R_12 {
@ M0G (width/length = 0.06/0.095~0.096um) extension on (GT NOT P2) must be equal at both side of GT, when M0G and GT are both in vertical direction
 GT_errorLayer = DFM SPACE (GT_0 INTERACT M0G_W060_L095_L096) <= 0.096 BY INT HORIZONTAL
 GT_centerline = DFM COPY (DFM PROPERTY GT_errorLayer [-= ABS(REMAINDER(EW(GT_errorLayer), 0.002))] == 0) CENTERLINE
 err1 = M0G_W060_L095_L096_with_GT_centerline NOT TOUCH EDGE GT_centerline
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

Q: M0G (width = 0.04/0.06um) must INTERACT at least one of the following options, except OCOVL region:
    1) two (GT NOT P2)
    2) two (M0 NOT M0C)
    3) one (M0 NOT M0C) and one (GT NOT P2)
    4) one V0 and one (M0 NOT M0C)
    5) one V0 and one (GT NOT P2)
    6) two V0
    7) one rectangle V0 and DIR (width <= 0.145um)
A: 
M0G_R_13 {
@ M0G (width = 0.04/0.06um) must INTERACT at least one of the following options, except OCOVL region:
@ 1) two (GT NOT P2)
@ 2) two (M0 NOT M0C)
@ 3) one (M0 NOT M0C) and one (GT NOT P2)
@ 4) one V0 and one (M0 NOT M0C)
@ 5) one V0 and one (GT NOT P2)
@ 6) two V0
@ 7) one rectangle V0 and DIR (width <= 0.145um)
 good_TYPE_1 = M0G_040_060 INTERACT GT_0 >= 2
 good_TYPE_2 = M0G_040_060 INTERACT M0_NOT_M0C >= 2
 good_TYPE_3 = (M0G_040_060 INTERACT M0_NOT_M0C) INTERACT GT_0

 good_TYPE_4_5_TMP = M0G_040_060 INTERACT V0
 good_TYPE_4 = good_TYPE_4_5_TMP INTERACT M0_NOT_M0C
 good_TYPE_5 = good_TYPE_4_5_TMP INTERACT GT_0
 good_TYPE_6 = good_TYPE_4_5_TMP INTERACT V0 >= 2
 good_TYPE_7 = (M0G_040_060 INTERACT RV0) NOT OUTSIDE (DIR WITH WIDTH <= 0.145)
 err1 = M0G_040_060 NOT (OR good_TYPE_1 good_TYPE_2 good_TYPE_3 good_TYPE_4 good_TYPE_5 good_TYPE_6 good_TYPE_7)
 err1 NOT INSIDE OCOVL
}

Q: M0G INTERACT GATE is not allowed, except in pick-up, MARKG, MARKS, DSTR, DMPNP, DIOMK1, DIOMK2, VARMOS and M0G (width = 0.04/0.051~0.055/0.088um)
A: 
M0G_R_14 {
@ M0G INTERACT GATE is not allowed, except in pick-up, MARKG, MARKS, DSTR, DMPNP, DIOMK1, DIOMK2, VARMOS and M0G (width = 0.04/0.051~0.055/0.088um)
 waive_AREA = OR TAP_RAW MARKG MARKS DSTR DMPNP DIOMK1 DIOMK2 VARMOS
 waive_M0G = OR M0G_040 M0G_WIDTH_051_To_055 M0G_088
 check_M0G = ((M0G NOT INTERACT waive_M0G) NOT waive_AREA) NOT INTERACT TAP_RAW
 err1 = (check_M0G INTERACT GATE) NOT waive_AREA
 err1 NOT INSIDE SealR_NOT_BULK
}

Q: M0G interact with (DUM_GT NOT P2) is not allowed
A: 
M0G_R_15 {
@ M0G interact with (DUM_GT NOT P2) is not allowed
 err1 = M0G INTERACT DUM_GT_NOT_P2
 err1 NOT INSIDE SealR_NOT_BULK
}

Q: DOP_M0G overlap with M0G is not allowed
A: 
M0G_R_17 {
@ DOP_M0G overlap with M0G is not allowed
 err1 = DOP_M0G AND M0G
 err1 NOT INSIDE SealR_NOT_BULK
}


//V0

Q: 45-degree V0 and RV0 is not allowed, except V0 bar in MARKS/MARKG/INDMY/LOGO regions
A: 
V0_R_1 {
@ 45-degree V0 and RV0 is not allowed, except V0 bar in MARKS/MARKG/INDMY/LOGO regions
 err1 = ANGLE (V0 NOT MARKS_MARKG_INDMY_LOGO) > 44.5 < 45.5
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
Q: Single V0 is not allowed in "H-shape" M1, when:
    M1 has "H-shape" interacting with two metal holes:
    1. Both two holes length <= 4.5um and area <= 4.05um2
    2. The V0 overlaps the center metal bar of this "H-shape" M1
    3. The center metal bar length <= 0.9um and width <= 0.12um
A: 
V0_R_2 {
@ Single V0 is not allowed in "H-shape" M1, when:
@ M1 has "H-shape" interacting with two metal holes:
@ 1. Both two holes length <= 4.5um and area <= 4.05um2
@ 2. The V0 overlaps the center metal bar of this "H-shape" M1
@ 3. The center metal bar length <= 0.9um and width <= 0.12um
 // DRC doesn't check when one or more square V0 is also on H-shape M1 region
 hole_area_meet = AREA (HOLES M1 INNER) <= 4.05
 hole_area_meet_len = (hole_area_meet WITH EDGE (LENGTH hole_area_meet <= 0.9)) NOT WITH EDGE (LENGTH hole_area_meet > 4.5)
 hole_area_real = (hole_area_meet_len NOT ENCLOSE RECTANGLE 0.9+GLOBAL_TOLERANCE 4.5) NOT ENCLOSE RECTANGLE 0.9 4.5+GLOBAL_TOLERANCE
 hole_bars_len = M1 COIN EDGE hole_area_real
 // 
 hole_bars = INT hole_bars_len <= 0.12 ABUT<90 OPPOSITE REGION EXCLUDE SHIELDED
 hole_bars_real = hole_bars WITH EDGE (LENGTH hole_bars_len <= 0.9)
 hole_bars_vias_sq = V0N INTERACT ((hole_bars_real INTERACT hole_area_real == 2) NOT ENCLOSE RV0)
 err1 = hole_bars_real INTERACT hole_bars_vias_sq == 1
 err1 NOT INSIDE SealR_NOT_BULK
}

Q: V0 and RV0 overlap with (DUM_AA OR DUM_GT) is not allowed
A: 
V0_R_3 {
@ V0 and RV0 overlap with (DUM_AA OR DUM_GT) is not allowed
 err1 = AND V0 (DUM_AA OR DUM_GT)
 err1 NOT INSIDE SealR_NOT_BULK
}

Q: It's not allowed (V0 OR RV0) overlap with the M1 resistor
A: 
V0_R_5 {
@ It's not allowed (V0 OR RV0) overlap with the M1 resistor
 err1 = V0 AND M1RES
 err1 NOT INSIDE SealR_NOT_BULK
}

Q: Recommend space between a square V0 and another (V0 OR RV0 OR DUM_V0) < 4um to avoid single square V0
A: 
V0_R_6_R {
@ Recommend space between a square V0 and another (V0 OR RV0 OR DUM_V0) < 4um to avoid single square V0
 ALL_VIA_CHECK = OR V0_SR DUM_V0
 STEP_1 = SIZE V0_SR BY 1.4  //;4/1.414 = 2.828
 STEP_1_GOOD = STEP_1 INTERACT ALL_VIA_CHECK > 1
 STEP_1_FILTER = V0N NOT INTERACT STEP_1_GOOD
 err1 = STEP_1_FILTER NOT WITH EDGE (EXT [STEP_1_FILTER] ALL_VIA_CHECK < 4 PERP ALSO)
 err1 NOT INSIDE SealR_NOT_BULK
}


//RV0


Q: Redundant via requirement must be obeyed by one of following conditions for M1 connection (M1 plate with length and width >= 0.162um) (two square vias are equal to one rectangular via for below conditions) (Except VIA bar)
    1) At least one rectangular via
    2) At least two square vias with space <= 0.091um
    3) At least four square vias with space <= 0.415um
A: 
RV0_R_1 {
@ Redundant via requirement must be obeyed by one of following conditions for M1 connection (M1 plate with length and width >= 0.162um) (two square vias are equal to one rectangular via for below conditions) (Except VIA bar)
@ 1) At least one rectangular via
@ 2) At least two square vias with space <= 0.091um
@ 3) At least four square vias with space <= 0.415um
//;two V0N can be relpaced by one RV0
 X1a = WITH WIDTH M1 >= 0.162 < 0.272
 WIDE_all = X1a ENCLOSE V0_SR
 WIDE_all_raw = COPY WIDE_all

//; condition 1
 Y1_good_step1 = COPY RV0
 Y1_good = WIDE_all_raw AND Y1_good_step1

//; condition 2
 Y2_wide_all = WIDE_all_raw NOT INTERACT Y1_good
 Y2_wide = (M1 INTERACT Y2_wide_all) INTERACT V0_SR >= 2
 Y2_wide_chk_1 = Y2_wide INTERACT (WIDE_all_raw NOT INTERACT Y1_good_step1)
 Y2_comb_step1 = SIZE V0N BY 0.091/2 INSIDE OF Y2_wide_chk_1 STEP 0.030
 Y2_good_step1 = Y2_comb_step1 INTERACT V0N >= 2
 Y2_good = WIDE_all_raw AND Y2_good_step1

//; condition 3
 Y3_wide_all = WIDE_all_raw NOT INTERACT (OR Y1_good Y2_good)
 Y3_wide = (M1 INTERACT Y3_wide_all) INTERACT V0_SR >= 2   //;rectangle array 0.415/2=0.2075
 Y3_vias_input = V0_SR AND Y3_wide
 Y3_wide_chk_1 = Y3_wide INTERACT Y3_wide_all
 Y3_comb_step1 = SIZE Y3_vias_input BY 0.030 INSIDE OF Y3_wide_chk_1 STEP 0.030
 Y3_good_step1 = OR (Y3_comb_step1 INTERACT V0N >= 4) ((Y3_comb_step1 INTERACT RV0 == 1) INTERACT V0N >= 2)  //; step1: 0.030

//; Y3_wide_chk_2 = Y3_wide_chk_1 NOT INTERACT Y3_good_step1
 Y3_wide_chk_2 = Y3_wide_chk_1 INTERACT (WIDE_all_raw NOT INTERACT Y3_good_step1)
 Y3_comb_step2 = SIZE Y3_comb_step1 BY 0.030 INSIDE OF Y3_wide_chk_2 STEP 0.030
 Y3_good_step2 = OR (Y3_comb_step2 INTERACT V0N >= 4) ((Y3_comb_step2 INTERACT RV0 == 1) INTERACT V0N >= 2)  //; step2: 0.030

//; Y3_wide_chk_3 = Y3_wide_chk_2 NOT INTERACT Y3_good_step2
 Y3_wide_chk_3 = Y3_wide_chk_2 INTERACT (WIDE_all_raw NOT INTERACT Y3_good_step2)
 Y3_comb_step3 = SIZE Y3_comb_step2 BY 0.030 INSIDE OF Y3_wide_chk_3 STEP 0.030
 Y3_good_step3 = OR (Y3_comb_step3 INTERACT V0N >= 4) ((Y3_comb_step3 INTERACT RV0 == 1) INTERACT V0N >= 2)  //; step3: 0.030

//; Y3_wide_chk_4 = Y3_wide_chk_3 NOT INTERACT Y3_good_step3
 Y3_wide_chk_4 = Y3_wide_chk_3 INTERACT (WIDE_all_raw NOT INTERACT Y3_good_step3)
 Y3_comb_step4 = SIZE Y3_comb_step3 BY 0.030 INSIDE OF Y3_wide_chk_4 STEP 0.030
 Y3_good_step4 = OR (Y3_comb_step4 INTERACT V0N >= 4) ((Y3_comb_step4 INTERACT RV0 == 1) INTERACT V0N >= 2)  //; step4: 0.030

//; Y3_wide_chk_5 = Y3_wide_chk_4 NOT INTERACT Y3_good_step4
 Y3_wide_chk_5 = Y3_wide_chk_4 INTERACT (WIDE_all_raw NOT INTERACT Y3_good_step4)
 Y3_comb_step5 = SIZE Y3_comb_step4 BY 0.030 INSIDE OF Y3_wide_chk_5 STEP 0.030
 Y3_good_step5 = OR (Y3_comb_step5 INTERACT V0N >= 4) ((Y3_comb_step5 INTERACT RV0 == 1) INTERACT V0N >= 2)  //; step5: 0.030

//; Y3_wide_chk_6 = Y3_wide_chk_5 NOT INTERACT Y3_good_step5
 Y3_wide_chk_6 = Y3_wide_chk_5 INTERACT (WIDE_all_raw NOT INTERACT Y3_good_step5)
 Y3_comb_step6 = SIZE Y3_comb_step5 BY 0.030 INSIDE OF Y3_wide_chk_6 STEP 0.030
 Y3_good_step6 = OR (Y3_comb_step6 INTERACT V0N >= 4) ((Y3_comb_step6 INTERACT RV0 == 1) INTERACT V0N >= 2)  //; step6: 0.030

//; Y3_wide_chk_7 = Y3_wide_chk_6 NOT INTERACT Y3_good_step6
 Y3_wide_chk_7 = Y3_wide_chk_6 INTERACT (WIDE_all_raw NOT INTERACT Y3_good_step6)
 Y3_comb_step7 = SIZE Y3_comb_step6 BY 0.0275 INSIDE OF Y3_wide_chk_7 STEP 0.025
 Y3_good_step7 = OR (Y3_comb_step7 INTERACT V0N >= 4) ((Y3_comb_step7 INTERACT RV0 == 1) INTERACT V0N >= 2)  //; step7: 0.2075-0.03*6 = 0.0275
 Y3_good = WIDE_all_raw AND (OR Y3_good_step1 Y3_good_step2 Y3_good_step3 Y3_good_step4 Y3_good_step5 Y3_good_step6 Y3_good_step7)

 err1 = ((WIDE_all_raw OUTSIDE (OR Y1_good Y2_good Y3_good)) INTERACT V0_SR) NOT INTERACT V0_BAR
 err1 NOT INSIDE SealR_NOT_BULK
}

Q: Redundant via requirement must be obeyed by one of following conditions for M1 connection (M1 plate with length and width >= 0.272um) (two square vias are equal to one rectangular via for below conditions) (Except VIA bar and OCCD)
    1) At least 4 square vias with space <= 0.091um
    2) At least 9 square vias with space <= 0.545um
    3) At least 5 rectangular vias with space <= 0.545um
A: 
RV0_R_2 {
@ Redundant via requirement must be obeyed by one of following conditions for M1 connection (M1 plate with length and width >= 0.272um) (two square vias are equal to one rectangular via for below conditions) (Except VIA bar and OCCD)
@ 1) At least 4 square vias with space <= 0.091um
@ 2) At least 9 square vias with space <= 0.545um
@ 3) At least 5 rectangular vias with space <= 0.545um
//;two V0N can be relpaced by one RV0 (DRM will remove it 20180918)
 X1a = WITH WIDTH M1 >= 0.272
 WIDE_all = X1a ENCLOSE V0_SR
 WIDE_all_raw = COPY WIDE_all

//;condition 1
 Y1_wide = (M1 INTERACT WIDE_all_raw) INTERACT V0_SR >= 2
 Y1_vias_input = V0_SR AND Y1_wide
 Y1_wide_chk_1 = COPY Y1_wide  //;rectangle array 0.091/2=0.0455
 Y1_comb_step1 = SIZE Y1_vias_input BY 0.030 INSIDE OF Y1_wide_chk_1 STEP 0.030
 Y1_good_step1_a = Y1_comb_step1 INTERACT V0N >= 4
 Y1_good_step1_b = (Y1_comb_step1 INTERACT RV0 == 1) INTERACT V0N >= 2
 Y1_good_step1_c = Y1_comb_step1 INTERACT RV0 >= 2
 Y1_good_step1 = OR Y1_good_step1_a Y1_good_step1_b Y1_good_step1_c //; step1: 0.03

 Y1_wide_chk_2 = Y1_wide_chk_1 INTERACT (WIDE_all_raw NOT INTERACT Y1_good_step1)
 Y1_comb_step2 = SIZE Y1_comb_step1 BY 0.0155 INSIDE OF Y1_wide_chk_2 STEP 0.015
 Y1_good_step2_a = Y1_comb_step2 INTERACT V0N >= 4
 Y1_good_step2_b = (Y1_comb_step2 INTERACT RV0 == 1) INTERACT V0N >= 2
 Y1_good_step2_c = Y1_comb_step2 INTERACT RV0 >= 2
 Y1_good_step2 = OR Y1_good_step2_a Y1_good_step2_b Y1_good_step2_c //; step2: 0.045-0.03
 Y1_good = WIDE_all_raw AND (OR Y1_good_step1 Y1_good_step2)

//;condition 2 & condition 3
 Y2_wide_all = WIDE_all_raw NOT INTERACT Y1_good
 Y2_wide = (M1 INTERACT Y2_wide_all) INTERACT V0_SR >= 5
 Y2_vias_input = V0_SR AND Y2_wide
 Y2_wide_chk_1 = Y2_wide INTERACT Y2_wide_all  //; rectangle array 0.545/2=0.2725
 Y2_comb_step1 = SIZE Y2_vias_input BY 0.030 INSIDE OF Y2_wide_chk_1 STEP 0.030
 Y2_good_step1_a = Y2_comb_step1 INTERACT V0N >= 9
 Y2_good_step1_b = (Y2_comb_step1 INTERACT RV0 == 1) INTERACT V0N >= 7
 Y2_good_step1_c = (Y2_comb_step1 INTERACT RV0 == 2) INTERACT V0N >= 5
 Y2_good_step1_d = (Y2_comb_step1 INTERACT RV0 == 3) INTERACT V0N >= 3
 //Y2_good_step1_e = (Y2_comb_step1 INTERACT RV0 == 4) INTERACT V0N >= 1
 Y2_good_step1_f = Y2_comb_step1 INTERACT RV0 >= 5
 Y2_good_step1 = OR Y2_good_step1_a Y2_good_step1_b Y2_good_step1_c Y2_good_step1_d Y2_good_step1_f //; step1: 0.030

 Y2_wide_chk_2 = Y2_wide_chk_1 INTERACT (WIDE_all_raw NOT INTERACT Y2_good_step1)
 Y2_comb_step2 = SIZE Y2_comb_step1 BY 0.030 INSIDE OF Y2_wide_chk_2 STEP 0.030
 Y2_good_step2_a = Y2_comb_step2 INTERACT V0N >= 9
 Y2_good_step2_b = (Y2_comb_step2 INTERACT RV0 == 1) INTERACT V0N >= 7
 Y2_good_step2_c = (Y2_comb_step2 INTERACT RV0 == 2) INTERACT V0N >= 5
 Y2_good_step2_d = (Y2_comb_step2 INTERACT RV0 == 3) INTERACT V0N >= 3
 //Y2_good_step2_e = (Y2_comb_step2 INTERACT RV0 == 4) INTERACT V0N >= 1
 Y2_good_step2_f = Y2_comb_step2 INTERACT RV0 >= 5
 Y2_good_step2 = OR Y2_good_step2_a Y2_good_step2_b Y2_good_step2_c Y2_good_step2_d Y2_good_step2_f //; step2: 0.030

 Y2_wide_chk_3 = Y2_wide_chk_2 INTERACT (WIDE_all_raw NOT INTERACT Y2_good_step2)
 Y2_comb_step3 = SIZE Y2_comb_step2 BY 0.030 INSIDE OF Y2_wide_chk_3 STEP 0.030
 Y2_good_step3_a = Y2_comb_step3 INTERACT V0N >= 9
 Y2_good_step3_b = (Y2_comb_step3 INTERACT RV0 == 1) INTERACT V0N >= 7
 Y2_good_step3_c = (Y2_comb_step3 INTERACT RV0 == 2) INTERACT V0N >= 5
 Y2_good_step3_d = (Y2_comb_step3 INTERACT RV0 == 3) INTERACT V0N >= 3
 //Y2_good_step3_e = (Y2_comb_step3 INTERACT RV0 == 4) INTERACT V0N >= 1
 Y2_good_step3_f = Y2_comb_step3 INTERACT RV0 >= 5
 Y2_good_step3 = OR Y2_good_step3_a Y2_good_step3_b Y2_good_step3_c Y2_good_step3_d Y2_good_step3_f //; step3: 0.030

 Y2_wide_chk_4 = Y2_wide_chk_3 INTERACT (WIDE_all_raw NOT INTERACT Y2_good_step3)
 Y2_comb_step4 = SIZE Y2_comb_step3 BY 0.030 INSIDE OF Y2_wide_chk_4 STEP 0.030
 Y2_good_step4_a = Y2_comb_step4 INTERACT V0N >= 9
 Y2_good_step4_b = (Y2_comb_step4 INTERACT RV0 == 1) INTERACT V0N >= 7
 Y2_good_step4_c = (Y2_comb_step4 INTERACT RV0 == 2) INTERACT V0N >= 5
 Y2_good_step4_d = (Y2_comb_step4 INTERACT RV0 == 3) INTERACT V0N >= 3
 //Y2_good_step4_e = (Y2_comb_step4 INTERACT RV0 == 4) INTERACT V0N >= 1
 Y2_good_step4_f = Y2_comb_step4 INTERACT RV0 >= 5
 Y2_good_step4 = OR Y2_good_step4_a Y2_good_step4_b Y2_good_step4_c Y2_good_step4_d Y2_good_step4_f //; step4: 0.030

 Y2_wide_chk_5 = Y2_wide_chk_4 INTERACT (WIDE_all_raw NOT INTERACT Y2_good_step4)
 Y2_comb_step5 = SIZE Y2_comb_step4 BY 0.030 INSIDE OF Y2_wide_chk_5 STEP 0.030
 Y2_good_step5_a = Y2_comb_step5 INTERACT V0N >= 9
 Y2_good_step5_b = (Y2_comb_step5 INTERACT RV0 == 1) INTERACT V0N >= 7
 Y2_good_step5_c = (Y2_comb_step5 INTERACT RV0 == 2) INTERACT V0N >= 5
 Y2_good_step5_d = (Y2_comb_step5 INTERACT RV0 == 3) INTERACT V0N >= 3
 //Y2_good_step5_e = (Y2_comb_step5 INTERACT RV0 == 4) INTERACT V0N >= 1
 Y2_good_step5_f = Y2_comb_step5 INTERACT RV0 >= 5
 Y2_good_step5 = OR Y2_good_step5_a Y2_good_step5_b Y2_good_step5_c Y2_good_step5_d Y2_good_step5_f //; step5: 0.030

 Y2_wide_chk_6 = Y2_wide_chk_5 INTERACT (WIDE_all_raw NOT INTERACT Y2_good_step5)
 Y2_comb_step6 = SIZE Y2_comb_step5 BY 0.030 INSIDE OF Y2_wide_chk_6 STEP 0.030
 Y2_good_step6_a = Y2_comb_step6 INTERACT V0N >= 9
 Y2_good_step6_b = (Y2_comb_step6 INTERACT RV0 == 1) INTERACT V0N >= 7
 Y2_good_step6_c = (Y2_comb_step6 INTERACT RV0 == 2) INTERACT V0N >= 5
 Y2_good_step6_d = (Y2_comb_step6 INTERACT RV0 == 3) INTERACT V0N >= 3
 //Y2_good_step6_e = (Y2_comb_step6 INTERACT RV0 == 4) INTERACT V0N >= 1
 Y2_good_step6_f = Y2_comb_step6 INTERACT RV0 >= 5
 Y2_good_step6 = OR Y2_good_step6_a Y2_good_step6_b Y2_good_step6_c Y2_good_step6_d Y2_good_step6_f //; step6: 0.030

 Y2_wide_chk_7 = Y2_wide_chk_6 INTERACT (WIDE_all_raw NOT INTERACT Y2_good_step6)
 Y2_comb_step7 = SIZE Y2_comb_step6 BY 0.030 INSIDE OF Y2_wide_chk_7 STEP 0.030
 Y2_good_step7_a = Y2_comb_step7 INTERACT V0N >= 9
 Y2_good_step7_b = (Y2_comb_step7 INTERACT RV0 == 1) INTERACT V0N >= 7
 Y2_good_step7_c = (Y2_comb_step7 INTERACT RV0 == 2) INTERACT V0N >= 5
 Y2_good_step7_d = (Y2_comb_step7 INTERACT RV0 == 3) INTERACT V0N >= 3
 //Y2_good_step7_e = (Y2_comb_step7 INTERACT RV0 == 4) INTERACT V0N >= 1
 Y2_good_step7_f = Y2_comb_step7 INTERACT RV0 >= 5
 Y2_good_step7 = OR Y2_good_step7_a Y2_good_step7_b Y2_good_step7_c Y2_good_step7_d Y2_good_step7_f //; step7: 0.030

 Y2_wide_chk_8 = Y2_wide_chk_7 INTERACT (WIDE_all_raw NOT INTERACT Y2_good_step7)
 Y2_comb_step8 = SIZE Y2_comb_step7 BY 0.030 INSIDE OF Y2_wide_chk_8 STEP 0.030
 Y2_good_step8_a = Y2_comb_step8 INTERACT V0N >= 9
 Y2_good_step8_b = (Y2_comb_step8 INTERACT RV0 == 1) INTERACT V0N >= 7
 Y2_good_step8_c = (Y2_comb_step8 INTERACT RV0 == 2) INTERACT V0N >= 5
 Y2_good_step8_d = (Y2_comb_step8 INTERACT RV0 == 3) INTERACT V0N >= 3
 //Y2_good_step8_e = (Y2_comb_step8 INTERACT RV0 == 4) INTERACT V0N >= 1
 Y2_good_step8_f = Y2_comb_step8 INTERACT RV0 >= 5
 Y2_good_step8 = OR Y2_good_step8_a Y2_good_step8_b Y2_good_step8_c Y2_good_step8_d Y2_good_step8_f //; step8: 0.030

 Y2_wide_chk_9 = Y2_wide_chk_8 INTERACT (WIDE_all_raw NOT INTERACT Y2_good_step8)
 Y2_comb_step9 = SIZE Y2_comb_step8 BY 0.0325 INSIDE OF Y2_wide_chk_9 STEP 0.030
 Y2_good_step9_a = Y2_comb_step9 INTERACT V0N >= 9
 Y2_good_step9_b = (Y2_comb_step9 INTERACT RV0 == 1) INTERACT V0N >= 7
 Y2_good_step9_c = (Y2_comb_step9 INTERACT RV0 == 2) INTERACT V0N >= 5
 Y2_good_step9_d = (Y2_comb_step9 INTERACT RV0 == 3) INTERACT V0N >= 3
 //Y2_good_step9_e = (Y2_comb_step9 INTERACT RV0 == 4) INTERACT V0N >= 1
 Y2_good_step9_f = Y2_comb_step9 INTERACT RV0 >= 5
 Y2_good_step9 = OR Y2_good_step9_a Y2_good_step9_b Y2_good_step9_c Y2_good_step9_d Y2_good_step9_f //; step9: 0.2725-0.03*8=0.0325
 Y2_Y3_good = WIDE_all_raw AND (OR Y2_good_step1 Y2_good_step2 Y2_good_step3 Y2_good_step4 Y2_good_step5 Y2_good_step6 Y2_good_step7 Y2_good_step8 Y2_good_step9)

 err1 = ((WIDE_all_raw OUTSIDE (OR Y1_good Y2_Y3_good)) INTERACT V0_SR) NOT INTERACT V0_BAR
 err1 NOT INSIDE OCCD
}

VARIABLE RV0_R_3_m1_width 0.162
VARIABLE RV0_R_3_m1_distance 0.5

Q: There should be at least two square V0 or one rectangular V0 in the intersection area of bottom metal and upper metal, when either wide M1 width and length >= 0.162um, the space between either via and wide metal is <= 0.5um (S, S is the shortest running path length from Via to the wide metal) (except via bar)
    DRC doesn't check M0G or M0 region that with at least two square or one rectangular V0 at the boundary of wide metal and branch
A: 
RV0_R_3 {
@ There should be at least two square V0 or one rectangular V0 in the intersection area of bottom metal and upper metal, when either wide M1 width and length >= 0.162um, the space between either via and wide metal is <= 0.5um (S, S is the shortest running path length from Via to the wide metal) (except via bar)
@ DRC doesn't check M0G or M0 region that with at least two square or one rectangular V0 at the boundary of wide metal and branch
//;DRC flags the overlapped region with one via, no matter the region is a part of any whole M0/M0G region
 wide_M1 = (WITH WIDTH M1 >= RV0_R_3_m1_width) ENCLOSE RECTANGLE RV0_R_3_m1_width RV0_R_3_m1_width
 wide_M1_real = wide_M1 NOT OUTSIDE ((SIZE wide_M1 BY RV0_R_3_m1_distance+GLOBAL_TOLERANCE) INTERACT V0)
 all_down_and_up = (M1 INTERACT wide_M1) AND M0_0
 dis_down_and_up = SIZE wide_M1_real BY RV0_R_3_m1_distance+GLOBAL_TOLERANCE INSIDE OF M1 STEP 0.022
 dis_down_arm = (dis_down_and_up NOT wide_M1) AND M1
 dis_down_arm_corner = (dis_down_arm AND M0_0) INTERACT wide_M1

 dis_down_arm_good_a = (dis_down_arm INTERACT V0N >= 2) OR (dis_down_arm INTERACT RV0)
 dis_down_arm_good_b = (all_down_and_up INTERACT dis_down_arm_corner) INTERACT V0N >= 2
 dis_down_arm_good_c = (all_down_and_up INTERACT dis_down_arm_corner) INTERACT RV0
 dis_down_arm_good = OR dis_down_arm_good_a dis_down_arm_good_b dis_down_arm_good_c
 dis_down_arm_bad = dis_down_arm NOT dis_down_arm_good

 err1_down_arm_TMP = dis_down_arm INTERACT ((dis_down_arm_bad INTERACT V0N) AND dis_down_arm)
 err1_down_arm = err1_down_arm_TMP INTERACT (V0N NOT OUTSIDE err1_down_arm_TMP)
 err1 = err1_down_arm INTERACT wide_M1 == 1
 err1 NOT INTERACT V0_BAR
}

VARIABLE RV0_R_4_m1_width 0.272
VARIABLE RV0_R_4_m1_distance 1

Q: There should be at least two square V0 or one rectangular V0 in the intersection area of bottom metal and upper metal, when either wide M1 width and length >= 0.272um, the space between either via and wide metal is <= 1um (S, S is the shortest running path length from Via to the wide metal) (except via bar)
    DRC doesn't check M0G or M0 region that with at least two square or one rectangular V0 at the boundary of wide metal and branch
A: 
RV0_R_4 {
@ There should be at least two square V0 or one rectangular V0 in the intersection area of bottom metal and upper metal, when either wide M1 width and length >= 0.272um, the space between either via and wide metal is <= 1um (S, S is the shortest running path length from Via to the wide metal) (except via bar)
@ DRC doesn't check M0G or M0 region that with at least two square or one rectangular V0 at the boundary of wide metal and branch
 wide_M1 = (WITH WIDTH M1 >= RV0_R_4_m1_width) ENCLOSE RECTANGLE RV0_R_4_m1_width RV0_R_4_m1_width
 wide_M1_real = wide_M1 NOT OUTSIDE ((SIZE wide_M1 BY RV0_R_4_m1_distance+GLOBAL_TOLERANCE) INTERACT V0)
 all_down_and_up = (M1 INTERACT wide_M1) AND M0_0
 dis_down_and_up = SIZE wide_M1_real BY RV0_R_4_m1_distance+GLOBAL_TOLERANCE INSIDE OF M1 STEP 0.022
 dis_down_arm = (dis_down_and_up NOT wide_M1) AND M1
 dis_down_arm_corner = (dis_down_arm AND M0_0) INTERACT wide_M1

 dis_down_arm_good_a = (dis_down_arm INTERACT V0N >= 2) OR (dis_down_arm INTERACT RV0)
 dis_down_arm_good_b = (all_down_and_up INTERACT dis_down_arm_corner) INTERACT V0N >= 2
 dis_down_arm_good_c = (all_down_and_up INTERACT dis_down_arm_corner) INTERACT RV0
 dis_down_arm_good = OR dis_down_arm_good_a dis_down_arm_good_b dis_down_arm_good_c
 dis_down_arm_bad = dis_down_arm NOT dis_down_arm_good

 err1_down_arm_TMP = dis_down_arm INTERACT ((dis_down_arm_bad INTERACT V0N) AND dis_down_arm)
 err1_down_arm = err1_down_arm_TMP INTERACT (V0N NOT OUTSIDE err1_down_arm_TMP)
 err1 = err1_down_arm INTERACT wide_M1 == 1
 err1 NOT INTERACT V0_BAR
}

VARIABLE RV0_R_5_m1_width 0.542
VARIABLE RV0_R_5_m1_distance 3

Q: There should be at least two square V0 or one rectangular V0 in the intersection area of bottom metal and upper metal, when either wide metal M1 width and length >= 0.542um, the space between either via and wide metal is <= 3um (S, S is the shortest running path length from Via to the wide metal) (except via bar)
    DRC doesn't check M0G or M0 region that with at least two square or one rectangular V0 at the boundary of wide metal and branch
A: 
RV0_R_5 {
@ There should be at least two square V0 or one rectangular V0 in the intersection area of bottom metal and upper metal, when either wide metal M1 width and length >= 0.542um, the space between either via and wide metal is <= 3um (S, S is the shortest running path length from Via to the wide metal) (except via bar)
@ DRC doesn't check M0G or M0 region that with at least two square or one rectangular V0 at the boundary of wide metal and branch
 wide_M1 = (WITH WIDTH M1 >= RV0_R_5_m1_width) ENCLOSE RECTANGLE RV0_R_5_m1_width RV0_R_5_m1_width
 wide_M1_real = wide_M1 NOT OUTSIDE ((SIZE wide_M1 BY RV0_R_5_m1_distance+GLOBAL_TOLERANCE) INTERACT V0)
 all_down_and_up = (M1 INTERACT wide_M1) AND M0_0
 dis_down_and_up = SIZE wide_M1_real BY RV0_R_5_m1_distance+GLOBAL_TOLERANCE INSIDE OF M1 STEP 0.022
 dis_down_arm = (dis_down_and_up NOT wide_M1) AND M1
 dis_down_arm_corner = (dis_down_arm AND M0_0) INTERACT wide_M1

 dis_down_arm_good_a = (dis_down_arm INTERACT V0N >= 2) OR (dis_down_arm INTERACT RV0)
 dis_down_arm_good_b = (all_down_and_up INTERACT dis_down_arm_corner) INTERACT V0N >= 2
 dis_down_arm_good_c = (all_down_and_up INTERACT dis_down_arm_corner) INTERACT RV0
 dis_down_arm_good = OR dis_down_arm_good_a dis_down_arm_good_b dis_down_arm_good_c
 dis_down_arm_bad = dis_down_arm NOT dis_down_arm_good

 err1_down_arm_TMP = dis_down_arm INTERACT ((dis_down_arm_bad INTERACT V0N) AND dis_down_arm)
 err1_down_arm = err1_down_arm_TMP INTERACT (V0N NOT OUTSIDE err1_down_arm_TMP)
 err1 = err1_down_arm INTERACT wide_M1 == 1
 err1 NOT INTERACT V0_BAR
}

VARIABLE RV0_R_6_m1_width 1.010
VARIABLE RV0_R_6_m1_distance 5

Q: There should be at least two square V0 or one rectangular V0 in the intersection area of bottom metal and upper metal, when either wide metal M1 width and length >= 1.01um, the space between either via and wide metal is <= 5um (S, S is the shortest running path length from Via to the wide metal) (except via bar)
    DRC doesn't check M0G or M0 region that with at least two square or one rectangular V0 at the boundary of wide metal and branch
A: 
RV0_R_6 {
@ There should be at least two square V0 or one rectangular V0 in the intersection area of bottom metal and upper metal, when either wide metal M1 width and length >= 1.01um, the space between either via and wide metal is <= 5um (S, S is the shortest running path length from Via to the wide metal) (except via bar)
@ DRC doesn't check M0G or M0 region that with at least two square or one rectangular V0 at the boundary of wide metal and branch
 wide_M1 = (WITH WIDTH M1 >= RV0_R_6_m1_width) ENCLOSE RECTANGLE RV0_R_6_m1_width RV0_R_6_m1_width
 wide_M1_real = wide_M1 NOT OUTSIDE ((SIZE wide_M1 BY RV0_R_6_m1_distance+GLOBAL_TOLERANCE) INTERACT V0)
 all_down_and_up = (M1 INTERACT wide_M1) AND M0_0
 dis_down_and_up = SIZE wide_M1_real BY RV0_R_6_m1_distance+GLOBAL_TOLERANCE INSIDE OF M1 STEP 0.022
 dis_down_arm = (dis_down_and_up NOT wide_M1) AND M1
 dis_down_arm_corner = (dis_down_arm AND M0_0) INTERACT wide_M1

 dis_down_arm_good_a = (dis_down_arm INTERACT V0N >= 2) OR (dis_down_arm INTERACT RV0)
 dis_down_arm_good_b = (all_down_and_up INTERACT dis_down_arm_corner) INTERACT V0N >= 2
 dis_down_arm_good_c = (all_down_and_up INTERACT dis_down_arm_corner) INTERACT RV0
 dis_down_arm_good = OR dis_down_arm_good_a dis_down_arm_good_b dis_down_arm_good_c
 dis_down_arm_bad = dis_down_arm NOT dis_down_arm_good

 err1_down_arm_TMP = dis_down_arm INTERACT ((dis_down_arm_bad INTERACT V0N) AND dis_down_arm)
 err1_down_arm = err1_down_arm_TMP INTERACT (V0N NOT OUTSIDE err1_down_arm_TMP)
 err1 = err1_down_arm INTERACT wide_M1 == 1
 err1 NOT INTERACT V0_BAR
}

Q: Rectangular V0 overlap with (M0G width = 0.05um) is not allowed
A: 
RV0_R_8 {
@ Rectangular V0 overlap with (M0G width = 0.05um) is not allowed
 err1 = RV0 AND (OR M0G_050 M0G_WIDTH_050)
 err1 NOT INSIDE SealR_NOT_BULK
}


//M1

Q: M1 overlap MTFUSE is not allowed
A: 
M1_R_1 {
@ M1 overlap MTFUSE is not allowed
 err1 = M1 AND MTFUSE
 err1 NOT INSIDE SealR_NOT_BULK
}

Q: U-shape M1 pitch (W+S1) or (W+S2) must be >= 0.072um and V1 enclosure by M1 line-end (E) must be >= 0.032um,
    When:
    (1) Both PRL1 and PRL2 >= -0.015um
    (2) Space (S) < 0.05um along length direction
    (3) W < 0.04um
    DRC waive if S1 or S2 > 0.04um
    This rule is not applied for INST region
A: 
M1_R_4 {
@ U-shape M1 pitch (W+S1) or (W+S2) must be >= 0.072um and V1 enclosure by M1 line-end (E) must be >= 0.032um,
@ When:
@ (1) Both PRL1 and PRL2 >= -0.015um
@ (2) Space (S) < 0.05um along length direction
@ (3) W < 0.04um
@ DRC waive if S1 or S2 > 0.04um
@ This rule is not applied for INST region
 end_enc = M1_end_0.040 NOT TOUCH EDGE (ENC V1 [M1_end_0.040] < 0.032 ABUT<90 OPPOSITE)
 end_sps = end_enc TOUCH EDGE (EXT [end_enc] M1_convex_270_270_edges < 0.05 ABUT<90 OPPOSITE)
 end_epd = EXPAND EDGE end_sps OUTSIDE BY 0.016
 end_sid = LENGTH (end_epd NOT TOUCH EDGE M1) == 0.016
 end_wid = INT end_sid < 0.040 ABUT<90 OPPOSITE
 end_sds = EXT end_sid M1 < 0.04 ABUT<90 OPPOSITE
 err1 = DFM PROPERTY end_epd end_wid end_sds OVERLAP ABUT ALSO MULTI [+= (count(end_wid) > 0 && count(end_sds) > 0) ? 1 : 0] > 0 [-= min(ew(end_wid)) + min(ew(end_sds))] < 0.072
 err1 NOT INSIDE INST
}

Q: U-shape M1 pitch (W+S1) or (W+S2) must be >= 0.072um
    When:
    (1) Both PRL1 and PRL2 >= -0.015um
    (2) Space (S) < 0.05um along length direction
    (3) W < 0.04um
    (4) M1 interact V0 and enclosure E < 0.032um
    DRC waive if S1 or S2 > 0.04um
    This rule is not applied for INST region
A: 
M1_R_5 {
@ U-shape M1 pitch (W+S1) or (W+S2) must be >= 0.072um
@ When:
@ (1) Both PRL1 and PRL2 >= -0.015um
@ (2) Space (S) < 0.05um along length direction
@ (3) W < 0.04um
@ (4) M1 interact V0 and enclosure E < 0.032um
@ DRC waive if S1 or S2 > 0.04um
@ This rule is not applied for INST region
 end_enc = M1_end_0.040 TOUCH EDGE (ENC V0 [M1_end_0.040] < 0.032 ABUT<90 OPPOSITE)
 end_sps = end_enc TOUCH EDGE (EXT [end_enc] M1_convex_270_270_edges < 0.05 ABUT<90 OPPOSITE)
 end_epd = EXPAND EDGE end_sps OUTSIDE BY 0.016
 end_sid = LENGTH (end_epd NOT TOUCH EDGE M1) == 0.016
 end_wid = INT end_sid < 0.040 ABUT<90 OPPOSITE
 end_sds = EXT end_sid M1 < 0.04 ABUT<90 OPPOSITE
 err1 = DFM PROPERTY end_epd end_wid end_sds OVERLAP ABUT ALSO MULTI [+= (count(end_wid) > 0 && count(end_sds) > 0) ? 1 : 0] > 0 [-= min(ew(end_wid)) + min(ew(end_sds))] < 0.072
 err1 NOT INSIDE INST
}

//M2


Q: U-shape Mxy is not allowed, except INST region
    DRC check condition:
    1. With at least one RVy or RVy-1
    2. Mxy width W <= 0.038um
    3. S <= 0.12um
A: 
M2_R_6_RV1_ME {
@ U-shape Mxy is not allowed, except INST region
@ DRC check condition:
@ 1. With at least one RVy or RVy-1
@ 2. Mxy width W <= 0.038um
@ 3. S <= 0.12um
 ushape_opp = LENGTH M2_convex_270_270_edges <= 0.120
 ushape_wid = INT ushape_opp M2_convex_gt_one_edges <= 0.038 OPPOSITE
 ushape_edg = ushape_opp COIN EDGE (DFM COPY ushape_wid EDGE)
 ushape_met = (M2 WITH EDGE ushape_edg) INTERACT RV1
 ushape_chk = ushape_edg COIN EDGE ushape_met
 ushape_038 = (EXPAND EDGE ushape_chk INSIDE BY 0.038) AND M2
 ushape_via = (SIZE ushape_038 BY 0.12 INSIDE OF M2 STEP 0.01) INTERACT RV1
 ushape_err = DFM PROPERTY ushape_wid ushape_via OVERLAP ABUT ALSO MULTI [s= area(ushape_via)] > 0 [w= min(ew(ushape_wid))] > 0
 // 
 err1 = copy (DFM COPY ushape_err REGION)
 err1 NOT INSIDE INST
}
 
Q: U-shape Mxy is not allowed, except INST region
    DRC check condition:
    1. With at least one RVy or RVy-1
    2. Mxy width W <= 0.038um
    3. S <= 0.12um
A: 
M2_R_6_RV2_ME {
@ U-shape Mxy is not allowed, except INST region
@ DRC check condition:
@ 1. With at least one RVy or RVy-1
@ 2. Mxy width W <= 0.038um
@ 3. S <= 0.12um
 ushape_opp = LENGTH M2_convex_270_270_edges <= 0.120
 ushape_wid = INT ushape_opp M2_convex_gt_one_edges <= 0.038 OPPOSITE
 ushape_edg = ushape_opp COIN EDGE (DFM COPY ushape_wid EDGE)
 ushape_met = (M2 WITH EDGE ushape_edg) INTERACT RV2
 ushape_chk = ushape_edg COIN EDGE ushape_met
 ushape_038 = (EXPAND EDGE ushape_chk INSIDE BY 0.038) AND M2
 ushape_via = (SIZE ushape_038 BY 0.12 INSIDE OF M2 STEP 0.01) INTERACT RV2
 ushape_err = DFM PROPERTY ushape_wid ushape_via OVERLAP ABUT ALSO MULTI [s= area(ushape_via)] > 0 [w= min(ew(ushape_wid))] > 0
 // 
 err1 = copy (DFM COPY ushape_err REGION)
 err1 NOT INSIDE INST
}
 
Q: U-shape Mxy is not allowed, except INST region
    DRC check condition:
    1. With at least one RVy or RVy-1
    2. Mxy width W <= 0.038um
    3. S <= 0.12um
A: 
M2_R_6_RV3_ME {
@ U-shape Mxy is not allowed, except INST region
@ DRC check condition:
@ 1. With at least one RVy or RVy-1
@ 2. Mxy width W <= 0.038um
@ 3. S <= 0.12um
 ushape_opp = LENGTH M2_convex_270_270_edges <= 0.120
 ushape_wid = INT ushape_opp M2_convex_gt_one_edges <= 0.038 OPPOSITE
 ushape_edg = ushape_opp COIN EDGE (DFM COPY ushape_wid EDGE)
 ushape_met = (M2 WITH EDGE ushape_edg) INTERACT RV3
 ushape_chk = ushape_edg COIN EDGE ushape_met
 ushape_038 = (EXPAND EDGE ushape_chk INSIDE BY 0.038) AND M2
 ushape_via = (SIZE ushape_038 BY 0.12 INSIDE OF M2 STEP 0.01) INTERACT RV3
 ushape_err = DFM PROPERTY ushape_wid ushape_via OVERLAP ABUT ALSO MULTI [s= area(ushape_via)] > 0 [w= min(ew(ushape_wid))] > 0
 // 
 err1 = DFM COPY ushape_err REGION
 err1 NOT INSIDE INST
}
 
Q: It's not allowed to use Hook-shape Mxy, except INST region
    Hook-shape Mxy definition:
    (1) Hook-end line width(W1) is <= 0.05um, length(L1) <= 0.15um, ΔL > 0.1um and Hook-end interact one via
    (2) W2/W3 width <= 0.072um
    (3) Space between two Mxy arms(S1) <= 0.1um
    (4) Space between via and another Mxy S2 <= 0.038um when PRL > -0.015um
    DRC waive if hook-end enclosure via >= 0.05um
A: 
M2_R_7_V1_ME {
@ It's not allowed to use Hook-shape Mxy, except INST region
@ Hook-shape Mxy definition:
@ (1) Hook-end line width(W1) is <= 0.05um, length(L1) <= 0.15um, ΔL > 0.1um and Hook-end interact one via
@ (2) W2/W3 width <= 0.072um
@ (3) Space between two Mxy arms(S1) <= 0.1um
@ (4) Space between via and another Mxy S2 <= 0.038um when PRL > -0.015um
@ DRC waive if hook-end enclosure via >= 0.05um
 hook_neck = CONVEX EDGE M2 ANGLE1==270 LENGTH1<=0.15 ANGLE2==270 LENGTH2>0 WITH LENGTH <= 0.100
 hook_neck_ege = hook_neck NOT TOUCH EDGE (INT (hook_neck) M2 <= 0.072 ABUT<90 OPPOSITE)
 hook_neck_exd = EXPAND EDGE hook_neck_ege OUTSIDE BY 0.01
 hook_neck_sid = M2 COIN EDGE hook_neck_exd
 // 
 hook_seek = (M2 WITH EDGE hook_neck_ege) WITH EDGE M2_end_0.050
 hook_head_sid = INT [hook_seek] <= 0.05 ABUT<90 OPPOSITE
 hook_head_end = M2_end_0.050 TOUCH EDGE hook_seek
 hook_head_end_r = M2_end_0.050 TOUCH EDGE (OR EDGE (ENC V1 [hook_head_end] < 0.05 ABUT<90 OPPOSITE) (ENC V2 [hook_head_end] < 0.05 ABUT<90 OPPOSITE))
 hook_head_via_b = V1 WITH EDGE (ENC [V1] hook_head_end < 0.05 ABUT<90 OPPOSITE)
 hook_head_via_u = V2 WITH EDGE (ENC [V2] hook_head_end < 0.05 ABUT<90 OPPOSITE)
 hook_head_via_b_sid = ENC [hook_head_via_b] hook_head_sid <= 0.018 ABUT<90 OPPOSITE
 hook_head_via_u_sid = ENC [hook_head_via_u] hook_head_sid <= 0.018 ABUT<90 OPPOSITE
 hook_head_via = hook_head_via_b WITH EDGE (EXT M2 [hook_head_via_b_sid] < 0.038+GLOBAL_TOLERANCE ABUT<90 OPPOSITE EXTENDED 0.015 MEASURE ALL)
 // 
 hook_seek_met = hook_seek ENCLOSE hook_head_via
 hook_neck_cor = EXT [hook_seek_met] < 0.005 ABUT==90 INTERSECTING ONLY
 hook_neck_err = EXT hook_neck_cor <= 0.100 ABUT<90 OPPOSITE
 hook_neck_arm = hook_seek_met TOUCH EDGE hook_neck_cor
 hook_neck_dtl = DFM PROPERTY hook_neck_err hook_neck_arm OVERLAP ABUT ALSO MULTI [dt_l = max(length(hook_neck_arm)) - min(length(hook_neck_arm))]
 // 
 hook_head_a = (INT (M2_convex_gt_one_edges TOUCH EDGE hook_seek_met) <= 0.05 OPPOSITE REGION) WITH EDGE hook_head_end_r
 hook_head_b = NOT ENCLOSE RECTANGLE hook_head_a 0.001 0.150+GLOBAL_TOLERANCE ORTHOGONAL ONLY
 hook_head = hook_head_b NOT OUTSIDE hook_head_via
 hook_tail = INT (hook_neck_sid) M2 <= 0.072 ABUT<90 OPPOSITE
 hook_gain = DFM PROPERTY hook_neck_err hook_tail hook_head hook_neck_dtl OVERLAP ABUT ALSO MULTI 
 [-= (count(hook_head) > 0 && count(hook_tail) == 0) ? 1 : 0] > 0 [dt_l = property(hook_neck_dtl,dt_l)] > 0.10
 err1 = copy (DFM COPY hook_gain REGION)
 err1 NOT INSIDE INST
}
 
Q: It's not allowed to use Hook-shape Mxy, except INST region
    Hook-shape Mxy definition:
    (1) Hook-end line width(W1) is <= 0.05um, length(L1) <= 0.15um, ΔL > 0.1um and Hook-end interact one via
    (2) W2/W3 width <= 0.072um
    (3) Space between two Mxy arms(S1) <= 0.1um
    (4) Space between via and another Mxy S2 <= 0.038um when PRL > -0.015um
    DRC waive if hook-end enclosure via >= 0.05um
A: 
M2_R_7_V2_ME {
@ It's not allowed to use Hook-shape Mxy, except INST region
@ Hook-shape Mxy definition:
@ (1) Hook-end line width(W1) is <= 0.05um, length(L1) <= 0.15um, ΔL > 0.1um and Hook-end interact one via
@ (2) W2/W3 width <= 0.072um
@ (3) Space between two Mxy arms(S1) <= 0.1um
@ (4) Space between via and another Mxy S2 <= 0.038um when PRL > -0.015um
@ DRC waive if hook-end enclosure via >= 0.05um
 hook_neck = CONVEX EDGE M2 ANGLE1==270 LENGTH1<=0.15 ANGLE2==270 LENGTH2>0 WITH LENGTH <= 0.100
 hook_neck_ege = hook_neck NOT TOUCH EDGE (INT (hook_neck) M2 <= 0.072 ABUT<90 OPPOSITE)
 hook_neck_exd = EXPAND EDGE hook_neck_ege OUTSIDE BY 0.01
 hook_neck_sid = M2 COIN EDGE hook_neck_exd
 // 
 hook_seek = (M2 WITH EDGE hook_neck_ege) WITH EDGE M2_end_0.050
 hook_head_sid = INT [hook_seek] <= 0.05 ABUT<90 OPPOSITE
 hook_head_end = M2_end_0.050 TOUCH EDGE hook_seek
 hook_head_end_r = M2_end_0.050 TOUCH EDGE (OR EDGE (ENC V1 [hook_head_end] < 0.05 ABUT<90 OPPOSITE) (ENC V2 [hook_head_end] < 0.05 ABUT<90 OPPOSITE))
 hook_head_via_b = V1 WITH EDGE (ENC [V1] hook_head_end < 0.05 ABUT<90 OPPOSITE)
 hook_head_via_u = V2 WITH EDGE (ENC [V2] hook_head_end < 0.05 ABUT<90 OPPOSITE)
 hook_head_via_b_sid = ENC [hook_head_via_b] hook_head_sid <= 0.018 ABUT<90 OPPOSITE
 hook_head_via_u_sid = ENC [hook_head_via_u] hook_head_sid <= 0.018 ABUT<90 OPPOSITE
 hook_head_via = hook_head_via_u WITH EDGE (EXT M2 [hook_head_via_u_sid] < 0.038+GLOBAL_TOLERANCE ABUT<90 OPPOSITE EXTENDED 0.015 MEASURE ALL)
 // 
 hook_seek_met = hook_seek ENCLOSE hook_head_via
 hook_neck_cor = EXT [hook_seek_met] < 0.005 ABUT==90 INTERSECTING ONLY
 hook_neck_err = EXT hook_neck_cor <= 0.100 ABUT<90 OPPOSITE
 hook_neck_arm = hook_seek_met TOUCH EDGE hook_neck_cor
 hook_neck_dtl = DFM PROPERTY hook_neck_err hook_neck_arm OVERLAP ABUT ALSO MULTI [dt_l = max(length(hook_neck_arm)) - min(length(hook_neck_arm))]
 // 
 hook_head_a = (INT (M2_convex_gt_one_edges TOUCH EDGE hook_seek_met) <= 0.05 OPPOSITE REGION) WITH EDGE hook_head_end_r
 hook_head_b = NOT ENCLOSE RECTANGLE hook_head_a 0.001 0.150+GLOBAL_TOLERANCE ORTHOGONAL ONLY
 hook_head = hook_head_b NOT OUTSIDE hook_head_via
 hook_tail = INT (hook_neck_sid) M2 <= 0.072 ABUT<90 OPPOSITE
 hook_gain = DFM PROPERTY hook_neck_err hook_tail hook_head hook_neck_dtl OVERLAP ABUT ALSO MULTI 
 [-= (count(hook_head) > 0 && count(hook_tail) == 0) ? 1 : 0] > 0 [dt_l = property(hook_neck_dtl,dt_l)] > 0.10
 err1 = copy (DFM COPY hook_gain REGION)
 err1 NOT INSIDE INST
}

Q: It's not recommended to use U-shape Mxy
    DRC check condition:
    1. With at least one RVy or RVy-1
    2. Mxy width W <= 0.038um
    3. S <= 0.12um
    Which rule is not applied for INST region
A: 
M2_R_6_RV1_DFM1 {
@ It's not recommended to use U-shape Mxy
@ DRC check condition:
@ 1. With at least one RVy or RVy-1
@ 2. Mxy width W <= 0.038um
@ 3. S <= 0.12um
@ Which rule is not applied for INST region
 ushape_opp = LENGTH M2_convex_270_270_edges <= 0.120
 ushape_wid = INT ushape_opp M2_convex_gt_one_edges <= 0.038 OPPOSITE
 ushape_edg = ushape_opp COIN EDGE (DFM COPY ushape_wid EDGE)
 ushape_met = (M2 WITH EDGE ushape_edg) INTERACT RV1
 ushape_chk = ushape_edg COIN EDGE ushape_met
 ushape_038 = (EXPAND EDGE ushape_chk INSIDE BY 0.038) AND M2
 ushape_via = (SIZE ushape_038 BY 0.12 INSIDE OF M2 STEP 0.01) INTERACT RV1
 ushape_err = DFM PROPERTY ushape_wid ushape_via OVERLAP ABUT ALSO MULTI [s= area(ushape_via)] > 0 [w= min(ew(ushape_wid))] > 0
 // 
 err1 = DFM COPY ushape_err REGION
 err1 NOT INSIDE INST
}
 
Q: It's not recommended to use U-shape Mxy
    DRC check condition:
    1. With at least one RVy or RVy-1
    2. Mxy width W <= 0.038um
    3. S <= 0.12um
    Which rule is not applied for INST region
A: 
M2_R_6_RV2_DFM1 {
@ It's not recommended to use U-shape Mxy
@ DRC check condition:
@ 1. With at least one RVy or RVy-1
@ 2. Mxy width W <= 0.038um
@ 3. S <= 0.12um
@ Which rule is not applied for INST region
 ushape_opp = LENGTH M2_convex_270_270_edges <= 0.120
 ushape_wid = INT ushape_opp M2_convex_gt_one_edges <= 0.038 OPPOSITE
 ushape_edg = ushape_opp COIN EDGE (DFM COPY ushape_wid EDGE)
 ushape_met = (M2 WITH EDGE ushape_edg) INTERACT RV2
 ushape_chk = ushape_edg COIN EDGE ushape_met
 ushape_038 = (EXPAND EDGE ushape_chk INSIDE BY 0.038) AND M2
 ushape_via = (SIZE ushape_038 BY 0.12 INSIDE OF M2 STEP 0.01) INTERACT RV2
 ushape_err = DFM PROPERTY ushape_wid ushape_via OVERLAP ABUT ALSO MULTI [s= area(ushape_via)] > 0 [w= min(ew(ushape_wid))] > 0
 // 
 err1 = DFM COPY ushape_err REGION
 err1 NOT INSIDE INST
}
 
Q: It's not recommended to use Hook-shape Mxy
    Hook-shape Mxy definition:
    (1) Hook-end line width(W1) is <= 0.05um, length(L1) <= 0.15um, ΔL > 0.1um and Hook-end interact one via
    (2) W2/W3 width <= 0.072um
    (3) Space between two Mxy arms(S1) <= 0.1um
    (4) Space between via and another Mxy S2 <= 0.038um when PRL > -0.015um
    DRC waive if hook-end enclosure via >= 0.05um
    This rule is not applied for INST region
A: 
M2_R_7_V1_DFM1 {
@ It's not recommended to use Hook-shape Mxy
@ Hook-shape Mxy definition:
@ (1) Hook-end line width(W1) is <= 0.05um, length(L1) <= 0.15um, ΔL > 0.1um and Hook-end interact one via
@ (2) W2/W3 width <= 0.072um
@ (3) Space between two Mxy arms(S1) <= 0.1um
@ (4) Space between via and another Mxy S2 <= 0.038um when PRL > -0.015um
@ DRC waive if hook-end enclosure via >= 0.05um
@ This rule is not applied for INST region
 hook_neck = CONVEX EDGE M2 ANGLE1==270 LENGTH1<=0.15 ANGLE2==270 LENGTH2>0 WITH LENGTH <= 0.100
 hook_neck_ege = hook_neck NOT TOUCH EDGE (INT (hook_neck) M2 <= 0.072 ABUT<90 OPPOSITE)
 hook_neck_exd = EXPAND EDGE hook_neck_ege OUTSIDE BY 0.01
 hook_neck_sid = M2 COIN EDGE hook_neck_exd
 // 
 hook_seek = (M2 WITH EDGE hook_neck_ege) WITH EDGE M2_end_0.050
 hook_head_sid = INT [hook_seek] <= 0.05 ABUT<90 OPPOSITE
 hook_head_end = M2_end_0.050 TOUCH EDGE hook_seek
 hook_head_end_r = M2_end_0.050 TOUCH EDGE (OR EDGE (ENC V1 [hook_head_end] < 0.05 ABUT<90 OPPOSITE) (ENC V2 [hook_head_end] < 0.05 ABUT<90 OPPOSITE))
 hook_head_via_b = V1 WITH EDGE (ENC [V1] hook_head_end < 0.05 ABUT<90 OPPOSITE)
 hook_head_via_u = V2 WITH EDGE (ENC [V2] hook_head_end < 0.05 ABUT<90 OPPOSITE)
 hook_head_via_b_sid = ENC [hook_head_via_b] hook_head_sid <= 0.018 ABUT<90 OPPOSITE
 hook_head_via_u_sid = ENC [hook_head_via_u] hook_head_sid <= 0.018 ABUT<90 OPPOSITE
 hook_head_via = hook_head_via_b WITH EDGE (EXT M2 [hook_head_via_b_sid] < 0.038+GLOBAL_TOLERANCE ABUT<90 OPPOSITE EXTENDED 0.015 MEASURE ALL)
 // 
 hook_seek_met = hook_seek ENCLOSE hook_head_via
 hook_neck_cor = EXT [hook_seek_met] < 0.005 ABUT==90 INTERSECTING ONLY
 hook_neck_err = EXT hook_neck_cor <= 0.100 ABUT<90 OPPOSITE
 hook_neck_arm = hook_seek_met TOUCH EDGE hook_neck_cor
 hook_neck_dtl = DFM PROPERTY hook_neck_err hook_neck_arm OVERLAP ABUT ALSO MULTI [dt_l = max(length(hook_neck_arm)) - min(length(hook_neck_arm))]
 // 
 hook_head_a = (INT (M2_convex_gt_one_edges TOUCH EDGE hook_seek_met) <= 0.05 OPPOSITE REGION) WITH EDGE hook_head_end_r
 hook_head_b = NOT ENCLOSE RECTANGLE hook_head_a 0.001 0.150+GLOBAL_TOLERANCE ORTHOGONAL ONLY
 hook_head = hook_head_b NOT OUTSIDE hook_head_via
 hook_tail = INT (hook_neck_sid) M2 <= 0.072 ABUT<90 OPPOSITE
 hook_gain = DFM PROPERTY hook_neck_err hook_tail hook_head hook_neck_dtl OVERLAP ABUT ALSO MULTI 
 [-= (count(hook_head) > 0 && count(hook_tail) == 0) ? 1 : 0] > 0 [dt_l = property(hook_neck_dtl,dt_l)] > 0.10
 err1 = DFM COPY hook_gain REGION
 err1 NOT INSIDE INST
}
 
Q: It's not recommended to use Hook-shape Mxy
    Hook-shape Mxy definition:
    (1) Hook-end line width(W1) is <= 0.05um, length(L1) <= 0.15um, ΔL > 0.1um and Hook-end interact one via
    (2) W2/W3 width <= 0.072um
    (3) Space between two Mxy arms(S1) <= 0.1um
    (4) Space between via and another Mxy S2 <= 0.038um when PRL > -0.015um
    DRC waive if hook-end enclosure via >= 0.05um
    This rule is not applied for INST region
A: 
M2_R_7_V2_DFM1 {
@ It's not recommended to use Hook-shape Mxy
@ Hook-shape Mxy definition:
@ (1) Hook-end line width(W1) is <= 0.05um, length(L1) <= 0.15um, ΔL > 0.1um and Hook-end interact one via
@ (2) W2/W3 width <= 0.072um
@ (3) Space between two Mxy arms(S1) <= 0.1um
@ (4) Space between via and another Mxy S2 <= 0.038um when PRL > -0.015um
@ DRC waive if hook-end enclosure via >= 0.05um
@ This rule is not applied for INST region
 hook_neck = CONVEX EDGE M2 ANGLE1==270 LENGTH1<=0.15 ANGLE2==270 LENGTH2>0 WITH LENGTH <= 0.100
 hook_neck_ege = hook_neck NOT TOUCH EDGE (INT (hook_neck) M2 <= 0.072 ABUT<90 OPPOSITE)
 hook_neck_exd = EXPAND EDGE hook_neck_ege OUTSIDE BY 0.01
 hook_neck_sid = M2 COIN EDGE hook_neck_exd
 // 
 hook_seek = (M2 WITH EDGE hook_neck_ege) WITH EDGE M2_end_0.050
 hook_head_sid = INT [hook_seek] <= 0.05 ABUT<90 OPPOSITE
 hook_head_end = M2_end_0.050 TOUCH EDGE hook_seek
 hook_head_end_r = M2_end_0.050 TOUCH EDGE (OR EDGE (ENC V1 [hook_head_end] < 0.05 ABUT<90 OPPOSITE) (ENC V2 [hook_head_end] < 0.05 ABUT<90 OPPOSITE))
 hook_head_via_b = V1 WITH EDGE (ENC [V1] hook_head_end < 0.05 ABUT<90 OPPOSITE)
 hook_head_via_u = V2 WITH EDGE (ENC [V2] hook_head_end < 0.05 ABUT<90 OPPOSITE)
 hook_head_via_b_sid = ENC [hook_head_via_b] hook_head_sid <= 0.018 ABUT<90 OPPOSITE
 hook_head_via_u_sid = ENC [hook_head_via_u] hook_head_sid <= 0.018 ABUT<90 OPPOSITE
 hook_head_via = hook_head_via_u WITH EDGE (EXT M2 [hook_head_via_u_sid] < 0.038+GLOBAL_TOLERANCE ABUT<90 OPPOSITE EXTENDED 0.015 MEASURE ALL)
 // 
 hook_seek_met = hook_seek ENCLOSE hook_head_via
 hook_neck_cor = EXT [hook_seek_met] < 0.005 ABUT==90 INTERSECTING ONLY
 hook_neck_err = EXT hook_neck_cor <= 0.100 ABUT<90 OPPOSITE
 hook_neck_arm = hook_seek_met TOUCH EDGE hook_neck_cor
 hook_neck_dtl = DFM PROPERTY hook_neck_err hook_neck_arm OVERLAP ABUT ALSO MULTI [dt_l = max(length(hook_neck_arm)) - min(length(hook_neck_arm))]
 // 
 hook_head_a = (INT (M2_convex_gt_one_edges TOUCH EDGE hook_seek_met) <= 0.05 OPPOSITE REGION) WITH EDGE hook_head_end_r
 hook_head_b = NOT ENCLOSE RECTANGLE hook_head_a 0.001 0.150+GLOBAL_TOLERANCE ORTHOGONAL ONLY
 hook_head = hook_head_b NOT OUTSIDE hook_head_via
 hook_tail = INT (hook_neck_sid) M2 <= 0.072 ABUT<90 OPPOSITE
 hook_gain = DFM PROPERTY hook_neck_err hook_tail hook_head hook_neck_dtl OVERLAP ABUT ALSO MULTI 
 [-= (count(hook_head) > 0 && count(hook_tail) == 0) ? 1 : 0] > 0 [dt_l = property(hook_neck_dtl,dt_l)] > 0.10
 err1 = DFM COPY hook_gain REGION
 err1 NOT INSIDE INST
}
 
Q: It's not recommended to use dense Mxy line end pattern
    DRC flage conditions:
    (1) Middle Mxy line width(W1) <= 0.038um, both two neighbour Mxy lines width <= 0.064um
    (2) Both the Vy-1 dense region (dense region definition: region formed by Vy-1 horizontal edge extension 0.038um, vertical edge extension 0.05um) horizontal edges neighbour Mxy line-end
    DRC waive if Mxy enclosure Vy-1 > 0.05um. (Vy-1 is the via underneath Mxy)
    This rule is not applied for INST region
A: 
M2_R_8_DFM1 {
@ It's not recommended to use dense Mxy line end pattern
@ DRC flage conditions:
@ (1) Middle Mxy line width(W1) <= 0.038um, both two neighbour Mxy lines width <= 0.064um
@ (2) Both the Vy-1 dense region (dense region definition: region formed by Vy-1 horizontal edge extension 0.038um, vertical edge extension 0.05um) horizontal edges neighbour Mxy line-end
@ DRC waive if Mxy enclosure Vy-1 > 0.05um. (Vy-1 is the via underneath Mxy)
@ This rule is not applied for INST region
 via_met = V1_SR NOT OUTSIDE (M2 WITH WIDTH <= 0.038)
 via_end = via_met TOUCH EDGE (ENC [via_met] M2_end_0.038 <= 0.05 ABUT<90 OPPOSITE)
 via_lin = (via_met NOT TOUCH EDGE via_end) TOUCH EDGE (ENC [via_met] met2_38_side <= 0.006 ABUT<90 OPPOSITE)
 via_mid = (via_met WITH EDGE via_end) WITH EDGE via_lin == 2
 via_sid = via_mid TOUCH EDGE via_lin
 // 
 nei_end = LENGTH M2_convex_90_90_edges <= 0.064
 nei_sid = LENGTH (EXPAND EDGE nei_end OUTSIDE BY 0.001) == 0.001
 nei_via = EXT [via_sid] nei_sid < 0.038+GLOBAL_TOLERANCE ABUT<90 OPPOSITE EXTENDED 0.050 MEASURE ALL
 err1 = via_mid WITH EDGE (via_mid TOUCH EDGE nei_via) >= 2
 err1 NOT INSIDE INST
}
 
Q: It's not recommended to use dense Mxy 3-bar pattern
    DRC flag conditions:
    (1) Middle Mxy line width(W1) is <= 0.048um, both two neighbour Mxy line width <= 0.064um and interact square or rectangle Vy or Vy-1
    (2) Mxy Space to both via (S1/S2) = 0.058~0.063um
    (3) The via PRL: -0.1 < PRL < 0.1um
    (4) Both neighbour Mxy enclosure Vy or Vy-1 < 0.05um
    This rule is not applied for INST region
A: 
M2_R_9_V1_DFM1 {
@ It's not recommended to use dense Mxy 3-bar pattern
@ DRC flag conditions:
@ (1) Middle Mxy line width(W1) is <= 0.048um, both two neighbour Mxy line width <= 0.064um and interact square or rectangle Vy or Vy-1
@ (2) Mxy Space to both via (S1/S2) = 0.058~0.063um
@ (3) The via PRL: -0.1 < PRL < 0.1um
@ (4) Both neighbour Mxy enclosure Vy or Vy-1 < 0.05um
@ This rule is not applied for INST region
 via_d_met = V1_SR NOT OUTSIDE (M2 WITH WIDTH <= 0.064)
 via_d_end = via_d_met TOUCH EDGE (ENC [via_d_met] M2_end_0.064 < 0.05 ABUT<90 OPPOSITE)
 via_d_lin = (via_d_met NOT TOUCH EDGE via_d_end) TOUCH EDGE (ENC [via_d_met] met2_64_side <= 0.032 ABUT<90 OPPOSITE)
 via_d_mid = (via_d_met WITH EDGE via_d_end) WITH EDGE via_d_lin >= 2
 via_d_sid = via_d_mid TOUCH EDGE via_d_lin
 via_d_sps = (EXT [met2_48_side] via_d_sid >= 0.058 <= 0.063 OPPOSITE EXTENDED 0.1 MEASURE ALL) TOUCH EDGE (EXT [met2_48_side] via_d_sid >= 0.058 <= 0.063 OPPOSITE MEASURE ALL)
 err1 = INT via_d_sps <= 0.048 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE INST
}

Q: It's not recommended to use dense Mxy 3-bar pattern
    DRC flag conditions:
    (1) Middle Mxy line width(W1) is <= 0.048um, both two neighbour Mxy line width <= 0.064um and interact square or rectangle Vy or Vy-1
    (2) Mxy Space to both via (S1/S2) = 0.058~0.063um
    (3) The via PRL: -0.1 < PRL < 0.1um
    (4) Both neighbour Mxy enclosure Vy or Vy-1 < 0.05um
    This rule is not applied for INST region
A: 
M2_R_9_V2_DFM1 {
@ It's not recommended to use dense Mxy 3-bar pattern
@ DRC flag conditions:
@ (1) Middle Mxy line width(W1) is <= 0.048um, both two neighbour Mxy line width <= 0.064um and interact square or rectangle Vy or Vy-1
@ (2) Mxy Space to both via (S1/S2) = 0.058~0.063um
@ (3) The via PRL: -0.1 < PRL < 0.1um
@ (4) Both neighbour Mxy enclosure Vy or Vy-1 < 0.05um
@ This rule is not applied for INST region
 via_u_met = V2_SR NOT OUTSIDE (M2 WITH WIDTH <= 0.064)
 via_u_end = via_u_met TOUCH EDGE (ENC [via_u_met] M2_end_0.064 < 0.05 ABUT<90 OPPOSITE)
 via_u_lin = (via_u_met NOT TOUCH EDGE via_u_end) TOUCH EDGE (ENC [via_u_met] met2_64_side <= 0.032 ABUT<90 OPPOSITE)
 via_u_mid = (via_u_met WITH EDGE via_u_end) WITH EDGE via_u_lin >= 2
 via_u_sid = via_u_mid TOUCH EDGE via_u_lin
 via_u_sps = (EXT [met2_48_side] via_u_sid >= 0.058 <= 0.063 OPPOSITE EXTENDED 0.1 MEASURE ALL) TOUCH EDGE (EXT [met2_48_side] via_u_sid >= 0.058 <= 0.063 OPPOSITE MEASURE ALL)
 err1 = INT via_u_sps <= 0.048 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE INST
}


Q: Mxy overlap of MTFUSE is not allowed
A: 
M2_R_4 {
@ Mxy overlap of MTFUSE is not allowed
 err1 = M2 AND MTFUSE
 err1 NOT INSIDE SealR_NOT_BULK
}
// Mxy.R.6[NC] Mxy pattern must be drawn on data type 0
 
Q: U-shape metal pitch (W+S1) or (W+S2) must be >= 0.072um except M2 in INST region
    Vy enclosure by Mxy line-end (E) must be >= 0.032um (Mxy is the metal underneath Vy)
    When:
    (1) Both PRL1 and PRL2 >= -0.015um
    (2) Space (S) < 0.070um along length direction
    (3) W < 0.046um
    DRC waive if S1 or S2 > 0.04um
A: 
M2_R_7 {
@ U-shape metal pitch (W+S1) or (W+S2) must be >= 0.072um except M2 in INST region
@ Vy enclosure by Mxy line-end (E) must be >= 0.032um (Mxy is the metal underneath Vy)
@ When:
@ (1) Both PRL1 and PRL2 >= -0.015um
@ (2) Space (S) < 0.070um along length direction
@ (3) W < 0.046um
@ DRC waive if S1 or S2 > 0.04um
 end_enc = M2_end_0.046 NOT TOUCH EDGE (ENC V2 [M2_end_0.046] < 0.032 ABUT<90 OPPOSITE)
 end_sps = end_enc TOUCH EDGE (EXT [end_enc] M2_convex_270_270_edges < 0.07 ABUT<90 OPPOSITE)
 end_epd = EXPAND EDGE end_sps OUTSIDE BY 0.016
 end_sid = LENGTH (end_epd NOT TOUCH EDGE M2) == 0.016
 end_wid = INT end_sid < 0.046 ABUT<90 OPPOSITE
 end_sds = EXT end_sid M2 < 0.04 ABUT<90 OPPOSITE
 err1 = DFM PROPERTY end_epd end_wid end_sds OVERLAP ABUT ALSO MULTI 
 [+= (count(end_wid) > 0 && count(end_sds) > 0) ? 1 : 0] > 0 [-= min(ew(end_wid)) + min(ew(end_sds))] < 0.072
 err1 NOT INSIDE INST
}
 
Q: U-shape metal pitch (W+S1) or (W+S2) must be >= 0.072um, except M2 in INST region
    When:
    1) Both PRL1 and PRL2 >= -0.015um
    2) Space (S) < 0.070um along length direction
    3) W < 0.046um
    4) Mxy interact Vy-1 and enclosure E < 0.05um. (Mxy is the metal above Vy-1)
    DRC waive if S1 or S2 > 0.04um
A: 
M2_R_8 {
@ U-shape metal pitch (W+S1) or (W+S2) must be >= 0.072um, except M2 in INST region
@ When:
@ 1) Both PRL1 and PRL2 >= -0.015um
@ 2) Space (S) < 0.070um along length direction
@ 3) W < 0.046um
@ 4) Mxy interact Vy-1 and enclosure E < 0.05um. (Mxy is the metal above Vy-1)
@ DRC waive if S1 or S2 > 0.04um
 end_enc = M2_end_0.046 TOUCH EDGE (ENC V1 [M2_end_0.046] < 0.05 ABUT<90 OPPOSITE)
 end_sps = end_enc TOUCH EDGE (EXT [end_enc] M2_convex_270_270_edges < 0.07 ABUT<90 OPPOSITE)
 end_epd = EXPAND EDGE end_sps OUTSIDE BY 0.016
 end_sid = LENGTH (end_epd NOT TOUCH EDGE M2) == 0.016
 end_wid = INT end_sid < 0.046 ABUT<90 OPPOSITE
 end_sds = EXT end_sid M2 < 0.04 ABUT<90 OPPOSITE
 err1 = DFM PROPERTY end_epd end_wid end_sds OVERLAP ABUT ALSO MULTI 
 [+= (count(end_wid) > 0 && count(end_sds) > 0) ? 1 : 0] > 0 [-= min(ew(end_wid)) + min(ew(end_sds))] < 0.072
 err1 NOT INSIDE INST
}


//M3

Q: It's not recommended to use U-shape Mxy
    DRC check condition:
    1. With at least one RVy or RVy-1
    2. Mxy width W <= 0.038um
    3. S <= 0.12um
    Which rule is not applied for INST region
A: 
M3_R_6_RV2_DFM1 {
@ It's not recommended to use U-shape Mxy
@ DRC check condition:
@ 1. With at least one RVy or RVy-1
@ 2. Mxy width W <= 0.038um
@ 3. S <= 0.12um
@ Which rule is not applied for INST region
 ushape_opp = LENGTH M3_convex_270_270_edges <= 0.120
 ushape_wid = INT ushape_opp M3_convex_gt_one_edges <= 0.038 OPPOSITE
 ushape_edg = ushape_opp COIN EDGE (DFM COPY ushape_wid EDGE)
 ushape_met = (M3 WITH EDGE ushape_edg) INTERACT RV2
 ushape_chk = ushape_edg COIN EDGE ushape_met
 ushape_038 = (EXPAND EDGE ushape_chk INSIDE BY 0.038) AND M3
 ushape_via = (SIZE ushape_038 BY 0.12 INSIDE OF M3 STEP 0.01) INTERACT RV2
 ushape_err = DFM PROPERTY ushape_wid ushape_via OVERLAP ABUT ALSO MULTI [s= area(ushape_via)] > 0 [w= min(ew(ushape_wid))] > 0
 // 
 err1 = DFM COPY ushape_err REGION
 err1 NOT INSIDE INST
}
 
Q: It's not recommended to use U-shape Mxy
    DRC check condition:
    1. With at least one RVy or RVy-1
    2. Mxy width W <= 0.038um
    3. S <= 0.12um
    Which rule is not applied for INST region
A: 
M3_R_6_RV3_DFM1 {
@ It's not recommended to use U-shape Mxy
@ DRC check condition:
@ 1. With at least one RVy or RVy-1
@ 2. Mxy width W <= 0.038um
@ 3. S <= 0.12um
@ Which rule is not applied for INST region
 ushape_opp = LENGTH M3_convex_270_270_edges <= 0.120
 ushape_wid = INT ushape_opp M3_convex_gt_one_edges <= 0.038 OPPOSITE
 ushape_edg = ushape_opp COIN EDGE (DFM COPY ushape_wid EDGE)
 ushape_met = (M3 WITH EDGE ushape_edg) INTERACT RV3
 ushape_chk = ushape_edg COIN EDGE ushape_met
 ushape_038 = (EXPAND EDGE ushape_chk INSIDE BY 0.038) AND M3
 ushape_via = (SIZE ushape_038 BY 0.12 INSIDE OF M3 STEP 0.01) INTERACT RV3
 ushape_err = DFM PROPERTY ushape_wid ushape_via OVERLAP ABUT ALSO MULTI [s= area(ushape_via)] > 0 [w= min(ew(ushape_wid))] > 0
 // 
 err1 = DFM COPY ushape_err REGION
 err1 NOT INSIDE INST
}
 
Q: It's not recommended to use Hook-shape Mxy
    Hook-shape Mxy definition:
    (1) Hook-end line width(W1) is <= 0.05um, length(L1) <= 0.15um, ΔL > 0.1um and Hook-end interact one via
    (2) W2/W3 width <= 0.072um
    (3) Space between two Mxy arms(S1) <= 0.1um
    (4) Space between via and another Mxy S2 <= 0.038um when PRL > -0.015um
    DRC waive if hook-end enclosure via >= 0.05um
    This rule is not applied for INST region
A: 
M3_R_7_V2_DFM1 {
@ It's not recommended to use Hook-shape Mxy
@ Hook-shape Mxy definition:
@ (1) Hook-end line width(W1) is <= 0.05um, length(L1) <= 0.15um, ΔL > 0.1um and Hook-end interact one via
@ (2) W2/W3 width <= 0.072um
@ (3) Space between two Mxy arms(S1) <= 0.1um
@ (4) Space between via and another Mxy S2 <= 0.038um when PRL > -0.015um
@ DRC waive if hook-end enclosure via >= 0.05um
@ This rule is not applied for INST region
 hook_neck = CONVEX EDGE M3 ANGLE1==270 LENGTH1<=0.15 ANGLE2==270 LENGTH2>0 WITH LENGTH <= 0.100
 hook_neck_ege = hook_neck NOT TOUCH EDGE (INT (hook_neck) M3 <= 0.072 ABUT<90 OPPOSITE)
 hook_neck_exd = EXPAND EDGE hook_neck_ege OUTSIDE BY 0.01
 hook_neck_sid = M3 COIN EDGE hook_neck_exd
 // 
 hook_seek = (M3 WITH EDGE hook_neck_ege) WITH EDGE M3_end_0.050
 hook_head_sid = INT [hook_seek] <= 0.05 ABUT<90 OPPOSITE
 hook_head_end = M3_end_0.050 TOUCH EDGE hook_seek
 hook_head_end_r = M3_end_0.050 TOUCH EDGE (OR EDGE (ENC V2 [hook_head_end] < 0.05 ABUT<90 OPPOSITE) (ENC V3 [hook_head_end] < 0.05 ABUT<90 OPPOSITE))
 hook_head_via_b = V2 WITH EDGE (ENC [V2] hook_head_end < 0.05 ABUT<90 OPPOSITE)
 hook_head_via_u = V3 WITH EDGE (ENC [V3] hook_head_end < 0.05 ABUT<90 OPPOSITE)
 hook_head_via_b_sid = ENC [hook_head_via_b] hook_head_sid <= 0.018 ABUT<90 OPPOSITE
 hook_head_via_u_sid = ENC [hook_head_via_u] hook_head_sid <= 0.018 ABUT<90 OPPOSITE
 hook_head_via = hook_head_via_b WITH EDGE (EXT M3 [hook_head_via_b_sid] < 0.038+GLOBAL_TOLERANCE ABUT<90 OPPOSITE EXTENDED 0.015 MEASURE ALL)
 // 
 hook_seek_met = hook_seek ENCLOSE hook_head_via
 hook_neck_cor = EXT [hook_seek_met] < 0.005 ABUT==90 INTERSECTING ONLY
 hook_neck_err = EXT hook_neck_cor <= 0.100 ABUT<90 OPPOSITE
 hook_neck_arm = hook_seek_met TOUCH EDGE hook_neck_cor
 hook_neck_dtl = DFM PROPERTY hook_neck_err hook_neck_arm OVERLAP ABUT ALSO MULTI [dt_l = max(length(hook_neck_arm)) - min(length(hook_neck_arm))]
 // 
 hook_head_a = (INT (M3_convex_gt_one_edges TOUCH EDGE hook_seek_met) <= 0.05 OPPOSITE REGION) WITH EDGE hook_head_end_r
 hook_head_b = NOT ENCLOSE RECTANGLE hook_head_a 0.001 0.150+GLOBAL_TOLERANCE ORTHOGONAL ONLY
 hook_head = hook_head_b NOT OUTSIDE hook_head_via
 hook_tail = INT (hook_neck_sid) M3 <= 0.072 ABUT<90 OPPOSITE
 hook_gain = DFM PROPERTY hook_neck_err hook_tail hook_head hook_neck_dtl OVERLAP ABUT ALSO MULTI 
 [-= (count(hook_head) > 0 && count(hook_tail) == 0) ? 1 : 0] > 0 [dt_l = property(hook_neck_dtl,dt_l)] > 0.10
 err1 = DFM COPY hook_gain REGION
 err1 NOT INSIDE INST
}
 
Q: It's not recommended to use Hook-shape Mxy
    Hook-shape Mxy definition:
    (1) Hook-end line width(W1) is <= 0.05um, length(L1) <= 0.15um, ΔL > 0.1um and Hook-end interact one via
    (2) W2/W3 width <= 0.072um
    (3) Space between two Mxy arms(S1) <= 0.1um
    (4) Space between via and another Mxy S2 <= 0.038um when PRL > -0.015um
    DRC waive if hook-end enclosure via >= 0.05um
    This rule is not applied for INST region
A: 
M3_R_7_V3_DFM1 {
@ It's not recommended to use Hook-shape Mxy
@ Hook-shape Mxy definition:
@ (1) Hook-end line width(W1) is <= 0.05um, length(L1) <= 0.15um, ΔL > 0.1um and Hook-end interact one via
@ (2) W2/W3 width <= 0.072um
@ (3) Space between two Mxy arms(S1) <= 0.1um
@ (4) Space between via and another Mxy S2 <= 0.038um when PRL > -0.015um
@ DRC waive if hook-end enclosure via >= 0.05um
@ This rule is not applied for INST region
 hook_neck = CONVEX EDGE M3 ANGLE1==270 LENGTH1<=0.15 ANGLE2==270 LENGTH2>0 WITH LENGTH <= 0.100
 hook_neck_ege = hook_neck NOT TOUCH EDGE (INT (hook_neck) M3 <= 0.072 ABUT<90 OPPOSITE)
 hook_neck_exd = EXPAND EDGE hook_neck_ege OUTSIDE BY 0.01
 hook_neck_sid = M3 COIN EDGE hook_neck_exd
 // 
 hook_seek = (M3 WITH EDGE hook_neck_ege) WITH EDGE M3_end_0.050
 hook_head_sid = INT [hook_seek] <= 0.05 ABUT<90 OPPOSITE
 hook_head_end = M3_end_0.050 TOUCH EDGE hook_seek
 hook_head_end_r = M3_end_0.050 TOUCH EDGE (OR EDGE (ENC V2 [hook_head_end] < 0.05 ABUT<90 OPPOSITE) (ENC V3 [hook_head_end] < 0.05 ABUT<90 OPPOSITE))
 hook_head_via_b = V2 WITH EDGE (ENC [V2] hook_head_end < 0.05 ABUT<90 OPPOSITE)
 hook_head_via_u = V3 WITH EDGE (ENC [V3] hook_head_end < 0.05 ABUT<90 OPPOSITE)
 hook_head_via_b_sid = ENC [hook_head_via_b] hook_head_sid <= 0.018 ABUT<90 OPPOSITE
 hook_head_via_u_sid = ENC [hook_head_via_u] hook_head_sid <= 0.018 ABUT<90 OPPOSITE
 hook_head_via = hook_head_via_u WITH EDGE (EXT M3 [hook_head_via_u_sid] < 0.038+GLOBAL_TOLERANCE ABUT<90 OPPOSITE EXTENDED 0.015 MEASURE ALL)
 // 
 hook_seek_met = hook_seek ENCLOSE hook_head_via
 hook_neck_cor = EXT [hook_seek_met] < 0.005 ABUT==90 INTERSECTING ONLY
 hook_neck_err = EXT hook_neck_cor <= 0.100 ABUT<90 OPPOSITE
 hook_neck_arm = hook_seek_met TOUCH EDGE hook_neck_cor
 hook_neck_dtl = DFM PROPERTY hook_neck_err hook_neck_arm OVERLAP ABUT ALSO MULTI [dt_l = max(length(hook_neck_arm)) - min(length(hook_neck_arm))]
 // 
 hook_head_a = (INT (M3_convex_gt_one_edges TOUCH EDGE hook_seek_met) <= 0.05 OPPOSITE REGION) WITH EDGE hook_head_end_r
 hook_head_b = NOT ENCLOSE RECTANGLE hook_head_a 0.001 0.150+GLOBAL_TOLERANCE ORTHOGONAL ONLY
 hook_head = hook_head_b NOT OUTSIDE hook_head_via
 hook_tail = INT (hook_neck_sid) M3 <= 0.072 ABUT<90 OPPOSITE
 hook_gain = DFM PROPERTY hook_neck_err hook_tail hook_head hook_neck_dtl OVERLAP ABUT ALSO MULTI 
 [-= (count(hook_head) > 0 && count(hook_tail) == 0) ? 1 : 0] > 0 [dt_l = property(hook_neck_dtl,dt_l)] > 0.10
 err1 = DFM COPY hook_gain REGION
 err1 NOT INSIDE INST
}
 
Q: It's not recommended to use dense Mxy line end pattern
    DRC flage conditions:
    (1) Middle Mxy line width(W1) <= 0.038um, both two neighbour Mxy lines width <= 0.064um
    (2) Both the Vy-1 dense region (dense region definition: region formed by Vy-1 horizontal edge extension 0.038um, vertical edge extension 0.05um) horizontal edges neighbour Mxy line-end
    DRC waive if Mxy enclosure Vy-1 > 0.05um. (Vy-1 is the via underneath Mxy)
    This rule is not applied for INST region
A: 
M3_R_8_DFM1 {
@ It's not recommended to use dense Mxy line end pattern
@ DRC flage conditions:
@ (1) Middle Mxy line width(W1) <= 0.038um, both two neighbour Mxy lines width <= 0.064um
@ (2) Both the Vy-1 dense region (dense region definition: region formed by Vy-1 horizontal edge extension 0.038um, vertical edge extension 0.05um) horizontal edges neighbour Mxy line-end
@ DRC waive if Mxy enclosure Vy-1 > 0.05um. (Vy-1 is the via underneath Mxy)
@ This rule is not applied for INST region
 via_met = V2_SR NOT OUTSIDE (M3 WITH WIDTH <= 0.038)
 via_end = via_met TOUCH EDGE (ENC [via_met] M3_end_0.038 <= 0.05 ABUT<90 OPPOSITE)
 via_lin = (via_met NOT TOUCH EDGE via_end) TOUCH EDGE (ENC [via_met] met3_38_side <= 0.006 ABUT<90 OPPOSITE)
 via_mid = (via_met WITH EDGE via_end) WITH EDGE via_lin == 2
 via_sid = via_mid TOUCH EDGE via_lin
 // 
 nei_end = LENGTH M3_convex_90_90_edges <= 0.064
 nei_sid = LENGTH (EXPAND EDGE nei_end OUTSIDE BY 0.001) == 0.001
 nei_via = EXT [via_sid] nei_sid < 0.038+GLOBAL_TOLERANCE ABUT<90 OPPOSITE EXTENDED 0.050 MEASURE ALL
 err1 = via_mid WITH EDGE (via_mid TOUCH EDGE nei_via) >= 2
 err1 NOT INSIDE INST
}
 
Q: It's not recommended to use dense Mxy 3-bar pattern
    DRC flag conditions:
    (1) Middle Mxy line width(W1) is <= 0.048um, both two neighbour Mxy line width <= 0.064um and interact square or rectangle Vy or Vy-1
    (2) Mxy Space to both via (S1/S2) = 0.058~0.063um
    (3) The via PRL: -0.1 < PRL < 0.1um
    (4) Both neighbour Mxy enclosure Vy or Vy-1 < 0.05um
    This rule is not applied for INST region
A: 
M3_R_9_V2_DFM1 {
@ It's not recommended to use dense Mxy 3-bar pattern
@ DRC flag conditions:
@ (1) Middle Mxy line width(W1) is <= 0.048um, both two neighbour Mxy line width <= 0.064um and interact square or rectangle Vy or Vy-1
@ (2) Mxy Space to both via (S1/S2) = 0.058~0.063um
@ (3) The via PRL: -0.1 < PRL < 0.1um
@ (4) Both neighbour Mxy enclosure Vy or Vy-1 < 0.05um
@ This rule is not applied for INST region
 via_d_met = V2_SR NOT OUTSIDE (M3 WITH WIDTH <= 0.064)
 via_d_end = via_d_met TOUCH EDGE (ENC [via_d_met] M3_end_0.064 < 0.05 ABUT<90 OPPOSITE)
 via_d_lin = (via_d_met NOT TOUCH EDGE via_d_end) TOUCH EDGE (ENC [via_d_met] met3_64_side <= 0.032 ABUT<90 OPPOSITE)
 via_d_mid = (via_d_met WITH EDGE via_d_end) WITH EDGE via_d_lin >= 2
 via_d_sid = via_d_mid TOUCH EDGE via_d_lin
 via_d_sps = (EXT [met3_48_side] via_d_sid >= 0.058 <= 0.063 OPPOSITE EXTENDED 0.1 MEASURE ALL) TOUCH EDGE (EXT [met3_48_side] via_d_sid >= 0.058 <= 0.063 OPPOSITE MEASURE ALL)
 err1 = INT via_d_sps <= 0.048 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE INST
}
 
Q: It's not recommended to use dense Mxy 3-bar pattern
    DRC flag conditions:
    (1) Middle Mxy line width(W1) is <= 0.048um, both two neighbour Mxy line width <= 0.064um and interact square or rectangle Vy or Vy-1
    (2) Mxy Space to both via (S1/S2) = 0.058~0.063um
    (3) The via PRL: -0.1 < PRL < 0.1um
    (4) Both neighbour Mxy enclosure Vy or Vy-1 < 0.05um
    This rule is not applied for INST region
A: 
M3_R_9_V3_DFM1 {
@ It's not recommended to use dense Mxy 3-bar pattern
@ DRC flag conditions:
@ (1) Middle Mxy line width(W1) is <= 0.048um, both two neighbour Mxy line width <= 0.064um and interact square or rectangle Vy or Vy-1
@ (2) Mxy Space to both via (S1/S2) = 0.058~0.063um
@ (3) The via PRL: -0.1 < PRL < 0.1um
@ (4) Both neighbour Mxy enclosure Vy or Vy-1 < 0.05um
@ This rule is not applied for INST region
 via_u_met = V3_SR NOT OUTSIDE (M3 WITH WIDTH <= 0.064)
 via_u_end = via_u_met TOUCH EDGE (ENC [via_u_met] M3_end_0.064 < 0.05 ABUT<90 OPPOSITE)
 via_u_lin = (via_u_met NOT TOUCH EDGE via_u_end) TOUCH EDGE (ENC [via_u_met] met3_64_side <= 0.032 ABUT<90 OPPOSITE)
 via_u_mid = (via_u_met WITH EDGE via_u_end) WITH EDGE via_u_lin >= 2
 via_u_sid = via_u_mid TOUCH EDGE via_u_lin
 via_u_sps = (EXT [met3_48_side] via_u_sid >= 0.058 <= 0.063 OPPOSITE EXTENDED 0.1 MEASURE ALL) TOUCH EDGE (EXT [met3_48_side] via_u_sid >= 0.058 <= 0.063 OPPOSITE MEASURE ALL)
 err1 = INT via_u_sps <= 0.048 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE INST
}

Q: U-shape metal pitch (W+S1) or (W+S2) must be >= 0.072um except M2 in INST region
    Vy enclosure by Mxy line-end (E) must be >= 0.032um (Mxy is the metal underneath Vy)
    When:
    (1) Both PRL1 and PRL2 >= -0.015um
    (2) Space (S) < 0.070um along length direction
    (3) W < 0.046um
    DRC waive if S1 or S2 > 0.04um
A: 
M3_R_7 {
@ U-shape metal pitch (W+S1) or (W+S2) must be >= 0.072um except M2 in INST region
@ Vy enclosure by Mxy line-end (E) must be >= 0.032um (Mxy is the metal underneath Vy)
@ When:
@ (1) Both PRL1 and PRL2 >= -0.015um
@ (2) Space (S) < 0.070um along length direction
@ (3) W < 0.046um
@ DRC waive if S1 or S2 > 0.04um
 end_enc = M3_end_0.046 NOT TOUCH EDGE (ENC V3 [M3_end_0.046] < 0.032 ABUT<90 OPPOSITE)
 end_sps = end_enc TOUCH EDGE (EXT [end_enc] M3_convex_270_270_edges < 0.07 ABUT<90 OPPOSITE)
 end_epd = EXPAND EDGE end_sps OUTSIDE BY 0.016
 end_sid = LENGTH (end_epd NOT TOUCH EDGE M3) == 0.016
 end_wid = INT end_sid < 0.046 ABUT<90 OPPOSITE
 end_sds = EXT end_sid M3 < 0.04 ABUT<90 OPPOSITE
 err1 = DFM PROPERTY end_epd end_wid end_sds OVERLAP ABUT ALSO MULTI 
 [+= (count(end_wid) > 0 && count(end_sds) > 0) ? 1 : 0] > 0 [-= min(ew(end_wid)) + min(ew(end_sds))] < 0.072
 err1 NOT INSIDE SealR_NOT_BULK
}
 
Q: U-shape metal pitch (W+S1) or (W+S2) must be >= 0.072um, except M2 in INST region
    When:
    1) Both PRL1 and PRL2 >= -0.015um
    2) Space (S) < 0.070um along length direction
    3) W < 0.046um
    4) Mxy interact Vy-1 and enclosure E < 0.05um. (Mxy is the metal above Vy-1)
    DRC waive if S1 or S2 > 0.04um
A: 
M3_R_8 {
@ U-shape metal pitch (W+S1) or (W+S2) must be >= 0.072um, except M2 in INST region
@ When:
@ 1) Both PRL1 and PRL2 >= -0.015um
@ 2) Space (S) < 0.070um along length direction
@ 3) W < 0.046um
@ 4) Mxy interact Vy-1 and enclosure E < 0.05um. (Mxy is the metal above Vy-1)
@ DRC waive if S1 or S2 > 0.04um
 end_enc = M3_end_0.046 TOUCH EDGE (ENC V2 [M3_end_0.046] < 0.05 ABUT<90 OPPOSITE)
 end_sps = end_enc TOUCH EDGE (EXT [end_enc] M3_convex_270_270_edges < 0.07 ABUT<90 OPPOSITE)
 end_epd = EXPAND EDGE end_sps OUTSIDE BY 0.016
 end_sid = LENGTH (end_epd NOT TOUCH EDGE M3) == 0.016
 end_wid = INT end_sid < 0.046 ABUT<90 OPPOSITE
 end_sds = EXT end_sid M3 < 0.04 ABUT<90 OPPOSITE
 err1 = DFM PROPERTY end_epd end_wid end_sds OVERLAP ABUT ALSO MULTI 
 [+= (count(end_wid) > 0 && count(end_sds) > 0) ? 1 : 0] > 0 [-= min(ew(end_wid)) + min(ew(end_sds))] < 0.072
 err1 NOT INSIDE SealR_NOT_BULK
}

//Vy1

Q: 45-degree (Vy OR RVy) is not allowed
A: 
Vy1_R_1 {
@ 45-degree (Vy OR RVy) is not allowed
 err1 = ANGLE (V1 NOT Vy1_BAR) > 44.5 < 45.5
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
Q: Single Vy is not allowed in H-shape Mxy+1/1.25xMy, when:
    1. The Mxy+1/1.25xMy has H-shape interacting with two metal holes: both two metal holes length <= 4.5um and two metal hole area <= 4.05um2
    2. The Vy overlaps on the center metal bar of this H-shape Mxy+1/1.25xMy
    3. The center metal bar length <= 0.9um and the metal bar width <= 0.12um
    DRC doesn't check when one or more square 1xVn is also on H-shape Mxy+1/1.25xMy region
A: 
Vy1_R_2 {
@ Single Vy is not allowed in H-shape Mxy+1/1.25xMy, when:
@ 1. The Mxy+1/1.25xMy has H-shape interacting with two metal holes: both two metal holes length <= 4.5um and two metal hole area <= 4.05um2
@ 2. The Vy overlaps on the center metal bar of this H-shape Mxy+1/1.25xMy
@ 3. The center metal bar length <= 0.9um and the metal bar width <= 0.12um
@ DRC doesn't check when one or more square 1xVn is also on H-shape Mxy+1/1.25xMy region
 hole_area_meet = AREA (HOLES M2 INNER) <= 4.05
 hole_area_meet_len = (hole_area_meet WITH EDGE (LENGTH hole_area_meet <= 0.9)) NOT WITH EDGE (LENGTH hole_area_meet > 4.5)
 hole_area_real = (hole_area_meet_len NOT ENCLOSE RECTANGLE 0.9+GLOBAL_TOLERANCE 4.5) NOT ENCLOSE RECTANGLE 0.9 4.5+GLOBAL_TOLERANCE
 hole_bars_len = M2 COIN EDGE hole_area_real
 // 
 hole_bars = INT hole_bars_len <= 0.12 ABUT<90 OPPOSITE REGION EXCLUDE SHIELDED
 hole_bars_real = hole_bars WITH EDGE (LENGTH hole_bars_len <= 0.9)
 hole_bars_vias_sq = V1N INTERACT ((hole_bars_real INTERACT hole_area_real == 2) NOT ENCLOSE RV1)
 err1 = hole_bars_real INTERACT hole_bars_vias_sq == 1
 err1 NOT INSIDE SealR_NOT_BULK
}
 
Q: (Vy OR RVy) overlap MTFUSE is not allowed, except V3
A: 
Vy1_R_7 {
@ (Vy OR RVy) overlap MTFUSE is not allowed, except V3
 err1 = V1 AND MTFUSE
 err1 NOT INSIDE SealR_NOT_BULK
}
// Vy.R.8[NC] Vy pattern must be drawn on data type 40
 
Q: It's not allowed Vy overlap with the metal resistor directly underneath and above the Vy
A: 
Vy1_R_9 {
@ It's not allowed Vy overlap with the metal resistor directly underneath and above the Vy
 err1 = V1 AND (M1RES AND M1)
 err2 = V1 AND (M2RES AND M2)
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}



 
Q: Recommend space between a square Vy and another (Vy OR RVy OR DUM_Vy) < 4um to avoid single square Vy
A: 
Vy1_R_10_R {
@ Recommend space between a square Vy and another (Vy OR RVy OR DUM_Vy) < 4um to avoid single square Vy
 ALL_VIA_CHECK = OR V1_SR DUM_V1
 STEP_1 = SIZE V1_SR BY 1.4
 // 4/1.414 = 2.828
 STEP_1_GOOD = STEP_1 INTERACT ALL_VIA_CHECK > 1
 STEP_1_FILTER = V1N NOT INTERACT STEP_1_GOOD
 err1 = STEP_1_FILTER NOT WITH EDGE (EXT [STEP_1_FILTER] ALL_VIA_CHECK < 4 PERP ALSO)
 err1 NOT INSIDE SealR_NOT_BULK
}

//Vy2

Q: 45-degree (Vy OR RVy) is not allowed
A: 
Vy2_R_1 {
@ 45-degree (Vy OR RVy) is not allowed
 err1 = ANGLE (V2 NOT Vy2_BAR) > 44.5 < 45.5
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
Q: Single Vy is not allowed in H-shape Mxy+1/1.25xMy, when:
    1. The Mxy+1/1.25xMy has H-shape interacting with two metal holes: both two metal holes length <= 4.5um and two metal hole area <= 4.05um2
    2. The Vy overlaps on the center metal bar of this H-shape Mxy+1/1.25xMy
    3. The center metal bar length <= 0.9um and the metal bar width <= 0.12um
    DRC doesn't check when one or more square 1xVn is also on H-shape Mxy+1/1.25xMy region
A: 
Vy2_R_2 {
@ Single Vy is not allowed in H-shape Mxy+1/1.25xMy, when:
@ 1. The Mxy+1/1.25xMy has H-shape interacting with two metal holes: both two metal holes length <= 4.5um and two metal hole area <= 4.05um2
@ 2. The Vy overlaps on the center metal bar of this H-shape Mxy+1/1.25xMy
@ 3. The center metal bar length <= 0.9um and the metal bar width <= 0.12um
@ DRC doesn't check when one or more square 1xVn is also on H-shape Mxy+1/1.25xMy region
 hole_area_meet = AREA (HOLES M3 INNER) <= 4.05
 hole_area_meet_len = (hole_area_meet WITH EDGE (LENGTH hole_area_meet <= 0.9)) NOT WITH EDGE (LENGTH hole_area_meet > 4.5)
 hole_area_real = (hole_area_meet_len NOT ENCLOSE RECTANGLE 0.9+GLOBAL_TOLERANCE 4.5) NOT ENCLOSE RECTANGLE 0.9 4.5+GLOBAL_TOLERANCE
 hole_bars_len = M3 COIN EDGE hole_area_real
 // 
 hole_bars = INT hole_bars_len <= 0.12 ABUT<90 OPPOSITE REGION EXCLUDE SHIELDED
 hole_bars_real = hole_bars WITH EDGE (LENGTH hole_bars_len <= 0.9)
 hole_bars_vias_sq = V2N INTERACT ((hole_bars_real INTERACT hole_area_real == 2) NOT ENCLOSE RV2)
 err1 = hole_bars_real INTERACT hole_bars_vias_sq == 1
 err1 NOT INSIDE SealR_NOT_BULK
}
 
Q: (Vy OR RVy) overlap MTFUSE is not allowed, except V3
A: 
Vy2_R_7 {
@ (Vy OR RVy) overlap MTFUSE is not allowed, except V3
 err1 = V2 AND MTFUSE
 err1 NOT INSIDE SealR_NOT_BULK
}
// Vy.R.8[NC] Vy pattern must be drawn on data type 40
 
Q: It's not allowed Vy overlap with the metal resistor directly underneath and above the Vy
A: 
Vy2_R_9 {
@ It's not allowed Vy overlap with the metal resistor directly underneath and above the Vy
 err1 = V2 AND (M2RES AND M2)
 err2 = V2 AND (M3RES AND M3)
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

#IFDEF RECOMMENDED_CHECK YES

 
Q: Recommend space between a square Vy and another (Vy OR RVy OR DUM_Vy) < 4um to avoid single square Vy
A: 
Vy2_R_10_R {
@ Recommend space between a square Vy and another (Vy OR RVy OR DUM_Vy) < 4um to avoid single square Vy
 ALL_VIA_CHECK = OR V2_SR DUM_V2
 STEP_1 = SIZE V2_SR BY 1.4
 // 4/1.414 = 2.828
 STEP_1_GOOD = STEP_1 INTERACT ALL_VIA_CHECK > 1
 STEP_1_FILTER = V2N NOT INTERACT STEP_1_GOOD
 err1 = STEP_1_FILTER NOT WITH EDGE (EXT [STEP_1_FILTER] ALL_VIA_CHECK < 4 PERP ALSO)
 err1 NOT INSIDE SealR_NOT_BULK
}



//Vy3

Q: 45-degree (Vy OR RVy) is not allowed
A: 
Vy3_R_1 {
@ 45-degree (Vy OR RVy) is not allowed
 err1 = ANGLE (V3 NOT Vy3_BAR) > 44.5 < 45.5
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
Q: Single Vy is not allowed in H-shape Mxy+1/1.25xMy, when:
    1. The Mxy+1/1.25xMy has H-shape interacting with two metal holes: both two metal holes length <= 4.5um and two metal hole area <= 4.05um2
    2. The Vy overlaps on the center metal bar of this H-shape Mxy+1/1.25xMy
    3. The center metal bar length <= 0.9um and the metal bar width <= 0.12um
    DRC doesn't check when one or more square 1xVn is also on H-shape Mxy+1/1.25xMy region
A: 
Vy3_R_2 {
@ Single Vy is not allowed in H-shape Mxy+1/1.25xMy, when:
@ 1. The Mxy+1/1.25xMy has H-shape interacting with two metal holes: both two metal holes length <= 4.5um and two metal hole area <= 4.05um2
@ 2. The Vy overlaps on the center metal bar of this H-shape Mxy+1/1.25xMy
@ 3. The center metal bar length <= 0.9um and the metal bar width <= 0.12um
@ DRC doesn't check when one or more square 1xVn is also on H-shape Mxy+1/1.25xMy region
 hole_area_meet = AREA (HOLES M4 INNER) <= 4.05
 hole_area_meet_len = (hole_area_meet WITH EDGE (LENGTH hole_area_meet <= 0.9)) NOT WITH EDGE (LENGTH hole_area_meet > 4.5)
 hole_area_real = (hole_area_meet_len NOT ENCLOSE RECTANGLE 0.9+GLOBAL_TOLERANCE 4.5) NOT ENCLOSE RECTANGLE 0.9 4.5+GLOBAL_TOLERANCE
 hole_bars_len = M4 COIN EDGE hole_area_real
 // 
 hole_bars = INT hole_bars_len <= 0.12 ABUT<90 OPPOSITE REGION EXCLUDE SHIELDED
 hole_bars_real = hole_bars WITH EDGE (LENGTH hole_bars_len <= 0.9)
 hole_bars_vias_sq = V3N INTERACT ((hole_bars_real INTERACT hole_area_real == 2) NOT ENCLOSE RV3)
 err1 = hole_bars_real INTERACT hole_bars_vias_sq == 1
 err1 NOT INSIDE SealR_NOT_BULK
}
 
Q: The numbers of neighboring square Vy to each edge of Vy (space <= 0.077um) when Vy under 1.25xMy < 2
A: 
Vy3_R_3 {
@ The numbers of neighboring square Vy to each edge of Vy (space <= 0.077um) when Vy under 1.25xMy < 2
 //;based on Vy.S.1 and Vy.S.2, so only check the space range 0.068~0.077um with PRL <= -0.032
 Y1 = EXT V3N >= 0.068 < 0.077+GLOBAL_TOLERANCE ABUT CORNER TO CORNER
 Y2 = DFM PROPERTY Y1 [-= (EWXP(Y1) > 0.032 && EWYP(Y1) > 0.032) ? 1 : 0] > 0
 Y3 = INT [V3N] < 0.001 ABUT INTERSECTING ONLY
 Y4 = Y3 COIN EDGE (DFM COPY Y2 EDGE)
 Y5 = INT Y4 V3N < 0.001 ABUT==90 INTERSECTING ONLY REGION
 Y6 = (INT (V3N COIN EDGE Y5) <= 0.032 OPPOSITE REGION) OR (INT (V3N COIN EDGE Y5) == 0.064 OPPOSITE REGION)
 err1 = V3N INTERACT Y6
 err1 NOT INSIDE SealR_NOT_BULK
}
 
Q: The numbers of neighboring square Vy in one group (space <= 0.077um) when Vy under 1.25xMy <= 3
A: 
Vy3_R_4 {
@ The numbers of neighboring square Vy in one group (space <= 0.077um) when Vy under 1.25xMy <= 3
 err1 = WITH NEIGHBOR V3N > 2 SPACE < 0.077+GLOBAL_TOLERANCE
 err1 NOT INSIDE SealR_NOT_BULK
}
// Vy.R.8[NC] Vy pattern must be drawn on data type 40
 
Q: It's not allowed Vy overlap with the metal resistor directly underneath and above the Vy
A: 
Vy3_R_9 {
@ It's not allowed Vy overlap with the metal resistor directly underneath and above the Vy
 err1 = V3 AND (M3RES AND M3)
 err2 = V3 AND (M4RES AND M4)
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}


Q: Recommend space between a square Vy and another (Vy OR RVy OR DUM_Vy) < 4um to avoid single square Vy
A: 
Vy3_R_10_R {
@ Recommend space between a square Vy and another (Vy OR RVy OR DUM_Vy) < 4um to avoid single square Vy
 ALL_VIA_CHECK = OR V3_SR DUM_V3
 STEP_1 = SIZE V3_SR BY 1.4
 // 4/1.414 = 2.828
 STEP_1_GOOD = STEP_1 INTERACT ALL_VIA_CHECK > 1
 STEP_1_FILTER = V3N NOT INTERACT STEP_1_GOOD
 err1 = STEP_1_FILTER NOT WITH EDGE (EXT [STEP_1_FILTER] ALL_VIA_CHECK < 4 PERP ALSO)
 err1 NOT INSIDE SealR_NOT_BULK
}


//RVy1


Q: Single RVy is not allowed in H-shape Mxy+1/1.25xMy, when:
    1) The Mxy+1/1.25xMy has H-shape interacting with two metal holes: both two metal holes length <= 4.5um and two metal hole area <= 4.05um2
    2) The RVy overlaps on the center metal bar of this H-shape Mxy+1/1.25xMy
    3) The center metal bar length <= 0.9um and the metal bar width <= 0.12um
A: 
RVy1_R_1 {
@ Single RVy is not allowed in H-shape Mxy+1/1.25xMy, when:
@ 1) The Mxy+1/1.25xMy has H-shape interacting with two metal holes: both two metal holes length <= 4.5um and two metal hole area <= 4.05um2
@ 2) The RVy overlaps on the center metal bar of this H-shape Mxy+1/1.25xMy
@ 3) The center metal bar length <= 0.9um and the metal bar width <= 0.12um
 // @ DRC doesn't check when one or more square 1xVn is also on H-shape Mxy+1/1.25xMy region
 hole_area_meet = AREA (HOLES M2 INNER) <= 4.05
 hole_area_meet_len = (hole_area_meet WITH EDGE (LENGTH hole_area_meet <= 0.9)) NOT WITH EDGE (LENGTH hole_area_meet > 4.5)
 hole_area_real = (hole_area_meet_len NOT ENCLOSE RECTANGLE 0.9+GLOBAL_TOLERANCE 4.5) NOT ENCLOSE RECTANGLE 0.9 4.5+GLOBAL_TOLERANCE
 hole_bars_len = M2 COIN EDGE hole_area_real
 // 
 hole_bars = INT hole_bars_len <= 0.12 ABUT<90 OPPOSITE REGION EXCLUDE SHIELDED
 hole_bars_real = hole_bars WITH EDGE (LENGTH hole_bars_len <= 0.9)
 hole_bars_vias_rect = RV1 INTERACT ((hole_bars_real INTERACT hole_area_real == 2) NOT ENCLOSE V1N >= 2)
 err1 = hole_bars_real INTERACT hole_bars_vias_rect == 1
 err1 NOT INSIDE SealR_NOT_BULK
}
 
Q: Redundant via requirement must be obeyed by one of following conditions of Vy numbers and space for Mxy and 1.25xMy connection
    (One of Mxy or 1.25xMy has width and length >= 0.162um) (Except VIA bar)
    1) At least one rectangular Vy
    2) At least two square Vy with space <= 0.091um
    3) At least four square Vy with space <= 0.415um
A: 
RVy1_R_2 {
@ Redundant via requirement must be obeyed by one of following conditions of Vy numbers and space for Mxy and 1.25xMy connection
@ (One of Mxy or 1.25xMy has width and length >= 0.162um) (Except VIA bar)
@ 1) At least one rectangular Vy
@ 2) At least two square Vy with space <= 0.091um
@ 3) At least four square Vy with space <= 0.415um
 X1a = WITH WIDTH M1 > 0.162-GLOBAL_TOLERANCE <= 0.272-GLOBAL_TOLERANCE
 X1b = WITH WIDTH M2 > 0.162-GLOBAL_TOLERANCE <= 0.272-GLOBAL_TOLERANCE
 Y1a = WITH WIDTH M1 > 0.272-GLOBAL_TOLERANCE
 Y1b = WITH WIDTH M2 > 0.272-GLOBAL_TOLERANCE
 WIDE_1 = (X1a AND M2) ENCLOSE V1
 WIDE_2 = (M1 AND X1b) ENCLOSE V1
 WIDE_3 = (Y1a AND M2) ENCLOSE V1
 WIDE_4 = (M1 AND Y1b) ENCLOSE V1
 WIDE_all_raw = (WIDE_1 OR WIDE_2) NOT (WIDE_3 OR WIDE_4)
 WIDE_all = (M1 AND M2) NOT OUTSIDE WIDE_all_raw
 // 
 // condition 1 & 2
 Y1_good = WIDE_all_raw AND RV1
 Y2_good = WIDE_all_raw AND 2XV1N
 // 
 // condition 3
 Y3_wide_all = WIDE_all_raw NOT INTERACT (OR Y1_good Y2_good)
 Y3_wide = (WIDE_all INTERACT Y3_wide_all) INTERACT V1_SR >= 2
 Y3_comb_step = SIZE V1_SR BY 0.091/2 INSIDE OF Y3_wide STEP 0.020
 Y3_good_step = OR (Y3_comb_step INTERACT V1N >= 2) (Y3_comb_step INTERACT (OR RV1 2XV1N))
 Y3_good = WIDE_all_raw AND Y3_good_step
 // 
 // condition 4: 32nm*32nm via can be replaced by 2XVia/RVia
 Y4_wide_all = WIDE_all_raw NOT INTERACT (OR Y1_good Y2_good Y3_good)
 Y4_wide = (WIDE_all INTERACT Y4_wide_all) INTERACT V1_SR >= 2 // rectangle array 0.415/2 =0.207
 Y4_vias_input = V1_SR AND Y4_wide
 Y4_wide_chk_1 = Y4_wide INTERACT Y4_wide_all
 Y4_comb_step1 = SIZE Y4_vias_input BY 0.050 INSIDE OF Y4_wide_chk_1 STEP 0.020
 Y4_good_step1_a = OR (Y4_comb_step1 INTERACT V1N >= 4) ((Y4_comb_step1 INTERACT V1N >= 2) INTERACT (OR RV1 2XV1N)) // step1: 0.050
 Y4_good_step1_b = OR (Y4_comb_step1 INTERACT 2XV1N >= 2) (Y4_comb_step1 INTERACT RV1 >= 2)
 Y4_good_step1 = OR Y4_good_step1_a Y4_good_step1_b
 // 
 Y4_wide_chk_2 = Y4_wide_chk_1 INTERACT (WIDE_all_raw NOT INTERACT Y4_good_step1)
 Y4_comb_step2 = SIZE Y4_comb_step1 BY 0.035 INSIDE OF Y4_wide_chk_2 STEP 0.020
 Y4_good_step2_a = OR (Y4_comb_step2 INTERACT V1N >= 4) ((Y4_comb_step2 INTERACT V1N >= 2) INTERACT (OR RV1 2XV1N)) // step2: 0.035
 Y4_good_step2_b = OR (Y4_comb_step2 INTERACT 2XV1N >= 2) (Y4_comb_step2 INTERACT RV1 >= 2)
 Y4_good_step2 = OR Y4_good_step2_a Y4_good_step2_b
 // 
 Y4_wide_chk_3 = Y4_wide_chk_2 INTERACT (WIDE_all_raw NOT INTERACT Y4_good_step2)
 Y4_comb_step3 = SIZE Y4_comb_step2 BY 0.035 INSIDE OF Y4_wide_chk_3 STEP 0.020
 Y4_good_step3_a = OR (Y4_comb_step3 INTERACT V1N >= 4) ((Y4_comb_step3 INTERACT V1N >= 2) INTERACT (OR RV1 2XV1N)) // step3: 0.035
 Y4_good_step3_b = OR (Y4_comb_step3 INTERACT 2XV1N >= 2) (Y4_comb_step3 INTERACT RV1 >= 2)
 Y4_good_step3 = OR Y4_good_step3_a Y4_good_step3_b
 // 
 Y4_wide_chk_4 = Y4_wide_chk_3 INTERACT (WIDE_all_raw NOT INTERACT Y4_good_step3)
 Y4_comb_step4 = SIZE Y4_comb_step3 BY 0.035 INSIDE OF Y4_wide_chk_4 STEP 0.020
 Y4_good_step4_a = OR (Y4_comb_step4 INTERACT V1N >= 4) ((Y4_comb_step4 INTERACT V1N >= 2) INTERACT (OR RV1 2XV1N)) // step4: 0.035
 Y4_good_step4_b = OR (Y4_comb_step4 INTERACT 2XV1N >= 2) (Y4_comb_step4 INTERACT RV1 >= 2)
 Y4_good_step4 = OR Y4_good_step4_a Y4_good_step4_b
 // 
 Y4_wide_chk_5 = Y4_wide_chk_4 INTERACT (WIDE_all_raw NOT INTERACT Y4_good_step4)
 Y4_comb_step5 = SIZE Y4_comb_step4 BY 0.035 INSIDE OF Y4_wide_chk_5 STEP 0.020
 Y4_good_step5_a = OR (Y4_comb_step5 INTERACT V1N >= 4) ((Y4_comb_step5 INTERACT V1N >= 2) INTERACT (OR RV1 2XV1N)) // step5: 0.035
 Y4_good_step5_b = OR (Y4_comb_step5 INTERACT 2XV1N >= 2) (Y4_comb_step5 INTERACT RV1 >= 2)
 Y4_good_step5 = OR Y4_good_step5_a Y4_good_step5_b
 // 
 Y4_wide_chk_6 = Y4_wide_chk_5 INTERACT (WIDE_all_raw NOT INTERACT Y4_good_step5)
 Y4_comb_step6 = SIZE Y4_comb_step5 BY 0.018 INSIDE OF Y4_wide_chk_6 STEP 0.015
 Y4_good_step6_a = OR (Y4_comb_step6 INTERACT V1N >= 4) ((Y4_comb_step6 INTERACT V1N >= 2) INTERACT (OR RV1 2XV1N)) // step6: 0.207-0.05-0.035*4=0.018
 Y4_good_step6_b = OR (Y4_comb_step6 INTERACT 2XV1N >= 2) (Y4_comb_step6 INTERACT RV1 >= 2)
 Y4_good_step6 = OR Y4_good_step6_a Y4_good_step6_b
 Y4_good = WIDE_all_raw AND (OR Y4_good_step1 Y4_good_step2 Y4_good_step3 Y4_good_step4 Y4_good_step5 Y4_good_step6)
 // 
 err1 = (WIDE_all_raw OUTSIDE (OR Y1_good Y2_good Y3_good Y4_good)) INTERACT V1
 err1 NOT INTERACT Vy1_BAR
}
 
Q: Redundant via requirement must be obeyed by one of following conditions of Vy numbers and space for Mxy and 1.25xMy connection
    (One of Mxy or 1.25xMy has width and length >= 0.272um, two square vias are equal to one rectangular via for below conditions) (Except VIA bar, MARKS and OCCD region)
    1) At least four square Vy with space <= 0.091um
    2) At least nine square Vy with space <= 0.545um
    3) At least two rectangular Vy with space <= 0.202um
    4) At least five rectangular Vy with space <= 0.545um
A: 
RVy1_R_3 {
@ Redundant via requirement must be obeyed by one of following conditions of Vy numbers and space for Mxy and 1.25xMy connection
@ (One of Mxy or 1.25xMy has width and length >= 0.272um, two square vias are equal to one rectangular via for below conditions) (Except VIA bar, MARKS and OCCD region)
@ 1) At least four square Vy with space <= 0.091um
@ 2) At least nine square Vy with space <= 0.545um
@ 3) At least two rectangular Vy with space <= 0.202um
@ 4) At least five rectangular Vy with space <= 0.545um
 X1a = WITH WIDTH M1 > 0.272-GLOBAL_TOLERANCE
 X1b = WITH WIDTH M2 > 0.272-GLOBAL_TOLERANCE
 WIDE_1 = (X1a AND M2) ENCLOSE V1
 WIDE_2 = (M1 AND X1b) ENCLOSE V1
 WIDE_all_raw = WIDE_1 OR WIDE_2
 WIDE_all = (M1 AND M2) NOT OUTSIDE WIDE_all_raw
 // 
 // condition 3: not replaced by RVia
 Y3_wide = WIDE_all INTERACT V1N >= 4 // rectangle array 0.091/2=0.045
 Y3_vias_input = V1N AND Y3_wide
 Y3_comb_step = SIZE Y3_vias_input BY 0.091/2 INSIDE OF Y3_wide STEP 0.02 // via minimum space = 0.083
 Y3_good_step = Y3_comb_step INTERACT V1N >= 4
 Y3_good = WIDE_all_raw AND Y3_good_step
 // 
 // condition 1 & 2 & 4 & 5: 32nm*32nm via can be replaced by 2XVia/RVia
 Y1_wide_all = WIDE_all_raw NOT INTERACT Y3_good
 Y1_wide = (WIDE_all INTERACT Y1_wide_all) INTERACT V1_SR >= 2 // rectangle array 0.545/2=0.272
 Y1_vias_input = V1_SR AND Y1_wide
 Y1_wide_chk_1 = Y1_wide INTERACT Y1_wide_all
 Y1_comb_step1 = SIZE Y1_vias_input BY 0.061 INSIDE OF Y1_wide_chk_1 STEP 0.02 // step1: 0.061, via minimum space = 0.202/2=0.101
 Y1_good_step1_a = Y1_comb_step1 INTERACT V1N >= 9
 Y1_good_step1_b = Y1_comb_step1 INTERACT RV1 >= 5
 Y1_good_step1_c = Y1_comb_step1 INTERACT 2XV1N >= 3
 Y1_good_step1_d = (Y1_comb_step1 INTERACT 1XV1N >= 7) INTERACT RV1 >= 1
 Y1_good_step1_e = (Y1_comb_step1 INTERACT 1XV1N >= 6) INTERACT 2XV1N >= 1
 Y1_good_step1_f = (Y1_comb_step1 INTERACT 1XV1N >= 5) INTERACT RV1 >= 2
 Y1_good_step1_g = ((Y1_comb_step1 INTERACT 1XV1N >= 4) INTERACT 2XV1N >= 1) INTERACT RV1 >= 1
 Y1_good_step1_h = (Y1_comb_step1 INTERACT 1XV1N >= 3) INTERACT RV1 >= 3
 Y1_good_step1_i = (Y1_comb_step1 INTERACT 1XV1N >= 3) INTERACT 2XV1N >= 2
 Y1_good_step1_j = ((Y1_comb_step1 INTERACT 1XV1N >= 2) INTERACT 2XV1N >= 1) INTERACT RV1 >= 2
 // SETLAYER Y1_good_step1_k = (Y1_comb_step1 INTERACT 1XV1N >= 1) INTERACT RV1 >= 4
 Y1_good_step1_l = ((Y1_comb_step1 INTERACT 1XV1N >= 1) INTERACT 2XV1N >= 2) INTERACT RV1 >= 1
 Y1_good_step1_m = Y1_comb_step1 INTERACT RV1 >= 2 // remove good condition3_val: 0.202
 Y1_good_step1_n = Y1_comb_step1 INTERACT 2XV1N >= 2
 Y1_good_step1_o = (Y1_comb_step1 INTERACT 1XV1N >= 2) INTERACT RV1 >= 1
 Y1_good_step1_p = (Y1_comb_step1 INTERACT 1XV1N >= 1) INTERACT 2XV1N >= 1
 Y1_good_step1_q = (Y1_comb_step1 INTERACT 2XV1N >= 1) INTERACT RV1 >= 1
 Y1_good_step1_r = OR Y1_good_step1_a Y1_good_step1_b Y1_good_step1_c Y1_good_step1_d Y1_good_step1_e Y1_good_step1_f Y1_good_step1_g Y1_good_step1_h
 Y1_good_step1_s = OR Y1_good_step1_i Y1_good_step1_j Y1_good_step1_l Y1_good_step1_m Y1_good_step1_n Y1_good_step1_o Y1_good_step1_p Y1_good_step1_q
 Y1_good_step1 = OR Y1_good_step1_r Y1_good_step1_s
 // 
 Y1_wide_chk_2 = Y1_wide_chk_1 INTERACT (WIDE_all_raw NOT INTERACT Y1_good_step1)
 Y1_comb_step2 = SIZE Y1_comb_step1 BY 0.040 INSIDE OF Y1_wide_chk_2 STEP 0.02 // step2: 0.040
 Y1_good_step2_a = Y1_comb_step2 INTERACT V1N >= 9
 Y1_good_step2_b = Y1_comb_step2 INTERACT RV1 >= 5
 Y1_good_step2_c = Y1_comb_step2 INTERACT 2XV1N >= 3
 Y1_good_step2_d = (Y1_comb_step2 INTERACT 1XV1N >= 7) INTERACT RV1 >= 1
 Y1_good_step2_e = (Y1_comb_step2 INTERACT 1XV1N >= 6) INTERACT 2XV1N >= 1
 Y1_good_step2_f = (Y1_comb_step2 INTERACT 1XV1N >= 5) INTERACT RV1 >= 2
 Y1_good_step2_g = ((Y1_comb_step2 INTERACT 1XV1N >= 4) INTERACT 2XV1N >= 1) INTERACT RV1 >= 1
 Y1_good_step2_h = (Y1_comb_step2 INTERACT 1XV1N >= 3) INTERACT RV1 >= 3
 Y1_good_step2_i = (Y1_comb_step2 INTERACT 1XV1N >= 3) INTERACT 2XV1N >= 2
 Y1_good_step2_j = ((Y1_comb_step2 INTERACT 1XV1N >= 2) INTERACT 2XV1N >= 1) INTERACT RV1 >= 2
 // SETLAYER Y1_good_step2_k = (Y1_comb_step2 INTERACT 1XV1N >= 1) INTERACT RV1 >= 4
 Y1_good_step2_l = ((Y1_comb_step2 INTERACT 1XV1N >= 1) INTERACT 2XV1N >= 2) INTERACT RV1 >= 1
 Y1_good_step2_m = Y1_comb_step2 INTERACT RV1 >= 2
 Y1_good_step2_n = Y1_comb_step2 INTERACT 2XV1N >= 2
 Y1_good_step2_o = (Y1_comb_step2 INTERACT 1XV1N >= 2) INTERACT RV1 >= 1
 Y1_good_step2_p = (Y1_comb_step2 INTERACT 1XV1N >= 1) INTERACT 2XV1N >= 1
 Y1_good_step2_q = (Y1_comb_step2 INTERACT 2XV1N >= 1) INTERACT RV1 >= 1
 Y1_good_step2_r = OR Y1_good_step2_a Y1_good_step2_b Y1_good_step2_c Y1_good_step2_d Y1_good_step2_e Y1_good_step2_f Y1_good_step2_g Y1_good_step2_h
 Y1_good_step2_s = OR Y1_good_step2_i Y1_good_step2_j Y1_good_step2_l Y1_good_step2_m Y1_good_step2_n Y1_good_step2_o Y1_good_step2_p Y1_good_step2_q
 Y1_good_step2 = OR Y1_good_step2_r Y1_good_step2_s
 // 
 // condition 1 & 2 & 4 & 5: 32nm*32nm via can be replaced by 2XVia/RVia
 Y1_wide_chk_3 = Y1_wide_chk_2 INTERACT (WIDE_all_raw NOT INTERACT Y1_good_step2)
 Y1_comb_step3 = SIZE Y1_comb_step2 BY 0.04 INSIDE OF Y1_wide_chk_3 STEP 0.02 // step3: 0.040
 Y1_good_step3_a = Y1_comb_step3 INTERACT V1N >= 9
 Y1_good_step3_b = Y1_comb_step3 INTERACT RV1 >= 5
 Y1_good_step3_c = Y1_comb_step3 INTERACT 2XV1N >= 3
 Y1_good_step3_d = (Y1_comb_step3 INTERACT 1XV1N >= 7) INTERACT RV1 >= 1
 Y1_good_step3_e = (Y1_comb_step3 INTERACT 1XV1N >= 6) INTERACT 2XV1N >= 1
 Y1_good_step3_f = (Y1_comb_step3 INTERACT 1XV1N >= 5) INTERACT RV1 >= 2
 Y1_good_step3_g = ((Y1_comb_step3 INTERACT 1XV1N >= 4) INTERACT 2XV1N >= 1) INTERACT RV1 >= 1
 Y1_good_step3_h = (Y1_comb_step3 INTERACT 1XV1N >= 3) INTERACT RV1 >= 3
 Y1_good_step3_i = (Y1_comb_step3 INTERACT 1XV1N >= 3) INTERACT 2XV1N >= 2
 Y1_good_step3_j = ((Y1_comb_step3 INTERACT 1XV1N >= 2) INTERACT 2XV1N >= 1) INTERACT RV1 >= 2
 // SETLAYER Y1_good_step3_k = (Y1_comb_step3 INTERACT 1XV1N >= 1) INTERACT RV1 >= 4
 Y1_good_step3_l = ((Y1_comb_step3 INTERACT 1XV1N >= 1) INTERACT 2XV1N >= 2) INTERACT RV1 >= 1
 Y1_good_step3_r = OR Y1_good_step3_a Y1_good_step3_b Y1_good_step3_c Y1_good_step3_d Y1_good_step3_e Y1_good_step3_f Y1_good_step3_g Y1_good_step3_h
 Y1_good_step3_s = OR Y1_good_step3_i Y1_good_step3_j Y1_good_step3_l
 Y1_good_step3 = OR Y1_good_step3_r Y1_good_step3_s
 // 
 Y1_wide_chk_4 = Y1_wide_chk_3 INTERACT (WIDE_all_raw NOT INTERACT Y1_good_step3)
 Y1_comb_step4 = SIZE Y1_comb_step3 BY 0.040 INSIDE OF Y1_wide_chk_4 STEP 0.02 // step4: 0.040
 Y1_good_step4_a = Y1_comb_step4 INTERACT V1N >= 9
 Y1_good_step4_b = Y1_comb_step4 INTERACT RV1 >= 5
 Y1_good_step4_c = Y1_comb_step4 INTERACT 2XV1N >= 3
 Y1_good_step4_d = (Y1_comb_step4 INTERACT 1XV1N >= 7) INTERACT RV1 >= 1
 Y1_good_step4_e = (Y1_comb_step4 INTERACT 1XV1N >= 6) INTERACT 2XV1N >= 1
 Y1_good_step4_f = (Y1_comb_step4 INTERACT 1XV1N >= 5) INTERACT RV1 >= 2
 Y1_good_step4_g = ((Y1_comb_step4 INTERACT 1XV1N >= 4) INTERACT 2XV1N >= 1) INTERACT RV1 >= 1
 Y1_good_step4_h = (Y1_comb_step4 INTERACT 1XV1N >= 3) INTERACT RV1 >= 3
 Y1_good_step4_i = (Y1_comb_step4 INTERACT 1XV1N >= 3) INTERACT 2XV1N >= 2
 Y1_good_step4_j = ((Y1_comb_step4 INTERACT 1XV1N >= 2) INTERACT 2XV1N >= 1) INTERACT RV1 >= 2
 // SETLAYER Y1_good_step4_k = (Y1_comb_step4 INTERACT 1XV1N >= 1) INTERACT RV1 >= 4
 Y1_good_step4_l = ((Y1_comb_step4 INTERACT 1XV1N >= 1) INTERACT 2XV1N >= 2) INTERACT RV1 >= 1
 Y1_good_step4_r = OR Y1_good_step4_a Y1_good_step4_b Y1_good_step4_c Y1_good_step4_d Y1_good_step4_e Y1_good_step4_f Y1_good_step4_g Y1_good_step4_h
 Y1_good_step4_s = OR Y1_good_step4_i Y1_good_step4_j Y1_good_step4_l
 Y1_good_step4 = OR Y1_good_step4_r Y1_good_step4_s
 // 
 Y1_wide_chk_5 = Y1_wide_chk_4 INTERACT (WIDE_all_raw NOT INTERACT Y1_good_step4)
 Y1_comb_step5 = SIZE Y1_comb_step4 BY 0.040 INSIDE OF Y1_wide_chk_5 STEP 0.02 // step5: 0.040
 Y1_good_step5_a = Y1_comb_step5 INTERACT V1N >= 9
 Y1_good_step5_b = Y1_comb_step5 INTERACT RV1 >= 5
 Y1_good_step5_c = Y1_comb_step5 INTERACT 2XV1N >= 3
 Y1_good_step5_d = (Y1_comb_step5 INTERACT 1XV1N >= 7) INTERACT RV1 >= 1
 Y1_good_step5_e = (Y1_comb_step5 INTERACT 1XV1N >= 6) INTERACT 2XV1N >= 1
 Y1_good_step5_f = (Y1_comb_step5 INTERACT 1XV1N >= 5) INTERACT RV1 >= 2
 Y1_good_step5_g = ((Y1_comb_step5 INTERACT 1XV1N >= 4) INTERACT 2XV1N >= 1) INTERACT RV1 >= 1
 Y1_good_step5_h = (Y1_comb_step5 INTERACT 1XV1N >= 3) INTERACT RV1 >= 3
 Y1_good_step5_i = (Y1_comb_step5 INTERACT 1XV1N >= 3) INTERACT 2XV1N >= 2
 Y1_good_step5_j = ((Y1_comb_step5 INTERACT 1XV1N >= 2) INTERACT 2XV1N >= 1) INTERACT RV1 >= 2
 // SETLAYER Y1_good_step5_k = (Y1_comb_step5 INTERACT 1XV1N >= 1) INTERACT RV1 >= 4
 Y1_good_step5_l = ((Y1_comb_step5 INTERACT 1XV1N >= 1) INTERACT 2XV1N >= 2) INTERACT RV1 >= 1
 Y1_good_step5_r = OR Y1_good_step5_a Y1_good_step5_b Y1_good_step5_c Y1_good_step5_d Y1_good_step5_e Y1_good_step5_f Y1_good_step5_g Y1_good_step5_h
 Y1_good_step5_s = OR Y1_good_step5_i Y1_good_step5_j Y1_good_step5_l
 Y1_good_step5 = OR Y1_good_step5_r Y1_good_step5_s
 // 
 Y1_wide_chk_6 = Y1_wide_chk_5 INTERACT (WIDE_all_raw NOT INTERACT Y1_good_step5)
 Y1_comb_step6 = SIZE Y1_comb_step5 BY 0.040 INSIDE OF Y1_wide_chk_6 STEP 0.02 // step6: 0.040
 Y1_good_step6_a = Y1_comb_step6 INTERACT V1N >= 9
 Y1_good_step6_b = Y1_comb_step6 INTERACT RV1 >= 5
 Y1_good_step6_c = Y1_comb_step6 INTERACT 2XV1N >= 3
 Y1_good_step6_d = (Y1_comb_step6 INTERACT 1XV1N >= 7) INTERACT RV1 >= 1
 Y1_good_step6_e = (Y1_comb_step6 INTERACT 1XV1N >= 6) INTERACT 2XV1N >= 1
 Y1_good_step6_f = (Y1_comb_step6 INTERACT 1XV1N >= 5) INTERACT RV1 >= 2
 Y1_good_step6_g = ((Y1_comb_step6 INTERACT 1XV1N >= 4) INTERACT 2XV1N >= 1) INTERACT RV1 >= 1
 Y1_good_step6_h = (Y1_comb_step6 INTERACT 1XV1N >= 3) INTERACT RV1 >= 3
 Y1_good_step6_i = (Y1_comb_step6 INTERACT 1XV1N >= 3) INTERACT 2XV1N >= 2
 Y1_good_step6_j = ((Y1_comb_step6 INTERACT 1XV1N >= 2) INTERACT 2XV1N >= 1) INTERACT RV1 >= 2
 // SETLAYER Y1_good_step6_k = (Y1_comb_step6 INTERACT 1XV1N >= 1) INTERACT RV1 >= 4
 Y1_good_step6_l = ((Y1_comb_step6 INTERACT 1XV1N >= 1) INTERACT 2XV1N >= 2) INTERACT RV1 >= 1
 Y1_good_step6_r = OR Y1_good_step6_a Y1_good_step6_b Y1_good_step6_c Y1_good_step6_d Y1_good_step6_e Y1_good_step6_f Y1_good_step6_g Y1_good_step6_h
 Y1_good_step6_s = OR Y1_good_step6_i Y1_good_step6_j Y1_good_step6_l
 Y1_good_step6 = OR Y1_good_step6_r Y1_good_step6_s
 // 
 Y1_wide_chk_7 = Y1_wide_chk_6 INTERACT (WIDE_all_raw NOT INTERACT Y1_good_step6)
 Y1_comb_step7 = SIZE Y1_comb_step6 BY 0.011 INSIDE OF Y1_wide_chk_7 STEP 0.02 // step7: 0.272-0.061-0.04-0.040*4=0.011
 Y1_good_step7_a = Y1_comb_step7 INTERACT V1N >= 9
 Y1_good_step7_b = Y1_comb_step7 INTERACT RV1 >= 5
 Y1_good_step7_c = Y1_comb_step7 INTERACT 2XV1N >= 3
 Y1_good_step7_d = (Y1_comb_step7 INTERACT 1XV1N >= 7) INTERACT RV1 >= 1
 Y1_good_step7_e = (Y1_comb_step7 INTERACT 1XV1N >= 6) INTERACT 2XV1N >= 1
 Y1_good_step7_f = (Y1_comb_step7 INTERACT 1XV1N >= 5) INTERACT RV1 >= 2
 Y1_good_step7_g = ((Y1_comb_step7 INTERACT 1XV1N >= 4) INTERACT 2XV1N >= 1) INTERACT RV1 >= 1
 Y1_good_step7_h = (Y1_comb_step7 INTERACT 1XV1N >= 3) INTERACT RV1 >= 3
 Y1_good_step7_i = (Y1_comb_step7 INTERACT 1XV1N >= 3) INTERACT 2XV1N >= 2
 Y1_good_step7_j = ((Y1_comb_step7 INTERACT 1XV1N >= 2) INTERACT 2XV1N >= 1) INTERACT RV1 >= 2
 // SETLAYER Y1_good_step7_k = (Y1_comb_step7 INTERACT 1XV1N >= 1) INTERACT RV1 >= 4
 Y1_good_step7_l = ((Y1_comb_step7 INTERACT 1XV1N >= 1) INTERACT 2XV1N >= 2) INTERACT RV1 >= 1
 Y1_good_step7_r = OR Y1_good_step7_a Y1_good_step7_b Y1_good_step7_c Y1_good_step7_d Y1_good_step7_e Y1_good_step7_f Y1_good_step7_g Y1_good_step7_h
 Y1_good_step7_s = OR Y1_good_step7_i Y1_good_step7_j Y1_good_step7_l
 Y1_good_step7 = OR Y1_good_step7_r Y1_good_step7_s
 Y1_Y2_Y4_good = WIDE_all_raw AND (OR Y1_good_step1 Y1_good_step2 Y1_good_step3 Y1_good_step4 Y1_good_step5 Y1_good_step6 Y1_good_step7)
 // 
 err1 = (WIDE_all_raw OUTSIDE (OR Y1_Y2_Y4_good Y3_good)) INTERACT V1
 (err1 NOT INTERACT Vy1_BAR) NOT INSIDE OCCD_MARKS
}
 
Q: There should be at least two square Vy or one rectangular Vy in the intersection area of bottom metal and upper metal, when either wide metal Mxy or 1.25xMy length >= 0.162um and width >= 0.162um, the space between either via and wide metal <= 0.5um (S, S is the shortest running path length from Via to the wide metal). (except via bar)
A: 
RVy1_R_4_M1 {
@ There should be at least two square Vy or one rectangular Vy in the intersection area of bottom metal and upper metal, when either wide metal Mxy or 1.25xMy length >= 0.162um and width >= 0.162um, the space between either via and wide metal <= 0.5um (S, S is the shortest running path length from Via to the wide metal). (except via bar)
 // DRC flags each intersecting area ({bottom metal AND upper metal}) with single square Via within the branch check region
 wide_M1 = (WITH WIDTH M1 > 0.162-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 0.162-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 0.162-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M1_real = wide_M1 NOT OUTSIDE ((SIZE wide_M1 BY 0.5+GLOBAL_TOLERANCE) INTERACT V1)
 all_down_and_up = (M1 INTERACT wide_M1) AND M2
 dis_down_arm_wide_all = SIZE wide_M1_real BY 0.5+GLOBAL_TOLERANCE INSIDE OF M1 STEP 0.025
 dis_down_and_up = dis_down_arm_wide_all AND all_down_and_up
 dis_down_and_up_arm = (dis_down_and_up NOT wide_M1) AND M1
 dis_down_arm = (dis_down_arm_wide_all NOT wide_M1) AND M1
 // 
 dis_down_arm_good_a = dis_down_and_up_arm INTERACT 1XV1N >= 2
 dis_down_arm_good_b = dis_down_and_up_arm INTERACT RV1
 dis_down_arm_good_c = dis_down_and_up_arm INTERACT 2XV1N
 dis_down_arm_good = OR dis_down_arm_good_a dis_down_arm_good_b dis_down_arm_good_c
 dis_down_arm_bad = (dis_down_and_up_arm NOT dis_down_arm_good) INTERACT (all_down_and_up INTERACT 1XV1N == 1)
 // 
 dis_down_arm_err_stack = (dis_down_arm_bad AND dis_down_and_up_arm) INTERACT 1XV1N
 dis_down_arm_err = dis_down_arm INTERACT dis_down_arm_err_stack
 err1_met_down = (dis_down_arm_err INTERACT (1XV1N NOT OUTSIDE dis_down_arm_err)) NOT INTERACT (OR RV1 2XV1N)
 // 
 wide_M2 = (WITH WIDTH M2 > 0.162-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 0.162-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 0.162-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M2_real = wide_M2 NOT OUTSIDE ((SIZE wide_M2 BY 0.5+GLOBAL_TOLERANCE) INTERACT V1)
 all_up_and_down = (M2 INTERACT wide_M2) AND M1
 dis_up_arm_wide_all = SIZE wide_M2_real BY 0.5+GLOBAL_TOLERANCE INSIDE OF M2 STEP 0.025
 dis_up_and_down = dis_up_arm_wide_all AND all_up_and_down
 dis_up_and_down_arm = (dis_up_and_down NOT wide_M2) AND M2
 dis_up_arm = (dis_up_arm_wide_all NOT wide_M2) AND M2
 // 
 dis_up_arm_good_a = dis_up_and_down_arm INTERACT 1XV1N >= 2
 dis_up_arm_good_b = dis_up_and_down_arm INTERACT RV1
 dis_up_arm_good_c = dis_up_and_down_arm INTERACT 2XV1N
 dis_up_arm_good = OR dis_up_arm_good_a dis_up_arm_good_b dis_up_arm_good_c
 dis_up_arm_bad = (dis_up_and_down_arm NOT dis_up_arm_good) INTERACT (all_up_and_down INTERACT 1XV1N == 1)
 // 
 dis_up_arm_err_stack = (dis_up_arm_bad AND dis_up_and_down_arm) INTERACT 1XV1N
 dis_up_arm_err = dis_up_arm INTERACT dis_up_arm_err_stack
 err2_met_up = (dis_up_arm_err INTERACT (1XV1N NOT OUTSIDE dis_up_arm_err)) NOT INTERACT (OR RV1 2XV1N)
 err1_met_down NOT INTERACT Vy1_BAR
}
 
Q: There should be at least two square Vy or one rectangular Vy in the intersection area of bottom metal and upper metal, when either wide metal Mxy or 1.25xMy length >= 0.162um and width >= 0.162um, the space between either via and wide metal <= 0.5um (S, S is the shortest running path length from Via to the wide metal). (except via bar)
A: 
RVy1_R_4_M2 {
@ There should be at least two square Vy or one rectangular Vy in the intersection area of bottom metal and upper metal, when either wide metal Mxy or 1.25xMy length >= 0.162um and width >= 0.162um, the space between either via and wide metal <= 0.5um (S, S is the shortest running path length from Via to the wide metal). (except via bar)
 // DRC flags each intersecting area ({bottom metal AND upper metal}) with single square Via within the branch check region
 wide_M1 = (WITH WIDTH M1 > 0.162-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 0.162-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 0.162-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M1_real = wide_M1 NOT OUTSIDE ((SIZE wide_M1 BY 0.5+GLOBAL_TOLERANCE) INTERACT V1)
 all_down_and_up = (M1 INTERACT wide_M1) AND M2
 dis_down_arm_wide_all = SIZE wide_M1_real BY 0.5+GLOBAL_TOLERANCE INSIDE OF M1 STEP 0.025
 dis_down_and_up = dis_down_arm_wide_all AND all_down_and_up
 dis_down_and_up_arm = (dis_down_and_up NOT wide_M1) AND M1
 dis_down_arm = (dis_down_arm_wide_all NOT wide_M1) AND M1
 // 
 dis_down_arm_good_a = dis_down_and_up_arm INTERACT 1XV1N >= 2
 dis_down_arm_good_b = dis_down_and_up_arm INTERACT RV1
 dis_down_arm_good_c = dis_down_and_up_arm INTERACT 2XV1N
 dis_down_arm_good = OR dis_down_arm_good_a dis_down_arm_good_b dis_down_arm_good_c
 dis_down_arm_bad = (dis_down_and_up_arm NOT dis_down_arm_good) INTERACT (all_down_and_up INTERACT 1XV1N == 1)
 // 
 dis_down_arm_err_stack = (dis_down_arm_bad AND dis_down_and_up_arm) INTERACT 1XV1N
 dis_down_arm_err = dis_down_arm INTERACT dis_down_arm_err_stack
 err1_met_down = (dis_down_arm_err INTERACT (1XV1N NOT OUTSIDE dis_down_arm_err)) NOT INTERACT (OR RV1 2XV1N)
 // 
 wide_M2 = (WITH WIDTH M2 > 0.162-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 0.162-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 0.162-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M2_real = wide_M2 NOT OUTSIDE ((SIZE wide_M2 BY 0.5+GLOBAL_TOLERANCE) INTERACT V1)
 all_up_and_down = (M2 INTERACT wide_M2) AND M1
 dis_up_arm_wide_all = SIZE wide_M2_real BY 0.5+GLOBAL_TOLERANCE INSIDE OF M2 STEP 0.025
 dis_up_and_down = dis_up_arm_wide_all AND all_up_and_down
 dis_up_and_down_arm = (dis_up_and_down NOT wide_M2) AND M2
 dis_up_arm = (dis_up_arm_wide_all NOT wide_M2) AND M2
 // 
 dis_up_arm_good_a = dis_up_and_down_arm INTERACT 1XV1N >= 2
 dis_up_arm_good_b = dis_up_and_down_arm INTERACT RV1
 dis_up_arm_good_c = dis_up_and_down_arm INTERACT 2XV1N
 dis_up_arm_good = OR dis_up_arm_good_a dis_up_arm_good_b dis_up_arm_good_c
 dis_up_arm_bad = (dis_up_and_down_arm NOT dis_up_arm_good) INTERACT (all_up_and_down INTERACT 1XV1N == 1)
 // 
 dis_up_arm_err_stack = (dis_up_arm_bad AND dis_up_and_down_arm) INTERACT 1XV1N
 dis_up_arm_err = dis_up_arm INTERACT dis_up_arm_err_stack
 err2_met_up = (dis_up_arm_err INTERACT (1XV1N NOT OUTSIDE dis_up_arm_err)) NOT INTERACT (OR RV1 2XV1N)
 err2_met_up NOT INTERACT Vy1_BAR
}
 
Q: There should be at least two square Vy or one rectangular Vy in the intersection area of bottom metal and upper metal, when either wide metal Mxy or 1.25xMy length >= 0.272um and width >= 0.272um, the space between either via and wide metal <= 1um (S, S is the shortest running path length from Via to the wide metal). (except via bar)
A: 
RVy1_R_5_M1 {
@ There should be at least two square Vy or one rectangular Vy in the intersection area of bottom metal and upper metal, when either wide metal Mxy or 1.25xMy length >= 0.272um and width >= 0.272um, the space between either via and wide metal <= 1um (S, S is the shortest running path length from Via to the wide metal). (except via bar)
 // DRC flags each intersecting area ({bottom metal AND upper metal}) with single square Via within the branch check region
 wide_M1 = (WITH WIDTH M1 > 0.272-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 0.272-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 0.272-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M1_real = wide_M1 NOT OUTSIDE ((SIZE wide_M1 BY 1+GLOBAL_TOLERANCE) INTERACT V1)
 all_down_and_up = (M1 INTERACT wide_M1) AND M2
 dis_down_arm_wide_all = SIZE wide_M1_real BY 1+GLOBAL_TOLERANCE INSIDE OF M1 STEP 0.025
 dis_down_and_up = dis_down_arm_wide_all AND all_down_and_up
 dis_down_and_up_arm = (dis_down_and_up NOT wide_M1) AND M1
 dis_down_arm = (dis_down_arm_wide_all NOT wide_M1) AND M1
 // 
 dis_down_arm_good_a = dis_down_and_up_arm INTERACT 1XV1N >= 2
 dis_down_arm_good_b = dis_down_and_up_arm INTERACT RV1
 dis_down_arm_good_c = dis_down_and_up_arm INTERACT 2XV1N
 dis_down_arm_good = OR dis_down_arm_good_a dis_down_arm_good_b dis_down_arm_good_c
 dis_down_arm_bad = (dis_down_and_up_arm NOT dis_down_arm_good) INTERACT (all_down_and_up INTERACT 1XV1N == 1)
 // 
 dis_down_arm_err_stack = (dis_down_arm_bad AND dis_down_and_up_arm) INTERACT 1XV1N
 dis_down_arm_err = dis_down_arm INTERACT dis_down_arm_err_stack
 err1_met_down = (dis_down_arm_err INTERACT (1XV1N NOT OUTSIDE dis_down_arm_err)) NOT INTERACT (OR RV1 2XV1N)
 // 
 wide_M2 = (WITH WIDTH M2 > 0.272-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 0.272-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 0.272-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M2_real = wide_M2 NOT OUTSIDE ((SIZE wide_M2 BY 1+GLOBAL_TOLERANCE) INTERACT V1)
 all_up_and_down = (M2 INTERACT wide_M2) AND M1
 dis_up_arm_wide_all = SIZE wide_M2_real BY 1+GLOBAL_TOLERANCE INSIDE OF M2 STEP 0.025
 dis_up_and_down = dis_up_arm_wide_all AND all_up_and_down
 dis_up_and_down_arm = (dis_up_and_down NOT wide_M2) AND M2
 dis_up_arm = (dis_up_arm_wide_all NOT wide_M2) AND M2
 // 
 dis_up_arm_good_a = dis_up_and_down_arm INTERACT 1XV1N >= 2
 dis_up_arm_good_b = dis_up_and_down_arm INTERACT RV1
 dis_up_arm_good_c = dis_up_and_down_arm INTERACT 2XV1N
 dis_up_arm_good = OR dis_up_arm_good_a dis_up_arm_good_b dis_up_arm_good_c
 dis_up_arm_bad = (dis_up_and_down_arm NOT dis_up_arm_good) INTERACT (all_up_and_down INTERACT 1XV1N == 1)
 // 
 dis_up_arm_err_stack = (dis_up_arm_bad AND dis_up_and_down_arm) INTERACT 1XV1N
 dis_up_arm_err = dis_up_arm INTERACT dis_up_arm_err_stack
 err2_met_up = (dis_up_arm_err INTERACT (1XV1N NOT OUTSIDE dis_up_arm_err)) NOT INTERACT (OR RV1 2XV1N)
 err1_met_down NOT INTERACT Vy1_BAR
}
 
Q: There should be at least two square Vy or one rectangular Vy in the intersection area of bottom metal and upper metal, when either wide metal Mxy or 1.25xMy length >= 0.272um and width >= 0.272um, the space between either via and wide metal <= 1um (S, S is the shortest running path length from Via to the wide metal). (except via bar)
A: 
RVy1_R_5_M2 {
@ There should be at least two square Vy or one rectangular Vy in the intersection area of bottom metal and upper metal, when either wide metal Mxy or 1.25xMy length >= 0.272um and width >= 0.272um, the space between either via and wide metal <= 1um (S, S is the shortest running path length from Via to the wide metal). (except via bar)
 // DRC flags each intersecting area ({bottom metal AND upper metal}) with single square Via within the branch check region
 wide_M1 = (WITH WIDTH M1 > 0.272-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 0.272-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 0.272-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M1_real = wide_M1 NOT OUTSIDE ((SIZE wide_M1 BY 1+GLOBAL_TOLERANCE) INTERACT V1)
 all_down_and_up = (M1 INTERACT wide_M1) AND M2
 dis_down_arm_wide_all = SIZE wide_M1_real BY 1+GLOBAL_TOLERANCE INSIDE OF M1 STEP 0.025
 dis_down_and_up = dis_down_arm_wide_all AND all_down_and_up
 dis_down_and_up_arm = (dis_down_and_up NOT wide_M1) AND M1
 dis_down_arm = (dis_down_arm_wide_all NOT wide_M1) AND M1
 // 
 dis_down_arm_good_a = dis_down_and_up_arm INTERACT 1XV1N >= 2
 dis_down_arm_good_b = dis_down_and_up_arm INTERACT RV1
 dis_down_arm_good_c = dis_down_and_up_arm INTERACT 2XV1N
 dis_down_arm_good = OR dis_down_arm_good_a dis_down_arm_good_b dis_down_arm_good_c
 dis_down_arm_bad = (dis_down_and_up_arm NOT dis_down_arm_good) INTERACT (all_down_and_up INTERACT 1XV1N == 1)
 // 
 dis_down_arm_err_stack = (dis_down_arm_bad AND dis_down_and_up_arm) INTERACT 1XV1N
 dis_down_arm_err = dis_down_arm INTERACT dis_down_arm_err_stack
 err1_met_down = (dis_down_arm_err INTERACT (1XV1N NOT OUTSIDE dis_down_arm_err)) NOT INTERACT (OR RV1 2XV1N)
 // 
 wide_M2 = (WITH WIDTH M2 > 0.272-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 0.272-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 0.272-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M2_real = wide_M2 NOT OUTSIDE ((SIZE wide_M2 BY 1+GLOBAL_TOLERANCE) INTERACT V1)
 all_up_and_down = (M2 INTERACT wide_M2) AND M1
 dis_up_arm_wide_all = SIZE wide_M2_real BY 1+GLOBAL_TOLERANCE INSIDE OF M2 STEP 0.025
 dis_up_and_down = dis_up_arm_wide_all AND all_up_and_down
 dis_up_and_down_arm = (dis_up_and_down NOT wide_M2) AND M2
 dis_up_arm = (dis_up_arm_wide_all NOT wide_M2) AND M2
 // 
 dis_up_arm_good_a = dis_up_and_down_arm INTERACT 1XV1N >= 2
 dis_up_arm_good_b = dis_up_and_down_arm INTERACT RV1
 dis_up_arm_good_c = dis_up_and_down_arm INTERACT 2XV1N
 dis_up_arm_good = OR dis_up_arm_good_a dis_up_arm_good_b dis_up_arm_good_c
 dis_up_arm_bad = (dis_up_and_down_arm NOT dis_up_arm_good) INTERACT (all_up_and_down INTERACT 1XV1N == 1)
 // 
 dis_up_arm_err_stack = (dis_up_arm_bad AND dis_up_and_down_arm) INTERACT 1XV1N
 dis_up_arm_err = dis_up_arm INTERACT dis_up_arm_err_stack
 err2_met_up = (dis_up_arm_err INTERACT (1XV1N NOT OUTSIDE dis_up_arm_err)) NOT INTERACT (OR RV1 2XV1N)
 err2_met_up NOT INTERACT Vy1_BAR
}
 
Q: There should be at least two square Vy or one rectangular Vy in the intersection area of bottom metal and upper metal, when either wide metal Mxy or 1.25xMy width and length >= 0.542um, the space between either via and wide metal <= 3um (S, S is the shortest running path length from Via to the wide metal). (except via bar)
A: 
RVy1_R_6_M1 {
@ There should be at least two square Vy or one rectangular Vy in the intersection area of bottom metal and upper metal, when either wide metal Mxy or 1.25xMy width and length >= 0.542um, the space between either via and wide metal <= 3um (S, S is the shortest running path length from Via to the wide metal). (except via bar)
 // DRC flags each intersecting area ({bottom metal AND upper metal}) with single square Via within the branch check region
 wide_M1 = (WITH WIDTH M1 > 0.542-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 0.542-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 0.542-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M1_real = wide_M1 NOT OUTSIDE ((SIZE wide_M1 BY 3+GLOBAL_TOLERANCE) INTERACT V1)
 all_down_and_up = (M1 INTERACT wide_M1) AND M2
 dis_down_arm_wide_all = SIZE wide_M1_real BY 3+GLOBAL_TOLERANCE INSIDE OF M1 STEP 0.025
 dis_down_and_up = dis_down_arm_wide_all AND all_down_and_up
 dis_down_and_up_arm = (dis_down_and_up NOT wide_M1) AND M1
 dis_down_arm = (dis_down_arm_wide_all NOT wide_M1) AND M1
 // 
 dis_down_arm_good_a = dis_down_and_up_arm INTERACT 1XV1N >= 2
 dis_down_arm_good_b = dis_down_and_up_arm INTERACT RV1
 dis_down_arm_good_c = dis_down_and_up_arm INTERACT 2XV1N
 dis_down_arm_good = OR dis_down_arm_good_a dis_down_arm_good_b dis_down_arm_good_c
 dis_down_arm_bad = (dis_down_and_up_arm NOT dis_down_arm_good) INTERACT (all_down_and_up INTERACT 1XV1N == 1)
 // 
 dis_down_arm_err_stack = (dis_down_arm_bad AND dis_down_and_up_arm) INTERACT 1XV1N
 dis_down_arm_err = dis_down_arm INTERACT dis_down_arm_err_stack
 err1_met_down = (dis_down_arm_err INTERACT (1XV1N NOT OUTSIDE dis_down_arm_err)) NOT INTERACT (OR RV1 2XV1N)
 // 
 wide_M2 = (WITH WIDTH M2 > 0.542-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 0.542-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 0.542-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M2_real = wide_M2 NOT OUTSIDE ((SIZE wide_M2 BY 3+GLOBAL_TOLERANCE) INTERACT V1)
 all_up_and_down = (M2 INTERACT wide_M2) AND M1
 dis_up_arm_wide_all = SIZE wide_M2_real BY 3+GLOBAL_TOLERANCE INSIDE OF M2 STEP 0.025
 dis_up_and_down = dis_up_arm_wide_all AND all_up_and_down
 dis_up_and_down_arm = (dis_up_and_down NOT wide_M2) AND M2
 dis_up_arm = (dis_up_arm_wide_all NOT wide_M2) AND M2
 // 
 dis_up_arm_good_a = dis_up_and_down_arm INTERACT 1XV1N >= 2
 dis_up_arm_good_b = dis_up_and_down_arm INTERACT RV1
 dis_up_arm_good_c = dis_up_and_down_arm INTERACT 2XV1N
 dis_up_arm_good = OR dis_up_arm_good_a dis_up_arm_good_b dis_up_arm_good_c
 dis_up_arm_bad = (dis_up_and_down_arm NOT dis_up_arm_good) INTERACT (all_up_and_down INTERACT 1XV1N == 1)
 // 
 dis_up_arm_err_stack = (dis_up_arm_bad AND dis_up_and_down_arm) INTERACT 1XV1N
 dis_up_arm_err = dis_up_arm INTERACT dis_up_arm_err_stack
 err2_met_up = (dis_up_arm_err INTERACT (1XV1N NOT OUTSIDE dis_up_arm_err)) NOT INTERACT (OR RV1 2XV1N)
 err1_met_down NOT INTERACT Vy1_BAR
}
 
Q: There should be at least two square Vy or one rectangular Vy in the intersection area of bottom metal and upper metal, when either wide metal Mxy or 1.25xMy width and length >= 0.542um, the space between either via and wide metal <= 3um (S, S is the shortest running path length from Via to the wide metal). (except via bar)
A: 
RVy1_R_6_M2 {
@ There should be at least two square Vy or one rectangular Vy in the intersection area of bottom metal and upper metal, when either wide metal Mxy or 1.25xMy width and length >= 0.542um, the space between either via and wide metal <= 3um (S, S is the shortest running path length from Via to the wide metal). (except via bar)
 // DRC flags each intersecting area ({bottom metal AND upper metal}) with single square Via within the branch check region
 wide_M1 = (WITH WIDTH M1 > 0.542-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 0.542-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 0.542-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M1_real = wide_M1 NOT OUTSIDE ((SIZE wide_M1 BY 3+GLOBAL_TOLERANCE) INTERACT V1)
 all_down_and_up = (M1 INTERACT wide_M1) AND M2
 dis_down_arm_wide_all = SIZE wide_M1_real BY 3+GLOBAL_TOLERANCE INSIDE OF M1 STEP 0.025
 dis_down_and_up = dis_down_arm_wide_all AND all_down_and_up
 dis_down_and_up_arm = (dis_down_and_up NOT wide_M1) AND M1
 dis_down_arm = (dis_down_arm_wide_all NOT wide_M1) AND M1
 // 
 dis_down_arm_good_a = dis_down_and_up_arm INTERACT 1XV1N >= 2
 dis_down_arm_good_b = dis_down_and_up_arm INTERACT RV1
 dis_down_arm_good_c = dis_down_and_up_arm INTERACT 2XV1N
 dis_down_arm_good = OR dis_down_arm_good_a dis_down_arm_good_b dis_down_arm_good_c
 dis_down_arm_bad = (dis_down_and_up_arm NOT dis_down_arm_good) INTERACT (all_down_and_up INTERACT 1XV1N == 1)
 // 
 dis_down_arm_err_stack = (dis_down_arm_bad AND dis_down_and_up_arm) INTERACT 1XV1N
 dis_down_arm_err = dis_down_arm INTERACT dis_down_arm_err_stack
 err1_met_down = (dis_down_arm_err INTERACT (1XV1N NOT OUTSIDE dis_down_arm_err)) NOT INTERACT (OR RV1 2XV1N)
 // 
 wide_M2 = (WITH WIDTH M2 > 0.542-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 0.542-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 0.542-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M2_real = wide_M2 NOT OUTSIDE ((SIZE wide_M2 BY 3+GLOBAL_TOLERANCE) INTERACT V1)
 all_up_and_down = (M2 INTERACT wide_M2) AND M1
 dis_up_arm_wide_all = SIZE wide_M2_real BY 3+GLOBAL_TOLERANCE INSIDE OF M2 STEP 0.025
 dis_up_and_down = dis_up_arm_wide_all AND all_up_and_down
 dis_up_and_down_arm = (dis_up_and_down NOT wide_M2) AND M2
 dis_up_arm = (dis_up_arm_wide_all NOT wide_M2) AND M2
 // 
 dis_up_arm_good_a = dis_up_and_down_arm INTERACT 1XV1N >= 2
 dis_up_arm_good_b = dis_up_and_down_arm INTERACT RV1
 dis_up_arm_good_c = dis_up_and_down_arm INTERACT 2XV1N
 dis_up_arm_good = OR dis_up_arm_good_a dis_up_arm_good_b dis_up_arm_good_c
 dis_up_arm_bad = (dis_up_and_down_arm NOT dis_up_arm_good) INTERACT (all_up_and_down INTERACT 1XV1N == 1)
 // 
 dis_up_arm_err_stack = (dis_up_arm_bad AND dis_up_and_down_arm) INTERACT 1XV1N
 dis_up_arm_err = dis_up_arm INTERACT dis_up_arm_err_stack
 err2_met_up = (dis_up_arm_err INTERACT (1XV1N NOT OUTSIDE dis_up_arm_err)) NOT INTERACT (OR RV1 2XV1N)
 err2_met_up NOT INTERACT Vy1_BAR
}
 
Q: There should be at least two square Vy or one rectangular Vy in the intersection area of bottom metal and upper metal, when either wide metal Mxy or 1.25xMy width and length >= 1.01um, the space between either via and wide metal <= 5um (S, S is the shortest running path length from Via to the wide metal). (except via bar)
A: 
RVy1_R_7_M1 {
@ There should be at least two square Vy or one rectangular Vy in the intersection area of bottom metal and upper metal, when either wide metal Mxy or 1.25xMy width and length >= 1.01um, the space between either via and wide metal <= 5um (S, S is the shortest running path length from Via to the wide metal). (except via bar)
 // DRC flags each intersecting area ({bottom metal AND upper metal}) with single square Via within the branch check region
 wide_M1 = (WITH WIDTH M1 > 1.01-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 1.01-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 1.01-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M1_real = wide_M1 NOT OUTSIDE ((SIZE wide_M1 BY 5+GLOBAL_TOLERANCE) INTERACT V1)
 all_down_and_up = (M1 INTERACT wide_M1) AND M2
 dis_down_arm_wide_all = SIZE wide_M1_real BY 5+GLOBAL_TOLERANCE INSIDE OF M1 STEP 0.025
 dis_down_and_up = dis_down_arm_wide_all AND all_down_and_up
 dis_down_and_up_arm = (dis_down_and_up NOT wide_M1) AND M1
 dis_down_arm = (dis_down_arm_wide_all NOT wide_M1) AND M1
 // 
 dis_down_arm_good_a = dis_down_and_up_arm INTERACT 1XV1N >= 2
 dis_down_arm_good_b = dis_down_and_up_arm INTERACT RV1
 dis_down_arm_good_c = dis_down_and_up_arm INTERACT 2XV1N
 dis_down_arm_good = OR dis_down_arm_good_a dis_down_arm_good_b dis_down_arm_good_c
 dis_down_arm_bad = (dis_down_and_up_arm NOT dis_down_arm_good) INTERACT (all_down_and_up INTERACT 1XV1N == 1)
 // 
 dis_down_arm_err_stack = (dis_down_arm_bad AND dis_down_and_up_arm) INTERACT 1XV1N
 dis_down_arm_err = dis_down_arm INTERACT dis_down_arm_err_stack
 err1_met_down = (dis_down_arm_err INTERACT (1XV1N NOT OUTSIDE dis_down_arm_err)) NOT INTERACT (OR RV1 2XV1N)
 // 
 wide_M2 = (WITH WIDTH M2 > 1.01-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 1.01-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 1.01-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M2_real = wide_M2 NOT OUTSIDE ((SIZE wide_M2 BY 5+GLOBAL_TOLERANCE) INTERACT V1)
 all_up_and_down = (M2 INTERACT wide_M2) AND M1
 dis_up_arm_wide_all = SIZE wide_M2_real BY 5+GLOBAL_TOLERANCE INSIDE OF M2 STEP 0.025
 dis_up_and_down = dis_up_arm_wide_all AND all_up_and_down
 dis_up_and_down_arm = (dis_up_and_down NOT wide_M2) AND M2
 dis_up_arm = (dis_up_arm_wide_all NOT wide_M2) AND M2
 // 
 dis_up_arm_good_a = dis_up_and_down_arm INTERACT 1XV1N >= 2
 dis_up_arm_good_b = dis_up_and_down_arm INTERACT RV1
 dis_up_arm_good_c = dis_up_and_down_arm INTERACT 2XV1N
 dis_up_arm_good = OR dis_up_arm_good_a dis_up_arm_good_b dis_up_arm_good_c
 dis_up_arm_bad = (dis_up_and_down_arm NOT dis_up_arm_good) INTERACT (all_up_and_down INTERACT 1XV1N == 1)
 // 
 dis_up_arm_err_stack = (dis_up_arm_bad AND dis_up_and_down_arm) INTERACT 1XV1N
 dis_up_arm_err = dis_up_arm INTERACT dis_up_arm_err_stack
 err2_met_up = (dis_up_arm_err INTERACT (1XV1N NOT OUTSIDE dis_up_arm_err)) NOT INTERACT (OR RV1 2XV1N)
 err1_met_down NOT INTERACT Vy1_BAR
}
 
Q: There should be at least two square Vy or one rectangular Vy in the intersection area of bottom metal and upper metal, when either wide metal Mxy or 1.25xMy width and length >= 1.01um, the space between either via and wide metal <= 5um (S, S is the shortest running path length from Via to the wide metal). (except via bar)
A: 
RVy1_R_7_M2 {
@ There should be at least two square Vy or one rectangular Vy in the intersection area of bottom metal and upper metal, when either wide metal Mxy or 1.25xMy width and length >= 1.01um, the space between either via and wide metal <= 5um (S, S is the shortest running path length from Via to the wide metal). (except via bar)
 // DRC flags each intersecting area ({bottom metal AND upper metal}) with single square Via within the branch check region
 wide_M1 = (WITH WIDTH M1 > 1.01-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 1.01-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 1.01-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M1_real = wide_M1 NOT OUTSIDE ((SIZE wide_M1 BY 5+GLOBAL_TOLERANCE) INTERACT V1)
 all_down_and_up = (M1 INTERACT wide_M1) AND M2
 dis_down_arm_wide_all = SIZE wide_M1_real BY 5+GLOBAL_TOLERANCE INSIDE OF M1 STEP 0.025
 dis_down_and_up = dis_down_arm_wide_all AND all_down_and_up
 dis_down_and_up_arm = (dis_down_and_up NOT wide_M1) AND M1
 dis_down_arm = (dis_down_arm_wide_all NOT wide_M1) AND M1
 // 
 dis_down_arm_good_a = dis_down_and_up_arm INTERACT 1XV1N >= 2
 dis_down_arm_good_b = dis_down_and_up_arm INTERACT RV1
 dis_down_arm_good_c = dis_down_and_up_arm INTERACT 2XV1N
 dis_down_arm_good = OR dis_down_arm_good_a dis_down_arm_good_b dis_down_arm_good_c
 dis_down_arm_bad = (dis_down_and_up_arm NOT dis_down_arm_good) INTERACT (all_down_and_up INTERACT 1XV1N == 1)
 // 
 dis_down_arm_err_stack = (dis_down_arm_bad AND dis_down_and_up_arm) INTERACT 1XV1N
 dis_down_arm_err = dis_down_arm INTERACT dis_down_arm_err_stack
 err1_met_down = (dis_down_arm_err INTERACT (1XV1N NOT OUTSIDE dis_down_arm_err)) NOT INTERACT (OR RV1 2XV1N)
 // 
 wide_M2 = (WITH WIDTH M2 > 1.01-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 1.01-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 1.01-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M2_real = wide_M2 NOT OUTSIDE ((SIZE wide_M2 BY 5+GLOBAL_TOLERANCE) INTERACT V1)
 all_up_and_down = (M2 INTERACT wide_M2) AND M1
 dis_up_arm_wide_all = SIZE wide_M2_real BY 5+GLOBAL_TOLERANCE INSIDE OF M2 STEP 0.025
 dis_up_and_down = dis_up_arm_wide_all AND all_up_and_down
 dis_up_and_down_arm = (dis_up_and_down NOT wide_M2) AND M2
 dis_up_arm = (dis_up_arm_wide_all NOT wide_M2) AND M2
 // 
 dis_up_arm_good_a = dis_up_and_down_arm INTERACT 1XV1N >= 2
 dis_up_arm_good_b = dis_up_and_down_arm INTERACT RV1
 dis_up_arm_good_c = dis_up_and_down_arm INTERACT 2XV1N
 dis_up_arm_good = OR dis_up_arm_good_a dis_up_arm_good_b dis_up_arm_good_c
 dis_up_arm_bad = (dis_up_and_down_arm NOT dis_up_arm_good) INTERACT (all_up_and_down INTERACT 1XV1N == 1)
 // 
 dis_up_arm_err_stack = (dis_up_arm_bad AND dis_up_and_down_arm) INTERACT 1XV1N
 dis_up_arm_err = dis_up_arm INTERACT dis_up_arm_err_stack
 err2_met_up = (dis_up_arm_err INTERACT (1XV1N NOT OUTSIDE dis_up_arm_err)) NOT INTERACT (OR RV1 2XV1N)
 err2_met_up NOT INTERACT Vy1_BAR
}


//RVy2

Q: Single RVy is not allowed in H-shape Mxy+1/1.25xMy, when:
    1) The Mxy+1/1.25xMy has H-shape interacting with two metal holes: both two metal holes length <= 4.5um and two metal hole area <= 4.05um2
    2) The RVy overlaps on the center metal bar of this H-shape Mxy+1/1.25xMy
    3) The center metal bar length <= 0.9um and the metal bar width <= 0.12um
A: 
RVy2_R_1 {
@ Single RVy is not allowed in H-shape Mxy+1/1.25xMy, when:
@ 1) The Mxy+1/1.25xMy has H-shape interacting with two metal holes: both two metal holes length <= 4.5um and two metal hole area <= 4.05um2
@ 2) The RVy overlaps on the center metal bar of this H-shape Mxy+1/1.25xMy
@ 3) The center metal bar length <= 0.9um and the metal bar width <= 0.12um
 // @ DRC doesn't check when one or more square 1xVn is also on H-shape Mxy+1/1.25xMy region
 hole_area_meet = AREA (HOLES M3 INNER) <= 4.05
 hole_area_meet_len = (hole_area_meet WITH EDGE (LENGTH hole_area_meet <= 0.9)) NOT WITH EDGE (LENGTH hole_area_meet > 4.5)
 hole_area_real = (hole_area_meet_len NOT ENCLOSE RECTANGLE 0.9+GLOBAL_TOLERANCE 4.5) NOT ENCLOSE RECTANGLE 0.9 4.5+GLOBAL_TOLERANCE
 hole_bars_len = M3 COIN EDGE hole_area_real
 // 
 hole_bars = INT hole_bars_len <= 0.12 ABUT<90 OPPOSITE REGION EXCLUDE SHIELDED
 hole_bars_real = hole_bars WITH EDGE (LENGTH hole_bars_len <= 0.9)
 hole_bars_vias_rect = RV2 INTERACT ((hole_bars_real INTERACT hole_area_real == 2) NOT ENCLOSE V2N >= 2)
 err1 = hole_bars_real INTERACT hole_bars_vias_rect == 1
 err1 NOT INSIDE SealR_NOT_BULK
}
 
Q: Redundant via requirement must be obeyed by one of following conditions of Vy numbers and space for Mxy and 1.25xMy connection
    (One of Mxy or 1.25xMy has width and length >= 0.162um) (Except VIA bar)
    1) At least one rectangular Vy
    2) At least two square Vy with space <= 0.091um
    3) At least four square Vy with space <= 0.415um
A: 
RVy2_R_2 {
@ Redundant via requirement must be obeyed by one of following conditions of Vy numbers and space for Mxy and 1.25xMy connection
@ (One of Mxy or 1.25xMy has width and length >= 0.162um) (Except VIA bar)
@ 1) At least one rectangular Vy
@ 2) At least two square Vy with space <= 0.091um
@ 3) At least four square Vy with space <= 0.415um
 X1a = WITH WIDTH M2 > 0.162-GLOBAL_TOLERANCE <= 0.272-GLOBAL_TOLERANCE
 X1b = WITH WIDTH M3 > 0.162-GLOBAL_TOLERANCE <= 0.272-GLOBAL_TOLERANCE
 Y1a = WITH WIDTH M2 > 0.272-GLOBAL_TOLERANCE
 Y1b = WITH WIDTH M3 > 0.272-GLOBAL_TOLERANCE
 WIDE_1 = (X1a AND M3) ENCLOSE V2
 WIDE_2 = (M2 AND X1b) ENCLOSE V2
 WIDE_3 = (Y1a AND M3) ENCLOSE V2
 WIDE_4 = (M2 AND Y1b) ENCLOSE V2
 WIDE_all_raw = (WIDE_1 OR WIDE_2) NOT (WIDE_3 OR WIDE_4)
 WIDE_all = (M2 AND M3) NOT OUTSIDE WIDE_all_raw
 // 
 // condition 1 & 2
 Y1_good = WIDE_all_raw AND RV2
 Y2_good = WIDE_all_raw AND 2XV2N
 // 
 // condition 3
 Y3_wide_all = WIDE_all_raw NOT INTERACT (OR Y1_good Y2_good)
 Y3_wide = (WIDE_all INTERACT Y3_wide_all) INTERACT V2_SR >= 2
 Y3_comb_step = SIZE V2_SR BY 0.091/2 INSIDE OF Y3_wide STEP 0.020
 Y3_good_step = OR (Y3_comb_step INTERACT V2N >= 2) (Y3_comb_step INTERACT (OR RV2 2XV2N))
 Y3_good = WIDE_all_raw AND Y3_good_step
 // 
 // condition 4: 32nm*32nm via can be replaced by 2XVia/RVia
 Y4_wide_all = WIDE_all_raw NOT INTERACT (OR Y1_good Y2_good Y3_good)
 Y4_wide = (WIDE_all INTERACT Y4_wide_all) INTERACT V2_SR >= 2 // rectangle array 0.415/2 =0.207
 Y4_vias_input = V2_SR AND Y4_wide
 Y4_wide_chk_1 = Y4_wide INTERACT Y4_wide_all
 Y4_comb_step1 = SIZE Y4_vias_input BY 0.050 INSIDE OF Y4_wide_chk_1 STEP 0.020
 Y4_good_step1_a = OR (Y4_comb_step1 INTERACT V2N >= 4) ((Y4_comb_step1 INTERACT V2N >= 2) INTERACT (OR RV2 2XV2N)) // step1: 0.050
 Y4_good_step1_b = OR (Y4_comb_step1 INTERACT 2XV2N >= 2) (Y4_comb_step1 INTERACT RV2 >= 2)
 Y4_good_step1 = OR Y4_good_step1_a Y4_good_step1_b
 // 
 Y4_wide_chk_2 = Y4_wide_chk_1 INTERACT (WIDE_all_raw NOT INTERACT Y4_good_step1)
 Y4_comb_step2 = SIZE Y4_comb_step1 BY 0.035 INSIDE OF Y4_wide_chk_2 STEP 0.020
 Y4_good_step2_a = OR (Y4_comb_step2 INTERACT V2N >= 4) ((Y4_comb_step2 INTERACT V2N >= 2) INTERACT (OR RV2 2XV2N)) // step2: 0.035
 Y4_good_step2_b = OR (Y4_comb_step2 INTERACT 2XV2N >= 2) (Y4_comb_step2 INTERACT RV2 >= 2)
 Y4_good_step2 = OR Y4_good_step2_a Y4_good_step2_b
 // 
 Y4_wide_chk_3 = Y4_wide_chk_2 INTERACT (WIDE_all_raw NOT INTERACT Y4_good_step2)
 Y4_comb_step3 = SIZE Y4_comb_step2 BY 0.035 INSIDE OF Y4_wide_chk_3 STEP 0.020
 Y4_good_step3_a = OR (Y4_comb_step3 INTERACT V2N >= 4) ((Y4_comb_step3 INTERACT V2N >= 2) INTERACT (OR RV2 2XV2N)) // step3: 0.035
 Y4_good_step3_b = OR (Y4_comb_step3 INTERACT 2XV2N >= 2) (Y4_comb_step3 INTERACT RV2 >= 2)
 Y4_good_step3 = OR Y4_good_step3_a Y4_good_step3_b
 // 
 Y4_wide_chk_4 = Y4_wide_chk_3 INTERACT (WIDE_all_raw NOT INTERACT Y4_good_step3)
 Y4_comb_step4 = SIZE Y4_comb_step3 BY 0.035 INSIDE OF Y4_wide_chk_4 STEP 0.020
 Y4_good_step4_a = OR (Y4_comb_step4 INTERACT V2N >= 4) ((Y4_comb_step4 INTERACT V2N >= 2) INTERACT (OR RV2 2XV2N)) // step4: 0.035
 Y4_good_step4_b = OR (Y4_comb_step4 INTERACT 2XV2N >= 2) (Y4_comb_step4 INTERACT RV2 >= 2)
 Y4_good_step4 = OR Y4_good_step4_a Y4_good_step4_b
 // 
 Y4_wide_chk_5 = Y4_wide_chk_4 INTERACT (WIDE_all_raw NOT INTERACT Y4_good_step4)
 Y4_comb_step5 = SIZE Y4_comb_step4 BY 0.035 INSIDE OF Y4_wide_chk_5 STEP 0.020
 Y4_good_step5_a = OR (Y4_comb_step5 INTERACT V2N >= 4) ((Y4_comb_step5 INTERACT V2N >= 2) INTERACT (OR RV2 2XV2N)) // step5: 0.035
 Y4_good_step5_b = OR (Y4_comb_step5 INTERACT 2XV2N >= 2) (Y4_comb_step5 INTERACT RV2 >= 2)
 Y4_good_step5 = OR Y4_good_step5_a Y4_good_step5_b
 // 
 Y4_wide_chk_6 = Y4_wide_chk_5 INTERACT (WIDE_all_raw NOT INTERACT Y4_good_step5)
 Y4_comb_step6 = SIZE Y4_comb_step5 BY 0.018 INSIDE OF Y4_wide_chk_6 STEP 0.015
 Y4_good_step6_a = OR (Y4_comb_step6 INTERACT V2N >= 4) ((Y4_comb_step6 INTERACT V2N >= 2) INTERACT (OR RV2 2XV2N)) // step6: 0.207-0.05-0.035*4=0.018
 Y4_good_step6_b = OR (Y4_comb_step6 INTERACT 2XV2N >= 2) (Y4_comb_step6 INTERACT RV2 >= 2)
 Y4_good_step6 = OR Y4_good_step6_a Y4_good_step6_b
 Y4_good = WIDE_all_raw AND (OR Y4_good_step1 Y4_good_step2 Y4_good_step3 Y4_good_step4 Y4_good_step5 Y4_good_step6)
 // 
 err1 = (WIDE_all_raw OUTSIDE (OR Y1_good Y2_good Y3_good Y4_good)) INTERACT V2
 err1 NOT INTERACT Vy2_BAR
}
 
Q: Redundant via requirement must be obeyed by one of following conditions of Vy numbers and space for Mxy and 1.25xMy connection
    (One of Mxy or 1.25xMy has width and length >= 0.272um, two square vias are equal to one rectangular via for below conditions) (Except VIA bar, MARKS and OCCD region)
    1) At least four square Vy with space <= 0.091um
    2) At least nine square Vy with space <= 0.545um
    3) At least two rectangular Vy with space <= 0.202um
    4) At least five rectangular Vy with space <= 0.545um
A: 
RVy2_R_3 {
@ Redundant via requirement must be obeyed by one of following conditions of Vy numbers and space for Mxy and 1.25xMy connection
@ (One of Mxy or 1.25xMy has width and length >= 0.272um, two square vias are equal to one rectangular via for below conditions) (Except VIA bar, MARKS and OCCD region)
@ 1) At least four square Vy with space <= 0.091um
@ 2) At least nine square Vy with space <= 0.545um
@ 3) At least two rectangular Vy with space <= 0.202um
@ 4) At least five rectangular Vy with space <= 0.545um
 X1a = WITH WIDTH M2 > 0.272-GLOBAL_TOLERANCE
 X1b = WITH WIDTH M3 > 0.272-GLOBAL_TOLERANCE
 WIDE_1 = (X1a AND M3) ENCLOSE V2
 WIDE_2 = (M2 AND X1b) ENCLOSE V2
 WIDE_all_raw = WIDE_1 OR WIDE_2
 WIDE_all = (M2 AND M3) NOT OUTSIDE WIDE_all_raw
 // 
 // condition 3: not replaced by RVia
 Y3_wide = WIDE_all INTERACT V2N >= 4 // rectangle array 0.091/2=0.045
 Y3_vias_input = V2N AND Y3_wide
 Y3_comb_step = SIZE Y3_vias_input BY 0.091/2 INSIDE OF Y3_wide STEP 0.02 // via minimum space = 0.083
 Y3_good_step = Y3_comb_step INTERACT V2N >= 4
 Y3_good = WIDE_all_raw AND Y3_good_step
 // 
 // condition 1 & 2 & 4 & 5: 32nm*32nm via can be replaced by 2XVia/RVia
 Y1_wide_all = WIDE_all_raw NOT INTERACT Y3_good
 Y1_wide = (WIDE_all INTERACT Y1_wide_all) INTERACT V2_SR >= 2 // rectangle array 0.545/2=0.272
 Y1_vias_input = V2_SR AND Y1_wide
 Y1_wide_chk_1 = Y1_wide INTERACT Y1_wide_all
 Y1_comb_step1 = SIZE Y1_vias_input BY 0.061 INSIDE OF Y1_wide_chk_1 STEP 0.02 // step1: 0.061, via minimum space = 0.202/2=0.101
 Y1_good_step1_a = Y1_comb_step1 INTERACT V2N >= 9
 Y1_good_step1_b = Y1_comb_step1 INTERACT RV2 >= 5
 Y1_good_step1_c = Y1_comb_step1 INTERACT 2XV2N >= 3
 Y1_good_step1_d = (Y1_comb_step1 INTERACT 1XV2N >= 7) INTERACT RV2 >= 1
 Y1_good_step1_e = (Y1_comb_step1 INTERACT 1XV2N >= 6) INTERACT 2XV2N >= 1
 Y1_good_step1_f = (Y1_comb_step1 INTERACT 1XV2N >= 5) INTERACT RV2 >= 2
 Y1_good_step1_g = ((Y1_comb_step1 INTERACT 1XV2N >= 4) INTERACT 2XV2N >= 1) INTERACT RV2 >= 1
 Y1_good_step1_h = (Y1_comb_step1 INTERACT 1XV2N >= 3) INTERACT RV2 >= 3
 Y1_good_step1_i = (Y1_comb_step1 INTERACT 1XV2N >= 3) INTERACT 2XV2N >= 2
 Y1_good_step1_j = ((Y1_comb_step1 INTERACT 1XV2N >= 2) INTERACT 2XV2N >= 1) INTERACT RV2 >= 2
 // SETLAYER Y1_good_step1_k = (Y1_comb_step1 INTERACT 1XV2N >= 1) INTERACT RV2 >= 4
 Y1_good_step1_l = ((Y1_comb_step1 INTERACT 1XV2N >= 1) INTERACT 2XV2N >= 2) INTERACT RV2 >= 1
 Y1_good_step1_m = Y1_comb_step1 INTERACT RV2 >= 2 // remove good condition3_val: 0.202
 Y1_good_step1_n = Y1_comb_step1 INTERACT 2XV2N >= 2
 Y1_good_step1_o = (Y1_comb_step1 INTERACT 1XV2N >= 2) INTERACT RV2 >= 1
 Y1_good_step1_p = (Y1_comb_step1 INTERACT 1XV2N >= 1) INTERACT 2XV2N >= 1
 Y1_good_step1_q = (Y1_comb_step1 INTERACT 2XV2N >= 1) INTERACT RV2 >= 1
 Y1_good_step1_r = OR Y1_good_step1_a Y1_good_step1_b Y1_good_step1_c Y1_good_step1_d Y1_good_step1_e Y1_good_step1_f Y1_good_step1_g Y1_good_step1_h
 Y1_good_step1_s = OR Y1_good_step1_i Y1_good_step1_j Y1_good_step1_l Y1_good_step1_m Y1_good_step1_n Y1_good_step1_o Y1_good_step1_p Y1_good_step1_q
 Y1_good_step1 = OR Y1_good_step1_r Y1_good_step1_s
 // 
 Y1_wide_chk_2 = Y1_wide_chk_1 INTERACT (WIDE_all_raw NOT INTERACT Y1_good_step1)
 Y1_comb_step2 = SIZE Y1_comb_step1 BY 0.040 INSIDE OF Y1_wide_chk_2 STEP 0.02 // step2: 0.040
 Y1_good_step2_a = Y1_comb_step2 INTERACT V2N >= 9
 Y1_good_step2_b = Y1_comb_step2 INTERACT RV2 >= 5
 Y1_good_step2_c = Y1_comb_step2 INTERACT 2XV2N >= 3
 Y1_good_step2_d = (Y1_comb_step2 INTERACT 1XV2N >= 7) INTERACT RV2 >= 1
 Y1_good_step2_e = (Y1_comb_step2 INTERACT 1XV2N >= 6) INTERACT 2XV2N >= 1
 Y1_good_step2_f = (Y1_comb_step2 INTERACT 1XV2N >= 5) INTERACT RV2 >= 2
 Y1_good_step2_g = ((Y1_comb_step2 INTERACT 1XV2N >= 4) INTERACT 2XV2N >= 1) INTERACT RV2 >= 1
 Y1_good_step2_h = (Y1_comb_step2 INTERACT 1XV2N >= 3) INTERACT RV2 >= 3
 Y1_good_step2_i = (Y1_comb_step2 INTERACT 1XV2N >= 3) INTERACT 2XV2N >= 2
 Y1_good_step2_j = ((Y1_comb_step2 INTERACT 1XV2N >= 2) INTERACT 2XV2N >= 1) INTERACT RV2 >= 2
 // SETLAYER Y1_good_step2_k = (Y1_comb_step2 INTERACT 1XV2N >= 1) INTERACT RV2 >= 4
 Y1_good_step2_l = ((Y1_comb_step2 INTERACT 1XV2N >= 1) INTERACT 2XV2N >= 2) INTERACT RV2 >= 1
 Y1_good_step2_m = Y1_comb_step2 INTERACT RV2 >= 2
 Y1_good_step2_n = Y1_comb_step2 INTERACT 2XV2N >= 2
 Y1_good_step2_o = (Y1_comb_step2 INTERACT 1XV2N >= 2) INTERACT RV2 >= 1
 Y1_good_step2_p = (Y1_comb_step2 INTERACT 1XV2N >= 1) INTERACT 2XV2N >= 1
 Y1_good_step2_q = (Y1_comb_step2 INTERACT 2XV2N >= 1) INTERACT RV2 >= 1
 Y1_good_step2_r = OR Y1_good_step2_a Y1_good_step2_b Y1_good_step2_c Y1_good_step2_d Y1_good_step2_e Y1_good_step2_f Y1_good_step2_g Y1_good_step2_h
 Y1_good_step2_s = OR Y1_good_step2_i Y1_good_step2_j Y1_good_step2_l Y1_good_step2_m Y1_good_step2_n Y1_good_step2_o Y1_good_step2_p Y1_good_step2_q
 Y1_good_step2 = OR Y1_good_step2_r Y1_good_step2_s
 // 
 // condition 1 & 2 & 4 & 5: 32nm*32nm via can be replaced by 2XVia/RVia
 Y1_wide_chk_3 = Y1_wide_chk_2 INTERACT (WIDE_all_raw NOT INTERACT Y1_good_step2)
 Y1_comb_step3 = SIZE Y1_comb_step2 BY 0.04 INSIDE OF Y1_wide_chk_3 STEP 0.02 // step3: 0.040
 Y1_good_step3_a = Y1_comb_step3 INTERACT V2N >= 9
 Y1_good_step3_b = Y1_comb_step3 INTERACT RV2 >= 5
 Y1_good_step3_c = Y1_comb_step3 INTERACT 2XV2N >= 3
 Y1_good_step3_d = (Y1_comb_step3 INTERACT 1XV2N >= 7) INTERACT RV2 >= 1
 Y1_good_step3_e = (Y1_comb_step3 INTERACT 1XV2N >= 6) INTERACT 2XV2N >= 1
 Y1_good_step3_f = (Y1_comb_step3 INTERACT 1XV2N >= 5) INTERACT RV2 >= 2
 Y1_good_step3_g = ((Y1_comb_step3 INTERACT 1XV2N >= 4) INTERACT 2XV2N >= 1) INTERACT RV2 >= 1
 Y1_good_step3_h = (Y1_comb_step3 INTERACT 1XV2N >= 3) INTERACT RV2 >= 3
 Y1_good_step3_i = (Y1_comb_step3 INTERACT 1XV2N >= 3) INTERACT 2XV2N >= 2
 Y1_good_step3_j = ((Y1_comb_step3 INTERACT 1XV2N >= 2) INTERACT 2XV2N >= 1) INTERACT RV2 >= 2
 // SETLAYER Y1_good_step3_k = (Y1_comb_step3 INTERACT 1XV2N >= 1) INTERACT RV2 >= 4
 Y1_good_step3_l = ((Y1_comb_step3 INTERACT 1XV2N >= 1) INTERACT 2XV2N >= 2) INTERACT RV2 >= 1
 Y1_good_step3_r = OR Y1_good_step3_a Y1_good_step3_b Y1_good_step3_c Y1_good_step3_d Y1_good_step3_e Y1_good_step3_f Y1_good_step3_g Y1_good_step3_h
 Y1_good_step3_s = OR Y1_good_step3_i Y1_good_step3_j Y1_good_step3_l
 Y1_good_step3 = OR Y1_good_step3_r Y1_good_step3_s
 // 
 Y1_wide_chk_4 = Y1_wide_chk_3 INTERACT (WIDE_all_raw NOT INTERACT Y1_good_step3)
 Y1_comb_step4 = SIZE Y1_comb_step3 BY 0.040 INSIDE OF Y1_wide_chk_4 STEP 0.02 // step4: 0.040
 Y1_good_step4_a = Y1_comb_step4 INTERACT V2N >= 9
 Y1_good_step4_b = Y1_comb_step4 INTERACT RV2 >= 5
 Y1_good_step4_c = Y1_comb_step4 INTERACT 2XV2N >= 3
 Y1_good_step4_d = (Y1_comb_step4 INTERACT 1XV2N >= 7) INTERACT RV2 >= 1
 Y1_good_step4_e = (Y1_comb_step4 INTERACT 1XV2N >= 6) INTERACT 2XV2N >= 1
 Y1_good_step4_f = (Y1_comb_step4 INTERACT 1XV2N >= 5) INTERACT RV2 >= 2
 Y1_good_step4_g = ((Y1_comb_step4 INTERACT 1XV2N >= 4) INTERACT 2XV2N >= 1) INTERACT RV2 >= 1
 Y1_good_step4_h = (Y1_comb_step4 INTERACT 1XV2N >= 3) INTERACT RV2 >= 3
 Y1_good_step4_i = (Y1_comb_step4 INTERACT 1XV2N >= 3) INTERACT 2XV2N >= 2
 Y1_good_step4_j = ((Y1_comb_step4 INTERACT 1XV2N >= 2) INTERACT 2XV2N >= 1) INTERACT RV2 >= 2
 // SETLAYER Y1_good_step4_k = (Y1_comb_step4 INTERACT 1XV2N >= 1) INTERACT RV2 >= 4
 Y1_good_step4_l = ((Y1_comb_step4 INTERACT 1XV2N >= 1) INTERACT 2XV2N >= 2) INTERACT RV2 >= 1
 Y1_good_step4_r = OR Y1_good_step4_a Y1_good_step4_b Y1_good_step4_c Y1_good_step4_d Y1_good_step4_e Y1_good_step4_f Y1_good_step4_g Y1_good_step4_h
 Y1_good_step4_s = OR Y1_good_step4_i Y1_good_step4_j Y1_good_step4_l
 Y1_good_step4 = OR Y1_good_step4_r Y1_good_step4_s
 // 
 Y1_wide_chk_5 = Y1_wide_chk_4 INTERACT (WIDE_all_raw NOT INTERACT Y1_good_step4)
 Y1_comb_step5 = SIZE Y1_comb_step4 BY 0.040 INSIDE OF Y1_wide_chk_5 STEP 0.02 // step5: 0.040
 Y1_good_step5_a = Y1_comb_step5 INTERACT V2N >= 9
 Y1_good_step5_b = Y1_comb_step5 INTERACT RV2 >= 5
 Y1_good_step5_c = Y1_comb_step5 INTERACT 2XV2N >= 3
 Y1_good_step5_d = (Y1_comb_step5 INTERACT 1XV2N >= 7) INTERACT RV2 >= 1
 Y1_good_step5_e = (Y1_comb_step5 INTERACT 1XV2N >= 6) INTERACT 2XV2N >= 1
 Y1_good_step5_f = (Y1_comb_step5 INTERACT 1XV2N >= 5) INTERACT RV2 >= 2
 Y1_good_step5_g = ((Y1_comb_step5 INTERACT 1XV2N >= 4) INTERACT 2XV2N >= 1) INTERACT RV2 >= 1
 Y1_good_step5_h = (Y1_comb_step5 INTERACT 1XV2N >= 3) INTERACT RV2 >= 3
 Y1_good_step5_i = (Y1_comb_step5 INTERACT 1XV2N >= 3) INTERACT 2XV2N >= 2
 Y1_good_step5_j = ((Y1_comb_step5 INTERACT 1XV2N >= 2) INTERACT 2XV2N >= 1) INTERACT RV2 >= 2
 // SETLAYER Y1_good_step5_k = (Y1_comb_step5 INTERACT 1XV2N >= 1) INTERACT RV2 >= 4
 Y1_good_step5_l = ((Y1_comb_step5 INTERACT 1XV2N >= 1) INTERACT 2XV2N >= 2) INTERACT RV2 >= 1
 Y1_good_step5_r = OR Y1_good_step5_a Y1_good_step5_b Y1_good_step5_c Y1_good_step5_d Y1_good_step5_e Y1_good_step5_f Y1_good_step5_g Y1_good_step5_h
 Y1_good_step5_s = OR Y1_good_step5_i Y1_good_step5_j Y1_good_step5_l
 Y1_good_step5 = OR Y1_good_step5_r Y1_good_step5_s
 // 
 Y1_wide_chk_6 = Y1_wide_chk_5 INTERACT (WIDE_all_raw NOT INTERACT Y1_good_step5)
 Y1_comb_step6 = SIZE Y1_comb_step5 BY 0.040 INSIDE OF Y1_wide_chk_6 STEP 0.02 // step6: 0.040
 Y1_good_step6_a = Y1_comb_step6 INTERACT V2N >= 9
 Y1_good_step6_b = Y1_comb_step6 INTERACT RV2 >= 5
 Y1_good_step6_c = Y1_comb_step6 INTERACT 2XV2N >= 3
 Y1_good_step6_d = (Y1_comb_step6 INTERACT 1XV2N >= 7) INTERACT RV2 >= 1
 Y1_good_step6_e = (Y1_comb_step6 INTERACT 1XV2N >= 6) INTERACT 2XV2N >= 1
 Y1_good_step6_f = (Y1_comb_step6 INTERACT 1XV2N >= 5) INTERACT RV2 >= 2
 Y1_good_step6_g = ((Y1_comb_step6 INTERACT 1XV2N >= 4) INTERACT 2XV2N >= 1) INTERACT RV2 >= 1
 Y1_good_step6_h = (Y1_comb_step6 INTERACT 1XV2N >= 3) INTERACT RV2 >= 3
 Y1_good_step6_i = (Y1_comb_step6 INTERACT 1XV2N >= 3) INTERACT 2XV2N >= 2
 Y1_good_step6_j = ((Y1_comb_step6 INTERACT 1XV2N >= 2) INTERACT 2XV2N >= 1) INTERACT RV2 >= 2
 // SETLAYER Y1_good_step6_k = (Y1_comb_step6 INTERACT 1XV2N >= 1) INTERACT RV2 >= 4
 Y1_good_step6_l = ((Y1_comb_step6 INTERACT 1XV2N >= 1) INTERACT 2XV2N >= 2) INTERACT RV2 >= 1
 Y1_good_step6_r = OR Y1_good_step6_a Y1_good_step6_b Y1_good_step6_c Y1_good_step6_d Y1_good_step6_e Y1_good_step6_f Y1_good_step6_g Y1_good_step6_h
 Y1_good_step6_s = OR Y1_good_step6_i Y1_good_step6_j Y1_good_step6_l
 Y1_good_step6 = OR Y1_good_step6_r Y1_good_step6_s
 // 
 Y1_wide_chk_7 = Y1_wide_chk_6 INTERACT (WIDE_all_raw NOT INTERACT Y1_good_step6)
 Y1_comb_step7 = SIZE Y1_comb_step6 BY 0.011 INSIDE OF Y1_wide_chk_7 STEP 0.02 // step7: 0.272-0.061-0.04-0.040*4=0.011
 Y1_good_step7_a = Y1_comb_step7 INTERACT V2N >= 9
 Y1_good_step7_b = Y1_comb_step7 INTERACT RV2 >= 5
 Y1_good_step7_c = Y1_comb_step7 INTERACT 2XV2N >= 3
 Y1_good_step7_d = (Y1_comb_step7 INTERACT 1XV2N >= 7) INTERACT RV2 >= 1
 Y1_good_step7_e = (Y1_comb_step7 INTERACT 1XV2N >= 6) INTERACT 2XV2N >= 1
 Y1_good_step7_f = (Y1_comb_step7 INTERACT 1XV2N >= 5) INTERACT RV2 >= 2
 Y1_good_step7_g = ((Y1_comb_step7 INTERACT 1XV2N >= 4) INTERACT 2XV2N >= 1) INTERACT RV2 >= 1
 Y1_good_step7_h = (Y1_comb_step7 INTERACT 1XV2N >= 3) INTERACT RV2 >= 3
 Y1_good_step7_i = (Y1_comb_step7 INTERACT 1XV2N >= 3) INTERACT 2XV2N >= 2
 Y1_good_step7_j = ((Y1_comb_step7 INTERACT 1XV2N >= 2) INTERACT 2XV2N >= 1) INTERACT RV2 >= 2
 // SETLAYER Y1_good_step7_k = (Y1_comb_step7 INTERACT 1XV2N >= 1) INTERACT RV2 >= 4
 Y1_good_step7_l = ((Y1_comb_step7 INTERACT 1XV2N >= 1) INTERACT 2XV2N >= 2) INTERACT RV2 >= 1
 Y1_good_step7_r = OR Y1_good_step7_a Y1_good_step7_b Y1_good_step7_c Y1_good_step7_d Y1_good_step7_e Y1_good_step7_f Y1_good_step7_g Y1_good_step7_h
 Y1_good_step7_s = OR Y1_good_step7_i Y1_good_step7_j Y1_good_step7_l
 Y1_good_step7 = OR Y1_good_step7_r Y1_good_step7_s
 Y1_Y2_Y4_good = WIDE_all_raw AND (OR Y1_good_step1 Y1_good_step2 Y1_good_step3 Y1_good_step4 Y1_good_step5 Y1_good_step6 Y1_good_step7)
 // 
 err1 = (WIDE_all_raw OUTSIDE (OR Y1_Y2_Y4_good Y3_good)) INTERACT V2
 (err1 NOT INTERACT Vy2_BAR) NOT INSIDE OCCD_MARKS
}
 
Q: There should be at least two square Vy or one rectangular Vy in the intersection area of bottom metal and upper metal, when either wide metal Mxy or 1.25xMy length >= 0.162um and width >= 0.162um, the space between either via and wide metal <= 0.5um (S, S is the shortest running path length from Via to the wide metal). (except via bar)
A: 
RVy2_R_4_M2 {
@ There should be at least two square Vy or one rectangular Vy in the intersection area of bottom metal and upper metal, when either wide metal Mxy or 1.25xMy length >= 0.162um and width >= 0.162um, the space between either via and wide metal <= 0.5um (S, S is the shortest running path length from Via to the wide metal). (except via bar)
 // DRC flags each intersecting area ({bottom metal AND upper metal}) with single square Via within the branch check region
 wide_M2 = (WITH WIDTH M2 > 0.162-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 0.162-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 0.162-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M2_real = wide_M2 NOT OUTSIDE ((SIZE wide_M2 BY 0.5+GLOBAL_TOLERANCE) INTERACT V2)
 all_down_and_up = (M2 INTERACT wide_M2) AND M3
 dis_down_arm_wide_all = SIZE wide_M2_real BY 0.5+GLOBAL_TOLERANCE INSIDE OF M2 STEP 0.025
 dis_down_and_up = dis_down_arm_wide_all AND all_down_and_up
 dis_down_and_up_arm = (dis_down_and_up NOT wide_M2) AND M2
 dis_down_arm = (dis_down_arm_wide_all NOT wide_M2) AND M2
 // 
 dis_down_arm_good_a = dis_down_and_up_arm INTERACT 1XV2N >= 2
 dis_down_arm_good_b = dis_down_and_up_arm INTERACT RV2
 dis_down_arm_good_c = dis_down_and_up_arm INTERACT 2XV2N
 dis_down_arm_good = OR dis_down_arm_good_a dis_down_arm_good_b dis_down_arm_good_c
 dis_down_arm_bad = (dis_down_and_up_arm NOT dis_down_arm_good) INTERACT (all_down_and_up INTERACT 1XV2N == 1)
 // 
 dis_down_arm_err_stack = (dis_down_arm_bad AND dis_down_and_up_arm) INTERACT 1XV2N
 dis_down_arm_err = dis_down_arm INTERACT dis_down_arm_err_stack
 err1_met_down = (dis_down_arm_err INTERACT (1XV2N NOT OUTSIDE dis_down_arm_err)) NOT INTERACT (OR RV2 2XV2N)
 // 
 wide_M3 = (WITH WIDTH M3 > 0.162-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 0.162-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 0.162-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M3_real = wide_M3 NOT OUTSIDE ((SIZE wide_M3 BY 0.5+GLOBAL_TOLERANCE) INTERACT V2)
 all_up_and_down = (M3 INTERACT wide_M3) AND M2
 dis_up_arm_wide_all = SIZE wide_M3_real BY 0.5+GLOBAL_TOLERANCE INSIDE OF M3 STEP 0.025
 dis_up_and_down = dis_up_arm_wide_all AND all_up_and_down
 dis_up_and_down_arm = (dis_up_and_down NOT wide_M3) AND M3
 dis_up_arm = (dis_up_arm_wide_all NOT wide_M3) AND M3
 // 
 dis_up_arm_good_a = dis_up_and_down_arm INTERACT 1XV2N >= 2
 dis_up_arm_good_b = dis_up_and_down_arm INTERACT RV2
 dis_up_arm_good_c = dis_up_and_down_arm INTERACT 2XV2N
 dis_up_arm_good = OR dis_up_arm_good_a dis_up_arm_good_b dis_up_arm_good_c
 dis_up_arm_bad = (dis_up_and_down_arm NOT dis_up_arm_good) INTERACT (all_up_and_down INTERACT 1XV2N == 1)
 // 
 dis_up_arm_err_stack = (dis_up_arm_bad AND dis_up_and_down_arm) INTERACT 1XV2N
 dis_up_arm_err = dis_up_arm INTERACT dis_up_arm_err_stack
 err2_met_up = (dis_up_arm_err INTERACT (1XV2N NOT OUTSIDE dis_up_arm_err)) NOT INTERACT (OR RV2 2XV2N)
 err1_met_down NOT INTERACT Vy2_BAR
}
 
Q: There should be at least two square Vy or one rectangular Vy in the intersection area of bottom metal and upper metal, when either wide metal Mxy or 1.25xMy length >= 0.162um and width >= 0.162um, the space between either via and wide metal <= 0.5um (S, S is the shortest running path length from Via to the wide metal). (except via bar)
A: 
RVy2_R_4_M3 {
@ There should be at least two square Vy or one rectangular Vy in the intersection area of bottom metal and upper metal, when either wide metal Mxy or 1.25xMy length >= 0.162um and width >= 0.162um, the space between either via and wide metal <= 0.5um (S, S is the shortest running path length from Via to the wide metal). (except via bar)
 // DRC flags each intersecting area ({bottom metal AND upper metal}) with single square Via within the branch check region
 wide_M2 = (WITH WIDTH M2 > 0.162-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 0.162-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 0.162-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M2_real = wide_M2 NOT OUTSIDE ((SIZE wide_M2 BY 0.5+GLOBAL_TOLERANCE) INTERACT V2)
 all_down_and_up = (M2 INTERACT wide_M2) AND M3
 dis_down_arm_wide_all = SIZE wide_M2_real BY 0.5+GLOBAL_TOLERANCE INSIDE OF M2 STEP 0.025
 dis_down_and_up = dis_down_arm_wide_all AND all_down_and_up
 dis_down_and_up_arm = (dis_down_and_up NOT wide_M2) AND M2
 dis_down_arm = (dis_down_arm_wide_all NOT wide_M2) AND M2
 // 
 dis_down_arm_good_a = dis_down_and_up_arm INTERACT 1XV2N >= 2
 dis_down_arm_good_b = dis_down_and_up_arm INTERACT RV2
 dis_down_arm_good_c = dis_down_and_up_arm INTERACT 2XV2N
 dis_down_arm_good = OR dis_down_arm_good_a dis_down_arm_good_b dis_down_arm_good_c
 dis_down_arm_bad = (dis_down_and_up_arm NOT dis_down_arm_good) INTERACT (all_down_and_up INTERACT 1XV2N == 1)
 // 
 dis_down_arm_err_stack = (dis_down_arm_bad AND dis_down_and_up_arm) INTERACT 1XV2N
 dis_down_arm_err = dis_down_arm INTERACT dis_down_arm_err_stack
 err1_met_down = (dis_down_arm_err INTERACT (1XV2N NOT OUTSIDE dis_down_arm_err)) NOT INTERACT (OR RV2 2XV2N)
 // 
 wide_M3 = (WITH WIDTH M3 > 0.162-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 0.162-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 0.162-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M3_real = wide_M3 NOT OUTSIDE ((SIZE wide_M3 BY 0.5+GLOBAL_TOLERANCE) INTERACT V2)
 all_up_and_down = (M3 INTERACT wide_M3) AND M2
 dis_up_arm_wide_all = SIZE wide_M3_real BY 0.5+GLOBAL_TOLERANCE INSIDE OF M3 STEP 0.025
 dis_up_and_down = dis_up_arm_wide_all AND all_up_and_down
 dis_up_and_down_arm = (dis_up_and_down NOT wide_M3) AND M3
 dis_up_arm = (dis_up_arm_wide_all NOT wide_M3) AND M3
 // 
 dis_up_arm_good_a = dis_up_and_down_arm INTERACT 1XV2N >= 2
 dis_up_arm_good_b = dis_up_and_down_arm INTERACT RV2
 dis_up_arm_good_c = dis_up_and_down_arm INTERACT 2XV2N
 dis_up_arm_good = OR dis_up_arm_good_a dis_up_arm_good_b dis_up_arm_good_c
 dis_up_arm_bad = (dis_up_and_down_arm NOT dis_up_arm_good) INTERACT (all_up_and_down INTERACT 1XV2N == 1)
 // 
 dis_up_arm_err_stack = (dis_up_arm_bad AND dis_up_and_down_arm) INTERACT 1XV2N
 dis_up_arm_err = dis_up_arm INTERACT dis_up_arm_err_stack
 err2_met_up = (dis_up_arm_err INTERACT (1XV2N NOT OUTSIDE dis_up_arm_err)) NOT INTERACT (OR RV2 2XV2N)
 err2_met_up NOT INTERACT Vy2_BAR
}
 
Q: There should be at least two square Vy or one rectangular Vy in the intersection area of bottom metal and upper metal, when either wide metal Mxy or 1.25xMy length >= 0.272um and width >= 0.272um, the space between either via and wide metal <= 1um (S, S is the shortest running path length from Via to the wide metal). (except via bar)
A: 
RVy2_R_5_M2 {
@ There should be at least two square Vy or one rectangular Vy in the intersection area of bottom metal and upper metal, when either wide metal Mxy or 1.25xMy length >= 0.272um and width >= 0.272um, the space between either via and wide metal <= 1um (S, S is the shortest running path length from Via to the wide metal). (except via bar)
 // DRC flags each intersecting area ({bottom metal AND upper metal}) with single square Via within the branch check region
 wide_M2 = (WITH WIDTH M2 > 0.272-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 0.272-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 0.272-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M2_real = wide_M2 NOT OUTSIDE ((SIZE wide_M2 BY 1+GLOBAL_TOLERANCE) INTERACT V2)
 all_down_and_up = (M2 INTERACT wide_M2) AND M3
 dis_down_arm_wide_all = SIZE wide_M2_real BY 1+GLOBAL_TOLERANCE INSIDE OF M2 STEP 0.025
 dis_down_and_up = dis_down_arm_wide_all AND all_down_and_up
 dis_down_and_up_arm = (dis_down_and_up NOT wide_M2) AND M2
 dis_down_arm = (dis_down_arm_wide_all NOT wide_M2) AND M2
 // 
 dis_down_arm_good_a = dis_down_and_up_arm INTERACT 1XV2N >= 2
 dis_down_arm_good_b = dis_down_and_up_arm INTERACT RV2
 dis_down_arm_good_c = dis_down_and_up_arm INTERACT 2XV2N
 dis_down_arm_good = OR dis_down_arm_good_a dis_down_arm_good_b dis_down_arm_good_c
 dis_down_arm_bad = (dis_down_and_up_arm NOT dis_down_arm_good) INTERACT (all_down_and_up INTERACT 1XV2N == 1)
 // 
 dis_down_arm_err_stack = (dis_down_arm_bad AND dis_down_and_up_arm) INTERACT 1XV2N
 dis_down_arm_err = dis_down_arm INTERACT dis_down_arm_err_stack
 err1_met_down = (dis_down_arm_err INTERACT (1XV2N NOT OUTSIDE dis_down_arm_err)) NOT INTERACT (OR RV2 2XV2N)
 // 
 wide_M3 = (WITH WIDTH M3 > 0.272-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 0.272-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 0.272-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M3_real = wide_M3 NOT OUTSIDE ((SIZE wide_M3 BY 1+GLOBAL_TOLERANCE) INTERACT V2)
 all_up_and_down = (M3 INTERACT wide_M3) AND M2
 dis_up_arm_wide_all = SIZE wide_M3_real BY 1+GLOBAL_TOLERANCE INSIDE OF M3 STEP 0.025
 dis_up_and_down = dis_up_arm_wide_all AND all_up_and_down
 dis_up_and_down_arm = (dis_up_and_down NOT wide_M3) AND M3
 dis_up_arm = (dis_up_arm_wide_all NOT wide_M3) AND M3
 // 
 dis_up_arm_good_a = dis_up_and_down_arm INTERACT 1XV2N >= 2
 dis_up_arm_good_b = dis_up_and_down_arm INTERACT RV2
 dis_up_arm_good_c = dis_up_and_down_arm INTERACT 2XV2N
 dis_up_arm_good = OR dis_up_arm_good_a dis_up_arm_good_b dis_up_arm_good_c
 dis_up_arm_bad = (dis_up_and_down_arm NOT dis_up_arm_good) INTERACT (all_up_and_down INTERACT 1XV2N == 1)
 // 
 dis_up_arm_err_stack = (dis_up_arm_bad AND dis_up_and_down_arm) INTERACT 1XV2N
 dis_up_arm_err = dis_up_arm INTERACT dis_up_arm_err_stack
 err2_met_up = (dis_up_arm_err INTERACT (1XV2N NOT OUTSIDE dis_up_arm_err)) NOT INTERACT (OR RV2 2XV2N)
 err1_met_down NOT INTERACT Vy2_BAR
}
 
Q: There should be at least two square Vy or one rectangular Vy in the intersection area of bottom metal and upper metal, when either wide metal Mxy or 1.25xMy length >= 0.272um and width >= 0.272um, the space between either via and wide metal <= 1um (S, S is the shortest running path length from Via to the wide metal). (except via bar)
A: 
RVy2_R_5_M3 {
@ There should be at least two square Vy or one rectangular Vy in the intersection area of bottom metal and upper metal, when either wide metal Mxy or 1.25xMy length >= 0.272um and width >= 0.272um, the space between either via and wide metal <= 1um (S, S is the shortest running path length from Via to the wide metal). (except via bar)
 // DRC flags each intersecting area ({bottom metal AND upper metal}) with single square Via within the branch check region
 wide_M2 = (WITH WIDTH M2 > 0.272-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 0.272-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 0.272-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M2_real = wide_M2 NOT OUTSIDE ((SIZE wide_M2 BY 1+GLOBAL_TOLERANCE) INTERACT V2)
 all_down_and_up = (M2 INTERACT wide_M2) AND M3
 dis_down_arm_wide_all = SIZE wide_M2_real BY 1+GLOBAL_TOLERANCE INSIDE OF M2 STEP 0.025
 dis_down_and_up = dis_down_arm_wide_all AND all_down_and_up
 dis_down_and_up_arm = (dis_down_and_up NOT wide_M2) AND M2
 dis_down_arm = (dis_down_arm_wide_all NOT wide_M2) AND M2
 // 
 dis_down_arm_good_a = dis_down_and_up_arm INTERACT 1XV2N >= 2
 dis_down_arm_good_b = dis_down_and_up_arm INTERACT RV2
 dis_down_arm_good_c = dis_down_and_up_arm INTERACT 2XV2N
 dis_down_arm_good = OR dis_down_arm_good_a dis_down_arm_good_b dis_down_arm_good_c
 dis_down_arm_bad = (dis_down_and_up_arm NOT dis_down_arm_good) INTERACT (all_down_and_up INTERACT 1XV2N == 1)
 // 
 dis_down_arm_err_stack = (dis_down_arm_bad AND dis_down_and_up_arm) INTERACT 1XV2N
 dis_down_arm_err = dis_down_arm INTERACT dis_down_arm_err_stack
 err1_met_down = (dis_down_arm_err INTERACT (1XV2N NOT OUTSIDE dis_down_arm_err)) NOT INTERACT (OR RV2 2XV2N)
 // 
 wide_M3 = (WITH WIDTH M3 > 0.272-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 0.272-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 0.272-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M3_real = wide_M3 NOT OUTSIDE ((SIZE wide_M3 BY 1+GLOBAL_TOLERANCE) INTERACT V2)
 all_up_and_down = (M3 INTERACT wide_M3) AND M2
 dis_up_arm_wide_all = SIZE wide_M3_real BY 1+GLOBAL_TOLERANCE INSIDE OF M3 STEP 0.025
 dis_up_and_down = dis_up_arm_wide_all AND all_up_and_down
 dis_up_and_down_arm = (dis_up_and_down NOT wide_M3) AND M3
 dis_up_arm = (dis_up_arm_wide_all NOT wide_M3) AND M3
 // 
 dis_up_arm_good_a = dis_up_and_down_arm INTERACT 1XV2N >= 2
 dis_up_arm_good_b = dis_up_and_down_arm INTERACT RV2
 dis_up_arm_good_c = dis_up_and_down_arm INTERACT 2XV2N
 dis_up_arm_good = OR dis_up_arm_good_a dis_up_arm_good_b dis_up_arm_good_c
 dis_up_arm_bad = (dis_up_and_down_arm NOT dis_up_arm_good) INTERACT (all_up_and_down INTERACT 1XV2N == 1)
 // 
 dis_up_arm_err_stack = (dis_up_arm_bad AND dis_up_and_down_arm) INTERACT 1XV2N
 dis_up_arm_err = dis_up_arm INTERACT dis_up_arm_err_stack
 err2_met_up = (dis_up_arm_err INTERACT (1XV2N NOT OUTSIDE dis_up_arm_err)) NOT INTERACT (OR RV2 2XV2N)
 err2_met_up NOT INTERACT Vy2_BAR
}
 
Q: There should be at least two square Vy or one rectangular Vy in the intersection area of bottom metal and upper metal, when either wide metal Mxy or 1.25xMy width and length >= 0.542um, the space between either via and wide metal <= 3um (S, S is the shortest running path length from Via to the wide metal). (except via bar)
A: 
RVy2_R_6_M2 {
@ There should be at least two square Vy or one rectangular Vy in the intersection area of bottom metal and upper metal, when either wide metal Mxy or 1.25xMy width and length >= 0.542um, the space between either via and wide metal <= 3um (S, S is the shortest running path length from Via to the wide metal). (except via bar)
 // DRC flags each intersecting area ({bottom metal AND upper metal}) with single square Via within the branch check region
 wide_M2 = (WITH WIDTH M2 > 0.542-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 0.542-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 0.542-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M2_real = wide_M2 NOT OUTSIDE ((SIZE wide_M2 BY 3+GLOBAL_TOLERANCE) INTERACT V2)
 all_down_and_up = (M2 INTERACT wide_M2) AND M3
 dis_down_arm_wide_all = SIZE wide_M2_real BY 3+GLOBAL_TOLERANCE INSIDE OF M2 STEP 0.025
 dis_down_and_up = dis_down_arm_wide_all AND all_down_and_up
 dis_down_and_up_arm = (dis_down_and_up NOT wide_M2) AND M2
 dis_down_arm = (dis_down_arm_wide_all NOT wide_M2) AND M2
 // 
 dis_down_arm_good_a = dis_down_and_up_arm INTERACT 1XV2N >= 2
 dis_down_arm_good_b = dis_down_and_up_arm INTERACT RV2
 dis_down_arm_good_c = dis_down_and_up_arm INTERACT 2XV2N
 dis_down_arm_good = OR dis_down_arm_good_a dis_down_arm_good_b dis_down_arm_good_c
 dis_down_arm_bad = (dis_down_and_up_arm NOT dis_down_arm_good) INTERACT (all_down_and_up INTERACT 1XV2N == 1)
 // 
 dis_down_arm_err_stack = (dis_down_arm_bad AND dis_down_and_up_arm) INTERACT 1XV2N
 dis_down_arm_err = dis_down_arm INTERACT dis_down_arm_err_stack
 err1_met_down = (dis_down_arm_err INTERACT (1XV2N NOT OUTSIDE dis_down_arm_err)) NOT INTERACT (OR RV2 2XV2N)
 // 
 wide_M3 = (WITH WIDTH M3 > 0.542-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 0.542-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 0.542-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M3_real = wide_M3 NOT OUTSIDE ((SIZE wide_M3 BY 3+GLOBAL_TOLERANCE) INTERACT V2)
 all_up_and_down = (M3 INTERACT wide_M3) AND M2
 dis_up_arm_wide_all = SIZE wide_M3_real BY 3+GLOBAL_TOLERANCE INSIDE OF M3 STEP 0.025
 dis_up_and_down = dis_up_arm_wide_all AND all_up_and_down
 dis_up_and_down_arm = (dis_up_and_down NOT wide_M3) AND M3
 dis_up_arm = (dis_up_arm_wide_all NOT wide_M3) AND M3
 // 
 dis_up_arm_good_a = dis_up_and_down_arm INTERACT 1XV2N >= 2
 dis_up_arm_good_b = dis_up_and_down_arm INTERACT RV2
 dis_up_arm_good_c = dis_up_and_down_arm INTERACT 2XV2N
 dis_up_arm_good = OR dis_up_arm_good_a dis_up_arm_good_b dis_up_arm_good_c
 dis_up_arm_bad = (dis_up_and_down_arm NOT dis_up_arm_good) INTERACT (all_up_and_down INTERACT 1XV2N == 1)
 // 
 dis_up_arm_err_stack = (dis_up_arm_bad AND dis_up_and_down_arm) INTERACT 1XV2N
 dis_up_arm_err = dis_up_arm INTERACT dis_up_arm_err_stack
 err2_met_up = (dis_up_arm_err INTERACT (1XV2N NOT OUTSIDE dis_up_arm_err)) NOT INTERACT (OR RV2 2XV2N)
 err1_met_down NOT INTERACT Vy2_BAR
}
 
Q: There should be at least two square Vy or one rectangular Vy in the intersection area of bottom metal and upper metal, when either wide metal Mxy or 1.25xMy width and length >= 0.542um, the space between either via and wide metal <= 3um (S, S is the shortest running path length from Via to the wide metal). (except via bar)
A: 
RVy2_R_6_M3 {
@ There should be at least two square Vy or one rectangular Vy in the intersection area of bottom metal and upper metal, when either wide metal Mxy or 1.25xMy width and length >= 0.542um, the space between either via and wide metal <= 3um (S, S is the shortest running path length from Via to the wide metal). (except via bar)
 // DRC flags each intersecting area ({bottom metal AND upper metal}) with single square Via within the branch check region
 wide_M2 = (WITH WIDTH M2 > 0.542-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 0.542-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 0.542-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M2_real = wide_M2 NOT OUTSIDE ((SIZE wide_M2 BY 3+GLOBAL_TOLERANCE) INTERACT V2)
 all_down_and_up = (M2 INTERACT wide_M2) AND M3
 dis_down_arm_wide_all = SIZE wide_M2_real BY 3+GLOBAL_TOLERANCE INSIDE OF M2 STEP 0.025
 dis_down_and_up = dis_down_arm_wide_all AND all_down_and_up
 dis_down_and_up_arm = (dis_down_and_up NOT wide_M2) AND M2
 dis_down_arm = (dis_down_arm_wide_all NOT wide_M2) AND M2
 // 
 dis_down_arm_good_a = dis_down_and_up_arm INTERACT 1XV2N >= 2
 dis_down_arm_good_b = dis_down_and_up_arm INTERACT RV2
 dis_down_arm_good_c = dis_down_and_up_arm INTERACT 2XV2N
 dis_down_arm_good = OR dis_down_arm_good_a dis_down_arm_good_b dis_down_arm_good_c
 dis_down_arm_bad = (dis_down_and_up_arm NOT dis_down_arm_good) INTERACT (all_down_and_up INTERACT 1XV2N == 1)
 // 
 dis_down_arm_err_stack = (dis_down_arm_bad AND dis_down_and_up_arm) INTERACT 1XV2N
 dis_down_arm_err = dis_down_arm INTERACT dis_down_arm_err_stack
 err1_met_down = (dis_down_arm_err INTERACT (1XV2N NOT OUTSIDE dis_down_arm_err)) NOT INTERACT (OR RV2 2XV2N)
 // 
 wide_M3 = (WITH WIDTH M3 > 0.542-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 0.542-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 0.542-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M3_real = wide_M3 NOT OUTSIDE ((SIZE wide_M3 BY 3+GLOBAL_TOLERANCE) INTERACT V2)
 all_up_and_down = (M3 INTERACT wide_M3) AND M2
 dis_up_arm_wide_all = SIZE wide_M3_real BY 3+GLOBAL_TOLERANCE INSIDE OF M3 STEP 0.025
 dis_up_and_down = dis_up_arm_wide_all AND all_up_and_down
 dis_up_and_down_arm = (dis_up_and_down NOT wide_M3) AND M3
 dis_up_arm = (dis_up_arm_wide_all NOT wide_M3) AND M3
 // 
 dis_up_arm_good_a = dis_up_and_down_arm INTERACT 1XV2N >= 2
 dis_up_arm_good_b = dis_up_and_down_arm INTERACT RV2
 dis_up_arm_good_c = dis_up_and_down_arm INTERACT 2XV2N
 dis_up_arm_good = OR dis_up_arm_good_a dis_up_arm_good_b dis_up_arm_good_c
 dis_up_arm_bad = (dis_up_and_down_arm NOT dis_up_arm_good) INTERACT (all_up_and_down INTERACT 1XV2N == 1)
 // 
 dis_up_arm_err_stack = (dis_up_arm_bad AND dis_up_and_down_arm) INTERACT 1XV2N
 dis_up_arm_err = dis_up_arm INTERACT dis_up_arm_err_stack
 err2_met_up = (dis_up_arm_err INTERACT (1XV2N NOT OUTSIDE dis_up_arm_err)) NOT INTERACT (OR RV2 2XV2N)
 err2_met_up NOT INTERACT Vy2_BAR
}
 
Q: There should be at least two square Vy or one rectangular Vy in the intersection area of bottom metal and upper metal, when either wide metal Mxy or 1.25xMy width and length >= 1.01um, the space between either via and wide metal <= 5um (S, S is the shortest running path length from Via to the wide metal). (except via bar)
A: 
RVy2_R_7_M2 {
@ There should be at least two square Vy or one rectangular Vy in the intersection area of bottom metal and upper metal, when either wide metal Mxy or 1.25xMy width and length >= 1.01um, the space between either via and wide metal <= 5um (S, S is the shortest running path length from Via to the wide metal). (except via bar)
 // DRC flags each intersecting area ({bottom metal AND upper metal}) with single square Via within the branch check region
 wide_M2 = (WITH WIDTH M2 > 1.01-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 1.01-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 1.01-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M2_real = wide_M2 NOT OUTSIDE ((SIZE wide_M2 BY 5+GLOBAL_TOLERANCE) INTERACT V2)
 all_down_and_up = (M2 INTERACT wide_M2) AND M3
 dis_down_arm_wide_all = SIZE wide_M2_real BY 5+GLOBAL_TOLERANCE INSIDE OF M2 STEP 0.025
 dis_down_and_up = dis_down_arm_wide_all AND all_down_and_up
 dis_down_and_up_arm = (dis_down_and_up NOT wide_M2) AND M2
 dis_down_arm = (dis_down_arm_wide_all NOT wide_M2) AND M2
 // 
 dis_down_arm_good_a = dis_down_and_up_arm INTERACT 1XV2N >= 2
 dis_down_arm_good_b = dis_down_and_up_arm INTERACT RV2
 dis_down_arm_good_c = dis_down_and_up_arm INTERACT 2XV2N
 dis_down_arm_good = OR dis_down_arm_good_a dis_down_arm_good_b dis_down_arm_good_c
 dis_down_arm_bad = (dis_down_and_up_arm NOT dis_down_arm_good) INTERACT (all_down_and_up INTERACT 1XV2N == 1)
 // 
 dis_down_arm_err_stack = (dis_down_arm_bad AND dis_down_and_up_arm) INTERACT 1XV2N
 dis_down_arm_err = dis_down_arm INTERACT dis_down_arm_err_stack
 err1_met_down = (dis_down_arm_err INTERACT (1XV2N NOT OUTSIDE dis_down_arm_err)) NOT INTERACT (OR RV2 2XV2N)
 // 
 wide_M3 = (WITH WIDTH M3 > 1.01-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 1.01-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 1.01-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M3_real = wide_M3 NOT OUTSIDE ((SIZE wide_M3 BY 5+GLOBAL_TOLERANCE) INTERACT V2)
 all_up_and_down = (M3 INTERACT wide_M3) AND M2
 dis_up_arm_wide_all = SIZE wide_M3_real BY 5+GLOBAL_TOLERANCE INSIDE OF M3 STEP 0.025
 dis_up_and_down = dis_up_arm_wide_all AND all_up_and_down
 dis_up_and_down_arm = (dis_up_and_down NOT wide_M3) AND M3
 dis_up_arm = (dis_up_arm_wide_all NOT wide_M3) AND M3
 // 
 dis_up_arm_good_a = dis_up_and_down_arm INTERACT 1XV2N >= 2
 dis_up_arm_good_b = dis_up_and_down_arm INTERACT RV2
 dis_up_arm_good_c = dis_up_and_down_arm INTERACT 2XV2N
 dis_up_arm_good = OR dis_up_arm_good_a dis_up_arm_good_b dis_up_arm_good_c
 dis_up_arm_bad = (dis_up_and_down_arm NOT dis_up_arm_good) INTERACT (all_up_and_down INTERACT 1XV2N == 1)
 // 
 dis_up_arm_err_stack = (dis_up_arm_bad AND dis_up_and_down_arm) INTERACT 1XV2N
 dis_up_arm_err = dis_up_arm INTERACT dis_up_arm_err_stack
 err2_met_up = (dis_up_arm_err INTERACT (1XV2N NOT OUTSIDE dis_up_arm_err)) NOT INTERACT (OR RV2 2XV2N)
 err1_met_down NOT INTERACT Vy2_BAR
}
 
Q: There should be at least two square Vy or one rectangular Vy in the intersection area of bottom metal and upper metal, when either wide metal Mxy or 1.25xMy width and length >= 1.01um, the space between either via and wide metal <= 5um (S, S is the shortest running path length from Via to the wide metal). (except via bar)
A: 
RVy2_R_7_M3 {
@ There should be at least two square Vy or one rectangular Vy in the intersection area of bottom metal and upper metal, when either wide metal Mxy or 1.25xMy width and length >= 1.01um, the space between either via and wide metal <= 5um (S, S is the shortest running path length from Via to the wide metal). (except via bar)
 // DRC flags each intersecting area ({bottom metal AND upper metal}) with single square Via within the branch check region
 wide_M2 = (WITH WIDTH M2 > 1.01-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 1.01-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 1.01-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M2_real = wide_M2 NOT OUTSIDE ((SIZE wide_M2 BY 5+GLOBAL_TOLERANCE) INTERACT V2)
 all_down_and_up = (M2 INTERACT wide_M2) AND M3
 dis_down_arm_wide_all = SIZE wide_M2_real BY 5+GLOBAL_TOLERANCE INSIDE OF M2 STEP 0.025
 dis_down_and_up = dis_down_arm_wide_all AND all_down_and_up
 dis_down_and_up_arm = (dis_down_and_up NOT wide_M2) AND M2
 dis_down_arm = (dis_down_arm_wide_all NOT wide_M2) AND M2
 // 
 dis_down_arm_good_a = dis_down_and_up_arm INTERACT 1XV2N >= 2
 dis_down_arm_good_b = dis_down_and_up_arm INTERACT RV2
 dis_down_arm_good_c = dis_down_and_up_arm INTERACT 2XV2N
 dis_down_arm_good = OR dis_down_arm_good_a dis_down_arm_good_b dis_down_arm_good_c
 dis_down_arm_bad = (dis_down_and_up_arm NOT dis_down_arm_good) INTERACT (all_down_and_up INTERACT 1XV2N == 1)
 // 
 dis_down_arm_err_stack = (dis_down_arm_bad AND dis_down_and_up_arm) INTERACT 1XV2N
 dis_down_arm_err = dis_down_arm INTERACT dis_down_arm_err_stack
 err1_met_down = (dis_down_arm_err INTERACT (1XV2N NOT OUTSIDE dis_down_arm_err)) NOT INTERACT (OR RV2 2XV2N)
 // 
 wide_M3 = (WITH WIDTH M3 > 1.01-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 1.01-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 1.01-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M3_real = wide_M3 NOT OUTSIDE ((SIZE wide_M3 BY 5+GLOBAL_TOLERANCE) INTERACT V2)
 all_up_and_down = (M3 INTERACT wide_M3) AND M2
 dis_up_arm_wide_all = SIZE wide_M3_real BY 5+GLOBAL_TOLERANCE INSIDE OF M3 STEP 0.025
 dis_up_and_down = dis_up_arm_wide_all AND all_up_and_down
 dis_up_and_down_arm = (dis_up_and_down NOT wide_M3) AND M3
 dis_up_arm = (dis_up_arm_wide_all NOT wide_M3) AND M3
 // 
 dis_up_arm_good_a = dis_up_and_down_arm INTERACT 1XV2N >= 2
 dis_up_arm_good_b = dis_up_and_down_arm INTERACT RV2
 dis_up_arm_good_c = dis_up_and_down_arm INTERACT 2XV2N
 dis_up_arm_good = OR dis_up_arm_good_a dis_up_arm_good_b dis_up_arm_good_c
 dis_up_arm_bad = (dis_up_and_down_arm NOT dis_up_arm_good) INTERACT (all_up_and_down INTERACT 1XV2N == 1)
 // 
 dis_up_arm_err_stack = (dis_up_arm_bad AND dis_up_and_down_arm) INTERACT 1XV2N
 dis_up_arm_err = dis_up_arm INTERACT dis_up_arm_err_stack
 err2_met_up = (dis_up_arm_err INTERACT (1XV2N NOT OUTSIDE dis_up_arm_err)) NOT INTERACT (OR RV2 2XV2N)
 err2_met_up NOT INTERACT Vy2_BAR
}



//RVy3

Q: Single RVy is not allowed in H-shape Mxy+1/1.25xMy, when:
    1) The Mxy+1/1.25xMy has H-shape interacting with two metal holes: both two metal holes length <= 4.5um and two metal hole area <= 4.05um2
    2) The RVy overlaps on the center metal bar of this H-shape Mxy+1/1.25xMy
    3) The center metal bar length <= 0.9um and the metal bar width <= 0.12um
A: 
RVy3_R_1 {
@ Single RVy is not allowed in H-shape Mxy+1/1.25xMy, when:
@ 1) The Mxy+1/1.25xMy has H-shape interacting with two metal holes: both two metal holes length <= 4.5um and two metal hole area <= 4.05um2
@ 2) The RVy overlaps on the center metal bar of this H-shape Mxy+1/1.25xMy
@ 3) The center metal bar length <= 0.9um and the metal bar width <= 0.12um
 // @ DRC doesn't check when one or more square 1xVn is also on H-shape Mxy+1/1.25xMy region
 hole_area_meet = AREA (HOLES M4 INNER) <= 4.05
 hole_area_meet_len = (hole_area_meet WITH EDGE (LENGTH hole_area_meet <= 0.9)) NOT WITH EDGE (LENGTH hole_area_meet > 4.5)
 hole_area_real = (hole_area_meet_len NOT ENCLOSE RECTANGLE 0.9+GLOBAL_TOLERANCE 4.5) NOT ENCLOSE RECTANGLE 0.9 4.5+GLOBAL_TOLERANCE
 hole_bars_len = M4 COIN EDGE hole_area_real
 // 
 hole_bars = INT hole_bars_len <= 0.12 ABUT<90 OPPOSITE REGION EXCLUDE SHIELDED
 hole_bars_real = hole_bars WITH EDGE (LENGTH hole_bars_len <= 0.9)
 hole_bars_vias_rect = RV3 INTERACT ((hole_bars_real INTERACT hole_area_real == 2) NOT ENCLOSE V3N >= 2)
 err1 = hole_bars_real INTERACT hole_bars_vias_rect == 1
 err1 NOT INSIDE SealR_NOT_BULK
}
 
Q: Redundant via requirement must be obeyed by one of following conditions of Vy numbers and space for Mxy and 1.25xMy connection
    (One of Mxy or 1.25xMy has width and length >= 0.162um) (Except VIA bar)
    1) At least one rectangular Vy
    2) At least two square Vy with space <= 0.091um
    3) At least four square Vy with space <= 0.415um
A: 
RVy3_R_2 {
@ Redundant via requirement must be obeyed by one of following conditions of Vy numbers and space for Mxy and 1.25xMy connection
@ (One of Mxy or 1.25xMy has width and length >= 0.162um) (Except VIA bar)
@ 1) At least one rectangular Vy
@ 2) At least two square Vy with space <= 0.091um
@ 3) At least four square Vy with space <= 0.415um
 X1a = WITH WIDTH M3 > 0.162-GLOBAL_TOLERANCE <= 0.272-GLOBAL_TOLERANCE
 X1b = WITH WIDTH M4 > 0.162-GLOBAL_TOLERANCE <= 0.272-GLOBAL_TOLERANCE
 Y1a = WITH WIDTH M3 > 0.272-GLOBAL_TOLERANCE
 Y1b = WITH WIDTH M4 > 0.272-GLOBAL_TOLERANCE
 WIDE_1 = (X1a AND M4) ENCLOSE V3
 WIDE_2 = (M3 AND X1b) ENCLOSE V3
 WIDE_3 = (Y1a AND M4) ENCLOSE V3
 WIDE_4 = (M3 AND Y1b) ENCLOSE V3
 WIDE_all_raw = (WIDE_1 OR WIDE_2) NOT (WIDE_3 OR WIDE_4)
 WIDE_all = (M3 AND M4) NOT OUTSIDE WIDE_all_raw
 // 
 // condition 1 & 2
 Y1_good = WIDE_all_raw AND RV3
 Y2_good = WIDE_all_raw AND 2XV3N
 // 
 // condition 3
 Y3_wide_all = WIDE_all_raw NOT INTERACT (OR Y1_good Y2_good)
 Y3_wide = (WIDE_all INTERACT Y3_wide_all) INTERACT V3_SR >= 2
 Y3_comb_step = SIZE V3_SR BY 0.091/2 INSIDE OF Y3_wide STEP 0.020
 Y3_good_step = OR (Y3_comb_step INTERACT V3N >= 2) (Y3_comb_step INTERACT (OR RV3 2XV3N))
 Y3_good = WIDE_all_raw AND Y3_good_step
 // 
 // condition 4: 32nm*32nm via can be replaced by 2XVia/RVia
 Y4_wide_all = WIDE_all_raw NOT INTERACT (OR Y1_good Y2_good Y3_good)
 Y4_wide = (WIDE_all INTERACT Y4_wide_all) INTERACT V3_SR >= 2 // rectangle array 0.415/2 =0.207
 Y4_vias_input = V3_SR AND Y4_wide
 Y4_wide_chk_1 = Y4_wide INTERACT Y4_wide_all
 Y4_comb_step1 = SIZE Y4_vias_input BY 0.050 INSIDE OF Y4_wide_chk_1 STEP 0.020
 Y4_good_step1_a = OR (Y4_comb_step1 INTERACT V3N >= 4) ((Y4_comb_step1 INTERACT V3N >= 2) INTERACT (OR RV3 2XV3N)) // step1: 0.050
 Y4_good_step1_b = OR (Y4_comb_step1 INTERACT 2XV3N >= 2) (Y4_comb_step1 INTERACT RV3 >= 2)
 Y4_good_step1 = OR Y4_good_step1_a Y4_good_step1_b
 // 
 Y4_wide_chk_2 = Y4_wide_chk_1 INTERACT (WIDE_all_raw NOT INTERACT Y4_good_step1)
 Y4_comb_step2 = SIZE Y4_comb_step1 BY 0.035 INSIDE OF Y4_wide_chk_2 STEP 0.020
 Y4_good_step2_a = OR (Y4_comb_step2 INTERACT V3N >= 4) ((Y4_comb_step2 INTERACT V3N >= 2) INTERACT (OR RV3 2XV3N)) // step2: 0.035
 Y4_good_step2_b = OR (Y4_comb_step2 INTERACT 2XV3N >= 2) (Y4_comb_step2 INTERACT RV3 >= 2)
 Y4_good_step2 = OR Y4_good_step2_a Y4_good_step2_b
 // 
 Y4_wide_chk_3 = Y4_wide_chk_2 INTERACT (WIDE_all_raw NOT INTERACT Y4_good_step2)
 Y4_comb_step3 = SIZE Y4_comb_step2 BY 0.035 INSIDE OF Y4_wide_chk_3 STEP 0.020
 Y4_good_step3_a = OR (Y4_comb_step3 INTERACT V3N >= 4) ((Y4_comb_step3 INTERACT V3N >= 2) INTERACT (OR RV3 2XV3N)) // step3: 0.035
 Y4_good_step3_b = OR (Y4_comb_step3 INTERACT 2XV3N >= 2) (Y4_comb_step3 INTERACT RV3 >= 2)
 Y4_good_step3 = OR Y4_good_step3_a Y4_good_step3_b
 // 
 Y4_wide_chk_4 = Y4_wide_chk_3 INTERACT (WIDE_all_raw NOT INTERACT Y4_good_step3)
 Y4_comb_step4 = SIZE Y4_comb_step3 BY 0.035 INSIDE OF Y4_wide_chk_4 STEP 0.020
 Y4_good_step4_a = OR (Y4_comb_step4 INTERACT V3N >= 4) ((Y4_comb_step4 INTERACT V3N >= 2) INTERACT (OR RV3 2XV3N)) // step4: 0.035
 Y4_good_step4_b = OR (Y4_comb_step4 INTERACT 2XV3N >= 2) (Y4_comb_step4 INTERACT RV3 >= 2)
 Y4_good_step4 = OR Y4_good_step4_a Y4_good_step4_b
 // 
 Y4_wide_chk_5 = Y4_wide_chk_4 INTERACT (WIDE_all_raw NOT INTERACT Y4_good_step4)
 Y4_comb_step5 = SIZE Y4_comb_step4 BY 0.035 INSIDE OF Y4_wide_chk_5 STEP 0.020
 Y4_good_step5_a = OR (Y4_comb_step5 INTERACT V3N >= 4) ((Y4_comb_step5 INTERACT V3N >= 2) INTERACT (OR RV3 2XV3N)) // step5: 0.035
 Y4_good_step5_b = OR (Y4_comb_step5 INTERACT 2XV3N >= 2) (Y4_comb_step5 INTERACT RV3 >= 2)
 Y4_good_step5 = OR Y4_good_step5_a Y4_good_step5_b
 // 
 Y4_wide_chk_6 = Y4_wide_chk_5 INTERACT (WIDE_all_raw NOT INTERACT Y4_good_step5)
 Y4_comb_step6 = SIZE Y4_comb_step5 BY 0.018 INSIDE OF Y4_wide_chk_6 STEP 0.015
 Y4_good_step6_a = OR (Y4_comb_step6 INTERACT V3N >= 4) ((Y4_comb_step6 INTERACT V3N >= 2) INTERACT (OR RV3 2XV3N)) // step6: 0.207-0.05-0.035*4=0.018
 Y4_good_step6_b = OR (Y4_comb_step6 INTERACT 2XV3N >= 2) (Y4_comb_step6 INTERACT RV3 >= 2)
 Y4_good_step6 = OR Y4_good_step6_a Y4_good_step6_b
 Y4_good = WIDE_all_raw AND (OR Y4_good_step1 Y4_good_step2 Y4_good_step3 Y4_good_step4 Y4_good_step5 Y4_good_step6)
 // 
 err1 = (WIDE_all_raw OUTSIDE (OR Y1_good Y2_good Y3_good Y4_good)) INTERACT V3
 err1 NOT INTERACT Vy3_BAR
}
 
Q: Redundant via requirement must be obeyed by one of following conditions of Vy numbers and space for Mxy and 1.25xMy connection
     (One of Mxy or 1.25xMy has width and length >= 0.272um, two square vias are equal to one rectangular via for below conditions) (Except VIA bar, MARKS and OCCD region)
    1) At least four square Vy with space <= 0.091um
    2) At least nine square Vy with space <= 0.545um
    3) At least two rectangular Vy with space <= 0.202um
    4) At least five rectangular Vy with space <= 0.545um
A: 
RVy3_R_3 {
@ Redundant via requirement must be obeyed by one of following conditions of Vy numbers and space for Mxy and 1.25xMy connection
@ (One of Mxy or 1.25xMy has width and length >= 0.272um, two square vias are equal to one rectangular via for below conditions) (Except VIA bar, MARKS and OCCD region)
@ 1) At least four square Vy with space <= 0.091um
@ 2) At least nine square Vy with space <= 0.545um
@ 3) At least two rectangular Vy with space <= 0.202um
@ 4) At least five rectangular Vy with space <= 0.545um
 X1a = WITH WIDTH M3 > 0.272-GLOBAL_TOLERANCE
 X1b = WITH WIDTH M4 > 0.272-GLOBAL_TOLERANCE
 WIDE_1 = (X1a AND M4) ENCLOSE V3
 WIDE_2 = (M3 AND X1b) ENCLOSE V3
 WIDE_all_raw = WIDE_1 OR WIDE_2
 WIDE_all = (M3 AND M4) NOT OUTSIDE WIDE_all_raw
 // 
 // condition 3: not replaced by RVia
 Y3_wide = WIDE_all INTERACT V3N >= 4 // rectangle array 0.091/2=0.045
 Y3_vias_input = V3N AND Y3_wide
 Y3_comb_step = SIZE Y3_vias_input BY 0.091/2 INSIDE OF Y3_wide STEP 0.02 // via minimum space = 0.083
 Y3_good_step = Y3_comb_step INTERACT V3N >= 4
 Y3_good = WIDE_all_raw AND Y3_good_step
 // 
 // condition 1 & 2 & 4 & 5: 32nm*32nm via can be replaced by 2XVia/RVia
 Y1_wide_all = WIDE_all_raw NOT INTERACT Y3_good
 Y1_wide = (WIDE_all INTERACT Y1_wide_all) INTERACT V3_SR >= 2 // rectangle array 0.545/2=0.272
 Y1_vias_input = V3_SR AND Y1_wide
 Y1_wide_chk_1 = Y1_wide INTERACT Y1_wide_all
 Y1_comb_step1 = SIZE Y1_vias_input BY 0.061 INSIDE OF Y1_wide_chk_1 STEP 0.02 // step1: 0.061, via minimum space = 0.202/2=0.101
 Y1_good_step1_a = Y1_comb_step1 INTERACT V3N >= 9
 Y1_good_step1_b = Y1_comb_step1 INTERACT RV3 >= 5
 Y1_good_step1_c = Y1_comb_step1 INTERACT 2XV3N >= 3
 Y1_good_step1_d = (Y1_comb_step1 INTERACT 1XV3N >= 7) INTERACT RV3 >= 1
 Y1_good_step1_e = (Y1_comb_step1 INTERACT 1XV3N >= 6) INTERACT 2XV3N >= 1
 Y1_good_step1_f = (Y1_comb_step1 INTERACT 1XV3N >= 5) INTERACT RV3 >= 2
 Y1_good_step1_g = ((Y1_comb_step1 INTERACT 1XV3N >= 4) INTERACT 2XV3N >= 1) INTERACT RV3 >= 1
 Y1_good_step1_h = (Y1_comb_step1 INTERACT 1XV3N >= 3) INTERACT RV3 >= 3
 Y1_good_step1_i = (Y1_comb_step1 INTERACT 1XV3N >= 3) INTERACT 2XV3N >= 2
 Y1_good_step1_j = ((Y1_comb_step1 INTERACT 1XV3N >= 2) INTERACT 2XV3N >= 1) INTERACT RV3 >= 2
 // SETLAYER Y1_good_step1_k = (Y1_comb_step1 INTERACT 1XV3N >= 1) INTERACT RV3 >= 4
 Y1_good_step1_l = ((Y1_comb_step1 INTERACT 1XV3N >= 1) INTERACT 2XV3N >= 2) INTERACT RV3 >= 1
 Y1_good_step1_m = Y1_comb_step1 INTERACT RV3 >= 2 // remove good condition3_val: 0.202
 Y1_good_step1_n = Y1_comb_step1 INTERACT 2XV3N >= 2
 Y1_good_step1_o = (Y1_comb_step1 INTERACT 1XV3N >= 2) INTERACT RV3 >= 1
 Y1_good_step1_p = (Y1_comb_step1 INTERACT 1XV3N >= 1) INTERACT 2XV3N >= 1
 Y1_good_step1_q = (Y1_comb_step1 INTERACT 2XV3N >= 1) INTERACT RV3 >= 1
 Y1_good_step1_r = OR Y1_good_step1_a Y1_good_step1_b Y1_good_step1_c Y1_good_step1_d Y1_good_step1_e Y1_good_step1_f Y1_good_step1_g Y1_good_step1_h
 Y1_good_step1_s = OR Y1_good_step1_i Y1_good_step1_j Y1_good_step1_l Y1_good_step1_m Y1_good_step1_n Y1_good_step1_o Y1_good_step1_p Y1_good_step1_q
 Y1_good_step1 = OR Y1_good_step1_r Y1_good_step1_s
 // 
 Y1_wide_chk_2 = Y1_wide_chk_1 INTERACT (WIDE_all_raw NOT INTERACT Y1_good_step1)
 Y1_comb_step2 = SIZE Y1_comb_step1 BY 0.040 INSIDE OF Y1_wide_chk_2 STEP 0.02 // step2: 0.040
 Y1_good_step2_a = Y1_comb_step2 INTERACT V3N >= 9
 Y1_good_step2_b = Y1_comb_step2 INTERACT RV3 >= 5
 Y1_good_step2_c = Y1_comb_step2 INTERACT 2XV3N >= 3
 Y1_good_step2_d = (Y1_comb_step2 INTERACT 1XV3N >= 7) INTERACT RV3 >= 1
 Y1_good_step2_e = (Y1_comb_step2 INTERACT 1XV3N >= 6) INTERACT 2XV3N >= 1
 Y1_good_step2_f = (Y1_comb_step2 INTERACT 1XV3N >= 5) INTERACT RV3 >= 2
 Y1_good_step2_g = ((Y1_comb_step2 INTERACT 1XV3N >= 4) INTERACT 2XV3N >= 1) INTERACT RV3 >= 1
 Y1_good_step2_h = (Y1_comb_step2 INTERACT 1XV3N >= 3) INTERACT RV3 >= 3
 Y1_good_step2_i = (Y1_comb_step2 INTERACT 1XV3N >= 3) INTERACT 2XV3N >= 2
 Y1_good_step2_j = ((Y1_comb_step2 INTERACT 1XV3N >= 2) INTERACT 2XV3N >= 1) INTERACT RV3 >= 2
 // SETLAYER Y1_good_step2_k = (Y1_comb_step2 INTERACT 1XV3N >= 1) INTERACT RV3 >= 4
 Y1_good_step2_l = ((Y1_comb_step2 INTERACT 1XV3N >= 1) INTERACT 2XV3N >= 2) INTERACT RV3 >= 1
 Y1_good_step2_m = Y1_comb_step2 INTERACT RV3 >= 2
 Y1_good_step2_n = Y1_comb_step2 INTERACT 2XV3N >= 2
 Y1_good_step2_o = (Y1_comb_step2 INTERACT 1XV3N >= 2) INTERACT RV3 >= 1
 Y1_good_step2_p = (Y1_comb_step2 INTERACT 1XV3N >= 1) INTERACT 2XV3N >= 1
 Y1_good_step2_q = (Y1_comb_step2 INTERACT 2XV3N >= 1) INTERACT RV3 >= 1
 Y1_good_step2_r = OR Y1_good_step2_a Y1_good_step2_b Y1_good_step2_c Y1_good_step2_d Y1_good_step2_e Y1_good_step2_f Y1_good_step2_g Y1_good_step2_h
 Y1_good_step2_s = OR Y1_good_step2_i Y1_good_step2_j Y1_good_step2_l Y1_good_step2_m Y1_good_step2_n Y1_good_step2_o Y1_good_step2_p Y1_good_step2_q
 Y1_good_step2 = OR Y1_good_step2_r Y1_good_step2_s
 // 
 // condition 1 & 2 & 4 & 5: 32nm*32nm via can be replaced by 2XVia/RVia
 Y1_wide_chk_3 = Y1_wide_chk_2 INTERACT (WIDE_all_raw NOT INTERACT Y1_good_step2)
 Y1_comb_step3 = SIZE Y1_comb_step2 BY 0.04 INSIDE OF Y1_wide_chk_3 STEP 0.02 // step3: 0.040
 Y1_good_step3_a = Y1_comb_step3 INTERACT V3N >= 9
 Y1_good_step3_b = Y1_comb_step3 INTERACT RV3 >= 5
 Y1_good_step3_c = Y1_comb_step3 INTERACT 2XV3N >= 3
 Y1_good_step3_d = (Y1_comb_step3 INTERACT 1XV3N >= 7) INTERACT RV3 >= 1
 Y1_good_step3_e = (Y1_comb_step3 INTERACT 1XV3N >= 6) INTERACT 2XV3N >= 1
 Y1_good_step3_f = (Y1_comb_step3 INTERACT 1XV3N >= 5) INTERACT RV3 >= 2
 Y1_good_step3_g = ((Y1_comb_step3 INTERACT 1XV3N >= 4) INTERACT 2XV3N >= 1) INTERACT RV3 >= 1
 Y1_good_step3_h = (Y1_comb_step3 INTERACT 1XV3N >= 3) INTERACT RV3 >= 3
 Y1_good_step3_i = (Y1_comb_step3 INTERACT 1XV3N >= 3) INTERACT 2XV3N >= 2
 Y1_good_step3_j = ((Y1_comb_step3 INTERACT 1XV3N >= 2) INTERACT 2XV3N >= 1) INTERACT RV3 >= 2
 // SETLAYER Y1_good_step3_k = (Y1_comb_step3 INTERACT 1XV3N >= 1) INTERACT RV3 >= 4
 Y1_good_step3_l = ((Y1_comb_step3 INTERACT 1XV3N >= 1) INTERACT 2XV3N >= 2) INTERACT RV3 >= 1
 Y1_good_step3_r = OR Y1_good_step3_a Y1_good_step3_b Y1_good_step3_c Y1_good_step3_d Y1_good_step3_e Y1_good_step3_f Y1_good_step3_g Y1_good_step3_h
 Y1_good_step3_s = OR Y1_good_step3_i Y1_good_step3_j Y1_good_step3_l
 Y1_good_step3 = OR Y1_good_step3_r Y1_good_step3_s
 // 
 Y1_wide_chk_4 = Y1_wide_chk_3 INTERACT (WIDE_all_raw NOT INTERACT Y1_good_step3)
 Y1_comb_step4 = SIZE Y1_comb_step3 BY 0.040 INSIDE OF Y1_wide_chk_4 STEP 0.02 // step4: 0.040
 Y1_good_step4_a = Y1_comb_step4 INTERACT V3N >= 9
 Y1_good_step4_b = Y1_comb_step4 INTERACT RV3 >= 5
 Y1_good_step4_c = Y1_comb_step4 INTERACT 2XV3N >= 3
 Y1_good_step4_d = (Y1_comb_step4 INTERACT 1XV3N >= 7) INTERACT RV3 >= 1
 Y1_good_step4_e = (Y1_comb_step4 INTERACT 1XV3N >= 6) INTERACT 2XV3N >= 1
 Y1_good_step4_f = (Y1_comb_step4 INTERACT 1XV3N >= 5) INTERACT RV3 >= 2
 Y1_good_step4_g = ((Y1_comb_step4 INTERACT 1XV3N >= 4) INTERACT 2XV3N >= 1) INTERACT RV3 >= 1
 Y1_good_step4_h = (Y1_comb_step4 INTERACT 1XV3N >= 3) INTERACT RV3 >= 3
 Y1_good_step4_i = (Y1_comb_step4 INTERACT 1XV3N >= 3) INTERACT 2XV3N >= 2
 Y1_good_step4_j = ((Y1_comb_step4 INTERACT 1XV3N >= 2) INTERACT 2XV3N >= 1) INTERACT RV3 >= 2
 // SETLAYER Y1_good_step4_k = (Y1_comb_step4 INTERACT 1XV3N >= 1) INTERACT RV3 >= 4
 Y1_good_step4_l = ((Y1_comb_step4 INTERACT 1XV3N >= 1) INTERACT 2XV3N >= 2) INTERACT RV3 >= 1
 Y1_good_step4_r = OR Y1_good_step4_a Y1_good_step4_b Y1_good_step4_c Y1_good_step4_d Y1_good_step4_e Y1_good_step4_f Y1_good_step4_g Y1_good_step4_h
 Y1_good_step4_s = OR Y1_good_step4_i Y1_good_step4_j Y1_good_step4_l
 Y1_good_step4 = OR Y1_good_step4_r Y1_good_step4_s
 // 
 Y1_wide_chk_5 = Y1_wide_chk_4 INTERACT (WIDE_all_raw NOT INTERACT Y1_good_step4)
 Y1_comb_step5 = SIZE Y1_comb_step4 BY 0.040 INSIDE OF Y1_wide_chk_5 STEP 0.02 // step5: 0.040
 Y1_good_step5_a = Y1_comb_step5 INTERACT V3N >= 9
 Y1_good_step5_b = Y1_comb_step5 INTERACT RV3 >= 5
 Y1_good_step5_c = Y1_comb_step5 INTERACT 2XV3N >= 3
 Y1_good_step5_d = (Y1_comb_step5 INTERACT 1XV3N >= 7) INTERACT RV3 >= 1
 Y1_good_step5_e = (Y1_comb_step5 INTERACT 1XV3N >= 6) INTERACT 2XV3N >= 1
 Y1_good_step5_f = (Y1_comb_step5 INTERACT 1XV3N >= 5) INTERACT RV3 >= 2
 Y1_good_step5_g = ((Y1_comb_step5 INTERACT 1XV3N >= 4) INTERACT 2XV3N >= 1) INTERACT RV3 >= 1
 Y1_good_step5_h = (Y1_comb_step5 INTERACT 1XV3N >= 3) INTERACT RV3 >= 3
 Y1_good_step5_i = (Y1_comb_step5 INTERACT 1XV3N >= 3) INTERACT 2XV3N >= 2
 Y1_good_step5_j = ((Y1_comb_step5 INTERACT 1XV3N >= 2) INTERACT 2XV3N >= 1) INTERACT RV3 >= 2
 // SETLAYER Y1_good_step5_k = (Y1_comb_step5 INTERACT 1XV3N >= 1) INTERACT RV3 >= 4
 Y1_good_step5_l = ((Y1_comb_step5 INTERACT 1XV3N >= 1) INTERACT 2XV3N >= 2) INTERACT RV3 >= 1
 Y1_good_step5_r = OR Y1_good_step5_a Y1_good_step5_b Y1_good_step5_c Y1_good_step5_d Y1_good_step5_e Y1_good_step5_f Y1_good_step5_g Y1_good_step5_h
 Y1_good_step5_s = OR Y1_good_step5_i Y1_good_step5_j Y1_good_step5_l
 Y1_good_step5 = OR Y1_good_step5_r Y1_good_step5_s
 // 
 Y1_wide_chk_6 = Y1_wide_chk_5 INTERACT (WIDE_all_raw NOT INTERACT Y1_good_step5)
 Y1_comb_step6 = SIZE Y1_comb_step5 BY 0.040 INSIDE OF Y1_wide_chk_6 STEP 0.02 // step6: 0.040
 Y1_good_step6_a = Y1_comb_step6 INTERACT V3N >= 9
 Y1_good_step6_b = Y1_comb_step6 INTERACT RV3 >= 5
 Y1_good_step6_c = Y1_comb_step6 INTERACT 2XV3N >= 3
 Y1_good_step6_d = (Y1_comb_step6 INTERACT 1XV3N >= 7) INTERACT RV3 >= 1
 Y1_good_step6_e = (Y1_comb_step6 INTERACT 1XV3N >= 6) INTERACT 2XV3N >= 1
 Y1_good_step6_f = (Y1_comb_step6 INTERACT 1XV3N >= 5) INTERACT RV3 >= 2
 Y1_good_step6_g = ((Y1_comb_step6 INTERACT 1XV3N >= 4) INTERACT 2XV3N >= 1) INTERACT RV3 >= 1
 Y1_good_step6_h = (Y1_comb_step6 INTERACT 1XV3N >= 3) INTERACT RV3 >= 3
 Y1_good_step6_i = (Y1_comb_step6 INTERACT 1XV3N >= 3) INTERACT 2XV3N >= 2
 Y1_good_step6_j = ((Y1_comb_step6 INTERACT 1XV3N >= 2) INTERACT 2XV3N >= 1) INTERACT RV3 >= 2
 // SETLAYER Y1_good_step6_k = (Y1_comb_step6 INTERACT 1XV3N >= 1) INTERACT RV3 >= 4
 Y1_good_step6_l = ((Y1_comb_step6 INTERACT 1XV3N >= 1) INTERACT 2XV3N >= 2) INTERACT RV3 >= 1
 Y1_good_step6_r = OR Y1_good_step6_a Y1_good_step6_b Y1_good_step6_c Y1_good_step6_d Y1_good_step6_e Y1_good_step6_f Y1_good_step6_g Y1_good_step6_h
 Y1_good_step6_s = OR Y1_good_step6_i Y1_good_step6_j Y1_good_step6_l
 Y1_good_step6 = OR Y1_good_step6_r Y1_good_step6_s
 // 
 Y1_wide_chk_7 = Y1_wide_chk_6 INTERACT (WIDE_all_raw NOT INTERACT Y1_good_step6)
 Y1_comb_step7 = SIZE Y1_comb_step6 BY 0.011 INSIDE OF Y1_wide_chk_7 STEP 0.02 // step7: 0.272-0.061-0.04-0.040*4=0.011
 Y1_good_step7_a = Y1_comb_step7 INTERACT V3N >= 9
 Y1_good_step7_b = Y1_comb_step7 INTERACT RV3 >= 5
 Y1_good_step7_c = Y1_comb_step7 INTERACT 2XV3N >= 3
 Y1_good_step7_d = (Y1_comb_step7 INTERACT 1XV3N >= 7) INTERACT RV3 >= 1
 Y1_good_step7_e = (Y1_comb_step7 INTERACT 1XV3N >= 6) INTERACT 2XV3N >= 1
 Y1_good_step7_f = (Y1_comb_step7 INTERACT 1XV3N >= 5) INTERACT RV3 >= 2
 Y1_good_step7_g = ((Y1_comb_step7 INTERACT 1XV3N >= 4) INTERACT 2XV3N >= 1) INTERACT RV3 >= 1
 Y1_good_step7_h = (Y1_comb_step7 INTERACT 1XV3N >= 3) INTERACT RV3 >= 3
 Y1_good_step7_i = (Y1_comb_step7 INTERACT 1XV3N >= 3) INTERACT 2XV3N >= 2
 Y1_good_step7_j = ((Y1_comb_step7 INTERACT 1XV3N >= 2) INTERACT 2XV3N >= 1) INTERACT RV3 >= 2
 // SETLAYER Y1_good_step7_k = (Y1_comb_step7 INTERACT 1XV3N >= 1) INTERACT RV3 >= 4
 Y1_good_step7_l = ((Y1_comb_step7 INTERACT 1XV3N >= 1) INTERACT 2XV3N >= 2) INTERACT RV3 >= 1
 Y1_good_step7_r = OR Y1_good_step7_a Y1_good_step7_b Y1_good_step7_c Y1_good_step7_d Y1_good_step7_e Y1_good_step7_f Y1_good_step7_g Y1_good_step7_h
 Y1_good_step7_s = OR Y1_good_step7_i Y1_good_step7_j Y1_good_step7_l
 Y1_good_step7 = OR Y1_good_step7_r Y1_good_step7_s
 Y1_Y2_Y4_good = WIDE_all_raw AND (OR Y1_good_step1 Y1_good_step2 Y1_good_step3 Y1_good_step4 Y1_good_step5 Y1_good_step6 Y1_good_step7)
 // 
 err1 = (WIDE_all_raw OUTSIDE (OR Y1_Y2_Y4_good Y3_good)) INTERACT V3
 (err1 NOT INTERACT Vy3_BAR) NOT INSIDE OCCD_MARKS
}
 
Q: There should be at least two square Vy or one rectangular Vy in the intersection area of bottom metal and upper metal, when either wide metal Mxy or 1.25xMy length >= 0.162um and width >= 0.162um, the space between either via and wide metal <= 0.5um (S, S is the shortest running path length from Via to the wide metal). (except via bar)
A: 
RVy3_R_4_M3 {
@ There should be at least two square Vy or one rectangular Vy in the intersection area of bottom metal and upper metal, when either wide metal Mxy or 1.25xMy length >= 0.162um and width >= 0.162um, the space between either via and wide metal <= 0.5um (S, S is the shortest running path length from Via to the wide metal). (except via bar)
 // DRC flags each intersecting area ({bottom metal AND upper metal}) with single square Via within the branch check region
 wide_M3 = (WITH WIDTH M3 > 0.162-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 0.162-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 0.162-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M3_real = wide_M3 NOT OUTSIDE ((SIZE wide_M3 BY 0.5+GLOBAL_TOLERANCE) INTERACT V3)
 all_down_and_up = (M3 INTERACT wide_M3) AND M4
 dis_down_arm_wide_all = SIZE wide_M3_real BY 0.5+GLOBAL_TOLERANCE INSIDE OF M3 STEP 0.025
 dis_down_and_up = dis_down_arm_wide_all AND all_down_and_up
 dis_down_and_up_arm = (dis_down_and_up NOT wide_M3) AND M3
 dis_down_arm = (dis_down_arm_wide_all NOT wide_M3) AND M3
 // 
 dis_down_arm_good_a = dis_down_and_up_arm INTERACT 1XV3N >= 2
 dis_down_arm_good_b = dis_down_and_up_arm INTERACT RV3
 dis_down_arm_good_c = dis_down_and_up_arm INTERACT 2XV3N
 dis_down_arm_good = OR dis_down_arm_good_a dis_down_arm_good_b dis_down_arm_good_c
 dis_down_arm_bad = (dis_down_and_up_arm NOT dis_down_arm_good) INTERACT (all_down_and_up INTERACT 1XV3N == 1)
 // 
 dis_down_arm_err_stack = (dis_down_arm_bad AND dis_down_and_up_arm) INTERACT 1XV3N
 dis_down_arm_err = dis_down_arm INTERACT dis_down_arm_err_stack
 err1_met_down = (dis_down_arm_err INTERACT (1XV3N NOT OUTSIDE dis_down_arm_err)) NOT INTERACT (OR RV3 2XV3N)
 // 
 wide_M4 = (WITH WIDTH M4 > 0.162-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 0.162-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 0.162-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M4_real = wide_M4 NOT OUTSIDE ((SIZE wide_M4 BY 0.5+GLOBAL_TOLERANCE) INTERACT V3)
 all_up_and_down = (M4 INTERACT wide_M4) AND M3
 dis_up_arm_wide_all = SIZE wide_M4_real BY 0.5+GLOBAL_TOLERANCE INSIDE OF M4 STEP 0.025
 dis_up_and_down = dis_up_arm_wide_all AND all_up_and_down
 dis_up_and_down_arm = (dis_up_and_down NOT wide_M4) AND M4
 dis_up_arm = (dis_up_arm_wide_all NOT wide_M4) AND M4
 // 
 dis_up_arm_good_a = dis_up_and_down_arm INTERACT 1XV3N >= 2
 dis_up_arm_good_b = dis_up_and_down_arm INTERACT RV3
 dis_up_arm_good_c = dis_up_and_down_arm INTERACT 2XV3N
 dis_up_arm_good = OR dis_up_arm_good_a dis_up_arm_good_b dis_up_arm_good_c
 dis_up_arm_bad = (dis_up_and_down_arm NOT dis_up_arm_good) INTERACT (all_up_and_down INTERACT 1XV3N == 1)
 // 
 dis_up_arm_err_stack = (dis_up_arm_bad AND dis_up_and_down_arm) INTERACT 1XV3N
 dis_up_arm_err = dis_up_arm INTERACT dis_up_arm_err_stack
 err2_met_up = (dis_up_arm_err INTERACT (1XV3N NOT OUTSIDE dis_up_arm_err)) NOT INTERACT (OR RV3 2XV3N)
 err1_met_down NOT INTERACT Vy3_BAR
}
 
Q: There should be at least two square Vy or one rectangular Vy in the intersection area of bottom metal and upper metal, when either wide metal Mxy or 1.25xMy length >= 0.162um and width >= 0.162um, the space between either via and wide metal <= 0.5um (S, S is the shortest running path length from Via to the wide metal). (except via bar)
A: 
RVy3_R_4_M4 {
@ There should be at least two square Vy or one rectangular Vy in the intersection area of bottom metal and upper metal, when either wide metal Mxy or 1.25xMy length >= 0.162um and width >= 0.162um, the space between either via and wide metal <= 0.5um (S, S is the shortest running path length from Via to the wide metal). (except via bar)
 // DRC flags each intersecting area ({bottom metal AND upper metal}) with single square Via within the branch check region
 wide_M3 = (WITH WIDTH M3 > 0.162-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 0.162-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 0.162-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M3_real = wide_M3 NOT OUTSIDE ((SIZE wide_M3 BY 0.5+GLOBAL_TOLERANCE) INTERACT V3)
 all_down_and_up = (M3 INTERACT wide_M3) AND M4
 dis_down_arm_wide_all = SIZE wide_M3_real BY 0.5+GLOBAL_TOLERANCE INSIDE OF M3 STEP 0.025
 dis_down_and_up = dis_down_arm_wide_all AND all_down_and_up
 dis_down_and_up_arm = (dis_down_and_up NOT wide_M3) AND M3
 dis_down_arm = (dis_down_arm_wide_all NOT wide_M3) AND M3
 // 
 dis_down_arm_good_a = dis_down_and_up_arm INTERACT 1XV3N >= 2
 dis_down_arm_good_b = dis_down_and_up_arm INTERACT RV3
 dis_down_arm_good_c = dis_down_and_up_arm INTERACT 2XV3N
 dis_down_arm_good = OR dis_down_arm_good_a dis_down_arm_good_b dis_down_arm_good_c
 dis_down_arm_bad = (dis_down_and_up_arm NOT dis_down_arm_good) INTERACT (all_down_and_up INTERACT 1XV3N == 1)
 // 
 dis_down_arm_err_stack = (dis_down_arm_bad AND dis_down_and_up_arm) INTERACT 1XV3N
 dis_down_arm_err = dis_down_arm INTERACT dis_down_arm_err_stack
 err1_met_down = (dis_down_arm_err INTERACT (1XV3N NOT OUTSIDE dis_down_arm_err)) NOT INTERACT (OR RV3 2XV3N)
 // 
 wide_M4 = (WITH WIDTH M4 > 0.162-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 0.162-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 0.162-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M4_real = wide_M4 NOT OUTSIDE ((SIZE wide_M4 BY 0.5+GLOBAL_TOLERANCE) INTERACT V3)
 all_up_and_down = (M4 INTERACT wide_M4) AND M3
 dis_up_arm_wide_all = SIZE wide_M4_real BY 0.5+GLOBAL_TOLERANCE INSIDE OF M4 STEP 0.025
 dis_up_and_down = dis_up_arm_wide_all AND all_up_and_down
 dis_up_and_down_arm = (dis_up_and_down NOT wide_M4) AND M4
 dis_up_arm = (dis_up_arm_wide_all NOT wide_M4) AND M4
 // 
 dis_up_arm_good_a = dis_up_and_down_arm INTERACT 1XV3N >= 2
 dis_up_arm_good_b = dis_up_and_down_arm INTERACT RV3
 dis_up_arm_good_c = dis_up_and_down_arm INTERACT 2XV3N
 dis_up_arm_good = OR dis_up_arm_good_a dis_up_arm_good_b dis_up_arm_good_c
 dis_up_arm_bad = (dis_up_and_down_arm NOT dis_up_arm_good) INTERACT (all_up_and_down INTERACT 1XV3N == 1)
 // 
 dis_up_arm_err_stack = (dis_up_arm_bad AND dis_up_and_down_arm) INTERACT 1XV3N
 dis_up_arm_err = dis_up_arm INTERACT dis_up_arm_err_stack
 err2_met_up = (dis_up_arm_err INTERACT (1XV3N NOT OUTSIDE dis_up_arm_err)) NOT INTERACT (OR RV3 2XV3N)
 err2_met_up NOT INTERACT Vy3_BAR
}
 
Q: There should be at least two square Vy or one rectangular Vy in the intersection area of bottom metal and upper metal, when either wide metal Mxy or 1.25xMy length >= 0.272um and width >= 0.272um, the space between either via and wide metal <= 1um (S, S is the shortest running path length from Via to the wide metal). (except via bar)
A: 
RVy3_R_5_M3 {
@ There should be at least two square Vy or one rectangular Vy in the intersection area of bottom metal and upper metal, when either wide metal Mxy or 1.25xMy length >= 0.272um and width >= 0.272um, the space between either via and wide metal <= 1um (S, S is the shortest running path length from Via to the wide metal). (except via bar)
 // DRC flags each intersecting area ({bottom metal AND upper metal}) with single square Via within the branch check region
 wide_M3 = (WITH WIDTH M3 > 0.272-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 0.272-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 0.272-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M3_real = wide_M3 NOT OUTSIDE ((SIZE wide_M3 BY 1+GLOBAL_TOLERANCE) INTERACT V3)
 all_down_and_up = (M3 INTERACT wide_M3) AND M4
 dis_down_arm_wide_all = SIZE wide_M3_real BY 1+GLOBAL_TOLERANCE INSIDE OF M3 STEP 0.025
 dis_down_and_up = dis_down_arm_wide_all AND all_down_and_up
 dis_down_and_up_arm = (dis_down_and_up NOT wide_M3) AND M3
 dis_down_arm = (dis_down_arm_wide_all NOT wide_M3) AND M3
 // 
 dis_down_arm_good_a = dis_down_and_up_arm INTERACT 1XV3N >= 2
 dis_down_arm_good_b = dis_down_and_up_arm INTERACT RV3
 dis_down_arm_good_c = dis_down_and_up_arm INTERACT 2XV3N
 dis_down_arm_good = OR dis_down_arm_good_a dis_down_arm_good_b dis_down_arm_good_c
 dis_down_arm_bad = (dis_down_and_up_arm NOT dis_down_arm_good) INTERACT (all_down_and_up INTERACT 1XV3N == 1)
 // 
 dis_down_arm_err_stack = (dis_down_arm_bad AND dis_down_and_up_arm) INTERACT 1XV3N
 dis_down_arm_err = dis_down_arm INTERACT dis_down_arm_err_stack
 err1_met_down = (dis_down_arm_err INTERACT (1XV3N NOT OUTSIDE dis_down_arm_err)) NOT INTERACT (OR RV3 2XV3N)
 // 
 wide_M4 = (WITH WIDTH M4 > 0.272-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 0.272-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 0.272-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M4_real = wide_M4 NOT OUTSIDE ((SIZE wide_M4 BY 1+GLOBAL_TOLERANCE) INTERACT V3)
 all_up_and_down = (M4 INTERACT wide_M4) AND M3
 dis_up_arm_wide_all = SIZE wide_M4_real BY 1+GLOBAL_TOLERANCE INSIDE OF M4 STEP 0.025
 dis_up_and_down = dis_up_arm_wide_all AND all_up_and_down
 dis_up_and_down_arm = (dis_up_and_down NOT wide_M4) AND M4
 dis_up_arm = (dis_up_arm_wide_all NOT wide_M4) AND M4
 // 
 dis_up_arm_good_a = dis_up_and_down_arm INTERACT 1XV3N >= 2
 dis_up_arm_good_b = dis_up_and_down_arm INTERACT RV3
 dis_up_arm_good_c = dis_up_and_down_arm INTERACT 2XV3N
 dis_up_arm_good = OR dis_up_arm_good_a dis_up_arm_good_b dis_up_arm_good_c
 dis_up_arm_bad = (dis_up_and_down_arm NOT dis_up_arm_good) INTERACT (all_up_and_down INTERACT 1XV3N == 1)
 // 
 dis_up_arm_err_stack = (dis_up_arm_bad AND dis_up_and_down_arm) INTERACT 1XV3N
 dis_up_arm_err = dis_up_arm INTERACT dis_up_arm_err_stack
 err2_met_up = (dis_up_arm_err INTERACT (1XV3N NOT OUTSIDE dis_up_arm_err)) NOT INTERACT (OR RV3 2XV3N)
 err1_met_down NOT INTERACT Vy3_BAR
}
 
Q: There should be at least two square Vy or one rectangular Vy in the intersection area of bottom metal and upper metal, when either wide metal Mxy or 1.25xMy length >= 0.272um and width >= 0.272um, the space between either via and wide metal <= 1um (S, S is the shortest running path length from Via to the wide metal). (except via bar)
A: 
RVy3_R_5_M4 {
@ There should be at least two square Vy or one rectangular Vy in the intersection area of bottom metal and upper metal, when either wide metal Mxy or 1.25xMy length >= 0.272um and width >= 0.272um, the space between either via and wide metal <= 1um (S, S is the shortest running path length from Via to the wide metal). (except via bar)
 // DRC flags each intersecting area ({bottom metal AND upper metal}) with single square Via within the branch check region
 wide_M3 = (WITH WIDTH M3 > 0.272-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 0.272-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 0.272-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M3_real = wide_M3 NOT OUTSIDE ((SIZE wide_M3 BY 1+GLOBAL_TOLERANCE) INTERACT V3)
 all_down_and_up = (M3 INTERACT wide_M3) AND M4
 dis_down_arm_wide_all = SIZE wide_M3_real BY 1+GLOBAL_TOLERANCE INSIDE OF M3 STEP 0.025
 dis_down_and_up = dis_down_arm_wide_all AND all_down_and_up
 dis_down_and_up_arm = (dis_down_and_up NOT wide_M3) AND M3
 dis_down_arm = (dis_down_arm_wide_all NOT wide_M3) AND M3
 // 
 dis_down_arm_good_a = dis_down_and_up_arm INTERACT 1XV3N >= 2
 dis_down_arm_good_b = dis_down_and_up_arm INTERACT RV3
 dis_down_arm_good_c = dis_down_and_up_arm INTERACT 2XV3N
 dis_down_arm_good = OR dis_down_arm_good_a dis_down_arm_good_b dis_down_arm_good_c
 dis_down_arm_bad = (dis_down_and_up_arm NOT dis_down_arm_good) INTERACT (all_down_and_up INTERACT 1XV3N == 1)
 // 
 dis_down_arm_err_stack = (dis_down_arm_bad AND dis_down_and_up_arm) INTERACT 1XV3N
 dis_down_arm_err = dis_down_arm INTERACT dis_down_arm_err_stack
 err1_met_down = (dis_down_arm_err INTERACT (1XV3N NOT OUTSIDE dis_down_arm_err)) NOT INTERACT (OR RV3 2XV3N)
 // 
 wide_M4 = (WITH WIDTH M4 > 0.272-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 0.272-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 0.272-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M4_real = wide_M4 NOT OUTSIDE ((SIZE wide_M4 BY 1+GLOBAL_TOLERANCE) INTERACT V3)
 all_up_and_down = (M4 INTERACT wide_M4) AND M3
 dis_up_arm_wide_all = SIZE wide_M4_real BY 1+GLOBAL_TOLERANCE INSIDE OF M4 STEP 0.025
 dis_up_and_down = dis_up_arm_wide_all AND all_up_and_down
 dis_up_and_down_arm = (dis_up_and_down NOT wide_M4) AND M4
 dis_up_arm = (dis_up_arm_wide_all NOT wide_M4) AND M4
 // 
 dis_up_arm_good_a = dis_up_and_down_arm INTERACT 1XV3N >= 2
 dis_up_arm_good_b = dis_up_and_down_arm INTERACT RV3
 dis_up_arm_good_c = dis_up_and_down_arm INTERACT 2XV3N
 dis_up_arm_good = OR dis_up_arm_good_a dis_up_arm_good_b dis_up_arm_good_c
 dis_up_arm_bad = (dis_up_and_down_arm NOT dis_up_arm_good) INTERACT (all_up_and_down INTERACT 1XV3N == 1)
 // 
 dis_up_arm_err_stack = (dis_up_arm_bad AND dis_up_and_down_arm) INTERACT 1XV3N
 dis_up_arm_err = dis_up_arm INTERACT dis_up_arm_err_stack
 err2_met_up = (dis_up_arm_err INTERACT (1XV3N NOT OUTSIDE dis_up_arm_err)) NOT INTERACT (OR RV3 2XV3N)
 err2_met_up NOT INTERACT Vy3_BAR
}
 
Q: There should be at least two square Vy or one rectangular Vy in the intersection area of bottom metal and upper metal, when either wide metal Mxy or 1.25xMy width and length >= 0.542um, the space between either via and wide metal <= 3um (S, S is the shortest running path length from Via to the wide metal). (except via bar)
A: 
RVy3_R_6_M3 {
@ There should be at least two square Vy or one rectangular Vy in the intersection area of bottom metal and upper metal, when either wide metal Mxy or 1.25xMy width and length >= 0.542um, the space between either via and wide metal <= 3um (S, S is the shortest running path length from Via to the wide metal). (except via bar)
 // DRC flags each intersecting area ({bottom metal AND upper metal}) with single square Via within the branch check region
 wide_M3 = (WITH WIDTH M3 > 0.542-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 0.542-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 0.542-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M3_real = wide_M3 NOT OUTSIDE ((SIZE wide_M3 BY 3+GLOBAL_TOLERANCE) INTERACT V3)
 all_down_and_up = (M3 INTERACT wide_M3) AND M4
 dis_down_arm_wide_all = SIZE wide_M3_real BY 3+GLOBAL_TOLERANCE INSIDE OF M3 STEP 0.025
 dis_down_and_up = dis_down_arm_wide_all AND all_down_and_up
 dis_down_and_up_arm = (dis_down_and_up NOT wide_M3) AND M3
 dis_down_arm = (dis_down_arm_wide_all NOT wide_M3) AND M3
 // 
 dis_down_arm_good_a = dis_down_and_up_arm INTERACT 1XV3N >= 2
 dis_down_arm_good_b = dis_down_and_up_arm INTERACT RV3
 dis_down_arm_good_c = dis_down_and_up_arm INTERACT 2XV3N
 dis_down_arm_good = OR dis_down_arm_good_a dis_down_arm_good_b dis_down_arm_good_c
 dis_down_arm_bad = (dis_down_and_up_arm NOT dis_down_arm_good) INTERACT (all_down_and_up INTERACT 1XV3N == 1)
 // 
 dis_down_arm_err_stack = (dis_down_arm_bad AND dis_down_and_up_arm) INTERACT 1XV3N
 dis_down_arm_err = dis_down_arm INTERACT dis_down_arm_err_stack
 err1_met_down = (dis_down_arm_err INTERACT (1XV3N NOT OUTSIDE dis_down_arm_err)) NOT INTERACT (OR RV3 2XV3N)
 // 
 wide_M4 = (WITH WIDTH M4 > 0.542-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 0.542-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 0.542-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M4_real = wide_M4 NOT OUTSIDE ((SIZE wide_M4 BY 3+GLOBAL_TOLERANCE) INTERACT V3)
 all_up_and_down = (M4 INTERACT wide_M4) AND M3
 dis_up_arm_wide_all = SIZE wide_M4_real BY 3+GLOBAL_TOLERANCE INSIDE OF M4 STEP 0.025
 dis_up_and_down = dis_up_arm_wide_all AND all_up_and_down
 dis_up_and_down_arm = (dis_up_and_down NOT wide_M4) AND M4
 dis_up_arm = (dis_up_arm_wide_all NOT wide_M4) AND M4
 // 
 dis_up_arm_good_a = dis_up_and_down_arm INTERACT 1XV3N >= 2
 dis_up_arm_good_b = dis_up_and_down_arm INTERACT RV3
 dis_up_arm_good_c = dis_up_and_down_arm INTERACT 2XV3N
 dis_up_arm_good = OR dis_up_arm_good_a dis_up_arm_good_b dis_up_arm_good_c
 dis_up_arm_bad = (dis_up_and_down_arm NOT dis_up_arm_good) INTERACT (all_up_and_down INTERACT 1XV3N == 1)
 // 
 dis_up_arm_err_stack = (dis_up_arm_bad AND dis_up_and_down_arm) INTERACT 1XV3N
 dis_up_arm_err = dis_up_arm INTERACT dis_up_arm_err_stack
 err2_met_up = (dis_up_arm_err INTERACT (1XV3N NOT OUTSIDE dis_up_arm_err)) NOT INTERACT (OR RV3 2XV3N)
 err1_met_down NOT INTERACT Vy3_BAR
}
 
Q: There should be at least two square Vy or one rectangular Vy in the intersection area of bottom metal and upper metal, when either wide metal Mxy or 1.25xMy width and length >= 0.542um, the space between either via and wide metal <= 3um (S, S is the shortest running path length from Via to the wide metal). (except via bar)
A: 
RVy3_R_6_M4 {
@ There should be at least two square Vy or one rectangular Vy in the intersection area of bottom metal and upper metal, when either wide metal Mxy or 1.25xMy width and length >= 0.542um, the space between either via and wide metal <= 3um (S, S is the shortest running path length from Via to the wide metal). (except via bar)
 // DRC flags each intersecting area ({bottom metal AND upper metal}) with single square Via within the branch check region
 wide_M3 = (WITH WIDTH M3 > 0.542-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 0.542-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 0.542-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M3_real = wide_M3 NOT OUTSIDE ((SIZE wide_M3 BY 3+GLOBAL_TOLERANCE) INTERACT V3)
 all_down_and_up = (M3 INTERACT wide_M3) AND M4
 dis_down_arm_wide_all = SIZE wide_M3_real BY 3+GLOBAL_TOLERANCE INSIDE OF M3 STEP 0.025
 dis_down_and_up = dis_down_arm_wide_all AND all_down_and_up
 dis_down_and_up_arm = (dis_down_and_up NOT wide_M3) AND M3
 dis_down_arm = (dis_down_arm_wide_all NOT wide_M3) AND M3
 // 
 dis_down_arm_good_a = dis_down_and_up_arm INTERACT 1XV3N >= 2
 dis_down_arm_good_b = dis_down_and_up_arm INTERACT RV3
 dis_down_arm_good_c = dis_down_and_up_arm INTERACT 2XV3N
 dis_down_arm_good = OR dis_down_arm_good_a dis_down_arm_good_b dis_down_arm_good_c
 dis_down_arm_bad = (dis_down_and_up_arm NOT dis_down_arm_good) INTERACT (all_down_and_up INTERACT 1XV3N == 1)
 // 
 dis_down_arm_err_stack = (dis_down_arm_bad AND dis_down_and_up_arm) INTERACT 1XV3N
 dis_down_arm_err = dis_down_arm INTERACT dis_down_arm_err_stack
 err1_met_down = (dis_down_arm_err INTERACT (1XV3N NOT OUTSIDE dis_down_arm_err)) NOT INTERACT (OR RV3 2XV3N)
 // 
 wide_M4 = (WITH WIDTH M4 > 0.542-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 0.542-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 0.542-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M4_real = wide_M4 NOT OUTSIDE ((SIZE wide_M4 BY 3+GLOBAL_TOLERANCE) INTERACT V3)
 all_up_and_down = (M4 INTERACT wide_M4) AND M3
 dis_up_arm_wide_all = SIZE wide_M4_real BY 3+GLOBAL_TOLERANCE INSIDE OF M4 STEP 0.025
 dis_up_and_down = dis_up_arm_wide_all AND all_up_and_down
 dis_up_and_down_arm = (dis_up_and_down NOT wide_M4) AND M4
 dis_up_arm = (dis_up_arm_wide_all NOT wide_M4) AND M4
 // 
 dis_up_arm_good_a = dis_up_and_down_arm INTERACT 1XV3N >= 2
 dis_up_arm_good_b = dis_up_and_down_arm INTERACT RV3
 dis_up_arm_good_c = dis_up_and_down_arm INTERACT 2XV3N
 dis_up_arm_good = OR dis_up_arm_good_a dis_up_arm_good_b dis_up_arm_good_c
 dis_up_arm_bad = (dis_up_and_down_arm NOT dis_up_arm_good) INTERACT (all_up_and_down INTERACT 1XV3N == 1)
 // 
 dis_up_arm_err_stack = (dis_up_arm_bad AND dis_up_and_down_arm) INTERACT 1XV3N
 dis_up_arm_err = dis_up_arm INTERACT dis_up_arm_err_stack
 err2_met_up = (dis_up_arm_err INTERACT (1XV3N NOT OUTSIDE dis_up_arm_err)) NOT INTERACT (OR RV3 2XV3N)
 err2_met_up NOT INTERACT Vy3_BAR
}
 
Q: There should be at least two square Vy or one rectangular Vy in the intersection area of bottom metal and upper metal, when either wide metal Mxy or 1.25xMy width and length >= 1.01um, the space between either via and wide metal <= 5um (S, S is the shortest running path length from Via to the wide metal). (except via bar)
A: 
RVy3_R_7_M3 {
@ There should be at least two square Vy or one rectangular Vy in the intersection area of bottom metal and upper metal, when either wide metal Mxy or 1.25xMy width and length >= 1.01um, the space between either via and wide metal <= 5um (S, S is the shortest running path length from Via to the wide metal). (except via bar)
 // DRC flags each intersecting area ({bottom metal AND upper metal}) with single square Via within the branch check region
 wide_M3 = (WITH WIDTH M3 > 1.01-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 1.01-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 1.01-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M3_real = wide_M3 NOT OUTSIDE ((SIZE wide_M3 BY 5+GLOBAL_TOLERANCE) INTERACT V3)
 all_down_and_up = (M3 INTERACT wide_M3) AND M4
 dis_down_arm_wide_all = SIZE wide_M3_real BY 5+GLOBAL_TOLERANCE INSIDE OF M3 STEP 0.025
 dis_down_and_up = dis_down_arm_wide_all AND all_down_and_up
 dis_down_and_up_arm = (dis_down_and_up NOT wide_M3) AND M3
 dis_down_arm = (dis_down_arm_wide_all NOT wide_M3) AND M3
 // 
 dis_down_arm_good_a = dis_down_and_up_arm INTERACT 1XV3N >= 2
 dis_down_arm_good_b = dis_down_and_up_arm INTERACT RV3
 dis_down_arm_good_c = dis_down_and_up_arm INTERACT 2XV3N
 dis_down_arm_good = OR dis_down_arm_good_a dis_down_arm_good_b dis_down_arm_good_c
 dis_down_arm_bad = (dis_down_and_up_arm NOT dis_down_arm_good) INTERACT (all_down_and_up INTERACT 1XV3N == 1)
 // 
 dis_down_arm_err_stack = (dis_down_arm_bad AND dis_down_and_up_arm) INTERACT 1XV3N
 dis_down_arm_err = dis_down_arm INTERACT dis_down_arm_err_stack
 err1_met_down = (dis_down_arm_err INTERACT (1XV3N NOT OUTSIDE dis_down_arm_err)) NOT INTERACT (OR RV3 2XV3N)
 // 
 wide_M4 = (WITH WIDTH M4 > 1.01-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 1.01-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 1.01-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M4_real = wide_M4 NOT OUTSIDE ((SIZE wide_M4 BY 5+GLOBAL_TOLERANCE) INTERACT V3)
 all_up_and_down = (M4 INTERACT wide_M4) AND M3
 dis_up_arm_wide_all = SIZE wide_M4_real BY 5+GLOBAL_TOLERANCE INSIDE OF M4 STEP 0.025
 dis_up_and_down = dis_up_arm_wide_all AND all_up_and_down
 dis_up_and_down_arm = (dis_up_and_down NOT wide_M4) AND M4
 dis_up_arm = (dis_up_arm_wide_all NOT wide_M4) AND M4
 // 
 dis_up_arm_good_a = dis_up_and_down_arm INTERACT 1XV3N >= 2
 dis_up_arm_good_b = dis_up_and_down_arm INTERACT RV3
 dis_up_arm_good_c = dis_up_and_down_arm INTERACT 2XV3N
 dis_up_arm_good = OR dis_up_arm_good_a dis_up_arm_good_b dis_up_arm_good_c
 dis_up_arm_bad = (dis_up_and_down_arm NOT dis_up_arm_good) INTERACT (all_up_and_down INTERACT 1XV3N == 1)
 // 
 dis_up_arm_err_stack = (dis_up_arm_bad AND dis_up_and_down_arm) INTERACT 1XV3N
 dis_up_arm_err = dis_up_arm INTERACT dis_up_arm_err_stack
 err2_met_up = (dis_up_arm_err INTERACT (1XV3N NOT OUTSIDE dis_up_arm_err)) NOT INTERACT (OR RV3 2XV3N)
 err1_met_down NOT INTERACT Vy3_BAR
}
 
Q: There should be at least two square Vy or one rectangular Vy in the intersection area of bottom metal and upper metal, when either wide metal Mxy or 1.25xMy width and length >= 1.01um, the space between either via and wide metal <= 5um (S, S is the shortest running path length from Via to the wide metal). (except via bar)
A: 
RVy3_R_7_M4 {
@ There should be at least two square Vy or one rectangular Vy in the intersection area of bottom metal and upper metal, when either wide metal Mxy or 1.25xMy width and length >= 1.01um, the space between either via and wide metal <= 5um (S, S is the shortest running path length from Via to the wide metal). (except via bar)
 // DRC flags each intersecting area ({bottom metal AND upper metal}) with single square Via within the branch check region
 wide_M3 = (WITH WIDTH M3 > 1.01-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 1.01-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 1.01-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M3_real = wide_M3 NOT OUTSIDE ((SIZE wide_M3 BY 5+GLOBAL_TOLERANCE) INTERACT V3)
 all_down_and_up = (M3 INTERACT wide_M3) AND M4
 dis_down_arm_wide_all = SIZE wide_M3_real BY 5+GLOBAL_TOLERANCE INSIDE OF M3 STEP 0.025
 dis_down_and_up = dis_down_arm_wide_all AND all_down_and_up
 dis_down_and_up_arm = (dis_down_and_up NOT wide_M3) AND M3
 dis_down_arm = (dis_down_arm_wide_all NOT wide_M3) AND M3
 // 
 dis_down_arm_good_a = dis_down_and_up_arm INTERACT 1XV3N >= 2
 dis_down_arm_good_b = dis_down_and_up_arm INTERACT RV3
 dis_down_arm_good_c = dis_down_and_up_arm INTERACT 2XV3N
 dis_down_arm_good = OR dis_down_arm_good_a dis_down_arm_good_b dis_down_arm_good_c
 dis_down_arm_bad = (dis_down_and_up_arm NOT dis_down_arm_good) INTERACT (all_down_and_up INTERACT 1XV3N == 1)
 // 
 dis_down_arm_err_stack = (dis_down_arm_bad AND dis_down_and_up_arm) INTERACT 1XV3N
 dis_down_arm_err = dis_down_arm INTERACT dis_down_arm_err_stack
 err1_met_down = (dis_down_arm_err INTERACT (1XV3N NOT OUTSIDE dis_down_arm_err)) NOT INTERACT (OR RV3 2XV3N)
 // 
 wide_M4 = (WITH WIDTH M4 > 1.01-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 1.01-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 1.01-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M4_real = wide_M4 NOT OUTSIDE ((SIZE wide_M4 BY 5+GLOBAL_TOLERANCE) INTERACT V3)
 all_up_and_down = (M4 INTERACT wide_M4) AND M3
 dis_up_arm_wide_all = SIZE wide_M4_real BY 5+GLOBAL_TOLERANCE INSIDE OF M4 STEP 0.025
 dis_up_and_down = dis_up_arm_wide_all AND all_up_and_down
 dis_up_and_down_arm = (dis_up_and_down NOT wide_M4) AND M4
 dis_up_arm = (dis_up_arm_wide_all NOT wide_M4) AND M4
 // 
 dis_up_arm_good_a = dis_up_and_down_arm INTERACT 1XV3N >= 2
 dis_up_arm_good_b = dis_up_and_down_arm INTERACT RV3
 dis_up_arm_good_c = dis_up_and_down_arm INTERACT 2XV3N
 dis_up_arm_good = OR dis_up_arm_good_a dis_up_arm_good_b dis_up_arm_good_c
 dis_up_arm_bad = (dis_up_and_down_arm NOT dis_up_arm_good) INTERACT (all_up_and_down INTERACT 1XV3N == 1)
 // 
 dis_up_arm_err_stack = (dis_up_arm_bad AND dis_up_and_down_arm) INTERACT 1XV3N
 dis_up_arm_err = dis_up_arm INTERACT dis_up_arm_err_stack
 err2_met_up = (dis_up_arm_err INTERACT (1XV3N NOT OUTSIDE dis_up_arm_err)) NOT INTERACT (OR RV3 2XV3N)
 err2_met_up NOT INTERACT Vy3_BAR
}


//125xmy4

Q: It's not recommended to use dense 1.25xMy 3-bar pattern
    DRC flag conditions:
    (1) Middle 1.25xMy line width (W1) <= 0.044um, both two neighbour 1.25xMy line width <= 0.06um and interact square or rectangle Vy-1 or Vy
    (2) 1.25xMxy Space to both via (S1/S2) < 0.048um
    (3) The via PRL: -0.1 < PRL < 0.1um
    (4) Both neighbour 1.25xMxy enclosure Vy < 0.05um, or Both neighbour 1.25xMxy enclosure 1.25xVn < 0.065um
    This rule is not applied for INST region
A: 
125xmy4_R_12_V3_DFM1 {
@ It's not recommended to use dense 1.25xMy 3-bar pattern
@ DRC flag conditions:
@ (1) Middle 1.25xMy line width (W1) <= 0.044um, both two neighbour 1.25xMy line width <= 0.06um and interact square or rectangle Vy-1 or Vy
@ (2) 1.25xMxy Space to both via (S1/S2) < 0.048um
@ (3) The via PRL: -0.1 < PRL < 0.1um
@ (4) Both neighbour 1.25xMxy enclosure Vy < 0.05um, or Both neighbour 1.25xMxy enclosure 1.25xVn < 0.065um
@ This rule is not applied for INST region
 met_44_side = INT [M4] <= 0.044 ABUT<90 OPPOSITE
 met_60_side = INT [M4] <= 0.060 ABUT<90 OPPOSITE
 via_d_met = V3_SR NOT OUTSIDE (M4 WITH WIDTH <= 0.06)
 via_d_end = via_d_met TOUCH EDGE (ENC [via_d_met] 125xmy4_060_end < 0.050 ABUT<90 OPPOSITE)
 via_d_lin = (via_d_met NOT TOUCH EDGE via_d_end) TOUCH EDGE (ENC [via_d_met] met_60_side <= 0.028 ABUT<90 OPPOSITE)
 via_d_mid = (via_d_met WITH EDGE via_d_end) WITH EDGE via_d_lin >= 2
 via_d_sid = via_d_mid TOUCH EDGE via_d_lin
 via_d_sps = (EXT [met_44_side] via_d_sid < 0.048 OPPOSITE EXTENDED 0.1 MEASURE ALL) TOUCH EDGE (EXT [met_44_side] via_d_sid < 0.048 OPPOSITE MEASURE ALL)
 err1 = INT via_d_sps <= 0.044 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE INST
}
 
Q: It's not recommended to use dense 1.25xMy 3-bar pattern
    DRC flag conditions:
    (1) Middle 1.25xMy line width (W1) <= 0.044um, both two neighbour 1.25xMy line width <= 0.06um and interact square or rectangle Vy-1 or Vy
    (2) 1.25xMxy Space to both via (S1/S2) < 0.048um
    (3) The via PRL: -0.1 < PRL < 0.1um
    (4) Both neighbour 1.25xMxy enclosure Vy < 0.05um, or Both neighbour 1.25xMxy enclosure 1.25xVn < 0.065um
    This rule is not applied for INST region
A: 
125xmy4_R_12_V4_DFM1 {
@ It's not recommended to use dense 1.25xMy 3-bar pattern
@ DRC flag conditions:
@ (1) Middle 1.25xMy line width (W1) <= 0.044um, both two neighbour 1.25xMy line width <= 0.06um and interact square or rectangle Vy-1 or Vy
@ (2) 1.25xMxy Space to both via (S1/S2) < 0.048um
@ (3) The via PRL: -0.1 < PRL < 0.1um
@ (4) Both neighbour 1.25xMxy enclosure Vy < 0.05um, or Both neighbour 1.25xMxy enclosure 1.25xVn < 0.065um
@ This rule is not applied for INST region
 met_44_side = INT [M4] <= 0.044 ABUT<90 OPPOSITE
 met_60_side = INT [M4] <= 0.060 ABUT<90 OPPOSITE
 via_u_met = V4_SR NOT OUTSIDE (M4 WITH WIDTH <= 0.06)
 via_u_end = via_u_met TOUCH EDGE (ENC [via_u_met] 125xmy4_060_end < 0.065 ABUT<90 OPPOSITE)
 via_u_lin = (via_u_met NOT TOUCH EDGE via_u_end) TOUCH EDGE (ENC [via_u_met] met_60_side <= 0.028 ABUT<90 OPPOSITE)
 via_u_mid = (via_u_met WITH EDGE via_u_end) WITH EDGE via_u_lin >= 2
 via_u_sid = via_u_mid TOUCH EDGE via_u_lin
 via_u_sps = (EXT [met_44_side] via_u_sid < 0.048 OPPOSITE EXTENDED 0.1 MEASURE ALL) TOUCH EDGE (EXT [met_44_side] via_u_sid < 0.048 OPPOSITE MEASURE ALL)
 err1 = INT via_u_sps <= 0.044 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE INST
}


//125xm6


Q: 1.25xMn.R.9.DFM:
    It's not recommended to use dense 1.25xMn 3-bar pattern
    DRC flag conditions:
    (1) Middle line width(W1) is <= 0.044um, both two neighbour 1.25xMn line width <= 0.06um and interact square or rectangle Vy or 1.25xVn
    (2) 1.25xMn Space to both via (S1/S2)< 0.048um
    (3) The via PRL: -0.1 < PRL < 0.1um
    (4) Both neighbor 1.25xMn enclosure 1.25xVn or 1.25xVn-1 < 0.065um
    This rule is not applied for INST region
A: 
125xm6_R_9_V5_DFM1 {
@ 1.25xMn.R.9.DFM:
@ It's not recommended to use dense 1.25xMn 3-bar pattern
@ DRC flag conditions:
@ (1) Middle line width(W1) is <= 0.044um, both two neighbour 1.25xMn line width <= 0.06um and interact square or rectangle Vy or 1.25xVn
@ (2) 1.25xMn Space to both via (S1/S2)< 0.048um
@ (3) The via PRL: -0.1 < PRL < 0.1um
@ (4) Both neighbor 1.25xMn enclosure 1.25xVn or 1.25xVn-1 < 0.065um
@ This rule is not applied for INST region
 met_44_side = INT [M6] <= 0.044 ABUT<90 OPPOSITE
 met_60_side = INT [M6] <= 0.060 ABUT<90 OPPOSITE
 via_d_met = V5_SR NOT OUTSIDE (M6 WITH WIDTH <= 0.06)
 via_d_end = via_d_met TOUCH EDGE (ENC [via_d_met] 125xm6_060_end < 0.065 ABUT<90 OPPOSITE)
 via_d_lin = (via_d_met NOT TOUCH EDGE via_d_end) TOUCH EDGE (ENC [via_d_met] met_60_side <= 0.028 ABUT<90 OPPOSITE)
 via_d_mid = (via_d_met WITH EDGE via_d_end) WITH EDGE via_d_lin >= 2
 via_d_sid = via_d_mid TOUCH EDGE via_d_lin
 via_d_sps = (EXT [met_44_side] via_d_sid < 0.048 OPPOSITE EXTENDED 0.1 MEASURE ALL) TOUCH EDGE (EXT [met_44_side] via_d_sid < 0.048 OPPOSITE MEASURE ALL)
 err1 = INT via_d_sps <= 0.044 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE INST
}

Q:  1.25xMn.R.9.DFM:
    It's not recommended to use dense 1.25xMn 3-bar pattern
    DRC flag conditions:
    (1) Middle line width(W1) is <= 0.044um, both two neighbour 1.25xMn line width <= 0.06um and interact square or rectangle Vy or 1.25xVn
    (2) 1.25xMn Space to both via (S1/S2)< 0.048um
    (3) The via PRL: -0.1 < PRL < 0.1um
    (4) Both neighbor 1.25xMn enclosure 1.25xVn or 1.25xVn-1 < 0.065um
    This rule is not applied for INST region
A: 
125xm6_R_9_V6_DFM1 {
@ 1.25xMn.R.9.DFM:
@ It's not recommended to use dense 1.25xMn 3-bar pattern
@ DRC flag conditions:
@ (1) Middle line width(W1) is <= 0.044um, both two neighbour 1.25xMn line width <= 0.06um and interact square or rectangle Vy or 1.25xVn
@ (2) 1.25xMn Space to both via (S1/S2)< 0.048um
@ (3) The via PRL: -0.1 < PRL < 0.1um
@ (4) Both neighbor 1.25xMn enclosure 1.25xVn or 1.25xVn-1 < 0.065um
@ This rule is not applied for INST region
 met_44_side = INT [M6] <= 0.044 ABUT<90 OPPOSITE
 met_60_side = INT [M6] <= 0.060 ABUT<90 OPPOSITE
 via_u_met = V6_SR NOT OUTSIDE (M6 WITH WIDTH <= 0.06)
 via_u_end = via_u_met TOUCH EDGE (ENC [via_u_met] 125xm6_060_end < 0.065 ABUT<90 OPPOSITE)
 via_u_lin = (via_u_met NOT TOUCH EDGE via_u_end) TOUCH EDGE (ENC [via_u_met] met_60_side <= 0.028 ABUT<90 OPPOSITE)
 via_u_mid = (via_u_met WITH EDGE via_u_end) WITH EDGE via_u_lin >= 2
 via_u_sid = via_u_mid TOUCH EDGE via_u_lin
 via_u_sps = (EXT [met_44_side] via_u_sid < 0.048 OPPOSITE EXTENDED 0.1 MEASURE ALL) TOUCH EDGE (EXT [met_44_side] via_u_sid < 0.048 OPPOSITE MEASURE ALL)
 err1 = INT via_u_sps <= 0.044 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE INST
}


//125xm5

Q: 1.25xMn.R.9.DFM:
     It's not recommended to use dense 1.25xMn 3-bar pattern
     DRC flag conditions:
     (1) Middle line width(W1) is <= 0.044um, both two neighbour 1.25xMn line width <= 0.06um and interact square or rectangle Vy or 1.25xVn
     (2) 1.25xMn Space to both via (S1/S2)< 0.048um
     (3) The via PRL: -0.1 < PRL < 0.1um
     (4) Both neighbor 1.25xMn enclosure 1.25xVn or 1.25xVn-1 < 0.065um
     This rule is not applied for INST region
A: 
125xm5_R_9_V4_DFM1 {
@ 1.25xMn.R.9.DFM:
@ It's not recommended to use dense 1.25xMn 3-bar pattern
@ DRC flag conditions:
@ (1) Middle line width(W1) is <= 0.044um, both two neighbour 1.25xMn line width <= 0.06um and interact square or rectangle Vy or 1.25xVn
@ (2) 1.25xMn Space to both via (S1/S2)< 0.048um
@ (3) The via PRL: -0.1 < PRL < 0.1um
@ (4) Both neighbor 1.25xMn enclosure 1.25xVn or 1.25xVn-1 < 0.065um
@ This rule is not applied for INST region
 met_44_side = INT [M5] <= 0.044 ABUT<90 OPPOSITE
 met_60_side = INT [M5] <= 0.060 ABUT<90 OPPOSITE
 via_d_met = V4_SR NOT OUTSIDE (M5 WITH WIDTH <= 0.06)
 via_d_end = via_d_met TOUCH EDGE (ENC [via_d_met] 125xm5_060_end < 0.065 ABUT<90 OPPOSITE)
 via_d_lin = (via_d_met NOT TOUCH EDGE via_d_end) TOUCH EDGE (ENC [via_d_met] met_60_side <= 0.028 ABUT<90 OPPOSITE)
 via_d_mid = (via_d_met WITH EDGE via_d_end) WITH EDGE via_d_lin >= 2
 via_d_sid = via_d_mid TOUCH EDGE via_d_lin
 via_d_sps = (EXT [met_44_side] via_d_sid < 0.048 OPPOSITE EXTENDED 0.1 MEASURE ALL) TOUCH EDGE (EXT [met_44_side] via_d_sid < 0.048 OPPOSITE MEASURE ALL)
 err1 = INT via_d_sps <= 0.044 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE INST
}
 
Q: 1.25xMn.R.9.DFM:
    It's not recommended to use dense 1.25xMn 3-bar pattern
    DRC flag conditions:
    (1) Middle line width(W1) is <= 0.044um, both two neighbour 1.25xMn line width <= 0.06um and interact square or rectangle Vy or 1.25xVn
    (2) 1.25xMn Space to both via (S1/S2)< 0.048um
    (3) The via PRL: -0.1 < PRL < 0.1um
    (4) Both neighbor 1.25xMn enclosure 1.25xVn or 1.25xVn-1 < 0.065um
    This rule is not applied for INST region
A: 
125xm5_R_9_V5_DFM1 {
@ 1.25xMn.R.9.DFM:
@ It's not recommended to use dense 1.25xMn 3-bar pattern
@ DRC flag conditions:
@ (1) Middle line width(W1) is <= 0.044um, both two neighbour 1.25xMn line width <= 0.06um and interact square or rectangle Vy or 1.25xVn
@ (2) 1.25xMn Space to both via (S1/S2)< 0.048um
@ (3) The via PRL: -0.1 < PRL < 0.1um
@ (4) Both neighbor 1.25xMn enclosure 1.25xVn or 1.25xVn-1 < 0.065um
@ This rule is not applied for INST region
 met_44_side = INT [M5] <= 0.044 ABUT<90 OPPOSITE
 met_60_side = INT [M5] <= 0.060 ABUT<90 OPPOSITE
 via_u_met = V5_SR NOT OUTSIDE (M5 WITH WIDTH <= 0.06)
 via_u_end = via_u_met TOUCH EDGE (ENC [via_u_met] 125xm5_060_end < 0.065 ABUT<90 OPPOSITE)
 via_u_lin = (via_u_met NOT TOUCH EDGE via_u_end) TOUCH EDGE (ENC [via_u_met] met_60_side <= 0.028 ABUT<90 OPPOSITE)
 via_u_mid = (via_u_met WITH EDGE via_u_end) WITH EDGE via_u_lin >= 2
 via_u_sid = via_u_mid TOUCH EDGE via_u_lin
 via_u_sps = (EXT [met_44_side] via_u_sid < 0.048 OPPOSITE EXTENDED 0.1 MEASURE ALL) TOUCH EDGE (EXT [met_44_side] via_u_sid < 0.048 OPPOSITE MEASURE ALL)
 err1 = INT via_u_sps <= 0.044 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE INST
}

//125xm7

Q: 1.25xMn.R.9.DFM:
     It's not recommended to use dense 1.25xMn 3-bar pattern
     DRC flag conditions:
    (1) Middle line width(W1) is <= 0.044um, both two neighbour 1.25xMn line width <= 0.06um and interact square or rectangle Vy or 1.25xVn
    (2) 1.25xMn Space to both via (S1/S2)< 0.048um
    (3) The via PRL: -0.1 < PRL < 0.1um
    (4) Both neighbor 1.25xMn enclosure 1.25xVn or 1.25xVn-1 < 0.065um
A: 
125xm7_R_9_V6_DFM1 {
@ 1.25xMn.R.9.DFM:
@ It's not recommended to use dense 1.25xMn 3-bar pattern
@ DRC flag conditions:
@ (1) Middle line width(W1) is <= 0.044um, both two neighbour 1.25xMn line width <= 0.06um and interact square or rectangle Vy or 1.25xVn
@ (2) 1.25xMn Space to both via (S1/S2)< 0.048um
@ (3) The via PRL: -0.1 < PRL < 0.1um
@ (4) Both neighbor 1.25xMn enclosure 1.25xVn or 1.25xVn-1 < 0.065um
@ This rule is not applied for INST region
 met_44_side = INT [M7] <= 0.044 ABUT<90 OPPOSITE
 met_60_side = INT [M7] <= 0.060 ABUT<90 OPPOSITE
 via_d_met = V6_SR NOT OUTSIDE (M7 WITH WIDTH <= 0.06)
 via_d_end = via_d_met TOUCH EDGE (ENC [via_d_met] 125xm7_060_end < 0.065 ABUT<90 OPPOSITE)
 via_d_lin = (via_d_met NOT TOUCH EDGE via_d_end) TOUCH EDGE (ENC [via_d_met] met_60_side <= 0.028 ABUT<90 OPPOSITE)
 via_d_mid = (via_d_met WITH EDGE via_d_end) WITH EDGE via_d_lin >= 2
 via_d_sid = via_d_mid TOUCH EDGE via_d_lin
 via_d_sps = (EXT [met_44_side] via_d_sid < 0.048 OPPOSITE EXTENDED 0.1 MEASURE ALL) TOUCH EDGE (EXT [met_44_side] via_d_sid < 0.048 OPPOSITE MEASURE ALL)
 err1 = INT via_d_sps <= 0.044 ABUT<90 OPPOSITE REGION
 err1 NOT INSIDE INST
}


//125xv4

Q: 45-degree 1.25xVn is not allowed
A: 
125xv4_R_1 {
@ 45-degree 1.25xVn is not allowed
 err1 = ANGLE (V4 NOT 125xv4_BAR) > 44.5 < 45.5
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
Q: t is not allowed to have single 1.25xVn in "H-shape" 1.25xMn+1 when all of the following conditions come into existence:
    1) The 1.25xMn+1 has "H-shape" interact two metal holes: both two metal hole length <= 4.5um and two metal hole area <= 4.05um2
    2) The 1.25xVn overlaps on the center metal bar of this "H-shape" 1.25xMn+1
    3) The center metal bar length <= 0.9um and the metal bar width <= 0.162um
A: 
125xv4_R_2 {
@ It is not allowed to have single 1.25xVn in "H-shape" 1.25xMn+1 when all of the following conditions come into existence:
@ 1) The 1.25xMn+1 has "H-shape" interact two metal holes: both two metal hole length <= 4.5um and two metal hole area <= 4.05um2
@ 2) The 1.25xVn overlaps on the center metal bar of this "H-shape" 1.25xMn+1
@ 3) The center metal bar length <= 0.9um and the metal bar width <= 0.162um
 hole_area_meet = AREA (HOLES M5 INNER) <= 4.05
 hole_area_meet_len = (hole_area_meet WITH EDGE (LENGTH hole_area_meet <= 0.9)) NOT WITH EDGE (LENGTH hole_area_meet > 4.5)
 hole_area_real = (hole_area_meet_len NOT ENCLOSE RECTANGLE 0.9+GLOBAL_TOLERANCE 4.5) NOT ENCLOSE RECTANGLE 0.9 4.5+GLOBAL_TOLERANCE
 hole_bars_len = M5 COIN EDGE hole_area_real
 // 
 hole_bars = INT hole_bars_len <= 0.162 ABUT<90 OPPOSITE REGION EXCLUDE SHIELDED
 hole_bars_real = hole_bars WITH EDGE (LENGTH hole_bars_len <= 0.9)
 hole_bars_vias_sq = V4N INTERACT ((hole_bars_real INTERACT hole_area_real == 2) NOT ENCLOSE RV4)
 err1 = hole_bars_real INTERACT hole_bars_vias_sq == 1
 err1 NOT INSIDE SealR_NOT_BULK
}
 
Q: The numbers of neighboring square 1.25xVn to each edge of 1.25xVn <= 0.065um is not allowed < 2
A: 
125xv4_R_3 {
@ The numbers of neighboring square 1.25xVn to each edge of 1.25xVn <= 0.065um is not allowed < 2
 // based on 125xVn.S.6 and 125xVn.S.1, so only check the space range 0.056~0.065um with PRL <= 0.04
 Y1 = EXT V4N >= 0.056 <= 0.065 ABUT CORNER TO CORNER
 Y2 = DFM PROPERTY Y1 [-= (EWXP(Y1) > 0.040 && EWYP(Y1) > 0.040) ? 1 : 0] > 0
 Y3 = INT [V4N] < 0.001 ABUT INTERSECTING ONLY
 Y4 = Y3 COIN EDGE (DFM COPY Y2 EDGE)
 Y5 = INT Y4 V4N < 0.001 ABUT==90 INTERSECTING ONLY REGION
 Y6 = INT (V4N COIN EDGE Y5) == 0.040 OPPOSITE REGION
 err1 = V4N INTERACT Y6
 err1 NOT INSIDE SealR_NOT_BULK
}
 
Q: The numbers of neighboring square 1.25xVn in one group (space <= 0.065um) <= 3
A: 
125xv4_R_4 {
@ The numbers of neighboring square 1.25xVn in one group (space <= 0.065um) <= 3
 err1 = WITH NEIGHBOR V4N > 2 SPACE <= 0.065
 err1 NOT INSIDE SealR_NOT_BULK
}
 

Q: Maximum delta V >= 5.6V is not allowed, when space between 1.25xVn is < 0.410um
A: 
125xv4_R_5 {
@ Maximum delta V >= 5.6V is not allowed, when space between 1.25xVn is < 0.410um
 chk_VIA = V4 INTERACT DVK_V4_SQ
 err1 = DFM DV chk_VIA V4 < 0.410 DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" >= 5.6 ANNOTATE NOT CONNECTED SINGULAR
 DFM COPY err1
}


// 1.25xVn.R.8[NC] 1.25xVn pattern must be drawn on data type 50
 
Q: It's not allowed 1.25xVn overlap with the metal resistor directly underneath and above the 1.25xVn
A: 
125xv4_R_9 {
@ It's not allowed 1.25xVn overlap with the metal resistor directly underneath and above the 1.25xVn
 err1 = V4 AND (M4RES AND M4)
 err2 = V4 AND (M5RES AND M5)
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

 
Q: Recommend space between a square 1.25xVn and another (1.25xVn OR 1.25xRVn OR DUM_1.25xVn) < 4um to avoid single square 1.25xVn
A: 
125xv4_R_10_R {
@ Recommend space between a square 1.25xVn and another (1.25xVn OR 1.25xRVn OR DUM_1.25xVn) < 4um to avoid single square 1.25xVn
 ALL_VIA_CHECK = OR V4_SR V4DUM_all V4DOP_all
 STEP_1 = SIZE V4_SR BY 1.4
 // 4/1.414 = 2.828
 STEP_1_GOOD = STEP_1 INTERACT ALL_VIA_CHECK > 1
 STEP_1_FILTER = V4N NOT INTERACT STEP_1_GOOD
 err1 = STEP_1_FILTER NOT WITH EDGE (EXT [STEP_1_FILTER] ALL_VIA_CHECK < 4 PERP ALSO)
 err1 NOT INSIDE SealR_NOT_BULK
}


//125xRv4

Q: Single 1.25xRVn is not allowed in "H-shape" 1.25xMn+1, when:
    1. The 1.25xMn+1 has "H-shape" interacting with two metal holes: both two metal holes length <= 4.5um and two metal hole area <= 4.05um2
    2. The 1.25xRVn overlaps on the center metal bar of this "H-shape" 1.25xMn+1
    3. The center metal bar length <= 0.9um and the metal bar width <= 0.162um
    DRC doesn't check when one or more square 1.25xRVn is also on H-shape 1.25xMn+1 region
A: 
125xRv4_R_1 {
@ Single 1.25xRVn is not allowed in "H-shape" 1.25xMn+1, when:
@ 1. The 1.25xMn+1 has "H-shape" interacting with two metal holes: both two metal holes length <= 4.5um and two metal hole area <= 4.05um2
@ 2. The 1.25xRVn overlaps on the center metal bar of this "H-shape" 1.25xMn+1
@ 3. The center metal bar length <= 0.9um and the metal bar width <= 0.162um
@ DRC doesn't check when one or more square 1.25xRVn is also on H-shape 1.25xMn+1 region
 hole_area_meet = AREA (HOLES M5 INNER) <= 4.05
 hole_area_meet_len = (hole_area_meet WITH EDGE (LENGTH hole_area_meet <= 0.9)) NOT WITH EDGE (LENGTH hole_area_meet > 4.5)
 hole_area_real = (hole_area_meet_len NOT ENCLOSE RECTANGLE 0.9+GLOBAL_TOLERANCE 4.5) NOT ENCLOSE RECTANGLE 0.9 4.5+GLOBAL_TOLERANCE
 hole_bars_len = M5 COIN EDGE hole_area_real
 // 
 hole_bars = INT hole_bars_len <= 0.162 ABUT<90 OPPOSITE REGION EXCLUDE SHIELDED
 hole_bars_real = hole_bars WITH EDGE (LENGTH hole_bars_len <= 0.9)
 hole_bars_vias_rect = RV4 INTERACT ((hole_bars_real INTERACT hole_area_real == 2) NOT ENCLOSE V4N >= 2)
 err1 = hole_bars_real INTERACT hole_bars_vias_rect == 1
 err1 NOT INSIDE SealR_NOT_BULK
}
 
Q: Redundant via requirement must be obeyed by one of following conditions of via numbers and space for 1.25xMy/1.25xMn, 1.25xMn+1 connection (one of 1.25xMy/1.25xMn or 1.25xMn+1 have width and length >= 0.164um, two square vias are equal to one rectangular via for below conditions) (Except VIA bar)
    1) At least one rectangular 1.25xVn
    2) At least two square 1.25xVn with space <= 0.091um
    3) At least four square 1.25xVn with space <= 0.59um
A: 
125xRv4_R_2 {
@ Redundant via requirement must be obeyed by one of following conditions of via numbers and space for 1.25xMy/1.25xMn, 1.25xMn+1 connection (one of 1.25xMy/1.25xMn or 1.25xMn+1 have width and length >= 0.164um, two square vias are equal to one rectangular via for below conditions) (Except VIA bar)
@ 1) At least one rectangular 1.25xVn
@ 2) At least two square 1.25xVn with space <= 0.091um
@ 3) At least four square 1.25xVn with space <= 0.59um
 X1a = WITH WIDTH M4 > 0.164-GLOBAL_TOLERANCE <= 0.398-GLOBAL_TOLERANCE
 X1b = WITH WIDTH M5 > 0.164-GLOBAL_TOLERANCE <= 0.398-GLOBAL_TOLERANCE
 Y1a = WITH WIDTH M4 > 0.398-GLOBAL_TOLERANCE
 Y1b = WITH WIDTH M5 > 0.398-GLOBAL_TOLERANCE
 WIDE_1 = (X1a AND M5) ENCLOSE V4
 WIDE_2 = (M4 AND X1b) ENCLOSE V4
 WIDE_3 = (Y1a AND M5) ENCLOSE V4
 WIDE_4 = (M4 AND Y1b) ENCLOSE V4
 WIDE_all_raw = (WIDE_1 OR WIDE_2) NOT (WIDE_3 OR WIDE_4)
 WIDE_all = (M4 AND M5) NOT OUTSIDE WIDE_all_raw
 // 
 // condition 1
 Y1_good = WIDE_all_raw AND RV4
 // condition 2
 Y2_wide_all = WIDE_all_raw NOT INTERACT Y1_good
 Y2_wide = (WIDE_all INTERACT Y2_wide_all) INTERACT V4_SR >= 2
 Y2_comb_step = SIZE V4_SR BY 0.091/2 INSIDE OF Y2_wide STEP 0.030
 Y2_good_step = OR (Y2_comb_step INTERACT V4N >= 2) (Y2_comb_step INTERACT RV4)
 Y2_good = WIDE_all_raw AND Y2_good_step
 // 
 // condition 3
 Y3_wide_all = WIDE_all_raw NOT INTERACT (OR Y1_good Y2_good)
 Y3_wide = (WIDE_all INTERACT Y3_wide_all) INTERACT V4_SR >= 2 // rectangle array 0.59/2=0.295
 Y3_vias_input = V4_SR AND Y3_wide
 Y3_wide_chk_1 = Y3_wide INTERACT Y3_wide_all
 Y3_comb_step1 = SIZE Y3_vias_input BY 0.04 INSIDE OF Y3_wide_chk_1 STEP 0.04 // via minimum space = 0.075
 Y3_good_step1 = OR (Y3_comb_step1 INTERACT V4N >= 4) (Y3_comb_step1 INTERACT RV4) // step1: 0.050
 // 
 Y3_wide_chk_2 = Y3_wide_chk_1 INTERACT (WIDE_all_raw NOT INTERACT Y3_good_step1)
 Y3_comb_step2 = SIZE Y3_comb_step1 BY 0.04 INSIDE OF Y3_wide_chk_2 STEP 0.04
 Y3_good_step2 = OR (Y3_comb_step2 INTERACT V4N >= 4) (Y3_comb_step2 INTERACT RV4) // step2: 0.04
 // 
 Y3_wide_chk_3 = Y3_wide_chk_2 INTERACT (WIDE_all_raw NOT INTERACT Y3_good_step2)
 Y3_comb_step3 = SIZE Y3_comb_step2 BY 0.04 INSIDE OF Y3_wide_chk_3 STEP 0.04
 Y3_good_step3 = OR (Y3_comb_step3 INTERACT V4N >= 4) (Y3_comb_step3 INTERACT RV4) // step3: 0.04
 // 
 Y3_wide_chk_4 = Y3_wide_chk_3 INTERACT (WIDE_all_raw NOT INTERACT Y3_good_step3)
 Y3_comb_step4 = SIZE Y3_comb_step3 BY 0.04 INSIDE OF Y3_wide_chk_4 STEP 0.04
 Y3_good_step4 = OR (Y3_comb_step4 INTERACT V4N >= 4) (Y3_comb_step4 INTERACT RV4) // step4: 0.04
 // 
 Y3_wide_chk_5 = Y3_wide_chk_4 INTERACT (WIDE_all_raw NOT INTERACT Y3_good_step4)
 Y3_comb_step5 = SIZE Y3_comb_step4 BY 0.04 INSIDE OF Y3_wide_chk_5 STEP 0.04
 Y3_good_step5 = OR (Y3_comb_step5 INTERACT V4N >= 4) (Y3_comb_step5 INTERACT RV4) // step5: 0.04
 // 
 Y3_wide_chk_6 = Y3_wide_chk_5 INTERACT (WIDE_all_raw NOT INTERACT Y3_good_step5)
 Y3_comb_step6 = SIZE Y3_comb_step5 BY 0.04 INSIDE OF Y3_wide_chk_6 STEP 0.04
 Y3_good_step6 = OR (Y3_comb_step6 INTERACT V4N >= 4) (Y3_comb_step6 INTERACT RV4) // step6: 0.04
 // 
 Y3_wide_chk_7 = Y3_wide_chk_6 INTERACT (WIDE_all_raw NOT INTERACT Y3_good_step6)
 Y3_comb_step7 = SIZE Y3_comb_step6 BY 0.04 INSIDE OF Y3_wide_chk_7 STEP 0.04
 Y3_good_step7 = OR (Y3_comb_step7 INTERACT V4N >= 4) (Y3_comb_step7 INTERACT RV4) // step7: 0.04
 // 
 Y3_wide_chk_8 = Y3_wide_chk_7 INTERACT (WIDE_all_raw NOT INTERACT Y3_good_step7)
 Y3_comb_step8 = SIZE Y3_comb_step7 BY 0.015 INSIDE OF Y3_wide_chk_8 STEP 0.015
 Y3_good_step8 = OR (Y3_comb_step8 INTERACT V4N >= 4) (Y3_comb_step8 INTERACT RV4) // step8: 0.295-0.04*7=0.015
 Y3_good = WIDE_all_raw AND (OR Y3_good_step1 Y3_good_step2 Y3_good_step3 Y3_good_step4 Y3_good_step5 Y3_good_step6 Y3_good_step7 Y3_good_step8)
 // 
 err1 = (WIDE_all_raw OUTSIDE (OR Y1_good Y2_good Y3_good)) INTERACT V4
 err1 NOT INTERACT 125xv4_BAR
}
 
Q: Redundant via requirement must be obeyed by one of following conditions of 1.25xVn numbers and space for 1.25xMy/1.25xMn and 1.25xMn+1 connection (one of 1.25xMy/1.25xMn or 1.25xMn+1 have width and length >= 0.398um, two square vias are equal to one rectangular via for below conditions), except VIA bar, OCCD region
    1) At least 4 square 1.25xVn with space <= 0.091um
    2) At least 2 square 1.25xVn and 1 rectangular 1.25xVn with space <= 0.118um
    3) At least 9 square 1.25xVn with space <= 0.77um
    For condition 2) and 3) 2 square 1.25xVn can be replaced by 1 rectangular 1.25xVn
A: 
125xRv4_R_3 {
@ Redundant via requirement must be obeyed by one of following conditions of 1.25xVn numbers and space for 1.25xMy/1.25xMn and 1.25xMn+1 connection (one of 1.25xMy/1.25xMn or 1.25xMn+1 have width and length >= 0.398um, two square vias are equal to one rectangular via for below conditions), except VIA bar, OCCD region
@ 1) At least 4 square 1.25xVn with space <= 0.091um
@ 2) At least 2 square 1.25xVn and 1 rectangular 1.25xVn with space <= 0.118um
@ 3) At least 9 square 1.25xVn with space <= 0.77um
@ For condition 2) and 3) 2 square 1.25xVn can be replaced by 1 rectangular 1.25xVn
 X1a = WITH WIDTH M4 > 0.398-GLOBAL_TOLERANCE
 X1b = WITH WIDTH M5 > 0.398-GLOBAL_TOLERANCE
 WIDE_1 = (X1a AND M5) ENCLOSE V4
 WIDE_2 = (M4 AND X1b) ENCLOSE V4
 WIDE_all_raw = WIDE_1 OR WIDE_2
 WIDE_all = (M4 AND M5) NOT OUTSIDE WIDE_all_raw
 // 
 // condition 1
 Y2_wide = WIDE_all INTERACT V4N >= 4
 Y2_vias_input = V4N AND Y2_wide
 Y2_wide_chk_1 = COPY Y2_wide // rectangle array 0.09/2=0.0455
 Y2_comb_step1 = SIZE Y2_vias_input BY 0.030 INSIDE OF Y2_wide_chk_1 STEP 0.030 // step1: 0.030, via minimum space = 0.056
 Y2_good_step1 = Y2_comb_step1 INTERACT V4N >= 4
 // 
 Y2_wide_chk_2 = Y2_wide_chk_1 INTERACT (WIDE_all_raw NOT INTERACT Y2_good_step1)
 Y2_comb_step2 = SIZE Y2_comb_step1 BY 0.0155 INSIDE OF Y2_wide_chk_2 STEP 0.015 // step2: 0.0155
 Y2_good_step2 = Y2_comb_step2 INTERACT V4N >= 4
 Y2_good = WIDE_all_raw AND (OR Y2_good_step1 Y2_good_step2)
 // 
 // condition 2
 Y1_wide_all = WIDE_all_raw NOT INTERACT Y2_good // rectangle array 0.118/2=0.059
 Y1_wide = (WIDE_all INTERACT Y1_wide_all) INTERACT V4 >= 2
 Y1_vias_input = V4 AND Y1_wide
 Y1_wide_chk_1 = Y1_wide INTERACT Y1_wide_all
 Y1_comb_step1 = SIZE Y1_vias_input BY 0.030 INSIDE OF Y1_wide_chk_1 STEP 0.030 // step1: 0.030, via minimum space = 0.100
 Y1_good_step1_a = Y1_comb_step1 INTERACT RV4 >= 2
 Y1_good_step1_b = (Y1_comb_step1 INTERACT V4N >= 2) INTERACT RV4 >= 1
 Y1_good_step1 = OR Y1_good_step1_a Y1_good_step1_b
 // 
 Y1_wide_chk_2 = Y1_wide_chk_1 INTERACT (WIDE_all_raw NOT INTERACT Y1_good_step1)
 Y1_comb_step2 = SIZE Y1_comb_step1 BY 0.029 INSIDE OF Y1_wide_chk_2 STEP 0.025 // step2: 0.059-0.030=0.029
 Y1_good_step2_a = Y1_comb_step2 INTERACT RV4 >= 2
 Y1_good_step2_b = (Y1_comb_step2 INTERACT V4N >= 2) INTERACT RV4 >= 1
 Y1_good_step2 = OR Y1_good_step2_a Y1_good_step2_b
 Y1_good = WIDE_all_raw AND (OR Y1_good_step1 Y1_good_step2)
 // 
 // condition 3
 Y3_wide_all = WIDE_all_raw NOT INTERACT (OR Y2_good Y1_good)
 Y3_wide = (WIDE_all INTERACT Y3_wide_all) INTERACT V4 >= 5
 Y3_vias_input = V4N AND Y3_wide
 Y3_wide_chk_1 = Y3_wide INTERACT Y3_wide_all // rectangle array 0.77/2=0.385
 Y3_comb_step1 = SIZE Y3_vias_input BY 0.070 INSIDE OF Y3_wide_chk_1 STEP 0.035 // step1: 0.070, via minimum space = 0.056
 Y3_good_step1_a = Y3_comb_step1 INTERACT V4N >= 9
 Y3_good_step1_b = (Y3_comb_step1 INTERACT V4N >= 7) INTERACT RV4 >= 1
 Y3_good_step1_c = (Y3_comb_step1 INTERACT V4N >= 5) INTERACT RV4 >= 2
 Y3_good_step1_d = (Y3_comb_step1 INTERACT V4N >= 3) INTERACT RV4 >= 3
 Y3_good_step1_e = (Y3_comb_step1 INTERACT V4N >= 1) INTERACT RV4 >= 4
 Y3_good_step1_f = Y3_comb_step1 INTERACT RV4 >= 5
 Y3_good_step1 = OR Y3_good_step1_a Y3_good_step1_b Y3_good_step1_c Y3_good_step1_d Y3_good_step1_e Y3_good_step1_f
 // 
 Y3_wide_chk_2 = Y3_wide_chk_1 INTERACT (WIDE_all_raw NOT INTERACT Y3_good_step1)
 Y3_comb_step2 = SIZE Y3_comb_step1 BY 0.035 INSIDE OF Y3_wide_chk_2 STEP 0.035 // step2: 0.035
 Y3_good_step2_a = Y3_comb_step2 INTERACT V4N >= 9
 Y3_good_step2_b = (Y3_comb_step2 INTERACT V4N >= 7) INTERACT RV4 >= 1
 Y3_good_step2_c = (Y3_comb_step2 INTERACT V4N >= 5) INTERACT RV4 >= 2
 Y3_good_step2_d = (Y3_comb_step2 INTERACT V4N >= 3) INTERACT RV4 >= 3
 Y3_good_step2_e = (Y3_comb_step2 INTERACT V4N >= 1) INTERACT RV4 >= 4
 Y3_good_step2_f = Y3_comb_step2 INTERACT RV4 >= 5
 Y3_good_step2 = OR Y3_good_step2_a Y3_good_step2_b Y3_good_step2_c Y3_good_step2_d Y3_good_step2_e Y3_good_step2_f
 // 
 Y3_wide_chk_3 = Y3_wide_chk_2 INTERACT (WIDE_all_raw NOT INTERACT Y3_good_step2)
 Y3_comb_step3 = SIZE Y3_comb_step2 BY 0.035 INSIDE OF Y3_wide_chk_3 STEP 0.035 // step3: 0.035
 Y3_good_step3_a = Y3_comb_step3 INTERACT V4N >= 9
 Y3_good_step3_b = (Y3_comb_step3 INTERACT V4N >= 7) INTERACT RV4 >= 1
 Y3_good_step3_c = (Y3_comb_step3 INTERACT V4N >= 5) INTERACT RV4 >= 2
 Y3_good_step3_d = (Y3_comb_step3 INTERACT V4N >= 3) INTERACT RV4 >= 3
 Y3_good_step3_e = (Y3_comb_step3 INTERACT V4N >= 1) INTERACT RV4 >= 4
 Y3_good_step3_f = Y3_comb_step3 INTERACT RV4 >= 5
 Y3_good_step3 = OR Y3_good_step3_a Y3_good_step3_b Y3_good_step3_c Y3_good_step3_d Y3_good_step3_e Y3_good_step3_f
 // 
 Y3_wide_chk_4 = Y3_wide_chk_3 INTERACT (WIDE_all_raw NOT INTERACT Y3_good_step3)
 Y3_comb_step4 = SIZE Y3_comb_step3 BY 0.035 INSIDE OF Y3_wide_chk_4 STEP 0.035 // step4: 0.035
 Y3_good_step4_a = Y3_comb_step4 INTERACT V4N >= 9
 Y3_good_step4_b = (Y3_comb_step4 INTERACT V4N >= 7) INTERACT RV4 >= 1
 Y3_good_step4_c = (Y3_comb_step4 INTERACT V4N >= 5) INTERACT RV4 >= 2
 Y3_good_step4_d = (Y3_comb_step4 INTERACT V4N >= 3) INTERACT RV4 >= 3
 Y3_good_step4_e = (Y3_comb_step4 INTERACT V4N >= 1) INTERACT RV4 >= 4
 Y3_good_step4_f = Y3_comb_step4 INTERACT RV4 >= 5
 Y3_good_step4 = OR Y3_good_step4_a Y3_good_step4_b Y3_good_step4_c Y3_good_step4_d Y3_good_step4_e Y3_good_step4_f
 // 
 Y3_wide_chk_5 = Y3_wide_chk_4 INTERACT (WIDE_all_raw NOT INTERACT Y3_good_step4)
 Y3_comb_step5 = SIZE Y3_comb_step4 BY 0.035 INSIDE OF Y3_wide_chk_5 STEP 0.035 // step5: 0.035
 Y3_good_step5_a = Y3_comb_step5 INTERACT V4N >= 9
 Y3_good_step5_b = (Y3_comb_step5 INTERACT V4N >= 7) INTERACT RV4 >= 1
 Y3_good_step5_c = (Y3_comb_step5 INTERACT V4N >= 5) INTERACT RV4 >= 2
 Y3_good_step5_d = (Y3_comb_step5 INTERACT V4N >= 3) INTERACT RV4 >= 3
 Y3_good_step5_e = (Y3_comb_step5 INTERACT V4N >= 1) INTERACT RV4 >= 4
 Y3_good_step5_f = Y3_comb_step5 INTERACT RV4 >= 5
 Y3_good_step5 = OR Y3_good_step5_a Y3_good_step5_b Y3_good_step5_c Y3_good_step5_d Y3_good_step5_e Y3_good_step5_f
 // 
 Y3_wide_chk_6 = Y3_wide_chk_5 INTERACT (WIDE_all_raw NOT INTERACT Y3_good_step5)
 Y3_comb_step6 = SIZE Y3_comb_step5 BY 0.035 INSIDE OF Y3_wide_chk_6 STEP 0.035 // step6: 0.035
 Y3_good_step6_a = Y3_comb_step6 INTERACT V4N >= 9
 Y3_good_step6_b = (Y3_comb_step6 INTERACT V4N >= 7) INTERACT RV4 >= 1
 Y3_good_step6_c = (Y3_comb_step6 INTERACT V4N >= 5) INTERACT RV4 >= 2
 Y3_good_step6_d = (Y3_comb_step6 INTERACT V4N >= 3) INTERACT RV4 >= 3
 Y3_good_step6_e = (Y3_comb_step6 INTERACT V4N >= 1) INTERACT RV4 >= 4
 Y3_good_step6_f = Y3_comb_step6 INTERACT RV4 >= 5
 Y3_good_step6 = OR Y3_good_step6_a Y3_good_step6_b Y3_good_step6_c Y3_good_step6_d Y3_good_step6_e Y3_good_step6_f
 // 
 Y3_wide_chk_7 = Y3_wide_chk_6 INTERACT (WIDE_all_raw NOT INTERACT Y3_good_step6)
 Y3_comb_step7 = SIZE Y3_comb_step6 BY 0.035 INSIDE OF Y3_wide_chk_7 STEP 0.035 // step7: 0.035
 Y3_good_step7_a = Y3_comb_step7 INTERACT V4N >= 9
 Y3_good_step7_b = (Y3_comb_step7 INTERACT V4N >= 7) INTERACT RV4 >= 1
 Y3_good_step7_c = (Y3_comb_step7 INTERACT V4N >= 5) INTERACT RV4 >= 2
 Y3_good_step7_d = (Y3_comb_step7 INTERACT V4N >= 3) INTERACT RV4 >= 3
 Y3_good_step7_e = (Y3_comb_step7 INTERACT V4N >= 1) INTERACT RV4 >= 4
 Y3_good_step7_f = Y3_comb_step7 INTERACT RV4 >= 5
 Y3_good_step7 = OR Y3_good_step7_a Y3_good_step7_b Y3_good_step7_c Y3_good_step7_d Y3_good_step7_e Y3_good_step7_f
 // 
 Y3_wide_chk_8 = Y3_wide_chk_7 INTERACT (WIDE_all_raw NOT INTERACT Y3_good_step7)
 Y3_comb_step8 = SIZE Y3_comb_step7 BY 0.035 INSIDE OF Y3_wide_chk_8 STEP 0.035 // step8: 0.035
 Y3_good_step8_a = Y3_comb_step8 INTERACT V4N >= 9
 Y3_good_step8_b = (Y3_comb_step8 INTERACT V4N >= 7) INTERACT RV4 >= 1
 Y3_good_step8_c = (Y3_comb_step8 INTERACT V4N >= 5) INTERACT RV4 >= 2
 Y3_good_step8_d = (Y3_comb_step8 INTERACT V4N >= 3) INTERACT RV4 >= 3
 Y3_good_step8_e = (Y3_comb_step8 INTERACT V4N >= 1) INTERACT RV4 >= 4
 Y3_good_step8_f = Y3_comb_step8 INTERACT RV4 >= 5
 Y3_good_step8 = OR Y3_good_step8_a Y3_good_step8_b Y3_good_step8_c Y3_good_step8_d Y3_good_step8_e Y3_good_step8_f
 // 
 Y3_wide_chk_9 = Y3_wide_chk_8 INTERACT (WIDE_all_raw NOT INTERACT Y3_good_step8)
 Y3_comb_step9 = SIZE Y3_comb_step8 BY 0.07 INSIDE OF Y3_wide_chk_9 STEP 0.035 // step9: 0.385-0.07-0.035*7=0.07
 Y3_good_step9_a = Y3_comb_step9 INTERACT V4N >= 9
 Y3_good_step9_b = (Y3_comb_step9 INTERACT V4N >= 7) INTERACT RV4 >= 1
 Y3_good_step9_c = (Y3_comb_step9 INTERACT V4N >= 5) INTERACT RV4 >= 2
 Y3_good_step9_d = (Y3_comb_step9 INTERACT V4N >= 3) INTERACT RV4 >= 3
 Y3_good_step9_e = (Y3_comb_step9 INTERACT V4N >= 1) INTERACT RV4 >= 4
 Y3_good_step9_f = Y3_comb_step9 INTERACT RV4 >= 5
 Y3_good_step9 = OR Y3_good_step9_a Y3_good_step9_b Y3_good_step9_c Y3_good_step9_d Y3_good_step9_e Y3_good_step9_f
 Y3_good = WIDE_all_raw AND (OR Y3_good_step1 Y3_good_step2 Y3_good_step3 Y3_good_step4 Y3_good_step5 Y3_good_step6 Y3_good_step7 Y3_good_step8 Y3_good_step9)
 // 
 err1 = (WIDE_all_raw OUTSIDE (OR Y1_good Y2_good Y3_good)) INTERACT V4
 (err1 NOT INTERACT 125xv4_BAR) NOT INSIDE OCCD
}
 
Q: There should be at least two square 1.25xVn or one rectangular 1.25xVn in the intersection area of bottom metal and upper metal, when either wide metal 1.25xMy/1.25xMn or 1.25xMn+1 length >= 0.162um and width >= 0.162um, the space between either via and wide metal <= 1.48um (S, S is the shortest running path length from Via to the wide metal). (except via bar)
    DRC flags each intersecting area ({bottom metal AND upper metal}) with single square Via within the branch check region
A: 
125xRv4_R_4_M4 {
@ There should be at least two square 1.25xVn or one rectangular 1.25xVn in the intersection area of bottom metal and upper metal, when either wide metal 1.25xMy/1.25xMn or 1.25xMn+1 length >= 0.162um and width >= 0.162um, the space between either via and wide metal <= 1.48um (S, S is the shortest running path length from Via to the wide metal). (except via bar)
@ DRC flags each intersecting area ({bottom metal AND upper metal}) with single square Via within the branch check region
 wide_M4 = (WITH WIDTH M4 > 0.162-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 0.162-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 0.162-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M4_real = wide_M4 NOT OUTSIDE ((SIZE wide_M4 BY 1.48+GLOBAL_TOLERANCE) INTERACT V4)
 all_down_and_up = (M4 INTERACT wide_M4) AND M5
 dis_down_arm_wide_all = SIZE wide_M4_real BY 1.48+GLOBAL_TOLERANCE INSIDE OF M4 STEP 0.025
 dis_down_and_up = dis_down_arm_wide_all AND all_down_and_up
 dis_down_and_up_arm = (dis_down_and_up NOT wide_M4) AND M4
 dis_down_arm = (dis_down_arm_wide_all NOT wide_M4) AND M4
 // 
 dis_down_arm_good_a = dis_down_and_up_arm INTERACT V4N >= 2
 dis_down_arm_good_b = dis_down_and_up_arm INTERACT RV4
 dis_down_arm_good = OR dis_down_arm_good_a dis_down_arm_good_b
 dis_down_arm_bad = (dis_down_and_up_arm NOT dis_down_arm_good) INTERACT (all_down_and_up INTERACT V4N == 1)
 // 
 dis_down_arm_err_stack = (dis_down_arm_bad AND dis_down_and_up_arm) INTERACT V4N
 dis_down_arm_err = dis_down_arm INTERACT dis_down_arm_err_stack
 err1_met_down = (dis_down_arm_err INTERACT (V4N NOT OUTSIDE dis_down_arm_err)) NOT INTERACT RV4
 // 
 wide_M5 = (WITH WIDTH M5 > 0.162-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 0.162-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 0.162-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M5_real = wide_M5 NOT OUTSIDE ((SIZE wide_M5 BY 1.48+GLOBAL_TOLERANCE) INTERACT V4)
 all_up_and_down = (M5 INTERACT wide_M5) AND M4
 dis_up_arm_wide_all = SIZE wide_M5_real BY 1.48+GLOBAL_TOLERANCE INSIDE OF M5 STEP 0.025
 dis_up_and_down = dis_up_arm_wide_all AND all_up_and_down
 dis_up_and_down_arm = (dis_up_and_down NOT wide_M5) AND M5
 dis_up_arm = (dis_up_arm_wide_all NOT wide_M5) AND M5
 // 
 dis_up_arm_good_a = dis_up_and_down_arm INTERACT V4N >= 2
 dis_up_arm_good_b = dis_up_and_down_arm INTERACT RV4
 dis_up_arm_good = OR dis_up_arm_good_a dis_up_arm_good_b
 dis_up_arm_bad = (dis_up_and_down_arm NOT dis_up_arm_good) INTERACT (all_up_and_down INTERACT V4N == 1)
 // 
 dis_up_arm_err_stack = (dis_up_arm_bad AND dis_up_and_down_arm) INTERACT V4N
 dis_up_arm_err = dis_up_arm INTERACT dis_up_arm_err_stack
 err2_met_up = (dis_up_arm_err INTERACT (V4N NOT OUTSIDE dis_up_arm_err)) NOT INTERACT RV4
 err1_met_down NOT INTERACT 125xv4_BAR
}
 
Q: There should be at least two square 1.25xVn or one rectangular 1.25xVn in the intersection area of bottom metal and upper metal, when either wide metal 1.25xMy/1.25xMn or 1.25xMn+1 length >= 0.162um and width >= 0.162um, the space between either via and wide metal <= 1.48um (S, S is the shortest running path length from Via to the wide metal). (except via bar)
    DRC flags each intersecting area ({bottom metal AND upper metal}) with single square Via within the branch check region
A: 
125xRv4_R_4_M5 {
@ There should be at least two square 1.25xVn or one rectangular 1.25xVn in the intersection area of bottom metal and upper metal, when either wide metal 1.25xMy/1.25xMn or 1.25xMn+1 length >= 0.162um and width >= 0.162um, the space between either via and wide metal <= 1.48um (S, S is the shortest running path length from Via to the wide metal). (except via bar)
@ DRC flags each intersecting area ({bottom metal AND upper metal}) with single square Via within the branch check region
 wide_M4 = (WITH WIDTH M4 > 0.162-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 0.162-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 0.162-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M4_real = wide_M4 NOT OUTSIDE ((SIZE wide_M4 BY 1.48+GLOBAL_TOLERANCE) INTERACT V4)
 all_down_and_up = (M4 INTERACT wide_M4) AND M5
 dis_down_arm_wide_all = SIZE wide_M4_real BY 1.48+GLOBAL_TOLERANCE INSIDE OF M4 STEP 0.025
 dis_down_and_up = dis_down_arm_wide_all AND all_down_and_up
 dis_down_and_up_arm = (dis_down_and_up NOT wide_M4) AND M4
 dis_down_arm = (dis_down_arm_wide_all NOT wide_M4) AND M4
 // 
 dis_down_arm_good_a = dis_down_and_up_arm INTERACT V4N >= 2
 dis_down_arm_good_b = dis_down_and_up_arm INTERACT RV4
 dis_down_arm_good = OR dis_down_arm_good_a dis_down_arm_good_b
 dis_down_arm_bad = (dis_down_and_up_arm NOT dis_down_arm_good) INTERACT (all_down_and_up INTERACT V4N == 1)
 // 
 dis_down_arm_err_stack = (dis_down_arm_bad AND dis_down_and_up_arm) INTERACT V4N
 dis_down_arm_err = dis_down_arm INTERACT dis_down_arm_err_stack
 err1_met_down = (dis_down_arm_err INTERACT (V4N NOT OUTSIDE dis_down_arm_err)) NOT INTERACT RV4
 // 
 wide_M5 = (WITH WIDTH M5 > 0.162-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 0.162-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 0.162-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M5_real = wide_M5 NOT OUTSIDE ((SIZE wide_M5 BY 1.48+GLOBAL_TOLERANCE) INTERACT V4)
 all_up_and_down = (M5 INTERACT wide_M5) AND M4
 dis_up_arm_wide_all = SIZE wide_M5_real BY 1.48+GLOBAL_TOLERANCE INSIDE OF M5 STEP 0.025
 dis_up_and_down = dis_up_arm_wide_all AND all_up_and_down
 dis_up_and_down_arm = (dis_up_and_down NOT wide_M5) AND M5
 dis_up_arm = (dis_up_arm_wide_all NOT wide_M5) AND M5
 // 
 dis_up_arm_good_a = dis_up_and_down_arm INTERACT V4N >= 2
 dis_up_arm_good_b = dis_up_and_down_arm INTERACT RV4
 dis_up_arm_good = OR dis_up_arm_good_a dis_up_arm_good_b
 dis_up_arm_bad = (dis_up_and_down_arm NOT dis_up_arm_good) INTERACT (all_up_and_down INTERACT V4N == 1)
 // 
 dis_up_arm_err_stack = (dis_up_arm_bad AND dis_up_and_down_arm) INTERACT V4N
 dis_up_arm_err = dis_up_arm INTERACT dis_up_arm_err_stack
 err2_met_up = (dis_up_arm_err INTERACT (V4N NOT OUTSIDE dis_up_arm_err)) NOT INTERACT RV4
 err2_met_up NOT INTERACT 125xv4_BAR
}
 
Q: There should be at least two square 1.25xVn or one rectangular 1.25xVn in the intersection area of bottom metal and upper metal, when either wide metal 1.25xMy/1.25xMn or 1.25xMn+1 length >= 0.91um and width >= 0.91um, the space between either via and wide metal <= 3.59um (S, S is the shortest running path length from Via to the wide metal). (except via bar)
    DRC flags each intersecting area ({bottom metal AND upper metal}) with single square Via within the branch check region
A: 
125xRv4_R_5_M4 {
@ There should be at least two square 1.25xVn or one rectangular 1.25xVn in the intersection area of bottom metal and upper metal, when either wide metal 1.25xMy/1.25xMn or 1.25xMn+1 length >= 0.91um and width >= 0.91um, the space between either via and wide metal <= 3.59um (S, S is the shortest running path length from Via to the wide metal). (except via bar)
@ DRC flags each intersecting area ({bottom metal AND upper metal}) with single square Via within the branch check region
 wide_M4 = (WITH WIDTH M4 > 0.91-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 0.91-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 0.91-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M4_real = wide_M4 NOT OUTSIDE ((SIZE wide_M4 BY 3.59+GLOBAL_TOLERANCE) INTERACT V4)
 all_down_and_up = (M4 INTERACT wide_M4) AND M5
 dis_down_arm_wide_all = SIZE wide_M4_real BY 3.59+GLOBAL_TOLERANCE INSIDE OF M4 STEP 0.025
 dis_down_and_up = dis_down_arm_wide_all AND all_down_and_up
 dis_down_and_up_arm = (dis_down_and_up NOT wide_M4) AND M4
 dis_down_arm = (dis_down_arm_wide_all NOT wide_M4) AND M4
 // 
 dis_down_arm_good_a = dis_down_and_up_arm INTERACT V4N >= 2
 dis_down_arm_good_b = dis_down_and_up_arm INTERACT RV4
 dis_down_arm_good = OR dis_down_arm_good_a dis_down_arm_good_b
 dis_down_arm_bad = (dis_down_and_up_arm NOT dis_down_arm_good) INTERACT (all_down_and_up INTERACT V4N == 1)
 // 
 dis_down_arm_err_stack = (dis_down_arm_bad AND dis_down_and_up_arm) INTERACT V4N
 dis_down_arm_err = dis_down_arm INTERACT dis_down_arm_err_stack
 err1_met_down = (dis_down_arm_err INTERACT (V4N NOT OUTSIDE dis_down_arm_err)) NOT INTERACT RV4
 // 
 wide_M5 = (WITH WIDTH M5 > 0.91-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 0.91-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 0.91-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M5_real = wide_M5 NOT OUTSIDE ((SIZE wide_M5 BY 3.59+GLOBAL_TOLERANCE) INTERACT V4)
 all_up_and_down = (M5 INTERACT wide_M5) AND M4
 dis_up_arm_wide_all = SIZE wide_M5_real BY 3.59+GLOBAL_TOLERANCE INSIDE OF M5 STEP 0.025
 dis_up_and_down = dis_up_arm_wide_all AND all_up_and_down
 dis_up_and_down_arm = (dis_up_and_down NOT wide_M5) AND M5
 dis_up_arm = (dis_up_arm_wide_all NOT wide_M5) AND M5
 // 
 dis_up_arm_good_a = dis_up_and_down_arm INTERACT V4N >= 2
 dis_up_arm_good_b = dis_up_and_down_arm INTERACT RV4
 dis_up_arm_good = OR dis_up_arm_good_a dis_up_arm_good_b
 dis_up_arm_bad = (dis_up_and_down_arm NOT dis_up_arm_good) INTERACT (all_up_and_down INTERACT V4N == 1)
 // 
 dis_up_arm_err_stack = (dis_up_arm_bad AND dis_up_and_down_arm) INTERACT V4N
 dis_up_arm_err = dis_up_arm INTERACT dis_up_arm_err_stack
 err2_met_up = (dis_up_arm_err INTERACT (V4N NOT OUTSIDE dis_up_arm_err)) NOT INTERACT RV4
 err1_met_down NOT INTERACT 125xv4_BAR
}
 
Q: There should be at least two square 1.25xVn or one rectangular 1.25xVn in the intersection area of bottom metal and upper metal, when either wide metal 1.25xMy/1.25xMn or 1.25xMn+1 length >= 0.91um and width >= 0.91um, the space between either via and wide metal <= 3.59um (S, S is the shortest running path length from Via to the wide metal). (except via bar)
    DRC flags each intersecting area ({bottom metal AND upper metal}) with single square Via within the branch check region
A: 
125xRv4_R_5_M5 {
@ There should be at least two square 1.25xVn or one rectangular 1.25xVn in the intersection area of bottom metal and upper metal, when either wide metal 1.25xMy/1.25xMn or 1.25xMn+1 length >= 0.91um and width >= 0.91um, the space between either via and wide metal <= 3.59um (S, S is the shortest running path length from Via to the wide metal). (except via bar)
@ DRC flags each intersecting area ({bottom metal AND upper metal}) with single square Via within the branch check region
 wide_M4 = (WITH WIDTH M4 > 0.91-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 0.91-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 0.91-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M4_real = wide_M4 NOT OUTSIDE ((SIZE wide_M4 BY 3.59+GLOBAL_TOLERANCE) INTERACT V4)
 all_down_and_up = (M4 INTERACT wide_M4) AND M5
 dis_down_arm_wide_all = SIZE wide_M4_real BY 3.59+GLOBAL_TOLERANCE INSIDE OF M4 STEP 0.025
 dis_down_and_up = dis_down_arm_wide_all AND all_down_and_up
 dis_down_and_up_arm = (dis_down_and_up NOT wide_M4) AND M4
 dis_down_arm = (dis_down_arm_wide_all NOT wide_M4) AND M4
 // 
 dis_down_arm_good_a = dis_down_and_up_arm INTERACT V4N >= 2
 dis_down_arm_good_b = dis_down_and_up_arm INTERACT RV4
 dis_down_arm_good = OR dis_down_arm_good_a dis_down_arm_good_b
 dis_down_arm_bad = (dis_down_and_up_arm NOT dis_down_arm_good) INTERACT (all_down_and_up INTERACT V4N == 1)
 // 
 dis_down_arm_err_stack = (dis_down_arm_bad AND dis_down_and_up_arm) INTERACT V4N
 dis_down_arm_err = dis_down_arm INTERACT dis_down_arm_err_stack
 err1_met_down = (dis_down_arm_err INTERACT (V4N NOT OUTSIDE dis_down_arm_err)) NOT INTERACT RV4
 // 
 wide_M5 = (WITH WIDTH M5 > 0.91-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 0.91-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 0.91-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M5_real = wide_M5 NOT OUTSIDE ((SIZE wide_M5 BY 3.59+GLOBAL_TOLERANCE) INTERACT V4)
 all_up_and_down = (M5 INTERACT wide_M5) AND M4
 dis_up_arm_wide_all = SIZE wide_M5_real BY 3.59+GLOBAL_TOLERANCE INSIDE OF M5 STEP 0.025
 dis_up_and_down = dis_up_arm_wide_all AND all_up_and_down
 dis_up_and_down_arm = (dis_up_and_down NOT wide_M5) AND M5
 dis_up_arm = (dis_up_arm_wide_all NOT wide_M5) AND M5
 // 
 dis_up_arm_good_a = dis_up_and_down_arm INTERACT V4N >= 2
 dis_up_arm_good_b = dis_up_and_down_arm INTERACT RV4
 dis_up_arm_good = OR dis_up_arm_good_a dis_up_arm_good_b
 dis_up_arm_bad = (dis_up_and_down_arm NOT dis_up_arm_good) INTERACT (all_up_and_down INTERACT V4N == 1)
 // 
 dis_up_arm_err_stack = (dis_up_arm_bad AND dis_up_and_down_arm) INTERACT V4N
 dis_up_arm_err = dis_up_arm INTERACT dis_up_arm_err_stack
 err2_met_up = (dis_up_arm_err INTERACT (V4N NOT OUTSIDE dis_up_arm_err)) NOT INTERACT RV4
 err2_met_up NOT INTERACT 125xv4_BAR
}
 
Q: There should be at least two square 1.25xVn or one rectangular 1.25xVn in the intersection area of bottom metal and upper metal, when either wide metal 1.25xMy/1.25xMn or 1.25xMn+1 length >= 1.36um and width >= 1.36um, the space between either via and wide metal <= 9um (S, S is the shortest running path length from Via to the wide metal). (except via bar)
    DRC flags each intersecting area ({bottom metal AND upper metal}) with single square Via within the branch check region
A: 
125xRv4_R_6_M4 {
@ There should be at least two square 1.25xVn or one rectangular 1.25xVn in the intersection area of bottom metal and upper metal, when either wide metal 1.25xMy/1.25xMn or 1.25xMn+1 length >= 1.36um and width >= 1.36um, the space between either via and wide metal <= 9um (S, S is the shortest running path length from Via to the wide metal). (except via bar)
@ DRC flags each intersecting area ({bottom metal AND upper metal}) with single square Via within the branch check region
 wide_M4 = (WITH WIDTH M4 > 1.36-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 1.36-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 1.36-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M4_real = wide_M4 NOT OUTSIDE ((SIZE wide_M4 BY 9+GLOBAL_TOLERANCE) INTERACT V4)
 all_down_and_up = (M4 INTERACT wide_M4) AND M5
 dis_down_arm_wide_all = SIZE wide_M4_real BY 9+GLOBAL_TOLERANCE INSIDE OF M4 STEP 0.025
 dis_down_and_up = dis_down_arm_wide_all AND all_down_and_up
 dis_down_and_up_arm = (dis_down_and_up NOT wide_M4) AND M4
 dis_down_arm = (dis_down_arm_wide_all NOT wide_M4) AND M4
 // 
 dis_down_arm_good_a = dis_down_and_up_arm INTERACT V4N >= 2
 dis_down_arm_good_b = dis_down_and_up_arm INTERACT RV4
 dis_down_arm_good = OR dis_down_arm_good_a dis_down_arm_good_b
 dis_down_arm_bad = (dis_down_and_up_arm NOT dis_down_arm_good) INTERACT (all_down_and_up INTERACT V4N == 1)
 // 
 dis_down_arm_err_stack = (dis_down_arm_bad AND dis_down_and_up_arm) INTERACT V4N
 dis_down_arm_err = dis_down_arm INTERACT dis_down_arm_err_stack
 err1_met_down = (dis_down_arm_err INTERACT (V4N NOT OUTSIDE dis_down_arm_err)) NOT INTERACT RV4
 // 
 wide_M5 = (WITH WIDTH M5 > 1.36-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 1.36-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 1.36-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M5_real = wide_M5 NOT OUTSIDE ((SIZE wide_M5 BY 9+GLOBAL_TOLERANCE) INTERACT V4)
 all_up_and_down = (M5 INTERACT wide_M5) AND M4
 dis_up_arm_wide_all = SIZE wide_M5_real BY 9+GLOBAL_TOLERANCE INSIDE OF M5 STEP 0.025
 dis_up_and_down = dis_up_arm_wide_all AND all_up_and_down
 dis_up_and_down_arm = (dis_up_and_down NOT wide_M5) AND M5
 dis_up_arm = (dis_up_arm_wide_all NOT wide_M5) AND M5
 // 
 dis_up_arm_good_a = dis_up_and_down_arm INTERACT V4N >= 2
 dis_up_arm_good_b = dis_up_and_down_arm INTERACT RV4
 dis_up_arm_good = OR dis_up_arm_good_a dis_up_arm_good_b
 dis_up_arm_bad = (dis_up_and_down_arm NOT dis_up_arm_good) INTERACT (all_up_and_down INTERACT V4N == 1)
 // 
 dis_up_arm_err_stack = (dis_up_arm_bad AND dis_up_and_down_arm) INTERACT V4N
 dis_up_arm_err = dis_up_arm INTERACT dis_up_arm_err_stack
 err2_met_up = (dis_up_arm_err INTERACT (V4N NOT OUTSIDE dis_up_arm_err)) NOT INTERACT RV4
 err1_met_down NOT INTERACT 125xv4_BAR
}
 
Q: There should be at least two square 1.25xVn or one rectangular 1.25xVn in the intersection area of bottom metal and upper metal, when either wide metal 1.25xMy/1.25xMn or 1.25xMn+1 length >= 1.36um and width >= 1.36um, the space between either via and wide metal <= 9um (S, S is the shortest running path length from Via to the wide metal). (except via bar)
    DRC flags each intersecting area ({bottom metal AND upper metal}) with single square Via within the branch check region
A: 
125xRv4_R_6_M5 {
@ There should be at least two square 1.25xVn or one rectangular 1.25xVn in the intersection area of bottom metal and upper metal, when either wide metal 1.25xMy/1.25xMn or 1.25xMn+1 length >= 1.36um and width >= 1.36um, the space between either via and wide metal <= 9um (S, S is the shortest running path length from Via to the wide metal). (except via bar)
@ DRC flags each intersecting area ({bottom metal AND upper metal}) with single square Via within the branch check region
 wide_M4 = (WITH WIDTH M4 > 1.36-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 1.36-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 1.36-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M4_real = wide_M4 NOT OUTSIDE ((SIZE wide_M4 BY 9+GLOBAL_TOLERANCE) INTERACT V4)
 all_down_and_up = (M4 INTERACT wide_M4) AND M5
 dis_down_arm_wide_all = SIZE wide_M4_real BY 9+GLOBAL_TOLERANCE INSIDE OF M4 STEP 0.025
 dis_down_and_up = dis_down_arm_wide_all AND all_down_and_up
 dis_down_and_up_arm = (dis_down_and_up NOT wide_M4) AND M4
 dis_down_arm = (dis_down_arm_wide_all NOT wide_M4) AND M4
 // 
 dis_down_arm_good_a = dis_down_and_up_arm INTERACT V4N >= 2
 dis_down_arm_good_b = dis_down_and_up_arm INTERACT RV4
 dis_down_arm_good = OR dis_down_arm_good_a dis_down_arm_good_b
 dis_down_arm_bad = (dis_down_and_up_arm NOT dis_down_arm_good) INTERACT (all_down_and_up INTERACT V4N == 1)
 // 
 dis_down_arm_err_stack = (dis_down_arm_bad AND dis_down_and_up_arm) INTERACT V4N
 dis_down_arm_err = dis_down_arm INTERACT dis_down_arm_err_stack
 err1_met_down = (dis_down_arm_err INTERACT (V4N NOT OUTSIDE dis_down_arm_err)) NOT INTERACT RV4
 // 
 wide_M5 = (WITH WIDTH M5 > 1.36-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 1.36-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 1.36-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M5_real = wide_M5 NOT OUTSIDE ((SIZE wide_M5 BY 9+GLOBAL_TOLERANCE) INTERACT V4)
 all_up_and_down = (M5 INTERACT wide_M5) AND M4
 dis_up_arm_wide_all = SIZE wide_M5_real BY 9+GLOBAL_TOLERANCE INSIDE OF M5 STEP 0.025
 dis_up_and_down = dis_up_arm_wide_all AND all_up_and_down
 dis_up_and_down_arm = (dis_up_and_down NOT wide_M5) AND M5
 dis_up_arm = (dis_up_arm_wide_all NOT wide_M5) AND M5
 // 
 dis_up_arm_good_a = dis_up_and_down_arm INTERACT V4N >= 2
 dis_up_arm_good_b = dis_up_and_down_arm INTERACT RV4
 dis_up_arm_good = OR dis_up_arm_good_a dis_up_arm_good_b
 dis_up_arm_bad = (dis_up_and_down_arm NOT dis_up_arm_good) INTERACT (all_up_and_down INTERACT V4N == 1)
 // 
 dis_up_arm_err_stack = (dis_up_arm_bad AND dis_up_and_down_arm) INTERACT V4N
 dis_up_arm_err = dis_up_arm INTERACT dis_up_arm_err_stack
 err2_met_up = (dis_up_arm_err INTERACT (V4N NOT OUTSIDE dis_up_arm_err)) NOT INTERACT RV4
 err2_met_up NOT INTERACT 125xv4_BAR
}
 
Q: 45-degree 1.25xRVn is not allowed
A: 
125xRv4_R_7 {
@ 45-degree 1.25xRVn is not allowed
 err1 = ANGLE (V4 NOT 125xv4_BAR) > 44.5 < 45.5
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 

#IFDEF Delta_Voltage_Rules_Check YES

Q: Maximum delta V >= 5.6V is not allowed, when space between 1.25xRVn is < 0.410um
A: 
125xRv4_R_8 {
@ Maximum delta V >= 5.6V is not allowed, when space between 1.25xRVn is < 0.410um
 chk_VIA = V4 INTERACT DVK_V4_RE
 err1 = DFM DV chk_VIA V4 < 0.410 DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" >= 5.6 ANNOTATE NOT CONNECTED SINGULAR
 DFM COPY err1
}


//125xv5

Q: 45-degree 1.25xVn is not allowed
A: 
125xv5_R_1 {
@ 45-degree 1.25xVn is not allowed
 err1 = ANGLE (V5 NOT 125xv5_BAR) > 44.5 < 45.5
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
Q: It is not allowed to have single 1.25xVn in "H-shape" 1.25xMn+1 when all of the following conditions come into existence:
    1) The 1.25xMn+1 has "H-shape" interact two metal holes: both two metal hole length <= 4.5um and two metal hole area <= 4.05um2
    2) The 1.25xVn overlaps on the center metal bar of this "H-shape" 1.25xMn+1
    3) The center metal bar length <= 0.9um and the metal bar width <= 0.162um
A: 
125xv5_R_2 {
@ It is not allowed to have single 1.25xVn in "H-shape" 1.25xMn+1 when all of the following conditions come into existence:
@ 1) The 1.25xMn+1 has "H-shape" interact two metal holes: both two metal hole length <= 4.5um and two metal hole area <= 4.05um2
@ 2) The 1.25xVn overlaps on the center metal bar of this "H-shape" 1.25xMn+1
@ 3) The center metal bar length <= 0.9um and the metal bar width <= 0.162um
 hole_area_meet = AREA (HOLES M6 INNER) <= 4.05
 hole_area_meet_len = (hole_area_meet WITH EDGE (LENGTH hole_area_meet <= 0.9)) NOT WITH EDGE (LENGTH hole_area_meet > 4.5)
 hole_area_real = (hole_area_meet_len NOT ENCLOSE RECTANGLE 0.9+GLOBAL_TOLERANCE 4.5) NOT ENCLOSE RECTANGLE 0.9 4.5+GLOBAL_TOLERANCE
 hole_bars_len = M6 COIN EDGE hole_area_real
 // 
 hole_bars = INT hole_bars_len <= 0.162 ABUT<90 OPPOSITE REGION EXCLUDE SHIELDED
 hole_bars_real = hole_bars WITH EDGE (LENGTH hole_bars_len <= 0.9)
 hole_bars_vias_sq = V5N INTERACT ((hole_bars_real INTERACT hole_area_real == 2) NOT ENCLOSE RV5)
 err1 = hole_bars_real INTERACT hole_bars_vias_sq == 1
 err1 NOT INSIDE SealR_NOT_BULK
}
 
Q: The numbers of neighboring square 1.25xVn to each edge of 1.25xVn <= 0.065um is not allowed < 2
A: 
125xv5_R_3 {
@ The numbers of neighboring square 1.25xVn to each edge of 1.25xVn <= 0.065um is not allowed < 2
 // based on 125xVn.S.6 and 125xVn.S.1, so only check the space range 0.056~0.065um with PRL <= 0.04
 Y1 = EXT V5N >= 0.056 <= 0.065 ABUT CORNER TO CORNER
 Y2 = DFM PROPERTY Y1 [-= (EWXP(Y1) > 0.040 && EWYP(Y1) > 0.040) ? 1 : 0] > 0
 Y3 = INT [V5N] < 0.001 ABUT INTERSECTING ONLY
 Y4 = Y3 COIN EDGE (DFM COPY Y2 EDGE)
 Y5 = INT Y4 V5N < 0.001 ABUT==90 INTERSECTING ONLY REGION
 Y6 = INT (V5N COIN EDGE Y5) == 0.040 OPPOSITE REGION
 err1 = V5N INTERACT Y6
 err1 NOT INSIDE SealR_NOT_BULK
}
 
Q: The numbers of neighboring square 1.25xVn in one group (space <= 0.065um) <= 3
A: 
125xv5_R_4 {
@ The numbers of neighboring square 1.25xVn in one group (space <= 0.065um) <= 3
 err1 = WITH NEIGHBOR V5N > 2 SPACE <= 0.065
 err1 NOT INSIDE SealR_NOT_BULK
}
 


Q: Maximum delta V >= 5.6V is not allowed, when space between 1.25xVn is < 0.410um
A: 
125xv5_R_5 {
@ Maximum delta V >= 5.6V is not allowed, when space between 1.25xVn is < 0.410um
 chk_VIA = V5 INTERACT DVK_V5_SQ
 err1 = DFM DV chk_VIA V5 < 0.410 DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" >= 5.6 ANNOTATE NOT CONNECTED SINGULAR
 DFM COPY err1
}



// 1.25xVn.R.8[NC] 1.25xVn pattern must be drawn on data type 50
 
Q: It's not allowed 1.25xVn overlap with the metal resistor directly underneath and above the 1.25xVn
A: 
125xv5_R_9 {
@ It's not allowed 1.25xVn overlap with the metal resistor directly underneath and above the 1.25xVn
 err1 = V5 AND (M5RES AND M5)
 err2 = V5 AND (M6RES AND M6)
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}



 
Q: Recommend space between a square 1.25xVn and another (1.25xVn OR 1.25xRVn OR DUM_1.25xVn) < 4um to avoid single square 1.25xVn
A: 
125xv5_R_10_R {
@ Recommend space between a square 1.25xVn and another (1.25xVn OR 1.25xRVn OR DUM_1.25xVn) < 4um to avoid single square 1.25xVn
 ALL_VIA_CHECK = OR V5_SR V5DUM_all V5DOP_all
 STEP_1 = SIZE V5_SR BY 1.4
 // 4/1.414 = 2.828
 STEP_1_GOOD = STEP_1 INTERACT ALL_VIA_CHECK > 1
 STEP_1_FILTER = V5N NOT INTERACT STEP_1_GOOD
 err1 = STEP_1_FILTER NOT WITH EDGE (EXT [STEP_1_FILTER] ALL_VIA_CHECK < 4 PERP ALSO)
 err1 NOT INSIDE SealR_NOT_BULK
}

//125xRv5

Q: Single 1.25xRVn is not allowed in "H-shape" 1.25xMn+1, when:
    1. The 1.25xMn+1 has "H-shape" interacting with two metal holes: both two metal holes length <= 4.5um and two metal hole area <= 4.05um2
    2. The 1.25xRVn overlaps on the center metal bar of this "H-shape" 1.25xMn+1
    3. The center metal bar length <= 0.9um and the metal bar width <= 0.162um
    DRC doesn't check when one or more square 1.25xRVn is also on H-shape 1.25xMn+1 region
A: 
125xRv5_R_1 {
@ Single 1.25xRVn is not allowed in "H-shape" 1.25xMn+1, when:
@ 1. The 1.25xMn+1 has "H-shape" interacting with two metal holes: both two metal holes length <= 4.5um and two metal hole area <= 4.05um2
@ 2. The 1.25xRVn overlaps on the center metal bar of this "H-shape" 1.25xMn+1
@ 3. The center metal bar length <= 0.9um and the metal bar width <= 0.162um
@ DRC doesn't check when one or more square 1.25xRVn is also on H-shape 1.25xMn+1 region
 hole_area_meet = AREA (HOLES M6 INNER) <= 4.05
 hole_area_meet_len = (hole_area_meet WITH EDGE (LENGTH hole_area_meet <= 0.9)) NOT WITH EDGE (LENGTH hole_area_meet > 4.5)
 hole_area_real = (hole_area_meet_len NOT ENCLOSE RECTANGLE 0.9+GLOBAL_TOLERANCE 4.5) NOT ENCLOSE RECTANGLE 0.9 4.5+GLOBAL_TOLERANCE
 hole_bars_len = M6 COIN EDGE hole_area_real
 // 
 hole_bars = INT hole_bars_len <= 0.162 ABUT<90 OPPOSITE REGION EXCLUDE SHIELDED
 hole_bars_real = hole_bars WITH EDGE (LENGTH hole_bars_len <= 0.9)
 hole_bars_vias_rect = RV5 INTERACT ((hole_bars_real INTERACT hole_area_real == 2) NOT ENCLOSE V5N >= 2)
 err1 = hole_bars_real INTERACT hole_bars_vias_rect == 1
 err1 NOT INSIDE SealR_NOT_BULK
}
 
Q: Redundant via requirement must be obeyed by one of following conditions of via numbers and space for 1.25xMy/1.25xMn, 1.25xMn+1 connection (one of 1.25xMy/1.25xMn or 1.25xMn+1 have width and length >= 0.164um, two square vias are equal to one rectangular via for below conditions) (Except VIA bar)
    1) At least one rectangular 1.25xVn
    2) At least two square 1.25xVn with space <= 0.091um
    3) At least four square 1.25xVn with space <= 0.59um
A: 
125xRv5_R_2 {
@ Redundant via requirement must be obeyed by one of following conditions of via numbers and space for 1.25xMy/1.25xMn, 1.25xMn+1 connection (one of 1.25xMy/1.25xMn or 1.25xMn+1 have width and length >= 0.164um, two square vias are equal to one rectangular via for below conditions) (Except VIA bar)
@ 1) At least one rectangular 1.25xVn
@ 2) At least two square 1.25xVn with space <= 0.091um
@ 3) At least four square 1.25xVn with space <= 0.59um
 X1a = WITH WIDTH M5 > 0.164-GLOBAL_TOLERANCE <= 0.398-GLOBAL_TOLERANCE
 X1b = WITH WIDTH M6 > 0.164-GLOBAL_TOLERANCE <= 0.398-GLOBAL_TOLERANCE
 Y1a = WITH WIDTH M5 > 0.398-GLOBAL_TOLERANCE
 Y1b = WITH WIDTH M6 > 0.398-GLOBAL_TOLERANCE
 WIDE_1 = (X1a AND M6) ENCLOSE V5
 WIDE_2 = (M5 AND X1b) ENCLOSE V5
 WIDE_3 = (Y1a AND M6) ENCLOSE V5
 WIDE_4 = (M5 AND Y1b) ENCLOSE V5
 WIDE_all_raw = (WIDE_1 OR WIDE_2) NOT (WIDE_3 OR WIDE_4)
 WIDE_all = (M5 AND M6) NOT OUTSIDE WIDE_all_raw
 // 
 // condition 1
 Y1_good = WIDE_all_raw AND RV5
 // condition 2
 Y2_wide_all = WIDE_all_raw NOT INTERACT Y1_good
 Y2_wide = (WIDE_all INTERACT Y2_wide_all) INTERACT V5_SR >= 2
 Y2_comb_step = SIZE V5_SR BY 0.091/2 INSIDE OF Y2_wide STEP 0.030
 Y2_good_step = OR (Y2_comb_step INTERACT V5N >= 2) (Y2_comb_step INTERACT RV5)
 Y2_good = WIDE_all_raw AND Y2_good_step
 // 
 // condition 3
 Y3_wide_all = WIDE_all_raw NOT INTERACT (OR Y1_good Y2_good)
 Y3_wide = (WIDE_all INTERACT Y3_wide_all) INTERACT V5_SR >= 2 // rectangle array 0.59/2=0.295
 Y3_vias_input = V5_SR AND Y3_wide
 Y3_wide_chk_1 = Y3_wide INTERACT Y3_wide_all
 Y3_comb_step1 = SIZE Y3_vias_input BY 0.04 INSIDE OF Y3_wide_chk_1 STEP 0.04 // via minimum space = 0.075
 Y3_good_step1 = OR (Y3_comb_step1 INTERACT V5N >= 4) (Y3_comb_step1 INTERACT RV5) // step1: 0.050
 // 
 Y3_wide_chk_2 = Y3_wide_chk_1 INTERACT (WIDE_all_raw NOT INTERACT Y3_good_step1)
 Y3_comb_step2 = SIZE Y3_comb_step1 BY 0.04 INSIDE OF Y3_wide_chk_2 STEP 0.04
 Y3_good_step2 = OR (Y3_comb_step2 INTERACT V5N >= 4) (Y3_comb_step2 INTERACT RV5) // step2: 0.04
 // 
 Y3_wide_chk_3 = Y3_wide_chk_2 INTERACT (WIDE_all_raw NOT INTERACT Y3_good_step2)
 Y3_comb_step3 = SIZE Y3_comb_step2 BY 0.04 INSIDE OF Y3_wide_chk_3 STEP 0.04
 Y3_good_step3 = OR (Y3_comb_step3 INTERACT V5N >= 4) (Y3_comb_step3 INTERACT RV5) // step3: 0.04
 // 
 Y3_wide_chk_4 = Y3_wide_chk_3 INTERACT (WIDE_all_raw NOT INTERACT Y3_good_step3)
 Y3_comb_step4 = SIZE Y3_comb_step3 BY 0.04 INSIDE OF Y3_wide_chk_4 STEP 0.04
 Y3_good_step4 = OR (Y3_comb_step4 INTERACT V5N >= 4) (Y3_comb_step4 INTERACT RV5) // step4: 0.04
 // 
 Y3_wide_chk_5 = Y3_wide_chk_4 INTERACT (WIDE_all_raw NOT INTERACT Y3_good_step4)
 Y3_comb_step5 = SIZE Y3_comb_step4 BY 0.04 INSIDE OF Y3_wide_chk_5 STEP 0.04
 Y3_good_step5 = OR (Y3_comb_step5 INTERACT V5N >= 4) (Y3_comb_step5 INTERACT RV5) // step5: 0.04
 // 
 Y3_wide_chk_6 = Y3_wide_chk_5 INTERACT (WIDE_all_raw NOT INTERACT Y3_good_step5)
 Y3_comb_step6 = SIZE Y3_comb_step5 BY 0.04 INSIDE OF Y3_wide_chk_6 STEP 0.04
 Y3_good_step6 = OR (Y3_comb_step6 INTERACT V5N >= 4) (Y3_comb_step6 INTERACT RV5) // step6: 0.04
 // 
 Y3_wide_chk_7 = Y3_wide_chk_6 INTERACT (WIDE_all_raw NOT INTERACT Y3_good_step6)
 Y3_comb_step7 = SIZE Y3_comb_step6 BY 0.04 INSIDE OF Y3_wide_chk_7 STEP 0.04
 Y3_good_step7 = OR (Y3_comb_step7 INTERACT V5N >= 4) (Y3_comb_step7 INTERACT RV5) // step7: 0.04
 // 
 Y3_wide_chk_8 = Y3_wide_chk_7 INTERACT (WIDE_all_raw NOT INTERACT Y3_good_step7)
 Y3_comb_step8 = SIZE Y3_comb_step7 BY 0.015 INSIDE OF Y3_wide_chk_8 STEP 0.015
 Y3_good_step8 = OR (Y3_comb_step8 INTERACT V5N >= 4) (Y3_comb_step8 INTERACT RV5) // step8: 0.295-0.04*7=0.015
 Y3_good = WIDE_all_raw AND (OR Y3_good_step1 Y3_good_step2 Y3_good_step3 Y3_good_step4 Y3_good_step5 Y3_good_step6 Y3_good_step7 Y3_good_step8)
 // 
 err1 = (WIDE_all_raw OUTSIDE (OR Y1_good Y2_good Y3_good)) INTERACT V5
 err1 NOT INTERACT 125xv5_BAR
}
 
Q: Redundant via requirement must be obeyed by one of following conditions of 1.25xVn numbers and space for 1.25xMy/1.25xMn and 1.25xMn+1 connection (one of 1.25xMy/1.25xMn or 1.25xMn+1 have width and length >= 0.398um, two square vias are equal to one rectangular via for below conditions), except VIA bar, OCCD region
    1) At least 4 square 1.25xVn with space <= 0.091um
    2) At least 2 square 1.25xVn and 1 rectangular 1.25xVn with space <= 0.118um
    3) At least 9 square 1.25xVn with space <= 0.77um
    For condition 2) and 3) 2 square 1.25xVn can be replaced by 1 rectangular 1.25xVn
A: 
125xRv5_R_3 {
@ Redundant via requirement must be obeyed by one of following conditions of 1.25xVn numbers and space for 1.25xMy/1.25xMn and 1.25xMn+1 connection (one of 1.25xMy/1.25xMn or 1.25xMn+1 have width and length >= 0.398um, two square vias are equal to one rectangular via for below conditions), except VIA bar, OCCD region
@ 1) At least 4 square 1.25xVn with space <= 0.091um
@ 2) At least 2 square 1.25xVn and 1 rectangular 1.25xVn with space <= 0.118um
@ 3) At least 9 square 1.25xVn with space <= 0.77um
@ For condition 2) and 3) 2 square 1.25xVn can be replaced by 1 rectangular 1.25xVn
 X1a = WITH WIDTH M5 > 0.398-GLOBAL_TOLERANCE
 X1b = WITH WIDTH M6 > 0.398-GLOBAL_TOLERANCE
 WIDE_1 = (X1a AND M6) ENCLOSE V5
 WIDE_2 = (M5 AND X1b) ENCLOSE V5
 WIDE_all_raw = WIDE_1 OR WIDE_2
 WIDE_all = (M5 AND M6) NOT OUTSIDE WIDE_all_raw
 // 
 // condition 1
 Y2_wide = WIDE_all INTERACT V5N >= 4
 Y2_vias_input = V5N AND Y2_wide
 Y2_wide_chk_1 = COPY Y2_wide // rectangle array 0.09/2=0.0455
 Y2_comb_step1 = SIZE Y2_vias_input BY 0.030 INSIDE OF Y2_wide_chk_1 STEP 0.030 // step1: 0.030, via minimum space = 0.056
 Y2_good_step1 = Y2_comb_step1 INTERACT V5N >= 4
 // 
 Y2_wide_chk_2 = Y2_wide_chk_1 INTERACT (WIDE_all_raw NOT INTERACT Y2_good_step1)
 Y2_comb_step2 = SIZE Y2_comb_step1 BY 0.0155 INSIDE OF Y2_wide_chk_2 STEP 0.015 // step2: 0.0155
 Y2_good_step2 = Y2_comb_step2 INTERACT V5N >= 4
 Y2_good = WIDE_all_raw AND (OR Y2_good_step1 Y2_good_step2)
 // 
 // condition 2
 Y1_wide_all = WIDE_all_raw NOT INTERACT Y2_good // rectangle array 0.118/2=0.059
 Y1_wide = (WIDE_all INTERACT Y1_wide_all) INTERACT V5 >= 2
 Y1_vias_input = V5 AND Y1_wide
 Y1_wide_chk_1 = Y1_wide INTERACT Y1_wide_all
 Y1_comb_step1 = SIZE Y1_vias_input BY 0.030 INSIDE OF Y1_wide_chk_1 STEP 0.030 // step1: 0.030, via minimum space = 0.100
 Y1_good_step1_a = Y1_comb_step1 INTERACT RV5 >= 2
 Y1_good_step1_b = (Y1_comb_step1 INTERACT V5N >= 2) INTERACT RV5 >= 1
 Y1_good_step1 = OR Y1_good_step1_a Y1_good_step1_b
 // 
 Y1_wide_chk_2 = Y1_wide_chk_1 INTERACT (WIDE_all_raw NOT INTERACT Y1_good_step1)
 Y1_comb_step2 = SIZE Y1_comb_step1 BY 0.029 INSIDE OF Y1_wide_chk_2 STEP 0.025 // step2: 0.059-0.030=0.029
 Y1_good_step2_a = Y1_comb_step2 INTERACT RV5 >= 2
 Y1_good_step2_b = (Y1_comb_step2 INTERACT V5N >= 2) INTERACT RV5 >= 1
 Y1_good_step2 = OR Y1_good_step2_a Y1_good_step2_b
 Y1_good = WIDE_all_raw AND (OR Y1_good_step1 Y1_good_step2)
 // 
 // condition 3
 Y3_wide_all = WIDE_all_raw NOT INTERACT (OR Y2_good Y1_good)
 Y3_wide = (WIDE_all INTERACT Y3_wide_all) INTERACT V5 >= 5
 Y3_vias_input = V5N AND Y3_wide
 Y3_wide_chk_1 = Y3_wide INTERACT Y3_wide_all // rectangle array 0.77/2=0.385
 Y3_comb_step1 = SIZE Y3_vias_input BY 0.070 INSIDE OF Y3_wide_chk_1 STEP 0.035 // step1: 0.070, via minimum space = 0.056
 Y3_good_step1_a = Y3_comb_step1 INTERACT V5N >= 9
 Y3_good_step1_b = (Y3_comb_step1 INTERACT V5N >= 7) INTERACT RV5 >= 1
 Y3_good_step1_c = (Y3_comb_step1 INTERACT V5N >= 5) INTERACT RV5 >= 2
 Y3_good_step1_d = (Y3_comb_step1 INTERACT V5N >= 3) INTERACT RV5 >= 3
 Y3_good_step1_e = (Y3_comb_step1 INTERACT V5N >= 1) INTERACT RV5 >= 4
 Y3_good_step1_f = Y3_comb_step1 INTERACT RV5 >= 5
 Y3_good_step1 = OR Y3_good_step1_a Y3_good_step1_b Y3_good_step1_c Y3_good_step1_d Y3_good_step1_e Y3_good_step1_f
 // 
 Y3_wide_chk_2 = Y3_wide_chk_1 INTERACT (WIDE_all_raw NOT INTERACT Y3_good_step1)
 Y3_comb_step2 = SIZE Y3_comb_step1 BY 0.035 INSIDE OF Y3_wide_chk_2 STEP 0.035 // step2: 0.035
 Y3_good_step2_a = Y3_comb_step2 INTERACT V5N >= 9
 Y3_good_step2_b = (Y3_comb_step2 INTERACT V5N >= 7) INTERACT RV5 >= 1
 Y3_good_step2_c = (Y3_comb_step2 INTERACT V5N >= 5) INTERACT RV5 >= 2
 Y3_good_step2_d = (Y3_comb_step2 INTERACT V5N >= 3) INTERACT RV5 >= 3
 Y3_good_step2_e = (Y3_comb_step2 INTERACT V5N >= 1) INTERACT RV5 >= 4
 Y3_good_step2_f = Y3_comb_step2 INTERACT RV5 >= 5
 Y3_good_step2 = OR Y3_good_step2_a Y3_good_step2_b Y3_good_step2_c Y3_good_step2_d Y3_good_step2_e Y3_good_step2_f
 // 
 Y3_wide_chk_3 = Y3_wide_chk_2 INTERACT (WIDE_all_raw NOT INTERACT Y3_good_step2)
 Y3_comb_step3 = SIZE Y3_comb_step2 BY 0.035 INSIDE OF Y3_wide_chk_3 STEP 0.035 // step3: 0.035
 Y3_good_step3_a = Y3_comb_step3 INTERACT V5N >= 9
 Y3_good_step3_b = (Y3_comb_step3 INTERACT V5N >= 7) INTERACT RV5 >= 1
 Y3_good_step3_c = (Y3_comb_step3 INTERACT V5N >= 5) INTERACT RV5 >= 2
 Y3_good_step3_d = (Y3_comb_step3 INTERACT V5N >= 3) INTERACT RV5 >= 3
 Y3_good_step3_e = (Y3_comb_step3 INTERACT V5N >= 1) INTERACT RV5 >= 4
 Y3_good_step3_f = Y3_comb_step3 INTERACT RV5 >= 5
 Y3_good_step3 = OR Y3_good_step3_a Y3_good_step3_b Y3_good_step3_c Y3_good_step3_d Y3_good_step3_e Y3_good_step3_f
 // 
 Y3_wide_chk_4 = Y3_wide_chk_3 INTERACT (WIDE_all_raw NOT INTERACT Y3_good_step3)
 Y3_comb_step4 = SIZE Y3_comb_step3 BY 0.035 INSIDE OF Y3_wide_chk_4 STEP 0.035 // step4: 0.035
 Y3_good_step4_a = Y3_comb_step4 INTERACT V5N >= 9
 Y3_good_step4_b = (Y3_comb_step4 INTERACT V5N >= 7) INTERACT RV5 >= 1
 Y3_good_step4_c = (Y3_comb_step4 INTERACT V5N >= 5) INTERACT RV5 >= 2
 Y3_good_step4_d = (Y3_comb_step4 INTERACT V5N >= 3) INTERACT RV5 >= 3
 Y3_good_step4_e = (Y3_comb_step4 INTERACT V5N >= 1) INTERACT RV5 >= 4
 Y3_good_step4_f = Y3_comb_step4 INTERACT RV5 >= 5
 Y3_good_step4 = OR Y3_good_step4_a Y3_good_step4_b Y3_good_step4_c Y3_good_step4_d Y3_good_step4_e Y3_good_step4_f
 // 
 Y3_wide_chk_5 = Y3_wide_chk_4 INTERACT (WIDE_all_raw NOT INTERACT Y3_good_step4)
 Y3_comb_step5 = SIZE Y3_comb_step4 BY 0.035 INSIDE OF Y3_wide_chk_5 STEP 0.035 // step5: 0.035
 Y3_good_step5_a = Y3_comb_step5 INTERACT V5N >= 9
 Y3_good_step5_b = (Y3_comb_step5 INTERACT V5N >= 7) INTERACT RV5 >= 1
 Y3_good_step5_c = (Y3_comb_step5 INTERACT V5N >= 5) INTERACT RV5 >= 2
 Y3_good_step5_d = (Y3_comb_step5 INTERACT V5N >= 3) INTERACT RV5 >= 3
 Y3_good_step5_e = (Y3_comb_step5 INTERACT V5N >= 1) INTERACT RV5 >= 4
 Y3_good_step5_f = Y3_comb_step5 INTERACT RV5 >= 5
 Y3_good_step5 = OR Y3_good_step5_a Y3_good_step5_b Y3_good_step5_c Y3_good_step5_d Y3_good_step5_e Y3_good_step5_f
 // 
 Y3_wide_chk_6 = Y3_wide_chk_5 INTERACT (WIDE_all_raw NOT INTERACT Y3_good_step5)
 Y3_comb_step6 = SIZE Y3_comb_step5 BY 0.035 INSIDE OF Y3_wide_chk_6 STEP 0.035 // step6: 0.035
 Y3_good_step6_a = Y3_comb_step6 INTERACT V5N >= 9
 Y3_good_step6_b = (Y3_comb_step6 INTERACT V5N >= 7) INTERACT RV5 >= 1
 Y3_good_step6_c = (Y3_comb_step6 INTERACT V5N >= 5) INTERACT RV5 >= 2
 Y3_good_step6_d = (Y3_comb_step6 INTERACT V5N >= 3) INTERACT RV5 >= 3
 Y3_good_step6_e = (Y3_comb_step6 INTERACT V5N >= 1) INTERACT RV5 >= 4
 Y3_good_step6_f = Y3_comb_step6 INTERACT RV5 >= 5
 Y3_good_step6 = OR Y3_good_step6_a Y3_good_step6_b Y3_good_step6_c Y3_good_step6_d Y3_good_step6_e Y3_good_step6_f
 // 
 Y3_wide_chk_7 = Y3_wide_chk_6 INTERACT (WIDE_all_raw NOT INTERACT Y3_good_step6)
 Y3_comb_step7 = SIZE Y3_comb_step6 BY 0.035 INSIDE OF Y3_wide_chk_7 STEP 0.035 // step7: 0.035
 Y3_good_step7_a = Y3_comb_step7 INTERACT V5N >= 9
 Y3_good_step7_b = (Y3_comb_step7 INTERACT V5N >= 7) INTERACT RV5 >= 1
 Y3_good_step7_c = (Y3_comb_step7 INTERACT V5N >= 5) INTERACT RV5 >= 2
 Y3_good_step7_d = (Y3_comb_step7 INTERACT V5N >= 3) INTERACT RV5 >= 3
 Y3_good_step7_e = (Y3_comb_step7 INTERACT V5N >= 1) INTERACT RV5 >= 4
 Y3_good_step7_f = Y3_comb_step7 INTERACT RV5 >= 5
 Y3_good_step7 = OR Y3_good_step7_a Y3_good_step7_b Y3_good_step7_c Y3_good_step7_d Y3_good_step7_e Y3_good_step7_f
 // 
 Y3_wide_chk_8 = Y3_wide_chk_7 INTERACT (WIDE_all_raw NOT INTERACT Y3_good_step7)
 Y3_comb_step8 = SIZE Y3_comb_step7 BY 0.035 INSIDE OF Y3_wide_chk_8 STEP 0.035 // step8: 0.035
 Y3_good_step8_a = Y3_comb_step8 INTERACT V5N >= 9
 Y3_good_step8_b = (Y3_comb_step8 INTERACT V5N >= 7) INTERACT RV5 >= 1
 Y3_good_step8_c = (Y3_comb_step8 INTERACT V5N >= 5) INTERACT RV5 >= 2
 Y3_good_step8_d = (Y3_comb_step8 INTERACT V5N >= 3) INTERACT RV5 >= 3
 Y3_good_step8_e = (Y3_comb_step8 INTERACT V5N >= 1) INTERACT RV5 >= 4
 Y3_good_step8_f = Y3_comb_step8 INTERACT RV5 >= 5
 Y3_good_step8 = OR Y3_good_step8_a Y3_good_step8_b Y3_good_step8_c Y3_good_step8_d Y3_good_step8_e Y3_good_step8_f
 // 
 Y3_wide_chk_9 = Y3_wide_chk_8 INTERACT (WIDE_all_raw NOT INTERACT Y3_good_step8)
 Y3_comb_step9 = SIZE Y3_comb_step8 BY 0.07 INSIDE OF Y3_wide_chk_9 STEP 0.035 // step9: 0.385-0.07-0.035*7=0.07
 Y3_good_step9_a = Y3_comb_step9 INTERACT V5N >= 9
 Y3_good_step9_b = (Y3_comb_step9 INTERACT V5N >= 7) INTERACT RV5 >= 1
 Y3_good_step9_c = (Y3_comb_step9 INTERACT V5N >= 5) INTERACT RV5 >= 2
 Y3_good_step9_d = (Y3_comb_step9 INTERACT V5N >= 3) INTERACT RV5 >= 3
 Y3_good_step9_e = (Y3_comb_step9 INTERACT V5N >= 1) INTERACT RV5 >= 4
 Y3_good_step9_f = Y3_comb_step9 INTERACT RV5 >= 5
 Y3_good_step9 = OR Y3_good_step9_a Y3_good_step9_b Y3_good_step9_c Y3_good_step9_d Y3_good_step9_e Y3_good_step9_f
 Y3_good = WIDE_all_raw AND (OR Y3_good_step1 Y3_good_step2 Y3_good_step3 Y3_good_step4 Y3_good_step5 Y3_good_step6 Y3_good_step7 Y3_good_step8 Y3_good_step9)
 // 
 err1 = (WIDE_all_raw OUTSIDE (OR Y1_good Y2_good Y3_good)) INTERACT V5
 (err1 NOT INTERACT 125xv5_BAR) NOT INSIDE OCCD
}
 
Q: There should be at least two square 1.25xVn or one rectangular 1.25xVn in the intersection area of bottom metal and upper metal, when either wide metal 1.25xMy/1.25xMn or 1.25xMn+1 length >= 0.162um and width >= 0.162um, the space between either via and wide metal <= 1.48um (S, S is the shortest running path length from Via to the wide metal). (except via bar)
    DRC flags each intersecting area ({bottom metal AND upper metal}) with single square Via within the branch check region
A: 
125xRv5_R_4_M5 {
@ There should be at least two square 1.25xVn or one rectangular 1.25xVn in the intersection area of bottom metal and upper metal, when either wide metal 1.25xMy/1.25xMn or 1.25xMn+1 length >= 0.162um and width >= 0.162um, the space between either via and wide metal <= 1.48um (S, S is the shortest running path length from Via to the wide metal). (except via bar)
@ DRC flags each intersecting area ({bottom metal AND upper metal}) with single square Via within the branch check region
 wide_M5 = (WITH WIDTH M5 > 0.162-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 0.162-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 0.162-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M5_real = wide_M5 NOT OUTSIDE ((SIZE wide_M5 BY 1.48+GLOBAL_TOLERANCE) INTERACT V5)
 all_down_and_up = (M5 INTERACT wide_M5) AND M6
 dis_down_arm_wide_all = SIZE wide_M5_real BY 1.48+GLOBAL_TOLERANCE INSIDE OF M5 STEP 0.025
 dis_down_and_up = dis_down_arm_wide_all AND all_down_and_up
 dis_down_and_up_arm = (dis_down_and_up NOT wide_M5) AND M5
 dis_down_arm = (dis_down_arm_wide_all NOT wide_M5) AND M5
 // 
 dis_down_arm_good_a = dis_down_and_up_arm INTERACT V5N >= 2
 dis_down_arm_good_b = dis_down_and_up_arm INTERACT RV5
 dis_down_arm_good = OR dis_down_arm_good_a dis_down_arm_good_b
 dis_down_arm_bad = (dis_down_and_up_arm NOT dis_down_arm_good) INTERACT (all_down_and_up INTERACT V5N == 1)
 // 
 dis_down_arm_err_stack = (dis_down_arm_bad AND dis_down_and_up_arm) INTERACT V5N
 dis_down_arm_err = dis_down_arm INTERACT dis_down_arm_err_stack
 err1_met_down = (dis_down_arm_err INTERACT (V5N NOT OUTSIDE dis_down_arm_err)) NOT INTERACT RV5
 // 
 wide_M6 = (WITH WIDTH M6 > 0.162-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 0.162-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 0.162-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M6_real = wide_M6 NOT OUTSIDE ((SIZE wide_M6 BY 1.48+GLOBAL_TOLERANCE) INTERACT V5)
 all_up_and_down = (M6 INTERACT wide_M6) AND M5
 dis_up_arm_wide_all = SIZE wide_M6_real BY 1.48+GLOBAL_TOLERANCE INSIDE OF M6 STEP 0.025
 dis_up_and_down = dis_up_arm_wide_all AND all_up_and_down
 dis_up_and_down_arm = (dis_up_and_down NOT wide_M6) AND M6
 dis_up_arm = (dis_up_arm_wide_all NOT wide_M6) AND M6
 // 
 dis_up_arm_good_a = dis_up_and_down_arm INTERACT V5N >= 2
 dis_up_arm_good_b = dis_up_and_down_arm INTERACT RV5
 dis_up_arm_good = OR dis_up_arm_good_a dis_up_arm_good_b
 dis_up_arm_bad = (dis_up_and_down_arm NOT dis_up_arm_good) INTERACT (all_up_and_down INTERACT V5N == 1)
 // 
 dis_up_arm_err_stack = (dis_up_arm_bad AND dis_up_and_down_arm) INTERACT V5N
 dis_up_arm_err = dis_up_arm INTERACT dis_up_arm_err_stack
 err2_met_up = (dis_up_arm_err INTERACT (V5N NOT OUTSIDE dis_up_arm_err)) NOT INTERACT RV5
 err1_met_down NOT INTERACT 125xv5_BAR
}
 
Q: There should be at least two square 1.25xVn or one rectangular 1.25xVn in the intersection area of bottom metal and upper metal, when either wide metal 1.25xMy/1.25xMn or 1.25xMn+1 length >= 0.162um and width >= 0.162um, the space between either via and wide metal <= 1.48um (S, S is the shortest running path length from Via to the wide metal). (except via bar)
    DRC flags each intersecting area ({bottom metal AND upper metal}) with single square Via within the branch check region
A: 
125xRv5_R_4_M6 {
@ There should be at least two square 1.25xVn or one rectangular 1.25xVn in the intersection area of bottom metal and upper metal, when either wide metal 1.25xMy/1.25xMn or 1.25xMn+1 length >= 0.162um and width >= 0.162um, the space between either via and wide metal <= 1.48um (S, S is the shortest running path length from Via to the wide metal). (except via bar)
@ DRC flags each intersecting area ({bottom metal AND upper metal}) with single square Via within the branch check region
 wide_M5 = (WITH WIDTH M5 > 0.162-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 0.162-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 0.162-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M5_real = wide_M5 NOT OUTSIDE ((SIZE wide_M5 BY 1.48+GLOBAL_TOLERANCE) INTERACT V5)
 all_down_and_up = (M5 INTERACT wide_M5) AND M6
 dis_down_arm_wide_all = SIZE wide_M5_real BY 1.48+GLOBAL_TOLERANCE INSIDE OF M5 STEP 0.025
 dis_down_and_up = dis_down_arm_wide_all AND all_down_and_up
 dis_down_and_up_arm = (dis_down_and_up NOT wide_M5) AND M5
 dis_down_arm = (dis_down_arm_wide_all NOT wide_M5) AND M5
 // 
 dis_down_arm_good_a = dis_down_and_up_arm INTERACT V5N >= 2
 dis_down_arm_good_b = dis_down_and_up_arm INTERACT RV5
 dis_down_arm_good = OR dis_down_arm_good_a dis_down_arm_good_b
 dis_down_arm_bad = (dis_down_and_up_arm NOT dis_down_arm_good) INTERACT (all_down_and_up INTERACT V5N == 1)
 // 
 dis_down_arm_err_stack = (dis_down_arm_bad AND dis_down_and_up_arm) INTERACT V5N
 dis_down_arm_err = dis_down_arm INTERACT dis_down_arm_err_stack
 err1_met_down = (dis_down_arm_err INTERACT (V5N NOT OUTSIDE dis_down_arm_err)) NOT INTERACT RV5
 // 
 wide_M6 = (WITH WIDTH M6 > 0.162-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 0.162-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 0.162-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M6_real = wide_M6 NOT OUTSIDE ((SIZE wide_M6 BY 1.48+GLOBAL_TOLERANCE) INTERACT V5)
 all_up_and_down = (M6 INTERACT wide_M6) AND M5
 dis_up_arm_wide_all = SIZE wide_M6_real BY 1.48+GLOBAL_TOLERANCE INSIDE OF M6 STEP 0.025
 dis_up_and_down = dis_up_arm_wide_all AND all_up_and_down
 dis_up_and_down_arm = (dis_up_and_down NOT wide_M6) AND M6
 dis_up_arm = (dis_up_arm_wide_all NOT wide_M6) AND M6
 // 
 dis_up_arm_good_a = dis_up_and_down_arm INTERACT V5N >= 2
 dis_up_arm_good_b = dis_up_and_down_arm INTERACT RV5
 dis_up_arm_good = OR dis_up_arm_good_a dis_up_arm_good_b
 dis_up_arm_bad = (dis_up_and_down_arm NOT dis_up_arm_good) INTERACT (all_up_and_down INTERACT V5N == 1)
 // 
 dis_up_arm_err_stack = (dis_up_arm_bad AND dis_up_and_down_arm) INTERACT V5N
 dis_up_arm_err = dis_up_arm INTERACT dis_up_arm_err_stack
 err2_met_up = (dis_up_arm_err INTERACT (V5N NOT OUTSIDE dis_up_arm_err)) NOT INTERACT RV5
 err2_met_up NOT INTERACT 125xv5_BAR
}
 
Q: There should be at least two square 1.25xVn or one rectangular 1.25xVn in the intersection area of bottom metal and upper metal, when either wide metal 1.25xMy/1.25xMn or 1.25xMn+1 length >= 0.91um and width >= 0.91um, the space between either via and wide metal <= 3.59um (S, S is the shortest running path length from Via to the wide metal). (except via bar)
    DRC flags each intersecting area ({bottom metal AND upper metal}) with single square Via within the branch check region
A: 
125xRv5_R_5_M5 {
@ There should be at least two square 1.25xVn or one rectangular 1.25xVn in the intersection area of bottom metal and upper metal, when either wide metal 1.25xMy/1.25xMn or 1.25xMn+1 length >= 0.91um and width >= 0.91um, the space between either via and wide metal <= 3.59um (S, S is the shortest running path length from Via to the wide metal). (except via bar)
@ DRC flags each intersecting area ({bottom metal AND upper metal}) with single square Via within the branch check region
 wide_M5 = (WITH WIDTH M5 > 0.91-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 0.91-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 0.91-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M5_real = wide_M5 NOT OUTSIDE ((SIZE wide_M5 BY 3.59+GLOBAL_TOLERANCE) INTERACT V5)
 all_down_and_up = (M5 INTERACT wide_M5) AND M6
 dis_down_arm_wide_all = SIZE wide_M5_real BY 3.59+GLOBAL_TOLERANCE INSIDE OF M5 STEP 0.025
 dis_down_and_up = dis_down_arm_wide_all AND all_down_and_up
 dis_down_and_up_arm = (dis_down_and_up NOT wide_M5) AND M5
 dis_down_arm = (dis_down_arm_wide_all NOT wide_M5) AND M5
 // 
 dis_down_arm_good_a = dis_down_and_up_arm INTERACT V5N >= 2
 dis_down_arm_good_b = dis_down_and_up_arm INTERACT RV5
 dis_down_arm_good = OR dis_down_arm_good_a dis_down_arm_good_b
 dis_down_arm_bad = (dis_down_and_up_arm NOT dis_down_arm_good) INTERACT (all_down_and_up INTERACT V5N == 1)
 // 
 dis_down_arm_err_stack = (dis_down_arm_bad AND dis_down_and_up_arm) INTERACT V5N
 dis_down_arm_err = dis_down_arm INTERACT dis_down_arm_err_stack
 err1_met_down = (dis_down_arm_err INTERACT (V5N NOT OUTSIDE dis_down_arm_err)) NOT INTERACT RV5
 // 
 wide_M6 = (WITH WIDTH M6 > 0.91-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 0.91-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 0.91-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M6_real = wide_M6 NOT OUTSIDE ((SIZE wide_M6 BY 3.59+GLOBAL_TOLERANCE) INTERACT V5)
 all_up_and_down = (M6 INTERACT wide_M6) AND M5
 dis_up_arm_wide_all = SIZE wide_M6_real BY 3.59+GLOBAL_TOLERANCE INSIDE OF M6 STEP 0.025
 dis_up_and_down = dis_up_arm_wide_all AND all_up_and_down
 dis_up_and_down_arm = (dis_up_and_down NOT wide_M6) AND M6
 dis_up_arm = (dis_up_arm_wide_all NOT wide_M6) AND M6
 // 
 dis_up_arm_good_a = dis_up_and_down_arm INTERACT V5N >= 2
 dis_up_arm_good_b = dis_up_and_down_arm INTERACT RV5
 dis_up_arm_good = OR dis_up_arm_good_a dis_up_arm_good_b
 dis_up_arm_bad = (dis_up_and_down_arm NOT dis_up_arm_good) INTERACT (all_up_and_down INTERACT V5N == 1)
 // 
 dis_up_arm_err_stack = (dis_up_arm_bad AND dis_up_and_down_arm) INTERACT V5N
 dis_up_arm_err = dis_up_arm INTERACT dis_up_arm_err_stack
 err2_met_up = (dis_up_arm_err INTERACT (V5N NOT OUTSIDE dis_up_arm_err)) NOT INTERACT RV5
 err1_met_down NOT INTERACT 125xv5_BAR
}
 
Q: There should be at least two square 1.25xVn or one rectangular 1.25xVn in the intersection area of bottom metal and upper metal, when either wide metal 1.25xMy/1.25xMn or 1.25xMn+1 length >= 0.91um and width >= 0.91um, the space between either via and wide metal <= 3.59um (S, S is the shortest running path length from Via to the wide metal). (except via bar)
    DRC flags each intersecting area ({bottom metal AND upper metal}) with single square Via within the branch check region
A: 
125xRv5_R_5_M6 {
@ There should be at least two square 1.25xVn or one rectangular 1.25xVn in the intersection area of bottom metal and upper metal, when either wide metal 1.25xMy/1.25xMn or 1.25xMn+1 length >= 0.91um and width >= 0.91um, the space between either via and wide metal <= 3.59um (S, S is the shortest running path length from Via to the wide metal). (except via bar)
@ DRC flags each intersecting area ({bottom metal AND upper metal}) with single square Via within the branch check region
 wide_M5 = (WITH WIDTH M5 > 0.91-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 0.91-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 0.91-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M5_real = wide_M5 NOT OUTSIDE ((SIZE wide_M5 BY 3.59+GLOBAL_TOLERANCE) INTERACT V5)
 all_down_and_up = (M5 INTERACT wide_M5) AND M6
 dis_down_arm_wide_all = SIZE wide_M5_real BY 3.59+GLOBAL_TOLERANCE INSIDE OF M5 STEP 0.025
 dis_down_and_up = dis_down_arm_wide_all AND all_down_and_up
 dis_down_and_up_arm = (dis_down_and_up NOT wide_M5) AND M5
 dis_down_arm = (dis_down_arm_wide_all NOT wide_M5) AND M5
 // 
 dis_down_arm_good_a = dis_down_and_up_arm INTERACT V5N >= 2
 dis_down_arm_good_b = dis_down_and_up_arm INTERACT RV5
 dis_down_arm_good = OR dis_down_arm_good_a dis_down_arm_good_b
 dis_down_arm_bad = (dis_down_and_up_arm NOT dis_down_arm_good) INTERACT (all_down_and_up INTERACT V5N == 1)
 // 
 dis_down_arm_err_stack = (dis_down_arm_bad AND dis_down_and_up_arm) INTERACT V5N
 dis_down_arm_err = dis_down_arm INTERACT dis_down_arm_err_stack
 err1_met_down = (dis_down_arm_err INTERACT (V5N NOT OUTSIDE dis_down_arm_err)) NOT INTERACT RV5
 // 
 wide_M6 = (WITH WIDTH M6 > 0.91-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 0.91-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 0.91-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M6_real = wide_M6 NOT OUTSIDE ((SIZE wide_M6 BY 3.59+GLOBAL_TOLERANCE) INTERACT V5)
 all_up_and_down = (M6 INTERACT wide_M6) AND M5
 dis_up_arm_wide_all = SIZE wide_M6_real BY 3.59+GLOBAL_TOLERANCE INSIDE OF M6 STEP 0.025
 dis_up_and_down = dis_up_arm_wide_all AND all_up_and_down
 dis_up_and_down_arm = (dis_up_and_down NOT wide_M6) AND M6
 dis_up_arm = (dis_up_arm_wide_all NOT wide_M6) AND M6
 // 
 dis_up_arm_good_a = dis_up_and_down_arm INTERACT V5N >= 2
 dis_up_arm_good_b = dis_up_and_down_arm INTERACT RV5
 dis_up_arm_good = OR dis_up_arm_good_a dis_up_arm_good_b
 dis_up_arm_bad = (dis_up_and_down_arm NOT dis_up_arm_good) INTERACT (all_up_and_down INTERACT V5N == 1)
 // 
 dis_up_arm_err_stack = (dis_up_arm_bad AND dis_up_and_down_arm) INTERACT V5N
 dis_up_arm_err = dis_up_arm INTERACT dis_up_arm_err_stack
 err2_met_up = (dis_up_arm_err INTERACT (V5N NOT OUTSIDE dis_up_arm_err)) NOT INTERACT RV5
 err2_met_up NOT INTERACT 125xv5_BAR
}
 
Q: There should be at least two square 1.25xVn or one rectangular 1.25xVn in the intersection area of bottom metal and upper metal, when either wide metal 1.25xMy/1.25xMn or 1.25xMn+1 length >= 1.36um and width >= 1.36um, the space between either via and wide metal <= 9um (S, S is the shortest running path length from Via to the wide metal). (except via bar)
    DRC flags each intersecting area ({bottom metal AND upper metal}) with single square Via within the branch check region
A: 
125xRv5_R_6_M5 {
@ There should be at least two square 1.25xVn or one rectangular 1.25xVn in the intersection area of bottom metal and upper metal, when either wide metal 1.25xMy/1.25xMn or 1.25xMn+1 length >= 1.36um and width >= 1.36um, the space between either via and wide metal <= 9um (S, S is the shortest running path length from Via to the wide metal). (except via bar)
@ DRC flags each intersecting area ({bottom metal AND upper metal}) with single square Via within the branch check region
 wide_M5 = (WITH WIDTH M5 > 1.36-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 1.36-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 1.36-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M5_real = wide_M5 NOT OUTSIDE ((SIZE wide_M5 BY 9+GLOBAL_TOLERANCE) INTERACT V5)
 all_down_and_up = (M5 INTERACT wide_M5) AND M6
 dis_down_arm_wide_all = SIZE wide_M5_real BY 9+GLOBAL_TOLERANCE INSIDE OF M5 STEP 0.025
 dis_down_and_up = dis_down_arm_wide_all AND all_down_and_up
 dis_down_and_up_arm = (dis_down_and_up NOT wide_M5) AND M5
 dis_down_arm = (dis_down_arm_wide_all NOT wide_M5) AND M5
 // 
 dis_down_arm_good_a = dis_down_and_up_arm INTERACT V5N >= 2
 dis_down_arm_good_b = dis_down_and_up_arm INTERACT RV5
 dis_down_arm_good = OR dis_down_arm_good_a dis_down_arm_good_b
 dis_down_arm_bad = (dis_down_and_up_arm NOT dis_down_arm_good) INTERACT (all_down_and_up INTERACT V5N == 1)
 // 
 dis_down_arm_err_stack = (dis_down_arm_bad AND dis_down_and_up_arm) INTERACT V5N
 dis_down_arm_err = dis_down_arm INTERACT dis_down_arm_err_stack
 err1_met_down = (dis_down_arm_err INTERACT (V5N NOT OUTSIDE dis_down_arm_err)) NOT INTERACT RV5
 // 
 wide_M6 = (WITH WIDTH M6 > 1.36-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 1.36-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 1.36-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M6_real = wide_M6 NOT OUTSIDE ((SIZE wide_M6 BY 9+GLOBAL_TOLERANCE) INTERACT V5)
 all_up_and_down = (M6 INTERACT wide_M6) AND M5
 dis_up_arm_wide_all = SIZE wide_M6_real BY 9+GLOBAL_TOLERANCE INSIDE OF M6 STEP 0.025
 dis_up_and_down = dis_up_arm_wide_all AND all_up_and_down
 dis_up_and_down_arm = (dis_up_and_down NOT wide_M6) AND M6
 dis_up_arm = (dis_up_arm_wide_all NOT wide_M6) AND M6
 // 
 dis_up_arm_good_a = dis_up_and_down_arm INTERACT V5N >= 2
 dis_up_arm_good_b = dis_up_and_down_arm INTERACT RV5
 dis_up_arm_good = OR dis_up_arm_good_a dis_up_arm_good_b
 dis_up_arm_bad = (dis_up_and_down_arm NOT dis_up_arm_good) INTERACT (all_up_and_down INTERACT V5N == 1)
 // 
 dis_up_arm_err_stack = (dis_up_arm_bad AND dis_up_and_down_arm) INTERACT V5N
 dis_up_arm_err = dis_up_arm INTERACT dis_up_arm_err_stack
 err2_met_up = (dis_up_arm_err INTERACT (V5N NOT OUTSIDE dis_up_arm_err)) NOT INTERACT RV5
 err1_met_down NOT INTERACT 125xv5_BAR
}
 
Q: There should be at least two square 1.25xVn or one rectangular 1.25xVn in the intersection area of bottom metal and upper metal, when either wide metal 1.25xMy/1.25xMn or 1.25xMn+1 length >= 1.36um and width >= 1.36um, the space between either via and wide metal <= 9um (S, S is the shortest running path length from Via to the wide metal). (except via bar)
    DRC flags each intersecting area ({bottom metal AND upper metal}) with single square Via within the branch check region
A: 
125xRv5_R_6_M6 {
@ There should be at least two square 1.25xVn or one rectangular 1.25xVn in the intersection area of bottom metal and upper metal, when either wide metal 1.25xMy/1.25xMn or 1.25xMn+1 length >= 1.36um and width >= 1.36um, the space between either via and wide metal <= 9um (S, S is the shortest running path length from Via to the wide metal). (except via bar)
@ DRC flags each intersecting area ({bottom metal AND upper metal}) with single square Via within the branch check region
 wide_M5 = (WITH WIDTH M5 > 1.36-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 1.36-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 1.36-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M5_real = wide_M5 NOT OUTSIDE ((SIZE wide_M5 BY 9+GLOBAL_TOLERANCE) INTERACT V5)
 all_down_and_up = (M5 INTERACT wide_M5) AND M6
 dis_down_arm_wide_all = SIZE wide_M5_real BY 9+GLOBAL_TOLERANCE INSIDE OF M5 STEP 0.025
 dis_down_and_up = dis_down_arm_wide_all AND all_down_and_up
 dis_down_and_up_arm = (dis_down_and_up NOT wide_M5) AND M5
 dis_down_arm = (dis_down_arm_wide_all NOT wide_M5) AND M5
 // 
 dis_down_arm_good_a = dis_down_and_up_arm INTERACT V5N >= 2
 dis_down_arm_good_b = dis_down_and_up_arm INTERACT RV5
 dis_down_arm_good = OR dis_down_arm_good_a dis_down_arm_good_b
 dis_down_arm_bad = (dis_down_and_up_arm NOT dis_down_arm_good) INTERACT (all_down_and_up INTERACT V5N == 1)
 // 
 dis_down_arm_err_stack = (dis_down_arm_bad AND dis_down_and_up_arm) INTERACT V5N
 dis_down_arm_err = dis_down_arm INTERACT dis_down_arm_err_stack
 err1_met_down = (dis_down_arm_err INTERACT (V5N NOT OUTSIDE dis_down_arm_err)) NOT INTERACT RV5
 // 
 wide_M6 = (WITH WIDTH M6 > 1.36-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 1.36-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 1.36-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M6_real = wide_M6 NOT OUTSIDE ((SIZE wide_M6 BY 9+GLOBAL_TOLERANCE) INTERACT V5)
 all_up_and_down = (M6 INTERACT wide_M6) AND M5
 dis_up_arm_wide_all = SIZE wide_M6_real BY 9+GLOBAL_TOLERANCE INSIDE OF M6 STEP 0.025
 dis_up_and_down = dis_up_arm_wide_all AND all_up_and_down
 dis_up_and_down_arm = (dis_up_and_down NOT wide_M6) AND M6
 dis_up_arm = (dis_up_arm_wide_all NOT wide_M6) AND M6
 // 
 dis_up_arm_good_a = dis_up_and_down_arm INTERACT V5N >= 2
 dis_up_arm_good_b = dis_up_and_down_arm INTERACT RV5
 dis_up_arm_good = OR dis_up_arm_good_a dis_up_arm_good_b
 dis_up_arm_bad = (dis_up_and_down_arm NOT dis_up_arm_good) INTERACT (all_up_and_down INTERACT V5N == 1)
 // 
 dis_up_arm_err_stack = (dis_up_arm_bad AND dis_up_and_down_arm) INTERACT V5N
 dis_up_arm_err = dis_up_arm INTERACT dis_up_arm_err_stack
 err2_met_up = (dis_up_arm_err INTERACT (V5N NOT OUTSIDE dis_up_arm_err)) NOT INTERACT RV5
 err2_met_up NOT INTERACT 125xv5_BAR
}
 
Q: 45-degree 1.25xRVn is not allowed
A: 
125xRv5_R_7 {
@ 45-degree 1.25xRVn is not allowed
 err1 = ANGLE (V5 NOT 125xv5_BAR) > 44.5 < 45.5
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 

#IFDEF Delta_Voltage_Rules_Check YES

Q: Maximum delta V >= 5.6V is not allowed, when space between 1.25xRVn is < 0.410um
A: 
125xRv5_R_8 {
@ Maximum delta V >= 5.6V is not allowed, when space between 1.25xRVn is < 0.410um
 chk_VIA = V5 INTERACT DVK_V5_RE
 err1 = DFM DV chk_VIA V5 < 0.410 DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" >= 5.6 ANNOTATE NOT CONNECTED SINGULAR
 DFM COPY err1
}


//125xv6


Q: 45-degree 1.25xVn is not allowed
A: 
125xv6_R_1 {
@ 45-degree 1.25xVn is not allowed
 err1 = ANGLE (V6 NOT 125xv6_BAR) > 44.5 < 45.5
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
Q: It is not allowed to have single 1.25xVn in "H-shape" 1.25xMn+1 when all of the following conditions come into existence:
    1) The 1.25xMn+1 has "H-shape" interact two metal holes: both two metal hole length <= 4.5um and two metal hole area <= 4.05um2
    2) The 1.25xVn overlaps on the center metal bar of this "H-shape" 1.25xMn+1
    3) The center metal bar length <= 0.9um and the metal bar width <= 0.162um
A: 
125xv6_R_2 {
@ It is not allowed to have single 1.25xVn in "H-shape" 1.25xMn+1 when all of the following conditions come into existence:
@ 1) The 1.25xMn+1 has "H-shape" interact two metal holes: both two metal hole length <= 4.5um and two metal hole area <= 4.05um2
@ 2) The 1.25xVn overlaps on the center metal bar of this "H-shape" 1.25xMn+1
@ 3) The center metal bar length <= 0.9um and the metal bar width <= 0.162um
 hole_area_meet = AREA (HOLES M7 INNER) <= 4.05
 hole_area_meet_len = (hole_area_meet WITH EDGE (LENGTH hole_area_meet <= 0.9)) NOT WITH EDGE (LENGTH hole_area_meet > 4.5)
 hole_area_real = (hole_area_meet_len NOT ENCLOSE RECTANGLE 0.9+GLOBAL_TOLERANCE 4.5) NOT ENCLOSE RECTANGLE 0.9 4.5+GLOBAL_TOLERANCE
 hole_bars_len = M7 COIN EDGE hole_area_real
 // 
 hole_bars = INT hole_bars_len <= 0.162 ABUT<90 OPPOSITE REGION EXCLUDE SHIELDED
 hole_bars_real = hole_bars WITH EDGE (LENGTH hole_bars_len <= 0.9)
 hole_bars_vias_sq = V6N INTERACT ((hole_bars_real INTERACT hole_area_real == 2) NOT ENCLOSE RV6)
 err1 = hole_bars_real INTERACT hole_bars_vias_sq == 1
 err1 NOT INSIDE SealR_NOT_BULK
}
 
Q: The numbers of neighboring square 1.25xVn to each edge of 1.25xVn <= 0.065um is not allowed < 2
A: 
125xv6_R_3 {
@ The numbers of neighboring square 1.25xVn to each edge of 1.25xVn <= 0.065um is not allowed < 2
 // based on 125xVn.S.6 and 125xVn.S.1, so only check the space range 0.056~0.065um with PRL <= 0.04
 Y1 = EXT V6N >= 0.056 <= 0.065 ABUT CORNER TO CORNER
 Y2 = DFM PROPERTY Y1 [-= (EWXP(Y1) > 0.040 && EWYP(Y1) > 0.040) ? 1 : 0] > 0
 Y3 = INT [V6N] < 0.001 ABUT INTERSECTING ONLY
 Y4 = Y3 COIN EDGE (DFM COPY Y2 EDGE)
 Y5 = INT Y4 V6N < 0.001 ABUT==90 INTERSECTING ONLY REGION
 Y6 = INT (V6N COIN EDGE Y5) == 0.040 OPPOSITE REGION
 err1 = V6N INTERACT Y6
 err1 NOT INSIDE SealR_NOT_BULK
}
 
Q: The numbers of neighboring square 1.25xVn in one group (space <= 0.065um) <= 3
A: 
125xv6_R_4 {
@ The numbers of neighboring square 1.25xVn in one group (space <= 0.065um) <= 3
 err1 = WITH NEIGHBOR V6N > 2 SPACE <= 0.065
 err1 NOT INSIDE SealR_NOT_BULK
}
 

#IFDEF Delta_Voltage_Rules_Check YES

Q: Maximum delta V >= 5.6V is not allowed, when space between 1.25xVn is < 0.410um
A: 
125xv6_R_5 {
@ Maximum delta V >= 5.6V is not allowed, when space between 1.25xVn is < 0.410um
 chk_VIA = V6 INTERACT DVK_V6_SQ
 err1 = DFM DV chk_VIA V6 < 0.410 DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" >= 5.6 ANNOTATE NOT CONNECTED SINGULAR
 DFM COPY err1
}

#ENDIF

// 1.25xVn.R.8[NC] 1.25xVn pattern must be drawn on data type 50
 
Q: It's not allowed 1.25xVn overlap with the metal resistor directly underneath and above the 1.25xVn
A: 
125xv6_R_9 {
@ It's not allowed 1.25xVn overlap with the metal resistor directly underneath and above the 1.25xVn
 err1 = V6 AND (M6RES AND M6)
 err2 = V6 AND (M7RES AND M7)
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

#IFDEF RECOMMENDED_CHECK YES

 
Q: Recommend space between a square 1.25xVn and another (1.25xVn OR 1.25xRVn OR DUM_1.25xVn) < 4um to avoid single square 1.25xVn
A: 
125xv6_R_10_R {
@ Recommend space between a square 1.25xVn and another (1.25xVn OR 1.25xRVn OR DUM_1.25xVn) < 4um to avoid single square 1.25xVn
 ALL_VIA_CHECK = OR V6_SR V6DUM_all V6DOP_all
 STEP_1 = SIZE V6_SR BY 1.4
 // 4/1.414 = 2.828
 STEP_1_GOOD = STEP_1 INTERACT ALL_VIA_CHECK > 1
 STEP_1_FILTER = V6N NOT INTERACT STEP_1_GOOD
 err1 = STEP_1_FILTER NOT WITH EDGE (EXT [STEP_1_FILTER] ALL_VIA_CHECK < 4 PERP ALSO)
 err1 NOT INSIDE SealR_NOT_BULK
}

//125xRv6

Q: Single 1.25xRVn is not allowed in "H-shape" 1.25xMn+1, when:
    1. The 1.25xMn+1 has "H-shape" interacting with two metal holes: both two metal holes length <= 4.5um and two metal hole area <= 4.05um2
    2. The 1.25xRVn overlaps on the center metal bar of this "H-shape" 1.25xMn+1
    3. The center metal bar length <= 0.9um and the metal bar width <= 0.162um
    DRC doesn't check when one or more square 1.25xRVn is also on H-shape 1.25xMn+1 region
A: 
125xRv6_R_1 {
@ Single 1.25xRVn is not allowed in "H-shape" 1.25xMn+1, when:
@ 1. The 1.25xMn+1 has "H-shape" interacting with two metal holes: both two metal holes length <= 4.5um and two metal hole area <= 4.05um2
@ 2. The 1.25xRVn overlaps on the center metal bar of this "H-shape" 1.25xMn+1
@ 3. The center metal bar length <= 0.9um and the metal bar width <= 0.162um
@ DRC doesn't check when one or more square 1.25xRVn is also on H-shape 1.25xMn+1 region
 hole_area_meet = AREA (HOLES M7 INNER) <= 4.05
 hole_area_meet_len = (hole_area_meet WITH EDGE (LENGTH hole_area_meet <= 0.9)) NOT WITH EDGE (LENGTH hole_area_meet > 4.5)
 hole_area_real = (hole_area_meet_len NOT ENCLOSE RECTANGLE 0.9+GLOBAL_TOLERANCE 4.5) NOT ENCLOSE RECTANGLE 0.9 4.5+GLOBAL_TOLERANCE
 hole_bars_len = M7 COIN EDGE hole_area_real
 // 
 hole_bars = INT hole_bars_len <= 0.162 ABUT<90 OPPOSITE REGION EXCLUDE SHIELDED
 hole_bars_real = hole_bars WITH EDGE (LENGTH hole_bars_len <= 0.9)
 hole_bars_vias_rect = RV6 INTERACT ((hole_bars_real INTERACT hole_area_real == 2) NOT ENCLOSE V6N >= 2)
 err1 = hole_bars_real INTERACT hole_bars_vias_rect == 1
 err1 NOT INSIDE SealR_NOT_BULK
}
 
Q: Redundant via requirement must be obeyed by one of following conditions of via numbers and space for 1.25xMy/1.25xMn, 1.25xMn+1 connection (one of 1.25xMy/1.25xMn or 1.25xMn+1 have width and length >= 0.164um, two square vias are equal to one rectangular via for below conditions) (Except VIA bar)
    1) At least one rectangular 1.25xVn
    2) At least two square 1.25xVn with space <= 0.091um
    3) At least four square 1.25xVn with space <= 0.59um
A: 
125xRv6_R_2 {
@ Redundant via requirement must be obeyed by one of following conditions of via numbers and space for 1.25xMy/1.25xMn, 1.25xMn+1 connection (one of 1.25xMy/1.25xMn or 1.25xMn+1 have width and length >= 0.164um, two square vias are equal to one rectangular via for below conditions) (Except VIA bar)
@ 1) At least one rectangular 1.25xVn
@ 2) At least two square 1.25xVn with space <= 0.091um
@ 3) At least four square 1.25xVn with space <= 0.59um
 X1a = WITH WIDTH M6 > 0.164-GLOBAL_TOLERANCE <= 0.398-GLOBAL_TOLERANCE
 X1b = WITH WIDTH M7 > 0.164-GLOBAL_TOLERANCE <= 0.398-GLOBAL_TOLERANCE
 Y1a = WITH WIDTH M6 > 0.398-GLOBAL_TOLERANCE
 Y1b = WITH WIDTH M7 > 0.398-GLOBAL_TOLERANCE
 WIDE_1 = (X1a AND M7) ENCLOSE V6
 WIDE_2 = (M6 AND X1b) ENCLOSE V6
 WIDE_3 = (Y1a AND M7) ENCLOSE V6
 WIDE_4 = (M6 AND Y1b) ENCLOSE V6
 WIDE_all_raw = (WIDE_1 OR WIDE_2) NOT (WIDE_3 OR WIDE_4)
 WIDE_all = (M6 AND M7) NOT OUTSIDE WIDE_all_raw
 // 
 // condition 1
 Y1_good = WIDE_all_raw AND RV6
 // condition 2
 Y2_wide_all = WIDE_all_raw NOT INTERACT Y1_good
 Y2_wide = (WIDE_all INTERACT Y2_wide_all) INTERACT V6_SR >= 2
 Y2_comb_step = SIZE V6_SR BY 0.091/2 INSIDE OF Y2_wide STEP 0.030
 Y2_good_step = OR (Y2_comb_step INTERACT V6N >= 2) (Y2_comb_step INTERACT RV6)
 Y2_good = WIDE_all_raw AND Y2_good_step
 // 
 // condition 3
 Y3_wide_all = WIDE_all_raw NOT INTERACT (OR Y1_good Y2_good)
 Y3_wide = (WIDE_all INTERACT Y3_wide_all) INTERACT V6_SR >= 2 // rectangle array 0.59/2=0.295
 Y3_vias_input = V6_SR AND Y3_wide
 Y3_wide_chk_1 = Y3_wide INTERACT Y3_wide_all
 Y3_comb_step1 = SIZE Y3_vias_input BY 0.04 INSIDE OF Y3_wide_chk_1 STEP 0.04 // via minimum space = 0.075
 Y3_good_step1 = OR (Y3_comb_step1 INTERACT V6N >= 4) (Y3_comb_step1 INTERACT RV6) // step1: 0.050
 // 
 Y3_wide_chk_2 = Y3_wide_chk_1 INTERACT (WIDE_all_raw NOT INTERACT Y3_good_step1)
 Y3_comb_step2 = SIZE Y3_comb_step1 BY 0.04 INSIDE OF Y3_wide_chk_2 STEP 0.04
 Y3_good_step2 = OR (Y3_comb_step2 INTERACT V6N >= 4) (Y3_comb_step2 INTERACT RV6) // step2: 0.04
 // 
 Y3_wide_chk_3 = Y3_wide_chk_2 INTERACT (WIDE_all_raw NOT INTERACT Y3_good_step2)
 Y3_comb_step3 = SIZE Y3_comb_step2 BY 0.04 INSIDE OF Y3_wide_chk_3 STEP 0.04
 Y3_good_step3 = OR (Y3_comb_step3 INTERACT V6N >= 4) (Y3_comb_step3 INTERACT RV6) // step3: 0.04
 // 
 Y3_wide_chk_4 = Y3_wide_chk_3 INTERACT (WIDE_all_raw NOT INTERACT Y3_good_step3)
 Y3_comb_step4 = SIZE Y3_comb_step3 BY 0.04 INSIDE OF Y3_wide_chk_4 STEP 0.04
 Y3_good_step4 = OR (Y3_comb_step4 INTERACT V6N >= 4) (Y3_comb_step4 INTERACT RV6) // step4: 0.04
 // 
 Y3_wide_chk_5 = Y3_wide_chk_4 INTERACT (WIDE_all_raw NOT INTERACT Y3_good_step4)
 Y3_comb_step5 = SIZE Y3_comb_step4 BY 0.04 INSIDE OF Y3_wide_chk_5 STEP 0.04
 Y3_good_step5 = OR (Y3_comb_step5 INTERACT V6N >= 4) (Y3_comb_step5 INTERACT RV6) // step5: 0.04
 // 
 Y3_wide_chk_6 = Y3_wide_chk_5 INTERACT (WIDE_all_raw NOT INTERACT Y3_good_step5)
 Y3_comb_step6 = SIZE Y3_comb_step5 BY 0.04 INSIDE OF Y3_wide_chk_6 STEP 0.04
 Y3_good_step6 = OR (Y3_comb_step6 INTERACT V6N >= 4) (Y3_comb_step6 INTERACT RV6) // step6: 0.04
 // 
 Y3_wide_chk_7 = Y3_wide_chk_6 INTERACT (WIDE_all_raw NOT INTERACT Y3_good_step6)
 Y3_comb_step7 = SIZE Y3_comb_step6 BY 0.04 INSIDE OF Y3_wide_chk_7 STEP 0.04
 Y3_good_step7 = OR (Y3_comb_step7 INTERACT V6N >= 4) (Y3_comb_step7 INTERACT RV6) // step7: 0.04
 // 
 Y3_wide_chk_8 = Y3_wide_chk_7 INTERACT (WIDE_all_raw NOT INTERACT Y3_good_step7)
 Y3_comb_step8 = SIZE Y3_comb_step7 BY 0.015 INSIDE OF Y3_wide_chk_8 STEP 0.015
 Y3_good_step8 = OR (Y3_comb_step8 INTERACT V6N >= 4) (Y3_comb_step8 INTERACT RV6) // step8: 0.295-0.04*7=0.015
 Y3_good = WIDE_all_raw AND (OR Y3_good_step1 Y3_good_step2 Y3_good_step3 Y3_good_step4 Y3_good_step5 Y3_good_step6 Y3_good_step7 Y3_good_step8)
 // 
 err1 = (WIDE_all_raw OUTSIDE (OR Y1_good Y2_good Y3_good)) INTERACT V6
 err1 NOT INTERACT 125xv6_BAR
}
 
Q: Redundant via requirement must be obeyed by one of following conditions of 1.25xVn numbers and space for 1.25xMy/1.25xMn and 1.25xMn+1 connection (one of 1.25xMy/1.25xMn or 1.25xMn+1 have width and length >= 0.398um, two square vias are equal to one rectangular via for below conditions), except VIA bar, OCCD region
     1) At least 4 square 1.25xVn with space <= 0.091um
     2) At least 2 square 1.25xVn and 1 rectangular 1.25xVn with space <= 0.118um
     3) At least 9 square 1.25xVn with space <= 0.77um
    For condition 2) and 3) 2 square 1.25xVn can be replaced by 1 rectangular 1.25xVn
A: 
125xRv6_R_3 {
@ Redundant via requirement must be obeyed by one of following conditions of 1.25xVn numbers and space for 1.25xMy/1.25xMn and 1.25xMn+1 connection (one of 1.25xMy/1.25xMn or 1.25xMn+1 have width and length >= 0.398um, two square vias are equal to one rectangular via for below conditions), except VIA bar, OCCD region
@ 1) At least 4 square 1.25xVn with space <= 0.091um
@ 2) At least 2 square 1.25xVn and 1 rectangular 1.25xVn with space <= 0.118um
@ 3) At least 9 square 1.25xVn with space <= 0.77um
@ For condition 2) and 3) 2 square 1.25xVn can be replaced by 1 rectangular 1.25xVn
 X1a = WITH WIDTH M6 > 0.398-GLOBAL_TOLERANCE
 X1b = WITH WIDTH M7 > 0.398-GLOBAL_TOLERANCE
 WIDE_1 = (X1a AND M7) ENCLOSE V6
 WIDE_2 = (M6 AND X1b) ENCLOSE V6
 WIDE_all_raw = WIDE_1 OR WIDE_2
 WIDE_all = (M6 AND M7) NOT OUTSIDE WIDE_all_raw
 // 
 // condition 1
 Y2_wide = WIDE_all INTERACT V6N >= 4
 Y2_vias_input = V6N AND Y2_wide
 Y2_wide_chk_1 = COPY Y2_wide // rectangle array 0.09/2=0.0455
 Y2_comb_step1 = SIZE Y2_vias_input BY 0.030 INSIDE OF Y2_wide_chk_1 STEP 0.030 // step1: 0.030, via minimum space = 0.056
 Y2_good_step1 = Y2_comb_step1 INTERACT V6N >= 4
 // 
 Y2_wide_chk_2 = Y2_wide_chk_1 INTERACT (WIDE_all_raw NOT INTERACT Y2_good_step1)
 Y2_comb_step2 = SIZE Y2_comb_step1 BY 0.0155 INSIDE OF Y2_wide_chk_2 STEP 0.015 // step2: 0.0155
 Y2_good_step2 = Y2_comb_step2 INTERACT V6N >= 4
 Y2_good = WIDE_all_raw AND (OR Y2_good_step1 Y2_good_step2)
 // 
 // condition 2
 Y1_wide_all = WIDE_all_raw NOT INTERACT Y2_good // rectangle array 0.118/2=0.059
 Y1_wide = (WIDE_all INTERACT Y1_wide_all) INTERACT V6 >= 2
 Y1_vias_input = V6 AND Y1_wide
 Y1_wide_chk_1 = Y1_wide INTERACT Y1_wide_all
 Y1_comb_step1 = SIZE Y1_vias_input BY 0.030 INSIDE OF Y1_wide_chk_1 STEP 0.030 // step1: 0.030, via minimum space = 0.100
 Y1_good_step1_a = Y1_comb_step1 INTERACT RV6 >= 2
 Y1_good_step1_b = (Y1_comb_step1 INTERACT V6N >= 2) INTERACT RV6 >= 1
 Y1_good_step1 = OR Y1_good_step1_a Y1_good_step1_b
 // 
 Y1_wide_chk_2 = Y1_wide_chk_1 INTERACT (WIDE_all_raw NOT INTERACT Y1_good_step1)
 Y1_comb_step2 = SIZE Y1_comb_step1 BY 0.029 INSIDE OF Y1_wide_chk_2 STEP 0.025 // step2: 0.059-0.030=0.029
 Y1_good_step2_a = Y1_comb_step2 INTERACT RV6 >= 2
 Y1_good_step2_b = (Y1_comb_step2 INTERACT V6N >= 2) INTERACT RV6 >= 1
 Y1_good_step2 = OR Y1_good_step2_a Y1_good_step2_b
 Y1_good = WIDE_all_raw AND (OR Y1_good_step1 Y1_good_step2)
 // 
 // condition 3
 Y3_wide_all = WIDE_all_raw NOT INTERACT (OR Y2_good Y1_good)
 Y3_wide = (WIDE_all INTERACT Y3_wide_all) INTERACT V6 >= 5
 Y3_vias_input = V6N AND Y3_wide
 Y3_wide_chk_1 = Y3_wide INTERACT Y3_wide_all // rectangle array 0.77/2=0.385
 Y3_comb_step1 = SIZE Y3_vias_input BY 0.070 INSIDE OF Y3_wide_chk_1 STEP 0.035 // step1: 0.070, via minimum space = 0.056
 Y3_good_step1_a = Y3_comb_step1 INTERACT V6N >= 9
 Y3_good_step1_b = (Y3_comb_step1 INTERACT V6N >= 7) INTERACT RV6 >= 1
 Y3_good_step1_c = (Y3_comb_step1 INTERACT V6N >= 5) INTERACT RV6 >= 2
 Y3_good_step1_d = (Y3_comb_step1 INTERACT V6N >= 3) INTERACT RV6 >= 3
 Y3_good_step1_e = (Y3_comb_step1 INTERACT V6N >= 1) INTERACT RV6 >= 4
 Y3_good_step1_f = Y3_comb_step1 INTERACT RV6 >= 5
 Y3_good_step1 = OR Y3_good_step1_a Y3_good_step1_b Y3_good_step1_c Y3_good_step1_d Y3_good_step1_e Y3_good_step1_f
 // 
 Y3_wide_chk_2 = Y3_wide_chk_1 INTERACT (WIDE_all_raw NOT INTERACT Y3_good_step1)
 Y3_comb_step2 = SIZE Y3_comb_step1 BY 0.035 INSIDE OF Y3_wide_chk_2 STEP 0.035 // step2: 0.035
 Y3_good_step2_a = Y3_comb_step2 INTERACT V6N >= 9
 Y3_good_step2_b = (Y3_comb_step2 INTERACT V6N >= 7) INTERACT RV6 >= 1
 Y3_good_step2_c = (Y3_comb_step2 INTERACT V6N >= 5) INTERACT RV6 >= 2
 Y3_good_step2_d = (Y3_comb_step2 INTERACT V6N >= 3) INTERACT RV6 >= 3
 Y3_good_step2_e = (Y3_comb_step2 INTERACT V6N >= 1) INTERACT RV6 >= 4
 Y3_good_step2_f = Y3_comb_step2 INTERACT RV6 >= 5
 Y3_good_step2 = OR Y3_good_step2_a Y3_good_step2_b Y3_good_step2_c Y3_good_step2_d Y3_good_step2_e Y3_good_step2_f
 // 
 Y3_wide_chk_3 = Y3_wide_chk_2 INTERACT (WIDE_all_raw NOT INTERACT Y3_good_step2)
 Y3_comb_step3 = SIZE Y3_comb_step2 BY 0.035 INSIDE OF Y3_wide_chk_3 STEP 0.035 // step3: 0.035
 Y3_good_step3_a = Y3_comb_step3 INTERACT V6N >= 9
 Y3_good_step3_b = (Y3_comb_step3 INTERACT V6N >= 7) INTERACT RV6 >= 1
 Y3_good_step3_c = (Y3_comb_step3 INTERACT V6N >= 5) INTERACT RV6 >= 2
 Y3_good_step3_d = (Y3_comb_step3 INTERACT V6N >= 3) INTERACT RV6 >= 3
 Y3_good_step3_e = (Y3_comb_step3 INTERACT V6N >= 1) INTERACT RV6 >= 4
 Y3_good_step3_f = Y3_comb_step3 INTERACT RV6 >= 5
 Y3_good_step3 = OR Y3_good_step3_a Y3_good_step3_b Y3_good_step3_c Y3_good_step3_d Y3_good_step3_e Y3_good_step3_f
 // 
 Y3_wide_chk_4 = Y3_wide_chk_3 INTERACT (WIDE_all_raw NOT INTERACT Y3_good_step3)
 Y3_comb_step4 = SIZE Y3_comb_step3 BY 0.035 INSIDE OF Y3_wide_chk_4 STEP 0.035 // step4: 0.035
 Y3_good_step4_a = Y3_comb_step4 INTERACT V6N >= 9
 Y3_good_step4_b = (Y3_comb_step4 INTERACT V6N >= 7) INTERACT RV6 >= 1
 Y3_good_step4_c = (Y3_comb_step4 INTERACT V6N >= 5) INTERACT RV6 >= 2
 Y3_good_step4_d = (Y3_comb_step4 INTERACT V6N >= 3) INTERACT RV6 >= 3
 Y3_good_step4_e = (Y3_comb_step4 INTERACT V6N >= 1) INTERACT RV6 >= 4
 Y3_good_step4_f = Y3_comb_step4 INTERACT RV6 >= 5
 Y3_good_step4 = OR Y3_good_step4_a Y3_good_step4_b Y3_good_step4_c Y3_good_step4_d Y3_good_step4_e Y3_good_step4_f
 // 
 Y3_wide_chk_5 = Y3_wide_chk_4 INTERACT (WIDE_all_raw NOT INTERACT Y3_good_step4)
 Y3_comb_step5 = SIZE Y3_comb_step4 BY 0.035 INSIDE OF Y3_wide_chk_5 STEP 0.035 // step5: 0.035
 Y3_good_step5_a = Y3_comb_step5 INTERACT V6N >= 9
 Y3_good_step5_b = (Y3_comb_step5 INTERACT V6N >= 7) INTERACT RV6 >= 1
 Y3_good_step5_c = (Y3_comb_step5 INTERACT V6N >= 5) INTERACT RV6 >= 2
 Y3_good_step5_d = (Y3_comb_step5 INTERACT V6N >= 3) INTERACT RV6 >= 3
 Y3_good_step5_e = (Y3_comb_step5 INTERACT V6N >= 1) INTERACT RV6 >= 4
 Y3_good_step5_f = Y3_comb_step5 INTERACT RV6 >= 5
 Y3_good_step5 = OR Y3_good_step5_a Y3_good_step5_b Y3_good_step5_c Y3_good_step5_d Y3_good_step5_e Y3_good_step5_f
 // 
 Y3_wide_chk_6 = Y3_wide_chk_5 INTERACT (WIDE_all_raw NOT INTERACT Y3_good_step5)
 Y3_comb_step6 = SIZE Y3_comb_step5 BY 0.035 INSIDE OF Y3_wide_chk_6 STEP 0.035 // step6: 0.035
 Y3_good_step6_a = Y3_comb_step6 INTERACT V6N >= 9
 Y3_good_step6_b = (Y3_comb_step6 INTERACT V6N >= 7) INTERACT RV6 >= 1
 Y3_good_step6_c = (Y3_comb_step6 INTERACT V6N >= 5) INTERACT RV6 >= 2
 Y3_good_step6_d = (Y3_comb_step6 INTERACT V6N >= 3) INTERACT RV6 >= 3
 Y3_good_step6_e = (Y3_comb_step6 INTERACT V6N >= 1) INTERACT RV6 >= 4
 Y3_good_step6_f = Y3_comb_step6 INTERACT RV6 >= 5
 Y3_good_step6 = OR Y3_good_step6_a Y3_good_step6_b Y3_good_step6_c Y3_good_step6_d Y3_good_step6_e Y3_good_step6_f
 // 
 Y3_wide_chk_7 = Y3_wide_chk_6 INTERACT (WIDE_all_raw NOT INTERACT Y3_good_step6)
 Y3_comb_step7 = SIZE Y3_comb_step6 BY 0.035 INSIDE OF Y3_wide_chk_7 STEP 0.035 // step7: 0.035
 Y3_good_step7_a = Y3_comb_step7 INTERACT V6N >= 9
 Y3_good_step7_b = (Y3_comb_step7 INTERACT V6N >= 7) INTERACT RV6 >= 1
 Y3_good_step7_c = (Y3_comb_step7 INTERACT V6N >= 5) INTERACT RV6 >= 2
 Y3_good_step7_d = (Y3_comb_step7 INTERACT V6N >= 3) INTERACT RV6 >= 3
 Y3_good_step7_e = (Y3_comb_step7 INTERACT V6N >= 1) INTERACT RV6 >= 4
 Y3_good_step7_f = Y3_comb_step7 INTERACT RV6 >= 5
 Y3_good_step7 = OR Y3_good_step7_a Y3_good_step7_b Y3_good_step7_c Y3_good_step7_d Y3_good_step7_e Y3_good_step7_f
 // 
 Y3_wide_chk_8 = Y3_wide_chk_7 INTERACT (WIDE_all_raw NOT INTERACT Y3_good_step7)
 Y3_comb_step8 = SIZE Y3_comb_step7 BY 0.035 INSIDE OF Y3_wide_chk_8 STEP 0.035 // step8: 0.035
 Y3_good_step8_a = Y3_comb_step8 INTERACT V6N >= 9
 Y3_good_step8_b = (Y3_comb_step8 INTERACT V6N >= 7) INTERACT RV6 >= 1
 Y3_good_step8_c = (Y3_comb_step8 INTERACT V6N >= 5) INTERACT RV6 >= 2
 Y3_good_step8_d = (Y3_comb_step8 INTERACT V6N >= 3) INTERACT RV6 >= 3
 Y3_good_step8_e = (Y3_comb_step8 INTERACT V6N >= 1) INTERACT RV6 >= 4
 Y3_good_step8_f = Y3_comb_step8 INTERACT RV6 >= 5
 Y3_good_step8 = OR Y3_good_step8_a Y3_good_step8_b Y3_good_step8_c Y3_good_step8_d Y3_good_step8_e Y3_good_step8_f
 // 
 Y3_wide_chk_9 = Y3_wide_chk_8 INTERACT (WIDE_all_raw NOT INTERACT Y3_good_step8)
 Y3_comb_step9 = SIZE Y3_comb_step8 BY 0.07 INSIDE OF Y3_wide_chk_9 STEP 0.035 // step9: 0.385-0.07-0.035*7=0.07
 Y3_good_step9_a = Y3_comb_step9 INTERACT V6N >= 9
 Y3_good_step9_b = (Y3_comb_step9 INTERACT V6N >= 7) INTERACT RV6 >= 1
 Y3_good_step9_c = (Y3_comb_step9 INTERACT V6N >= 5) INTERACT RV6 >= 2
 Y3_good_step9_d = (Y3_comb_step9 INTERACT V6N >= 3) INTERACT RV6 >= 3
 Y3_good_step9_e = (Y3_comb_step9 INTERACT V6N >= 1) INTERACT RV6 >= 4
 Y3_good_step9_f = Y3_comb_step9 INTERACT RV6 >= 5
 Y3_good_step9 = OR Y3_good_step9_a Y3_good_step9_b Y3_good_step9_c Y3_good_step9_d Y3_good_step9_e Y3_good_step9_f
 Y3_good = WIDE_all_raw AND (OR Y3_good_step1 Y3_good_step2 Y3_good_step3 Y3_good_step4 Y3_good_step5 Y3_good_step6 Y3_good_step7 Y3_good_step8 Y3_good_step9)
 // 
 err1 = (WIDE_all_raw OUTSIDE (OR Y1_good Y2_good Y3_good)) INTERACT V6
 (err1 NOT INTERACT 125xv6_BAR) NOT INSIDE OCCD
}

Q: There should be at least two square 1.25xVn or one rectangular 1.25xVn in the intersection area of bottom metal and upper metal, when either wide metal 1.25xMy/1.25xMn or 1.25xMn+1 length >= 0.162um and width >= 0.162um, the space between either via and wide metal <= 1.48um (S, S is the shortest running path length from Via to the wide metal). (except via bar)
    DRC flags each intersecting area ({bottom metal AND upper metal}) with single square Via within the branch check region
A: 
125xRv6_R_4_M6 {
@ There should be at least two square 1.25xVn or one rectangular 1.25xVn in the intersection area of bottom metal and upper metal, when either wide metal 1.25xMy/1.25xMn or 1.25xMn+1 length >= 0.162um and width >= 0.162um, the space between either via and wide metal <= 1.48um (S, S is the shortest running path length from Via to the wide metal). (except via bar)
@ DRC flags each intersecting area ({bottom metal AND upper metal}) with single square Via within the branch check region
 wide_M6 = (WITH WIDTH M6 > 0.162-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 0.162-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 0.162-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M6_real = wide_M6 NOT OUTSIDE ((SIZE wide_M6 BY 1.48+GLOBAL_TOLERANCE) INTERACT V6)
 all_down_and_up = (M6 INTERACT wide_M6) AND M7
 dis_down_arm_wide_all = SIZE wide_M6_real BY 1.48+GLOBAL_TOLERANCE INSIDE OF M6 STEP 0.025
 dis_down_and_up = dis_down_arm_wide_all AND all_down_and_up
 dis_down_and_up_arm = (dis_down_and_up NOT wide_M6) AND M6
 dis_down_arm = (dis_down_arm_wide_all NOT wide_M6) AND M6
 // 
 dis_down_arm_good_a = dis_down_and_up_arm INTERACT V6N >= 2
 dis_down_arm_good_b = dis_down_and_up_arm INTERACT RV6
 dis_down_arm_good = OR dis_down_arm_good_a dis_down_arm_good_b
 dis_down_arm_bad = (dis_down_and_up_arm NOT dis_down_arm_good) INTERACT (all_down_and_up INTERACT V6N == 1)
 // 
 dis_down_arm_err_stack = (dis_down_arm_bad AND dis_down_and_up_arm) INTERACT V6N
 dis_down_arm_err = dis_down_arm INTERACT dis_down_arm_err_stack
 err1_met_down = (dis_down_arm_err INTERACT (V6N NOT OUTSIDE dis_down_arm_err)) NOT INTERACT RV6
 // 
 wide_M7 = (WITH WIDTH M7 > 0.162-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 0.162-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 0.162-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M7_real = wide_M7 NOT OUTSIDE ((SIZE wide_M7 BY 1.48+GLOBAL_TOLERANCE) INTERACT V6)
 all_up_and_down = (M7 INTERACT wide_M7) AND M6
 dis_up_arm_wide_all = SIZE wide_M7_real BY 1.48+GLOBAL_TOLERANCE INSIDE OF M7 STEP 0.025
 dis_up_and_down = dis_up_arm_wide_all AND all_up_and_down
 dis_up_and_down_arm = (dis_up_and_down NOT wide_M7) AND M7
 dis_up_arm = (dis_up_arm_wide_all NOT wide_M7) AND M7
 // 
 dis_up_arm_good_a = dis_up_and_down_arm INTERACT V6N >= 2
 dis_up_arm_good_b = dis_up_and_down_arm INTERACT RV6
 dis_up_arm_good = OR dis_up_arm_good_a dis_up_arm_good_b
 dis_up_arm_bad = (dis_up_and_down_arm NOT dis_up_arm_good) INTERACT (all_up_and_down INTERACT V6N == 1)
 // 
 dis_up_arm_err_stack = (dis_up_arm_bad AND dis_up_and_down_arm) INTERACT V6N
 dis_up_arm_err = dis_up_arm INTERACT dis_up_arm_err_stack
 err2_met_up = (dis_up_arm_err INTERACT (V6N NOT OUTSIDE dis_up_arm_err)) NOT INTERACT RV6
 err1_met_down NOT INTERACT 125xv6_BAR
}
 
Q: There should be at least two square 1.25xVn or one rectangular 1.25xVn in the intersection area of bottom metal and upper metal, when either wide metal 1.25xMy/1.25xMn or 1.25xMn+1 length >= 0.162um and width >= 0.162um, the space between either via and wide metal <= 1.48um (S, S is the shortest running path length from Via to the wide metal). (except via bar)
    DRC flags each intersecting area ({bottom metal AND upper metal}) with single square Via within the branch check region
A: 
125xRv6_R_4_M7 {
@ There should be at least two square 1.25xVn or one rectangular 1.25xVn in the intersection area of bottom metal and upper metal, when either wide metal 1.25xMy/1.25xMn or 1.25xMn+1 length >= 0.162um and width >= 0.162um, the space between either via and wide metal <= 1.48um (S, S is the shortest running path length from Via to the wide metal). (except via bar)
@ DRC flags each intersecting area ({bottom metal AND upper metal}) with single square Via within the branch check region
 wide_M6 = (WITH WIDTH M6 > 0.162-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 0.162-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 0.162-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M6_real = wide_M6 NOT OUTSIDE ((SIZE wide_M6 BY 1.48+GLOBAL_TOLERANCE) INTERACT V6)
 all_down_and_up = (M6 INTERACT wide_M6) AND M7
 dis_down_arm_wide_all = SIZE wide_M6_real BY 1.48+GLOBAL_TOLERANCE INSIDE OF M6 STEP 0.025
 dis_down_and_up = dis_down_arm_wide_all AND all_down_and_up
 dis_down_and_up_arm = (dis_down_and_up NOT wide_M6) AND M6
 dis_down_arm = (dis_down_arm_wide_all NOT wide_M6) AND M6
 // 
 dis_down_arm_good_a = dis_down_and_up_arm INTERACT V6N >= 2
 dis_down_arm_good_b = dis_down_and_up_arm INTERACT RV6
 dis_down_arm_good = OR dis_down_arm_good_a dis_down_arm_good_b
 dis_down_arm_bad = (dis_down_and_up_arm NOT dis_down_arm_good) INTERACT (all_down_and_up INTERACT V6N == 1)
 // 
 dis_down_arm_err_stack = (dis_down_arm_bad AND dis_down_and_up_arm) INTERACT V6N
 dis_down_arm_err = dis_down_arm INTERACT dis_down_arm_err_stack
 err1_met_down = (dis_down_arm_err INTERACT (V6N NOT OUTSIDE dis_down_arm_err)) NOT INTERACT RV6
 // 
 wide_M7 = (WITH WIDTH M7 > 0.162-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 0.162-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 0.162-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M7_real = wide_M7 NOT OUTSIDE ((SIZE wide_M7 BY 1.48+GLOBAL_TOLERANCE) INTERACT V6)
 all_up_and_down = (M7 INTERACT wide_M7) AND M6
 dis_up_arm_wide_all = SIZE wide_M7_real BY 1.48+GLOBAL_TOLERANCE INSIDE OF M7 STEP 0.025
 dis_up_and_down = dis_up_arm_wide_all AND all_up_and_down
 dis_up_and_down_arm = (dis_up_and_down NOT wide_M7) AND M7
 dis_up_arm = (dis_up_arm_wide_all NOT wide_M7) AND M7
 // 
 dis_up_arm_good_a = dis_up_and_down_arm INTERACT V6N >= 2
 dis_up_arm_good_b = dis_up_and_down_arm INTERACT RV6
 dis_up_arm_good = OR dis_up_arm_good_a dis_up_arm_good_b
 dis_up_arm_bad = (dis_up_and_down_arm NOT dis_up_arm_good) INTERACT (all_up_and_down INTERACT V6N == 1)
 // 
 dis_up_arm_err_stack = (dis_up_arm_bad AND dis_up_and_down_arm) INTERACT V6N
 dis_up_arm_err = dis_up_arm INTERACT dis_up_arm_err_stack
 err2_met_up = (dis_up_arm_err INTERACT (V6N NOT OUTSIDE dis_up_arm_err)) NOT INTERACT RV6
 err2_met_up NOT INTERACT 125xv6_BAR
}
 
Q: There should be at least two square 1.25xVn or one rectangular 1.25xVn in the intersection area of bottom metal and upper metal, when either wide metal 1.25xMy/1.25xMn or 1.25xMn+1 length >= 0.91um and width >= 0.91um, the space between either via and wide metal <= 3.59um (S, S is the shortest running path length from Via to the wide metal). (except via bar)
    DRC flags each intersecting area ({bottom metal AND upper metal}) with single square Via within the branch check region
A: 
125xRv6_R_5_M6 {
@ There should be at least two square 1.25xVn or one rectangular 1.25xVn in the intersection area of bottom metal and upper metal, when either wide metal 1.25xMy/1.25xMn or 1.25xMn+1 length >= 0.91um and width >= 0.91um, the space between either via and wide metal <= 3.59um (S, S is the shortest running path length from Via to the wide metal). (except via bar)
@ DRC flags each intersecting area ({bottom metal AND upper metal}) with single square Via within the branch check region
 wide_M6 = (WITH WIDTH M6 > 0.91-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 0.91-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 0.91-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M6_real = wide_M6 NOT OUTSIDE ((SIZE wide_M6 BY 3.59+GLOBAL_TOLERANCE) INTERACT V6)
 all_down_and_up = (M6 INTERACT wide_M6) AND M7
 dis_down_arm_wide_all = SIZE wide_M6_real BY 3.59+GLOBAL_TOLERANCE INSIDE OF M6 STEP 0.025
 dis_down_and_up = dis_down_arm_wide_all AND all_down_and_up
 dis_down_and_up_arm = (dis_down_and_up NOT wide_M6) AND M6
 dis_down_arm = (dis_down_arm_wide_all NOT wide_M6) AND M6
 // 
 dis_down_arm_good_a = dis_down_and_up_arm INTERACT V6N >= 2
 dis_down_arm_good_b = dis_down_and_up_arm INTERACT RV6
 dis_down_arm_good = OR dis_down_arm_good_a dis_down_arm_good_b
 dis_down_arm_bad = (dis_down_and_up_arm NOT dis_down_arm_good) INTERACT (all_down_and_up INTERACT V6N == 1)
 // 
 dis_down_arm_err_stack = (dis_down_arm_bad AND dis_down_and_up_arm) INTERACT V6N
 dis_down_arm_err = dis_down_arm INTERACT dis_down_arm_err_stack
 err1_met_down = (dis_down_arm_err INTERACT (V6N NOT OUTSIDE dis_down_arm_err)) NOT INTERACT RV6
 // 
 wide_M7 = (WITH WIDTH M7 > 0.91-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 0.91-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 0.91-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M7_real = wide_M7 NOT OUTSIDE ((SIZE wide_M7 BY 3.59+GLOBAL_TOLERANCE) INTERACT V6)
 all_up_and_down = (M7 INTERACT wide_M7) AND M6
 dis_up_arm_wide_all = SIZE wide_M7_real BY 3.59+GLOBAL_TOLERANCE INSIDE OF M7 STEP 0.025
 dis_up_and_down = dis_up_arm_wide_all AND all_up_and_down
 dis_up_and_down_arm = (dis_up_and_down NOT wide_M7) AND M7
 dis_up_arm = (dis_up_arm_wide_all NOT wide_M7) AND M7
 // 
 dis_up_arm_good_a = dis_up_and_down_arm INTERACT V6N >= 2
 dis_up_arm_good_b = dis_up_and_down_arm INTERACT RV6
 dis_up_arm_good = OR dis_up_arm_good_a dis_up_arm_good_b
 dis_up_arm_bad = (dis_up_and_down_arm NOT dis_up_arm_good) INTERACT (all_up_and_down INTERACT V6N == 1)
 // 
 dis_up_arm_err_stack = (dis_up_arm_bad AND dis_up_and_down_arm) INTERACT V6N
 dis_up_arm_err = dis_up_arm INTERACT dis_up_arm_err_stack
 err2_met_up = (dis_up_arm_err INTERACT (V6N NOT OUTSIDE dis_up_arm_err)) NOT INTERACT RV6
 err1_met_down NOT INTERACT 125xv6_BAR
}
 
Q: There should be at least two square 1.25xVn or one rectangular 1.25xVn in the intersection area of bottom metal and upper metal, when either wide metal 1.25xMy/1.25xMn or 1.25xMn+1 length >= 0.91um and width >= 0.91um, the space between either via and wide metal <= 3.59um (S, S is the shortest running path length from Via to the wide metal). (except via bar)
    DRC flags each intersecting area ({bottom metal AND upper metal}) with single square Via within the branch check region
A: 
125xRv6_R_5_M7 {
@ There should be at least two square 1.25xVn or one rectangular 1.25xVn in the intersection area of bottom metal and upper metal, when either wide metal 1.25xMy/1.25xMn or 1.25xMn+1 length >= 0.91um and width >= 0.91um, the space between either via and wide metal <= 3.59um (S, S is the shortest running path length from Via to the wide metal). (except via bar)
@ DRC flags each intersecting area ({bottom metal AND upper metal}) with single square Via within the branch check region
 wide_M6 = (WITH WIDTH M6 > 0.91-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 0.91-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 0.91-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M6_real = wide_M6 NOT OUTSIDE ((SIZE wide_M6 BY 3.59+GLOBAL_TOLERANCE) INTERACT V6)
 all_down_and_up = (M6 INTERACT wide_M6) AND M7
 dis_down_arm_wide_all = SIZE wide_M6_real BY 3.59+GLOBAL_TOLERANCE INSIDE OF M6 STEP 0.025
 dis_down_and_up = dis_down_arm_wide_all AND all_down_and_up
 dis_down_and_up_arm = (dis_down_and_up NOT wide_M6) AND M6
 dis_down_arm = (dis_down_arm_wide_all NOT wide_M6) AND M6
 // 
 dis_down_arm_good_a = dis_down_and_up_arm INTERACT V6N >= 2
 dis_down_arm_good_b = dis_down_and_up_arm INTERACT RV6
 dis_down_arm_good = OR dis_down_arm_good_a dis_down_arm_good_b
 dis_down_arm_bad = (dis_down_and_up_arm NOT dis_down_arm_good) INTERACT (all_down_and_up INTERACT V6N == 1)
 // 
 dis_down_arm_err_stack = (dis_down_arm_bad AND dis_down_and_up_arm) INTERACT V6N
 dis_down_arm_err = dis_down_arm INTERACT dis_down_arm_err_stack
 err1_met_down = (dis_down_arm_err INTERACT (V6N NOT OUTSIDE dis_down_arm_err)) NOT INTERACT RV6
 // 
 wide_M7 = (WITH WIDTH M7 > 0.91-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 0.91-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 0.91-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M7_real = wide_M7 NOT OUTSIDE ((SIZE wide_M7 BY 3.59+GLOBAL_TOLERANCE) INTERACT V6)
 all_up_and_down = (M7 INTERACT wide_M7) AND M6
 dis_up_arm_wide_all = SIZE wide_M7_real BY 3.59+GLOBAL_TOLERANCE INSIDE OF M7 STEP 0.025
 dis_up_and_down = dis_up_arm_wide_all AND all_up_and_down
 dis_up_and_down_arm = (dis_up_and_down NOT wide_M7) AND M7
 dis_up_arm = (dis_up_arm_wide_all NOT wide_M7) AND M7
 // 
 dis_up_arm_good_a = dis_up_and_down_arm INTERACT V6N >= 2
 dis_up_arm_good_b = dis_up_and_down_arm INTERACT RV6
 dis_up_arm_good = OR dis_up_arm_good_a dis_up_arm_good_b
 dis_up_arm_bad = (dis_up_and_down_arm NOT dis_up_arm_good) INTERACT (all_up_and_down INTERACT V6N == 1)
 // 
 dis_up_arm_err_stack = (dis_up_arm_bad AND dis_up_and_down_arm) INTERACT V6N
 dis_up_arm_err = dis_up_arm INTERACT dis_up_arm_err_stack
 err2_met_up = (dis_up_arm_err INTERACT (V6N NOT OUTSIDE dis_up_arm_err)) NOT INTERACT RV6
 err2_met_up NOT INTERACT 125xv6_BAR
}
 
Q: There should be at least two square 1.25xVn or one rectangular 1.25xVn in the intersection area of bottom metal and upper metal, when either wide metal 1.25xMy/1.25xMn or 1.25xMn+1 length >= 1.36um and width >= 1.36um, the space between either via and wide metal <= 9um (S, S is the shortest running path length from Via to the wide metal). (except via bar)
    DRC flags each intersecting area ({bottom metal AND upper metal}) with single square Via within the branch check region
A: 
125xRv6_R_6_M6 {
@ There should be at least two square 1.25xVn or one rectangular 1.25xVn in the intersection area of bottom metal and upper metal, when either wide metal 1.25xMy/1.25xMn or 1.25xMn+1 length >= 1.36um and width >= 1.36um, the space between either via and wide metal <= 9um (S, S is the shortest running path length from Via to the wide metal). (except via bar)
@ DRC flags each intersecting area ({bottom metal AND upper metal}) with single square Via within the branch check region
 wide_M6 = (WITH WIDTH M6 > 1.36-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 1.36-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 1.36-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M6_real = wide_M6 NOT OUTSIDE ((SIZE wide_M6 BY 9+GLOBAL_TOLERANCE) INTERACT V6)
 all_down_and_up = (M6 INTERACT wide_M6) AND M7
 dis_down_arm_wide_all = SIZE wide_M6_real BY 9+GLOBAL_TOLERANCE INSIDE OF M6 STEP 0.025
 dis_down_and_up = dis_down_arm_wide_all AND all_down_and_up
 dis_down_and_up_arm = (dis_down_and_up NOT wide_M6) AND M6
 dis_down_arm = (dis_down_arm_wide_all NOT wide_M6) AND M6
 // 
 dis_down_arm_good_a = dis_down_and_up_arm INTERACT V6N >= 2
 dis_down_arm_good_b = dis_down_and_up_arm INTERACT RV6
 dis_down_arm_good = OR dis_down_arm_good_a dis_down_arm_good_b
 dis_down_arm_bad = (dis_down_and_up_arm NOT dis_down_arm_good) INTERACT (all_down_and_up INTERACT V6N == 1)
 // 
 dis_down_arm_err_stack = (dis_down_arm_bad AND dis_down_and_up_arm) INTERACT V6N
 dis_down_arm_err = dis_down_arm INTERACT dis_down_arm_err_stack
 err1_met_down = (dis_down_arm_err INTERACT (V6N NOT OUTSIDE dis_down_arm_err)) NOT INTERACT RV6
 // 
 wide_M7 = (WITH WIDTH M7 > 1.36-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 1.36-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 1.36-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M7_real = wide_M7 NOT OUTSIDE ((SIZE wide_M7 BY 9+GLOBAL_TOLERANCE) INTERACT V6)
 all_up_and_down = (M7 INTERACT wide_M7) AND M6
 dis_up_arm_wide_all = SIZE wide_M7_real BY 9+GLOBAL_TOLERANCE INSIDE OF M7 STEP 0.025
 dis_up_and_down = dis_up_arm_wide_all AND all_up_and_down
 dis_up_and_down_arm = (dis_up_and_down NOT wide_M7) AND M7
 dis_up_arm = (dis_up_arm_wide_all NOT wide_M7) AND M7
 // 
 dis_up_arm_good_a = dis_up_and_down_arm INTERACT V6N >= 2
 dis_up_arm_good_b = dis_up_and_down_arm INTERACT RV6
 dis_up_arm_good = OR dis_up_arm_good_a dis_up_arm_good_b
 dis_up_arm_bad = (dis_up_and_down_arm NOT dis_up_arm_good) INTERACT (all_up_and_down INTERACT V6N == 1)
 // 
 dis_up_arm_err_stack = (dis_up_arm_bad AND dis_up_and_down_arm) INTERACT V6N
 dis_up_arm_err = dis_up_arm INTERACT dis_up_arm_err_stack
 err2_met_up = (dis_up_arm_err INTERACT (V6N NOT OUTSIDE dis_up_arm_err)) NOT INTERACT RV6
 err1_met_down NOT INTERACT 125xv6_BAR
}
 
Q: There should be at least two square 1.25xVn or one rectangular 1.25xVn in the intersection area of bottom metal and upper metal, when either wide metal 1.25xMy/1.25xMn or 1.25xMn+1 length >= 1.36um and width >= 1.36um, the space between either via and wide metal <= 9um (S, S is the shortest running path length from Via to the wide metal). (except via bar)
    DRC flags each intersecting area ({bottom metal AND upper metal}) with single square Via within the branch check region
A: 
125xRv6_R_6_M7 {
@ There should be at least two square 1.25xVn or one rectangular 1.25xVn in the intersection area of bottom metal and upper metal, when either wide metal 1.25xMy/1.25xMn or 1.25xMn+1 length >= 1.36um and width >= 1.36um, the space between either via and wide metal <= 9um (S, S is the shortest running path length from Via to the wide metal). (except via bar)
@ DRC flags each intersecting area ({bottom metal AND upper metal}) with single square Via within the branch check region
 wide_M6 = (WITH WIDTH M6 > 1.36-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 1.36-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 1.36-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M6_real = wide_M6 NOT OUTSIDE ((SIZE wide_M6 BY 9+GLOBAL_TOLERANCE) INTERACT V6)
 all_down_and_up = (M6 INTERACT wide_M6) AND M7
 dis_down_arm_wide_all = SIZE wide_M6_real BY 9+GLOBAL_TOLERANCE INSIDE OF M6 STEP 0.025
 dis_down_and_up = dis_down_arm_wide_all AND all_down_and_up
 dis_down_and_up_arm = (dis_down_and_up NOT wide_M6) AND M6
 dis_down_arm = (dis_down_arm_wide_all NOT wide_M6) AND M6
 // 
 dis_down_arm_good_a = dis_down_and_up_arm INTERACT V6N >= 2
 dis_down_arm_good_b = dis_down_and_up_arm INTERACT RV6
 dis_down_arm_good = OR dis_down_arm_good_a dis_down_arm_good_b
 dis_down_arm_bad = (dis_down_and_up_arm NOT dis_down_arm_good) INTERACT (all_down_and_up INTERACT V6N == 1)
 // 
 dis_down_arm_err_stack = (dis_down_arm_bad AND dis_down_and_up_arm) INTERACT V6N
 dis_down_arm_err = dis_down_arm INTERACT dis_down_arm_err_stack
 err1_met_down = (dis_down_arm_err INTERACT (V6N NOT OUTSIDE dis_down_arm_err)) NOT INTERACT RV6
 // 
 wide_M7 = (WITH WIDTH M7 > 1.36-GLOBAL_TOLERANCE) ENCLOSE RECTANGLE 1.36-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE 1.36-GLOBAL_TOLERANCE+GLOBAL_TOLERANCE
 wide_M7_real = wide_M7 NOT OUTSIDE ((SIZE wide_M7 BY 9+GLOBAL_TOLERANCE) INTERACT V6)
 all_up_and_down = (M7 INTERACT wide_M7) AND M6
 dis_up_arm_wide_all = SIZE wide_M7_real BY 9+GLOBAL_TOLERANCE INSIDE OF M7 STEP 0.025
 dis_up_and_down = dis_up_arm_wide_all AND all_up_and_down
 dis_up_and_down_arm = (dis_up_and_down NOT wide_M7) AND M7
 dis_up_arm = (dis_up_arm_wide_all NOT wide_M7) AND M7
 // 
 dis_up_arm_good_a = dis_up_and_down_arm INTERACT V6N >= 2
 dis_up_arm_good_b = dis_up_and_down_arm INTERACT RV6
 dis_up_arm_good = OR dis_up_arm_good_a dis_up_arm_good_b
 dis_up_arm_bad = (dis_up_and_down_arm NOT dis_up_arm_good) INTERACT (all_up_and_down INTERACT V6N == 1)
 // 
 dis_up_arm_err_stack = (dis_up_arm_bad AND dis_up_and_down_arm) INTERACT V6N
 dis_up_arm_err = dis_up_arm INTERACT dis_up_arm_err_stack
 err2_met_up = (dis_up_arm_err INTERACT (V6N NOT OUTSIDE dis_up_arm_err)) NOT INTERACT RV6
 err2_met_up NOT INTERACT 125xv6_BAR
}
 
Q: 45-degree 1.25xRVn is not allowed
A: 
125xRv6_R_7 {
@ 45-degree 1.25xRVn is not allowed
 err1 = ANGLE (V6 NOT 125xv6_BAR) > 44.5 < 45.5
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

//10xTM2

Q: 10xTMn.R.1: 10xTMn must be drawn on data type of 0
    10xTMn.R.2: 10xTMn and 14xTMn can't be used on same chip
A: 
10xTM2_R_1_2 {
@ 10xTMn.R.1: 10xTMn must be drawn on data type of 0
@ 10xTMn.R.2: 10xTMn and 14xTMn can't be used on same chip
 TM2_40 INTERACT DRC:1
}
 

#IFDEF Delta_Voltage_Rules_Check YES

 
Q: Maximum delta V >= 5.6V is not allowed, when space between 10xTMn and 10xTMn/10xTVn-1/10xTVn is < 3.6um
A: 
10xTM2_R_3_TM2 {
@ Maximum delta V >= 5.6V is not allowed, when space between 10xTMn and 10xTMn/10xTVn-1/10xTVn is < 3.6um
 err1 = DFM DV M8 < 3.600 DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" >= 5.6 ANNOTATE NOT CONNECTED SINGULAR
 DFM COPY err1
}
 
Q: Maximum delta V >= 5.6V is not allowed, when space between 10xTMn and 10xTMn/10xTVn-1/10xTVn is < 3.6um
A: 
10xTM2_R_3_TV2 {
@ Maximum delta V >= 5.6V is not allowed, when space between 10xTMn and 10xTMn/10xTVn-1/10xTVn is < 3.6um
 err1 = DFM DV M8 V7 < 3.600 DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" >= 5.6 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err1
}

//TV

Q: 10xTV.R.10.DFM: Recommended maximum continuous stacked VIA layers (including V0), which has only one square via for each via layer to avoid high Rc <= 4
    14xTV.R.10.DFM: Recommended maximum continuous stacked VIA layers (including V0), which has only one square via for each via layer to avoid high Rc <= 4
     UTV.R.10.DFM: Recommended maximum continuous stacked VIA layers (including V0), which has only one square via for each via layer to avoid high Rc <= 4
A: 
TV_R_10_V0V1V2V3V4_DFM1 {
@ 10xTV.R.10.DFM: Recommended maximum continuous stacked VIA layers (including V0), which has only one square via for each via layer to avoid high Rc <= 4
@ 14xTV.R.10.DFM: Recommended maximum continuous stacked VIA layers (including V0), which has only one square via for each via layer to avoid high Rc <= 4
@ UTV.R.10.DFM: Recommended maximum continuous stacked VIA layers (including V0), which has only one square via for each via layer to avoid high Rc <= 4
 stack_3_vias = stack_3 INTERACT (stack_3 AND stack_4)
 stack_4_vias = stack_2 INTERACT (stack_2 AND stack_3_vias)
 stack_5_vias = stack_1 INTERACT (stack_1 AND stack_4_vias)
 err1 = stack_0 INTERACT (stack_0 AND stack_5_vias)
 err1 NOT INSIDE SealR_NOT_BULK
}
 
Q: 10xTV.R.10.DFM: Recommended maximum continuous stacked VIA layers (including V0), which has only one square via for each via layer to avoid high Rc <= 4
    14xTV.R.10.DFM: Recommended maximum continuous stacked VIA layers (including V0), which has only one square via for each via layer to avoid high Rc <= 4
    UTV.R.10.DFM: Recommended maximum continuous stacked VIA layers (including V0), which has only one square via for each via layer to avoid high Rc <= 4
A: 
TV_R_10_V1V2V3V4V5_DFM1 {
@ 10xTV.R.10.DFM: Recommended maximum continuous stacked VIA layers (including V0), which has only one square via for each via layer to avoid high Rc <= 4
@ 14xTV.R.10.DFM: Recommended maximum continuous stacked VIA layers (including V0), which has only one square via for each via layer to avoid high Rc <= 4
@ UTV.R.10.DFM: Recommended maximum continuous stacked VIA layers (including V0), which has only one square via for each via layer to avoid high Rc <= 4
 stack_3_vias = stack_4 INTERACT (stack_4 AND stack_5)
 stack_4_vias = stack_3 INTERACT (stack_3 AND stack_3_vias)
 stack_5_vias = stack_2 INTERACT (stack_2 AND stack_4_vias)
 err1 = stack_1 INTERACT (stack_1 AND stack_5_vias)
 err1 NOT INSIDE SealR_NOT_BULK
}
 
Q: 10xTV.R.10.DFM: Recommended maximum continuous stacked VIA layers (including V0), which has only one square via for each via layer to avoid high Rc <= 4
     14xTV.R.10.DFM: Recommended maximum continuous stacked VIA layers (including V0), which has only one square via for each via layer to avoid high Rc <= 4
    UTV.R.10.DFM: Recommended maximum continuous stacked VIA layers (including V0), which has only one square via for each via layer to avoid high Rc <= 4
A: 
TV_R_10_V2V3V4V5V6_DFM1 {
@ 10xTV.R.10.DFM: Recommended maximum continuous stacked VIA layers (including V0), which has only one square via for each via layer to avoid high Rc <= 4
@ 14xTV.R.10.DFM: Recommended maximum continuous stacked VIA layers (including V0), which has only one square via for each via layer to avoid high Rc <= 4
@ UTV.R.10.DFM: Recommended maximum continuous stacked VIA layers (including V0), which has only one square via for each via layer to avoid high Rc <= 4
 stack_3_vias = stack_5 INTERACT (stack_5 AND stack_6)
 stack_4_vias = stack_4 INTERACT (stack_4 AND stack_3_vias)
 stack_5_vias = stack_3 INTERACT (stack_3 AND stack_4_vias)
 err1 = stack_2 INTERACT (stack_2 AND stack_5_vias)
 err1 NOT INSIDE SealR_NOT_BULK
}
 
Q: 10xTV.R.10.DFM: Recommended maximum continuous stacked VIA layers (including V0), which has only one square via for each via layer to avoid high Rc <= 4
@ 14xTV.R.10.DFM: Recommended maximum continuous stacked VIA layers (including V0), which has only one square via for each via layer to avoid high Rc <= 4
@ UTV.R.10.DFM: Recommended maximum continuous stacked VIA layers (including V0), which has only one square via for each via layer to avoid high Rc <= 4
A: 
TV_R_10_V3V4V5V6V7_DFM1 {
@ 10xTV.R.10.DFM: Recommended maximum continuous stacked VIA layers (including V0), which has only one square via for each via layer to avoid high Rc <= 4
@ 14xTV.R.10.DFM: Recommended maximum continuous stacked VIA layers (including V0), which has only one square via for each via layer to avoid high Rc <= 4
@ UTV.R.10.DFM: Recommended maximum continuous stacked VIA layers (including V0), which has only one square via for each via layer to avoid high Rc <= 4
 stack_3_vias = stack_6 INTERACT (stack_6 AND stack_7)
 stack_4_vias = stack_5 INTERACT (stack_5 AND stack_3_vias)
 stack_5_vias = stack_4 INTERACT (stack_4 AND stack_4_vias)
 err1 = stack_3 INTERACT (stack_3 AND stack_5_vias)
 err1 NOT INSIDE SealR_NOT_BULK
}

//125XM

Q: Maximum number of stacked metal layers (including M1) of high density area (density > 70% in window size 800um*800um, stepping size 100um) <= 4
    For 1.25xMy.R.1.DFM, 1.25xMn.R.1.DFM
A: 
125XM_R_1_M1M2M3M4M5_DFM1 {
@ Maximum number of stacked metal layers (including M1) of high density area (density > 70% in window size 800um*800um, stepping size 100um) <= 4
@ For 1.25xMy.R.1.DFM, 1.25xMn.R.1.DFM
 X1 = M1_all NOT MARKS
 X2 = M2_all NOT MARKS
 X3 = M3_all NOT MARKS
 X4 = M4_all NOT MARKS
 X5 = M5_all NOT MARKS
 N = COPY CHIP_NOT_MARKS
 DENSITY X1 X2 X3 X4 X5 N > 0 WINDOW 800 STEP 100 BACKUP PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_125XM_R_1_M1M2M3M4M5_DFM1.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_125XM_R_1_M1M2M3M4M5_DFM1.rdb" [(~~(AREA(X1)/AREA(N) -0.7))*(~~(AREA(X2)/AREA(N) -0.7))*(~~(AREA(X3)/AREA(N) -0.7))*(~~(AREA(X4)/AREA(N) -0.7))*(~~(AREA(X5)/AREA(N) -0.7))]
}
 
Q: Maximum number of stacked metal layers (including M1) of high density area (density > 70% in window size 800um*800um, stepping size 100um) <= 4
    For 1.25xMy.R.1.DFM, 1.25xMn.R.1.DFM
A: 
125XM_R_1_M2M3M4M5M6_DFM1 {
@ Maximum number of stacked metal layers (including M1) of high density area (density > 70% in window size 800um*800um, stepping size 100um) <= 4
@ For 1.25xMy.R.1.DFM, 1.25xMn.R.1.DFM
 X1 = M2_all NOT MARKS
 X2 = M3_all NOT MARKS
 X3 = M4_all NOT MARKS
 X4 = M5_all NOT MARKS
 X5 = M6_all NOT MARKS
 N = COPY CHIP_NOT_MARKS
 DENSITY X1 X2 X3 X4 X5 N > 0 WINDOW 800 STEP 100 BACKUP PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_125XM_R_1_M2M3M4M5M6_DFM1.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_125XM_R_1_M2M3M4M5M6_DFM1.rdb" [(~~(AREA(X1)/AREA(N) -0.7))*(~~(AREA(X2)/AREA(N) -0.7))*(~~(AREA(X3)/AREA(N) -0.7))*(~~(AREA(X4)/AREA(N) -0.7))*(~~(AREA(X5)/AREA(N) -0.7))]
}
 
Q: Maximum number of stacked metal layers (including M1) of high density area (density > 70% in window size 800um*800um, stepping size 100um) <= 4
    For 1.25xMy.R.1.DFM, 1.25xMn.R.1.DFM
A: 
125XM_R_1_M3M4M5M6M7_DFM1 {
@ Maximum number of stacked metal layers (including M1) of high density area (density > 70% in window size 800um*800um, stepping size 100um) <= 4
@ For 1.25xMy.R.1.DFM, 1.25xMn.R.1.DFM
 X1 = M3_all NOT MARKS
 X2 = M4_all NOT MARKS
 X3 = M5_all NOT MARKS
 X4 = M6_all NOT MARKS
 X5 = M7_all NOT MARKS
 N = COPY CHIP_NOT_MARKS
 DENSITY X1 X2 X3 X4 X5 N > 0 WINDOW 800 STEP 100 BACKUP PRINT "./SMIC_14SFPLUS_DRC_logFile/density_report_125XM_R_1_M3M4M5M6M7_DFM1.log" RDB "./SMIC_14SFPLUS_DRC_logFile/density_report_125XM_R_1_M3M4M5M6M7_DFM1.rdb" [(~~(AREA(X1)/AREA(N) -0.7))*(~~(AREA(X2)/AREA(N) -0.7))*(~~(AREA(X3)/AREA(N) -0.7))*(~~(AREA(X4)/AREA(N) -0.7))*(~~(AREA(X5)/AREA(N) -0.7))]
}


//PA

Q: 45-degree rotated PA is not allowed, except INDMY region
A: 
PA_R_1 {
@ 45-degree rotated PA is not allowed, except INDMY region
 err1 = (PA NOT WITH EDGE PA_h_edges) NOT WITH EDGE PA_v_edges
 err1 NOT INSIDE INDMY
}


//MD

Q: MD must be a drawn layer
A: 
MD_R_1 {
@ MD must be a drawn layer
 err1 = DRC:1 NOT INTERACT MD
 err1 NOT INSIDE SealR_NOT_BULK
}

Q: MD interact PA (PA size <= 2.7um) is not allowed, except LOGO region
A: 
MD_R_2 {
@ MD interact PA (PA size <= 2.7um) is not allowed, except LOGO region
 err1 = MD INTERACT (PA WITH WIDTH <= 2.7)
 err1 NOT INSIDE LOGO
}

Q: Inductor under MD wire-bond pad opening is not allowed
A: 
MD_R_3 {
@ Inductor under MD wire-bond pad opening is not allowed
 err1 = INDMY AND DUP_area
 err1 NOT INSIDE SealR_NOT_BULK
}

//WBPAD

Q: MD/ALPA/PA/TM/TM-1 patterns in wire bond pad area should have 4 corners with 45° cut for corner stress relief. The length of corner cut >= 2um <= 5um
A: 
WBPAD_9_R {
@ MD/ALPA/PA/TM/TM-1 patterns in wire bond pad area should have 4 corners with 45° cut for corner stress relief. The length of corner cut >= 2um <= 5um
 md_WAIVE_2_convex = CONVEX EDGE MD ANGLE1==270 ANGLE2==270
 md_WAIVE_1_convex = LENGTH (CONVEX EDGE MD ANGLE1==270 ANGLE2==90) < 3
 md_WAIVE_2_convex_EXP = (EXPAND EDGE md_WAIVE_2_convex OUTSIDE BY 0.001) WITH EDGE md_WAIVE_1_convex == 2
 md_WAIVE_1_convex_EXP = ((EXPAND EDGE md_WAIVE_1_convex OUTSIDE BY 0.001) WITH EDGE md_WAIVE_2_convex == 1) INTERACT md_WAIVE_2_convex_EXP
 md_WAIVE_ALL = EXTENTS (OR md_WAIVE_1_convex_EXP md_WAIVE_2_convex_EXP)

 md_IN_pad = (MD OR md_WAIVE_ALL) NOT OUTSIDE DUP_area
 md_IN_pad_SKEW = ANGLE md_IN_pad > 44 < 46
 md_IN_pad_ORTV = ANGLE (CONVEX EDGE md_IN_pad == 2) == 90
 md_IN_pad_ORTH = ANGLE (CONVEX EDGE md_IN_pad == 2) == 0
 md_IN_pad_GOOD = ((md_IN_pad WITH EDGE md_IN_pad_ORTV == 2) WITH EDGE md_IN_pad_ORTH == 2) WITH EDGE md_IN_pad_SKEW == 4
 md_IN_pad_EXTENT = EXTENTS md_IN_pad_GOOD
 md_IN_pad_CORNER_less = INT md_IN_pad_EXTENT < 1.414-GLOBAL_TOLERANCE ABUT==90 INTERSECTING ONLY REGION
 md_IN_pad_CORNER_more = INT md_IN_pad_EXTENT < 3.536+GLOBAL_TOLERANCE ABUT==90 INTERSECTING ONLY REGION

 err1 = (md_IN_pad NOT md_IN_pad_GOOD) OR (INT MD < 0.1 ABUT<90 INTERSECTING ONLY REGION)
 err2 = EXPAND EDGE (md_IN_pad_SKEW INSIDE EDGE md_IN_pad_CORNER_less) OUTSIDE BY 0.001
 err3 = EXPAND EDGE (md_IN_pad_SKEW OUTSIDE EDGE md_IN_pad_CORNER_more) OUTSIDE BY 0.001
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
}

Q: MD/ALPA/PA/TM/TM-1 patterns in wire bond pad area should have 4 corners with 45° cut for corner stress relief. The length of corner cut >= 2um <= 5um
A: 
WBPAD_9_R_ALPA {
@ MD/ALPA/PA/TM/TM-1 patterns in wire bond pad area should have 4 corners with 45° cut for corner stress relief. The length of corner cut >= 2um <= 5um
 md_CHECK = ALPA_PAD ENCLOSE DUP_area
 md_WAIVE_2_convex = CONVEX EDGE md_CHECK ANGLE1==270 ANGLE2==270
 md_WAIVE_1_convex = LENGTH (CONVEX EDGE md_CHECK ANGLE1==270 ANGLE2==90) < 3
 md_WAIVE_2_convex_EXP = (EXPAND EDGE md_WAIVE_2_convex OUTSIDE BY 0.001) WITH EDGE md_WAIVE_1_convex == 2
 md_WAIVE_1_convex_EXP = ((EXPAND EDGE md_WAIVE_1_convex OUTSIDE BY 0.001) WITH EDGE md_WAIVE_2_convex == 1) INTERACT md_WAIVE_2_convex_EXP
 md_WAIVE_ALL = EXTENTS (OR md_WAIVE_1_convex_EXP md_WAIVE_2_convex_EXP)

 md_IN_pad = (md_CHECK OR md_WAIVE_ALL) NOT OUTSIDE DUP_area
 md_IN_pad_SKEW = ANGLE md_IN_pad > 44 < 46
 md_IN_pad_ORTV = ANGLE (CONVEX EDGE md_IN_pad == 2) == 90
 md_IN_pad_ORTH = ANGLE (CONVEX EDGE md_IN_pad == 2) == 0
 md_IN_pad_GOOD = ((md_IN_pad WITH EDGE md_IN_pad_ORTV == 2) WITH EDGE md_IN_pad_ORTH == 2) WITH EDGE md_IN_pad_SKEW == 4
 md_IN_pad_EXTENT = EXTENTS md_IN_pad_GOOD
 md_IN_pad_CORNER_less = INT md_IN_pad_EXTENT < 1.414-GLOBAL_TOLERANCE ABUT==90 INTERSECTING ONLY REGION
 md_IN_pad_CORNER_more = INT md_IN_pad_EXTENT < 3.536+GLOBAL_TOLERANCE ABUT==90 INTERSECTING ONLY REGION

 err1 = (md_IN_pad NOT md_IN_pad_GOOD) OR (INT md_CHECK < 0.1 ABUT<90 INTERSECTING ONLY REGION)
 err2 = EXPAND EDGE (md_IN_pad_SKEW INSIDE EDGE md_IN_pad_CORNER_less) OUTSIDE BY 0.001
 err3 = EXPAND EDGE (md_IN_pad_SKEW OUTSIDE EDGE md_IN_pad_CORNER_more) OUTSIDE BY 0.001
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
}

Q: MD/ALPA/PA/TM/TM-1 patterns in wire bond pad area should have 4 corners with 45° cut for corner stress relief. The length of corner cut >= 2um <= 5um
A: 
WBPAD_9_R_PA {
@ MD/ALPA/PA/TM/TM-1 patterns in wire bond pad area should have 4 corners with 45° cut for corner stress relief. The length of corner cut >= 2um <= 5um
 md_CHECK = ((PA INTERACT DUP_area) WITH WIDTH > 20) INTERACT DUP_area
 md_WAIVE_2_convex = CONVEX EDGE md_CHECK ANGLE1==270 ANGLE2==270
 md_WAIVE_1_convex = LENGTH (CONVEX EDGE md_CHECK ANGLE1==270 ANGLE2==90) < 3
 md_WAIVE_2_convex_EXP = (EXPAND EDGE md_WAIVE_2_convex OUTSIDE BY 0.001) WITH EDGE md_WAIVE_1_convex == 2
 md_WAIVE_1_convex_EXP = ((EXPAND EDGE md_WAIVE_1_convex OUTSIDE BY 0.001) WITH EDGE md_WAIVE_2_convex == 1) INTERACT md_WAIVE_2_convex_EXP
 md_WAIVE_ALL = EXTENTS (OR md_WAIVE_1_convex_EXP md_WAIVE_2_convex_EXP)

 md_IN_pad = (md_CHECK OR md_WAIVE_ALL) NOT OUTSIDE DUP_area
 md_IN_pad_SKEW = ANGLE md_IN_pad > 44 < 46
 md_IN_pad_ORTV = ANGLE (CONVEX EDGE md_IN_pad == 2) == 90
 md_IN_pad_ORTH = ANGLE (CONVEX EDGE md_IN_pad == 2) == 0
 md_IN_pad_GOOD = ((md_IN_pad WITH EDGE md_IN_pad_ORTV == 2) WITH EDGE md_IN_pad_ORTH == 2) WITH EDGE md_IN_pad_SKEW == 4
 md_IN_pad_EXTENT = EXTENTS md_IN_pad_GOOD
 md_IN_pad_CORNER_less = INT md_IN_pad_EXTENT < 1.414-GLOBAL_TOLERANCE ABUT==90 INTERSECTING ONLY REGION
 md_IN_pad_CORNER_more = INT md_IN_pad_EXTENT < 3.536+GLOBAL_TOLERANCE ABUT==90 INTERSECTING ONLY REGION

 err1 = (md_IN_pad NOT md_IN_pad_GOOD) OR (INT md_CHECK < 0.1 ABUT<90 INTERSECTING ONLY REGION)
 err2 = EXPAND EDGE (md_IN_pad_SKEW INSIDE EDGE md_IN_pad_CORNER_less) OUTSIDE BY 0.001
 err3 = EXPAND EDGE (md_IN_pad_SKEW OUTSIDE EDGE md_IN_pad_CORNER_more) OUTSIDE BY 0.001
 err4 = OR ((PA INTERACT DUP_area) VERTEX != 8) (EXT (PA INTERACT DUP_area) < 0.005 ABUT INTERSECTING REGION)
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
 err4 NOT INSIDE SealR_NOT_BULK
}

Q: MD/ALPA/PA/TM/TM-1 patterns in wire bond pad area should have 4 corners with 45° cut for corner stress relief. The length of corner cut >= 2um <= 5um
A: 
WBPAD_9_R_TM {
@ MD/ALPA/PA/TM/TM-1 patterns in wire bond pad area should have 4 corners with 45° cut for corner stress relief. The length of corner cut >= 2um <= 5um
 md_CHECK = ((TM INTERACT DUP_area) WITH WIDTH > 20) INTERACT DUP_area
 md_WAIVE_2_convex = CONVEX EDGE md_CHECK ANGLE1==270 ANGLE2==270
 md_WAIVE_1_convex = LENGTH (CONVEX EDGE md_CHECK ANGLE1==270 ANGLE2==90) < 3
 md_WAIVE_2_convex_EXP = (EXPAND EDGE md_WAIVE_2_convex OUTSIDE BY 0.001) WITH EDGE md_WAIVE_1_convex == 2
 md_WAIVE_1_convex_EXP = ((EXPAND EDGE md_WAIVE_1_convex OUTSIDE BY 0.001) WITH EDGE md_WAIVE_2_convex == 1) INTERACT md_WAIVE_2_convex_EXP
 md_WAIVE_ALL = EXTENTS (OR md_WAIVE_1_convex_EXP md_WAIVE_2_convex_EXP)

 md_IN_pad = (md_CHECK OR md_WAIVE_ALL) NOT OUTSIDE DUP_area
 md_IN_pad_SKEW = ANGLE md_IN_pad > 44 < 46
 md_IN_pad_ORTV = ANGLE (CONVEX EDGE md_IN_pad == 2) == 90
 md_IN_pad_ORTH = ANGLE (CONVEX EDGE md_IN_pad == 2) == 0
 md_IN_pad_GOOD = ((md_IN_pad WITH EDGE md_IN_pad_ORTV == 2) WITH EDGE md_IN_pad_ORTH == 2) WITH EDGE md_IN_pad_SKEW == 4
 md_IN_pad_EXTENT = EXTENTS md_IN_pad_GOOD
 md_IN_pad_CORNER_less = INT md_IN_pad_EXTENT < 1.414-GLOBAL_TOLERANCE ABUT==90 INTERSECTING ONLY REGION
 md_IN_pad_CORNER_more = INT md_IN_pad_EXTENT < 3.536+GLOBAL_TOLERANCE ABUT==90 INTERSECTING ONLY REGION

 err1 = (md_IN_pad NOT md_IN_pad_GOOD) OR (INT md_CHECK < 0.1 ABUT<90 INTERSECTING ONLY REGION)
 err2 = EXPAND EDGE (md_IN_pad_SKEW INSIDE EDGE md_IN_pad_CORNER_less) OUTSIDE BY 0.001
 err3 = EXPAND EDGE (md_IN_pad_SKEW OUTSIDE EDGE md_IN_pad_CORNER_more) OUTSIDE BY 0.001
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
}

Q: MD/ALPA/PA/TM/TM-1 patterns in wire bond pad area should have 4 corners with 45° cut for corner stress relief. The length of corner cut >= 2um <= 5um
A: 
WBPAD_9_R_TM_1 {
@ MD/ALPA/PA/TM/TM-1 patterns in wire bond pad area should have 4 corners with 45° cut for corner stress relief. The length of corner cut >= 2um <= 5um
 md_CHECK = ((TM_1 INTERACT DUP_area) WITH WIDTH > 20) INTERACT DUP_area
 md_WAIVE_2_convex = CONVEX EDGE md_CHECK ANGLE1==270 ANGLE2==270
 md_WAIVE_1_convex = LENGTH (CONVEX EDGE md_CHECK ANGLE1==270 ANGLE2==90) < 3
 md_WAIVE_2_convex_EXP = (EXPAND EDGE md_WAIVE_2_convex OUTSIDE BY 0.001) WITH EDGE md_WAIVE_1_convex == 2
 md_WAIVE_1_convex_EXP = ((EXPAND EDGE md_WAIVE_1_convex OUTSIDE BY 0.001) WITH EDGE md_WAIVE_2_convex == 1) INTERACT md_WAIVE_2_convex_EXP
 md_WAIVE_ALL = EXTENTS (OR md_WAIVE_1_convex_EXP md_WAIVE_2_convex_EXP)

 md_IN_pad = (md_CHECK OR md_WAIVE_ALL) NOT OUTSIDE DUP_area
 md_IN_pad_SKEW = ANGLE md_IN_pad > 44 < 46
 md_IN_pad_ORTV = ANGLE (CONVEX EDGE md_IN_pad == 2) == 90
 md_IN_pad_ORTH = ANGLE (CONVEX EDGE md_IN_pad == 2) == 0
 md_IN_pad_GOOD = ((md_IN_pad WITH EDGE md_IN_pad_ORTV == 2) WITH EDGE md_IN_pad_ORTH == 2) WITH EDGE md_IN_pad_SKEW == 4
 md_IN_pad_EXTENT = EXTENTS md_IN_pad_GOOD
 md_IN_pad_CORNER_less = INT md_IN_pad_EXTENT < 1.414-GLOBAL_TOLERANCE ABUT==90 INTERSECTING ONLY REGION
 md_IN_pad_CORNER_more = INT md_IN_pad_EXTENT < 3.536+GLOBAL_TOLERANCE ABUT==90 INTERSECTING ONLY REGION

 err1 = (md_IN_pad NOT md_IN_pad_GOOD) OR (INT md_CHECK < 0.1 ABUT<90 INTERSECTING ONLY REGION)
 err2 = EXPAND EDGE (md_IN_pad_SKEW INSIDE EDGE md_IN_pad_CORNER_less) OUTSIDE BY 0.001
 err3 = EXPAND EDGE (md_IN_pad_SKEW OUTSIDE EDGE md_IN_pad_CORNER_more) OUTSIDE BY 0.001
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
}


//CHIPB

Q: CHIPB layer (GDS No: 127;3) must be drawn
A: 
CHIPB_R_1a {
@ CHIPB layer (GDS No: 127;3) must be drawn
 err1 = DRC:1 NOT INTERACT CHIPB
 err1 NOT INSIDE SealR_NOT_BULK
}

Q: CHIPB must be rectangular and orthogonal to grid
A: 
CHIPB_R_2 {
@ CHIPB must be rectangular and orthogonal to grid
 err1 = NOT RECTANGLE CHIPB ORTHOGONAL ONLY
 err1 NOT INSIDE SealR_NOT_BULK
}

Q: Only one CHIPB is allowed in a chip
    Notice: CHIPB must be drawn for CELLB on-grid check
A: 
CHIPB_R_3_no_CHIPB {
@ Only one CHIPB is allowed in a chip
@ Notice: CHIPB must be drawn for CELLB on-grid check
//; DRC:1:LOGO = EXTENT DRAWN ORIGINAL IGNORE LOGO
 err1 = BULK NOT INTERACT CHIPB
 err1 NOT INSIDE SealR_NOT_BULK
}

Q: Only one CHIPB is allowed in a chip
    Notice: CHIPB must be drawn for CELLB on-grid check
A: 
CHIPB_R_3_more_than_2_CHIPB {
@ Only one CHIPB is allowed in a chip
@ Notice: CHIPB must be drawn for CELLB on-grid check
//; DRC:1:LOGO = EXTENT DRAWN ORIGINAL IGNORE LOGO
 err1 = CHIPB INTERACT (DRC:1 INTERACT CHIPB > 1)
 err1 NOT INSIDE SealR_NOT_BULK
}

Q: CHIPB edge must be on an integer multiple of 0.010um
A: 
CHIPB_R_4 {
@ CHIPB edge must be on an integer multiple of 0.010um
 err1 = LENGTH CHIPB < 0.010
 err2 = DFM PROPERTY CHIPB_h_edges CHIPB OVERLAP ABUT ALSO MULTI [-= ABS(REMAINDER((LENGTH(CHIPB_h_edges) - 0.010),0.010))] > 0
 err3 = DFM PROPERTY CHIPB_v_edges CHIPB OVERLAP ABUT ALSO MULTI [-= ABS(REMAINDER((LENGTH(CHIPB_v_edges) - 0.010),0.010))] > 0
 err1 NOT INSIDE EDGE SealR_NOT_BULK
 err2 NOT INSIDE EDGE SealR_NOT_BULK
 err3 NOT INSIDE EDGE SealR_NOT_BULK
}

//OCCD

Q: OCCDB is for all BEOL OCCD marker recognition, OCCDB must be drawn the same as ((OCCDM1 OR OCCDMn) OR OCCDBn)
A: 
OCCD_R_1 {
@ OCCDB is for all BEOL OCCD marker recognition, OCCDB must be drawn the same as ((OCCDM1 OR OCCDMn) OR OCCDBn)
 err1 = OCCDB NOT COIN INSIDE EDGE (OR OCCDM1 OCCDM2 OCCDM3 OCCDM4 OCCDM5 OCCDM6 OCCDM7 OCCDM8 OCCDB1 OCCDB2)
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

Q: OCCD is for all OCCD markers recognition, OCCD must be drawn the same as (OCCDFH OR OCCDB)
A: 
OCCD_R_2 {
@ OCCD is for all OCCD markers recognition, OCCD must be drawn the same as (OCCDFH OR OCCDB)
 err1 = OCCD NOT COIN INSIDE EDGE (OR OCCDFH OCCDB)
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}
 
Q: OCCDFH overlap with PSUB, DG, LOGO, INST, MARKS, MARKG, NODMF, OCOVL, DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, V0DUB, M1DUB, EFUSE, RESNW, RESP1, RESP2, ESDIO2, DSTR, DIOMK2, DMPNP, VARMOS, LDBK, INDMY, FUSEMK1, DUM_AA, DUM_AR, DUM_GT, DUM_P2, DUM_M0, DUM_M0C, DUM_M0G, DUM_V0, DUM_M1, SNDUM, SPDUM, NPAA, PPAA, AR_H, AR_V, DIOMK1, ESDIO1, SVT_N edge, SVT_P edge, HVT_N edge, HVT_P edge, LVT_N edge, LVT_P edge, ULVT_N edge, ULVT_P edge, LFN_N edge, LFN_P edge, MTFUSE, CTOP, AR_HDOP, AR_VDOP OCCDM1 is not allowed
A: 
OCCD_R_3 {
@ OCCDFH overlap with PSUB, DG, LOGO, INST, MARKS, MARKG, NODMF, OCOVL, DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, V0DUB, M1DUB, EFUSE, RESNW, RESP1, RESP2, ESDIO2, DSTR, DIOMK2, DMPNP, VARMOS, LDBK, INDMY, FUSEMK1, DUM_AA, DUM_AR, DUM_GT, DUM_P2, DUM_M0, DUM_M0C, DUM_M0G, DUM_V0, DUM_M1, SNDUM, SPDUM, NPAA, PPAA, AR_H, AR_V, DIOMK1, ESDIO1, SVT_N edge, SVT_P edge, HVT_N edge, HVT_P edge, LVT_N edge, LVT_P edge, ULVT_N edge, ULVT_P edge, LFN_N edge, LFN_P edge, MTFUSE, CTOP, AR_HDOP, AR_VDOP OCCDM1 is not allowed
 err1 = OCCDFH AND (OR PSUB DG LOGO INST MARKS MARKG NODMF OCOVL DUMBA DUMBP ARDUB P2DUB M0DUB M0CDUB M0GDUB V0DUB M1DUB EFUSE RESNW RESP1 RESP2 ESDIO2 DSTR DIOMK2 DMPNP VARMOS LDBK INDMY FUSEMK1 DUM_AA DUM_AR DUM_GT DUM_P2 DUM_M0 DUM_M0C DUM_M0G DUM_V0 DUM_M1 SNDUM SPDUM NPAA PPAA AR_H AR_V DIOMK1 ESDIO1 MTFUSE CTOP AR_HDOP AR_VDOP OCCDM1)
 err1 NOT INSIDE SealR_NOT_BULK
 err2_SVT_N = SVT_N NOT OUTSIDE EDGE OCCDFH
 err2_SVT_N NOT INSIDE EDGE SealR_NOT_BULK
 err2_SVT_P = SVT_P NOT OUTSIDE EDGE OCCDFH
 err2_SVT_P NOT INSIDE EDGE SealR_NOT_BULK
 err2_HVT_N = HVT_N NOT OUTSIDE EDGE OCCDFH
 err2_HVT_N NOT INSIDE EDGE SealR_NOT_BULK
 err2_HVT_P = HVT_P NOT OUTSIDE EDGE OCCDFH
 err2_HVT_P NOT INSIDE EDGE SealR_NOT_BULK
 err2_LVT_N = LVT_N NOT OUTSIDE EDGE OCCDFH
 err2_LVT_N NOT INSIDE EDGE SealR_NOT_BULK
 err2_LVT_P = LVT_P NOT OUTSIDE EDGE OCCDFH
 err2_LVT_P NOT INSIDE EDGE SealR_NOT_BULK
 err2_ULVT_N = ULVT_N NOT OUTSIDE EDGE OCCDFH
 err2_ULVT_N NOT INSIDE EDGE SealR_NOT_BULK
 err2_ULVT_P = ULVT_P NOT OUTSIDE EDGE OCCDFH
 err2_ULVT_P NOT INSIDE EDGE SealR_NOT_BULK
 err2_LFN_N = LFN_N NOT OUTSIDE EDGE OCCDFH
 err2_LFN_N NOT INSIDE EDGE SealR_NOT_BULK
 err2_LFN_P = LFN_P NOT OUTSIDE EDGE OCCDFH
 err2_LFN_P NOT INSIDE EDGE SealR_NOT_BULK
}
 
Q: OCCDM1 overlap with INST, LOGO, MARKS, MARKG, NODMF, OCOVL, M1DUB, MTFUSE, MOMDMY, INDMY, FUSEMK1, DUM_M1, CTOP is not allowed
A: 
OCCD_R_4 {
@ OCCDM1 overlap with INST, LOGO, MARKS, MARKG, NODMF, OCOVL, M1DUB, MTFUSE, MOMDMY, INDMY, FUSEMK1, DUM_M1, CTOP is not allowed
 err1 = OCCDM1 AND (OR INDMY INST LOGO MARKS MARKG NODMF OCOVL M1DUB MTFUSE MOMDMY FUSEMK1 DUM_M1 CTOP)
 err1 NOT INSIDE SealR_NOT_BULK
}
 
Q: OCCDMn (n = 2~8, respectively) overlap with INST, LOGO, MARKS, MARKG, NODMF, OCOVL, MnDUB, MTFUSE, MOMDMY, INDMY, FUSEMK1, DUM_Mn, CTOP is not allowed
A: 
OCCD_R_5_OCCDM2 {
@ OCCDMn (n = 2~8, respectively) overlap with INST, LOGO, MARKS, MARKG, NODMF, OCOVL, MnDUB, MTFUSE, MOMDMY, INDMY, FUSEMK1, DUM_Mn, CTOP is not allowed
 err1 = OCCDM2 AND (OR INDMY INST LOGO MARKS MARKG NODMF OCOVL M2DUB MTFUSE MOMDMY FUSEMK1 DUM_M2 CTOP)
 err1 NOT INSIDE SealR_NOT_BULK
}
 
Q: OCCDMn (n = 2~8, respectively) overlap with INST, LOGO, MARKS, MARKG, NODMF, OCOVL, MnDUB, MTFUSE, MOMDMY, INDMY, FUSEMK1, DUM_Mn, CTOP is not allowed
A: 
OCCD_R_5_OCCDM3 {
@ OCCDMn (n = 2~8, respectively) overlap with INST, LOGO, MARKS, MARKG, NODMF, OCOVL, MnDUB, MTFUSE, MOMDMY, INDMY, FUSEMK1, DUM_Mn, CTOP is not allowed
 err1 = OCCDM3 AND (OR INDMY INST LOGO MARKS MARKG NODMF OCOVL M3DUB MTFUSE MOMDMY FUSEMK1 DUM_M3 CTOP)
 err1 NOT INSIDE SealR_NOT_BULK
}
 
Q: OCCDMn (n = 2~8, respectively) overlap with INST, LOGO, MARKS, MARKG, NODMF, OCOVL, MnDUB, MTFUSE, MOMDMY, INDMY, FUSEMK1, DUM_Mn, CTOP is not allowed
A: 
OCCD_R_5_OCCDM4 {
@ OCCDMn (n = 2~8, respectively) overlap with INST, LOGO, MARKS, MARKG, NODMF, OCOVL, MnDUB, MTFUSE, MOMDMY, INDMY, FUSEMK1, DUM_Mn, CTOP is not allowed
 err1 = OCCDM4 AND (OR INDMY INST LOGO MARKS MARKG NODMF OCOVL M4DUB MTFUSE MOMDMY FUSEMK1 DUM_M4 CTOP)
 err1 NOT INSIDE SealR_NOT_BULK
}
 
Q: OCCDMn (n = 2~8, respectively) overlap with INST, LOGO, MARKS, MARKG, NODMF, OCOVL, MnDUB, MTFUSE, MOMDMY, INDMY, FUSEMK1, DUM_Mn, CTOP is not allowed
A: 
OCCD_R_5_OCCDM5 {
@ OCCDMn (n = 2~8, respectively) overlap with INST, LOGO, MARKS, MARKG, NODMF, OCOVL, MnDUB, MTFUSE, MOMDMY, INDMY, FUSEMK1, DUM_Mn, CTOP is not allowed
 err1 = OCCDM5 AND (OR INDMY INST LOGO MARKS MARKG NODMF OCOVL M5DUB MTFUSE MOMDMY FUSEMK1 DUM_M5 CTOP)
 err1 NOT INSIDE SealR_NOT_BULK
}
 
Q: OCCDMn (n = 2~8, respectively) overlap with INST, LOGO, MARKS, MARKG, NODMF, OCOVL, MnDUB, MTFUSE, MOMDMY, INDMY, FUSEMK1, DUM_Mn, CTOP is not allowed
A: 
OCCD_R_5_OCCDM6 {
@ OCCDMn (n = 2~8, respectively) overlap with INST, LOGO, MARKS, MARKG, NODMF, OCOVL, MnDUB, MTFUSE, MOMDMY, INDMY, FUSEMK1, DUM_Mn, CTOP is not allowed
 err1 = OCCDM6 AND (OR INDMY INST LOGO MARKS MARKG NODMF OCOVL M6DUB MTFUSE MOMDMY FUSEMK1 DUM_M6 CTOP)
 err1 NOT INSIDE SealR_NOT_BULK
}
 
Q: OCCDMn (n = 2~8, respectively) overlap with INST, LOGO, MARKS, MARKG, NODMF, OCOVL, MnDUB, MTFUSE, MOMDMY, INDMY, FUSEMK1, DUM_Mn, CTOP is not allowed
A: 
OCCD_R_5_OCCDM7 {
@ OCCDMn (n = 2~8, respectively) overlap with INST, LOGO, MARKS, MARKG, NODMF, OCOVL, MnDUB, MTFUSE, MOMDMY, INDMY, FUSEMK1, DUM_Mn, CTOP is not allowed
 err1 = OCCDM7 AND (OR INDMY INST LOGO MARKS MARKG NODMF OCOVL M7DUB MTFUSE MOMDMY FUSEMK1 DUM_M7 CTOP)
 err1 NOT INSIDE SealR_NOT_BULK
}
 
Q:  OCCDBn (n = 1~2, respectively) overlap with INDMY, INST, LOGO, MARKS, MARKG, NODMF, OCOVL, BnDUB, MOMDMY, FUSEMK1, DUM_Bn, CTOP is not allowed
A: 
OCCD_R_6_OCCDB1 {
@ OCCDBn (n = 1~2, respectively) overlap with INDMY, INST, LOGO, MARKS, MARKG, NODMF, OCOVL, BnDUB, MOMDMY, FUSEMK1, DUM_Bn, CTOP is not allowed
 err1 = OCCDB1 AND (OR INDMY INST LOGO MARKS MARKG NODMF OCOVL B1DUB MOMDMY FUSEMK1 DUM_B1i CTOP)
 err1 NOT INSIDE SealR_NOT_BULK
}
 
Q: OCCDBn (n = 1~2, respectively) overlap with INDMY, INST, LOGO, MARKS, MARKG, NODMF, OCOVL, BnDUB, MOMDMY, FUSEMK1, DUM_Bn, CTOP is not allowed
A: 
OCCD_R_6_OCCDB2 {
@ OCCDBn (n = 1~2, respectively) overlap with INDMY, INST, LOGO, MARKS, MARKG, NODMF, OCOVL, BnDUB, MOMDMY, FUSEMK1, DUM_Bn, CTOP is not allowed
 err1 = OCCDB2 AND (OR INDMY INST LOGO MARKS MARKG NODMF OCOVL B2DUB MOMDMY FUSEMK1 DUM_B2i CTOP)
 err1 NOT INSIDE SealR_NOT_BULK
}
 
chip_window = DRC:1 WITH WIDTH >= 500

#IFDEF RECOMMENDED_CHECK YES

 
Q: Recommended at least one OCCDFH in each 2000umx2000um window of chip
A: 
OCCD_R_7_R {
@ Recommended at least one OCCDFH in each 2000umx2000um window of chip
 err1 = DENSITY OCCDFH chip_window [!AREA(chip_window) + AREA(OCCDFH)] == 0 WINDOW 2000 STEP 1000 BACKUP INSIDE OF LAYER DRC:1 BY POLYGON
 err1 NOT INSIDE SealR_NOT_BULK
}
 
Q: Recommended at least one OCCDM1 in each 2000umx2000um window of chip
A: 
OCCD_R_8_R {
@ Recommended at least one OCCDM1 in each 2000umx2000um window of chip
 err1 = DENSITY OCCDM1 chip_window [!AREA(chip_window) + AREA(OCCDM1)] == 0 WINDOW 2000 STEP 1000 BACKUP INSIDE OF LAYER DRC:1 BY POLYGON
 err1 NOT INSIDE SealR_NOT_BULK
}
 
Q: Recommended at least one OCCDMn (n = 2~8, respectively) in each 2000umx2000um window of chip
A: 
OCCD_R_9_OCCDM2_R {
@ Recommended at least one OCCDMn (n = 2~8, respectively) in each 2000umx2000um window of chip
 err1 = DENSITY OCCDM2 chip_window [!AREA(chip_window) + AREA(OCCDM2)] == 0 WINDOW 2000 STEP 1000 BACKUP INSIDE OF LAYER DRC:1 BY POLYGON
 err1 NOT INSIDE SealR_NOT_BULK
}
 
Q: Recommended at least one OCCDMn (n = 2~8, respectively) in each 2000umx2000um window of chip
A: 
OCCD_R_9_OCCDM3_R {
@ Recommended at least one OCCDMn (n = 2~8, respectively) in each 2000umx2000um window of chip
 err1 = DENSITY OCCDM3 chip_window [!AREA(chip_window) + AREA(OCCDM3)] == 0 WINDOW 2000 STEP 1000 BACKUP INSIDE OF LAYER DRC:1 BY POLYGON
 err1 NOT INSIDE SealR_NOT_BULK
}
 
Q: Recommended at least one OCCDMn (n = 2~8, respectively) in each 2000umx2000um window of chip
A: 
OCCD_R_9_OCCDM4_R {
@ Recommended at least one OCCDMn (n = 2~8, respectively) in each 2000umx2000um window of chip
 err1 = DENSITY OCCDM4 chip_window [!AREA(chip_window) + AREA(OCCDM4)] == 0 WINDOW 2000 STEP 1000 BACKUP INSIDE OF LAYER DRC:1 BY POLYGON
 err1 NOT INSIDE SealR_NOT_BULK
}
 
Q: Recommended at least one OCCDMn (n = 2~8, respectively) in each 2000umx2000um window of chip
A: 
OCCD_R_9_OCCDM5_R {
@ Recommended at least one OCCDMn (n = 2~8, respectively) in each 2000umx2000um window of chip
 err1 = DENSITY OCCDM5 chip_window [!AREA(chip_window) + AREA(OCCDM5)] == 0 WINDOW 2000 STEP 1000 BACKUP INSIDE OF LAYER DRC:1 BY POLYGON
 err1 NOT INSIDE SealR_NOT_BULK
}
 
Q: Recommended at least one OCCDMn (n = 2~8, respectively) in each 2000umx2000um window of chip
A: 
OCCD_R_9_OCCDM6_R {
@ Recommended at least one OCCDMn (n = 2~8, respectively) in each 2000umx2000um window of chip
 err1 = DENSITY OCCDM6 chip_window [!AREA(chip_window) + AREA(OCCDM6)] == 0 WINDOW 2000 STEP 1000 BACKUP INSIDE OF LAYER DRC:1 BY POLYGON
 err1 NOT INSIDE SealR_NOT_BULK
}
 
Q: Recommended at least one OCCDMn (n = 2~8, respectively) in each 2000umx2000um window of chip
A: 
OCCD_R_9_OCCDM7_R {
@ Recommended at least one OCCDMn (n = 2~8, respectively) in each 2000umx2000um window of chip
 err1 = DENSITY OCCDM7 chip_window [!AREA(chip_window) + AREA(OCCDM7)] == 0 WINDOW 2000 STEP 1000 BACKUP INSIDE OF LAYER DRC:1 BY POLYGON
 err1 NOT INSIDE SealR_NOT_BULK
}
 
Q: Recommended at least one OCCDBn (n = 1~2, respectively) in each 2000umx2000um window of chip
A: 
OCCD_R_10_OCCDB1_R {
@ Recommended at least one OCCDBn (n = 1~2, respectively) in each 2000umx2000um window of chip
 err1 = DENSITY OCCDB1 chip_window [!AREA(chip_window) + AREA(OCCDB1)] == 0 WINDOW 2000 STEP 1000 BACKUP INSIDE OF LAYER DRC:1 BY POLYGON
 err1 NOT INSIDE SealR_NOT_BULK
}
 
Q: Recommended at least one OCCDBn (n = 1~2, respectively) in each 2000umx2000um window of chip
A: 
OCCD_R_10_OCCDB2_R {
@ Recommended at least one OCCDBn (n = 1~2, respectively) in each 2000umx2000um window of chip
 err1 = DENSITY OCCDB2 chip_window [!AREA(chip_window) + AREA(OCCDB2)] == 0 WINDOW 2000 STEP 1000 BACKUP INSIDE OF LAYER DRC:1 BY POLYGON
 err1 NOT INSIDE SealR_NOT_BULK
}


//OCOVL

Q: OCOVL should be drawn the same as (OCOVL_FEOL OR OCOVL_BEOL)
A: 
OCOVL_R_1 {
@ OCOVL should be drawn the same as (OCOVL_FEOL OR OCOVL_BEOL)
 err1 = OCOVL NOT COIN INSIDE EDGE (OR OCOVL_FEOL OCOVL_BEOL)
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

Q: OCOVL_FEOL overlap DNW, NW, PSUB, AA, GT_P96, SN, SP, DG, V0, LOGO, INST, MARKS, MARKG, NODMF, OCCD, DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, V0DUB, EFUSE, RESNW, RESP1, RESP2, ESDIO2, DSTR, DIOMK2, DMPNP, VARMOS, LDBK, INDMY, FUSEMK1, DUM_AA, DUM_AR, DUM_GT, DUM_P2, DUM_M0, DUM_M0C, DUM_M0G, DUM_V0, SNDUM, SPDUM, NPAA, CELLB edge, DIOMK1, ESDIO1, SVT_N edge, SVT_P edge, HVT_N edge, HVT_P edge, LVT_N edge, LVT_P edge, ULVT_N edge, ULVT_P edge, LFN_N edge, LFN_P edge, MTFUSE, CTOP, AR_HDOP, AR_VDOP is not allowed
A: 
OCOVL_R_3 {
@ OCOVL_FEOL overlap DNW, NW, PSUB, AA, GT_P96, SN, SP, DG, V0, LOGO, INST, MARKS, MARKG, NODMF, OCCD, DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, V0DUB, EFUSE, RESNW, RESP1, RESP2, ESDIO2, DSTR, DIOMK2, DMPNP, VARMOS, LDBK, INDMY, FUSEMK1, DUM_AA, DUM_AR, DUM_GT, DUM_P2, DUM_M0, DUM_M0C, DUM_M0G, DUM_V0, SNDUM, SPDUM, NPAA, CELLB edge, DIOMK1, ESDIO1, SVT_N edge, SVT_P edge, HVT_N edge, HVT_P edge, LVT_N edge, LVT_P edge, ULVT_N edge, ULVT_P edge, LFN_N edge, LFN_P edge, MTFUSE, CTOP, AR_HDOP, AR_VDOP is not allowed
 err1 = OCOVL_FEOL and (OR DNW NW PSUB AA GT_P96 SN SP DG V0 LOGO INST MARKS MARKG NODMF OCCD DUMBA DUMBP ARDUB P2DUB M0DUB M0CDUB M0GDUB V0DUB EFUSE RESNW RESP1 RESP2 ESDIO2 DSTR DIOMK2 DMPNP VARMOS LDBK INDMY FUSEMK1 DUM_AA DUM_AR DUM_GT DUM_P2 DUM_M0 DUM_M0C DUM_M0G DUM_V0 SNDUM SPDUM NPAA MTFUSE CTOP AR_HDOP AR_VDOP DIOMK1 ESDIO1)
 err1 NOT INSIDE SealR_NOT_BULK
}

Q: OCOVL_FEOL overlap DNW, NW, PSUB, AA, GT_P96, SN, SP, DG, V0, LOGO, INST, MARKS, MARKG, NODMF, OCCD, DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, V0DUB, EFUSE, RESNW, RESP1, RESP2, ESDIO2, DSTR, DIOMK2, DMPNP, VARMOS, LDBK, INDMY, FUSEMK1, DUM_AA, DUM_AR, DUM_GT, DUM_P2, DUM_M0, DUM_M0C, DUM_M0G, DUM_V0, SNDUM, SPDUM, NPAA, CELLB edge, DIOMK1, ESDIO1, SVT_N edge, SVT_P edge, HVT_N edge, HVT_P edge, LVT_N edge, LVT_P edge, ULVT_N edge, ULVT_P edge, LFN_N edge, LFN_P edge, MTFUSE, CTOP, AR_HDOP, AR_VDOP is not allowed
A: 
OCOVL_R_3_VT {
@ OCOVL_FEOL overlap DNW, NW, PSUB, AA, GT_P96, SN, SP, DG, V0, LOGO, INST, MARKS, MARKG, NODMF, OCCD, DUMBA, DUMBP, ARDUB, P2DUB, M0DUB, M0CDUB, M0GDUB, V0DUB, EFUSE, RESNW, RESP1, RESP2, ESDIO2, DSTR, DIOMK2, DMPNP, VARMOS, LDBK, INDMY, FUSEMK1, DUM_AA, DUM_AR, DUM_GT, DUM_P2, DUM_M0, DUM_M0C, DUM_M0G, DUM_V0, SNDUM, SPDUM, NPAA, CELLB edge, DIOMK1, ESDIO1, SVT_N edge, SVT_P edge, HVT_N edge, HVT_P edge, LVT_N edge, LVT_P edge, ULVT_N edge, ULVT_P edge, LFN_N edge, LFN_P edge, MTFUSE, CTOP, AR_HDOP, AR_VDOP is not allowed
 err1 = (OR (EXPAND EDGE (CELLB INSIDE EDGE OCOVL_FEOL) BY 0.001) (EXPAND EDGE (SVT_N INSIDE EDGE OCOVL_FEOL) BY 0.001) (EXPAND EDGE (SVT_P INSIDE EDGE OCOVL_FEOL) BY 0.001) (EXPAND EDGE (HVT_N INSIDE EDGE OCOVL_FEOL) BY 0.001) (EXPAND EDGE (HVT_P INSIDE EDGE OCOVL_FEOL) BY 0.001) (EXPAND EDGE (LVT_N INSIDE EDGE OCOVL_FEOL) BY 0.001) (EXPAND EDGE (LVT_P INSIDE EDGE OCOVL_FEOL) BY 0.001) (EXPAND EDGE (ULVT_N INSIDE EDGE OCOVL_FEOL) BY 0.001) (EXPAND EDGE (ULVT_P INSIDE EDGE OCOVL_FEOL) BY 0.001) (EXPAND EDGE (LFN_N INSIDE EDGE OCOVL_FEOL) BY 0.001) (EXPAND EDGE (LFN_P INSIDE EDGE OCOVL_FEOL) BY 0.001)) AND OCOVL_FEOL
 err1 NOT INSIDE SealR_NOT_BULK
}

Q: OCOVLM1CA overlap AA, M1CB, GT, M0C, M0G, INDMY, INST, LOGO, MARKS, MARKG, NODMF, OCCD, MTFUSE, MOMDMY, FUSEMK1, DUMBA, M1DUB, M0DUB, DUMBP, M0CDUB, M0GDUB, DUM_AA, DUM_M1, DUM_M0, DUM_GT, DUM_M0C, DUM_M0G, CTOP is not allowed
A: 
OCOVL_R_4 {
@ OCOVLM1CA overlap AA, M1CB, GT, M0C, M0G, INDMY, INST, LOGO, MARKS, MARKG, NODMF, OCCD, MTFUSE, MOMDMY, FUSEMK1, DUMBA, M1DUB, M0DUB, DUMBP, M0CDUB, M0GDUB, DUM_AA, DUM_M1, DUM_M0, DUM_GT, DUM_M0C, DUM_M0G, CTOP is not allowed
 err1 = OCOVLM1CA and (OR AA M1CB GT M0C M0G INDMY INST LOGO MARKS MARKG NODMF OCCD MTFUSE MOMDMY FUSEMK1 DUMBA M1DUB M0DUB DUMBP M0CDUB M0GDUB DUM_AA DUM_M1 DUM_M0 DUM_GT DUM_M0C DUM_M0G CTOP)
 err1 NOT INSIDE SealR_NOT_BULK
}

Q: OCOVLM1CB overlap INDMY, INST, LOGO, MARKS, MARKG, NODMF, OCCD, MTFUSE, MOMDMY, FUSEMK1, M1DUB, M0DUB, M0CDUB, M0GDUB, DUM_M1, DUM_M0, DUM_M0C, DUM_M0G, CTOP is not allowed\
A: 
OCOVL_R_5 {
@ OCOVLM1CB overlap INDMY, INST, LOGO, MARKS, MARKG, NODMF, OCCD, MTFUSE, MOMDMY, FUSEMK1, M1DUB, M0DUB, M0CDUB, M0GDUB, DUM_M1, DUM_M0, DUM_M0C, DUM_M0G, CTOP is not allowed
 err1 = OCOVLM1CB and (OR INDMY INST LOGO MARKS MARKG NODMF OCCD MTFUSE MOMDMY FUSEMK1 M1DUB M0DUB M0CDUB M0GDUB DUM_M1 DUM_M0 DUM_M0C DUM_M0G CTOP)
 err1 NOT INSIDE SealR_NOT_BULK
}

Q: OCOVLM2CA overlap M1CB, M2CB, M0C, M0, V0, INDMY, INST, LOGO, MARKS, MARKG, NODMF, OCCD, MTFUSE, MOMDMY, FUSEMK1, M1DUB, M2DUB, M0GDUB, M0CDUB, M0DUB, V0DUB, DUM_M1, DUM_M2, DUM_M0G, DUM_M0C, DUM_M0, DUM_V0, CTOP is not allowed
A: 
OCOVL_R_6 {
@ OCOVLM2CA overlap M1CB, M2CB, M0C, M0, V0, INDMY, INST, LOGO, MARKS, MARKG, NODMF, OCCD, MTFUSE, MOMDMY, FUSEMK1, M1DUB, M2DUB, M0GDUB, M0CDUB, M0DUB, V0DUB, DUM_M1, DUM_M2, DUM_M0G, DUM_M0C, DUM_M0, DUM_V0, CTOP is not allowed
 err1 = OCOVLM2CA and (OR M1CB M2CB M0C M0 V0 INDMY INST LOGO MARKS MARKG NODMF OCCD MTFUSE MOMDMY FUSEMK1 M1DUB M2DUB M0GDUB M0CDUB M0DUB V0DUB DUM_M1 DUM_M2 DUM_M0G DUM_M0C DUM_M0 DUM_V0 CTOP)
 err1 NOT INSIDE SealR_NOT_BULK
}

Q: OCOVLM4 overlap M1CB, M2CB, M3CB, V0, V1, V2, V3, INDMY, INST, LOGO, MARKS, MARKG, NODMF, OCCD, MTFUSE, MOMDMY, FUSEMK1, M3DUB, M4DUB, DUM_M1, DUM_M2, DUM_M3, DUM_M4, DUM_V0, DUM_V1, DUM_V2, DUM_V3, CTOP is not allowed
A: 
OCOVL_R_7 {
@ OCOVLM4 overlap M1CB, M2CB, M3CB, V0, V1, V2, V3, INDMY, INST, LOGO, MARKS, MARKG, NODMF, OCCD, MTFUSE, MOMDMY, FUSEMK1, M3DUB, M4DUB, DUM_M1, DUM_M2, DUM_M3, DUM_M4, DUM_V0, DUM_V1, DUM_V2, DUM_V3, CTOP is not allowed
 err1 = OCOVLM4 and (OR M1CB M2CB M3CB V0 V1 V2 V3 INDMY INST LOGO MARKS MARKG NODMF OCCD MTFUSE MOMDMY FUSEMK1 M3DUB M4DUB DUM_M1 DUM_M2 DUM_M3 DUM_M4 DUM_V0 DUM_V1 DUM_V2 DUM_V3 CTOP)
 err1 NOT INSIDE SealR_NOT_BULK
}

Q: OCOVLV0 overlap V0CB, M1CB, INDMY, INST, LOGO, MARKS, MARKG, NODMF, OCCD, MTFUSE, MOMDMY, FUSEMK1, V0DUB, M1DUB, M0GDUB, M0CDUB, M0DUB, DUM_V0, DUM_M1, DUM_M0G, DUM_M0C, DUM_M0, CTOP is not allowed
A: 
OCOVL_R_8 {
@ OCOVLV0 overlap V0CB, M1CB, INDMY, INST, LOGO, MARKS, MARKG, NODMF, OCCD, MTFUSE, MOMDMY, FUSEMK1, V0DUB, M1DUB, M0GDUB, M0CDUB, M0DUB, DUM_V0, DUM_M1, DUM_M0G, DUM_M0C, DUM_M0, CTOP is not allowed
 err1 = OCOVLV0 and (OR V0CB M1CB INDMY INST LOGO MARKS MARKG NODMF OCCD MTFUSE MOMDMY FUSEMK1 V0DUB M1DUB M0GDUB M0CDUB M0DUB DUM_V0 DUM_M1 DUM_M0G DUM_M0C DUM_M0 CTOP)
 err1 NOT INSIDE SealR_NOT_BULK
}

Q: V0, M1, M2, M3 inside OCOVL must be pre-colored
A: 
OCOVL_R_9 {
@ V0, M1, M2, M3 inside OCOVL must be pre-colored
 err1 = (V0 NOT INTERACT (OR V0CA V0CB)) AND OCOVL
 err2 = (M1 NOT INTERACT (OR M1CA M1CB)) AND OCOVL
 err3 = (M2 NOT INTERACT (OR M2CA M2CB)) AND OCOVL
 err4 = (M3 NOT INTERACT (OR M3CA M3CB)) AND OCOVL

 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
 err4 NOT INSIDE SealR_NOT_BULK
}

//HR


Q: Square number (length/width) of high R resistor must be >= 1
A: 
HR_R_1 {
@ Square number (length/width) of high R resistor must be >= 1
 HR_w_side = DIR_AND_RESP2 INSIDE EDGE DIR
 HR_l_side = DIR NOT OUTSIDE EDGE RESP2
 err1 = DFM PROPERTY DIR_AND_RESP2 HR_w_side HR_l_side OVERLAP ABUT ALSO [squares = LENGTH(HR_l_side)/LENGTH(HR_w_side)] < 1
 err1 NOT INSIDE SealR_NOT_BULK
}

Q: DIRDMP must be placed 2-side beside high R resistor
    RESP2/RESP1 must interact two DIRDMPs within 2.3um in HR resistor width direction
A: 
HR_R_2 {
@ DIRDMP must be placed 2-side beside high R resistor
@ RESP2/RESP1 must interact two DIRDMPs within 2.3um in HR resistor width direction
 hr_RES_A_area = (RESP2 NOT DIR) INTERACT DIR_AND_RESP2
 hr_RES_L_side = EXPAND EDGE (DIR_AND_RESP2 COIN EDGE DIR_L_edges) OUTSIDE BY 0.001
 hr_RES_L_s230 = SIZE hr_RES_L_side BY 2.299 INSIDE OF hr_RES_A_area STEP 0.1

 err1 = (hr_RES_L_s230 NOT INTERACT DIRDMP) TOUCH DIR == 1  //;only check the outer-most side
 err2 = RESP1 INTERACT DIRDMP < 2
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

Q: DIR, DIRDMP, and RESP2 (INTERACT DIR) must be 3 rectangle orthogonal to grid respectively
A: 
HR_R_3 {
@ DIR, DIRDMP, and RESP2 (INTERACT DIR) must be 3 rectangle orthogonal to grid respectively
 err1 = NOT RECTANGLE DIR ORTHOGONAL ONLY
 err2 = NOT RECTANGLE DIRDMP ORTHOGONAL ONLY
 err3 = NOT RECTANGLE (RESP2 INTERACT DIR) ORTHOGONAL ONLY
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
}

Q: DIR resistor can only use M0G (width = 0.06um)
A: 
HR_R_4 {
@ DIR resistor can only use M0G (width = 0.06um)
 err1 = (DIR NOT INTERACT M0G_060) OR ((M0G NOT M0G_060) INTERACT DIR)
 err1 NOT INSIDE SealR_NOT_BULK
}

Q: RESP2 must abut with M0G edge, RESP2 must interact at least two DIRDMP
A: 
HR_R_5 {
@ RESP2 must abut with M0G edge, RESP2 must interact at least two DIRDMP
 err1 = (DIR_AND_RESP2 INSIDE EDGE DIR) NOT COIN OUTSIDE EDGE M0G //; not abut with M0G edge
 err2 = RESP2 INTERACT DIRDMP == 1
 err3 = RESP2 NOT INTERACT DIRDMP
 err1 NOT INSIDE EDGE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
}

Q: RESP2 intersecting DIR or DIRDMP must form two or more DIRs or DIRDMPs
A: 
HR_R_6 {
@ RESP2 intersecting DIR or DIRDMP must form two or more DIRs or DIRDMPs
 err1 = INT (RESP2 INSIDE EDGE ALL_DIR) < 0.005 ABUT INTERSECTING ONLY REGION
 err2 = EXPAND EDGE ((DIR_W_edges OR EDGE DIRDMP_W_edges) NOT OUTSIDE EDGE RESP2) BY 0.001
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

DIR_W_edges_in_resp1 = DIR_W_edges NOT OUTSIDE EDGE RESP1
DIR_W_edges_in_resp1_v_edges = ANGLE DIR_W_edges_in_resp1 == 90
DIR_W_edges_in_resp1_h_edges = ANGLE DIR_W_edges_in_resp1 == 0

Q: DIR must be covered by RESP1, and must be uni-direction in the same RESP1
A: 
HR_R_7 {
@ DIR must be covered by RESP1, and must be uni-direction in the same RESP1
 direction_h_DIR = EXPAND EDGE DIR_W_edges_in_resp1_v_edges INSIDE BY 0.001
 direction_v_DIR = EXPAND EDGE DIR_W_edges_in_resp1_h_edges INSIDE BY 0.001
 err1_TMP = (RESP1 INTERACT direction_h_DIR) INTERACT direction_v_DIR
 err1 = direction_h_DIR INTERACT err1_TMP
 err1 NOT INSIDE SealR_NOT_BULK

 err2 = DIR NOT RESP1
 err2 NOT INSIDE SealR_NOT_BULK
}

Q: RESP1 and RESP2 must INTERACT DIR
A: 
HR_R_8 {
@ RESP1 and RESP2 must INTERACT DIR
 err1 = (RESP1 NOT INTERACT DIR) OR (RESP2 NOT INTERACT DIR)
 err1 NOT INSIDE SealR_NOT_BULK
}

Q: M0G (INTERACT DIR) INTERACT GT is not allowed
A: 
HR_R_9 {
@ M0G (INTERACT DIR) INTERACT GT is not allowed
 err1 = (M0G INTERACT DIR) INTERACT GT
 err1 NOT INSIDE SealR_NOT_BULK
}

//HR_NET_vol_neg = HR_c INTERACT MG_NET_vol_neg
//HR_NET_vol_pos = HR_c INTERACT MG_NET_vol_pos
//HR_NET_vol_gt_pos_560 = HR_c INTERACT MG_NET_vol_gt_pos_560
//HR_NET_vol_lt_neg_560 = HR_c INTERACT MG_NET_vol_lt_neg_560

#IFDEF Delta_Voltage_Rules_Check YES
VARIABLE HR_R_10_DIR_2_DIR_val 1.6
VARIABLE HR_R_10_DIR_2_M0_val 3.6
VARIABLE HR_R_10_DIR_2_M0G_val 3.6
VARIABLE HR_R_10_DIR_2_GT_val 0.42
VARIABLE HR_R_10_DIR_2_GT_NOT_P2_val 0.72

Q: Maximum delta V >= 5.6V is not allowed, when:
    1. Space between two DIR/DIRDMP is < 1.6um
    2. Space between DIR/DIRDMP and (AOP_M0G OR (M0 NOT M0C)) is < 3.6um
    3. Space between DIR and AOP_GT is < 0.42um
   4. DIR space to (AOP_GT NOT P2) is < 0.72um
A: 
HR_R_10_DIR_2_DIR {
@ Maximum delta V >= 5.6V is not allowed, when:
@ 1. Space between two DIR/DIRDMP is < 1.6um
@ 2. Space between DIR/DIRDMP and (AOP_M0G OR (M0 NOT M0C)) is < 3.6um
@ 3. Space between DIR and AOP_GT is < 0.42um
@ 4. DIR space to (AOP_GT NOT P2) is < 0.72um
 err1 = DFM DV HR_c < HR_R_10_DIR_2_DIR_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" >= 5.6 ANNOTATE NOT CONNECTED SINGULAR
 DFM COPY err1

 err2 = DFM DV HR_c DIRDMP < HR_R_10_DIR_2_DIR_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" >= 5.6 ANNOTATE NOT CONNECTED SINGULAR
 DFM COPY err2

/*
 err2 = EXT HR_NET_vol_gt_pos_560 DIRDMP < HR_R_10_DIR_2_DIR_val SINGULAR REGION
 err3 = EXT HR_NET_vol_lt_neg_560 DIRDMP < HR_R_10_DIR_2_DIR_val SINGULAR REGION
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
*/
}

Q: Maximum delta V >= 5.6V is not allowed, when:
    1. Space between two DIR/DIRDMP is < 1.6um
    2. Space between DIR/DIRDMP and (AOP_M0G OR (M0 NOT M0C)) is < 3.6um
    3. Space between DIR and AOP_GT is < 0.42um
    4. DIR space to (AOP_GT NOT P2) is < 0.72um
A: 
HR_R_10_DIR_2_M0 {
@ Maximum delta V >= 5.6V is not allowed, when:
@ 1. Space between two DIR/DIRDMP is < 1.6um
@ 2. Space between DIR/DIRDMP and (AOP_M0G OR (M0 NOT M0C)) is < 3.6um
@ 3. Space between DIR and AOP_GT is < 0.42um
@ 4. DIR space to (AOP_GT NOT P2) is < 0.72um
 err1 = DFM DV HR_c M0_NOT_M0C < HR_R_10_DIR_2_M0_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" >= 5.6 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err1

 err2 = DFM DV HR_c delta_DOP_M0 < HR_R_10_DIR_2_M0_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" >= 5.6 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err2

 err3 = DFM DV M0_NOT_M0C DIRDMP < HR_R_10_DIR_2_M0_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" >= 5.6 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err3
}

Q: Maximum delta V >= 5.6V is not allowed, when:
    1. Space between two DIR/DIRDMP is < 1.6um
    2. Space between DIR/DIRDMP and (AOP_M0G OR (M0 NOT M0C)) is < 3.6um
    3. Space between DIR and AOP_GT is < 0.42um
    4. DIR space to (AOP_GT NOT P2) is < 0.72um
A: 
HR_R_10_DIR_2_M0G {
@ Maximum delta V >= 5.6V is not allowed, when:
@ 1. Space between two DIR/DIRDMP is < 1.6um
@ 2. Space between DIR/DIRDMP and (AOP_M0G OR (M0 NOT M0C)) is < 3.6um
@ 3. Space between DIR and AOP_GT is < 0.42um
@ 4. DIR space to (AOP_GT NOT P2) is < 0.72um
 err1 = DFM DV HR_c M0G < HR_R_10_DIR_2_M0G_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" >= 5.6 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err1

 err2 = DFM DV HR_c DOP_M0G < HR_R_10_DIR_2_M0G_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" >= 5.6 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err2

 err3 = DFM DV M0G DIRDMP < HR_R_10_DIR_2_M0G_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" >= 5.6 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err3
}

Q: Maximum delta V >= 5.6V is not allowed, when:
    1. Space between two DIR/DIRDMP is < 1.6um
    2. Space between DIR/DIRDMP and (AOP_M0G OR (M0 NOT M0C)) is < 3.6um
    3. Space between DIR and AOP_GT is < 0.42um
    4. DIR space to (AOP_GT NOT P2) is < 0.72um
A: 
HR_R_10_DIR_2_GT {
@ Maximum delta V >= 5.6V is not allowed, when:
@ 1. Space between two DIR/DIRDMP is < 1.6um
@ 2. Space between DIR/DIRDMP and (AOP_M0G OR (M0 NOT M0C)) is < 3.6um
@ 3. Space between DIR and AOP_GT is < 0.42um
@ 4. DIR space to (AOP_GT NOT P2) is < 0.72um
 err1 = DFM DV HR_c GT_0 < HR_R_10_DIR_2_GT_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" >= 5.6 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err1

 err2 = DFM DV HR_c DOP_GT < HR_R_10_DIR_2_GT_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" >= 5.6 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err2

 err3 = DFM DV GT_0 DIRDMP < HR_R_10_DIR_2_GT_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" >= 5.6 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err3

}

Q: Maximum delta V >= 5.6V is not allowed, when:
    1. Space between two DIR/DIRDMP is < 1.6um
    2. Space between DIR/DIRDMP and (AOP_M0G OR (M0 NOT M0C)) is < 3.6um
    3. Space between DIR and AOP_GT is < 0.42um
    4. DIR space to (AOP_GT NOT P2) is < 0.72um
A: 
HR_R_10_DIR_2_GT_NOT_P2 {
@ Maximum delta V >= 5.6V is not allowed, when:
@ 1. Space between two DIR/DIRDMP is < 1.6um
@ 2. Space between DIR/DIRDMP and (AOP_M0G OR (M0 NOT M0C)) is < 3.6um
@ 3. Space between DIR and AOP_GT is < 0.42um
@ 4. DIR space to (AOP_GT NOT P2) is < 0.72um
 err1 = DFM DV HR_c GT_0 < HR_R_10_DIR_2_GT_NOT_P2_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" >= 5.6 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err1

 err2 = DFM DV HR_c DOP_GT_NOT_P2 < HR_R_10_DIR_2_GT_NOT_P2_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" >= 5.6 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err2

 err3 = DFM DV GT_0 DIRDMP < HR_R_10_DIR_2_GT_NOT_P2_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" >= 5.6 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err3

}
#ENDIF

Q: (RESP2 AND DIR) overlap M0G is not allowed
A: 
HR_R_15 {
@ (RESP2 AND DIR) overlap M0G is not allowed
 err1 = DIR_AND_RESP2 AND M0G
 err1 NOT INSIDE SealR_NOT_BULK
}

Q: DIRDMP length must be same with DIR in DIR length direction
A: 
HR_R_16 {
@ DIRDMP length must be same with DIR in DIR length direction
 chk_area = (RESP2 INTERACT ALL_DIR) NOT ALL_DIR_AND_RESP2
 chk_edge = ALL_DIR TOUCH EDGE (chk_area COIN EDGE ALL_DIR_AND_RESP2)
 err1 = DFM PROPERTY chk_area chk_edge OVERLAP ABUT ALSO MULTI [-= count(chk_edge)] == 2 [+= (max(length(chk_edge)) == min(length(chk_edge))) ? 1 : 0] == 0
 err1 NOT INSIDE SealR_NOT_BULK
}

Q: AADMP/GTDMP/M0GDMP must to be drawn in RESP2 region
    DRC flags Without AADMP
A: 
HR_R_17_AADMP {
@ AADMP/GTDMP/M0GDMP must to be drawn in RESP2 region
@ DRC flags Without AADMP
 chk_area = ((RESP2 INTERACT ALL_DIR) NOT ALL_DIR_AND_RESP2) INTERACT ALL_DIR_AND_RESP2 == 2
 err1 = chk_area NOT INTERACT AADMP
 err1 NOT INSIDE SealR_NOT_BULK
}

Q: AADMP/GTDMP/M0GDMP must to be drawn in RESP2 region
    DRC flags Without GTDMP
A: 
HR_R_17_GTDMP {
@ AADMP/GTDMP/M0GDMP must to be drawn in RESP2 region
@ DRC flags Without GTDMP
 chk_area = ((RESP2 INTERACT ALL_DIR) NOT ALL_DIR_AND_RESP2) INTERACT ALL_DIR_AND_RESP2 == 2
 err1 = chk_area NOT INTERACT GTDMP
 err1 NOT INSIDE SealR_NOT_BULK
}

Q: AADMP/GTDMP/M0GDMP must to be drawn in RESP2 region
    DRC flags Without M0GDMP
A: 
HR_R_17_M0GDMP {
@ AADMP/GTDMP/M0GDMP must to be drawn in RESP2 region
@ DRC flags Without M0GDMP
 chk_area = ((RESP2 INTERACT ALL_DIR) NOT ALL_DIR_AND_RESP2) INTERACT ALL_DIR_AND_RESP2 == 2
 err1 = chk_area NOT INTERACT M0GDMP
 err1 NOT INSIDE SealR_NOT_BULK
}

Q: M0DMP interact with RESP1 is not allowed
A: 
HR_R_18 {
@ M0DMP interact with RESP1 is not allowed
 err1 = M0DMP INTERACT RESP1
 err1 NOT INSIDE SealR_NOT_BULK
}


//RESNW

Q: RESNW horizontal edge must align with AA horizontal edge
A: 
RESNW_R_1 {
@ RESNW horizontal edge must align with AA horizontal edge
 err1 = NWR_BODY TOUCH AA == 1
 err2 = NWR_BODY NOT TOUCH AA
 err3 = NWR_BODY AND AA
 err4 = (RESNW INSIDE EDGE NW) NOT TOUCH EDGE AA
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
 err4 NOT INSIDE EDGE SealR_NOT_BULK
}

Q: RESNW must separate Resistor NW into two or more NWs
A: 
RESNW_R_2 {
@ RESNW must separate Resistor NW into two or more NWs
 nwr_terminal = NWR NOT RESNW
 err1 = NWR_BODY NOT INTERACT nwr_terminal
 err2 = NWR_BODY INTERACT nwr_terminal == 1
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

Q: NW resistor must be rectangle
A: 
RESNW_R_3 {
@ NW resistor must be rectangle
 err1 = NOT RECTANGLE NWR_BODY ORTHOGONAL ONLY
 err1 NOT INSIDE SealR_NOT_BULK
}

Q: DNW, SP, SVT_P, LVT_P, HVT_P, ULVT_P, LFN_P implant layers are not allowed in NW resistor area
A: 
RESNW_R_4 {
@ DNW, SP, SVT_P, LVT_P, HVT_P, ULVT_P, LFN_P implant layers are not allowed in NW resistor area
 err1 = (OR DNW SP SVT_P LVT_P HVT_P ULVT_P LFN_P) AND (OR NWR_BODY AA_NWR)
 err1 NOT INSIDE SealR_NOT_BULK
}

Q: NW resistor length direction must be GATE poly direction
A: 
RESNW_R_5 {
@ NW resistor length direction must be GATE poly direction
 err1 = ANGLE (NWR_BODY INSIDE EDGE RESNW) != 90
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}


//DSTR

Q: DSTR overlap SVT_N, SVT_P, LVT_N, LVT_P, HVT_N, HVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P is not allowed
A: 
DSTR_R_1 {
@ DSTR overlap SVT_N, SVT_P, LVT_N, LVT_P, HVT_N, HVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P is not allowed
 err1 = AND DSTR ALL_VT_IMP
 err1 NOT INSIDE SealR_NOT_BULK
}

Q: ((GT NOT P2) INTERACT ACTIVE) must connect to S/D ACTIVE in DSTR region
A: 
DSTR_R_2 {
@ ((GT NOT P2) INTERACT ACTIVE) must connect to S/D ACTIVE in DSTR region
 chk_GT = (GT_0 INTERACT ACT) AND DSTR
 good_a = (NET AREA RATIO chk_GT real_NSD [!!AREA(chk_GT)*!!AREA(real_NSD)] > 0) OR (NET AREA RATIO chk_GT real_PSD [!!AREA(chk_GT)*!!AREA(real_PSD)] > 0)
 good_b = (NET AREA RATIO chk_GT N_inject [!!AREA(chk_GT)*!!AREA(N_inject)] > 0) OR (NET AREA RATIO chk_GT P_inject [!!AREA(chk_GT)*!!AREA(P_inject)] > 0)
 err1 = chk_GT NOT (OR good_a good_b)
 err1 NOT INSIDE SealR_NOT_BULK
}

DIO_GATE_CORE = ((GT_0 AND GATE_raw) AND DSTR) NOT DG

DIO_GATE_in_PW = DIO_GATE_CORE AND (ACT AND PW_0)
DIO_GATE_in_NW = DIO_GATE_CORE AND (ACT AND NW)
DIO_GATE_PW = PW_0 AND DIO_GATE_in_PW
DIO_GATE_NW = NW AND DIO_GATE_in_NW

Q: Delta V > 3V between core diode GATE and core diode bulk is not allowed
A: 
DSTR_R_3_pdio {
@ Delta V > 3V between core diode GATE and core diode bulk is not allowed
//;exclude rw diode
 gate_netid = DFM PROPERTY DIO_GATE_in_PW net_vol_assign NODAL MULTI
 [max_vol = property(net_vol_assign, max_vol)]
 [min_vol = property(net_vol_assign, min_vol)]

 bulk_netid = DFM PROPERTY DIO_GATE_PW net_vol_assign NODAL MULTI
 [max_vol = property(net_vol_assign, max_vol)]
 [min_vol = property(net_vol_assign, min_vol)]

 err1 = DFM PROPERTY DIO_GATE_in_PW gate_netid bulk_netid ABUT ALSO OVERLAP MULTI
 [VH_1 = property(gate_netid, max_vol)]
 [VL_1 = property(gate_netid, min_vol)]
 [VH_2 = property(bulk_netid, max_vol)]
 [VL_2 = property(bulk_netid, min_vol)]
 [DT_v = fmax((property_ref(VH_1) - property_ref(VL_2)), (property_ref(VH_2) - property_ref(VL_1)))] > 3
 err1 NOT INSIDE SealR_NOT_BULK
}

Q: Delta V > 3V between core diode GATE and core diode bulk is not allowed
A: 
DSTR_R_3_ndio {
@ Delta V > 3V between core diode GATE and core diode bulk is not allowed
//;exclude nwdio, dnwdio
 gate_netid = DFM PROPERTY DIO_GATE_in_NW net_vol_assign NODAL MULTI
 [max_vol = property(net_vol_assign, max_vol)]
 [min_vol = property(net_vol_assign, min_vol)]

 bulk_netid = DFM PROPERTY DIO_GATE_NW net_vol_assign NODAL MULTI
 [max_vol = property(net_vol_assign, max_vol)]
 [min_vol = property(net_vol_assign, min_vol)]

 err1 = DFM PROPERTY DIO_GATE_in_NW gate_netid bulk_netid ABUT ALSO OVERLAP MULTI
 [VH_1 = property(gate_netid, max_vol)]
 [VL_1 = property(gate_netid, min_vol)]
 [VH_2 = property(bulk_netid, max_vol)]
 [VL_2 = property(bulk_netid, min_vol)]
 [DT_v = fmax((property_ref(VH_1) - property_ref(VL_2)), (property_ref(VH_2) - property_ref(VL_1)))] > 3
 err1 NOT INSIDE SealR_NOT_BULK
}


//GATED

Q: AA CUT DIOMK2 is not allowed
A: 
GATED_R_1 {
@ AA CUT DIOMK2 is not allowed
 err1 = DIOMK2 INSIDE EDGE (AA CUT DIOMK2)
 err1 NOT INSIDE EDGE SealR_NOT_BULK
}

Q: (DIOMK2 AND AA) must be fully covered by DG
A: 
GATED_R_2 {
@ (DIOMK2 AND AA) must be fully covered by DG
 err1 = (DIOMK2 AND AA) NOT DG
 err1 NOT INSIDE SealR_NOT_BULK
}

Q: DIOMK2 overlap DUM_GT is not allowed
A: 
GATED_R_3 {
@ DIOMK2 overlap DUM_GT is not allowed
 err1 = DIOMK2 AND DUM_GT
 err1 NOT INSIDE SealR_NOT_BULK
}

Q: (AA NOT GT) INSIDE DIOMK2 must interact M0
A: 
GATED_R_4 {
@ (AA NOT GT) INSIDE DIOMK2 must interact M0
 chk_pre = AA_SD_all AND DIOMK2
 err1 = chk_pre NOT INTERACT M0
 err1 NOT INSIDE SealR_NOT_BULK
}

//BJT

Q: ((Emitter AA SIZING 0.048um) SIZING -0.048um) must be one 1.632*1.728um or 2.04um*2.352um rectangle outside DG
A: 
BJT_R_1 {
@ ((Emitter AA SIZING 0.048um) SIZING -0.048um) must be one 1.632*1.728um or 2.04um*2.352um rectangle outside DG
 good_emitter_1 = RECTANGLE emitter_AA_size_ud_048 == 1.632 BY == 1.728
 good_emitter_2 = RECTANGLE emitter_AA_size_ud_048 == 2.040 BY == 2.352
 err1 = ((emitter_AA_size_ud_048 NOT good_emitter_1) NOT good_emitter_2) NOT DG
 err1 NOT INSIDE SealR_NOT_BULK
}

Q: Overlap SVT_N, SVT_P, LVT_N, LVT_P, HVT_N, HVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, VARMOS, or INST is not allowed
A: 
BJT_R_2 {
@ Overlap SVT_N, SVT_P, LVT_N, LVT_P, HVT_N, HVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, VARMOS, or INST is not allowed
 err1 = DMPNP AND (OR ALL_VT_IMP VARMOS INST)
 err1 NOT INSIDE SealR_NOT_BULK
}

Q: BIPOLA must be inside DMPNP
    DRC flags BIPOLA NOT totally INSIDE DMPNP
A: 
BJT_R_3_1 {
@ BIPOLA must be inside DMPNP
@ DRC flags BIPOLA NOT totally INSIDE DMPNP
 err1 = (BIPOLA NOT INSIDE DMPNP) OR (DMPNP NOT ENCLOSE BIPOLA)
 err1 NOT INSIDE SealR_NOT_BULK
}

Q: BIPOLA must be inside DMPNP
    DRC flags BIPOLA CUT emitter/collector/base AA
A: 
BJT_R_3_2 {
@ BIPOLA must be inside DMPNP
@ DRC flags BIPOLA CUT emitter/collector/base AA
//; abnormal BJT
 err1 = EXPAND EDGE (BIPOLA INSIDE EDGE AA) INSIDE BY 0.001 OUTSIDE BY 0.001
 err1 NOT INSIDE SealR_NOT_BULK
}

Q: BIPOLA must be inside DMPNP
    DRC flags BIPOLA overlap with RING collector/base AA
A: 
BJT_R_3_3 {
@ BIPOLA must be inside DMPNP
@ DRC flags BIPOLA overlap with RING collector/base AA
 err1 = BIPOLA AND (OR CAKE_Collector_AA RING_Collector_AA RING_Base_AA)
 err1 NOT INSIDE SealR_NOT_BULK
}

Q: BIPOLA must be inside DMPNP
    DRC flags DMPNP without any AA
A: 
BJT_R_3_4 {
@ BIPOLA must be inside DMPNP
@ DRC flags DMPNP without any AA
 err1 = DMPNP NOT ENCLOSE BJT_AA
 err1 NOT INSIDE SealR_NOT_BULK
}

Q: BIPOLA must be inside DMPNP
    DRC flags DMPNP without B/C/E AA
    DRC flags core BJT covered by DG and IO BJT not covered by DG
A: 
BJT_R_3_5 {
@ BIPOLA must be inside DMPNP
@ DRC flags DMPNP without B/C/E AA
@ DRC flags core BJT covered by DG and IO BJT not covered by DG
 err1 = DMPNP NOT ENCLOSE real_Collector_AA
 err2 = DMPNP NOT ENCLOSE Base_AA
 err3 = DMPNP NOT ENCLOSE Emitter_AA
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK

 err4 = OR (RING_Collector_AA AND DG) (RING_Base_AA AND DG) ((CAKE_Collector_AA INTERACT real_Collector_AA_H) NOT DG) ((CAKE_Base_AA INTERACT real_Base_AA_H) NOT DG)
 err4 NOT INSIDE SealR_NOT_BULK
}

Q: BIPOLA must be inside DMPNP
    DRC flags non-orthogonal B/C/E AA
A: 
BJT_R_3_6 {
@ BIPOLA must be inside DMPNP
@ DRC flags non-orthogonal B/C/E AA
 err1 = NOT RECTANGLE (OR (Collector_AA INTERACT real_Collector_AA) Base_AA Emitter_AA) ORTHOGONAL ONLY
 err1 NOT INSIDE SealR_NOT_BULK
}

Q: GT on Emitter AA must connect to Base AA
A: 
BJT_R_4 {
@ GT on Emitter AA must connect to Base AA
 PNP_emitter_GT = GT_0 AND (GT INTERACT (Emitter_AA AND SP))
 NPN_emitter_GT = GT_0 AND (GT INTERACT (Emitter_AA AND SN))
 BJT_aa_connect = Base_AA AND M0_0

 err1 = PNP_emitter_GT NOT INTERACT (PNP_emitter_GT AND BJT_aa_connect)
 err2 = NPN_emitter_GT NOT INTERACT (NPN_emitter_GT AND BJT_aa_connect)
 err3 = PNP_emitter_GT INTERACT (PNP_emitter_GT AND BJT_aa_connect) < 2
 err4 = NPN_emitter_GT INTERACT (NPN_emitter_GT AND BJT_aa_connect) < 2
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
 err4 NOT INSIDE SealR_NOT_BULK
}

//VAR

Q: VARMOS overlap (GATE AND SP), SVT_N, SVT_P, LVT_N, LVT_P, HVT_N, HVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, or PSUB is not allowed
A: 
VAR_R_2_PGATE {
@ VARMOS overlap (GATE AND SP), SVT_N, SVT_P, LVT_N, LVT_P, HVT_N, HVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, or PSUB is not allowed
 err1 = AND VARMOS (GATE AND SP)
 err1 NOT INSIDE SealR_NOT_BULK
}

Q: VARMOS overlap (GATE AND SP), SVT_N, SVT_P, LVT_N, LVT_P, HVT_N, HVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, or PSUB is not allowed
A: 
VAR_R_2_VT_Layer {
@ VARMOS overlap (GATE AND SP), SVT_N, SVT_P, LVT_N, LVT_P, HVT_N, HVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, or PSUB is not allowed
 err1 = AND VARMOS ALL_VT_IMP
 err1 NOT INSIDE SealR_NOT_BULK
}

Q: VARMOS overlap (GATE AND SP), SVT_N, SVT_P, LVT_N, LVT_P, HVT_N, HVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, or PSUB is not allowed
A: 
VAR_R_2_PSUB {
@ VARMOS overlap (GATE AND SP), SVT_N, SVT_P, LVT_N, LVT_P, HVT_N, HVT_P, ULVT_N, ULVT_P, LFN_N, LFN_P, or PSUB is not allowed
 err1 = AND VARMOS PSUB
 err1 NOT INSIDE SealR_NOT_BULK
}

Q: SP overlap ((GATE AND NW) AND VARMOS) is not allowed
A: 
VAR_R_3 {
@ SP overlap ((GATE AND NW) AND VARMOS) is not allowed
 err1 = SP AND ((GATE AND NW) AND VARMOS)
 err1 NOT INSIDE SealR_NOT_BULK
}

Q: Maximum delta V >= 5.6V is not allowed, when space between V0 is < 0.410um
A: 
V0_R_4 {
@ Maximum delta V >= 5.6V is not allowed, when space between V0 is < 0.410um
 err1 = DFM DV (V0 INTERACT DVK_V0_SQ) (V0 INTERACT DVK_V0_SR) < V0_R_4_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" >= 5.6 ANNOTATE NOT CONNECTED SINGULAR
 DFM COPY err1
}

Q: Maximum delta V >= 5.6V of (V0 OR RV0) is not allowed, when space between (V0 OR RV0) is < 0.410um
A: 
RV0_R_7 {
@ Maximum delta V >= 5.6V of (V0 OR RV0) is not allowed, when space between (V0 OR RV0) is < 0.410um
 err1 = DFM DV (V0 INTERACT DVK_V0_SR) < RV0_R_7_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" >= 5.6 ANNOTATE NOT CONNECTED SINGULAR
 DFM COPY err1
}


VARIABLE M1_R_2_M1_val 0.360
VARIABLE M1_R_2_V0_val 0.360
VARIABLE M1_R_2_V1_val 0.360

Q: Maximum delta V >= 5.6V is not allowed, when space between M1 and M1/V0/V1 is < 0.360um
A: 
M1_R_2_M1 {
@ Maximum delta V >= 5.6V is not allowed, when space between M1 and M1/V0/V1 is < 0.360um
 err1 = DFM DV M1 < M1_R_2_M1_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" >= 5.6 ANNOTATE NOT CONNECTED SINGULAR
 DFM COPY err1
}

Q: Maximum delta V >= 5.6V is not allowed, when space between M1 and M1/V0/V1 is < 0.360um
A: 
M1_R_2_V0 {
@ Maximum delta V >= 5.6V is not allowed, when space between M1 and M1/V0/V1 is < 0.360um
 err1 = DFM DV M1 (V0 INTERACT DVK_V0_SR) < M1_R_2_V0_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" >= 5.6 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err1
}

Q: Maximum delta V >= 5.6V is not allowed, when space between M1 and M1/V0/V1 is < 0.360um
A: 
M1_R_2_V1 {
@ Maximum delta V >= 5.6V is not allowed, when space between M1 and M1/V0/V1 is < 0.360um
 err1 = DFM DV M1 (V1 INTERACT DVK_V1_SR) < M1_R_2_V1_val DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" >= 5.6 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err1
}

Q: Maximum delta V >= 5.6V is not allowed, when space between Mxy and Mxy/above via/bottom via < 0.360um
A: 
M2_R_5_M2 {
@ Maximum delta V >= 5.6V is not allowed, when space between Mxy and Mxy/above via/bottom via < 0.360um
 err1 = DFM DV M2 < 0.360 DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" >= 5.6 ANNOTATE NOT CONNECTED SINGULAR
 DFM COPY err1
}
 
Q: Maximum delta V >= 5.6V is not allowed, when space between Mxy and Mxy/above via/bottom via < 0.360um
A: 
M2_R_5_V1 {
@ Maximum delta V >= 5.6V is not allowed, when space between Mxy and Mxy/above via/bottom via < 0.360um
 err1 = DFM DV M2 V1 < 0.360 DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" >= 5.6 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err1
}
 
Q: Maximum delta V >= 5.6V is not allowed, when space between Mxy and Mxy/above via/bottom via < 0.360um
A: 
M2_R_5_V2 {
@ Maximum delta V >= 5.6V is not allowed, when space between Mxy and Mxy/above via/bottom via < 0.360um
 err1 = DFM DV M2 V2 < 0.360 DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" >= 5.6 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err1
}

Q: Maximum delta V >= 5.6V is not allowed, when space between Mxy and Mxy/above via/bottom via < 0.360um
A: 
M3_R_5_M3 {
@ Maximum delta V >= 5.6V is not allowed, when space between Mxy and Mxy/above via/bottom via < 0.360um
 err1 = DFM DV M3 < 0.360 DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" >= 5.6 ANNOTATE NOT CONNECTED SINGULAR
 DFM COPY err1
}
 
Q: Maximum delta V >= 5.6V is not allowed, when space between Mxy and Mxy/above via/bottom via < 0.360um
A: 
M3_R_5_V2 {
@ Maximum delta V >= 5.6V is not allowed, when space between Mxy and Mxy/above via/bottom via < 0.360um
 err1 = DFM DV M3 V2 < 0.360 DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" >= 5.6 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err1
}
 
Q: Maximum delta V >= 5.6V is not allowed, when space between Mxy and Mxy/above via/bottom via < 0.360um
A: 
M3_R_5_V3 {
@ Maximum delta V >= 5.6V is not allowed, when space between Mxy and Mxy/above via/bottom via < 0.360um
 err1 = DFM DV M3 V3 < 0.360 DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" >= 5.6 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err1
}

Q: Maximum delta V >= 5.6V is not allowed, when space between Vy is < 0.410um
A: 
Vy1_R_5 {
@ Maximum delta V >= 5.6V is not allowed, when space between Vy is < 0.410um
 chk_VIA = V1 INTERACT DVK_V1_SQ
 err1 = DFM DV chk_VIA V1 < 0.410 DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" >= 5.6 ANNOTATE NOT CONNECTED SINGULAR
 DFM COPY err1
}
 
Q: Maximum delta V >= 5.6V is not allowed, when space between Vy and RVy is < 0.410um
A: 
RVy1_R_8 {
@ Maximum delta V >= 5.6V is not allowed, when space between Vy and RVy is < 0.410um
 err1 = DFM DV (V1 INTERACT DVK_V1_SR) < 0.410 DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" >= 5.6 ANNOTATE NOT CONNECTED SINGULAR
 DFM COPY err1
}
 
Q: Maximum delta V >= 5.6V is not allowed, when space between Vy is < 0.410um
A: 
Vy2_R_5 {
@ Maximum delta V >= 5.6V is not allowed, when space between Vy is < 0.410um
 chk_VIA = V2 INTERACT DVK_V2_SQ
 err1 = DFM DV chk_VIA V2 < 0.410 DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" >= 5.6 ANNOTATE NOT CONNECTED SINGULAR
 DFM COPY err1
}
 
Q: Maximum delta V >= 5.6V is not allowed, when space between Vy and RVy is < 0.410um
A: 
RVy2_R_8 {
@ Maximum delta V >= 5.6V is not allowed, when space between Vy and RVy is < 0.410um
 err1 = DFM DV (V2 INTERACT DVK_V2_SR) < 0.410 DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" >= 5.6 ANNOTATE NOT CONNECTED SINGULAR
 DFM COPY err1
}
 
 
Q: Maximum delta V >= 5.6V is not allowed, when space between Vy is < 0.410um
A: 
Vy3_R_5 {
@ Maximum delta V >= 5.6V is not allowed, when space between Vy is < 0.410um
 chk_VIA = V3 INTERACT DVK_V3_SQ
 err1 = DFM DV chk_VIA V3 < 0.410 DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" >= 5.6 ANNOTATE NOT CONNECTED SINGULAR
 DFM COPY err1
}

Q:  Maximum delta V >= 5.6V is not allowed, when space between Vy and RVy is < 0.410um
A: 
RVy3_R_8 {
@ Maximum delta V >= 5.6V is not allowed, when space between Vy and RVy is < 0.410um
 err1 = DFM DV (V3 INTERACT DVK_V3_SR) < 0.410 DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" >= 5.6 ANNOTATE NOT CONNECTED SINGULAR
 DFM COPY err1
}

Q: It is not allowed for maximum delta V >= 5.6V, when space between 1.25xMn and 1.25xMn/1.25xVn-1/1.25xVn is < 0.36um
    ("M5_55" is mapped to "M5" in the rule name of this check)
A: 
125xm5_R_4_M5 {
@ It is not allowed for maximum delta V >= 5.6V, when space between 1.25xMn and 1.25xMn/1.25xVn-1/1.25xVn is < 0.36um
@ ("M5_55" is mapped to "M5" in the rule name of this check)
 err1 = DFM DV M5 < 0.360 DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" >= 5.6 ANNOTATE NOT CONNECTED SINGULAR
 DFM COPY err1
}
 
Q: It is not allowed for maximum delta V >= 5.6V, when space between 1.25xMn and 1.25xMn/1.25xVn-1/1.25xVn is < 0.36um
    ("V4_50" is mapped to "V4" in the rule name of this check)
A: 
125xm5_R_4_V4 {
@ It is not allowed for maximum delta V >= 5.6V, when space between 1.25xMn and 1.25xMn/1.25xVn-1/1.25xVn is < 0.36um
@ ("V4_50" is mapped to "V4" in the rule name of this check)
 err1 = DFM DV M5 V4 < 0.360 DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" >= 5.6 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err1
}
 
Q: It is not allowed for maximum delta V >= 5.6V, when space between 1.25xMn and 1.25xMn/1.25xVn-1/1.25xVn is < 0.36um
    ("V5_50" is mapped to "V5" in the rule name of this check)
A: 
125xm5_R_4_V5 {
@ It is not allowed for maximum delta V >= 5.6V, when space between 1.25xMn and 1.25xMn/1.25xVn-1/1.25xVn is < 0.36um
@ ("V5_50" is mapped to "V5" in the rule name of this check)
 err1 = DFM DV M5 V5 < 0.360 DVPARAMS net_vol_assign "min_vol" 0 "max_vol" 0 "syncID" >= 5.6 ANNOTATE NOT CONNECTED SINGULAR MEASURE ALL
 DFM COPY err1
}

Q: It is not allowed:
    1) V1 in MOMMK1
    2) Vn/Vn-1 in MOMMKn (n = 2~7), Vn-1 is the via underneath 1xMn, and Vn is the via above 1xMn. Vn can be inter-via or top via (TV1 or TV2 or UTV)
A: 
MOM_R_1_V1_MOMMK1 {
@ It is not allowed:
@ 1) V1 in MOMMK1
@ 2) Vn/Vn-1 in MOMMKn (n = 2~7), Vn-1 is the via underneath 1xMn, and Vn is the via above 1xMn. Vn can be inter-via or top via (TV1 or TV2 or UTV)
 err1 = V1 AND MOMMK1
 err1 NOT INSIDE SealR_NOT_BULK
}
 
Q: It is not allowed:
    1) V1 in MOMMK1
    2) Vn/Vn-1 in MOMMKn (n = 2~7), Vn-1 is the via underneath 1xMn, and Vn is the via above 1xMn. Vn can be inter-via or top via (TV1 or TV2 or UTV)
A: 
MOM_R_1_V2_MOMMK2 {
@ It is not allowed:
@ 1) V1 in MOMMK1
@ 2) Vn/Vn-1 in MOMMKn (n = 2~7), Vn-1 is the via underneath 1xMn, and Vn is the via above 1xMn. Vn can be inter-via or top via (TV1 or TV2 or UTV)
 err1 = V2 AND MOMMK2
 err1 NOT INSIDE SealR_NOT_BULK
}
 
Q: It is not allowed:
    1) V1 in MOMMK1
    2) Vn/Vn-1 in MOMMKn (n = 2~7), Vn-1 is the via underneath 1xMn, and Vn is the via above 1xMn. Vn can be inter-via or top via (TV1 or TV2 or UTV)
A: 
MOM_R_1_V3_MOMMK3 {
@ It is not allowed:
@ 1) V1 in MOMMK1
@ 2) Vn/Vn-1 in MOMMKn (n = 2~7), Vn-1 is the via underneath 1xMn, and Vn is the via above 1xMn. Vn can be inter-via or top via (TV1 or TV2 or UTV)
 err1 = V3 AND MOMMK3
 err1 NOT INSIDE SealR_NOT_BULK
}
 
Q: It is not allowed:
    1) V1 in MOMMK1
    2) Vn/Vn-1 in MOMMKn (n = 2~7), Vn-1 is the via underneath 1xMn, and Vn is the via above 1xMn. Vn can be inter-via or top via (TV1 or TV2 or UTV)
A: 
MOM_R_1_V4_MOMMK4 {
@ It is not allowed:
@ 1) V1 in MOMMK1
@ 2) Vn/Vn-1 in MOMMKn (n = 2~7), Vn-1 is the via underneath 1xMn, and Vn is the via above 1xMn. Vn can be inter-via or top via (TV1 or TV2 or UTV)
 err1 = V4 AND MOMMK4
 err1 NOT INSIDE SealR_NOT_BULK
}
 
Q: It is not allowed:
    1) V1 in MOMMK1
    2) Vn/Vn-1 in MOMMKn (n = 2~7), Vn-1 is the via underneath 1xMn, and Vn is the via above 1xMn. Vn can be inter-via or top via (TV1 or TV2 or UTV)
A: 
MOM_R_1_V5_MOMMK5 {
@ It is not allowed:
@ 1) V1 in MOMMK1
@ 2) Vn/Vn-1 in MOMMKn (n = 2~7), Vn-1 is the via underneath 1xMn, and Vn is the via above 1xMn. Vn can be inter-via or top via (TV1 or TV2 or UTV)
 err1 = V5 AND MOMMK5
 err1 NOT INSIDE SealR_NOT_BULK
}
 
Q: It is not allowed:
    1) V1 in MOMMK1
    2) Vn/Vn-1 in MOMMKn (n = 2~7), Vn-1 is the via underneath 1xMn, and Vn is the via above 1xMn. Vn can be inter-via or top via (TV1 or TV2 or UTV)
A: 
MOM_R_1_V6_MOMMK6 {
@ It is not allowed:
@ 1) V1 in MOMMK1
@ 2) Vn/Vn-1 in MOMMKn (n = 2~7), Vn-1 is the via underneath 1xMn, and Vn is the via above 1xMn. Vn can be inter-via or top via (TV1 or TV2 or UTV)
 err1 = V6 AND MOMMK6
 err1 NOT INSIDE SealR_NOT_BULK
}
 
Q: It is not allowed:
    1) V1 in MOMMK1
    2) Vn/Vn-1 in MOMMKn (n = 2~7), Vn-1 is the via underneath 1xMn, and Vn is the via above 1xMn. Vn can be inter-via or top via (TV1 or TV2 or UTV)
A: 
MOM_R_1_V1_MOMMK2 {
@ It is not allowed:
@ 1) V1 in MOMMK1
@ 2) Vn/Vn-1 in MOMMKn (n = 2~7), Vn-1 is the via underneath 1xMn, and Vn is the via above 1xMn. Vn can be inter-via or top via (TV1 or TV2 or UTV)
 err1 = V1 AND MOMMK2
 err1 NOT INSIDE SealR_NOT_BULK
}
 
Q: It is not allowed:
    1) V1 in MOMMK1
    2) Vn/Vn-1 in MOMMKn (n = 2~7), Vn-1 is the via underneath 1xMn, and Vn is the via above 1xMn. Vn can be inter-via or top via (TV1 or TV2 or UTV)
A: 
MOM_R_1_V2_MOMMK3 {
@ It is not allowed:
@ 1) V1 in MOMMK1
@ 2) Vn/Vn-1 in MOMMKn (n = 2~7), Vn-1 is the via underneath 1xMn, and Vn is the via above 1xMn. Vn can be inter-via or top via (TV1 or TV2 or UTV)
 err1 = V2 AND MOMMK3
 err1 NOT INSIDE SealR_NOT_BULK
}
 
Q: It is not allowed:
    1) V1 in MOMMK1
    2) Vn/Vn-1 in MOMMKn (n = 2~7), Vn-1 is the via underneath 1xMn, and Vn is the via above 1xMn. Vn can be inter-via or top via (TV1 or TV2 or UTV)
A: 
MOM_R_1_V3_MOMMK4 {
@ It is not allowed:
@ 1) V1 in MOMMK1
@ 2) Vn/Vn-1 in MOMMKn (n = 2~7), Vn-1 is the via underneath 1xMn, and Vn is the via above 1xMn. Vn can be inter-via or top via (TV1 or TV2 or UTV)
 err1 = V3 AND MOMMK4
 err1 NOT INSIDE SealR_NOT_BULK
}
 
Q: It is not allowed:
    1) V1 in MOMMK1
    2) Vn/Vn-1 in MOMMKn (n = 2~7), Vn-1 is the via underneath 1xMn, and Vn is the via above 1xMn. Vn can be inter-via or top via (TV1 or TV2 or UTV)
A: 
MOM_R_1_V4_MOMMK5 {
@ It is not allowed:
@ 1) V1 in MOMMK1
@ 2) Vn/Vn-1 in MOMMKn (n = 2~7), Vn-1 is the via underneath 1xMn, and Vn is the via above 1xMn. Vn can be inter-via or top via (TV1 or TV2 or UTV)
 err1 = V4 AND MOMMK5
 err1 NOT INSIDE SealR_NOT_BULK
}
 
Q: It is not allowed:
    1) V1 in MOMMK1
    2) Vn/Vn-1 in MOMMKn (n = 2~7), Vn-1 is the via underneath 1xMn, and Vn is the via above 1xMn. Vn can be inter-via or top via (TV1 or TV2 or UTV)
A: 
MOM_R_1_V5_MOMMK6 {
@ It is not allowed:
@ 1) V1 in MOMMK1
@ 2) Vn/Vn-1 in MOMMKn (n = 2~7), Vn-1 is the via underneath 1xMn, and Vn is the via above 1xMn. Vn can be inter-via or top via (TV1 or TV2 or UTV)
 err1 = V5 AND MOMMK6
 err1 NOT INSIDE SealR_NOT_BULK
}

Q: RSPMK1 must be a rectangle with width = 0.09um in GATE poly direction
A: 
RSPMK1_R_1 {
@ RSPMK1 must be a rectangle with width = 0.09um in GATE poly direction
 err1 = NOT RECTANGLE RSPMK1 ORTHOGONAL ONLY
 err2 = RSPMK1 NOT (INT RSPMK1_h_edges == 0.090 OPPOSITE REGION)
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

Q: M0C (width = 0.051um) must interact RSPMK1
A: 
RSPMK1_R_2 {
@ M0C (width = 0.051um) must interact RSPMK1
 err1 = M0C_051 NOT INTERACT RSPMK1
 err1 NOT INSIDE SealR_NOT_BULK
}

Q: RSPMK1 (length > 0.4um) must interact V0, and extension on either one side of V0 must be 0.005um in GATE poly direction
    Flag://;Extension on either side of V0 != 0.005um
    Flag://;RSPMK1 with length > 0.4um not interact V0
A: 
RSPMK1_R_3 {
@ RSPMK1 (length > 0.4um) must interact V0, and extension on either one side of V0 must be 0.005um in GATE poly direction
@ Flag://;Extension on either side of V0 != 0.005um
@ Flag://;RSPMK1 with length > 0.4um not interact V0
 err1_TMP = ENC [V0i] RSPMK1_h_edges == 0.005 ABUT<90 OPPOSITE
 err1 = (V0i INTERACT RSPMK1) NOT WITH EDGE err1_TMP
 err1 NOT INSIDE SealR_NOT_BULK

 err2 = (RSPMK1 WITH EDGE (LENGTH RSPMK1_h_edges > 0.4)) NOT INTERACT V0i
 err2 NOT INSIDE SealR_NOT_BULK
}

Q: RSPMK1 overlap AOP_M0C (width = 0.048, 0.052, 0.082, 0.108um) or (AA NOT GTMK1) is not allowed
A: 
RSPMK1_R_4 {
@ RSPMK1 overlap AOP_M0C (width = 0.048, 0.052, 0.082, 0.108um) or (AA NOT GTMK1) is not allowed
 chk_AOP_M0C = OR AOP_M0C_048 AOP_M0C_052 AOP_M0C_082 AOP_M0C_108
 err1 = RSPMK1 AND chk_AOP_M0C
 err2 = RSPMK1 AND (AA NOT GTMK1)
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

Q: (RSPMK1 SIZING -0.004um) overlap M0G is not allowed
A: 
RSPMK1_R_5 {
@ (RSPMK1 SIZING -0.004um) overlap M0G is not allowed
 err1 = (SIZE RSPMK1 BY -0.004) AND M0G
 err1 NOT INSIDE SealR_NOT_BULK
}

RSPMK1_horizontal_centerline = DFM COPY (DFM SPACE RSPMK1 <= 0.090 BY INT VERTICAL) CENTERLINE
RSPMK1_horizontal_M1_centerline = DFM COPY (DFM SPACE (M1 INTERACT RSPMK1) <= 0.090 BY INT VERTICAL) CENTERLINE

Q: RSPMK1 center line must align with any one of M1 center line in S/D direction
A: 
RSPMK1_R_7 {
@ RSPMK1 center line must align with any one of M1 center line in S/D direction
 err1 = RSPMK1_horizontal_centerline NOT TOUCH EDGE RSPMK1_horizontal_M1_centerline
 err2 = RSPMK1_h_edges NOT TOUCH EDGE (RSPMK1 COIN INSIDE EDGE M1)
 err1 NOT INSIDE EDGE SealR_NOT_BULK
 err2 NOT INSIDE EDGE SealR_NOT_BULK
}


//BM0

Q: M0_B1 or M0_B2 must be a rectangle and fully inside M0 or fully butted with M0 at either one horizontal side
A: 
BM0_R_1 {
@ M0_B1 or M0_B2 must be a rectangle and fully inside M0 or fully butted with M0 at either one horizontal side
 good_M0_B1 = (M0_B1 WITH EDGE (M0_B1 COIN EDGE (ANGLE M0i == 0))) TOUCH M0i
 good_M0_B2 = M0_B2 WITH EDGE (M0_B2 COIN EDGE (ANGLE M0i == 0))

 err1 = M0_B1 NOT RECTANGLE
 err2 = M0_B2 NOT RECTANGLE
 err3 = (M0_B1 NOT M0i) NOT good_M0_B1
 err4 = (M0_B2 NOT M0i) NOT good_M0_B2
 err5 = M0_B2 INSIDE M0i

 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
 err4 NOT INSIDE SealR_NOT_BULK
 err5 NOT INSIDE SealR_NOT_BULK
}

Q: (M0_B2 (INTERACT M0_B1) NOT M0_B1) must be one rectangle (width/length = 0.04/0.042um) and fully inside M0
A: 
BM0_R_2 {
@ (M0_B2 (INTERACT M0_B1) NOT M0_B1) must be one rectangle (width/length = 0.04/0.042um) and fully inside M0
 chk_M0_B2 = (M0_B2 INTERACT M0_B1) NOT M0_B1
 good_M0_B2 = RECTANGLE chk_M0_B2 == 0.04 BY == 0.042

 err1 = chk_M0_B2 NOT good_M0_B2
 err2 = chk_M0_B2 NOT M0i
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

Q: M0_B2 (NOT INTERACT M0_B1) overlap M0 is not allowed
A: 
BM0_R_3 {
@ M0_B2 (NOT INTERACT M0_B1) overlap M0 is not allowed
 err1 = (M0_B2 NOT INTERACT M0_B1) AND M0i
 err1 NOT INSIDE SealR_NOT_BULK
}

Q: M0_B1 and M0_B2 must be inside RSPMK1
A: 
BM0_R_4 {
@ M0_B1 and M0_B2 must be inside RSPMK1
 err1 = M0_B1 NOT INSIDE RSPMK1
 err2 = M0_B2 NOT INSIDE RSPMK1
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}

Q: Horizontal edge of M0_B1/M0_B2 (horizontal edge fully butted with M0 at both sides) must be inside M0C
A: 
BM0_R_5 {
@ Horizontal edge of M0_B1/M0_B2 (horizontal edge fully butted with M0 at both sides) must be inside M0C
 EDGE_M0_B1 = ANGLE (M0_B1 COIN EDGE M0i) == 0
 ERRS_M0_B1 = EDGE_M0_B1 COIN EDGE (M0_B1 WITH EDGE EDGE_M0_B1 == 2)
 err1 = ERRS_M0_B1 NOT INSIDE EDGE M0C
 err1 NOT INSIDE EDGE SealR_NOT_BULK

 EDGE_M0_B2 = ANGLE (M0_B2 COIN EDGE M0i) == 0
 ERRS_M0_B2 = EDGE_M0_B2 COIN EDGE (M0_B2 WITH EDGE EDGE_M0_B2 == 2)
 err2 = ERRS_M0_B2 NOT INSIDE EDGE M0C
 err2 NOT INSIDE EDGE SealR_NOT_BULK
}

Q: M0_B1 or M0_B2 interact (M0 (width = 0.054um) OR DOP_M0) is not allowed
A: 
BM0_R_6 {
@ M0_B1 or M0_B2 interact (M0 (width = 0.054um) OR DOP_M0) is not allowed
 err1 = M0_B1_B2 INTERACT (M0_054_raw OR DOP_M0)
 err1 NOT INSIDE SealR_NOT_BULK
}

Q: M0_B2 interact two or three M0_B1 is not allowed
A: 
BM0_R_7 {
@ M0_B2 interact two or three M0_B1 is not allowed
 err1 = M0_B2 INTERACT M0_B1 == 2
 err2 = M0_B2 INTERACT M0_B1 == 3
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
}


//BV0

Q: V0_B0 must overlap one or two square V0
    V0_B0 overlap with RV0 is not allowed
A: 
BV0_R_1 {
@ V0_B0 must overlap one or two square V0
@ V0_B0 overlap with RV0 is not allowed
 chk_via = copy V0_B0
 err1 = chk_via NOT INTERACT V0N_raw
 err2 = chk_via INTERACT V0N_raw > 2
 err3 = chk_via INTERACT RV0_raw
 err1 NOT INSIDE SealR_NOT_BULK
 err2 NOT INSIDE SealR_NOT_BULK
 err3 NOT INSIDE SealR_NOT_BULK
}

//INST

Q: INST overlap (SVT_N or SVT_P or HVT_N or HVT_P or LVT_N or LVT_P or ULVT_N or ULVT_P or LFN_N or LFN_P) is not allowed
A: 
INST_R_1 {
@ INST overlap (SVT_N or SVT_P or HVT_N or HVT_P or LVT_N or LVT_P or ULVT_N or ULVT_P or LFN_N or LFN_P) is not allowed
 err1 = INST AND ALL_VT_IMP
 err1 NOT INSIDE SealR_NOT_BULK
}

