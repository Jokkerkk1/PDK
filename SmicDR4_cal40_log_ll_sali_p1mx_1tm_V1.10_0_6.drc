#! tvf
namespace import tvf::*


VERBATIM {
//***********************************************
//   SMIC internal choice
//***********************************************
/*This switch can control all the recommended or guideline rules.
  the default set is NO,Change "NO" to "YES" could open all the recommended or guideline rules.
  NOTICE:this switch is only for SMIC PDE internal use.
  Customer or other users please keep the default set "NO".
  SMIC don't bear any responsibility for use this switch!
*/
#DEFINE OPEN_ALL_RECOMMENDED_GUIDELINE NO


//********************************************************************************
//                           CALIBRE DRC PROGRAM
//********************************************************************************


//=================================================================================
//|                                                                               |
//|  40nm 1PxM single topmetal Calibre DRC rule file for                          |
//|                                                                               |
//|                                                                               |
//|       SMIC:       40nm Logic Salicide 0.9/1.1/1.2/1.8/2.5V Low Leakage        |
//|                   and Generic Design Rule                                     |
//|                                                                               |
//|       Doc. No:       TD-LO40-DR-2001         Rev: 4        Tech Dev Rev: 1.10 |
//|                                                                               |
//|                                                                               |
//| Calibre Tool Version : 2013.4_15.12                                           |
//|                                                                               |
//|       SMIC Technologies                                                       |
//|                                                                               |
//|===============================================================================|
//|										  |
//|  Release Note :								  |
//|										  |
//|	I. Skip following rules check, please manually check them :		  |
//|	    1) RESP1.1					                          |
//|	    2) CDR rule.							  |
//|	    					         		          |
//|===============================================================================|
//|                                                                               |
//|    DISCLAIMER                                                                 |
//|                                                                               |
//|   SMIC hereby provides the quality information to you but makes no claims,    |
//| promises or guarantees about the accuracy, completeness, or adequacy of the   |
//| information herein. The information contained herein is provided on an "AS IS"|
//| basis without any warranty, and SMIC assumes no obligation to provide support |
//| of any kind or otherwise maintain the information.                            |
//|                                                                               |
//|   SMIC disclaims any representation that the information does not infringe any|
//| intellectual property rights or proprietary rights of any third parties.SMIC  |
//| makes no other warranty, whether express, implied or statutory as to any      |
//| matter whatsoever, including but not limited to the accuracy or sufficiency of|
//| any information or the merchantability and fitness for a particular purpose.  |
//| Neither SMIC nor any of its representatives shall be liable for any cause of  |
//| action incurred to connect to this service.                                   |
//|                                                                               |
//|===============================================================================|
//|                                                                               |
//|    STATEMENT OF USE AND CONFIDENTIALITY                                       |
//|                                                                               |
//|   The following/attached material contains confidential and proprietary       |
//| information of SMIC. This material is based upon information which SMIC       |
//| considers reliable, but SMIC neither represents nor warrants that such        |
//| information is accurate or complete, and it must not be relied upon as such.  |
//| This information was prepared for informational purposes and is for the use by|
//| SMIC's customer only. SMIC reserves the right to make changes in the          |
//| information at any time without notice.                                       |
//|   No part of this information may be reproduced, transmitted, transcribed,    |
//| stored in a retrieval system, or translated into any human or computer        |
//| language, in any form or by any means, electronic, mechanical, magnetic,      |
//| optical, chemical, manual, or otherwise, without the prior written consent of |
//| SMIC. Any unauthorized use or disclosure of this material is strictly         |
//| prohibited and may be unlawful. By accepting this material, the receiving     |
//| party shall be deemed to have acknowledged, accepted, and agreed to be bound  |
//| by the foregoing limitations and restrictions. Thank you.                     |
//|                                                                               |
//|===============================================================================|
//|                                                                               |
//|   This file includes SVRF/TVF Technology under license by Mentor Graphics     |
//| Corporation.  "SVRF/TVF Technology" shall mean Mentor Graphics' Standard      |
//| Verification Rule Format ("SVRF") and Tcl Verification Format ("TVF")         |
//| proprietary syntaxes for expressing process rules.  You shall not use SVRF/TVF|
//| Technology unless you are a Mentor Graphics customer with a license to use the|
//| applicable Mentor Graphics software. The exact terms of your obligations and  |
//| rights are governed by your respective license.  You shall not use SVRF/TVF   |
//| Technology except: (a) for your internal business purposes and (b) for use    |
//| with Mentor Graphics' Calibre tools. All SVRF/TVF Technology constitutes or   |
//| contains trade secrets and confidential information of Mentor Graphics or its |
//| licensors. You shall not make SVRF/TVF Technology available in any form to any|
//| person other than your employees and on-site contractors, excluding Mentor    |
//| Graphics competitors, whose job performance requires access and who are under |
//| obligations of confidentiality.                                               |
//|                                                                               |
//|===============================================================================|
//|                                                                               |
//| Revision History :                                                            |
//|                                                                               |
//|   Rev         Date          Who                      What                     |
//| ---------  -------------  ------------  --------------------------------------|
//| V1.10_0_6  20-Aug-2015     Penny_Hua   Below rules changed align with DR:
//|                                        Add switch #DEFINE MOM_5_6_CHECK,#DEFINE MOM_4_CHECK
//|                                        Add rules MOM_4_G,MOM_5_G,MOM_6_G
//|            16-July-2015    Penny_Hua   Update below density rules:
//|                                        GT_31_density，M1_15_density，M2_14_density，M3_14_density，M3_16_M1M2M3_density，M4_14_density，M4_16_M2M3M4_density，
//|                                        M5_14_density，M5_16_M3M4M5_density，M6_14_density，M6_16_M4M5M6_density，M7_14_density，M7_16_M5M6M7_density，
//|                                        M8_14_density，M8_16_M6M7M8_density，IND_R_9_G_l_TM2_density，IND_R_9_G_h_TM2_density，IND_R_9_G_l_MTT2_density，
//|                                        IND_R_9_G_h_MTT2_density             
//|            14-July-2015    Penny_Hua   Update DNW_8            |
//|            26-Jun-2015     Dorian_Zheng   Update ALPA_1           |
//|				`						  |
//|            May-8-2015      Leon_Tang   Update LU rules,MTT2_13,BD_6,GT_20b    |
//|                                        AA_C_5,Mn_12,Mn_13,GT_33 downgrate to [R]|
//|                                        Add DUMC_34a,DUMC_35a,SAB_16_R,NW_1a,  |
//|                                        TG_16a,GRC_7~GRC_12,LD_10,LD_11        |
//|                                        Delete ULVT_3,ULVT_5                   |
//|                                        Update DUMC_34,DUMC_35,Mn_2,SRDOP_15,  |
//|                                        NW_3,ULVT_4,ULVT_6,SAB_5,SAB_6,SAB_8,  |
//|                                        SAB_11,TG_16,GT_5a,TG_11_R,DUMC_26     |
//|                                        Update CT_1,CT_8,CT_13,DNW_8           |
//|                                        Move DG_15~DG_19 to TG_16~TG_20        |
//|                                        Update AA_19,GT_20b,SAB_5,Convention_2,|
//|                                        DG_16,DG_3,DG_4,TG_3,TG_4              |
//|                                        Update GT_28,GT_32,GT_33,CT_21,SP_8c,  |
//|                                        SN_7c,SN_8c                            |
//|                                        Delete AA_9b,M1_4a,Mn_4a               |
//|                                        Update AA_20,DG_18,DG_19,SP_7c,SN_7c   |
//|                                        LU_3_3a/b/c/d                          |
//|                                        Update AA_15a_R,AA_15b_R,GT_20b,IND_R_8|
//|                                        GT_31                                  |
//|                                        Update AA_9b,AA_13a,DIFRES_6,DNW_9,    |
//|                                        NW_11_R,NW_12_R,NW_17_R,RESNWST_6,     |
//|                                        RESNWAA_9,RESNWAA_11,DG_16,DG_17,DG_18,|
//|                                        DG_19,GT_3e,GT_5,GT_5a,SRGT_5,GT_9,    |
//|                                        SRGT_10,GT_21,GT_28,GT_32,GT_33,PLRES_6,|
//|                                        LVT_4,LVT_4a,LVT_5,LVT_5a,HVT_4,HVT_4a,| 
//|                                        HVT_5,HVT_5a,SP_6,SP_7a/b/c,SN_6,SN_7a/b,|
//|                                        CT_5,CT_5_R,CT_20,M1_4a,Mn_4a,V1_19,Vn_19,|
//|                                        Vn_23_R,PA_11,ESD_5,MTT2_11,SRAM device rule,|
//|                                        LOGO_1,LU_3,                           |
//|                                        Delete LVT_15,HVT_15,ULVT_10,SP_22,SN_23,|
//|                                        SAB_8a/b,                              |
//|                                        Update switch follow 4R Design rule.   |
//|                                        Add DFM priority for recommended rules.|
//|                                        Update connect follow net definition.  |
//|                                        Implement ESD and Latch up rules       |
//|                                        Update AA_1,AA_4a,AA_4b_4c,AA_9a,AA_11,|
//|                                        AA_13,AA_14,AA_14a,AA_15a,AA_15b,AA_16,|
//|                                        AA_17,AA_18,AA_19,RESAA_7,RESAA_12,RESAA_13,|
//|                                        AA_C_1,AA_C_4,AA_C_5,DIFRES_6,DIFRES_7,|
//|                                        DIFRES_11,DIFRES_12,DNW_1,DNW_2,DNW_2a,|
//|                                        DNW_7,NW_1,SRNW_1,NW_3,NW_7,NW_11_R,NW_12_R,|
//|                                        SRNW_14,NW_13,NW_14,NW_15,NW_16,RESNWST_6,|
//|                                        RESNWST_7,RESNWST_9,RESNWAA_7,RESNWAA_9,|
//|                                        RESNWAA_10,RESNWAA_11,PSUB_1,PSUB_4,PSUB_12,|
//|                                        TG_1,TG_2,TG_13,TG_14,TG_15,DG_1,DG_2, |
//|                                        DG_12,DG_13,DG_14,BORDER_1,GT_2a,GT_3,GT_3c,|
//|                                        SRGT_3,GT_4,SRGT_5,SRGT_6,SRGT_7,GT_8a,|
//|                                        GT_17,GT_18,GT_20b,GT_21,GT_27,GT_28,  |
//|                                        RESP1_7,PLRES_6,PLRES_7,PLRES_8,PLRES_9,|
//|                                        PLRES_10,LVT_1,LVT_13,HVT_1,HVT_13,SP_9,|
//|                                        SRSP_10,SP_15,SP_20a,SN_7b,SN_9,SN_15, |
//|                                        SAB_5,SAB_6,SAB_8,SAB_11,CT_1,CT_3,CT_3a,|
//|                                        CT_8,CT_10,M1_1,M1_2,M1_3,SRM1_3sa,M1_4,|
//|                                        M1_5,M1_6/6a/b/c,M1_7a,M1_7bc,M1_7e,M1_8/8a,|
//|                                        M1_9,M1_10,M1_14,V1_2,V1_5/5a,V1_6abc,V1_7abc,|
//|                                        V1_9,Mn_1,Mn_2,Mn_3,Mn_4,Mn_5,Mn_6/6a/b/c,|
//|                                        Mn_7/7a,Mn_8.Mn_9,Mn_12,Vn_2,Vn_5/5a,Vn_6abc,|
//|                                        Vn_7abc,Vn_9,TV1_4_5,TM1_1,TM1_2,TM1_5,TM1_7,|
//|                                        TM1_8,TM1_9,TM1_10,TM1_13,TV2_4_5,TM2_1,TM2_2,|
//|                                        TM2_5,TM2_7,TM2_8,TM2_9,TM2_10,TM2_12, |
//|                                        ALPA_1,ALPA_2,PA_1,PA_2,PA_4,MD_5,HRP_9,|
//|                                        MTT2_1,MTT2_2,MTT2_3,MTT2_6,MTT2_7,MTT2_11,|
//|                                        EFU rules,ULVT_3,ULVT_4,ULVT_6,ULVT_9,BUMP_4_G,|
//|                                        BUMP_5_G,BUMP_7_G,Convention rules,DUMC_2,|
//|                                        DUMC_12,DUMC_18,DUMC_22,               |
//|                                        Add AA_9b,AA_13a,AA_20,AA_21,AA_22,DNW_8a,|
//|                                        DNW_8b,DNW_9,PSUB_14,PSUB_15,DG_15,DG_16,|
//|                                        DG_17,DG_18,DG_19,BORDER_6,GT_3d/e,GT_17a,|
//|                                        GT_18a,GT_29,GT_30,GT_31,GT_32,GT_33,LVT_15,|
//|                                        HVT_15,SP_22,SN_20a,sn_23,SAB_8a/b,CT_13,|
//|                                        CT_20,M1_4a,M1_15,M1_16,V1_17a/b,V1_18,V1_19,|
//|                                        V1_20,V1_21,Mn_4a,Mn_13,Mn_14,Mn_15,Mn_16,|
//|                                        Vn_17a/b,Vn_18,Vn_19,Vn_20,Vn_21,TV1_14,TV1_15,|
//|                                        TV1_16,TV1_17,TV2_15,TV2_16,TV2_17,TV2_18,|
//|                                        PA_11,MTT2_6a,MTT2_13,ULVT_5,ULVT_10,  |
//|                                        Inductor rules,LOGO rules,DUMC_40~DUMC_51,|
//|                                        Delete GT_20c/d,SAB_15,CT_9,CT_11,M1_11a/b,|
//|                                        ALPA_5,ALPA_11,ESD_8,DUMCN rules       |
//| -------  -------------  ------ ------  ---------------------------------------|
//|V1.0_5R   Jan-23-2014      Liu Li       Add DNW.2a,DNW.4a due to DR update.   |    
//|
//|V1.0_4R   Aug-23-2013      Liu Li        Update TG.3/4/5/6/11,ULVT.4,ULVT.6,Mn.6a,Mn.6c,DG.3/4/5/6/11,GT.3c,GT.6,GT.6a |
//|                                         RESAA.5,RESAA.6,AA.4d,DNW.7,PSUB.7,RESP1.5/6/11,SP.14,SN.14,SAB.4/6/7/8/11/15,
//|                                         TM2.9,DUMC.6/16/20/26/26a/28,MTT2.2
//|                                       Change Mn.12,NW.11,NW.12,AA.C.5 to recommend rule,and set default status in design rule check as off, 
//|                                       GT.2b_R,GT.6a_R MD.4_R MD.6_R ESD.9a_R change default status in design rule check as off,
//|                                        Delete ULVT.3,ULVT.5,CT.19,DFM.5,ALPA.11     |  
//|
//|V1.0_3R   May-07-2013     Liu Li        Update MTT2_5/7b,SP.3a/3b/4/15,SN.3a/3b/4/15,SRSN.3a/3b coding
//|                                        V1.17,Vn.17,MTT2.7b                                        |
//|                                         
//|V1.0_2R   Apr-17-2013     Liu Li       Update RESP1.12,RESP1.13 V1.3,Vn.3,    |
//|                                           Mn.7d,Mn.7e,V1.17,Vn.17              |
//|                                         modify the SRAM marking layer form DPSRAM to RFSRAM
//|
//|V1.0_1.1R     Oct-26-2012    Liu Li       Add BORDER rule switch   
//|                                        update input layer exclude MARKS  
//|                                        RESAA.14,RESP1.15,NW.12,TG.5,DG.5,GT.6a,SP.20a/21a,CT.3,CT.3a    
//|                                        CT.6abd/6acd,CT.7ab,CT.19,M1.3,M1.7e,V1.6abc/7abc,V1.8,V1.17  
//|                                        Vn.17,Mn.12,Vn.6abc/7abc,DFM.5/13/19,DUMCN.21/22,DUP.1/5,MTT2.5
//|V1.0_1R     Sep-26-2012    Liu Li       Define AA/PLOY/HRP resistor area 
//|                                        Update RESNWST rule, AA.11/14/14a/18/19,RESAA.3/5/6/9a/10,AAC.5,
//|                                        RESNWAA_2_3/8,TG.11,BORDER4,GT.1b/2b/3c/6/20c/20d/22,RESP1.5/6/9/10,	. 
//|                                        SP.9/10/12/14/15/20a/21a,SN.3a/3b/9/10/14,SAB.15,M1.13,M1.14,V1.16/17
//|                                        Vn.16/Vn.17,Mn.9,ALPA.2/5,HRP.9,MTT2.2/5,DFM.3,DUMC.18/22/27/35,NW.13                                   
//|                                        Add DUP rule, RESAA.14,DNW.7,PSUB.3e,GT.1h,RESP1.15,ESD.9/9a,BUMP.1
//|                                        Delete layer ALRDL(83;3)
//|
//|                                         Update NW.11,NW.12 
//|                                       
//|
//|                                           Update V1.17,Vn.17
//|                                         
//|                                           Update V1.16,Vn.16,V1.17,Vn.17,TM1.7,TM2.7 coding,according to DR team request who will update design rule next DR version.   
//|
//|                                           Update rule description in runset,according to design rule in TECN(TECN NO.:TD1208070001)
//|                                         Update Mn.11,GT.6a,M1.6,Mn.6,MTT2.7b 
//|                                     
//|                                           
//|                                        define ULVT BUMP OCOVL GT end 
//|                                       add AA.4d/16/17/18/19, NW.9/11/12/13/14/15/16, BORDER.4, GT.3c/6a/8a/27/28,7a/7d/7e 
//|                                       SP.7c/8c,AA.C.5,MTT2.7b,DUMC.21a,DFM.29,EFU rule coding,ULVT rule coding,BUMP rule coding    
//|                                       Delete AA.5/6/7/8,SRGT.103,SRGT.19,V1.5b/6d/7d,Vn.5b/6d/7d,TM1.6,TM2.6,DFM.11
//|                                       Update AA.9a/14a/14,NW.1,rename RESNWAA7/10/11/12/13/14 to RESNWAA.9/10/11/12/13
//|                                       PSUB.2/3a/3b/3cd,TG.11,GT.5/6/8/20c/20d/21/25a/26/22,RESP1.7,PLRES.5,SP.1/6/7a/10,
//|                                       SRSP.3a,SN.1/6/7a/10,SAB.3/7/8,CT.1a/2a,11/12,SRCT.2a,SRM1.7ab,M1.6a/6b/6c/8/8a/13,
//|                                       V1.3/5/5a/17,SRM2.3,M2.3,Mn.6a/6b/6c/7/7a/7d/7e/10a/10b,Vn.3/5/5a/16/17,TM2.7,
//|                                        HRP.12,DFM.1/2/20/21/24/25,DUMC.20/21/30,SRNW.1,DIFRES.7,RESNWST.4,GT.8,PLRES.7
//|                                        V1.16,Vn.16,DUMC.21,DFM.10
//|                                       
//|                                            According to design rule DOC:TD-LO40-DR-2001 3R draft 2012-07-11v1 
//|                                       Add RESNWAA rule coding, SRAM Device Dimension Check Rule coding,SRMarker rules coding ,DRDOP.105 coding      
//|                                       Update SRAA.4a,SRAA.4c,SRNW.1,SRGT.3/7/10,SRDOP.102/103,SRSN.3a/3b/10,SRSP.3a/3b/10,SRRCT.104c,/106/107/107a/108
//|                                       SRM1.7ab,SRV1.6ac,SRM2.4,M1.8b,Mn.7b,Mn.11,DFM.3/5/9,MD.11
//|                                       Delete SRAA.4,SRNW.3,SRGT.5/7/9,SRSN.1/2/6/7,SRSP.1/2/6/7,SRCT.105/3/6a,SRRCT.104,SRV1.7,SRM1.3
//|                                       
//|                                               According to design rule DOC:TD-LO40-DR-2001 3R draft 2012-06-21v1 
//|                                        Add V1.16,V1.17,Vn.16,Vn.17;Update GT.4
//|                                             According to design rule DOC:TD-LO40-DR-2001 3R pre-Release design rule.doc 
//|                                       Update AA.4b/4a,AA.4c,AA.14,AA,9,AA.12, GT.1a~GT.1g,GT.3/4/9/10/5/6/7/8/17/20b,
//|                                         TG.4/3/5,TG.6,DG.3/4/5,DG.6,M1.7abc,M1.8,M1.8a,M1.9 Mn.8,Mn.7,Mn.7a,TM1.10,TM2.10,MTT_8,M1_2/3, 
//|               	                    TM1.5 TM2.5,TM1.13 TM2.12,M1.11a,M1.11b,M1.11c,Mn.10a,Mn.10b,M1.7bc_M1.7bc_M1.7e,TM1.8,TM2.8.
//|                                          MTT.2a,Mn.10c,M1.10,M1.4,M1.5,Mn.4,Mn.5,Mn.9,CT.3a,CT.6abd,6acd,CT.7ab,CT.1,CT.1a,CT.10,CT.2a,CT.4,
//|                                          V1.6d,V1.7d,V1.7abc,Vn.7abc,V1.6abc,Vn.6abc,V1.5,V1.5a,Vn.5,Vn.5a,V1.3,Vn.3,TV1.13,TV1.4,TV2.4, 
//|                                          LVT.6/9/10,HVT.6/9/10,PA.3,ALPA.1/9/10 HRP.2, SN.7b,MD.6,DFM.1,DFM.1a,DFM.2,DFM.2a,DFM_5_Mn,
//|                                        SRAA.4a,SRAA.1#a,SRAA.4/5/6/7/9,SRNW.1,SRGT.3/4/5/6/8/9/10,SRSP.1/12,SRM1_1,
//|                                       SRM1.4,SRMn.4,SAB.7/11,DUMC.6/16,NW.10, DUMC.22,PSUB_Note1/2/3/5 renamed as PSUB_10/11/12/13 ,PSUB.6,
//|                                       Add AA.14a,M1.13,M1.12,Mn.11,GT.20c,GT.20d,DFM1a,DFM2a, M1.11a,M1.11b,M1.11c,Mn.10a,Mn.10b,Mn.10c,V1.5b,Vn.5b      
//|                                       ,RESNWST,PLRES,DIFRES and LD rule coding,TV2.13,CORN.2,V1_5a/Vn_5a/M1_7e,CT.6c,HRP.1   
//|                                       Delete GT.16,M1.11c,Mn.10c,AA.C.5,SRCT.101,DUMBA/P/M from DUMC_2/6, 12/16,18/26,SRAA.101,DNW.5,DNW.6,SRCT.2a,SRSN.7b,DUMC.9 
//|                                                                               | 
//| V0.22=V0.0_0R Dec-27-2011 Zhitao_Chen  Rename file and version number.        |
//|                                                                               |
//|*******************************************************************************|
//| Old file name: SmicDR1T_cal40_log_ll_sali_p1mx_1tm_121825.drc                 |
//|                                                                               |
//| V0.22=V0.0_2R Dec-23-2011 Zhitao_Chen  M1_7c rule changed in doc 0.02==>0.015.|
//| V0.21=V0.0_2R Dec-20-2011 Zhitao_Chen  Update definition of MARKG and MARKS.  |
//|                                      Update code following change of rules:   |
//|                                       DUMC_2/12/23, M1_6/M1_6abc/Mn_6/Mn_6abc,|
//|                                       V1_6abcd/Vn6_abcd, V1_7abcd/Vn_7abcd,   |
//|                                       CT_10, M1_7abc, DFM_28, RESAA_12/13,    |
//|                                       PA_1, MD_11, TM1_13, TM2_12, DUMCN_13,  |
//|                                       CT_1, CT_6ab, CT_7ab, GT_2b.            |
//|                                       SRDOP_101, SRGT_7, SRCT_6a/7a.          |
//|                                      Add new groups of rules for HRP and MTT. |
//|                                      Add 6 new severity options.              |
//|                                      Code optimization of following items:    |
//|                                       Remove definition of *ING *BAR layers.  |
//|                                       OVERDR changed into 125:3,              |
//|                                       AA_4b, AA_7, PSUB_Note5, LVT_13, Vn_5,  |
//|                                       ALPA_7, PA_10, MD_6, MD_10, DFM_9, M1_3,|
//|                                       M2_3, AAC_5, DNW_4, DFM_4.              |
//|                                      Remove following rules:                  |
//|                                       DG_10, RESP1_10, RESAA_8/11, V1_4/Vn_4, |
//|                                       DUMCN_5, GT_13, SN_20, SP_20, SRGT_13,  |
//|                                       GSRNC, GSRPC, SRSM_1, LVT_3/14, HVT_3/14|
//|                                       SRAA_1.                                 |
//|                                                                               |
//|   0.20   Sept-9-2011    Zhitao_Chen  Add definition of layer LDBK (216:150).  |
//|                                      Exclude LDBK in AA_5/7/8/11 GT_5.        |
//|                                      Exclude PSUB in AA_6.                    |
//|                                      Exclude INDMY in PSUB_5/6/7/9/Note3.     |
//|                                      Update macros Mn_6 Mn_6a_6c Mn_6b follow |
//|                                       Li_Liu's fix in her local version 0.19a.|
//|                                      Update macro TM7.                        |
//|                                      Update MD_11 to avoid some false alarms. |
//|                                      Remove following groups of rules:        |
//|                                       NLL, LVN, VTNH, NLH, NLHT,              |
//|                                       PLL, LVP, VTPH, PLH, PLHT.              |
//|                                      Remove dummy/CT checks from BORDER rules.|
//|                                      Update TG_5/DG_5 to include all devices. |
//|                                      Update AA_12 to include all MOS.         |
//|                                      Change GT_1b from 0.2 into 0.15 .        |
//|                                      Add OPPOSITE in NW_3 SP_2 SN_2.          |
//|                                      Merge the content of SAB_12 into SAB_7,  |
//|                                       and disable check in SRAM by this rule. |
//|                                      Comment out GT_23, covered by SP_SN_17.  |
//|                                      Implement CT_2a/3a following document.   |
//|                                      Update CT_6ab CT_7ab to highlight CT     |
//|                                       partially in AA or partially in GT also.|
//|                                      Update GT_1fg to check NMOS also.        |
//|                                      Update GT_22.                            |
//|                                      Add option SRAM_GT_DIRECTION and GT_26.  |
//|                                      Update definition of MDA for AAC_4,      |
//|                                       because it was >=0.1 <0.2 in same line. |
//|                                      Remove PA_9 ALPA_6 RESP1_14 TG_10        |
//|                                       GT_24a/25a.                             |
//|                                      Remove option RECOMMENDED and RESAA/P1_8.|
//|                                      Change TM1_13 TM2_12 from 12um to 30um.  |
//|                                       Notice that TM1_13 is for 2TM case only.|
//|                                      Change NOT INST into NOT INSIDE INST in: |
//|                                       AA_1a/4a/4b/4c/5/6/7 NW_3 GT_3~10/13    |
//|                                       SP_3a/3b/6/7a/7b/10/12/15/20            |
//|                                       SN_3a/3b/4/6/7a/7b/10 CT_4/5/6ab/7ab    |
//|                                       M1_3/7ab V1_6abc/7abc/8 M2_3 V2_6abc    |
//|                                       DFM_5_M1/M2 DFM_8/19 DFM_22_M2 DFM_23_M2|
//|                                       and layers AAconerdfm/GTconerdfm.       |
//|                                      Change NOT EXCLU into                    |
//|                                         NOT INSIDE (EXCLU OR MARKG)           |
//|                                       in all layer definitions.               |
//|                                      Disable MARKG area in following rules:   |
//|                                       AA_14a/b _15a/b AAC_3 GT_20l/h _20bl/h  |
//|                                       M1_8/8a/8b/8c M2~M8_7/7a~7e             |
//|                                       TM1_10a/10b/11/12 TM2_10a/10b/11        |
//|                                       ALPA_1/2/5/7/9/10/11 PA_1~4             |
//|                                       Convention_BAD_IMP                      |
//|                                      Update M4_7~M8_7 depending on option     |
//|                                       of TOPMETAL, to avoid using >0 <0.2 .   |
//|                                      Update definition of V1_array Vn_array.  |
//|                                      Add rule ALPA_12 (must be drawn layer.)  |
//|                                      Splited M1_7ab to M1_7ab_AA and M1_7ab_GT|
//|                                       and add code to check CT enclosure by   |
//|                                       M1 with width > 0.14.                   |
//|                                      Replace INSIDE OF LAYER in density rules:|
//|                                       AA_15a/b ALPA_5                         |
//|                                      Use DENSITY ... [area()/area()] ... in   |
//|                                       GT_20bl/h                               |
//|                                      Update DNW_4 to find DNW NW touching also|
//|                                      Add BORDER_3 (DNW enclosure by BORDER)   |
//|                                      Change layer DG from all 29 into 29:0 .  |
//|                                      Add layer ESD1 (41:0) and ESD1 rules.    |
//|                                      Rename PSUB_3c into PSUB_3cd.            |
//|                                      Implement DFM4 following 65nm style.     |
//|                                      Update DFM26 following 65nm DFM21 style. |
//|                                      Following rule codes added by Jane_Zeng: |
//|                                       LVT_2/3/4a/5a/10/14,HVT_2/3/4a/5a/10/14.|
//|                                      Update code HVT_5 following Jane_Zeng.   |
//|                                      Change L/HVT_9 from 0.19 to 0.1, remove  |
//|                                       L/HVT_3a/7/12.                          |
//|                                      TV space change from 0.36 to 0.34.       |
//|                                      Add metal option of 3 inter metals.      |
//|                                      Optimize DFM_5 following Li_Liu's code.  |
//|                                      Add seal ring rules.                     |
//|                                      Update DFM priority1 rules to check SRAM.|
//|                                      For 2TM, update TV1_Note into TV1_13.    |
//|                                      Copy DUMC DUMCN rules from Hu_Tang.      |
//|                                      Update V1_6/7d Vn_6/7d.                  |
//|                                      Update V1_4/Vn_4 to exclude MOMDMY.      |
//|                                      Border and DUMC_31 interpret BORDER as   |
//|                                       holes being filled.                     |
//|                                      Add Calibre version of validation.       |
//|   0.19    20-Jul-2011    Hu_Tang      DR update:                              |
//|                                       Update GT_16,                           |
//|                                       Add back definitions of M1W~M8W         |
//|   0.18    18-Jul-2011    Hu_Tang      DR update:                              |
//|                                       change corn size from 78 to 74 in CORN.1|
//|   0.17    12-Jul-2011    Hu_Tang      DR update to 1T(2011-06-29v1):          | 
//|                                      Update BORDER rules and change its switch|                   
//|                                      Add CORN.1 and define its switch         |
//|                                      Add MD.11                                |  
//|                                      Delete CT14~CT18,V11~V15,Vn.11~Vn.15,    | 
//|                                             TV2.8~TV2.12                      |
//|                                             PA.5~PA.8, MD.7,MD.9              |                   
//|                                      Modify M1.6,M1.6a,M1.6b,M1.6c            |
//|                                             Mn.6,Mn.6a,Mn.6b,Mn.6c            |
//|                                             TM2.5,TM2.6,TM2.7                 | 
//|   0.15    15-Feb-2011    Carolyn Y     DR update to 1T(2011-01-31v2) :	  |
//|					   Changed back LVT.4,HVT.4,LVN.4,LVP.4,  |
//|					      VTNH.4,VTPH.4 to 0.14 from 0.18.	  |
//|   0.14    20-Jan-2011    Carolyn Y     DR update to 1T(2011-01-09v1) :	  |
//|					   Modify GT.9&10(0.14->0.13).		  |
//|					      TM1.5&6, TM2.5&6(">="->">").	  |
//|					      DFM.9(0.11->0.09),DFM.13(0.30->0.18)|
//|					      LVT.4,HVT.4,LVN.4,LVP.4,VTNH.4,     |
//|					      VTPH.4(0.14->0.18).		  |
//|					   Add the BORDER rules and a swicth.	  |
//|					      DFM.26.				  |
//|					   Delete ALPA.4.			  |
//|					   Correct AA.10(AA->MOS).		  |
//|					   Optimize Vn.6d&7d(with edge->enclose   |
//|					      rectangle).			  |
//|   0.13    16-Dec-2010    Carolyn Y     DR update to 1T(2010-12-14) :	  |
//|					   Modify NW.3&4(potential to net), delete|
//|					   NW.5&6 and "VIRTUAL CONNECT "VDD" ..". |
//|					   GT.1c(0.26->0.27),PSUB.3c(0.5->1.20).  |
//|					   PSUB.3b(0.45->0.8).			  |
//|   0.12    15-Sep-2010    Carolyn Y     DR update to 1T(20100915) :   	  |
//|					   SRAM rule update to 0T(20100913) :	  |
//|					   Dummy check rule(20100908) :		  |
//|					   1.Modify SRPW_1(generative PW->original PW) 
//|					   SN.10/SP.10, LVT.7/HVT.7(include S/D   |
//|					   direction check, exclude pickup).      |
//|					   LVT.4/HVT.4, NLL.4/PLL.4, LVN.4/LVP.4, |
//|					   VTNH.4/VTPH.4, NLH.4/PLH.4, NLHT.4/PLHT.4|
//|					   (0.22->0.18).			  |
//|					   The description of LVT.5/HVT.5,  
//|					   NLL.5&7/PLL.5&7, LVN.5&7/LVP5&7,       |
//|					   VTNH.5&7/VTPH.5&7, NLH.5&7/PLH5&7,	  |
//|					   NLHT.4/PLHT.4; CT.11.		  |
//|					   Modify well, LDD, S/D implant rules's  |
//|					   width, space to be with run length > 0.|
//|					   Seperated HVT.3 to HVT.3a and HVT.3b,  |
//|					   LVT/HVT.3 to LVT/HVT.3a and LVT/HVT.3b,|
//|					   NLL/PLL.3 to NLL/PLL.3a and NLL/PLL.3b,|
//|					   LVN/LVP.3 to LVN/LVP.3a and LVN/LVP.3b,|
//|					   NLH/PLH.3 to NLH/PLH.3a and NLH/PLH.3b,|
//|					   VTN/PH.3 to VTN/PH.3a and VTN/PH.3b,	  |
//|					   N/PLHT.3 to N/PLHT.3a and N/PLHT.3b,   | 
//|					   SN.3/SP.3 tp SN.3/SP.3a and SN.3/SP.3b.|
//|					   HVT.5(0.18->0.08).                     |
//|					   SAB.10(0.32->0.20).			  |
//|					   GT.2b(extend AA 0.6->2.5).		  |
//|					   GT.18(0.042->0.04).			  |
//|					   CT.3(0.23->0.11).			  |
//|					   Vn.6d/Vn.7d(intersection area->width.  |
//|					   Convention_BPMO(exclude Varactor MOS). |
//|					   AA.1/AA.9, NW.1, SN.1/SN.16, SP.1/SP.16|
//|					   M1.4/M2.4(The region coross INST are   |
//|					   checked by SRAM rules.)		  | 
//|					   2.Add DFM_5_M8, DFM_7_M8.		  |
//|					   Dummy check rules.			  |
//|					   3.Delete grid selection option, there's|
//|					   only 0.001um grid size allowed.	  |
//|					   SN.19, SP.19, SRGT.102.		  |
//|					   4.Optimize Convention_latchup.a/b to   |
//|				           reduce the run time.			  |
//|					   SN.16(NOT->NOT IN INST).		  |
//|					   5.Correct the definition of SQCT.	  |
//|   0.11    09-Aug-2010    Carolyn Y     Optimize deck :                        |
//|                                        DFM_24_Mn(EXCINS->EXCLU).              |
//|                                        LVT_11/HVT_11(PACT->PTAP,NACT->NTAP).  |
//|   0.10    26-Jul-2010    Carolyn Y     Add SRAM rules.			  |
//|					   Modify (main rules exclude SRAM cell   |
//|					   check) to (main rules include SRAM cell|
//|					   check).				  |
//|   0.9     23-Jul-2010    Carolyn Y     Add convention rules.		  |
//|					   Fixed V5/6_8/9/10 bugs(modify the      |
//|					   connect via are V5/V6).		  |
//|   0.8     20-Jul-2010    Carolyn Y     Optimize POLY_2b to avoid false alarm. |
//|   0.7     19-Jul-2010    Carolyn Y     Update NW.1&NW.3(0.30->0.33);	  |
//|					   NW.4,NW.5&NW.6(0.50->0.60);		  |
//|					   PSUB.1&PSUB.4(0.30->0.33);		  |
//|					   CT.3(run_length 0.0->0.34).		  |
//|					   Optimize the description of SN.22.	  |
//|					   Delete M1.7cd.			  |
//|   0.6     15-Jul-2010    Carolyn Y     Update CT.8&CT.9(0.40->0.30). 	  |
//|					   Mn.6(0.105->0.10).			  |
//|					   Optimize V1.8.			  |
//|   0.5     14-Jul-2010    Carolyn Y     DR update to 1T(20100713).		  |
//|					   About deck :				  |
//|					   1.Add Vn.7d rules in advance.	  |
//|					   2.Optimize AA_4b.			  |
//|   0.4     08-Jul-2010    Carolyn Y     DR update to 1T(20100706).		  |
//|   0.3     01-Jul-2010    Carolyn Y     DR update to 1T(20100630). 		  |
//|					   1.Correct Vn_6abc&Vn_7abc, check the   |
//|					    via in Mn and Mn+1 intersection region.|
//|					   2.Redefine GT(execpt floating poly).	  |
//|   0.2     22-Jun-2010    Carolyn Y     DR update to 1T(201006111) :		  |
//|					   1.Add layer BORDER(127;0) as CHIPEDGE. |
//|					   2.Correct AA.10(for different VT).	  |		
//|					   DFM rule update to 1T :		  |
//|   0.1     22-Apr-2010    Carolyn Y     DR update to 1T(20100531) :		  |
//|   QA level : II								  |
//|										  |
//|*******************************************************************************|
//| Old file name : SmicDR0T_cal40_log_ll_sali_p1mt10_121825.drc		  |
//|   1.0     18-Jan-2010    Carolyn Y     Initiate version.			  |
//|   QA level : I								  |
//|                                                                               |
//|===============================================================================|


//#################################################
//#     Environmental Variables Setting           #
//#################################################

/*TOP Metal select. The value can be 9,8,7,6,5,4(include single top metals(TM2)).
  Default value is 9.*/
#DEFINE TOPMETAL 9


//This switch is for default turn on DFM rules
//Default value is "YES" to check default turn on DFM rules
//Please change the value "YES" into "NO" if you don't want to check this rules
#DEFINE DFM_rules_CHECK_ON YES
   

//This switch is for default turn off DFM rules
//Default value is "NO" not to check default turn off DFM rules
//Please change the value "NO" into "YES" if you want to check this rules
#DEFINE DFM_rules_CHECK_OFF NO


/* LDMOS rule selection. Defaults to NO.
  when check LDMOS rules , please set it to "YES"; 
  when not to check LDMOS rules, please set it to "NO".*/
#DEFINE LDMOS NO


/* Inductor rule selection. Defaults to YES.
  when check inductor rules , please set it to "YES"; 
  when not to check inductor rules, please set it to "NO".*/
#DEFINE INDUCTOR YES


/* BUMP rule selection. Defaults to NO.
  when check BUMP rules , please set it to "YES"; 
  when not to check BUMP rules, please set it to "NO".*/
#DEFINE BUMP NO


/* DUP rule selection. Defaults to YES.
  when check DUP rules , please set it to "YES"; 
  when not to check DUP rules, please set it to "NO".*/
#DEFINE DUP YES


/* CORN rule selection. Defaults to YES.
  when check Chip without SEAL RING , please set it to "YES"; 
  when check Chip with SEAL RING, please set it to "NO".*/
#DEFINE CHK_CORN YES


/*BORDER rule selection. Defaults to YES.
  If customer check the chip level , please set it to "YES"; 
  If customer check the IP level , please set it to "NO".*/
#DEFINE CHK_BORDER YES


/*SRAM GT direction selection. Default is H (horizontal).
  But it can also be changed into V (vertical). */
#DEFINE SRAM_GT_DIRECTION H


/*If top metal is layer TM2 (layer 122, top metal with regular thickness), then please use default value NO.
  If top metal is layer MTT2 (layer 231, top metal with ultra thickness), then please change it into YES.*/
#DEFINE UTM NO


/*ESD layout guideline selection. Defaults to NO.
  when check ESD layout guidelines, please set it to "YES"; 
  when not to check ESD layout guidelines, please set it to "NO".*/
#DEFINE ESD NO


/*Latch Up Prevention Layout Guidelines selection. Defaults to YES.
  when check Latch up guidelines, please set it to "YES"; 
  when not to check Latch up guidelines, please set it to "NO".*/
#DEFINE LATCH_UP YES


/*MOM(metal oxide metal) capacitor rule selection for MOM.5[G],MOM.6[G]. Defaults to YES.
  when check MOM.5[G],MOM.6[G] guidelines,please set it to "YES";
  when not to check MOM.5[G],MOM.6[G] guidelines,please set it to "NO".*/
#DEFINE MOM_5_6_CHECK YES


/*NOTICE:this switch is only for SMIC internal pcell use.
Customer or other users please keep the default set "NO".
SMIC don't bear any responsibility for use this switch!
MOM(metal oxide metal) capacitor rule selection for MOM.4[G]. Defaults to NO.
when check MOM.4[G] guidelines,please set it to "YES";
when not to check MOM.4[G] guidelines,please set it to "NO"*/
#DEFINE MOM_4_CHECK NO


//*************************************
//     DIRECTIVE SECTION
//*************************************

LAYOUT PRIMARY "*"
LAYOUT PATH "xxx.gds"
LAYOUT SYSTEM GDSII

DRC RESULTS DATABASE "drc_CAL.OUT" ASCII
DRC SUMMARY REPORT "drc_CAL.SUM" HIER
PRECISION       1000
RESOLUTION      1

FLAG ACUTE YES
FLAG NONSIMPLE YES
FLAG SKEW YES
FLAG OFFGRID YES

skew_edge_check {
           @Skew edge check
           DRAWN SKEW }
// does not check layers that do not appear in other rule
// checks used in the run

DRC EXCLUDE FALSE NOTCH YES

TEXT DEPTH PRIMARY

LAYOUT BASE LAYER AAi GTi NWi DNWi SNi SPi CTi
//LVS POWER NAME "?VDD?" "?VCC?"

LAYOUT INPUT EXCEPTION SEVERITY PATH_NONSIMPLE 2
LAYOUT INPUT EXCEPTION SEVERITY PATH_CIRCULAR 6
LAYOUT INPUT EXCEPTION SEVERITY POLYGON_NONSIMPLE 2
LAYOUT INPUT EXCEPTION SEVERITY POLYGON_NOT_CLOSED 2
LAYOUT INPUT EXCEPTION SEVERITY PATH_ENDSEGMENT_SHORT 2
LAYOUT INPUT EXCEPTION SEVERITY PATH_ACUTE 4
LAYOUT INPUT EXCEPTION SEVERITY PATH_WIDTH_ZERO 2
LAYOUT INPUT EXCEPTION SEVERITY POLYGON_IS_RECTANGLE 2
LAYOUT INPUT EXCEPTION SEVERITY BOX_RECORD 4
LAYOUT INPUT EXCEPTION SEVERITY NODE_RECORD 4

GROUP DFM_rules_all ?_R_?
GROUP DFM_rules_ON ?_ON
GROUP DFM_rules_OFF ?_OFF

#IFDEF DFM_rules_CHECK_ON NO
DRC UNSELECT CHECK DFM_rules_ON
#ENDIF

#IFDEF DFM_rules_CHECK_OFF NO
DRC UNSELECT CHECK DFM_rules_OFF
#ENDIF

#ENCRYPT

//************************************
//     INPUT LAYER STATEMENTS
//************************************

LAYER MAP 10 DATATYPE 0 1000
LAYER AAi	1000	// Active Area
LAYER MAP 10 DATATYPE 1 1010
LAYER AADUM     1010     // Dummy AA layer
LAYER MAP 14 DATATYPE 0 1400
LAYER NWi       1400
LAYER MAP 16 DATATYPE 0 1600
LAYER PCi       1600    // SRAM PMOS implant
LAYER MAP 19 DATATYPE 0 1900
LAYER DNWi      1900
//LAYER MAP 20 DATATYPE 0 2000
//LAYER PWi       2000
LAYER MAP 21 DATATYPE 0 2101
LAYER NCi       2101    // SRAM NMOS implant
LAYER MAP 26 DATATYPE 0 2600 
LAYER LOGO      2600      // L MARK area
LAYER MAP 29 DATATYPE 0 290
LAYER DGi	290
LAYER MAP 30 DATATYPE 0 300
LAYER GTi	300	// Poly Gate
LAYER MAP 30 DATATYPE 1 301
LAYER GTDUM	301	// GT Dummy
LAYER MAP 34 DATATYPE 0 3400
LAYER HRi       3400
LAYER MAP 35 DATATYPE 0 3500
LAYER NLLi	3500
LAYER MAP 36 DATATYPE 0 3600
LAYER NLHi	3600
LAYER MAP 37 DATATYPE 0 3700
LAYER PLHi	3700
LAYER MAP 38 DATATYPE 0 3800	
LAYER PLLi	3800
LAYER MAP 39 DATATYPE 0 390
LAYER HRPi      390
LAYER MAP 40 DATATYPE 0 400
LAYER SNi       400
LAYER MAP 41 DATATYPE 0 410
LAYER ESD1i 410
LAYER MAP 43 DATATYPE 0 430
LAYER SPi       430
LAYER MAP 46 DATATYPE 0 4600
LAYER VTPHi     4600
LAYER MAP 47 DATATYPE 0 4700
LAYER VTNHi     4700
LAYER MAP 48 DATATYPE 0 4800
LAYER SABi      4800
LAYER MAP	50 DATATYPE 0 500
LAYER CTi	500
LAYER MAP	60 DATATYPE 0 600
LAYER INST	600	// SRAM block layer
LAYER MAP       61 DATATYPE 0 610
LAYER M1i	610
LAYER MAP       61 DATATYPE 1 611
LAYER M1DUMi	611
LAYER MAP       62 DATATYPE 0 620
LAYER M2i	620
LAYER MAP       62 DATATYPE 1 621
LAYER M2DUMi	621
LAYER MAP       63 DATATYPE 0 630
LAYER M3i	630
LAYER MAP	63 DATATYPE 1 631
LAYER M3DUMi	631
LAYER MAP       64 DATATYPE 0 640
LAYER M4i	640
LAYER MAP       64 DATATYPE 1 641
LAYER M4DUMi	641
LAYER MAP       65 DATATYPE 0 650
LAYER M5i	650
LAYER MAP       65 DATATYPE 1 651
LAYER M5DUMi	651
LAYER MAP       66 DATATYPE 0 660
LAYER M6i	660
LAYER MAP       66 DATATYPE 1 661
LAYER M6DUMi	661
LAYER MAP       67 DATATYPE 0 670
LAYER M7i	670
LAYER MAP       67 DATATYPE 1 671
LAYER M7DUMi	671
LAYER MAP       68 DATATYPE 0 680
LAYER M8i	680
LAYER MAP       68 DATATYPE 1 681
LAYER M8DUMi	681
LAYER MAP       70 DATATYPE 0 700
LAYER V1i	700
LAYER MAP	70 DATATYPE 1 701
LAYER V1DUMi	701
LAYER MAP	70 DATATYPE 6 706
LAYER V1DUB	706
LAYER MAP       71 DATATYPE 0 710
LAYER V2i	710
LAYER MAP	71 DATATYPE 1 711
LAYER V2DUMi	711
LAYER MAP       71 DATATYPE 6 716
LAYER V2DUB     716
LAYER MAP       72 DATATYPE 0 720
LAYER V3i	720
LAYER MAP	72 DATATYPE 1 721
LAYER V3DUMi	721
LAYER MAP       72 DATATYPE 6 726
LAYER V3DUB     726
LAYER MAP	73 DATATYPE 0 730
LAYER V4i	730
LAYER MAP	73 DATATYPE 1 731
LAYER V4DUMi	731
LAYER MAP       73 DATATYPE 6 736
LAYER V4DUB     736
LAYER MAP	74 DATATYPE 0 740
LAYER V5i	740
LAYER MAP	74 DATATYPE 1 741
LAYER V5DUMi	741	
LAYER MAP       74 DATATYPE 6 746
LAYER V5DUB     746
LAYER MAP       75 DATATYPE 0 750
LAYER V6i	750
LAYER MAP	75 DATATYPE 1 751
LAYER V6DUMi	751	
LAYER MAP       75 DATATYPE 6 756
LAYER V6DUB     756
LAYER MAP       76 DATATYPE 0 760
LAYER V7i	760
LAYER MAP	76 DATATYPE 1 761
LAYER V7DUMi	761
LAYER MAP       76 DATATYPE 6 766
LAYER V7DUB     766
LAYER MAP       85 DATATYPE 0 850
LAYER PSUBi     850
LAYER MAP 	80 DATATYPE 0 800
LAYER PA        800     // Passivation / Pad
LAYER MAP	81 DATATYPE 0 810
LAYER FUSE      810     // Fuse Window
LAYER MAP	81 DATATYPE 1 811
LAYER GTFUSE	811
LAYER MAP       81 DATATYPE 2 812
LAYER EFUSE     812
LAYER MAP       83 DATATYPE 0 830
LAYER ALPAi      830     // AlGu bonding pad,Alfuse
LAYER MAP	83 DATATYPE 6 836
LAYER ALDUB	836
LAYER MAP	83 DATATYPE 11 8311
LAYER ALDUM	8311
LAYER MAP 90 DATATYPE 0 900
LAYER DUMBM     900     // Dummy Metal block layer
LAYER MAP 91 DATATYPE 0 910
LAYER DUMBA     910     // Dummy AA block layer
LAYER MAP 92 DATATYPE 0 920
LAYER DUMBP     920     // Dummy poly block layer
LAYER MAP	93 DATATYPE 0 930
LAYER VARMOS    930
LAYER MAP	95 DATATYPE 0 950
LAYER RESNW     950     // Dummy Pattern for NWELL Resistor
LAYER MAP	96 DATATYPE 0 960
LAYER RESP1     960     // Dummy Pattern for Poly-1 Resistor
LAYER MAP       96 DATATYPE 3 963
LAYER PLRES     963
LAYER MAP	97 DATATYPE 0 970
LAYER RESAA     970     // Dummy Pattern for AA Resistor
LAYER MAP       97 DATATYPE 3 973
LAYER DIFRES    973
LAYER MAP 99 DATATYPE 0 990
LAYER SDOPi	990     // SRAM PG implant
LAYER MAP 109 DATATYPE 0 1090
LAYER PWHTi	1090
LAYER MAP 110 DATATYPE 0 1100
LAYER NWHTi	1100
LAYER MAP 114 DATATYPE 0  1140 
LAYER NLHTi	1140
LAYER MAP 115 DATATYPE 0  1150
LAYER PLHTi	1150
LAYER MAP       123 DATATYPE 0 1230
LAYER TV2i      1230
LAYER MAP	122 DATATYPE 0 1220
LAYER TM2i      1220
LAYER MAP       122 DATATYPE 1 1221
LAYER TM2DUMi   1221
LAYER MAP       125 DATATYPE 0 1250
LAYER TGi	1250
LAYER MAP       125 DATATYPE 1 1251
LAYER TGV	1251	// Marking layer for 2.5V UD 1.8V device
LAYER MAP       125 DATATYPE 3 1253
LAYER OVERDR    1253	// Marking layer for 2.5V OD 3.3V device
LAYER MAP	127 DATATYPE 0 1270
LAYER BORDERi    1270    // Top Structure's Border
LAYER MAP 130 DATATYPE 0 1300
LAYER MD	1300
LAYER MAP 132 DATATYPE 0 1320
LAYER EXCLU	1320    // Un-DRC region
LAYER MAP 137 DATATYPE 0 1370
LAYER CAPBP     1370    // Capacitor Dummy
LAYER MAP       138 DATATYPE 0 1380
LAYER DSTR      1380
LAYER MAP	151 DATATYPE 1 1511
LAYER M1DUB     1511
LAYER MAP	152 DATATYPE 1 1521
LAYER M2DUB     1521
LAYER MAP	153 DATATYPE 1 1531
LAYER M3DUB	1531	
LAYER MAP       154 DATATYPE 1 1541
LAYER M4DUB     1541
LAYER MAP       155 DATATYPE 1 1551
LAYER M5DUB     1551
LAYER MAP       156 DATATYPE 1 1561
LAYER M6DUB     1561
LAYER MAP       157 DATATYPE 1 1571
LAYER M7DUB     1571
LAYER MAP       158 DATATYPE 1 1581
LAYER M8DUB     1581
LAYER MAP 	159 DATATYPE 12 1592
LAYER LVT	1592	// Low-Vt devices
LAYER MAP	159 DATATYPE 11 1591
LAYER HVT	1591	// High-Vt devices
LAYER MAP	159 DATATYPE 7 1597
LAYER PTCT	1597
LAYER MAP       159 DATATYPE 1 1590
LAYER BIPOLA    1590
LAYER MAP       171 DATATYPE 0 1710
LAYER M1R       1710  // Dummy for Metal1 Resistor
LAYER MAP       172 DATATYPE 0 1720
LAYER M2R       1720  // Dummy for Metal2 Resistor
LAYER MAP       173 DATATYPE 0 1730
LAYER M3R       1730  // Dummy for Metal3 Resistor
LAYER MAP       174 DATATYPE 0 1740
LAYER M4R       1740  // Dummy for Metal4 Resistor
LAYER MAP       175 DATATYPE 0 1750
LAYER M5R       1750  // Dummy for Metal5 Resistor
LAYER MAP       176 DATATYPE 0 1760
LAYER M6R       1760  // Dummy for Metal6 Resistor
LAYER MAP       177 DATATYPE 0 1770
LAYER M7R       1770  // Dummy for Metal7 Resistor
LAYER MAP       178 DATATYPE 0 1780
LAYER M8R       1780  // Dummy for Metal8 Resistor
LAYER MAP       189 DATATYPE 151 1891
LAYER MARKS     1891
LAYER MAP       189 DATATYPE 0 1890
LAYER MARKG     1890
LAYER MAP	193 DATATYPE 1 1931
LAYER TM1DUB	1931
LAYER MAP	194 DATATYPE 1 1941
LAYER TM2DUB    1941
LAYER MAP       194 DATATYPE 2 1942
LAYER MTT2DB    1942
LAYER MAP       201 DATATYPE 0 2010
LAYER TM1R      2010  // Dummy for Top Metal1 Resistor
LAYER MAP       202 DATATYPE 0 2020
LAYER TM2R      2020 // Dummy for Top Metal2 Resistor
LAYER MAP       131 DATATYPE 4 1314
LAYER PLDMK     1314
LAYER MAP       134 DATATYPE 0 1340
LAYER DMPNP     1340
LAYER MAP       203 DATATYPE 0 2030
LAYER WNi       2030     // NFET Tensile SiN film Cap
LAYER MAP       210 DATATYPE 0 2100
LAYER HRPDMY    2100
LAYER MAP	211 DATATYPE 1 2111
LAYER MAP       211 TEXTTYPE 1 2111
LAYER MOMDMY    2111
LAYER MAP	212 DATATYPE 0 2120
LAYER INDMY     2120     // IN Dummy Layer
LAYER MAP       216 DATATYPE 150 516
LAYER LDBK      516     //      Identify LDMOS function area and do related
LAYER MAP       218 DATATYPE 0 2180 
LAYER LVPi	2180
LAYER MAP       219 DATATYPE 0 2190
LAYER LVNi	2190
LAYER MAP       231 DATATYPE 0 2310
LAYER MTT2i     2310
LAYER MAP       89 DATATYPE 160 8916
LAYER OTPMK1    8916

LAYER   MAP     61   DATATYPE 7 6170
LAYER   M1DOP   6170
LAYER   MAP     62   DATATYPE 7 6270
LAYER   M2DOP   6270
LAYER   MAP     63   DATATYPE 7 6370
LAYER   M3DOP   6370
LAYER   MAP     64   DATATYPE 7 6470
LAYER   M4DOP   6470
LAYER   MAP     65   DATATYPE 7 6570
LAYER   M5DOP   6570
LAYER   MAP     66   DATATYPE 7 6670
LAYER   M6DOP   6670
LAYER   MAP     67   DATATYPE 7 6770
LAYER   M7DOP   6770
LAYER   MAP     68   DATATYPE 7 6870
LAYER   M8DOP   6870
LAYER   MAP     70   DATATYPE 7 7070
LAYER   V1DOP   7070
LAYER   MAP     71   DATATYPE 7 7170
LAYER   V2DOP   7170
LAYER   MAP     72   DATATYPE 7 7270
LAYER   V3DOP   7270
LAYER   MAP     73   DATATYPE 7 7370
LAYER   V4DOP   7370
LAYER   MAP     74   DATATYPE 7 7470
LAYER   V5DOP   7470
LAYER   MAP     75   DATATYPE 7 7570
LAYER   V6DOP   7570
LAYER   MAP     76   DATATYPE 7 7670
LAYER   V7DOP   7670
LAYER   MAP     231  DATATYPE 1 2311
LAYER   MTT2DMi 2311
LAYER MAP       61 DATATYPE 251 6151
LAYER M1PIN	6151
LAYER MAP       62 DATATYPE 251 6251
LAYER M2PIN	6251
LAYER MAP       63 DATATYPE 251 6351
LAYER M3PIN	6351
LAYER MAP       64 DATATYPE 251 6451
LAYER M4PIN	6451
LAYER MAP       65 DATATYPE 251 6551
LAYER M5PIN	6551
LAYER MAP       66 DATATYPE 251 6651
LAYER M6PIN	6651
LAYER MAP       67 DATATYPE 251 6751
LAYER M7PIN	6751
LAYER MAP       68 DATATYPE 251 6851
LAYER M8PIN	6851
LAYER MAP       60 DATATYPE 2  622
LAYER DNSRAM	622
LAYER MAP       60 DATATYPE 4  624
LAYER DPSRAM	624
LAYER MAP       60 DATATYPE 5  625
LAYER LRSRAM	625
LAYER MAP       60 DATATYPE 11  6211
LAYER D2SRAM	6211

LAYER MAP       60 DATATYPE 9  629
LAYER RFSRAM	629
LAYER MAP       60 DATATYPE 12  6012
LAYER 2PSRAM    6012
LAYER MAP       60 DATATYPE 150 6015
LAYER HPBL	6015

LAYER MAP       159 DATATYPE 152 15952 
LAYER ULVTi	15952
LAYER MAP       168 DATATYPE 0 1680 
LAYER BUMPi	1680
LAYER MAP       91 DATATYPE 5  9150 
LAYER OCOVLi	9150
LAYER MAP       29 DATATYPE 1  2901 
LAYER DGV	2901
LAYER MAP       89 DATATYPE 156  8956 
LAYER DUPMK1i	8956
LAYER MAP       83 DATATYPE 1  8319 
LAYER ALPAR	8319
LAYER MAP      133 DATATYPE 0  1330
LAYER ESDIO1   1330
LAYER MAP      133 DATATYPE 3  1333
LAYER ESDIO2   1333
LAYER MAP      133 DATATYPE 1  1331
LAYER ESDHV    1331
LAYER MAP  81 DATATYPE 152 8115
LAYER FUSEMK1  8115
LAYER MAP  83 DATATYPE 2 8322
LAYER ALPATXT 8322
LAYER MAP  131 DATATYPE 175 1375
LAYER VDDMK1 1375
LAYER MAP  131 DATATYPE 176 1376
LAYER VSSMK1 1376
LAYER MAP 999 DATATYPE 1117 4327
LAYER EMPTY5 4327
LAYER MAP 131 DATATYPE 177 1377
LAYER LUWMK1 1377 
LAYER MAP 91  DATATYPE  4  948
LAYER OCCD 948
LAYER MAP 999 DATATYPE 1120 4330
LAYER EMPTY8 4330

LAYER MAP 211 DATATYPE 11 2110
LAYER MOMMK1 2110
LAYER MAP 211 DATATYPE 12 2118 
LAYER MOMMK2 2118
LAYER MAP 211 DATATYPE 13 2112	
LAYER MOMMK3 2112
LAYER MAP 211 DATATYPE 14 2113	
LAYER MOMMK4 2113
LAYER MAP 211 DATATYPE 15 2114	
LAYER MOMMK5 2114
LAYER MAP 211 DATATYPE 16 2115	
LAYER MOMMK6 2115
LAYER MAP 211 DATATYPE 17 2116	
LAYER MOMMK7 2116
LAYER MAP 211 DATATYPE 18 2117	
LAYER MOMMK8 2117	


#IFDEF OPEN_ALL_RECOMMENDED_GUIDELINE YES
#DEFINE DFM_rules_CHECK_ON YES
#DEFINE DFM_rules_CHECK_OFF YES
#DEFINE LDMOS YES
#DEFINE INDUCTOR YES
#DEFINE BUMP YES
#DEFINE DUP YES
#DEFINE CHK_CORN YES
#DEFINE CHK_BORDER YES
#DEFINE ESD YES
#DEFINE LATCH_UP YES
#DEFINE MOM_5_6_CHECK YES
#DEFINE MOM_4_CHECK YES
#ENDIF


//MARKS = COPY MARKS
M1DUM   = (M1DUMi OR M1DOP) NOT MARKS
M2DUM   = (M2DUMi OR M2DOP) NOT MARKS
M3DUM   = (M3DUMi OR M3DOP) NOT MARKS
M4DUM   = (M4DUMi OR M4DOP) NOT MARKS
M5DUM   = (M5DUMi OR M5DOP) NOT MARKS
M6DUM   = (M6DUMi OR M6DOP) NOT MARKS
M7DUM   = (M7DUMi OR M7DOP) NOT MARKS
M8DUM   = (M8DUMi OR M8DOP) NOT MARKS
V1DUM   = (V1DUMi OR V1DOP) NOT MARKS
V2DUM   = (V2DUMi OR V2DOP) NOT MARKS
V3DUM   = (V3DUMi OR V3DOP) NOT MARKS
V4DUM   = (V4DUMi OR V4DOP) NOT MARKS
V5DUM   = (V5DUMi OR V5DOP) NOT MARKS
V6DUM   = (V6DUMi OR V6DOP) NOT MARKS
V7DUM   = (V7DUMi OR V7DOP) NOT MARKS
TM2DUM  = TM2DUMi NOT MARKS
MTT2DM  = MTT2DMi NOT MARKS

AA	= AAi NOT MARKS
NW	= NWi NOT MARKS
PC	= PCi NOT MARKS
DNW	= DNWi NOT MARKS
NC	= NCi NOT MARKS
DG	= DGi NOT MARKS
GT	= GTi NOT MARKS
NLL	= NLLi NOT MARKS
NLH	= NLHi NOT MARKS
PLH	= PLHi NOT MARKS
PLL	= PLLi NOT MARKS
SN	= SNi NOT MARKS
SP	= SPi NOT MARKS
VTPH	= VTPHi NOT MARKS
VTNH	= VTNHi NOT MARKS
SAB	= SABi NOT MARKS
CT	= CTi NOT MARKS
M1      = M1i NOT MARKS
V1      = V1i NOT MARKS
M2	= M2i NOT MARKS
V2	= V2i NOT MARKS
M3	= M3i NOT MARKS
V3	= V3i NOT MARKS
M4	= M4i NOT MARKS
V4	= V4i NOT MARKS
M5	= M5i NOT MARKS
V5	= V5i NOT MARKS
M6	= M6i NOT MARKS
V6	= V6i NOT MARKS
M7	= M7i NOT MARKS
V7	= V7i NOT MARKS
M8	= M8i NOT MARKS
TV2	= TV2i NOT MARKS
TM2	= TM2i NOT MARKS
MTT2    = MTT2i NOT MARKS
WN      = WNi NOT MARKS
SDOP	= SDOPi NOT MARKS
PWHT	= PWHTi NOT MARKS
NWHT	= NWHTi NOT MARKS
NLHT	= NLHTi NOT MARKS
PLHT	= PLHTi NOT MARKS
TG	= TGi NOT MARKS
LVP	= LVPi NOT MARKS
LVN	= LVNi NOT MARKS
PSUB	= PSUBi NOT MARKS
HRP	= HRPi NOT MARKS
ULVT	= ULVTi NOT MARKS
BUMP	= BUMPi NOT MARKS
OCOVL	= OCOVLi NOT MARKS
DUPMK1  = DUPMK1i NOT MARKS
ESD1    =  ESD1i NOT MARKS
ALPA    =  ALPAi NOT MARKS
BD_HOLE = HOLES BORDERi
BD_WITHHOLE = BORDERi OR BD_HOLE
BORDER = BORDERi OR (HOLES BORDERi)
SRAM =((DNSRAM OR LRSRAM) OR D2SRAM) OR RFSRAM

AA_all = AA OR AADUM
AAi_all = AAi OR AADUM
GT_all = GT OR GTDUM
GTi_all = GTi OR GTDUM
M1_all = M1 OR M1DUM
M1i_all = M1i OR M1DUM
M2_all = M2 OR M2DUM
M2i_all = M2i OR M2DUM
M3_all = M3 OR M3DUM
M3i_all = M3i OR M3DUM
M4_all = M4 OR M4DUM
M4i_all = M4i OR M4DUM
M5_all = M5 OR M5DUM
M5i_all = M5i OR M5DUM
M6_all = M6 OR M6DUM
M6i_all = M6i OR M6DUM
M7_all = M7 OR M7DUM
M7i_all = M7i OR M7DUM
M8_all = M8 OR M8DUM
M8i_all = M8i OR M8DUM
V1_all = V1 OR V1DUM
V2_all = V2 OR V2DUM
V3_all = V3 OR V3DUM
V4_all = V4 OR V4DUM
V5_all = V5 OR V5DUM
V6_all = V6 OR V6DUM
V7_all = V7 OR V7DUM
TM2_all = TM2 OR TM2DUM
TM2i_all = TM2i OR TM2DUM
MTT2_all = MTT2 OR MTT2DM
MTT2i_all = MTT2i OR MTT2DM
AL_all = ALPA OR ALDUM
ALi_all = ALPAi OR ALDUM

#IFDEF UTM YES
TM = COPY MTT2
#ENDIF

#IFDEF UTM NO
TM = COPY TM2
#ENDIF

GT0 = GTi NOT (SABi OR (RESP1 OR HRPDMY))
PSD_NOT_R = ((PACTi NOT PGATEi) AND NWi) NOT SABi
NSD_NOT_R = ((NACTi NOT NGATEi) NOT NWi) NOT SABi
ACTIVES = (PTAPi OR NTAPi) OR (PSD_NOT_R OR NSD_NOT_R)

CONNECT MD ALPAi 
CONNECT ALPAi MTT2i BY PA
CONNECT ALPAi TM2i BY PA
#IFDEF TOPMETAL 9
UTV = COPY V7
UTM = COPY M8
UTMR = COPY M8R
CONNECT MTT2i M8i BY TV2i
CONNECT TM2i M8i BY TV2i
CONNECT M8i M7i BY V7i
CONNECT M7i M6i BY V6i
CONNECT M6i M5i BY V5i
CONNECT M5i M4i BY V4i
CONNECT M4i M3i BY V3i

#ENDIF
#IFDEF TOPMETAL 8
UTV = COPY V6
UTM = COPY M7
UTMR = COPY M7R
CONNECT MTT2i M7i BY TV2i
CONNECT TM2i M7i BY TV2i
CONNECT M7i M6i BY V6i
CONNECT M6i M5i BY V5i
CONNECT M5i M4i BY V4i
CONNECT M4i M3i BY V3i
#ENDIF
#IFDEF TOPMETAL 7
UTV = COPY V5
UTM = COPY M6
UTMR = COPY M6R
CONNECT MTT2i M6i BY TV2i
CONNECT TM2i M6i BY TV2i
CONNECT M6i M5i BY V5i
CONNECT M5i M4i BY V4i
CONNECT M4i M3i BY V3i
#ENDIF
#IFDEF TOPMETAL 6
UTV = COPY V4
UTM = COPY M5
UTMR = COPY M5R
CONNECT MTT2i M5i BY TV2i
CONNECT TM2i M5i BY TV2i
CONNECT M5i M4i BY V4i
CONNECT M4i M3i BY V3i
#ENDIF
#IFDEF TOPMETAL 5
UTV = COPY V3
UTM = COPY M4
UTMR = COPY M4R
CONNECT MTT2i M4i BY TV2i
CONNECT TM2i M4i BY TV2i
CONNECT M4i M3i BY V3i
#ENDIF
#IFDEF TOPMETAL 4
UTV = COPY V2
UTM = COPY M3
UTMR = COPY M3R
CONNECT MTT2i M3i BY TV2i
CONNECT TM2i M3i BY TV2i
#ENDIF
CONNECT M3i M2i BY V2i
CONNECT M2i M1i BY V1i
CONNECT CT M1
CONNECT M1i GT0 NTAPi PTAPi PSD_NOT_R NSD_NOT_R ACTIVES BY CTi
CONNECT NTAPi ACTIVES
CONNECT PTAPi ACTIVES
CONNECT PSD_NOT_R ACTIVES
CONNECT NSD_NOT_R ACTIVES
CONNECT NTAPi NWi
CONNECT NW NWi
CONNECT LVNW NWi
CONNECT HMVNW NWi
CONNECT NWi DNWi
CONNECT PTAPi PW

#IFDEF TOPMETAL 9
LABEL ORDER MTT2i TM2i M8i M7i M6i M5i M4i M3i M2i M1i NTAPi PTAPi NSD_NOT_R PSD_NOT_R GT0 NWi
#ENDIF
#IFDEF TOPMETAL 8
LABEL ORDER MTT2i TM2i M7i M6i M5i M4i M3i M2i M1i NTAPi PTAPi NSD_NOT_R PSD_NOT_R GT0 NWi
#ENDIF
#IFDEF TOPMETAL 7
LABEL ORDER MTT2i TM2i M6i M5i M4i M3i M2i M1i NTAPi PTAPi NSD_NOT_R PSD_NOT_R GT0 NWi
#ENDIF
#IFDEF TOPMETAL 6
LABEL ORDER MTT2i TM2i M5i M4i M3i M2i M1i NTAPi PTAPi NSD_NOT_R PSD_NOT_R GT0 NWi
#ENDIF
#IFDEF TOPMETAL 5
LABEL ORDER MTT2i TM2i M4i M3i M2i M1i NTAPi PTAPi NSD_NOT_R PSD_NOT_R GT0 NWi
#ENDIF
#IFDEF TOPMETAL 4
LABEL ORDER MTT2i TM2i M3i M2i M1i NTAPi PTAPi NSD_NOT_R PSD_NOT_R GT0 NWi
#ENDIF

#IFDEF TOPMETAL 9
#DEFINE M8_CHECK YES
#DEFINE M7_CHECK YES
#DEFINE M6_CHECK YES
#DEFINE M5_CHECK YES
#DEFINE M4_CHECK YES
#DEFINE V7_CHECK YES
#DEFINE V6_CHECK YES
#DEFINE V5_CHECK YES
#DEFINE V4_CHECK YES
#DEFINE V3_CHECK YES
#ENDIF
#IFDEF TOPMETAL 8
#DEFINE M8_CHECK NO
#DEFINE M7_CHECK YES
#DEFINE M6_CHECK YES
#DEFINE M5_CHECK YES
#DEFINE M4_CHECK YES
#DEFINE V7_CHECK NO
#DEFINE V6_CHECK YES
#DEFINE V5_CHECK YES
#DEFINE V4_CHECK YES
#DEFINE V3_CHECK YES
#ENDIF
#IFDEF TOPMETAL 7
#DEFINE M8_CHECK NO
#DEFINE M7_CHECK NO
#DEFINE M6_CHECK YES
#DEFINE M5_CHECK YES
#DEFINE M4_CHECK YES
#DEFINE V7_CHECK NO
#DEFINE V6_CHECK NO
#DEFINE V5_CHECK YES
#DEFINE V4_CHECK YES
#DEFINE V3_CHECK YES
#ENDIF
#IFDEF TOPMETAL 6
#DEFINE M8_CHECK NO
#DEFINE M7_CHECK NO
#DEFINE M6_CHECK NO
#DEFINE M5_CHECK YES
#DEFINE M4_CHECK YES
#DEFINE V7_CHECK NO
#DEFINE V6_CHECK NO
#DEFINE V5_CHECK NO
#DEFINE V4_CHECK YES
#DEFINE V3_CHECK YES
#ENDIF
#IFDEF TOPMETAL 5
#DEFINE M8_CHECK NO
#DEFINE M7_CHECK NO
#DEFINE M6_CHECK NO
#DEFINE M5_CHECK NO
#DEFINE M4_CHECK YES
#DEFINE V7_CHECK NO
#DEFINE V6_CHECK NO
#DEFINE V5_CHECK NO
#DEFINE V4_CHECK NO
#DEFINE V3_CHECK YES
#ENDIF
#IFDEF TOPMETAL 4
#DEFINE M8_CHECK NO
#DEFINE M7_CHECK NO
#DEFINE M6_CHECK NO
#DEFINE M5_CHECK NO
#DEFINE M4_CHECK NO
#DEFINE V7_CHECK NO
#DEFINE V6_CHECK NO
#DEFINE V5_CHECK NO
#DEFINE V4_CHECK NO
#DEFINE V3_CHECK NO
#ENDIF

/*
VIRTUAL CONNECT NAME "?VDD?" "?VCC?" "?VSS?" "?GND?"
VIRTUAL CONNECT COLON YES
*/


//******************************************
//    LAYER DERIVATIONS AND OPERATIONS
//******************************************


//==================
// For Connectivity
//==================

PACTi   = SPi AND AAi
NACTi   = SNi AND AAi

PTAPi   = PACTi NOT NWi
NTAPi   = NACTi AND NWi

PGATEi  = PACTi AND GTi
NGATEi  = NACTi AND GTi

PSDii   = (PACTi NOT PGATEi) TOUCH PGATEi
NSDii   = (NACTi NOT NGATEi) TOUCH NGATEi
PSDi	= PACTi NOT PGATEi
NSDi    = NACTi NOT NGATEi

PMOSii  = PGATEi OR PSDii
NMOSii  = NGATEi OR NSDii
PMOSi   = PGATEi OR PSDi
NMOSi   = NGATEi OR NSDi


//==================
// Transistor Def
//==================

DRC:1   = EXTENT DRAWN ORIGINAL
BULK    = SIZE DRC:1 BY 1.0

PW      = BULK NOT (NWi OR PSUBi)

PACT    = SP AND AA
NACT    = SN AND AA
ACT	= PACT OR NACT

PGT     = SP AND GT
NGT     = SN AND GT

PTAP    = PACT NOT NW
NTAP    = NACT AND NW
TAP     = PTAP OR NTAP

GATE0 = (GT INTERACT CT) AND AA   
AA1 = (AA INTERACT GATE0) NOT GATE0 
AA2 = AA1 TOUCH GATE0 > 1  
AA3 = AA1 INTERACT CT     
AA4 = AA2 OR AA3   
GATE1 = GATE0 TOUCH AA4 == 2  
GATE2 = GATE0 AND LDBK  
Real_GATE = GATE1 OR GATE2
Real_NGATE = Real_GATE AND SN
Real_PGATE = Real_GATE AND SP

GATE    = AA AND GT
PGATE   = GATE AND SP 
NGATE   = SN AND GATE
//GATE    = (AA AND GT) NOT PLDMK
PSD     = (PACT NOT PGATE) TOUCH PGATE
NSD     = (NACT NOT NGATE) TOUCH NGATE
Real_PSD = (PACT NOT Real_PGATE) TOUCH Real_PGATE
Real_NSD = (NACT NOT Real_NGATE) TOUCH Real_NGATE

PMOS    = PGATE OR PSD
NMOS    = NGATE OR NSD
MOS     = PMOS OR NMOS
MOS12   = MOS OUTSIDE (DG OR TG)
MOS18   = MOS INTERACT DG
MOS25   = MOS INTERACT TG

Real_PMOS = Real_PGATE OR Real_PSD
Real_NMOS = Real_NGATE OR Real_NSD
Real_MOS = Real_PMOS OR Real_NMOS
Real_MOS12 = Real_MOS OUTSIDE (DG OR TG)
Real_MOS18 = Real_MOS INTERACT DG
Real_MOS25 = Real_MOS INTERACT TG

PBAA    = AA AND PSUB
PBGT    = GT INTERACT PSUB

NAAEIGT = NACT IN EDGE GT
PAAEIGT = PACT IN EDGE GT
NGTEIAA = GT IN EDGE NACT
PGTEIAA = GT IN EDGE PACT
GTEIAA  = GT IN EDGE AA

INTERGT = GT NOT GATE
//GT_end  = CONVEX EDGE GT ANGLE1 <180 ANGLE2 <180 WITH LENGTH < 0.120
//GT_nonend = GT NOT COIN EDGE GT_end_head1
//GT_end = ENC AA GT < 0.12 OPPOSITE REGION
//GT_end_head = GT_end COIN EDGE ((GT INTERACT GATE) NOT TOUCH EDGE GATE)
//GT_end_head1 =(GT INTERACT GATE) NOT TOUCH EDGE GATE

GT_end_head1 = CONVEX EDGE GT  ANGLE1 ==90  LENGTH1 >=0.08 ANGLE2 ==90  LENGTH2 >=0.08 WITH LENGTH <=0.11
GT_end_head =  ENC (AA ENCLOSE GATE) [GT_end_head1] < 0.12 OPPOSITE
GT_nonend = GT NOT COIN EDGE GT_end_head1
FTGT    = GT NOT INTERACT CTi
FTAA	= AA NOT INTERACT CTi

//==================
//  Resistor Def
//==================

AAR     = AA AND RESAA
GTR     = GT AND RESP1
AASABR  = AAR INTERACT SAB
GTSABR  = GTR INTERACT SAB
NWR     = NW AND RESNW
//NWR_AA  = AA AND RESNW
NWR_AA  = AA AND NWR
NWR_CT  = CT AND NWR_AA
NWR_SN  = SN INTERACT NWR
NWR_SP  = SP INTERACT NWR

//AAR_body = (AA INSIDE RESAA) AND SAB
AAR_body = AAR AND SAB

//=============
//   HRP Def
//=============

HRPR    = GT AND HRPDMY
HR_GT    = HRPR AND HRPDMY
SAB_GT   = HRPR AND SAB

//==============
//  Well Def
//==============

HVNW = NW NOT OUTSIDE TG
MVNW = NW NOT OUTSIDE DG
HMVNW = HVNW OR MVNW
LVNW = NW NOT HMVNW


//=====================
// CT / Wide Metal Def
//=====================

ACT_CT   = CT AND AA
INTERCT  = CT AND INTERGT
CTAAM1   = CT INTERACT (AA AND M1)
CTGTM1   = CT INTERACT (GT AND M1)
CTM1     = CTAAM1 OR CTGTM1

TM2SLOT1 = HOLES TM2 INNER EMPTY
TM2_SL  = (TM2 INTERACT TM2SLOT1) OR TM2SLOT1

GROUP density_rule ?_density?
//DRC UNSELECT CHECK density_rule


//================================================
// CORN / Chamfer area size at the chip corner Def
//================================================

CORN = INT DRC:1 < 74 ABUT REGION

EXCLU_1 {
@ report DRC alert if EXCLU is used
COPY EXCLU  
}
//===========================
//  AA - Active Area DRC
//===========================

GROUP GAA AA_?

AA_1 {
@ AA minimum width(The INST connected area apply SRAMdesign rule) is 0.06
 X= INT AA_all < 0.06 ABUT<90 SINGULAR REGION
 X OUTSIDE INST
}

SRAA_1sa {
@ AA inner vertex to inner vertex distance is 0.046
  X= EXT AA  < 0.046 ABUT<90 OPPOSITE REGION NOTCH 
  X NOT OUT INST
}

AA_1a {
@ AA minimum width of NMOS/PMOS for 0.9/1.1/1.2V transistor is 0.12
 X= INT (Real_MOS12 IN EDGE GT) < 0.12 ABUT<90 REGION
 X OUTSIDE INST
}
/*
AA_1R {
@ AA minimum width of NMOS/PMOS for 1.2V transistor is 0.12
  INT MOS12 < 0.12 ABUT<90 SINGULAR REGION
}
*/
AA_2 {
@ AA (enclosure by TG or DG) minimum width of NMOS/PMOS for 1.8/2.5v transistor is 0.32
  INT ((Real_MOS AND (DG OR TG)) IN EDGE GT) < 0.32 ABUT<90 REGION
}
/*
AA_3 {
@ AA minimum width for interconnect is 0.08
  INT AA < 0.08 ABUT<90 SINGULAR REGION
}
*/
AA_4a {
@ AA minimum space  is 0.08
 X= EXT AA_all < 0.08  SINGULAR REGION 
 X OUTSIDE INST
}
SRAA_4a {
@ AA min space is 0.065
X=EXT AA  < 0.065 ABUT<90 SINGULAR REGION 
X NOT OUTSIDE INST
}
GATE14 = GATE WITH EDGE (LENGTH (GT IN EDGE AA) >= 0.14)
EDGE1 = AA TOUCH EDGE GATE
EDGE2 = (AA ENCLOSE GATE14) TOUCH EDGE GATE
/*AA_4b {
@ AA for transistor minimum space if one of AA width(W2) >= 0.14um, and AA to AA overlap(run length)
@ which along S/D direction Y1>=0.14, S >= 0.1
  AA_INGT=AA INTERACT GATE
  AA12 = AA_INGT WITH WIDTH >= 0.14
  AA_TCHGTX1 =AA_INGT TOUCH EDGE GATE
  AA_TCHGTX2 =AA12 TOUCH EDGE GATE 
  AA_TCHGTY1= EXPAND EDGE AA_TCHGTX1 OUTSIDE BY 0.001
  AA_TCHGTY2= EXPAND EDGE AA_TCHGTX2 OUTSIDE BY 0.001
  AA_edge1 = LENGTH AA_INGT > 0
  AA_edge11 = EXPAND EDGE AA_edge1 OUTSIDE BY 0.001
  AA_edgeZ1 = AA_edge11 NOT AA_TCHGTY1
  AA_edgeZ2 = AA_edge11 NOT AA_TCHGTY2
  AAspace = EXT AA_edgeZ1 AA_edgeZ2 < 0.098 OPPOSITE REGION
 ((AAspace OUTSIDE INST) WITH EDGE (LENGTH (AAspace NOT INSIDE INST) >= 0.14)) NOT AA_INGT
}*/
SRAA_4c {
@ AA with gate minimum space along gate poly direction is 0.085, if one of AA width (W3)>=0.14um, and AA to AA overlap (run length) Y2 >=0.14um
AA_INGT=AA INTERACT GATE
AA12 = AA_INGT WITH WIDTH >= 0.14
AA_TCHGTX1 =AA_INGT TOUCH EDGE GATE
AA_TCHGTX2 =AA12 TOUCH EDGE GATE
AAspace = EXT  AA_TCHGTX1  AA_TCHGTX2 <0.085 OPPOSITE REGION
(AAspace NOT OUTSIDE INST) WITH EDGE (LENGTH (AAspace NOT OUTSIDE INST) >= 0.14)
}
AA_4b_4c {
@ The space between two AA with gate along source/drain direction is >=0.1 , if one of AA width (W2) >= 0.14m, and AA to AA run length Y1>=0.14um
@ The space between two AA with gate along gate poly direction is >=0.1, if one of AA width (W3)>=0.14m, and AA to AA run length Y2 >=0.14um
  AA_INGT=AA INTERACT GATE
  AA12 = AA_INGT WITH WIDTH >= 0.14
  AAspace = EXT AA_INGT AA12 < 0.1 OPPOSITE REGION
  AAspace_waive = AAspace COIN EDGE (AA_INGT TOUCH EDGE GATE)
  WAIVE = (AAspace WITH EDGE AAspace_waive) NOT OUTSIDE INST
  (AAspace NOT WAIVE) WITH EDGE (LENGTH AAspace >= 0.14)
}
AA_4d{
@ Space between two AAs inside (DG OR TG) is 0.13
EXT (AA INSIDE (DG OR TG))<0.13 ABUT<90 SINGULAR REGION
}
AA_4e_R_ON {
@ Space between (AA or AADUM) is <= 10
@ DRC check maximum STI width.
@ DRC dont check: chip corner DUMBA region as defined in rule CORN.2 if seal ring is added by SMIC.
  CORN_DUMBA = DUMBA INTERACT CORN
  X = DRC:1 NOT CORN_DUMBA
  AA_all = AAi OR AADUM
  (WITH WIDTH (X NOT AA_all) > 10) NOT MARKS
}
AA_9 {
@ AA minimum area except floating AA is 0.02
 X=AREA (AA NOT FTAA)  < 0.02
 X OUT INST
}
SRAA_9 {
@ AA minimum area is 0.015
 X= AREA AA < 0.015  
 X NOT OUTSIDE INST
}
AA_9a {
@ AA minimum area at floating AA is 0.015
 X = AREA (AA_all NOT INTERACT CTi) < 0.015
 X OUTSIDE  INST
}
/*
AA_9b {
@ AA area when AA all of edge length < 0.21 m is >= 0.055um.
@ This rule is not applied for (DNSRAM OR LRSRAM) OR D2SRAM) OR RFSRAM) covered region.
  AA_ignore = AA_all WITH EDGE (length AA_all >= 0.21)
  (AREA (AA_all NOT AA_ignore) < 0.055) NOT SRAM
}
*/
AA_10_R_ON {
@ DG, TG or core transistors mixed in the same AA are prohibited
  MOS CUT DG
  MOS CUT TG
  (MOS INTERACT DG) INTERACT TG
}
AA_11 {
@ It is not allowed to draw AA straddle on NW, excluding LDMOS area.waive the AA interact with RESNW
  ((AA_all CUT NW) NOT LDBK) NOT (AA_all INTERACT RESNW)
}
AA_12_R_ON {
@ AA channel width of NMOS/PMOS for 0.9/1.1/1.2V transistor is <=50. Waive transistor inside VARMOS
  X = LENGTH (GT IN EDGE ((MOS NOT (DG OR TG)) NOT VARMOS)) > 50
  EXPAND EDGE X INSIDE BY 0.01
}
AA_13 {
@ AA minimum enclosed area(um2) is 0.0395um2.
  AAHOLE = HOLES AA_all INNER
  AREA (AAHOLE NOT AA_all) < 0.0395
}
AA_13a_R_OFF {
@ Enclosed area when AA all of inner edge length < 0.21 m is >= 0.077um2.
@ This rule is not applied for (DNSRAM OR LRSRAM) OR D2SRAM) OR RFSRAM) covered region.
  AA_ignore = AA_all WITH EDGE (LENGTH (AA_all TOUCH EDGE (HOLES AA_all INNER)) >= 0.21)
  X = (HOLES (AA_all NOT AA_ignore) INNER) NOT AA_all
  (AREA X < 0.077) NOT SRAM 
}
AA_14_a_density {
@ For area excluding (DG or TG), Minimum AA density (including dummy)is 20%. Density check window size: 200um*200um with step size: 100um.
@ Waive RESNW, LOGO, seal ring(MARKS) areas
@ DRC check with the said window size and rule number and highlight as X. Y = X not (DG or TG), Z= (Y area)/(100*100)  
@ If Z > 25%, highlight Y for AA density inside of Y that cannot meet of rule value requirement.
  DENSITY_MARK = ((BORDER NOT RESNW) NOT LOGO) NOT MARKS
  CHECK_LAYER = (((AAi OR AADUM) NOT RESNW) NOT LOGO) NOT MARKS
  CHECK_REGION = COPY DENSITY_MARK
  X = DENSITY CHECK_LAYER CHECK_REGION [area(CHECK_LAYER)/area(CHECK_REGION)] < 0.20 WINDOW 200 STEP 100 BACKUP RDB density_report_AA_14_a1.db
  Y = X NOT (DG OR TG)
  Z= COPY Y
  M = DENSITY Y  [area(Y)/(100*100)]>0.25  INSIDE OF LAYER Z  RDB density_report_AA_14_a2.db
  N = COPY M
  W =DENSITY CHECK_LAYER M [area(CHECK_LAYER)/area(M)] < 0.20 INSIDE OF LAYER N BY POLYGON PRINT density_report_AA_14_a.log RDB density_report_AA_14_a.db
  (( W NOT MARKS ) NOT RESNW) NOT LOGO
}
AA_14_b_density {
@ For area excluding (DG or TG), Maximum AA density (including dummy)is 82%. Density check window size: 200um*200um with step size: 100um.
@ Waive RESNW, LOGO, seal ring(MARKS) areas
@ DRC check with the said window size and rule number and highlight as X. Y = X not (DG or TG), Z= (Y area)/(100*100)  
@ If Z > 25%, highlight Y for AA density inside of Y that cannot meet of rule value requirement.
  DENSITY_MARK = ((BORDER NOT RESNW) NOT LOGO) NOT MARKS
  CHECK_LAYER = (((AAi OR AADUM) NOT RESNW) NOT LOGO) NOT MARKS
  CHECK_REGION = COPY DENSITY_MARK
  X = DENSITY CHECK_LAYER CHECK_REGION [area(CHECK_LAYER)/area(CHECK_REGION)] > 0.82 WINDOW 200 STEP 100 BACKUP RDB density_report_AA_14_b1.db
  Y = X NOT (DG OR TG)
  Z= COPY Y
  M = DENSITY Y  [area(Y)/(100*100)]>0.25  INSIDE OF LAYER Z  RDB density_report_AA_14_b2.db
  N = COPY M
  W =DENSITY CHECK_LAYER M [area(CHECK_LAYER)/area(M)]> 0.82  INSIDE OF LAYER N BY POLYGON PRINT density_report_AA_14_b.log RDB density_report_AA_14_b.db
  (( W NOT MARKS ) NOT RESNW) NOT LOGO
}
AA_14a_a_density {
@ For area in of (DG or TG), Minimum AA density (including dummy) is 20%. Density check window size: 200um*200um with step size 100um
@ DRC check with the said window size and rule number and highlight as X.  Y = X and (DG or TG), Z= (Y area)/(100*100)  If Z > 25%,
@ highlight Y for AA density inside of Y outside of rule value requirement
DENSITY_MARK = BORDER NOT MARKS
CHECK_LAYER = (AAi OR AADUM) NOT MARKS
CHECK_REGION = COPY DENSITY_MARK
X = DENSITY CHECK_LAYER CHECK_REGION [area(CHECK_LAYER)/area(CHECK_REGION)] < 0.20 WINDOW 200 STEP 100 BACKUP RDB density_report_AA_14a_a1.db
Y = X AND (DG OR TG)
Z= COPY Y 
M = DENSITY Y  [area(Y)/(100*100)]>0.25  INSIDE OF LAYER Z  RDB density_report_AA_14a_a2.db
N = COPY M
W =DENSITY CHECK_LAYER M [area(CHECK_LAYER)/area(M)] < 0.20 INSIDE OF LAYER N BY POLYGON PRINT density_report_AA_14a_a.log RDB density_report_AA_14a_a.db
W NOT MARKS
}
AA_14a_b_density {
@ For area in of (DG or TG), Maximum AA density (including dummy) is 90%. Density check window size: 200um*200um, step size: 100um.
@ DRC check with the said window size and rule number and highlight as X.  Y = X and (DG or TG)  Highlight AA density inside of Y outside of rule value requires
DENSITY_MARK = BORDER NOT MARKS
CHECK_LAYER = (AAi OR AADUM) NOT MARKS
CHECK_REGION = COPY DENSITY_MARK
X = DENSITY CHECK_LAYER CHECK_REGION [area(CHECK_LAYER)/area(CHECK_REGION)] > 0.9 WINDOW 200 STEP 100 BACKUP RDB density_report_AA_14a_b1.db 
Y = X AND (DG OR TG)
Z= COPY Y
M = DENSITY Y  [area(Y)/(100*100)]>0.25  INSIDE OF LAYER Z  RDB density_report_AA_14a_b2.db
N = COPY M
W = DENSITY CHECK_LAYER M [area(CHECK_LAYER)/area(M)] >0.9 INSIDE OF LAYER N BY POLYGON PRINT density_report_AA_14a_b.log RDB density_report_AA_14a_b.db
W NOT MARKS
}

AA_15a_R_density_OFF {
@ AA density overlap by DUMBA min. is 20%. Density check window size: 200um*200um, step size: 100um
  DENSITY_MARK = DUMBA NOT MARKS
  CHECK_LAYER = (AAi OR AADUM) NOT MARKS
  CHECK_REGION = COPY DENSITY_MARK
  DENSITY CHECK_LAYER CHECK_REGION [area(CHECK_LAYER)/area(CHECK_REGION)] < 0.20 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER DENSITY_MARK PRINT density_report_AA_15a.log RDB density_report_AA15a.db
}
AA_15b_R_density_OFF {
@ AA density overlap by DUMBA max. is 80%. Density check window size: 200um*200um, step size: 100um
  DENSITY_MARK = DUMBA NOT MARKS
  CHECK_LAYER = (AAi OR AADUM) NOT MARKS
  CHECK_REGION = COPY DENSITY_MARK
  DENSITY CHECK_LAYER CHECK_REGION [area(CHECK_LAYER)/area(CHECK_REGION)] > 0.80 WINDOW 200 STEP 100 BACKUP INSIDE OF LAYER DENSITY_MARK PRINT density_report_AA_15b.log RDB density_report_AA15b.db
}
AA_16 {
@ Bent 45 degree AA width is >= 0.16
X = ANGLE AA_all ==45 
INT X <0.16  ABUT <90 REGION 
}
AA_17 {
@ 45 degree AA space to parallel AA is >=0.16
X = ANGLE AA_all ==45
EXT X AA_all <0.16 REGION  PARA ONLY
}

AA_18{
@ AA space for of U shape (notch) is >=0.15. Waive for extrusion E <= 0.03  or U shape bottom AA width W0 > 0.08um
X =CONVEX EDGE AA ANGLE1>269.9<271.1 ANGLE2>269.9<271.1 WITH LENGTH<0.15
Y= CONVEX EDGE AA ANGLE1>89.9<90.1 ANGLE2>269.9<271.1 WITH LENGTH>0.03
Z= EXT X Y <0.001  ABUT == 90 INTERSECTING ONLY REGION
M = INT X AA <=0.08 OPPOSITE REGION 
(((EXPAND EDGE X OUTSIDE BY 0.001) INTERACT Z == 2) INTERACT M) OUTSIDE INST
}
AA_19 {
@ AA must be fully covered by (SN OR SP).
@ Waive the violations in AA INTERACT RESNW,LOGO,OCOVL region
(AA NOT INSIDE (SN OR SP)) NOT (((AA INTERACT RESNW) OR LOGO) OR OCOVL)
}
/*SRAA_101 {
@ AA min width with space on both side <0.15um is 0.046
  AAspace = EXT (AA AND INST) < 0.150 ABUT <90 OPPOSITE REGION
  AAspace_edge1 = AA COIN EDGE AAspace
  AAspace_edge2 = AA NOT COIN EDGE AAspace_edge1
  INT AAspace_edge2 < 0.046 ABUT <90 REGION
}*/
AA_20 {
@ Maximum length of (AA NOT pickup AA) when AA width < 0.12um and butted with pickup AA is 0.4um.
  X = (MOS TOUCH TAP) WITH WIDTH < 0.12
  LENGTH (X TOUCH TAP) > 0.4
}
AA_21 {
@ Maximum AA length between two contacts, or between one contact and AA line end when AA width < 0.12 m is <= 60um.
  AA_CHECK = (WITH WIDTH AA < 0.12) ENCLOSE CT > 0
  X = SIZE CT BY 30 INSIDE OF AA_CHECK STEP 0.02
  AA_CHECK INTERACT X > 1

  Y = SIZE X BY 30 INSIDE OF AA_CHECK STEP 0.02
  AA_CHECK NOT Y
}
AA_22_a_density {
@ AA density over the whole chip is >= 25%.
  DENSITY_MARK = BORDER NOT MARKS
  CHECK_LAYER = (AAi OR AADUM) NOT MARKS
  CHECK_REGION = COPY DENSITY_MARK
  X = DENSITY CHECK_LAYER CHECK_REGION [area(CHECK_LAYER)/area(CHECK_REGION)] < 0.25 PRINT density_report_AA_22_a.log RDB density_report_AA_22_a.db
  X NOT MARKS
}
AA_22_b_density {
@ AA density over the whole chip is <= 75%.
  DENSITY_MARK = BORDER NOT MARKS
  CHECK_LAYER = (AAi OR AADUM) NOT MARKS
  CHECK_REGION = COPY DENSITY_MARK
  X = DENSITY CHECK_LAYER CHECK_REGION [area(CHECK_LAYER)/area(CHECK_REGION)] > 0.75 PRINT density_report_AA_22_b.log RDB density_report_AA_22_b.db
  X NOT MARKS
}
AA_23_R_OFF {
@ For any geometry on AA, NW, GT, M1, or Mn (n=2~8), an edge of length < 1.0xWmin cannot have any adjacent edge with length < 1.0xWmin.
  CONVEX EDGE AA ANGLE1 > 0 LENGTH1 < 0.06 ANGLE2 > 0 WITH LENGTH < 0.06
  CONVEX EDGE GT ANGLE1 > 0 LENGTH1 < 0.04 ANGLE2 > 0 WITH LENGTH < 0.04
  CONVEX EDGE NW ANGLE1 > 0 LENGTH1 < 0.33 ANGLE2 > 0 WITH LENGTH < 0.33
  CONVEX EDGE M1 ANGLE1 > 0 LENGTH1 < 0.07 ANGLE2 > 0 WITH LENGTH < 0.07
  CONVEX EDGE M2 ANGLE1 > 0 LENGTH1 < 0.07 ANGLE2 > 0 WITH LENGTH < 0.07
  CONVEX EDGE M3 ANGLE1 > 0 LENGTH1 < 0.07 ANGLE2 > 0 WITH LENGTH < 0.07
  CONVEX EDGE M4 ANGLE1 > 0 LENGTH1 < 0.07 ANGLE2 > 0 WITH LENGTH < 0.07
  CONVEX EDGE M5 ANGLE1 > 0 LENGTH1 < 0.07 ANGLE2 > 0 WITH LENGTH < 0.07
  CONVEX EDGE M6 ANGLE1 > 0 LENGTH1 < 0.07 ANGLE2 > 0 WITH LENGTH < 0.07
  CONVEX EDGE M7 ANGLE1 > 0 LENGTH1 < 0.07 ANGLE2 > 0 WITH LENGTH < 0.07
  CONVEX EDGE M8 ANGLE1 > 0 LENGTH1 < 0.07 ANGLE2 > 0 WITH LENGTH < 0.07
}


//=============================
//   RESAA - AA Resistor DRC
//=============================

GROUP GRESAA RESAA_?

//Skip RESAA_1 : AA resistor must within RESAA layer
RESAA_2 {
@ AA resistor minimum width is 0.40; AA resistor mean AA with RESAA overlap SAB.
  INT (AAR INSIDE EDGE SAB) < 0.40 ABUT<90 REGION
}
/*
RESAA_2R {
@ AA resistor minimum width is 0.40
  INT (AAR IN EDGE SAB) < 0.40 ABUT<90 REGION
}
*/
RESAA_3 {
@ AA resistor minimum length is 0.40
  INT (SAB COIN EDGE AAR) < 0.40 ABUT<90 REGION
}
/*
RESAA_3R {
@ AA resistor minimum length is 0.80
  INT (SAB IN EDGE AAR) < 0.80 ABUT<90 REGION
}
*/
RESAA_4 {
@ AA resistor must be orthogonal
  ANGLE AAR >0 <90
}
RESAA_5 {
@ CT to SAB minimum space is 0.180
  EXT (CT INSIDE (AA INTERACT AAR)) SAB < 0.180 ABUT<90 SINGULAR REGION
}
RESAA_6 {
@ Extension of RESAA outside of AA minimum distance is 0.15
  ENC AA RESAA < 0.15 ABUT<90 SINGULAR REGION
}
RESAA_7 {
@ The minimum separation between resistors with un-related implant region is 0.16.
@ Un-related implant region: NW, LVT, HVT, SN, SP, ESD1. These regions don?t interact with resistors.
  EXT AAR (SN NOT INTERACT AAR) < 0.16 ABUT<90 SINGULAR REGION 
  EXT AAR (SP NOT INTERACT AAR) < 0.16 ABUT<90 SINGULAR REGION
  EXT AAR (ESD1 NOT INTERACT AAR) < 0.16 ABUT<90 SINGULAR REGION
  EXT AAR (NW NOT INTERACT AAR) < 0.16 ABUT<90 SINGULAR REGION
  EXT AAR (LVT NOT INTERACT AAR) < 0.16 ABUT<90 SINGULAR REGION
  EXT AAR (HVT NOT INTERACT AAR) < 0.16 ABUT<90 SINGULAR REGION
}
/*
RESAA_8 {
@ Dog-bone design at the end of AA resistor for contact pick-up is not suggested.
  X = CONVEX EDGE AAR == 1
  EXPAND EDGE X INSIDE BY 0.01
}
*/
RESAA_9 {
@ For AA resistor, make sure the AA be covered by SAB and implanted by either SN or SP
  (AA AND RESAA) NOT SAB
  (AAR NOT IN SP) NOT IN SN
}
RESAA_10 {
@ AA SAB resistor with SP must lay on NW
  (AAR  AND SP) NOT NW
}
/*
RESAA_11 {
@ Minimum AA extension of SAB is 0.40 
  ENC SAB AAR < 0.40 ABUT<90 SINGULAR REGION
}
*/
RESAA_12 {
@ Minimum Space RESAA to non-related AA is 0.08
  EXT RESAA AA < 0.08 ABUT>0<90 SINGULAR REGION
}
RESAA_13 {
@ Minimum Space RESAA to non-related Poly is 0.08
  EXT RESAA GT < 0.08 ABUT>0<90 SINGULAR REGION
}
RESAA_14{
@ RESAA and SAB on AA should have coincident edge
X =SAB  INSIDE EDGE AA 
Y = RESAA INSIDE EDGE AA
Y NOT COIN EDGE X    
RESAA ENCLOSE AA
}

  
//===========================
//  AAC - AA Density Rules
//===========================

GROUP GAAC AA_C_?

HDA = DENSITY (AAi OR AADUM) > 0.85 WINDOW 250 STEP 25
LDA = DENSITY (AAi OR AADUM) < 0.10 WINDOW 25 STEP 25
MDA = (DENSITY (AAi OR AADUM) < 0.20 WINDOW 25 STEP 25) NOT LDA

AA_C_1 {
@ Maximum containing rectangle of HDA is 250*250
  (HDA WITH WIDTH > 250) NOT MARKS
}
/*
AAC_2 {
@ Minimum space between HDAs is 80
  EXT HDA < 80 ABUT<90 SINGULAR REGION
}
*/
AA_C_3 {
@ Maximum containing rectangle of LDA is 50*50
  (LDA WITH WIDTH > 50) NOT MARKS
}
AA_C_4 {
@ Maximum containing rectangle of MDA is 125*125
  (MDA WITH WIDTH > 125) NOT MARKS
}
AA_C_5_R_OFF {
@ Minimum space between real gate and minimum 50*50um LDA is 20
@ Waive if the gate channel length >= 0.06um
  X = LDA WITH WIDTH >= 50
  Y = SIZE X BY 20
  Z =LENGTH ( AA COIN EDGE Real_GATE)<0.06  
  ((Real_GATE WITH EDGE Z)  NOT X) AND Y
}


//===========================
//  AA silicide resistor DRC
//===========================

GROUP GDIFRES DIFRES_?

AAD =AA AND DIFRES

DIFRES_1{
@AA Silicide resistor minimum width is 0.2
 INT AAD <0.2  ABUT<90  REGION
}
DIFRES_2{
@DIFRES can not overlap with RESAA
DIFRES AND RESAA
}
DIFRES_3{
@AA Silicide resistor minimum square number is 1
  X = DIFRES INTERACT AA
  Y = AA AND DIFRES
  L = LENGTH Y >0
  L1 = EXPAND EDGE L OUTSIDE BY 0.001 
  W = INSIDE EDGE X AA
  W1 =  EXPAND EDGE W OUTSIDE BY 0.001
  L_RE =L1 NOT W1
  L_EDGE = L_RE COIN EDGE Y 
  DFM PROPERTY Y L_EDGE W OVERLAP ABUT ALSO MULTI [WIDTH = LENGTH(W)] >0 [SQUARES = LENGTH(L_EDGE)/LENGTH(W)] < 1
}
DIFRES_4{
@AA Silicide resistor must be orthogonal
ANGLE AAD >0 <90
}
DIFRES_5{
@CT to DIFRES space fix is 0.01
 //(SIZE (CT INSIDE (AA INTERACT AAD)) BY 0.01) NOT TOUCH  DIFRES
 X1 = EXT CT DIFRES <= 0.07 ABUT<90 REGION OPPOSITE 
 X2 = EXT CT DIFRES == 0.01 ABUT<90 REGION OPPOSITE
 (X1 NOT (X2 NOT (X2 ENCLOSE CT))) OR (CT INTERACT DIFRES)
}
DIFRES_6{
@Extension of DIFRES outside of AA minimum distance is 0
 X =AAD TOUCH (DIFRES NOT AAD) >1
 Y = DIFRES COIN EDGE AA
 Z =EXPAND EDGE Y INSIDE BY 0.001 
 DIFRES NOT INTERACT (X OR (DIFRES INTERACT Z))
}
DIFRES_7{
@The minimum separation between AA resistors and un-related implant region is 0.16.
@ Un-related implant region: NW, LVT, HVT, SN, SP, ESD1. These regions don?t interact with resistors.
  EXT AAD (SN NOT INTERACT AAD) < 0.16 ABUT<90 SINGULAR REGION
  EXT AAD (SP NOT INTERACT AAD) < 0.16 ABUT<90 SINGULAR REGION
  EXT AAD (ESD1 NOT INTERACT AAD) < 0.16 ABUT<90 SINGULAR REGION
  EXT AAD (NW NOT INTERACT AAD) < 0.16 ABUT<90 SINGULAR REGION
  EXT AAD (LVT NOT INTERACT AAD) < 0.16 ABUT<90 SINGULAR REGION
  EXT AAD (HVT NOT INTERACT AAD) < 0.16 ABUT<90 SINGULAR REGION
}
DIFRES_8{
@For AA Silicide resistor, make sure the AA be implanted by either SN or SP. Minimum enclosure by SN or SP is 0.18
((AA ENCLOSE AAD) NOT IN SP) NOT IN SN
ENC (AA ENCLOSE AAD) SN <0.18 ABUT<90 SINGULAR REGION
 ENC (AA ENCLOSE AAD) SP <0.18 ABUT<90 SINGULAR REGION
}
DIFRES_9{
@AA Silicide resistor with SP must lay on NW
 (AAD AND SP) NOT NW  
}
DIFRES_10{
@AA Silicide resistor with SN must lay on PW
(AAD AND SN) NOT PW
}
DIFRES_11{
@Minimum Space between DIFRES and non-related AA is 0.08
EXT DIFRES AA < 0.08 ABUT>0<90 SINGULAR REGION
}
DIFRES_12{
@Minimum Space between DIFRES and non-related Poly is 0.08
EXT DIFRES GT < 0.08 ABUT>0<90 SINGULAR REGION
}

//==========================
//  DNW - Deep N-Well DRC
//==========================
  
GROUP GDNW DNW_?

DNW_1 {
@ DNW minimum width is 0.52
  INT DNW < 0.52 ABUT<90 SINGULAR REGION
}
DNW_2 {
@ Minimum space between two DNW regions is 0.80
  EXT DNW < 0.80 ABUT<90 SINGULAR REGION
}
DNW_2a {
@ Space between two DNW regions at different net is 1.8um.
 EXT DNW < 1.8 ABUT<90 REGION NOT CONNECTED
}
DNW_3 {
@ Minimum overlap of NW and DNW region is 0
  DNW OUT EDGE NW
}
DNW_4 {
@ Minimum space between a DNW and a NW is 0.565
  X = NW NOT COIN EDGE DNW
  EXT X DNW < 0.565 ABUT<90 REGION
}
CONNECT DNW NW 
DNW_4a {
@ Minimum space between a DNW region and a NW region of different net is 1.5um
 X = NW NOT COIN EDGE DNW
EXT DNW X < 1.5 ABUT<90 REGION NOT CONNECTED 
}
/*DNW_5 {
@ Minimum space between P+AA to DNW is 0.21
  EXT DNW PACT < 0.21 ABUT<90 SINGULAR REGION
}
DNW_6 {
@ Minimum space between N+AA enclosed by DNW to NW is 0.21
  EXT (NACT AND DNW) NW  < 0.21 ABUT<90 SINGULAR REGION
}*/
DNW_7 {
@ Space between DNW and N+AA outside of DNW is >= 1.4um.
 EXT ((NACT NOT NW) OUTSIDE DNW) DNW < 1.4 ABUT<90 SINGULAR REGION
}
DNW_8 {
@ Space between (NW hole INSIDE DNW) and ((NW hole INSIDE DNW) or (PW NOT DNW)) at different nets is >= 0.6um.
  X = (HOLES NW) INSIDE DNW
  Z = PW AND X
  H = PW AND (PW NOT DNW)

  OUT1 = EXT Z < 0.6 ABUT < 90 REGION NOT CONNECTED
  OUT1 NOT MARKS   

  OUT2 = EXT Z H < 0.6 ABUT < 90 REGION NOT CONNECTED
  OUT2 NOT MARKS 
}
DGTG = DG OR TG
/*
DNW_8b {
@ Space between (NW hole INSIDE DNW) and ((NW hole INSIDE DNW) INTERACT (DG OR TG)) or ((PW NOT DNW) INTERACT (DG OR TG)) at different nets. is >= 0.6um.
@ DRC doesn?t check LDBK region.
  X = (HOLES NW) INSIDE DNW
  Y1 = PW COIN EDGE X 
  Y2 = PW COIN EDGE (X INTERACT DGTG)
  Z = (PW NOT DNW) INTERACT DGTG

  OUT1 = (EXT Y1 Y2 < 0.6 ABUT < 90 REGION NOT CONNECTED) NOT LDBK
  OUT1 NOT MARKS   

  OUT2 = (EXT Y1 Z < 0.6 ABUT < 90 REGION NOT CONNECTED) NOT LDBK
  OUT2 NOT MARKS 
}
*/
DNW_9 {
@ It is not allowed that N+AA CUT DNW.
  (NACT NOT NW) CUT DNW
}

//===================================
//   NW - N-Well Implant Layer DRC
//===================================

GROUP GNW NW_?

NW_1 {
@ NW minimum width(parallel side to side width, The INST connected area apply SRAM design rule) is 0.33
 X= INT NW  < 0.33 REGION PARA ONLY 
 X OUT INST
}
SRNW_1 {
@ NW minimum width is 0.27
 X = INT NW  < 0.27 ABUT<90 SINGULAR REGION
 X NOT OUTSIDE INST
}
NW_1a {
@ NW width for (((DNSRAM OR LRSRAM) OR D2SRAM) OR RFSRAM) connected area is >= 0.27.
 X= INT NW  < 0.27 ABUT<90 SINGULAR REGION 
 X NOT OUTSIDE SRAM
}
/*
NW_2 {
@ NW width for NW resistor is 1.2
  INT NWR < 1.20 ABUT<90 OPPOSITE REGION
}
*/
NW_3 {
@ Minimum space between two NW regions at the same net (with run length > 0 and skip to check jog <= 0.005um) is 0.33um.
  JOG_EDGE = CONVEX EDGE NW == 1 WITH LENGTH <= 0.005
  X = NW NOT COIN EDGE JOG_EDGE
  EXT X < 0.33 ABUT<90 OPPOSITE REGION CONNECTED
}
/*SRNW_3 {
@ Minimum space between two 0.9/1.1/1.2v NW regions at the same potential is 0.324
  X = EXT NW < 0.324 ABUT<90 SINGULAR REGION CONNECTED
  X NOT OUTSIDE INST
}*/
NW_4 {
@ Minimum space between two NW regions at different net is 0.60
  EXT NW < 0.60 ABUT<90 SINGULAR REGION NOT CONNECTED
}
NW_7 {
@ NW minimum area is 0.64um.
  AREA NW < 0.64
}
NW_8 {
@ NW minimum enclosed area is 0.70
  NWHOLE = HOLES NW INNER
  AREA (NWHOLE NOT NW) < 0.70
}
NW_9 {
@ NW minimum space to N+AA (enclosure by TG or DG) is 0.22
  EXT NW (NACT INSIDE (TG OR DG)) < 0.22 ABUT<90 SINGULAR REGION
}
NW_10 {
@ NW enclosure of P+AA (enclosed by TG or DG)is 0.22
ENC (PACT INSIDE (TG OR DG)) NW < 0.22 ABUT<90 SINGULAR REGION
}
/*NW_11{
@ N+AA adjacent both two edges space opposite to NW is >=0.16. Both of two adjacent edges space to NW smaller than rule value is not permitted.
X = EXT [NACT] NW <0.16 ABUT<90 OPPOSITE  
Y=NACT TOUCH EDGE X 
Z =INT Y <0.002 ABUT  REGION
Z NOT SRAM
}
*/
NW_11_R_ON {
@ N+AA adjacent both two edges space opposite to NW is >=0.16. Both of two adjacent edges space to NW smaller than rule value is not permitted.
@ In schematic rule check method, E = 0.08, D=0.16
NACT_EDGE = LENGTH NACT >0
Eregion = EXPAND EDGE NACT_EDGE INSIDE BY 0.08  EXTEND BY 0.001 
Eregion_EDGE = NACT INSIDE EDGE  Eregion 
Eregion_=EXT [Eregion_EDGE] NW <0.16  OPPOSITE  PERP ALSO OBTUSE ALSO
Eregion_EDGE_1 = Eregion_EDGE TOUCH EDGE Eregion_
INT Eregion_EDGE_1 <0.002 ABUT REGION  
}
/*NW_12{
@ NW enclosure opposite of P+AA adjacent both two edges is >= 0.16. Both of two adjacent edges enclosed by NW smaller than rule value is not permitted.
X = ENC [PACT] NW <0.16 ABUT<90 OPPOSITE    
Y =PACT TOUCH EDGE X  
Z =INT Y <0.002 ABUT  REGION
Z NOT SRAM
}*/
NW_12_R_ON {
@ NW enclosure opposite of P+AA adjacent both two edges is >= 0.16. Both of two adjacent edges enclosed by NW smaller than rule value is not permitted.
@ In schematic rule check method, E = 0.08, D=0.16.
@ This rule is not applied for (DNSRAM OR LRSRAM) OR D2SRAM) OR RFSRAM) covered region.
PACT_EDGE = LENGTH PACT >0
Eregion = EXPAND EDGE PACT_EDGE INSIDE BY 0.08  EXTEND BY 0.001 
Eregion_EDGE = PACT INSIDE EDGE  Eregion 
Eregion_=ENC [Eregion_EDGE] NW <0.16  OPPOSITE  PERP ALSO OBTUSE ALSO
Eregion_EDGE_1 = Eregion_EDGE TOUCH EDGE Eregion_
ERROR = INT Eregion_EDGE_1 <0.002 ABUT REGION
ERROR OUTSIDE SRAM
}
SRNW_13{
@ N+AA enclosure by NW is 0.027
 X = ENC NTAP NW < 0.027 ABUT<90 SINGULAR REGION
 X NOT OUTSIDE INST
}

SRNW_14 {
@ Minimum space between NW and N+AA inside PW is 0.04
@ Minimum space between NW outer vertex and N+AA inside PW outer vertex is 0.037
  (EXT NACT NW < 0.04 ABUT<90 OPPOSITE REGION) NOT OUTSIDE INST 
  (EXT NACT NW < 0.037 ABUT<90 CORNER TO CORNER SINGULAR REGION) NOT OUTSIDE INST
}

SRNW_15 {
@ P+AA enclosure by NW is 0.037
 X= ENC PACT NW < 0.037 ABUT<90 SINGULAR REGION INSIDE ALSO
 X NOT OUTSIDE INST
}

NW_13 {
@ N+ AA Minimum enclosure by NW is 0.08, excluding LDMOS area.Waive ((AA interact RESNW) and SN)
  ENC ((NACT OUTSIDE (INST OR LDBK)) NOT ((AA INTERACT RESNW) AND SN)) NW < 0.08 ABUT<90 SINGULAR REGION
}
NW_14 {
@ Minimum Space between NW and N+AA is 0.08um.
  X = EXT NACT NW < 0.08 ABUT<90 SINGULAR REGION
  X OUTSIDE INST
}
NW_15 {
@ P+AA minimum enclosure by NW is 0.08, excluding LDMOS area.
  ENC (PACT  OUTSIDE (INST OR LDBK)) NW < 0.08 ABUT<90 SINGULAR REGION
}
NW_16 {
@ Minimum Space between NW and P+ AA inside PW is 0.08um, excluding LDMOS area.
  EXT (PTAP NOT (LDBK OR PSUB)) NW < 0.08 ABUT<90 SINGULAR REGION
}
NW_17_R_OFF {
@ For parallel long NW (length > 50m), must make NW width larger than 0.89m or NW to NW space larger than 0.89m. 
@ If this area pass AA density DRC check, this rule can be waived.
@ This rule is not applied for (((DNSRAM OR LRSRAM) OR D2SRAM) OR RFSRAM) covered region.
   X1 = EXT NW < 0.89 OPPOSITE REGION PARA ONLY
   X2 = LENGTH X1 > 50
   X3 = EXPAND EDGE X2 OUTSIDE BY 0.89
   X4 = X3 NOT INTERACT (X3 NOT NW)
   X5 = INT X2 < 0.89 REGION
   (X5 NOT INTERACT X4) NOT SRAM
}
  
//================================
//  RESNWST  DRC
//================================

GROUP GRESNWS RESNWST_?

NWRSTI =(NW AND RESNW) NOT AA

RESNWST_1_2 {
@ NW-Resistor width is >=1.2 
@ NW-Resistor minimum length is >=10
INT (NWRSTI TOUCH EDGE AA) <10 ABUT<90 OPPOSITE REGION 
NOT ENCLOSE RECTANGLE NWRSTI 1.2 10
}
RESNWST_3{
@ NW-Resistor and NW space S1 >=1
EXT NWRSTI NW <1 ABUT<90 SINGULAR REGION
}
RESNWST_4{
@ The nearest CT space to (AA edge touch RESNW)	S2=0.3
X0 = RESNW INTERACT NWRSTI
X01 = (RESNW COIN EDGE NWRSTI) TOUCH EDGE AA
X1 = EXT X01 CT  <= 0.36 ABUT<90 REGION OPPOSITE 
X2 = EXT X01 CT == 0.3 ABUT<90 REGION OPPOSITE
(X1 NOT (X2 NOT (X2 ENCLOSE CT))) OR (CT INTERACT X0)
}

RESNWST_5 {
@ Minimum space between NWSTI resistor and adjacent AA is 0.44um.
  EXT NWRSTI (AA NOT INTERACT NWRSTI) < 0.44 ABUT<90 SINGULAR REGION
}
RESNWST_6 {
@ Space between RESNW to silicided AA area.	S4	=	0.00
@ DRC check by (RESNW AND NW) touch AA edge with count 2.
   (RESNW AND NW) TOUCH AA < 2  
} 
RESNWST_7{
@ SN enclosure of AA is >= 0.4um.
ENC (AA TOUCH NWRSTI) SN <0.4  ABUT<90 REGION
}
RESNWST_8{
@ AA enclosure of NW(the NW interacted with RESNW)	EN2	>=	0.3
ENC (NW INTERACT RESNW) AA <0.3 ABUT<90 REGION
}
RESNWST_9{
@ CT should be in (NW AND ( pick up AA))	
  CT AND ((AA TOUCH RESNW) NOT NW)
}	
RESNWST_10{
@ NW resistor under STI must not overlap with AADUM	
NWRSTI AND AADUM 
}		
RESNWST_11{
@ (RESNW AND NW) must be an orthogonal rectangle shape to have good simulation accuracy	R3		
NOT RECTANGLE (RESNW AND NW) ORTHOGONAL ONLY
}

//================================
//  RESNW - N-Well Resistor DRC
//================================

GROUP GRESNWAA RESNWAA_?

RESNWAA= (NW AND RESNW) AND AA

RESNWAA_1{
@ RESNW must be an orthogonal rectangle
NOT RECTANGLE (RESNW INTERACT RESNWAA) ORTHOGONAL ONLY
}
RESNWAA_2_3{
@ NW-Resistor minimum length (SMIC 2R)>=10
@ NW-Resistor width (SMIC 2R, 65nm rule 1.6um)>=1.2
INT (RESNWAA TOUCH EDGE SN) <10 ABUT<90 OPPOSITE REGION
NOT ENCLOSE RECTANGLE RESNWAA 1.2 10 
}
RESNWAA_4{
@ AA enclosure of RESNWAA (SMIC 2R no rule, 65nm rule number)>=0.3
ENC RESNWAA AA < 0.3 ABUT<90 REGION
}
RESNWAA_5{
@ NW enclosure of CT (65nm rule, included in SMIC 2R)>=0.20
ENC CT (NW ENCLOSE RESNWAA)  <0.2 ABUT<90 REGION   
}
RESNWAA_6 {
@ Enclosure of SAB beyond related NW (65nm rule)>=0.20
 X1 = HOLES SAB
 X2 = SAB TOUCH X1
 ENC (NW INTERACT RESNWAA)  X1 < 0.2 ABUT<90 SINGULAR REGION
 ENC (NW INTERACT RESNWAA)  X2 < 0.2 ABUT<90 SINGULAR REGION
 (((NW INTERACT RESNWAA) INTERACT X1) NOT X1) NOT SAB
}
RESNWAA_7{
@ RESNW must not overlap with other implant layers (except NW) in the NW-Resistor area.
@ Other implant layers: LVT, HVT, SN, SP, ESD1. These layers don?t interact with resistors.
  RESNWAA AND SN
  RESNWAA AND SP
  RESNWAA AND ESD1
  RESNWAA AND LVT
  RESNWAA AND HVT
}
RESNWAA_8{
@ Space between RESNW and CT inside (AA interact RESNW) =0.70
X0 = RESNW INTERACT RESNWAA
X01 = (RESNW INTERACT RESNWAA) COIN EDGE SN
X = CT INSIDE (AA INTERACT RESNW)
X1 = EXT X01 X <= 0.76 ABUT<90 REGION OPPOSITE 
X2 = EXT X01 X == 0.7 ABUT<90 REGION OPPOSITE
(X1 NOT (X2 NOT (X2 ENCLOSE CT))) OR (CT INTERACT X0)
}
RESNWAA_9{
@ Extension of RESNW outside of NW (65nm 0.2um, SMIC 2R RESNW within NW) >= 0.00
 X =RESNWAA TOUCH (RESNW NOT RESNWAA) >1
 Y = RESNW COIN EDGE NW
 Z =EXPAND EDGE Y INSIDE BY 0.001 
 RESNW NOT INTERACT (X OR (RESNW INTERACT Z))
}
RESNWAA_10{ 
@ SAB must include NW resistor except CT area
/*
  X = RESNW ENCLOSE (RESNW AND AA)
  Y = (SAB OR (HOLES SAB)) INTERACT X
  Y NOT ENCLOSE RESNWAA
*/
  X = SAB INTERACT RESNWAA
  RESNWAA NOT X
  CT AND X
}		
RESNWAA_11{
@ Space between RESNW to SN (SMIC 2R no rule, 65nm no rule)=0.00
  (RESNW INTERACT RESNWAA) NOT TOUCH SN
  (SN INTERACT (NW INTERACT RESNWAA)) NOT TOUCH (RESNW INTERACT RESNWAA)
}
RESNWAA_12{
@ SAB enclosure of AA (SMIC 2R no rule, 65nm rule 0.2um, 0.18um is SMIC SAB main rule)>=0.18
ENC (AA INTERACT RESNWAA) SAB < 0.18 ABUT<90 REGION
}
RESNWAA_13 {
@ SAB overlap of SN =0.4. Use exact value on sides touch RESNW.(65nm rule 0.2, 40nm WAT TK 0.4um)
X = SN COIN EDGE RESNW 
Y = EXPAND EDGE X INSIDE BY 0.4     
Y NOT TOUCH (HOLES SAB) 
}

//===================================
//   PW - P-Well Implant Layer DRC
//===================================
/*
GROUP GSRPW SRPW_?

SRPW_1 {
@ PW minimum width is 0.268
  INT PWi < 0.268 ABUT<90 SINGULAR REGION
}
*/


//==========================================
//  PSUB - Native NMOS blocked implant DRC
//==========================================

GROUP GPSUB PSUB_?

PSUB_1 {
@ PSUB width is 0.33
  INT PSUB < 0.33 ABUT<90 SINGULAR REGION
}
PSUB_2 {
@ Minimum width of an AA to define the width of native NMOS for 0.9/1.1/1.2/1.8/2.5v transistors is 0.4
  INT ((PBAA IN EDGE GT) COIN EDGE GATE) < 0.40 ABUT<90 REGION
}
PSUB_3a {
@ 0.9/1.1/1.2V minimum gate length enclosed by PSUB is 0.30
  X = (PBGT INSIDE EDGE PBAA) COIN EDGE GATE
  INT X < 0.30 ABUT<90 REGION
}
PSUB_3b {
@ 1.8V minimum gate length enclosed  by PSUB(enclosed by DG) is 0.80
  X = (PBGT INSIDE EDGE (PBAA INTERACT DG)) COIN EDGE GATE
  INT X < 0.80 ABUT<90 REGION
}
PSUB_3cde {
@ 2.5V minimum gate length enclosed by PSUB(enclosed by TG) is 1.20
@ 2.5V overdrive 3.3V gate length enclosed by PSUB (enclosed by TG)is 1.20
@ 2.5V underdrive 1.8V gate length enclosure by PSUB( enclosed by TG)is 1.20	
  X =( PBGT INSIDE EDGE (PBAA INTERACT TG)) COIN EDGE GATE
  INT X < 1.20 ABUT<90 REGION
}
PSUB_4 {
@ Space between two PSUB regions is 0.33
  EXT PSUB < 0.33 ABUT<90 SINGULAR REGION
}
PSUB_5 {
@ AA enclosure by PSUB is min 0.20, max 0.26, inductor does not need to follow.
@ Note7:it is recommended that PSUB should be conformal to AA edge
  //X1 = SIZE (PBAA NOT INTERACT CAPBP) BY 0.20  //not PSUB CAP
  //X2 = SIZE (PBAA NOT INTERACT CAPBP) BY 0.26
  X1 = SIZE PBAA BY 0.20
  X2 = SIZE PBAA BY 0.26
  X3 = X2 NOT X1
  Y = (PSUB INTERACT PBAA) NOT INDMY
  OUTSIDE EDGE Y X3
}
PSUB_6 {
@ Space between PSUB and AA is 0.08, inductor does not need to follow.
  (EXT PSUB AA < 0.08 ABUT<90 SINGULAR REGION) NOT INDMY
}
PSUB_7 {
@ Space between PSUB and NW is 0.63, inductor does not need to follow.
  (EXT PSUB NW < 0.63 ABUT<90 SINGULAR REGION) NOT INDMY
}
/*
PSUB_8 {
@ Extension of native NMOS poly gate outside of AA(poly endcap) is 0.20
  X = PBAA INSIDE EDGE PBGT
  ENC X PBGT < 0.20 ABUT<90 REGION
}
*/
PSUB_9 {
@ Minimum space between a PSUB outside INDMY and an unrelated Gate region is 0.37
  EXT (PSUB NOT INSIDE INDMY) GATE < 0.37 ABUT<90 SINGULAR REGION
}
PSUB_10 {
@ PSUB inside or cross over a NW area is not allowed  
  PSUB AND NW
}
PSUB_11 {
@ PSUB inside or cross over a Deep N-Well is not allowed
  PSUB AND DNW
}
PSUB_12 {
@ Only one AA region is allowed to exist in one PSUB region
@ except for the NMOS capacitor, INDMY and pickup region.
  (PSUB NOT INTERACT INDMY) INTERACT ((AA NOT TAP) NOT INTERACT CAPBP) > 1
}
/*PSUB_Note4 {
@ SP, P+ implant area, is not allowed to exist in a PSUB region
 (PSUB NOT INDMY) AND SP
}
PSUB_13 {
@ Bent Poly is not allowed to exist on AA in a PSUB region
  X = GT INSIDE EDGE PBAA
  INT X < 0.01 ABUT < 180 REGION
  EXT X < 0.01 ABUT < 180 REGION
}
*/
PSUB_14 {
@ PSUB area is >= 0.7um2.
  AREA PSUB < 0.7
}
PSUB_15 {
@ PSUB enclosed area is >= 0.64um2.
  AREA ((HOLES PSUB INNER) NOT PSUB) < 0.64
}
PSUB_16_R_ON {
@ It?s not allowed (SP AND GATE) in PSUB.
@ DRC doesn?t check INDMY region.
  (PGATE AND PSUB) NOT INDMY
}

/*
//=====================================
//  SDOP - SRAM PG Implant Layer DRC
//=====================================

GROUP GSDOP SDOP_?

SDOP_1 {
@ SDOP width is 0.18
  INT SDOP < 0.18 ABUT<90 SINGULAR REGION
}
SDOP_2 {
@ Space between two SDOP is 0.18. Merge if the space is less than this rule
  EXT SDOP < 0.18 ABUT<90 SINGULAR REGION
}
SDOP_3 {
@ Space between SDOP and N+/AA in PW or P+ AA in NW is 0.09
  EXT SDOP NTAP < 0.09 ABUT<90 SINGULAR REGION
  EXT SDOP PTAP < 0.09 ABUT<90 SINGULAR REGION
}
SDOP_4 {
@ SDOP extension outside of poly gate for NMOS along source drain direction is 0.18
  ENC NGTEIAA SDOP < 0.18 ABUT<90 REGION
}
SDOP_5 {
@ Space between SDOP and P-channel poly gate is 0.2
  EXT SDOP PGATE < 0.20 ABUT<90 SINGULAR REGION
}
SDOP_6 {
@ Space between SDOP SAB poly and AA resistor is 0.2
  EXT SDOP (GTR INTERACT SAB) < 0.2 ABUT<90 SINGULAR REGION
  EXT SDOP (AAR INTERACT SAB) < 0.2 ABUT<90 SINGULAR REGION
}
SDOP_7 {
@ N+AA enclosure by SDOP is 0.08 if the distance to the poly gate w >0.16um
  X = (NMOS AND SDOP) TOUCH EDGE NAAEIGT 
  ENC X SDOP < 0.08 ABUT<90 REGION
}
SDOP_8 {
@ N+AA enclosure by SDOP is 0.18 if the distance to the poly gate w<=0.16um
  X = EXPAND EDGE (GT IN EDGE (AA AND SDOP)) OUTSIDE BY 0.16 EXTEND BY 0.18 
  X NOT SDOP
}
SDOP_9 {
@ SDOP area is 0.1
  AREA SDOP < 0.10
}
SDOP_10 {
@ SDOP minimum enclosed area is 0.1
  SDOPHOLE = HOLES SDOP INNER
  AREA (SDOPHOLE NOT SDOP) < 0.10
}
SDOP_11 {
@ SDOP can not overlap with P+ pickup AA or butted P+AA
  SDOP AND PACT
}
SDOP_12 {
@ SDOP shapes must be orthogonal
  ANGLE SDOP >0<90
}
SDOP_13 {
@ (SDOP over AA) over (TG, DG, LVN, VTNH) is prohibited
  SDAA = AA AND SDOP
  SDAA AND TG
  SDAA AND DG
  SDAA AND LVN
  SDAA AND VTNH
}
*/
//================================
//  SRDOP - SRAM Pass Gate DRC
//================================

GROUP GSRDOP SRDOP_?

SRDOP_101 {
@ Gate touching SDOP must be covered by SDOP
 (GATE NOT OUTSIDE SDOP) NOT SDOP
}
SRDOP_102 {
@ SDOP min. width is 0.18
  INT SDOP < 0.18 ABUT<90 SINGULAR REGION
}
SRDOP_103 {
@ SDOP min. area is 0.1
  AREA SDOP < 0.1
}
SRDOP_104 {
@ SDOP is must be in INST
  SDOP NOT INST
}
SRDOP_105 {
@ SDOP must enclose Real Gate is 0.056
ENC Real_GATE SDOP < 0.056 ABUT<90 SINGULAR REGION
}


//==================================================
//   TG - Triple Gate DRC (Define 2.5V IO region)
//==================================================

GROUP GTG TG_?

TG_1 {
@ TG minimum width is 0.33(single-point-interact is allowed).
  INT TG < 0.33 ABUT<90 REGION
}
TG_2 {
@ Minimum space between two TGs is 0.33(single-point-interact is allowed).
  EXT TG < 0.33 ABUT<90 REGION
}
TG_3 {
@ AA with transistor minimum enclosure by TG is 0.20um(include AA area not under poly).
  ENC Real_MOS TG < 0.20 ABUT<90 SINGULAR REGION 
}
TG_4 {
@ Real gate enclosure by TG is 0.20
  ENC Real_GATE TG < 0.20 ABUT<90 SINGULAR REGION
}
TG_5 {
@ Minimum space between TG and AA with device is 0.19
@ Prohibit overlap of TG and other voltage AA with transistor
  X_MOS = AA INTERACT (GT INTERACT GATE)
  X_RES = AA INTERACT (DIFRES OR RESAA)
  X_DIO1 = AA INTERACT (SIZE (DSTR NOT INTERACT PSUB) BY 0.3)
  X_DIO2 = AA INTERACT (SIZE (DSTR INTERACT PSUB) BY 0.4)
  X_NPN_PNP = AA INTERACT DMPNP
  X_ALL = (((X_MOS OR X_RES) OR (X_DIO1 OR X_DIO2)) OR X_NPN_PNP) NOT INST
  X =(AA AND ((SN AND NW) OR (SP NOT NW)))  NOT VARMOS
  EXT TG (X_ALL NOT X) < 0.19 ABUT<90 SINGULAR REGION
  (X_MOS CUT TG) AND TG
}
TG_6 {
@ Space between TG and Real gate is 0.19 (Don't be necessary for pick-up to follow these rules)
  EXT TG Real_GATE < 0.19 ABUT<90 SINGULAR REGION
}
TG_7 {
@ Minimum area is 0.463
  AREA TG < 0.463
}
TG_8 {
@ Minimum enclosed area is 0.463
  TGHOLE = HOLES TG INNER
  AREA (TGHOLE NOT TG) < 0.463
}
/*
TG_9 {
@ AA (enclosure by TG) minimum width for 2.5V transistor is 0.32
  INT MOS25 < 0.32 ABUT<90 SINGULAR REGION
}
TG_10 {
@ TG shapes must be orthogonal
  ANGLE TG >0<90
}
*/
TG_11_R_ON {
@ Extension of AA in TG outside of Real gate is 0.15. Exclude gate within LDMOS region(within LDBK) and within inductor area(layer INDMY)
  //ENC MOS25 GT < 0.17 ABUT<90 SINGULAR REGION
  ENC (Real_GATE NOT (LDBK OR INDMY))  (AA AND TG)  < 0.15 ABUT>0<90 SINGULAR REGION
}
TG_12 {
@ Space between TG and DG is 0.33
  EXT TG DG < 0.33 ABUT<90 SINGULAR REGION
}
TG_13 {
@ TG minimum overlap past NW with abutting permitted is 0.33
  ENC NW (TG NOT COIN EDGE NW) < 0.33 ABUT<90 REGION
}
TG_14 {
@ TG minimum overlap of NW with abutting permitted is 0.33
  INT NW (TG NOT COIN EDGE NW) < 0.33 ABUT<90 REGION
}
TG_15 {
@ NW minimum overlap past TG with abutting permitted is 0.33
  ENC (TG NOT COIN EDGE NW) NW < 0.33 ABUT<90 REGION
}
TG_16 {
@ (((DG OR TG) OR NW) OR PSUB) opposite width is >= 0.33um.
@ This rule is not applied for (DNSRAM OR LRSRAM) OR D2SRAM) OR RFSRAM) connected region.
  (INT (OR DG TG NW PSUB) < 0.33 ABUT<90 OPPOSITE SINGULAR REGION) OUTSIDE SRAM
}
TG_16a {
@ (((DG OR TG) OR NW) OR PSUB) width for (((DNSRAM OR LRSRAM) OR D2SRAM) OR RFSRAM) connected area is >= 0.27um.
  (INT (OR DG TG NW PSUB) < 0.27 ABUT<90 SINGULAR REGION) NOT OUTSIDE SRAM
}
TG_17 {
@ Space between (DG OR TG) and NW when the run length > 0 is >= 0.33um. Space= 0um is allowed.
@ DRC waive: 
@ a.the violated region not interact with AA region.
@ b.The violated region interacts with AA, but the AA is pickup AA.
  (EXT DG (NW NOT COIN EDGE DG) < 0.33 ABUT<90 OPPOSITE REGION) INTERACT (AA NOT TAP)
  (EXT TG (NW NOT COIN EDGE TG) < 0.33 ABUT<90 OPPOSITE REGION) INTERACT (AA NOT TAP)
}
TG_18 {
@ Space between (NW NOT (DG OR TG)) and (NW NOT (DG OR TG)) is >= 0.33um.
@ with run length > 0, skip to check jog <=0.01um pattern.
  X = NW NOT (DG OR TG)
  JOG_EDGE = CONVEX EDGE X == 1 WITH LENGTH <= 0.01
  Y = X NOT COIN EDGE JOG_EDGE
  EXT Y < 0.33 ABUT<90 OPPOSITE REGION
}
TG_19 {
@ Space between ((DG OR TG) AND NW) and ((DG OR TG) AND NW) when run length > 0 is >= 0.33um.
  X = NW AND (DG OR TG)
  EXT X < 0.33 ABUT<90 OPPOSITE REGION
}
TG_20 {
@ Space between ((DG OR TG) NOT (NW OR PSUB)) and ((DG OR TG) NOT (NW OR PSUB)) when run length > 0 is >= 0.33um.
  X = (DG OR TG) NOT (NW OR PSUB)
  EXT X < 0.33 ABUT<90 OPPOSITE REGION
}
   

//================================================
//   DG - Dual Gate DRC (Define 1.8V IO region)
//================================================

GROUP GDG DG_?

DG_1 {
@ DG minimum width is 0.33
  INT DG < 0.33 ABUT<90 SINGULAR REGION
}
DG_2 {
@ Minmum space between two DGs is 0.33, merge if the space is less than rule
  EXT DG < 0.33 ABUT<90 SINGULAR REGION
}
DG_3 {
@ AA with transistor minimum enclosure by DG is 0.20 (include AA area not under poly)
  ENC Real_MOS DG < 0.20 ABUT<90 SINGULAR REGION
}
DG_4 {
@ Real gate minimum enclosure by DG is 0.20
  ENC Real_GATE DG < 0.20 ABUT<90 SINGULAR REGION
}
DG_5 {
@ Minimum space between DG and AA with device is 0.19
@ Prohibit overlap of DG and other voltage AA with transistor
  X_MOS = AA INTERACT (GT INTERACT GATE)
  X_RES = AA INTERACT (DIFRES OR RESAA)
  X_DIO1 = AA INTERACT (SIZE (DSTR NOT INTERACT PSUB) BY 0.3)
  X_DIO2 = AA INTERACT (SIZE (DSTR INTERACT PSUB) BY 0.4) 
  X_NPN_PNP = AA INTERACT DMPNP
  X_ALL = (((X_MOS OR X_RES) OR (X_DIO1 OR X_DIO2)) OR X_NPN_PNP) NOT INST
  X =(AA AND ((SN AND NW) OR (SP NOT NW)))  NOT VARMOS
  EXT DG (X_ALL NOT X )< 0.19 ABUT<90 SINGULAR REGION
  (X_MOS CUT DG) AND DG
}
DG_6 {
@ Minimum space between DG and Real gate is 0.19
  EXT DG Real_GATE < 0.19 ABUT<90 SINGULAR REGION
}
DG_7 {
@ Minimum area is 0.463
  AREA DG < 0.463
}
DG_8 {
@ Minimum enclosed area is 0.463
  DGHOLE = HOLES DG INNER
  AREA (DGHOLE NOT DG) < 0.463
}
/*
DG_9 {
@ AA (enclosure by DG) minimum width for 1.8V transistor is 0.32
  INT MOS18 < 0.32 ABUT<90 SINGULAR REGION
}
DG_10 {
@ DG shapes must be orthogonal
  ANGLE DG >0<90
}
*/
DG_11_R_ON {
@ AA (enclosed by DG) minimum overlap past poly is 0.15
  ENC GT MOS18 < 0.15 ABUT<90 SINGULAR REGION
}
DG_12 {
@ DG minimum overlap past NW with abutting permitted is 0.33
  ENC NW DG < 0.33 ABUT>0<90 SINGULAR REGION
}
DG_13 {
@ DG minimum overlap of NW with abutting permitted is 0.33
  INT NW DG < 0.33 ABUT>0<90 SINGULAR REGION
}
DG_14 {
@ NW minimum overlap past DG with abutting permitted is 0.33
  ENC DG NW < 0.33 ABUT>0<90 SINGULAR REGION
}


#IFDEF CHK_CORN YES
//==============================================
//    BORDER AND CORN - BORDER AND CORN Rule DRC
//==============================================

CORN_1 {
@ Chamfer area size at the chip corner is 74. The chip edge is defined to be the maximum boundary of all chip layers.
@ All layers include BORDER(127;0) should not interact with area A in the figure.This rule is applicable for chips gds
@ Note 1. The DRC executes this section rule check on following layers: AA, GT, CT, SP, SAB, CT, Vn n=1-7, Mn n=1-8, MnDUM n=1-8, TV1, TV2, TM1, TM2, BORDER.
@ Note 2. This rule section only applies for those chips that need to have chip level. The chip corner rule check option is default turned on in DRC script.
@ Note.3. In case for the building block level design, or the IP gds, please turn off the chip corner rule check option.
  CORN AND AAi
  CORN AND GTi
  CORN AND CTi
  CORN AND SPi
  CORN AND SABi
  CORN AND V1i
  CORN AND V2i
  CORN AND V3i
  CORN AND V4i
  CORN AND V5i
  CORN AND V6i
  CORN AND V7i
  CORN AND M1i
  CORN AND M2i
  CORN AND M3i
  CORN AND M4i
  CORN AND M5i
  CORN AND M6i
  CORN AND M7i
  CORN AND M8i
  CORN AND M1DUM
  CORN AND M2DUM
  CORN AND M3DUM
  CORN AND M4DUM
  CORN AND M5DUM
  CORN AND M6DUM
  CORN AND M7DUM
  CORN AND M8DUM
  CORN AND TV2i
  CORN AND TM2i
  CORN AND MTT2i
  CORN AND BORDER
}
CORN_2 {
@ For the chips needs SMIC mask shop insert dummy and seal ring, the corner area A(see this section figure) should be covered with (DUMBA, DUMBP, DUMBM).
 CORN NOT (( DUMBA OR DUMBP) OR DUMBM)
}
#ENDIF
/*Note for BORDER rules : 
This section is only used for the design which customer do not put the seal ring. 
If customer draw seal ring following design rule, chip edge BORDER layer can be skipped.
Chip edge BORDER layer and layout pattern rule is defined to avoid any layout pattern extend out to scribe lane region
Customer must draw border layer if they do not put the seal ring in the design.
*/

#IFDEF CHK_BORDER YES
BORDER_1 {
@ Designer need to add BORDER (CHIPEDGE) to define chip boundary and have all chip layout patterns inside BORDER.
@ except DUMBA, DUMBP, DUMBM in corner as defined in rule CORN.2.
  (DRC:1 NOT BD_WITHHOLE) NOT ((OR DUMBA DUMBP DUMBM) INTERACT CORN)
}

//============
//BORDER_ER.2
//============

BORDER_2_AA {
@ AA enclosure by BORDER min. is 0.36
  ENC AAi BD_WITHHOLE < 0.36 ABUT<90 SINGULAR REGION
}
BORDER_2_GT {
@ GT enclosure by BORDER min. is 0.36
  ENC GTi BD_WITHHOLE < 0.36 ABUT<90 SINGULAR REGION
}
BORDER_2_CT {
@ CT enclosure by BORDER min. is 0.36
  ENC CTi BD_WITHHOLE < 0.36 ABUT<90 SINGULAR REGION
}
BORDER_2_M1 {
@ M1 enclosure by BORDER min. is 0.36
  ENC M1i BD_WITHHOLE < 0.36 ABUT<90 SINGULAR REGION
}
BORDER_2_M2 {
@ M2 enclosure by BORDER min. is 0.36
  ENC M2i BD_WITHHOLE < 0.36 ABUT<90 SINGULAR REGION
}
BORDER_2_M3 {
@ M3 enclosure by BORDER min. is 0.36
  ENC M3i BD_WITHHOLE < 0.36 ABUT<90 SINGULAR REGION
}
BORDER_2_M4 {
@ M4 enclosure by BORDER min. is 0.36
  ENC M4i BD_WITHHOLE < 0.36 ABUT<90 SINGULAR REGION
}
BORDER_2_M5 {
@ M5 enclosure by BORDER min. is 0.36
  ENC M5i BD_WITHHOLE < 0.36 ABUT<90 SINGULAR REGION
}
BORDER_2_M6 {
@ M6 enclosure by BORDER min. is 0.36
  ENC M6i BD_WITHHOLE < 0.36 ABUT<90 SINGULAR REGION
}
BORDER_2_M7 {
@ M7 enclosure by BORDER min. is 0.36
  ENC M7i BD_WITHHOLE < 0.36 ABUT<90 SINGULAR REGION
}
BORDER_2_M8 {
@ M8 enclosure by BORDER min. is 0.36
  ENC M8i BD_WITHHOLE < 0.36 ABUT<90 SINGULAR REGION
}
BORDER_2_V1 {
@ V1 enclosure by BORDER min. is 0.36
  ENC V1i BD_WITHHOLE < 0.36 ABUT<90 SINGULAR REGION
}
BORDER_2_V2 {
@ V2 enclosure by BORDER min. is 0.36
  ENC V2i BD_WITHHOLE < 0.36 ABUT<90 SINGULAR REGION
}
BORDER_2_V3 {
@ V3 enclosure by BORDER min. is 0.36
  ENC V3i BD_WITHHOLE < 0.36 ABUT<90 SINGULAR REGION
}
BORDER_2_V4 {
@ V4 enclosure by BORDER min. is 0.36
  ENC V4i BD_WITHHOLE < 0.36 ABUT<90 SINGULAR REGION
}
BORDER_2_V5 {
@ V5 enclosure by BORDER min. is 0.36
  ENC V5i BD_WITHHOLE < 0.36 ABUT<90 SINGULAR REGION
}
BORDER_2_V6 {
@ V6 enclosure by BORDER min. is 0.36
  ENC V6i BD_WITHHOLE < 0.36 ABUT<90 SINGULAR REGION
}
BORDER_2_V7 {
@ V7 enclosure by BORDER min. is 0.36
  ENC V7i BD_WITHHOLE < 0.36 ABUT<90 SINGULAR REGION
}

BORDER_3 {
@ DNW minimum enclosure by chip edge(BORDER layer) is 0.8
 ENC DNW BD_WITHHOLE < 0.8 ABUT<90 SINGULAR REGION
}
#IFDEF CHK_CORN YES
BORDER_4{
@ All designs should place a BORDER at the most outermost edge with straight lines from chip corner area to corner area.
BD_WITHHOLE NOT ( RECTANGLE (BD_WITHHOLE OR CORN))
} 
#ENDIF
#IFDEF CHK_CORN  NO
BORDER_4{
@ All designs should place a BORDER at the most outermost edge with straight lines from chip corner area to corner area.
BD_WITHHOLE NOT ( RECTANGLE BD_WITHHOLE )
} 
#ENDIF 

BORDER_6 {
@ Enclosure of seal ring outer ring outline edge by BORDER layer if seal ring has been added by designers is >= 5um.
MS_OUT_TEMP1 = (((((((M1i AND MARKS) OR (M2i AND MARKS)) OR (M3i AND MARKS)) OR (M4i AND MARKS)) OR (M5i AND MARKS)) OR (M6i AND MARKS)) OR (M7i AND MARKS))  OR (M8i AND MARKS)
MS_OUT_TEMP2 = (TM2i AND MARKS) OR (MTT2i AND MARKS)
MS_OUT = MS_OUT_TEMP1 OR MS_OUT_TEMP2
X = HOLES MS_OUT
MS_outer_ring = MS_OUT TOUCH X 
ENC MS_outer_ring BD_WITHHOLE < 5
}
#ENDIF


//==========================
//    GT - Poly Rule DRC
//==========================

GROUP GGT GT_?

GT_1a {
@ Real Gate minimum channel length for 0.9/1.1/1.2V N/P MOS transistors (std, high, or low VT) is 0.04  
@ SRGT_1, Gate minimum length is 0.04
  X = (GT IN EDGE (AA NOT (DG OR TG))) COIN EDGE Real_GATE
  INT X < 0.04 ABUT<90 REGION OPPOSITE
}
GT_1a_R_OFF {
@ Real GATE channel length for 0.9/1.1/1.2V N/P MOS transistors (std, high, or low VT) is >= 0.044um.
  X = (GT IN EDGE (AA NOT (DG OR TG))) COIN EDGE Real_GATE
  INT X < 0.044 ABUT<90 REGION OPPOSITE
}
GT_1b {
@ Real GATE minimum channel length for 1.8V N/P MOS transistors is 0.15
  X = GT COIN EDGE ((Real_GATE AND DG)  NOT DGV)
  INT X < 0.15 ABUT<90 REGION OPPOSITE
}
GT_1c {
@ Real GATE minimum channel length for 2.5V N/P MOS transistors is 0.27
  X = GT COIN EDGE ((Real_GATE AND TG) NOT TGV)
  INT X < 0.27 ABUT<90 REGION OPPOSITE
}
GT_1d {
@ Real Gate minimum channel length for 2.5V overdrive 3.3V NMOS transistors is 0.55
  X = GT COIN EDGE ((Real_NGATE AND TG) AND OVERDR)
  INT X < 0.55 ABUT<90 REGION OPPOSITE
}
GT_1e {
@ Real Gate minimum channel length for 2.5V overdrive 3.3V PMOS transistors is 0.44
  X = GT COIN EDGE ((Real_PGATE AND TG) AND OVERDR)
  INT X < 0.44 ABUT<90 REGION OPPOSITE
}
GT_1fg {
@ Real Gate minimum channel length for 2.5V underdrive 1.8V NMOS transistors is 0.24
@ Real Gate minimum channel length for 2.5V underdrive 1.8V PMOS transistors is 0.24
  X = GT COIN EDGE ((Real_GATE AND TG) AND TGV)
  INT X < 0.24 ABUT<90 REGION OPPOSITE
}
GT_1h{
@ Real Gate channel length for 1.8V underdrive 1.5V N/P MOS transistors	0.125
X = GT COIN EDGE ((Real_GATE AND DG) AND DGV)
  INT X < 0.125 ABUT<90 REGION OPPOSITE
}
GT_2a {
@ Poly minimum width is 0.04
 INT GT_all < 0.04 ABUT<90 SINGULAR REGION
}
GT_2b_R_OFF {
@ Non-floating poly outside of (extend AA W>= 2.5um) region minimum width is 0.06, This rule is not applicable for GT interacting with EFUSE(81;2).
  AAregion = SIZE AA BY 2.5
  GTout = (GT NOT FTGT) NOT AAregion
  err = (INT (GTout NOT COIN EDGE AAregion) < 0.06 ABUT<90 REGION) NOT EFUSE
  err NOT (GT WITH WIDTH >0.06)  
}

GT_3 {
@ Space between two poly is 0.1
 EXT (GT_all OUTSIDE INST)< 0.10  SINGULAR REGION
}
GT_3c{
@ GT to GT space if one GTs width > 0.12um is >=0.14, parallel run length of the two GT > 0.14um
X = GT_all WITH WIDTH > 0.12  
Y = EXT X GT_all < 0.14 REGION OPPOSITE
Y1 = EXT X [GT_all] < 0.14 OPPOSITE  
Z = LENGTH Y1 >0.14  
Y WITH EDGE Z
}

AA_VEX_0 = CONVEX EDGE AA == 0
AA_VEX_1 = CONVEX EDGE AA == 1
AA_VEX_2 = CONVEX EDGE AA == 2
AA_LS = ((AA NOT WITH EDGE AA_VEX_0) WITH EDGE AA_VEX_1 == 2) WITH EDGE AA_VEX_2 == 4
GT_VEX_0 = CONVEX EDGE GT == 0
GT_VEX_1 = CONVEX EDGE GT == 1
GT_VEX_2 = CONVEX EDGE GT == 2
GT_LS = ((GT NOT WITH EDGE GT_VEX_0) WITH EDGE GT_VEX_1 == 2) WITH EDGE GT_VEX_2 == 4
GT_3d {
@ Space between two GATEs when L-shape AA and L-shape poly enclosed area < 0.011 m2 is >= 0.105um.
  AA_corner = EXT AA < 0.001 ABUT == 90 INTERSECTING ONLY REGION
  GT_corner = EXT GT < 0.001 ABUT == 90 INTERSECTING ONLY REGION
  AA_GT_corner = EXT AA GT < 0.001 ABUT == 90 INTERSECTING ONLY REGION  
  Check_region_1 = HOLES (AA OR GT) INNER
  Check_region_2 = (((RECTANGLE CHeck_region_1) INTERACT AA_GT_corner == 2) INTERACT AA_corner == 1) INTERACT GT_corner == 1
  Check_region = AREA Check_region_2 < 0.011
  Check_gate = GATE INTERACT (SIZE Check_region by 0.001)
  EXT Check_gate < 0.105 ABUT<90 SINGULAR REGION
}

GATE_WE = GATE COIN EDGE GT
GATE_LE = (GATE TOUCH EDGE (INT GATE_WE GATE < 0.005 ABUT INTERSECTING ONLY REGION)) NOT COIN EDGE GATE_WE
GT_3e {
@ Space between large GT and GATE when the channel length ? 0.08 m. is >= 0.93um.
@ The large GT definition:GT area ? 630 m2 and within regions of density > 70% in window 30 m x 30 m, 
@ stepping 15 m. Dummy poly doesn?t  be included the density check.
  Density_region = DENSITY GTi > 0.7 WINDOW 30 STEP 15
  Large_GT = (AREA GT_all >= 630) INSIDE Density_region
  GATE_check = GATE WITH EDGE (LENGTH GATE_LE <= 0.08)
  EXT Large_GT GATE_check < 0.93 ABUT<90 SINGULAR REGION
}

SRGT_3 {
@ Space between two poly on field is 0.07
  X = (GT NOT AA) COIN EDGE GT
  OUT1 = EXT X < 0.07 ABUT<90 REGION
  OUT2 = EXT GT <= 0.001 ABUT<90 SINGULAR REGION
  (OUT1 OR OUT2) NOT OUTSIDE INST 
}
GT_4 { 
@ Space between AA and poly on field oxide is 0.03
  X =EXT AA GT_all < 0.03 ABUT==0 SINGULAR REGION
  X OUTSIDE INST
}
/*SRGT_4 {
@ Space between AA and non-floating poly on field oxide is 0.01
 X = EXT AA (GT NOT (FTGT OR INDMY)) < 0.01 ABUT<90 SINGULAR REGION
 X NOT OUTSIDE INST 
}*/
//skip SRGT.4
GT_5 {
@ Extension of AA outside of Real GATE is 0.06, excluding LDMOS and within inductor area(layer INDMY)
  ENC (Real_GATE NOT (LDBK OR INDMY)) ( AA OUTSIDE INST)  < 0.06 ABUT>0<90 SINGULAR REGION
}
GT_5a_R_OFF {
@ Extension of AA outside of Real GATE is >= 0.07. 
@ Exclude gate within LDMOS region (layer: LDBK) and within inductor area (layer: INDMY).
  ENC (Real_GATE NOT (LDBK OR INDMY)) ( AA OUTSIDE INST)  < 0.07 ABUT>0<90 SINGULAR REGION
}

SRGT_5 {
@ Extension of AA outside of Real GATE is 0.045
  X =ENC Real_GATE AA < 0.045 ABUT>0<90 SINGULAR REGION
  X NOT OUTSIDE INST
}
GT_head = CONVEX EDGE GT ANGLE1 >89.9<90.1 ANGLE2>89.9<90.1 WITH LENGTH>0.001
GT_6 {
@ Extension of poly outside of AA to form poly end-cap is 0.09. Waive within LDBK area
 err= ENC (AA  COIN EDGE GATE) GT_head< 0.09 ABUT<90 REGION OPPOSITE
 err1=err NOT WITH EDGE ((err NOT COIN EDGE GT) NOT COIN EDGE GATE)
 ((err1 INSIDE GT ) NOT (LDBK OR INDMY)) OUTSIDE INST 
}

GT_6a_R_OFF {
@ Extension E of GT outside of AA to form poly end-cap is 0.11.  The GT to L shape AA(in the same MOS) space S < 0.1um.  The L shape AA height h > 0.02um.
@ This rule is not applied for (DNSRAM OR LRSRAM) OR D2SRAM) OR RFSRAM) covered region.
AA_L1  =CONVEX EDGE AA ANGLE1 == 270 ANGLE2 ==90 WITH LENGTH >0.02
AA_L =  AA_L1 NOT COIN EDGE (AA TOUCH EDGE GATE)
S1 = CONVEX EDGE (AA OR GT) ANGLE1 == 270 ANGLE2 == 270 WITH LENGTH <0.1
S = S1 COIN EDGE AA
SL_CORNER=EXT S AA_L< 0.002  ABUT==90 INTERSECTING ONLY REGION
S_region =( EXPAND EDGE  S INSIDE BY 0.001 EXTEND BY 0.001 ) INTERACT SL_CORNER
err =ENC (GATE TOUCH EDGE S_region)  GT_head   < 0.11 ABUT<90 REGION OPPOSITE
err1=err NOT WITH EDGE ((err NOT COIN EDGE GT) NOT COIN EDGE GATE)
(err1 INSIDE GT) OUTSIDE SRAM  
}

GT_6b_R_OFF {
@ Extension of poly outside of AA to form poly end-cap is >= 0.1um.
@ Exclude inside inductor (layer: INDMY) and exclude inside LDMOS (layer: LDBK).
  X = ENC AA GT < 0.1 ABUT<90 SINGULAR REGION
  X NOT INSIDE (INDMY OR LDBK)
}
SRGT_6 {
@ Extension of non-floating poly outside of AA to form poly end-cap is 0.055
@ area interacted with rectangle contact need not follow this rule
  X = ENC (AA COIN EDGE GATE) (GT NOT FTGT)  < 0.055 ABUT<90 REGION
  (X NOT INTERACT RECT) NOT OUTSIDE INST
}
/*
GT_7 {
@ (poly_end with length < 0.120) minimum space to (poly_end with length < 0.120)
@ (head to head space)  with run length > 0 must be is 0.1.
  X = EXT GT_end_head < 0.1 ABUT<90 REGION OPPOSITE
  X OUTSIDE INST
}
*/
SRGT_7 {
@ (poly_end with length < 0.120) minimum space to (poly_end with length < 0.120),excluding floating poly
@ (head to head space) must be > 0.07
@ The head to head with run length > 0.
//  X = EXT GT_end_head < 0.07 ABUT<90 REGION OPPOSITE
//  (X NOT OUTSIDE INST) NOT INTERACT FTGT
  POLY_end = CONVEX EDGE (GT NOT FTGT)  ANGLE1 ==90  LENGTH1 >=0.08 ANGLE2 ==90  LENGTH2 >=0.08 WITH LENGTH < 0.12
  (EXT POLY_end < 0.07 ABUT<90 REGION OPPOSITE) NOT OUTSIDE INST
}
/*
GT_8 {
@ (poly_end with length < 0.120) minimum space to poly (head to side) must be > 0.1 ,This rule is not applicable for SRAM region check.
  X = EXT GT_end_head GT_nonend < 0.1 ABUT<90 REGION
  X OUTSIDE INST
}
*/
GT_8a{
@ Space between GT line end to line (Dh) or GT line to line (Ds) when the layout structures meet the conditions of below: (Waive the GT small extrusion F<0.04m)
@ 1. GT line end definition: GT width W<0.065um
@ 2. Runlength of GT line to line or GT line to end: E1>=-0.03um
@ 3. Any one edge distance from the corner of the two edges: K1 <0.065um
@ Any one of Dh or Ds meet this rule value is ok.
@ This rule is not applicable for SRAM region check.		0.11
LINE_END = CONVEX EDGE GT_all ANGLE1 ==90 LENGTH1 >=0.04 ANGLE2  ==90 LENGTH2  >=0.04 WITH LENGTH  < 0.065
LINE_END_SHAPE = EXPAND EDGE LINE_END INSIDE BY 0.034
LINE_SIDE = (GT_all COIN EDGE LINE_END_SHAPE ) NOT COIN EDGE LINE_END
LINE_END_EXP = EXPAND EDGE LINE_END INSIDE BY 0.001 EXTEND BY 0.031
LINE_SIDE_EXP = EXPAND EDGE LINE_SIDE INSIDE BY 0.001 EXTEND BY 0.031
LINE_END_1 = LINE_END_EXP TOUCH EDGE LINE_END
LINE_SIDE_1 = LINE_SIDE_EXP TOUCH EDGE LINE_SIDE
E1 = EXT [LINE_END_1] GT_all < 0.11 OPPOSITE PERP ALSO OBTUSE ALSO
E2 = EXT [LINE_SIDE_1] GT_all < 0.11  OPPOSITE PERP ALSO OBTUSE ALSO
LINE_END_E1 = LINE_END_1 TOUCH EDGE E1
LINE_SIDE_E2 = LINE_SIDE_1 TOUCH EDGE E2
GT_CORNER = INT LINE_END_E1 LINE_SIDE_E2 <= 0.002 ABUT==90 REGION
(LINE_END_SHAPE INTERACT GT_CORNER) OUTSIDE INST
}
/*SRGT_8 {
@ (poly_end with length < 0.120) minimum space to poly (head to side) must be > 0.072,excluding floating poly
   X = GT AND AA 
  GT_nonend = GT NOT COIN EDGE GT_end_head1
   GT_end = ENC AA GT < 0.12 OPPOSITE REGION
   GT_end_head = GT_end COIN EDGE ((GT INTERACT X) NOT TOUCH EDGE X)
   GT_end_head1 = (GT INTERACT X) NOT TOUCH EDGE X
  Y = EXT GT_end_head GT_nonend < 0.072 ABUT<90 REGION
 (Y NOT OUTSIDE INST) NOT INTERACT FTGT
 }*/
GT_9 {
@ For GT channel length < 0.06, range of Real gate space to (GT or GTDUM) 0.12~0.33
@ The (GT or GTDUM) parallel to Real gate for GT.9 covers channel width >= 67% .
 X0= (Real_GATE OUTSIDE INST) INSIDE EDGE ACT
 X = INT X0 < 0.06 ABUT<90 OPPOSITE REGION
 Y = EXT X (GT OR GTDUM) < 0.12 ABUT<90 OPPOSITE REGION
 Z1 = EXPAND EDGE X0 OUTSIDE BY 0.331
 Z2 = Z1 NOT Real_GATE
 Z4 = EXT X (GT OR GTDUM) <= 0.33 ABUT<90 OPPOSITE REGION 
 Z5 = ((Z2 NOT INTERACT Z4)  INTERACT X ) OR Y

 B0 = Real_GATE INSIDE EDGE ACT
  B1 = INT [B0] < 0.06 ABUT<90 OPPOSITE 
  B2 = EXT B1 (GT OR GTDUM) >= 0.12 <= 0.33 ABUT<90 OPPOSITE EXCLUDE SHIELDED 4
  B3 = DFM PROPERTY B1 B2 OVERLAP ABUT ALSO MULTI SPLIT
  [prop1 = EC(B2)/LENGTH(B1)] < 0.67
 B4= EXPAND EDGE B3 OUTSIDE BY 0.1 
 ((Z5 OR B4) OUTSIDE INST) OUTSIDE OTPMK1
}


GT_10 {
@ For GT channel length >= 0.06, minimum Real gate space to (GT or GTDUM) is 0.13
@ PFET gate minimum space over AA is 0.13
  X = LENGTH (ACT INSIDE EDGE (GT OUTSIDE INST))>=0.06
  Y = Real_GATE WITH EDGE X  
   EXT Y (GT OR GTDUM) < 0.13 ABUT<90 OPPOSITE  REGION
}
SRGT_10 {
@ For GT channel length >= 0.06, minimum Real gate space to (GT or GTDUM) is 0.12
  X = LENGTH (ACT INSIDE EDGE (GT NOT OUTSIDE INST))>=0.06
  Y = Real_GATE WITH EDGE X  
  EXT Y (GT OR GTDUM ) < 0.12 ABUT<90 OPPOSITE  REGION
}
/*
GT_13 {
@ poly minimum overlap past AA is 0.09,when poly to AA inner vertex distance < 0.060
  gtextaa = ENC (AA NOT INSIDE INST) (GT NOT INSIDE INST) < 0.090 OPPOSITE REGION
  gatespcaa = EXT (GATE NOT INSIDE INST) (AA NOT INSIDE INST) < 0.06 ABUT==90 PERP ONLY REGION
  gtextaa WITH EDGE (gtextaa TOUCH EDGE gatespcaa)
}
SRGT_13 {
@ poly minimum overlap past AA is 0.05,when poly to AA inner vertex distance < 0.060
  gtextaa = ENC (AA AND INST) (GT AND INST) < 0.050 OPPOSITE REGION
  gatespcaa = EXT (GATE AND INST) (AA AND INST) < 0.06 ABUT==90 PERP ONLY REGION
  gtextaa WITH EDGE (gtextaa TOUCH EDGE gatespcaa)
}

GT_16 {
@ Poly maximum density(%) with 25um tiling withing whole GDS aread is 70(Max. density value)
  DENSITY (GTi OR GTDUM) > 0.70 WINDOW 25 STEP 12.5 BACKUP PRINT density_report_GT16.log
}*/
GT_17 {
@ minimum area is 0.012
@ SRGT_17, minimum area is 0.012
  AREA GT_all < 0.012
}
GT_17a_R_OFF {
@ GT area when GT all of edge length < 0.21 m is >= 0.055um2.
  GT_ignore = GT_all WITH EDGE (length GT_all >= 0.21)
  AREA (GT_all NOT GT_ignore) < 0.055
}
GT_18 {
@ poly minimum enclosed area is 0.040
  AREA ((HOLES GT_all INNER) NOT GT_all) < 0.040
}
GT_18a_R_OFF {
@ Enclosed area when AA all of inner edge length < 0.21 m is >= 0.077um2.
  GT_ignore = GT_all WITH EDGE (LENGTH (GT_all TOUCH EDGE (HOLES GT_all INNER)) >= 0.21)
  X = (HOLES (GT_all NOT GT_ignore) INNER) NOT GT_all
  AREA X < 0.077 
}
/*
GT_19 {
@ (GT AND AA) area GTAA.  GTAA enclose 200x200um area.  Maximum area for GTAA (um2) 50000
  X = ENCLOSE RECTANGLE GATE 200 200
  AREA X > 50000
}
*/
GT_20l_density {
@ Poly min. density in whole chip is 13% 
  DENSITY_MARK = BORDER NOT MARKS
  CHECK_LAYER = (GTi OR GTDUM) NOT MARKS
  CHECK_REGION = COPY DENSITY_MARK
  X = DENSITY CHECK_LAYER CHECK_REGION [area(CHECK_LAYER)/area(CHECK_REGION)] < 0.13 PRINT density_report_GT20l.log RDB density_report_GT20l.db
  X NOT MARKS
}
GT_20h_density {
@ Poly max. density in whole chip is 40%
  DENSITY_MARK = BORDER NOT MARKS
  CHECK_LAYER = (GTi OR GTDUM) NOT MARKS
  CHECK_REGION = COPY DENSITY_MARK
  X = DENSITY CHECK_LAYER CHECK_REGION [area(CHECK_LAYER)/area(CHECK_REGION)] > 0.40 PRINT density_report_GT20h.log RDB density_report_GT20h.db
  X NOT MARKS
}
GT_20b_density {
@ Poly min. density overlap by DUMBP is 13%, Exclude OCCD,OCOVL region.
  DENSITY_MARK = DUMBP NOT ((MARKS OR OCOVL) OR OCCD)
  CHECK_LAYER = (GTi OR GTDUM) NOT ((MARKS OR OCOVL) OR OCCD)
  CHECK_REGION = COPY DENSITY_MARK
  Z = DENSITY CHECK_LAYER CHECK_REGION [area(CHECK_LAYER)/area(CHECK_REGION)] < 0.13 INSIDE OF LAYER DENSITY_MARK PRINT density_report_GT20b.log  RDB density_report_GT20b.db
  Z NOT ((MARKS OR OCOVL) OR OCCD)
}
/*
GT_20bh {
@ Poly max. density overlap by DUMBP is 40%
  X = GTi OR GTDUM
  Y = COPY DUMBP
  Z = DENSITY X DUMBP [area(X)/area(DUMBP)] > 0.4 INSIDE OF LAYER Y PRINT density_report_GT20bh.log RDB density_report_GT20bh.db
  Z NOT MARKS
}

GT_20c {
@Poly density (including dummy) excluding (DG or TG)is 10%, check window 100x100m with step 50m.
@DRC check with the said window size and rule number and highlight as X.  Y = X not (DG or TG) , Z= (Y area)/(100*100)  
@If Z > 25%, highlight Y for GT density inside of Y smaller than rule value
 
 X =DENSITY (GTi OR GTDUM) < 0.1 WINDOW 100 STEP 50 BACKUP RDB density_report_GT20c1.db
 Y = X NOT (DG OR TG)
 Z= COPY Y
 M = DENSITY Y  [area(Y)/(100*100)]>0.25  INSIDE OF LAYER Z RDB density_report_GT20c2.db
 N = COPY M
 W =DENSITY GTi_ALL M [area(GTi_ALL)/area(M)] < 0.1 INSIDE OF LAYER N BY POLYGON PRINT density_report_GT_20c.log RDB density_report_GT20c.db
 W NOT MARKS
}
GT_20d {
@Poly density (including dummy) in (DG or TG)is 5%, check window 100x100m with step 50m.
@DRC check with the said window size and rule number and highlight as X.  Y = X and (DG or TG) , Z= (Y area)/(100*100) 
@ If Z > 25%, highlight Y for GT density inside of Y smaller than rule value 
X =DENSITY (GTi OR GTDUM) < 0.05 WINDOW 100 STEP 50 BACKUP PRINT density_report_GT.20d.log RDB density_report_GT20d1.db
Y = X AND (DG OR TG) 
 Z= COPY Y
 M = DENSITY Y  [area(Y)/(100*100)]>0.25  INSIDE OF LAYER Z RDB density_report_GT20d2.db
 N = COPY M
  W =DENSITY GTi_ALL M [area(GTi_ALL)/area(M)] < 0.05 INSIDE OF LAYER N BY POLYGON PRINT density_report_GT_20d.log RDB density_report_GT20d.db
 W NOT MARKS
}
*/
GT_21 {
@ No bent Real GATE on AA are allowed 
@ All Real gate patterns on AA have to be orthogonal to AA edge
@ and SRGT_21
  GTEIAA1 = GTEIAA COIN EDGE Real_GATE
  (INT GTEIAA1 < 0.01 ABUT == 90 REGION) NOT OCOVL
  (EXT GTEIAA1 < 0.01 ABUT == 90 REGION) NOT OCOVL
  (INT GTEIAA1 < 0.01 ABUT == 45 REGION) NOT OCOVL
  (EXT GTEIAA1 < 0.01 ABUT == 45 REGION) NOT OCOVL
  (INT GTEIAA1 < 0.01 ABUT == 135 REGION) NOT OCOVL
  (EXT GTEIAA1 < 0.01 ABUT == 135 REGION) NOT OCOVL
  AAEIGT1 = (IN EDGE AA GT) COIN EDGE Real_GATE
  (INT GTEIAA1 AAEIGT1 < 0.01 ABUT!=90 REGION) NOT OCOVL 
}
GT_22 {
@ GT must be enclosed by (SN or SP) except the MOM, GTFUSE and  (HRP AND GT). Exclude floating GT
 X = (((GT NOT FTGT) NOT INTERACT (HRP AND GT)) NOT INTERACT (MOMDMY OR GTFUSE)) NOT (SN OR SP)
 X NOT OCOVL
}
/* This rule is already covered by SP_SN_17.
GT_23 {
@ SN and SP overlap on gate over AA is not allowed
  (GATE AND SN) AND SP
}
*/
GTmergeAA = GT OR AA
U_edge = CONVEX EDGE GTmergeAA ANGLE1 == 270 ANGLE2 == 270
U_edge_ = EXPAND EDGE U_edge INSIDE BY 0.001
AAconer = EXT AA < 0.01 ABUT == 90 INTERSECTING ONLY REGION
GTconer = EXT GT < 0.01 ABUT == 90 INTERSECTING ONLY REGION
GT_24 {
@  L-shaped GT minimum space to AA is 0.04
   LGT_ = U_edge_ TOUCH GTconer == 1
   LGT = U_edge COIN EDGE LGT_
   LENGTH LGT < 0.04
}
GT_24b_R_OFF {
@ If channel length < 0.2um, channel width <= 0.45um, and L-shape GT length ( L >= 0.055um), 
@ space between L-shaped GT to AA in the same MOS is >= 0.05um. 
@ (Waive the violations in SRAM area)
  GATE_check = (GATE WITH EDGE (LENGTH GATE_LE < 0.2)) WITH EDGE (LENGTH GATE_WE <= 0.45)
  GT_AA = (GT OR AA) INTERACT GATE_check
  GT_AA_L = CONVEX EDGE GT_AA ANGLE1 == 270 ANGLE2 == 270 WITH LENGTH < 0.05
  GT_L = (GT_AA_L COIN EDGE GT) NOT COIN EDGE (CONVEX EDGE GT == 0)
  X0 = EXPAND EDGE GT_L INSIDE BY 0.005
  Y = EXT GT < 0.005 ABUT REGION
  Z = GT TOUCH EDGE ((Y WITH EDGE GT_L) NOT COIN EDGE GT_L)
  H = LENGTH Z >= 0.055
  P = EXPAND EDGE H OUTSIDE BY 0.005
  Q = Y INTERACT P
  W = (X0 TOUCH GATE_check) INTERACT Q
  W NOT SRAM
}
GT_24c_R_OFF {
@ If channel length < 0.2um, channel width> 0.45um, and L-shape GT length ( L >= 0.055um), 
@ space between L-shaped GT to AA in the same MOS is >= 0.05um. 
  GATE_check = (GATE WITH EDGE (LENGTH GATE_LE < 0.2)) WITH EDGE (LENGTH GATE_WE > 0.45)
  GT_AA = (GT OR AA) INTERACT GATE_check
  GT_AA_L = CONVEX EDGE GT_AA ANGLE1 == 270 ANGLE2 == 270 WITH LENGTH < 0.05
  GT_L = (GT_AA_L COIN EDGE GT) NOT COIN EDGE (CONVEX EDGE GT == 0)
  X0 = EXPAND EDGE GT_L INSIDE BY 0.005
  Y = EXT GT < 0.005 ABUT REGION
  Z = GT TOUCH EDGE ((Y WITH EDGE GT_L) NOT COIN EDGE GT_L)
  H = LENGTH Z >= 0.055
  P = EXPAND EDGE H OUTSIDE BY 0.005
  Q = Y INTERACT P
  (X0 TOUCH GATE_check) INTERACT Q
}
GT_25 {
@ L-shape AA minimum space to poly(in same transistor) is 0.03
   LAA_ = U_edge_ TOUCH AAconer == 1
   LAA = U_edge COIN EDGE LAA_
   X = LENGTH LAA  <  0.03
   X COIN EDGE (AA TOUCH EDGE GATE)
}
GT_25b_R_OFF {
@ If channel length < 0.2um, channel width <= 0.45um, 
@ space between L-shaped AA to GT in the same MOS is >= 0.05um. 
@ (Waive the violations in SRAM area).
  GATE_check = (GATE WITH EDGE (LENGTH GATE_LE < 0.2)) WITH EDGE (LENGTH GATE_WE <= 0.45)
  GT_AA = (GT OR AA) INTERACT GATE_check
  GT_AA_L = CONVEX EDGE GT_AA ANGLE1 == 270 ANGLE2 == 270 WITH LENGTH < 0.05
  AA_L = (GT_AA_L COIN EDGE AA) NOT COIN EDGE ((CONVEX EDGE AA == 0) NOT TOUCH EDGE GATE)
  X0 = EXPAND EDGE AA_L INSIDE BY 0.005
  Y = EXT AA < 0.005 ABUT REGION
  Z = AA TOUCH EDGE ((Y WITH EDGE AA_L) NOT COIN EDGE AA_L)
  H = LENGTH Z > 0
  P = EXPAND EDGE H OUTSIDE BY 0.005
  Q = Y INTERACT P
  W = (X0 TOUCH GATE_check) INTERACT Q
  W NOT SRAM
}
GT_25c_R_OFF {
@ If channel length < 0.2um, channel width > 0.45um, 
@ space between L-shaped AA to GT in the same MOS is >= 0.05um. 
  GATE_check = (GATE WITH EDGE (LENGTH GATE_LE < 0.2)) WITH EDGE (LENGTH GATE_WE > 0.45)
  GT_AA = (GT OR AA) INTERACT GATE_check
  GT_AA_L = CONVEX EDGE GT_AA ANGLE1 == 270 ANGLE2 == 270 WITH LENGTH < 0.05
  AA_L = (GT_AA_L COIN EDGE AA) NOT COIN EDGE ((CONVEX EDGE AA == 0) NOT TOUCH EDGE GATE)
  X0 = EXPAND EDGE AA_L INSIDE BY 0.005
  Y = EXT AA < 0.005 ABUT REGION
  Z = AA TOUCH EDGE ((Y WITH EDGE AA_L) NOT COIN EDGE AA_L)
  H = LENGTH Z > 0
  P = EXPAND EDGE H OUTSIDE BY 0.005
  Q = Y INTERACT P
  (X0 TOUCH GATE_check) INTERACT Q
}
#IFDEF SRAM_GT_DIRECTION V
GT_26 {
@ All memory cell transistor(transistors within INST layer),
@ gate GT direction should be unidirectional in one chip.
 X = (((GT INTERACT CT) NOT OUTSIDE INST) INSIDE EDGE AA) COIN EDGE GATE
 Y = ANGLE X != 90
 EXPAND EDGE Y INSIDE BY 0.01
}
#ENDIF
#IFDEF SRAM_GT_DIRECTION H
GT_26 {
@ All memory cell transistor(transistors within INST layer),
@ gate GT direction should be unidirectional in one chip.
 X = (((GT INTERACT CT) NOT OUTSIDE INST) INSIDE EDGE AA) COIN EDGE GATE
 Y = ANGLE X != 0
 EXPAND EDGE Y INSIDE BY 0.01
}
#ENDIF
GT_27 {
@ Bent 45 deg GT min width is 0.16
X = ANGLE GT_all ==45
INT X <0.16 ABUT<90 REGION 
}
GT_28 {
@ The space between GT to bent 45 degree GT is >= 0.16um.
@ This rule is not applied for LOGO region.
X = ANGLE GT_all ==45
(EXT GT_all X <0.16  ABUT<90 REGION SPACE) NOT LOGO
}
GT_29 {
@ The poly length between two CTs (the two CTs on same poly), when the poly width <0.08um is <= 20um.
@ This rule isn?t applicable for ESDIO2, ESDHV region.

  GT_CHECK = (WITH WIDTH GT < 0.08) ENCLOSE CT > 0
  X = SIZE CT BY 10 INSIDE OF GT_CHECK STEP 0.02
  Y = GT_CHECK INTERACT X > 1
  Y NOT (ESDIO2 OR ESDHV)
}
GT_30 {
@ The length from the any point inside poly GATE to the nearest CT on GATE poly, when the poly width <0.08um is <= 65um.
@ This rule isn?t applicable for ESDIO2, ESDHV region.
 X = GATE WITH EDGE (LENGTH GATE_LE < 0.08)
 Y = (GT INTERACT X) INTERACT CT
 Z0 = SIZE CT BY 65 INSIDE OF Y STEP 0.065
 Z1 = (GATE INTERACT Y) NOT INSIDE Z0
 Z1 NOT (ESDIO2 OR ESDHV)
}
GT_31_density {
@ (AA or poly) local density is >= 0.05%(including dummy).
@ 1. Checked window size: 20 m x 20 m, stepping 10 m. Excluded: DUMBA/DUMBP/RESNW/LOGO/INDMY region. 
@ 2. The rule is applied while the checked region width is >= 5um.
  AA_OR_GT = AAi_all OR GTi_all
  DENSITY_MARK = WITH WIDTH ((((((BORDER NOT DUMBA) NOT DUMBP) NOT RESNW) NOT LOGO) NOT INDMY) NOT MARKS) >= 5 
  CHECK_LAYER = AA_OR_GT AND DENSITY_MARK
  CHECK_REGION = COPY DENSITY_MARK
  DENSITY CHECK_LAYER CHECK_REGION [area(CHECK_LAYER)/area(CHECK_REGION)] < 0.0005 WINDOW 20 STEP 10 BACKUP PRINT density_report_GT_31.log RDB density_report_GT_31.db
}
GT_32_R_OFF {
@ Poly interacting AA must separate at least two AA diffusions(exclude dummy pattern).
@ DRC doesn't check:
@ 1.(DNSRAM OR LRSRAM) OR D2SRAM) OR RFSRAM), LDBK, LOGO and INDMY covered region. 
@ 2.When AA or poly not interact with CT.
/*
 X = GT INTERACT AA
 Y = INT X < 0.005 ABUT INTERSECTING ONLY REGION
 Z = X INTERACT (Y AND AA)
 Z NOT (OR INST LDBK INDMY LOGO)

 H = AA INTERACT GT
 L = INT H < 0.005 ABUT INTERSECTING ONLY REGION
 W = GT INTERACT (L AND GT)
 W NOT INSIDE (OR INST LDBK INDMY LOGO)

 (GT TOUCH AA) NOT (OR INST LDBK INDMY LOGO)
*/
 ERR = ((GT INTERACT CT) AND (AA INTERACT CT)) TOUCH ((AA INTERACT CT) NOT (GT INTERACT CT)) == 1
 ERR NOT (OR SRAM LDBK LOGO INDMY)
}
GT_33_R_OFF {
@ Floating Real Gate is not allowed if the effective source/drain is not connected together.
@ Definition of floating Real Gate:
@ 1.Real Gate without CT on poly.
@ 2.Real Gate with CT on poly but not connect to MOS AA, pickup or PAD.
@ 3.It is not a floating Real Gate if the Real Gate is connected to AA by butted CT in (DNSRAM OR LRSRAM) OR D2SRAM) OR RFSRAM) covered region.
@ Definition of effective source/drain:
@ Source/drain is connected to different (MOS AA NOT poly), pickup, Real Gate or PAD.
@ This rule is only used to check chip level GDS.
//  ERR = ((GT INTERACT AA) NOT INTERACT CT) INTERACT Real_GATE
//  ERR NOT (INST OR LOGO)
GATE_CONNECT = STAMP Real_GATE BY GT0
FGATE = NET AREA RATIO GATE_CONNECT PTAPi NTAPi PSD_NOT_R NSD_NOT_R MD > 0 [!AREA(PTAPi)*!AREA(NTAPi)*!AREA(PSD_NOT_R)*!AREA(NSD_NOT_R)*!AREA(MD)]
FNSD = NET AREA RATIO NSD_NOT_R PSD_NOT_R GATE_CONNECT PTAPi NTAPi MD > 0 [~(COUNT(NSD_NOT_R) -1)*!AREA(PSD_NOT_R)*!AREA(GATE_CONNECT)*!AREA(PTAPi)*!AREA(NTAPi)*!AREA(MD)]
FPSD = NET AREA RATIO PSD_NOT_R NSD_NOT_R GATE_CONNECT PTAPi NTAPi MD > 0 [~(COUNT(PSD_NOT_R) -1)*!AREA(NSD_NOT_R)*!AREA(GATE_CONNECT)*!AREA(PTAPi)*!AREA(NTAPi)*!AREA(MD)]
ENSD = NSD_NOT_R NOT FNSD
EPSD = PSD_NOT_R NOT FPSD
FNSD_temp = FNSD NOT ((FNSD OR GATE) INTERACT ENSD > 1 BY NET)
FPSD_temp = FPSD NOT ((FPSD OR GATE) INTERACT EPSD > 1 BY NET)
FGATE_final = FGATE NOT INTERACT (OR FNSD_temp FPSD_temp)

(FGATE_final INTERACT NSD_NOT_R > 1 BY NET) NOT MARKS
(FGATE_final INTERACT PSD_NOT_R > 1 BY NET) NOT MARKS
}
GT_34_R_OFF {
@ Distance from poly to a perpendicular AA "U" inside vertex, where the AA vertex distance is ? 0.210 m is >= 0.09um.
  AA_OR_GT = AA OR GT
  X = HOLES AA_OR_GT INNER
  AA_corner = EXT AA < 0.005 ABUT REGION
  AA_GT_corner = EXT AA GT < 0.005 ABUT REGION 
  Y = ((RECTANGLE X) INTERACT AA_corner == 2) INTERACT AA_GT_corner == 2
  Z = Y WITH EDGE (LENGTH (Y COIN EDGE GT) <= 0.21)
  W = (Z COIN EDGE AA) NOT COIN EDGE (CONVEX EDGE AA ANGLE1 == 270 ANGLE2 == 270) 
  LENGTH W < 0.09
}
GT_35_R_OFF {
@ poly minimum overlap past AA when poly to AA inner vertex distance < 0.040um is 0.13
  gtextaa = ENC AA GT < 0.13 OPPOSITE REGION
  gatespcaa = EXT GATE AA < 0.04 ABUT==90 PERP ONLY REGION
  gtextaa  WITH EDGE (gtextaa TOUCH EDGE gatespcaa)
}

/*
SRGT_102 {
@ Two poly segment with width < 0.045 must not share 1 vertex
  EXT ((GT AND INST) WITH WIDTH < 0.045) < 0.01 ABUT == 90 REGION
}

//Skip SRGT_101 : Poly in INST must be same orientation
SRGT_103 {
@ Non-flaoting Poly must devide AA into 2 or more regions
@ area interacted with share contact need not follow this rule
  GATE = (((GT NOT FTGT) AND AA) NOT OUTSIDE INST) NOT INTERACT RECT
  sized_gate = SIZE GATE BY 0.001
  GATE INTERACT (sized_gate AND (AA NOT GT))  < 2
}
*/


//==============================
//  RESP1 - Poly Resistor DRC
//==============================
  
GROUP GRESP1 RESP1_?

RESP1_2 {
@ POLY resistor minimum width is 0.4
  INT (GTR IN EDGE SAB) < 0.4 ABUT<90 REGION
}
/*
RESP1_2R { 
@ POLY resistor minimum width is 0.39
  INT (GTR IN EDGE SAB) < 0.39 ABUT<90 REGION
}
*/
RESP1_3 {
@ POLY resistor minimum length is 0.40
  INT (SAB COIN EDGE GTR) < 0.40 ABUT<90 REGION
}
/*
RESP1_3R {
@ POLY resistor minimum length is 0.80
  INT (SAB IN EDGE GTR) < 0.80 ABUT<90 REGION
}
*/
RESP1_4 {
@ POLY resistor must be orthogonal
  ANGLE GTR >0<90
}
RESP1_5 {
@ CT to SAB minimum space is 0.18
  EXT (CT AND (GT INTERACT GTR)) SAB < 0.18 ABUT<90 SINGULAR REGION
}
RESP1_6 {
@ Extension of RESP1 outside of POLY minimum distance is 0.15
  ENC (GT INTERACT GTR) RESP1 < 0.15 ABUT<90 SINGULAR REGION
}
RESP1_7 {
@ The separation minimum between resistors with un-related implant region is 0.16
@ Un-related implant region: LVT, HVT, SN, SP, ESD1. These regions don?t interact with resistors.
  EXT GTR (SN NOT INTERACT GTR) < 0.16 ABUT<90 SINGULAR REGION
  EXT GTR (SP NOT INTERACT GTR) < 0.16 ABUT<90 SINGULAR REGION
  EXT GTR (ESD1 NOT INTERACT GTR) < 0.16 ABUT<90 SINGULAR REGION
  EXT GTR (LVT NOT INTERACT GTR) < 0.16 ABUT<90 SINGULAR REGION
  EXT GTR (HVT NOT INTERACT GTR) < 0.16 ABUT<90 SINGULAR REGION
}
/*
RESP1_8 {
@ Dog-bone design at the end of POLY resistor for contact pick-up is not suggested
  X = CONVEX EDGE GTR == 1
  EXPAND EDGE X INSIDE BY 0.01
}
*/
RESP1_9 {
@ For POLY resistor, make sure the POLY be covered by SAB and implanted by either SN or SP
  GTR NOT SAB
  (GTR NOT IN SP) NOT IN SN
}
/*
RESP1_10 {
@ POLY SAB resistor with SP must lay on NW
  ((GTR INTERACT SAB) AND SP) NOT NW
}
*/
RESP1_11 {
@ Extension Poly to SAB is 0.3
  ENC SAB (GT INTERACT GTR)< 0.3 ABUT<90 SINGULAR REGION
}
RESP1_12 {
@ Minimum Space RESPl to non-related AA is 0.16
  EXT RESP1 (AA NOT INTERACT RESP1) < 0.16 ABUT<90 SINGULAR REGION
}
RESP1_13 {
@ Minimum Space RESPl to non-related Poly is 0.24
  EXT RESP1 (GT NOT INTERACT RESP1)  < 0.24 ABUT<90 SINGULAR REGION
}
/*
RESP1_14 {
@ If you have N_poly_resistor device, please confirm it with SMIC PIE
  ((RESP1 AND SN) AND SAB ) AND GT
}
*/
RESP1_15{
@ RESP1 and SAB on GT should have coincident edge
X = RESP1 INSIDE EDGE GT
Y = SAB INSIDE EDGE GT
X NOT COIN  EDGE Y
RESP1 ENCLOSE GT
}

//==============================
//  Poly silicide Resistor  DRC
//==============================
  
GROUP GPLRES PLRES_?

GTP =GT AND PLRES

PLRES_1{
@POLY Silicide resistor minimum width is 0.15  
INT GTP < 0.15 ABUT<90 REGION 
}
PLRES_2{
@PLRES can not overlap with RESP1
 PLRES AND RESP1
}
PLRES_3{
@POLY Silicide resistor minimum square number(length/width ratio) >= 1
  X = PLRES INTERACT GT
  Y = GT AND  PLRES
    L = LENGTH Y >0
  L1 = EXPAND EDGE L OUTSIDE BY 0.001 
  W = INSIDE EDGE X GT
  W1 =  EXPAND EDGE W OUTSIDE BY 0.001
  L_RE =L1 NOT W1
  L_EDGE = L_RE COIN EDGE Y
  DFM PROPERTY Y L_EDGE W OVERLAP ABUT ALSO MULTI [WIDTH = LENGTH(W)] >0 [SQUARES = LENGTH(L_EDGE)/LENGTH(W)] < 1
 }
PLRES_4{
@POLY Silicide resistor must be orthogonal
  ANGLE GTP >0< 90
}
PLRES_5{
@CT to PLRES space: Fixed value is 0.01
//(SIZE (CT INSIDE (GT INTERACT GTP)) BY 0.01) NOT TOUCH PLRES
X1 = EXT CT GTP <= 0.07 ABUT<90 REGION OPPOSITE
X2 = EXT CT GTP == 0.01 ABUT<90 REGION OPPOSITE
(X1 NOT (X2 NOT (X2 ENCLOSE CT))) OR (CT INTERACT PLRES)
}
PLRES_6{
@min Extension of PLRES outside of POLY minimum distance is 0.0
 X =GTP TOUCH (PLRES NOT GTP) >1
 Y = PLRES COIN EDGE GT
 Z =EXPAND EDGE Y INSIDE BY 0.001 
 PLRES NOT INTERACT (X OR (PLRES INTERACT Z))
}
PLRES_7{
@The minimum separation between resistors with un-related implant region is 0.16
@ Un-related implant region: LVT, HVT, SN, SP, ESD1. These region don?t interact with resistors.
  EXT GTP (SN NOT INTERACT GTP) < 0.16 ABUT<90 SINGULAR REGION
  EXT GTP (SP NOT INTERACT GTP) < 0.16 ABUT<90 SINGULAR REGION
  EXT GTP (ESD1 NOT INTERACT GTP) < 0.16 ABUT<90 SINGULAR REGION
  EXT GTP (LVT NOT INTERACT GTP) < 0.16 ABUT<90 SINGULAR REGION
  EXT GTP (HVT NOT INTERACT GTP) < 0.16 ABUT<90 SINGULAR REGION
}
PLRES_8{
@For POLY Silicide resistor, make sure the POLY resistor be implanted by either SN or SP. Minimum enclosure by SN or SP is 0.18
 (GTP NOT IN SP) NOT IN SN
 ENC GTP SN <0.18 ABUT<90 SINGULAR REGION
 ENC GTP SP <0.18 ABUT<90 SINGULAR REGION
}
PLRES_9{
@Minimum Space PLRES to non-related AA is 0.16
EXT PLRES AA< 0.16 ABUT>0<90 SINGULAR REGION
}
PLRES_10 {
@Minimum Space PLRES to non-related Poly is 0.24 
EXT PLRES GT< 0.24 ABUT>0<90 SINGULAR REGION
}

/*
//=================================
//  SE - Short Edge Design Rules
//=================================

GROUP GSE SE_?

SE_1 {
@ AA vertex must not be connected to two short edge with length < 0.07
  CONVEX EDGE (LENGTH AA < 0.070) ANGLE1 >=0 ANGLE2 >0
}
SE_2 {
@ Poly vertex must not be connected to two short edge with length < 0.04
  CONVEX EDGE (LENGTH GT < 0.040) ANGLE1 >=0 ANGLE2 >0
}
SE_2R {
@ Poly vertex must not be connected to two short edge w/ length <= 0.07
  CONVEX EDGE (LENGTH GT < 0.070)  ANGLE1 >=0 ANGLE2 >0
}
SE_2a {
@ Poly edge with length < 0.07 um must have at least one neighboring edge with length = 0.07 um
  CONVEX EDGE (LENGTH PC < 0.070)  ANGLE1 >0 ANGLE2 >0
}
SE_3 {
@ SN vertex must not be connected to two short edges with length < 0.14um
  CONVEX EDGE (LENGTH SN < 0.140)  ANGLE1 >=0 ANGLE2 >0
}
SE_4 {
@ M1 vertex must not be connected to two short edges with lengths < 0.07 um
  CONVEX EDGE (LENGTH M1 < 0.070)  ANGLE1 >=0 ANGLE2 >0
}
SE_5a {
@ M2 vertex must not be connected to two short edges with lengths < 0.07 um
  CONVEX EDGE (LENGTH M2 < 0.070)  ANGLE1 >=0 ANGLE2 >0
}
SE_5b {
@ M3 vertex must not be connected to two short edges with lengths < 0.07 um
  CONVEX EDGE (LENGTH M3 < 0.070)  ANGLE1 >=0 ANGLE2 >0
}
SE_5c {
@ M4 vertex must not be connected to two short edges with lengths < 0.07 um
  CONVEX EDGE (LENGTH M4 < 0.070)  ANGLE1 >=0 ANGLE2 >0
}
SE_5d {
@ M5 vertex must not be connected to two short edges with lengths < 0.07 um
  CONVEX EDGE (LENGTH M5 < 0.070)  ANGLE1 >=0 ANGLE2 >0
}
SE_5e {
@ M6 vertex must not be connected to two short edges with lengths < 0.07 um
  CONVEX EDGE (LENGTH M6 < 0.070)  ANGLE1 >=0 ANGLE2 >0
}
SE_5f {
@ M7 vertex must not be connected to two short edges with lengths < 0.07 um
  CONVEX EDGE (LENGTH M7 < 0.070)  ANGLE1 >=0 ANGLE2 >0
}
SE_5g {
@ M8 vertex must not be connected to two short edges with lengths < 0.07 um
  CONVEX EDGE (LENGTH M8 < 0.070)  ANGLE1 >=0 ANGLE2 >0
}
SE_4R {
@ Any M1 vertex touching an M1 edge <= 0.07 um must connect to an M1 edge >= 0.135
  Length (CONVEX EDGE (LENGTH M1 <= 0.135) ANGLE1 >=0  ANGLE2 > 0) <= 0.070
}
SE_5Ra {
@ Any M2 vertex touching an M2 edge <= 0.07 um must connect to an M2 edge >= 0.135
  Length (CONVEX EDGE (LENGTH M2 <= 0.135) ANGLE1 >=0  ANGLE2 > 0) <= 0.070
}
SE_5Rb {
@ Any M3 vertex touching an M3 edge <= 0.07 um must connect to an M3 edge >= 0.135
  Length (CONVEX EDGE (LENGTH M3 <= 0.135) ANGLE1 >=0  ANGLE2 > 0) <= 0.070
}
SE_5Rc {
@ Any M4 vertex touching an M4 edge <= 0.07 um must connect to an M4 edge >= 0.135
  Length (CONVEX EDGE (LENGTH M4 <= 0.135) ANGLE1 >=0  ANGLE2 > 0) <= 0.070
}
SE_5Rd {
@ Any M5 vertex touching an M5 edge <= 0.07 um must connect to an M5 edge >= 0.135
  Length (CONVEX EDGE (LENGTH M5 <= 0.135) ANGLE1 >=0  ANGLE2 > 0) <= 0.070
}
SE_5Re {
@ Any M6 vertex touching an M6 edge <= 0.07 um must connect to an M6 edge >= 0.135
  Length (CONVEX EDGE (LENGTH M6 <= 0.135) ANGLE1 >=0  ANGLE2 > 0) <= 0.070
}
SE_5Rf {
@ Any M7 vertex touching an M7 edge <= 0.07 um must connect to an M7 edge >= 0.135
  Length (CONVEX EDGE (LENGTH M7 <= 0.135) ANGLE1 >=0  ANGLE2 > 0) <= 0.070
}
SE_5Rg {
@ Any M8 vertex touching an M8 edge <= 0.07 um must connect to an M8 edge >= 0.135
  Length (CONVEX EDGE (LENGTH M8 <= 0.135) ANGLE1 >=0  ANGLE2 > 0) <= 0.070
}
*/



//===========================================
//  LVT - Low Vt devices DRC 
//===========================================

GROUP GLVT LVT_?

LVT_1 {
@ LVT minimum width(only check opposite side) is 0.18
  INT LVT < 0.18 ABUT>0<90 OPPOSITE REGION
}
LVT_2 {
@ Minimum Space between two LVT. (with run length > 0 ) is 0.18
  EXT LVT < 0.18 ABUT < 90 REGION OPPOSITE
}
/*
LVT_3 {
@ Minimum Space between LVT and AA (except Pickup AA) is 0.04
  EXT LVT (AA NOT TAP) < 0.04 ABUT<90 REGION
}
*/
LVT_4 {
@ LVT minimum extension outside of Real gate for MOS along source drain direction is 0.14
  Z = Real_GATE INTERACT LVT
  X = Z INSIDE EDGE ACT
  ENC X LVT < 0.14 ABUT<90 REGION OPPOSITE
}
LVT_4a {
@ LVT minimum extension outside of Real gate for MOS along poly direction is 0.08
  Z = Real_GATE INTERACT LVT
  X = ACT TOUCH EDGE Z
  ENC X LVT < 0.08 ABUT<90 REGION OPPOSITE
}
LVT_5 {
@ Minimum space between LVT and Real gate for MOS along source drain direction is 0.14
  X = Real_GATE INSIDE EDGE ACT
  EXT LVT X < 0.14 ABUT<90 REGION OPPOSITE
}
LVT_5a {
@ Minimum Space between LVT and Real gate along poly direction is 0.08
  X = Real_GATE TOUCH EDGE ACT
  EXT X LVT < 0.08 ABUT<90 REGION
}
LVT_6 {
@ Minimum space between LVT to (poly SAB resistor(GT AND RESP1) or AA SAB resistor(AA AND RESAA)) is 0.18
  EXT LVT GTSABR < 0.18 ABUT<90 SINGULAR REGION
  EXT LVT AASABR < 0.18 ABUT<90 SINGULAR REGION
}
LVT_9 {
@ LVT minimum area is 0.19
  AREA LVT < 0.19
}
LVT_10 {
@ LVT minimum enclosed area is 0.19
  AREA ((HOLES LVT INNER) NOT LVT) < 0.19
}
LVT_13 {
@ (LVT overlap AA) overlapping ( DG, VARMOS, PSUB and HVT) is prohibited
  (LVT AND AA) AND (((DG OR VARMOS) OR PSUB) OR HVT) 
}
/*
LVT_14 {
@ Minimum Space between LVT and pickup AA is 0.02
  EXT LVT TAP < 0.02 ABUT<90 REGION
}
*/
/*
LVT_15 {
@ 45-degree edge length is >= 0.5um.
  X = ANGLE LVT >=44.9 <=45.1
  LENGTH X < 0.5
}
*/
//===========================================
//  HVT - High Vt devices DRC
//===========================================

GROUP GHVT HVT_?

HVT_1 {
@ HVT minimum width(only check opposite side) is 0.18
  INT HVT < 0.18 ABUT>0<90 OPPOSITE REGION
}
HVT_2 {
@ Minimum Space between two HVT. (with run length > 0 ) is 0.18
  EXT HVT < 0.18 ABUT < 90 REGION   OPPOSITE
}
/*
HVT_3 {
@ Minimum Space between HVT and AA (except Pickup AA) is 0.04
  EXT HVT (AA NOT TAP) < 0.04 ABUT<90 REGION
}
*/
HVT_4 {
@ HVT minimum extension outside of Real gate for MOS along source drain direction is 0.14
  Z = Real_GATE INTERACT HVT
  X = Z INSIDE EDGE ACT
  ENC X HVT < 0.14 ABUT<90 REGION OPPOSITE
}
HVT_4a {
@ HVT minimum extension outside of Real gate for MOS along poly direction is 0.08
  Z = Real_GATE INTERACT HVT
  X = ACT TOUCH EDGE Z
  ENC X HVT < 0.08 ABUT<90 REGION OPPOSITE
}
HVT_5 {
@ Minimum space between HVT and Real gate for MOS along source drain direction is 0.14
  X = Real_GATE INSIDE EDGE ACT
  EXT HVT X < 0.14 ABUT<90 REGION OPPOSITE
}
HVT_5a {
@ Minimum Space between HVT and Real gate along poly direction is 0.08
  X = Real_GATE TOUCH EDGE ACT
  EXT X HVT < 0.08 ABUT<90 REGION
}
HVT_6 {
@ Minimum space between HVT to (poly SAB resistor(RESP1 AND GT) or AA SAB resistor(RESAA AND AA)) is 0.18
  EXT HVT GTSABR < 0.18 ABUT<90 SINGULAR REGION
  EXT HVT AASABR < 0.18 ABUT<90 SINGULAR REGION
}
HVT_9 {
@ HVT minimum area is 0.19
  AREA HVT < 0.19
}
HVT_10 {
@ HVT minimum enclosed area is 0.19
  AREA ((HOLES HVT INNER) NOT HVT) < 0.19
}
HVT_13 {
@ (HVT overlap AA) overlapping ( DG, VARMOS, PSUB, LVT) is prohibited
  (HVT AND AA) AND (((DG OR VARMOS) OR PSUB) OR LVT)
}
/*
HVT_14 {
@ Minimum Space between HVT and pickup AA is 0.02
  EXT HVT TAP < 0.02 ABUT<90 REGION
}
*/
/*
HVT_15 {
@ 45-degree edge length is >= 0.5um.
  X = ANGLE HVT >=44.9 <=45.1
  LENGTH X < 0.5
}
*/
/*
//===============================
//  NC - SRAM NMOS Implant DRC
//===============================

GROUP GNC NC_?

NC_1 {
@ NC minimum width is 0.18
  INT NC < 0.18 ABUT<90 SINGULAR REGION
}
NC_2 {
@ Minimum space between two NC is 0.18
@ Merge if the space is less than 0.18
  EXT NC < 0.18 ABUT<90 SINGULAR REGION
}
NC_3 {
@ Minimum space between NC and N+AA in PW or P+AA in NW is 0.08, except AA resistor
  X = (PACT NOT (PTAP OR AAR)) NOT TOUCH EDGE NC
  Y = (NACT NOT (NTAP OR AAR)) NOT TOUCH EDGE NC
  EXT NC X < 0.08 ABUT<90 REGION
  EXT NC Y < 0.08 ABUT<90 REGION
}
NC_4_8 {
@ NC minimum extension outside of poly gate for NMOS along source drain direction is 0.18
@ N+AA minimum enclosure by NC if the distance to the poly gate < 0.16um is 0.16
  Z = NGATE INTERACT NC
  X = Z INSIDE EDGE NACT
  A = EXPAND EDGE X INSIDE BY 0.16 OUTSIDE BY 0.16 CORNER FILL
  Y = Z COIN EDGE NACT
  B = EXPAND EDGE Y OUTSIDE BY 0.16 EXTEND BY 0.16
  C = A OR B
  C NOT NC
  ENC X NC < 0.18 ABUT<90 REGION OPPOSITE
}
NC_5 {
@ Space between NC and P-channel poly gate is 0.2
  EXT NC PGATE < 0.20 ABUT<90 SINGULAR REGION
}
NC_6 {
@ Space between NC SAB poly and AA resistor is 0.2
  EXT NC GTR < 0.20 ABUT<90 SINGULAR REGION
  EXT NC AAR < 0.20 ABUT<90 SINGULAR REGION
}
NC_7 {
@ N+AA enclosure by NC if the distance to the poly gate w>0.22um is 0.08
  X = (NACT TOUCH EDGE NGATE) NOT COIN EDGE PACT
  ENC X NC < 0.08 ABUT<90 REGION
}
NC_9 {
@ NC area is 0.10
  AREA NC < 0.10
}
NC_10 {
@ NC minimum enclosed area is 0.10
  AREA ((HOLES NC INNER) NOT NC) < 0.10
}
NC_11 {
@ NC can not overlap with P+ pickup AA or butted P+AA
  NC AND PACT
}
NC_12 {
@ NC shapes must be orthogonal
  ANGLE NC >0<90
}
NC_13 {
@ (NC over AA) over (TG, DG, LVN, VTNH) is prohibited
  (NC AND AA) AND (TG OR DG)
  (NC AND AA) AND (LVN OR VTNH)
}



//===============================
//  PC - SRAM PMOS Implant DRC
//===============================

GROUP GPC PC_?

PC_1 {
@ PC width is 0.18
  INT PC < 0.18 ABUT<90 SINGULAR REGION
}
PC_2 {
@ Space between two PC is 0.18
@ Merge if the space is less than 0.18
  EXT PC < 0.18 ABUT<90 SINGULAR REGION
}
PC_3 {
@ Space between PC and N+AA in PW or P+AA in NW is 0.09, except AA resistor
  X = (PACT NOT (PTAP OR AAR)) NOT TOUCH EDGE PC
  Y = (NACT NOT (NTAP OR AAR)) NOT TOUCH EDGE PC
  EXT PC X < 0.09 ABUT<90 REGION
  EXT PC Y < 0.09 ABUT<90 REGION
}
PC_4_8 {
@ PC extension outside of poly gate for PMOS along source drain direction is 0.18
@ N+AA enclosure by PC if the distance to the poly gate < 0.22um is 0.18
  Z = PGATE INTERACT PC
  X = Z INSIDE EDGE PACT
  A = EXPAND EDGE X INSIDE BY 0.22 OUTSIDE BY 0.22 CORNER FILL
  Y = Z COIN EDGE PACT
  B = EXPAND EDGE Y OUTSIDE BY 0.22 EXTEND BY 0.18
  C = A OR B
  C NOT PC
  ENC X PC < 0.18 ABUT<90 REGION OPPOSITE
}
PC_5 {
@ Space between PC and N-channel poly gate is 0.2
  EXT PC NGATE < 0.20 ABUT<90 SINGULAR REGION
}
PC_6 {
@ Space between PC SAB poly and AA resistor is 0.2
  EXT PC GTR < 0.20 ABUT<90 SINGULAR REGION
  EXT PC AAR < 0.20 ABUT<90 SINGULAR REGION
}
PC_7 {
@ P+AA enclosure by PC if the distance to the poly gate w>0.22um is 0.08
  X = (PACT TOUCH EDGE PGATE) NOT COIN EDGE NACT
  ENC X PC < 0.08 ABUT<90 REGION
}
PC_9 {
@ PC area is 0.10
  AREA PC < 0.10
}
PC_10 {
@ PC minimum enclosed area is 0.10
  AREA ((HOLES PC INNER) NOT PC) < 0.10
}
PC_11 {
@ PC can not overlap with N+ pickup AA or butted N+AA
  PC AND NACT
}
PC_12 {
@ PC shapes must be orthogonal
  ANGLE PC >0<90
}
PC_13 {
@ (PC over AA) over (TG, DG, LVP, VTPH) is prohibited
  (PC AND AA) AND (TG OR DG)
  (PC AND AA) AND (LVP OR VTPH)
}


//============================
//  NC - N-cell Implant DRC
//============================

GROUP GSRNC SRNC_?

SRNC_101 {
@ NC minimum width is 0.272
  INT NC < 0.272 ABUT<90 REGION
}
SRNC_102 {
@ Minimum space between two NC is 0.46
  EXT NC < 0.46 ABUT<90 REGION
}
SRNC_103 {
@ NC min area is 0.114
  AREA NC < 0.114
}
SRNC_104 {
@ NC minimum enclosed area is 0.114
  AREA ((HOLES NC INNER) NOT NC) < 0.114
}



//===============================
//  PC - P-cell Implant DRC
//===============================

GROUP GSRPC SRPC_?

SRPC_101 {
@ PC width is 0.46
  INT PC < 0.46 ABUT<90 REGION
}
SRPC_102 {
@ Space between two PC is 0.272
  EXT PC < 0.272 ABUT<90 REGION
}
SRPC_103 {
@ PC area is 0.114
  AREA PC < 0.114
}
SRPC_104 {
@ PC minimum enclosed area is 0.114
  AREA ((HOLES PC INNER) NOT PC) < 0.114
}
*/

//=======================================
//  SP - P+ S/D implantation DRC
//=======================================

GROUP GSP SP_?

SP_1 {
@ SP minimum width(with run length > 0) is 0.18
  INT SP < 0.18 ABUT<90 REGION OPPOSITE
}
/*SRSP_1 {
@ SP minimum width is 0.135
 X= INT SP < 0.135 ABUT<90 REGION
 X NOT OUTSIDE INST
}*/
SP_2 {
@ Minimum space between two SP(with run length > 0) is 0.18
@ Merge if the space is less than 0.18
  EXT SP < 0.18 OPPOSITE ABUT<90 REGION
}
/*SRSP_2 {
@ Minimum space between two SP is 0.135
 X= EXT SP < 0.135 ABUT<90 REGION
 X NOT OUTSIDE INST
}*/
SP_3a {
@ Minimum space between SP and N+AA in PW (run length > 0.1um) is 0.08, excpet AA resistor
  X = ((NACT OUTSIDE INST) NOT (NTAP OR AAR)) NOT COIN EDGE SP
  X1 = EXT SP X < 0.08 ABUT>0<90 REGION OPPOSITE
  X1 WITH EDGE (LENGTH X1 > 0.1)
}
SP_3b {
@ Minimum space between SP and N+AA in PW (run length <= 0.1um) is 0.05, excpet AA resistor
  X = ((NACT OUTSIDE INST) NOT (NTAP OR AAR)) NOT COIN EDGE SP
  EXT SP X < 0.05 ABUT>0<90 REGION
}
SRSP_3a{
@ Minimum space between SP and N+ AA inside PW is 0.041, except AA resistor. (run length > 0.1um)
  X = (NACT NOT OUTSIDE INST) AND PW
  Y = EXT SP X < 0.041 ABUT>0<90 REGION OPPOSITE
  (Y WITH EDGE (LENGTH Y > 0.1)) NOT OUTSIDE INST 
}
SRSP_3b{
@ Minimum space between SP and N+ AA inside PW is 0.037, except AA resistor. (run length <= 0.1um)
  X = (NACT NOT OUTSIDE INST) AND PW
  Y = EXT SP X < 0.037 ABUT>0<90 REGION OPPOSITE
  Z = Y COIN EDGE SP  
  (Y WITH EDGE (LENGTH Z <=0.1 )) NOT OUTSIDE INST 
}
SP_4{
@ Minimum space between SP and N+ pick-up AA is 0.02
  X = NTAP NOT COIN EDGE (SP INTERACT PACT)
  EXT SP X < 0.02 ABUT<90 REGION
}
// SKip SP.5 : Space between a SP and a butted N+ AA is 0
SP_6 {
@ SP minimum extension outside of Real gate for PMOS along S/D direction is 0.16
  ENC (GT COIN EDGE Real_GATE) SP < 0.16 ABUT<90 REGION OPPOSITE
}
/*SRSP_6 {
@ SP minimum extension outside of poly gate for PMOS is 0.18, excluding floating poly
  ENC (((GT NOT OUTSIDE INST) NOT FTGT) IN EDGE PACT) SP < 0.18 ABUT<90 REGION OPPOSITE
}*/
SP_7a {
@ Minimum space between SP and S/D direction N-channel Real gate is 0.16
  EXT SP (GT COIN EDGE Real_NGATE) < 0.16 ABUT<90 REGION OPPOSITE
}
/*SRSP_7a {
@ Minimum space between SP and S/D direction N-channel poly gate is 0.18, excluding floating poly
 SD = ((AA INTERACT GT) NOT GT) INTERACT CT 
 X = EXT SP (((GT NOT OUTSIDE INST) NOT FTGT) IN EDGE NACT) < 0.18 ABUT<90 REGION OPPOSITE
 X INTERACT SD
}*/

SP_7b {
@ Minimum space between SP and non-S/D direction N-channel Real gate is 0.08um.
@ This rule is not applied for (DNSRAM OR LRSRAM) OR D2SRAM) OR RFSRAM) covered region.
X=  EXT SP  Real_NGATE  < 0.08 ABUT<90 SINGULAR REGION
X OUTSIDE SRAM
}

LAYER MAP 999 DATATYPE 1118 9998
LAYER EMPTY2 9998
Real_PGATE_EMPTY2 = Real_PGATE OR EMPTY2
PSD_EMPTY2 = PSD OR EMPTY2
NTAP_EMPTY2 = NTAP OR EMPTY2
CONNECT Real_PGATE_EMPTY2 PSD_EMPTY2
CONNECT PSD_EMPTY2 NTAP_EMPTY2
SP_7c {
@ A butted N+ pick-up AA space to PMOS Real gate in the same AA is >= 0.23
EXT (NTAP_EMPTY2 TOUCH PSD_EMPTY2) Real_PGATE_EMPTY2 <0.23 ABUT<90 SINGULAR REGION CONNECTED
}
/*SRSP_7b {
@ Minimum space between SP and non-S/D direction N-channel poly gate is 0.038
@ Minimum space between SP outter vertex and non-S/D direction N-channel poly gate outter vertex is 0.037
  X =EXT SP NGATE < 0.038 ABUT<90 REGION OPPOSITE
  X NOT OUTSIDE INST 
  Y = EXT SP NGATE < 0.037 ABUT<90 REGION CORNER TO CORNER
  Y NOT OUTSIDE INST 
}
SP_8a {
@ Minimum space between SP on a butted AA and poly gate edge in case the
@ extending of butted P+ AA is less than 0.16 (h<0.16) in PW is 0.16
  NGTL = NACT INSIDE EDGE GT
  NAAL = NACT TOUCH EDGE NGTL
  NAAL_EP = EXPAND EDGE NAAL OUTSIDE BY 0.16 EXTEND BY 0.01
  BUTPA_ED = PACT COIN EDGE (NACT NOT NTAP)
  BUTPA_ED_1 = BUTPA_ED INSIDE EDGE NAAL_EP
  BUTSP_1 = (SP INTERACT PW) WITH EDGE BUTPA_ED_1

  GTSP_1 = GT INSIDE EDGE ((NACT NOT NTAP) TOUCH PACT)
  GTSP   = GT TOUCH EDGE GTSP_1

  EXT BUTSP_1 GTSP < 0.16 ABUT<90 REGION
}
SP_8b {
@ Minimum space between a SP on a butted AA and poly gate edge in case the
@ extending of butted P+ AA is larger than 0.16 (h>0.16) in PW is 0.08
  NGTL = NACT INSIDE EDGE GT
  NAAL = NACT TOUCH EDGE NGTL
  NAAL_EP = EXPAND EDGE NAAL OUTSIDE BY 0.16 EXTEND BY 0.01
  BUTPA_ED = PACT COIN EDGE (NACT NOT NTAP)
  BUTPA_ED_1 = BUTPA_ED INSIDE EDGE NAAL_EP
  BUTSP_1 = (SP INTERACT PW) WITH EDGE BUTPA_ED_1

  BUTSP_2 = ((SP INTERACT PW) WITH EDGE BUTPA_ED ) NOT BUTSP_1

  GTSP_1 = GT INSIDE EDGE ((NACT NOT NTAP) TOUCH PACT)
  GTSP   = GT TOUCH EDGE GTSP_1

  EXT BUTSP_2 GTSP < 0.08 ABUT<90 REGION
}*/
SP_8c{
@ A butted N+ pick-up AA (in L shape AA) space to PMOS gate in the same AA is >=0.23, when this butted N+ pick-up AA extrusion:  0 < h < 0.1um 
  PAAL = PACT TOUCH INSIDE EDGE Real_PGATE
  PAAL_EP = EXPAND EDGE PAAL OUTSIDE BY 0.1 EXTEND BY 0.01
  BUTNA_ED = NACT COIN EDGE (PACT NOT PTAP)
  BUTNA_ED_1 = BUTNA_ED INSIDE EDGE PAAL_EP
  BUTSN_1 = (NACT INTERACT NW) WITH EDGE BUTNA_ED_1
  GTSP_1 = (GT INSIDE EDGE (PACT  TOUCH NACT)) COIN EDGE Real_PGATE
  GTSP   = (GT WITH EDGE GTSP_1) TOUCH EDGE Real_PGATE  
 // P = CONVEX EDGE (PACT OR (GT ENCLOSE PGATE)) ANGLE1==270 ANGLE2==270  
 // P_REGION = EXPAND EDGE P OUTSIDE BY 0.1
 EXT BUTSN_1 GTSP < 0.23 ABUT<90 REGION
}
SP_9 {
@ Space between a SP and a N+AA or N+POLY resistor (SN AND ((RESAA AND AA) OR (RESP1 AND GT))is 0.14um.
  EXT SP (AAR AND SN) < 0.14 ABUT<90 SINGULAR REGION
  EXT SP (GTR AND SN) < 0.14 ABUT<90 SINGULAR REGION
 // EXT SP (HRPR AND SN) < 0.16 ABUT<90 SINGULAR REGION
}
SP_10 {
@ P+AA minimum enclosure by SP((not include pick up AA) is 0.08
  X = (PTAP INTERACT GATE) AND VARMOS
  Y = PACT NOT (PTAP NOT X)
  Z = ENC Y SP < 0.08 ABUT >0< 90 SINGULAR REGION
  Z OUTSIDE INST
}
SRSP_10 {
@ P+AA minimum enclosure by SP is 0.038 (not include pick up AA)
  X =ENC (PACT NOT PTAP) (SP NOT COIN EDGE NTAP) < 0.038 ABUT<90 REGION
  X NOT OUTSIDE INST  
}
SP_12 {
@ SP enclosure of P+ pickup AA is 0.02
  X0 = (PTAP INTERACT GATE) AND VARMOS
  X = ((PTAP OUTSIDE INST) NOT X0) NOT COIN EDGE NACT
  ENC X SP < 0.02 ABUT<90 REGION
}
//Skip SRSP.12 : P+ pickup AA minimum enclosure by SP is 0
/*
SP_11 {
@ N+AA minimum enclosure by SN if the distance to the related poly is <w= 0.16 is 0.16
  A = EXPAND EDGE PGTEIAA INSIDE BY 0.16 OUTSIDE BY 0.16 CORNER FILL
  Y = PGATE COIN EDGE PACT
  B = EXPAND EDGE Y OUTSIDE BY 0.16 EXTEND BY 0.16
  C = A OR B
  ENC PACT (SP IN EDGE C) < 0.16 ABUT<90 REGION OPPOSITE
}
*/
//Skip SP.13 : AA enclosure by SP along the edge of butted P+AA/N+AA is 0
SP_14 {
@ P+ AA resistor or P+Poly resistor minimum enclosure by SP is 0.14
@ The resistor here: (SP AND ((RESAA AND AA) OR (RESP1 AND GT))
  ENC (AAR AND SP) SP < 0.14 ABUT<90 SINGULAR REGION
  ENC (GTR AND SP) SP < 0.14 ABUT<90 SINGULAR REGION
}
SP_15 {
@ SP and AA minimum overlap is 0.10
  INT SP AA < 0.10 ABUT>0<90 SINGULAR REGION
}
/*SRSP_15 {
@ SP and AA minimum overlap, SP inner vertex to AA inner vertex is 0.098
 INT (SP NOT OUTSIDE INST) ((AA NOT OUTSIDE INST) NOT TOUCH EDGE SP) < 0.098 ABUT<90 REGION OPPOSITE
}*/
SP_16 {
@ SP minimum area include the connected area within INST is 0.11
  AREA (SP OUT INST) < 0.11
}
SRSP_16 {
@ SP minimum area is 0.072
 X = AREA SP < 0.072
 X NOT OUTSIDE INST 
}
SP_SN_17 {
@ SN and SP overlap is forbidden
  SN AND SP
}
SP_18 {
@ Minimum enclosed area of SP is 0.11
 AREA ((HOLES SP INNER) NOT SP) < 0.11
}
/*
SP_19 {
@ Minimum enclosure of a SP beyond a P+ AA in NW is 0.02
  ENC ((PACT AND NW) NOT COIN EDGE NTAP) SP < 0.02 ABUT<90 REGION
}

SRSP_19 {
@ Minimum enclosure of a SP beyond a P+ AA in NW is 0.0325
  ENC (((PACT NOT OUTSIDE INST) AND NW) NOT COIN EDGE NTAP) SP < 0.0325 ABUT<90 REGION
}

SP_20 { 
@ Minimum AA butted p-well contact enclosure by SP is 0.02
  //INT (PTAP COIN EDGE NACT) PTAP < 0.08 ABUT<90 REGION
   ENC ((PTAP NOT INSIDE INST) NOT COIN EDGE NACT) SP < 0.02 ABUT<90 REGION
}
*/
//Skip SRSP.20 : Minimum overlap of SP and AA butted p-well contact is 0
SP_20a {
@ P+ butted AA in P-well area(the area interact with CT)is >= 0.021um.
  AREA (((((SP CUT AA ) NOT (SP ENCLOSE AA)) AND AA) NOT NW) INTERACT CT) < 0.021
}
/*
SP_21 {
@ N+ butted AA in NW contact extension of SP is 0.08
  INT (NTAP COIN EDGE PACT) NTAP  < 0.08 ABUT<90 REGION
}
SP_21a {
@ N+ butted AA in NW area(the area interact with CT)
 AREA (((((SN CUT AA ) NOT (SN ENCLOSE AA)) AND AA) AND NW) INTERACT CT)<0.03
}
*/
/*
SP_22 {
@ 45-degree edge length is >= 0.5um
  X = ANGLE SP >=44.9 <=45.1
  LENGTH X < 0.5
}
*/

//=================================
//  SN - N+ S/D Implantation DRC
//=================================

GROUP GSN SN_?

SN_1 {
@ SN minimum width(run length > 0) is 0.18
  INT SN  < 0.18 ABUT<90 OPPOSITE REGION
}
/*SRSN_1 {
@ SN width is 0.135
  X =INT SN < 0.135 ABUT<90 REGION
 X NOT OUTSIDE INST 
}*/
SN_2 {
@ Minimum space between two SN (with run length > 0) is 0.18
  EXT SN  < 0.18 OPPOSITE ABUT<90 REGION
}
/*SRSN_2 {
@ Space between two SN is 0.135
 X = EXT SN < 0.135 ABUT<90 REGION
 X NOT OUTSIDE INST 
}*/
SN_3a {
@ Minimum space between SN and P+AA in NW (run length > 0.1um) is 0.08,except AA resistor(RESAA AND AA)
  //X = (PACT NOT (PTAP OR AAR)) NOT TOUCH EDGE SN
  X = ((PACT AND NW) NOT AAR) NOT COIN EDGE SN
  X1 = EXT SN X < 0.08 ABUT>0<90 REGION OPPOSITE
  X2 =X1 WITH EDGE (LENGTH X1 > 0.1)
  X2 OUTSIDE INST 
}
SN_3b {
@ Minimum space between SN and P+AA in NW (run length <= 0.10um) is 0.05, except AA resistor(RESAA AND AA)
  X =((PACT  AND NW) NOT AAR) NOT COIN EDGE SN
  X1 = EXT SN X < 0.05 ABUT>0<90 REGION
   X1 OUTSIDE INST
}
SRSN_3a{
@ Minimum space between SN and P+ AA inside NW is 0.043, except AA resistor. (run length > 0.1um)
  X = ((PACT NOT OUTSIDE INST) AND NW) NOT COIN EDGE SN
  Y = EXT SN X < 0.043 ABUT>0<90 REGION OPPOSITE
  (Y WITH EDGE (LENGTH Y > 0.1)) NOT OUTSIDE INST 
}
SRSN_3b{
@ Minimum space between SN and P+ AA inside NW is 0.038, except AA resistor. (run length <= 0.1um)
  X = ((PACT NOT OUTSIDE INST) AND NW) NOT COIN EDGE SN
  Y = EXT SN X < 0.038 ABUT>0<90 REGION OPPOSITE
  Z = Y COIN EDGE SN  
  (Y WITH EDGE (LENGTH Z <=0.1 )) NOT OUTSIDE INST 
}
SN_4 {
@ Minimum space between SN and P+ pick-up AA is 0.02
  X = (PTAP OUTSIDE INST) NOT COIN EDGE (SN INTERACT NACT)
  EXT SN X < 0.02 ABUT<90 REGION
}
// Skip SRSN.4 : Minimum space between SN and P+ pick-up AA is 0 
// SKip SN.5 : Space between a SN and a butted P+ AA is 0
SN_6 {
@ SN minimum extension outside of Real gate for NMOS along source drain direction is 0.16
  ENC (Real_GATE COIN EDGE GT) SN < 0.16 ABUT<90 REGION OPPOSITE
}
/*SRSN_6 {
@ SN minimum extension outside of Poly gate for NMOS along source drain direction is 0.18, excluding floatin poly
  SD = ((AA INTERACT GT) NOT GT) INTERACT CT
  X = ENC (((GT NOT OUTSIDE INST) NOT FTGT) IN EDGE NACT) SN < 0.18 ABUT<90 REGION OPPOSITE
  X INTERACT SD
}*/
SN_7a {
@ Minimum space between SN and S/D driection P-channel Real gate is 0.16
  EXT SN (GT COIN EDGE Real_PGATE) < 0.16 ABUT<90 REGION OPPOSITE
}
/*SRSN_7a {
@ Minimum space between SN and S/D driection P-channel poly gate is 0.18, excluding floatin poly
  EXT SN (((GT NOT OUTSIDE INST) NOT FTGT) IN EDGE PACT) < 0.18 ABUT<90 REGION OPPOSITE
}*/
SN_7b {
@ Minimum space between SN and Non-S/D driection P-channel Real gate is 0.08.
@ This rule is not applied for (DNSRAM OR LRSRAM) OR D2SRAM) OR RFSRAM) covered region.
 X = EXT SN Real_PGATE < 0.08 ABUT<90 SINGULAR REGION
 X NOT SRAM
}

Real_NGATE_EMPTY2 = Real_NGATE OR EMPTY2
NSD_EMPTY2 = NSD OR EMPTY2
PTAP_EMPTY2 = PTAP OR EMPTY2
CONNECT Real_NGATE_EMPTY2 NSD_EMPTY2
CONNECT NSD_EMPTY2 PTAP_EMPTY2
SN_7c{
@ A butted P+ pick-up AA space to NMOS Real Gate in the same AA is >=0.23
EXT (PTAP_EMPTY2 TOUCH NSD_EMPTY2) Real_NGATE_EMPTY2 <0.23 ABUT<90 SINGULAR REGION CONNECTED
}
/*SRSN_7b {
@ Minimum space between SN and Non-S/D driection P-channel poly gate is 0.043, excluding floatin poly
  EXT SN ((PGATE AND INST) NOT FTGT) < 0.043 ABUT<90 REGION
}
SN_8a {
@ Minimum space between SN on a butted AA and poly gate edge in case the extending of butted N+ AA is less than 0.16 in NW is 0.16
  PGTL = PACT INSIDE EDGE GT
  PAAL = PACT TOUCH EDGE PGTL
  PAAL_EP = EXPAND EDGE PAAL OUTSIDE BY 0.16 EXTEND BY 0.01
  BUTNA_ED = NACT COIN EDGE (PACT NOT PTAP)
  BUTNA_ED_1 = BUTNA_ED INSIDE EDGE PAAL_EP
  BUTSN_1 = (SN INTERACT NW) WITH EDGE BUTNA_ED_1

  GTSN_1 = GT INSIDE EDGE ((PACT NOT PTAP) TOUCH NACT)
  GTSN   = GT TOUCH EDGE GTSN_1
  EXT BUTSN_1 GTSN < 0.16 ABUT<90 REGION
}
SN_8b {
@ Minimum space between SN on a butted AA and poly gate edge in case the extending of butted N+ AA is larger than 0.16 in NW is 0.08
  PGTL = PACT INSIDE EDGE GT
  PAAL = PACT TOUCH EDGE PGTL
  PAAL_EP = EXPAND EDGE PAAL OUTSIDE BY 0.16 EXTEND BY 0.01
  BUTNA_ED = NACT COIN EDGE (PACT NOT PTAP)
  BUTNA_ED_1 = BUTNA_ED INSIDE EDGE PAAL_EP
  BUTSN_1 = (SN INTERACT NW) WITH EDGE BUTNA_ED_1

  BUTSN_2 = ((SN INTERACT NW) WITH EDGE BUTNA_ED ) NOT BUTSN_1

  GTSN_1 = GT INSIDE EDGE ((PACT NOT PTAP) TOUCH NACT)
  GTSN   = GT TOUCH EDGE GTSN_1

  EXT BUTSN_2 GTSN < 0.08 ABUT<90 REGION
}
*/
SN_8c{
@ A butted P+ pick-up AA (in L shape AA) space to NMOS Real Gate in the same AA is >=0.23, when this butted P+ pick-up AA extrusion:  0 < h < 0.1um
  NAAL = NACT TOUCH INSIDE EDGE Real_NGATE
  NAAL_EP = EXPAND EDGE NAAL OUTSIDE BY 0.1 EXTEND BY 0.01
  BUTNA_ED = PACT COIN EDGE (NACT NOT NTAP)
  BUTNA_ED_1 = BUTNA_ED INSIDE EDGE NAAL_EP
  BUTSN_1 = (PACT INTERACT PW) WITH EDGE BUTNA_ED_1

  GTSN_1 = (GT INSIDE EDGE ((NACT NOT NTAP) TOUCH PACT)) COIN EDGE Real_NGATE
  GTSN   = (GT WITH EDGE GTSN_1) TOUCH EDGE Real_NGATE  
  N = CONVEX EDGE (NACT OR (GT ENCLOSE NGATE)) ANGLE1==270 ANGLE2==270  
  N_REGION = EXPAND EDGE N OUTSIDE BY 0.1
  EXT BUTSN_1 GTSN < 0.23 ABUT<90 REGION
}
SN_9 {
@ Minimum space between a SN and a P-type resistor is 0.14um. (SP AND ((RESAA AND AA) OR (RESP1 AND GT))
  EXT SN (AAR AND SP) < 0.14 ABUT<90 SINGULAR REGION
  EXT SN (GTR AND SP) < 0.14 ABUT<90 SINGULAR REGION
  //EXT SN (HRPR INTERACT SP) < 0.16 ABUT<90 SINGULAR REGION
}
/*
SN_10 {
@ N+AA minimum enclosure by SN if the distance to the poly gate is > w=0.16 is 0.08
@ N+ pickup AA minimum enclosure by SN is 0.08
  //ENC SN (NACT NOT COIN EDGE PACT) < 0.08 ABUT<90 REGION
  X = ((NACT NOT NTAP) NOT NWR_SN) NOT COIN EDGE PACT
  A = X COIN EDGE SP
  B = X NOT COIN EDGE SP
  Achk = LENGTH A > 0.08
  ENC Achk SN < 0.08 ABUT<90 REGION
  ENC B SN < 0.08 ABUT<90 REGION OPPOSITE
}
SN_10 {
@ N+AA minimum enclosure by SN(Not apply to AA along S/D direction) is 0.08
  ENC ((NACT NOT INSIDE INST) TOUCH EDGE GATE) (SN NOT COIN EDGE PTAP) < 0.08 ABUT<90 REGION
}
*/
SN_10 {
@ N+AA minimum enclosure by SN(not include pick up AA) is 0.08 Waive for (AA interact RESNW)
  X = (NTAP INTERACT GATE) AND VARMOS
  Y = ((AA NOT INTERACT RESNW) AND SN) NOT (NTAP NOT X)
  Z = ENC Y SN < 0.08 ABUT >0< 90 SINGULAR REGION
  Z OUTSIDE INST
}
SRSN_10 {
@ N+AA minimum enclosure by SN is 0.041 (not include pick up AA)
@ N+AA outter vertex to SN inner vertex is 0.037(Not apply to AA along S/D direction)
  ENC ((NACT NOT OUTSIDE INST) NOT NTAP)  (SN NOT COIN EDGE PTAP) < 0.041 ABUT<90 REGION OPPOSITE
  ENC ((NACT NOT OUTSIDE INST) TOUCH EDGE GATE) (SN NOT COIN EDGE PTAP) < 0.037 ABUT<90 REGION
}
/*
SN_11 {
@ SN minimum extension outside of poly gate for NMOS is 0.22
  //ENC NGTEIAA SN < 0.18 ABUT<90 REGION OPPOSITE
  A = EXPAND EDGE NGTEIAA INSIDE BY 0.16 OUTSIDE BY 0.16 CORNER FILL
  Y = NGATE COIN EDGE NACT
  B = EXPAND EDGE Y OUTSIDE BY 0.16 EXTEND BY 0.16
  C = A OR B
  ENC NACT (SN IN EDGE C) < 0.16 ABUT<90 REGION OPPOSITE
}
*/
SN_12 {
@ N+ pickup AA minimum enclosure by SN is 0.02 Waive for (AA interact RESNW)
  //X = (NTAP NOT SNNR) NOT COIN EDGE PACT
  X0 = (NTAP INTERACT GATE) AND VARMOS
  X = ((NTAP NOT X0) NOT (AA INTERACT RESNW)) NOT COIN EDGE PACT
  ENC X SN < 0.02 ABUT<90 REGION
}
//Skip SN.13 : AA enclosure by SN along the edge of butted P+AA/N+AA is 0
SN_14 {
@ N+AA resistor or N+POLY resistor minimum enclosure by SN is 0.14. The resistor here: (SN AND ((RESAA AND AA) OR (RESP1 AND GT))
  ENC (AAR AND SN) SN < 0.14 ABUT<90 SINGULAR REGION
  ENC (GTR AND SN) SN < 0.14 ABUT<90 SINGULAR REGION
}
SN_15 {
@ SN and AA minimum overlap is 0.10
  INT SN AA < 0.10 ABUT>0<90 SINGULAR REGION
}
SN_16 {
@ SN minimum area include the connected area within INST is 0.11
  AREA (SN OUT INST) < 0.11
}
SRSN_16 {
@ SN minimum area is 0.0823
  X =AREA SN < 0.0823
 X NOT OUTSIDE INST 
}
SN_18 {
@ Minimum enclosed area of SN is 0.11
  AREA (((HOLES SN INNER) NOT SN) OUTSIDE INST) < 0.11
}
SRSN_18 {
@ Minimum enclosed area of SN is 0.0728
 X = AREA ((HOLES SN INNER) NOT SN) < 0.0728
 X NOT OUTSIDE INST 
}
/*
SN_19 {
@ Minimum enclosure of a SN beyond a N+ AA in PW is 0.02
  ENC ((NACT AND PW) NOT COIN EDGE PTAP) SN < 0.02 ABUT<90 REGION
}
SN_20 {
@ Minimum AA butted N-well contact enclosure by SN is 0.02
   ENC (NTAP NOT COIN EDGE PACT) SN < 0.02 ABUT<90 REGION
}
*/
SN_20a {
@ N+ butted AA in N-well area(the area interact with CT)is >= 0.021
  AREA (((((SN CUT AA ) NOT (SN ENCLOSE AA)) AND AA) AND NW) INTERACT CT) < 0.021
}
/*
SN_21 {
@ AA butted p-well contact minimum extension of SN is 0.08
  INT (PTAP COIN EDGE NACT) PTAP < 0.08 ABUT<90 REGION
}
//SN_20a covered by SP_21a
//SN_21a covered by SP_20a
SN_22 {
@ SN minimum width and length if the area touch with gate
  error = INT SN < 0.28 ABUT<90 OPPOSITE REGION
  error INTERACT GATE
}
*/
/*
SN_23 {
@ 45-degree edge length is >= 0.5um
  X = ANGLE SN >=44.9 <=45.1
  LENGTH X < 0.5
}
*/

//=================================
//  SAB - Salicide Block DRC
//=================================

GROUP GSAB SAB_?

SAB_1 {
@ SAB minimum width is 0.20um
  INT SAB < 0.20 ABUT<90 SINGULAR REGION
}
SAB_2 {
@ Minimum space between two SABs is 0.20um
  EXT SAB < 0.20 ABUT<90 SINGULAR REGION
}
SAB_3 {
@ Minimum extension of related AA outside of SAB is 0.2um
  X =ENC SAB AA < 0.20 ABUT<90 SINGULAR REGION
  X NOT OCOVL
}
SAB_4 {
@ Minimum space between SAB and AA is 0.15um
  EXT SAB AA < 0.15 ABUT<90 SINGULAR REGION
}
SAB_5 {
@ Minimum space between SAB and poly Real GATE is 0.24um.
  EXT SAB Real_GATE < 0.24 ABUT<90 SINGULAR REGION
}
SAB_6 {
@ Minimum extension of SAB outside of poly is 0.15um.
  ENC GT SAB < 0.15 ABUT<90 SINGULAR REGION
}
SAB_7 {
@ Minimum space between SAB and CT is 0.18
 X= EXT SAB CT < 0.18 ABUT<90 SINGULAR REGION
 X NOT OCOVL
 (CT AND SAB) NOT OCOVL
}
SAB_8 {
@ Minimum extension of SAB outside of AA is 0.15um.
 X = ENC AA SAB < 0.15 ABUT<90 SINGULAR REGION
 X NOT OCOVL
}
/*
SAB_8a {
@ Extension of SAB outside of AA/poly when SAB width >10um is >= 0.25um.
  SAB_CHECK = SAB WITH WIDTH > 10
  ENC AA SAB_CHECK < 0.25 SINGULAR ABUT < 90 REGION
  ENC GT SAB_CHECK < 0.25 SINGULAR ABUT < 90 REGION
}
SAB_8b {
@ Extension of SAB outside of AA/poly when SAB width < 0.43um is >= 0.25um.
  SAB_CHECK = SAB WITH WIDTH < 0.43
  ENC AA SAB_CHECK < 0.25 SINGULAR ABUT < 90 REGION
  ENC GT SAB_CHECK < 0.25 SINGULAR ABUT < 90 REGION
}
*/
/*
SAB_9 {
@ SAB overlap with SN/SP is 0.28
  INT SN SAB < 0.28 ABUT<90 SINGULAR REGION
  INT SP SAB < 0.28 ABUT<90 SINGULAR REGION
}
*/
SAB_10 {
@ SAB minimum area is 0.20
  AREA SAB < 0.20
}
SAB_10a {
@ SAB minimum enclosed area is 0.37
  AREA ((HOLES SAB INNER) NOT SAB) < 0.37
}
SAB_11 {
@ Minimum space between SAB and ((GT not interacting with SAB) on STI) is 0.2um.
  EXT SAB ((GT NOT INTERACT SAB) NOT AA) < 0.2 ABUT<90 SINGULAR REGION
}
/* This rule is covered by SAB_7 now.
SAB_12 {
@ CT in SAB region is not allowed
  AND CT SAB
}
*/
//Skip SAB.13 and SAB.14
/*
SAB_15 {
@ Minimum resistor poly extension to SAB is 0.3. The resistor: GT interact RESP1
  ENC SAB (GT INTERACT RESP1) < 0.3 ABUT<90 SINGULAR REGION
}
*/
SAB_16_R_OFF {
@ SAB overlap of GATE is not allow(except ESDIO1,ESDIO2,ESDHV,OCOVL region).
  (SAB AND GATE) NOT (OR ESDIO1 ESDIO2 ESDHV OCOVL)
}


//========================
//  CT - Contact DRC
//========================

GROUP GCT CT_?

//SQCT = RECTANGLE (CT NOT OUTSIDE INST) == 0.060 BY == 0.060
SQCT = RECTANGLE CT == 0.060 BY == 0.060
RECT = RECTANGLE CT == 0.060 BY == 0.160

CT_1 {
@CT.1	Fixed CT size (square shape)is 0.06.
    X = RECTANGLE CTi ASPECT ==1
    NOT RECTANGLE X == 0.060 BY == 0.060
}
CT_1a {
@ Non-square CT only allowed inside of [EFUSE, OCOVL, SRAM(INST)]
X = RECTANGLE CTi ASPECT ==1
Y = CT NOT X 
(Y NOT INSIDE (EFUSE OR INST)) NOT OCOVL
}
CT_2 {
@ Minimum space between two contacts is 0.080
  EXT SQCT < 0.080 ABUT<90 SINGULAR REGION
}
CT_2a {
@ Minimum space between two contacts on different net is 0.11
  X = EXT SQCT < 0.11 ABUT<90 REGION NOT CONNECTED
  X OUTSIDE INST
}
SRCT_2a {
@ Minimum space between two contacts on different net is 0.088
  X = EXT SQCT < 0.088 ABUT<90 REGION NOT CONNECTED
  X NOT OUTSIDE INST
}
/*
SRCT.101{
@ CT must be on AA or Poly 
 (SQCT NOT OUTSIDE INST) NOT (AA OR GT)
}*/
SRCT_102{
@ CT min space to V1 on different net is 0.075
X = EXT SQCT V1 <0.075 ABUT<90 REGION NOT CONNECTED
X NOT OUTSIDE INST
}
/*SRCT_105 {
@ CT touching INST distance to CT no touching INST is 0.10
  EXT (SQCT NOT OUTSIDE INST) (CT OUTSIDE INST) < 0.10 ABUT<90 SINGULAR REGION
}*/
CT_array = SIZE ( SIZE (SIZE CT BY 0.090) BY -0.30) BY 0.21
CT_3 {
@ CT array minimum space to CT array for run length > 0.34um is 0.11
@ This rule is not applied for (DNSRAM OR LRSRAM) OR D2SRAM) OR RFSRAM) covered region.
  X = EXT (CT_array OUTSIDE SRAM) < 0.11 ABUT<90 OPPOSITE REGION
  X WITH EDGE (LENGTH X > 0.34)
}
CT_3_R_OFF {
@ CT array space to CT array for run length > 0.34?m is >= 0.18um.
@ CT array is formed by logic operation (((all CTs su0.09) sd0.3) su0.21).
  X = EXT CT_array < 0.18 ABUT<90 OPPOSITE REGION
  X WITH EDGE (LENGTH X > 0.34)
}
/*SRCT_3 {
@ CT array minimum space to CT array for run length > 0.000 um is 0.223
  EXT (CT_array NOT OUTSIDE INST) < 0.223 ABUT<90 OPPOSITE REGION
}*/
CT_3a {
@ Minimum space between two contacts in CT array is 0.08: contact array is larger or equal to 4x4 CT. 
@ Two contact regions whose space is within 0.12um at same M1 are considered to be in the same array.
@ This rule is not applied for (DNSRAM OR LRSRAM) OR D2SRAM) OR RFSRAM) covered region.
  X = (SIZE (CT OUTSIDE SRAM) BY 0.060 OVERUNDER) AND M1
  Y = SIZE X BY 0.235 UNDEROVER
  Z = CT INTERACT Y
  ERR = (EXT Z < 0.08 ABUT<90 SINGULAR REGION) INSIDE M1
  ERR NOT SRAM
}
CT_4 {
@ Minimum space between AA region and contact overlap poly is 0.040
  EXT (INTERCT OUTSIDE INST) AA < 0.040 ABUT<90 SINGULAR REGION
}
CT_4_R_OFF {
@ Space between AA region and contact overlap poly is >= 0.05um.
  EXT (INTERCT OUTSIDE INST) AA < 0.050 ABUT<90 SINGULAR REGION
}
SRCT_4 {
@ Minimum space between AA region and contact overlap poly is 0.032
  EXT ((SQCT NOT OUTSIDE INST) AND GT) AA < 0.032 ABUT<90 SINGULAR REGION
}
CT_5 {
@ 0.9/1.1/1.2V device minimum space between Real gate region and contact overlap AA is 0.040
  EXT (Real_GATE OUTSIDE INST) (ACT_CT OUTSIDE INST) < 0.040 ABUT<90 SINGULAR REGION
}
CT_5_R_OFF {
@ 0.9/1.0/1.1/1.2V device space between Real Gate and contact overlap AA is >= 0.05um.
  EXT (Real_GATE OUTSIDE INST) (ACT_CT OUTSIDE INST) < 0.050 ABUT<90 SINGULAR REGION
}
SRCT_5 {
@ Minimum space between gate region and contact overlap AA is 0.028
 X = EXT GATE (SQCT AND AA) < 0.028 ABUT<90 SINGULAR REGION
 X NOT OUTSIDE INST
}
CT_5a {
@ 1.8/2.5V device minimum space between Real gate(enclosure by TG or DG) to contact overlap AA is 0.080
  EXT (Real_GATE AND (DG OR TG)) ACT_CT < 0.080 ABUT<90 SINGULAR REGION
}
/*
CT_6 {
@ Minimum enclosure of an AA region beyond an AA CT region is 0.005
  ENC (CT INTERACT AA) AA < 0.005 ABUT<90 SINGULAR OUTSIDE ALSO
}
*/
CT_6abd {
@CT must be within AA (if CT touchs AA), and must meet rule (CT.6a or (CT.6b, CT.6c)) and CT.6d.
@ CT.6 CT.6a, CT.6b, CT.6c and CT.6d are not applicable for CT interacts with EFUSE(81;2) 
@The CT here is interacted with M1 and AA intersection.
@ CT enclosure by AA (four sides) >=0.01
@ CT enclosure by AA (exclude pick-up AA) for two opposite sides when either opposite sides<0.01um, >=0.005um >=0.03um.
@ CT enclosure by AA >=0.005
@ This rule is not applied for (DNSRAM OR LRSRAM) OR D2SRAM) OR RFSRAM) covered region.
  (((CT OUTSIDE SRAM) INTERACT AA) NOT AA ) NOT EFUSE
  AAandM1 = ((AA NOT GT) AND M1) INTERACT (CT OUTSIDE SRAM)
  BadCT = RECTANGLE ENCLOSURE ((CT OUTSIDE SRAM) NOT TAP) AA OUTSIDE ALSO
  GOOD 0.01 OPPOSITE 0.01 OPPOSITE 0.01 OPPOSITE 0.01 OPPOSITE
  GOOD 0.03 OPPOSITE 0.005 OPPOSITE  0.03 OPPOSITE 0.005 OPPOSITE 
 (BadCT INTERACT AAandM1)  NOT EFUSE
}
CT_6acd {
@ CT enclosure by AA (four sides) >=0.01
@ CT enclosure by pick-up AA for two opposite sides when either opposite sides<0.01um, >=0.005um.>=0.02um.
@ CT enclosure by AA  >=0.005
@ This rule is not applied for (DNSRAM OR LRSRAM) OR D2SRAM) OR RFSRAM) covered region.
  AAandM1 = ((AA NOT GT) AND M1) INTERACT (CT OUTSIDE SRAM)
  BadCT = RECTANGLE ENCLOSURE ((CT OUTSIDE SRAM) AND TAP) AA   OUTSIDE ALSO
  GOOD 0.01 OPPOSITE 0.01 OPPOSITE 0.01 OPPOSITE 0.01 OPPOSITE
  GOOD 0.02 OPPOSITE 0.005 OPPOSITE  0.02 OPPOSITE 0.005 OPPOSITE
 (BadCT INTERACT AAandM1)  NOT EFUSE
}

/*SRCT_6a {
@ CT touching INST, Minimum CT enclosure by AA is -0.011
  CTintAA = (SQCT NOT OUTSIDE INST) INTERACT AA
  (SIZE CTintAA BY -0.011) NOT AA
}
CT_7 {
@ Minimum enclosure of a poly region beyond a poly CT region is 0.00
  (CT INTERACT GT) NOT GT
}
*/
CT_7ab {
@ CT must be within poly
@ per M1 and poly intersection containing a CT, must meet rule CT.7a or CT.7b
@ Minimum CT enclosure by poly is 0.01
@ Minimum CT enclosure by poly for two opposite sides is 0.02 when the either two opposite sides<=0.01um, >=0um, except EFUSE.
@ This rule is not applied for (DNSRAM OR LRSRAM) OR D2SRAM) OR RFSRAM) covered region.
  (((CT OUTSIDE SRAM) INTERACT GT) NOT GT)  NOT EFUSE
  GTandM1 = (GT AND M1) INTERACT (CT OUTSIDE SRAM)
  BadCT = RECTANGLE ENCLOSURE (CT OUTSIDE SRAM) GT OUTSIDE ALSO
  GOOD 0.01 OPPOSITE 0.01 OPPOSITE 0.01 OPPOSITE 0.01 OPPOSITE
  GOOD 0.02  0.00   0.02  0.00 
 (BadCT INTERACT GTandM1) NOT EFUSE
}
/*SRCT_7a {
@ Minimum CT enclosure by Poly is -0.003
  CTintGT = (SQCT NOT OUTSIDE INST) INTERACT GT
  (SIZE CTintGT BY -0.003) NOT GT
}*/
CT_8 {
@ Minimum CT(on AA) must be fully enclosed by (SN OR SP) is 0.03um.
@ This rule is not applied for OCOVL region.
  (ENC ACT_CT (SN OR SP) < 0.030 ABUT<90 SINGULAR REGION OUTSIDE ALSO) NOT OCOVL
}
/*
CT_9 {
@ Minimum CT(on AA) enclosure by SN is 0.03
  ENC ACT_CT SN < 0.030 ABUT<90 SINGULAR REGION
}
*/
CT_10 {
@ CT overlap (gate or (STI not GT)) region is forbidden.  Waive the CT overlap gate in (LOGO, INDMY, MOMDMY). 
@ Waive the CT overlap STI for (CT straddles STI in INST). Waive rectangle CT in ( INST or EFUSE) violation of this rule.
  X1 = (CT AND (AA AND GT)) OR (CT NOT ((AA OR AADUM) OR GT))
  X2 =  (CT AND GATE) AND ((LOGO OR INDMY) OR MOMDMY)
  X3 =  (CT NOT (AA OR AADUM) ) AND INST
   ((X1 NOT  X2) NOT X3) NOT ((CT NOT SQCT) AND (INST OR EFUSE))
}
/*
CT_11 {
@ AA contact located on SN/SP boundary is forbidden
  (ACT_CT INTERACT SN) INTERACT SP
}
*/
/*
CT_11 {
@ It is not allowed that (CT not outside AA) touches or straddles on (SN or SP) edge
  X =CT NOT OUTSIDE AA
 (X INTERACT SN) NOT (CT INSIDE SN)  
 (X INTERACT SP) NOT (CT INSIDE SP)
}
*/
CT_12 {
@ Non-salicided contacts are not allowed
  (CT AND SAB) NOT OCOVL
}
CT_13 {
@ 45 degree rotated contacts are not allowed.
@ This rule is not applied for OCOVL region.
  (CT WITH EDGE (ANGLE CT > 0 < 90)) NOT OCOVL
}
/*
CT_19_R {
@ Recommend to have redundant CT to prevent high contact resistance:
@ On the resistor connection.
@ Gate Source/Drain, and poly
@ For large transistor, spread the CT necessary for current all over the S/D area.
@ DRC highlight single CT connection
 X = ((HRP AND HRPDMY) AND SAB) AND GT
 X1 =((GT ENCLOSE X ) NOT X) ENCLOSE CT ==1   // HRP
  Z = (RESP1 AND SAB) AND GT 
X2 =((GT ENCLOSE Z ) NOT Z ) ENCLOSE CT ==1   //RESP1
Y = (SAB AND RESAA) AND AA 
X3 =((AA ENCLOSE Y) NOT Y)  ENCLOSE CT ==1 // RESAA
X4 =((AA ENCLOSE AAD) NOT AAD)  ENCLOSE CT ==1 //DIFRES
 X5 =(AA TOUCH NWRSTI) ENCLOSE CT ==1  // RESNWST
X6 =(HOLES (SAB ENCLOSE RESNWAA))  ENCLOSE CT ==1 // RESNWAA
X7= ((GT ENCLOSE GTP) NOT GTP)  ENCLOSE CT ==1 //PLRES
X8=(NSD OR PSD) ENCLOSE CT==1   
X9= ((GT ENCLOSE GATE) NOT GATE) ENCLOSE CT==1
((((((((X1 OR X2) OR X3) OR X4) OR X5) OR X6) OR X7) OR X8) OR X9 ) OUTSIDE SRAM
}*/
CT_20 {
@ CT must be fully covered by M1 and (AA OR GT).
@ This rule is not applied for (DNSRAM OR LRSRAM) OR D2SRAM) OR RFSRAM) covered region.
  (CT NOT (M1 OR (AA OR GT))) NOT SRAM
}
CT_21 {
@ It's not allowed CT overlap with NW, AA, Poly and M1 resistor.
@ For NW, AA, silicide poly resistor, please refer each resistor section definition.
@ Non-silicide poly resistor definition: ((GT AND RESP1) AND SAB)
@ M1 resistor definition: (M1 AND M1R).
  RES = OR RESNWAA NWRSTI AAR AAD (GTR AND SAB) GTP
  CT AND (M1 AND M1R)
  CT AND RES
}

//===========================================
//  SCT - Rectangle SCT in SRAM Layer DRC
//===========================================

GROUP GSRRCT SRRCT_?

SRRCT_101_102 {
@ Rectangle CT width is 0.06
@ Rectangle CT length is 0.16
  ((CT NOT OUTSIDE INST) NOT SQCT) NOT RECT
}
SRRCT_103 {
@ Rectangle CT min space to Rectangle CT is 0.074
  EXT (RECT NOT OUTSIDE INST) < 0.074 ABUT<90 SINGULAR REGION
}
/*SRRCT_104 {
@ Rectangle CT min space to CT no touching INST is 0.073
  EXT RECT (CT NOT INTERACT INST) < 0.073 ABUT<90 SINGULAR REGION
}*/
SRRCT_104c {
@ Rectangle CT min space to  CT INSIDE INST with touching prohibited is 0.07
  EXT (RECT NOT OUTSIDE INST) (CT INSIDE INST) < 0.07 ABUT>0<90 SINGULAR REGION
}
SCT_end = RECT COIN EDGE (LENGTH RECT == 0.06)
SCT_side = RECT NOT COIN EDGE SCT_end
SRRCT_106 {
@ Rectangle CT end min space to AA is 0.133(with run length>0)
  EXT (SCT_end NOT OUTSIDE EDGE INST) AA < 0.133 ABUT<90 REGION OPPOSITE
}
SRRCT_106a {
@ Rectangle CT side min space to AA is 0.069
  EXT (SCT_side NOT OUTSIDE EDGE INST) AA < 0.069 ABUT<90 REGION
}
SRRCT_107 {
@ Rectangle CT end min space to Poly is 0.037
  EXT (SCT_end NOT OUTSIDE EDGE INST) GT < 0.037 ABUT<90 REGION
}
SRRCT_107a {
@ Rectangle CT side min space to Poly is 0.082
  EXT (SCT_side NOT OUTSIDE EDGE INST) GT < 0.082 ABUT<90 REGION
}
SRRCT_108 {
@ Rectangle CT min space to M1 is 0.057
  EXT (RECT NOT OUTSIDE INST) M1 < 0.057 ABUT<90 SINGULAR REGION
}


//==========================================================
// DMACRO / DMACRO for M1_6_6a_6b_6c Mn_6_6a_6b_6c TM_5_6_7
//==========================================================    

DMACRO Mn_6 MTLAY MTLEN MTWID MTSPA {
 MTW  = MTLAY WITH WIDTH > MTWID
 MTSi = EXT  MTW < MTSPA OPPOSITE REGION PARA ONLY
 MTS  = COPY MTSi 
 MTS WITH EDGE (LENGTH MTS > MTLEN)
}

DMACRO Mn_6a MTLAY MTLEN MTWID MTSPA {
 MTW  = MTLAY WITH WIDTH > MTWID
 MTSi = EXT MTLAY [MTW] < MTSPA OPPOSITE PARA ONLY
 MTS  = EXT MTLAY MTW < MTSPA OPPOSITE REGION PARA ONLY
 MTS WITH EDGE (LENGTH MTSi > MTLEN)
}

DMACRO Mn_6b MTLAY MTLEN MTW1 MTW2 MTSPA {
 MTWW1 = MTLAY WITH WIDTH > MTW1
 MTWW2 = MTLAY WITH WIDTH > MTW2
 MTSi  = EXT MTWW1 MTWW2 < MTSPA OPPOSITE REGION PARA ONLY
 MTS   = COPY MTSi
 MTS WITH EDGE (LENGTH MTS > MTLEN)
}

DMACRO Mn_6c MTLAY MTLEN MTW MTSPA {
 MTWW = MTLAY WITH WIDTH > MTW
 MTSi = EXT MTLAY [MTWW] < MTSPA OPPOSITE PARA ONLY
 MTS  = EXT MTLAY MTWW < MTSPA OPPOSITE REGION PARA ONLY  
 MTS WITH EDGE (LENGTH MTSi > MTLEN)
}

DMACRO TM56 MTLAY MTLEN MTWID MTSPA {
 X0_a = MTLAY WITH WIDTH >= MTLEN
 X0 = ENCLOSE RECTANGLE X0_a MTLEN MTWID
 X1 = EXT MTLAY < MTSPA OPPOSITE SPACE REGION PARA ONLY
 X2 = LENGTH X1 >= MTLEN
 X3 = X2 TOUCH EDGE X0
 X4_near = EXPAND EDGE X3 OUTSIDE BY MTWID
 X4_far  = (EXPAND EDGE X3 OUTSIDE BY (MTWID + 0.01)) NOT X4_near
 X5 = X4_near NOT MTLAY
 X6_near = EXT X1 X5 < MTWID OPPOSITE REGION
 X6_far  = EXT X4_far X5 < MTWID OPPOSITE REGION
 X7 = (X4_near NOT X5) NOT (X6_near OR X6_far)
 X7_edge = LENGTH (X7 COIN EDGE X1) >= MTLEN
 X7_expand = EXPAND EDGE X7_edge OUTSIDE BY MTSPA
 (X7_expand AND X1) NOT X5
}

DMACRO TM7 MTLAY MTLEN MTW1 MTW2 MTSPA {
 X0_a = MTLAY WITH WIDTH > MTLEN
 X0_1 = ENCLOSE RECTANGLE X0_a (MTLEN + 0.001) (MTW1 + 0.001)
 X0_2 = ENCLOSE RECTANGLE X0_a (MTW2 + 0.001) (MTLEN + 0.001)
 X1 = EXT X0_1 X0_2 < MTSPA OPPOSITE SPACE REGION PARA ONLY
 X2 = LENGTH X1 > MTLEN
 X3_1 = X2 TOUCH EDGE X0_1
 X3_2 = X2 TOUCH EDGE X0_2
 X4_1_near0 = EXPAND EDGE X3_1 OUTSIDE BY (MTW1 + 0.001)
 X4_1_near = SIZE (X4_1_near0 AND X0_1) BY ((MTLEN-0.1)/2.0) UNDEROVER
 X4_1_far  = (EXPAND EDGE X3_1 OUTSIDE BY (MTW1 + 0.01)) NOT X4_1_near0
 X4_1_real = X4_1_near WITH EDGE (LENGTH X4_1_far > MTLEN)
 X4_2_near0 = EXPAND EDGE X3_2 OUTSIDE BY (MTW2 + 0.001)
 X4_2_near = SIZE (X4_2_near0 AND X0_2) BY ((MTLEN-0.1)/2.0) UNDEROVER
 X4_2_far  = (EXPAND EDGE X3_2 OUTSIDE BY (MTW2 + 0.01)) NOT X4_2_near0
 X4_2_real = X4_2_near WITH EDGE (LENGTH X4_2_far > MTLEN)
 EXT X4_1_real X4_2_real < MTSPA OPPOSITE REGION PARA ONLY
}

MnPIN = ((((((M1PIN OR M2PIN) OR M3PIN) OR M4PIN) OR M5PIN) OR M6PIN) OR M7PIN) OR M8PIN

//=====================
//  M1 - Metal 1 DRC
//=====================

GROUP GM1 M1_?


M1_1 {
@ M1 minimum width is 0.07
  INT M1_all < 0.07 ABUT<90 SINGULAR REGION
}
M1_1_R_OFF {
@ M1 minimum width is 0.08um.
  INT M1 < 0.08 ABUT<90 SINGULAR REGION
}
M1_2 {
@ M1 maximum width is 4.5
  Y1 = M1_all NOT INDMY 
  Y2 = M1_all AND INDMY
  Y1 WITH WIDTH >4.5
  X0= INT Y2 < 4.501 REGION
  X1= Y2 NOT X0
  X2= Y2 WITH WIDTH >4.5
  (X1 INTERACT X2) WITH WIDTH >4.5
}
M1_3 {
@ M1 minimum space is 0.07.
@ This rule is not applied for (DNSRAM OR LRSRAM) OR D2SRAM) OR RFSRAM) covered region.
  X = EXT M1_all < 0.07 ABUT<89.99 SINGULAR REGION
  X OUTSIDE SRAM
}
M1_3_R_OFF {
@ M1 minimum space is 0.08
  X = EXT M1 < 0.08 ABUT<89.99 SINGULAR REGION
  X OUTSIDE SRAM
}
SRM1_3sa {
@ M1 outter vertex to outter vertex distance is 0.064
 X = EXT M1 < 0.064 ABUT<90 SINGULAR REGION CORNER TO CORNER
 X NOT OUTSIDE INST
}
M1_4 {
@ M1 minimum area (The INST connected area apply SRAM design rule) is 0.0196
  AREA (M1_all OUT INST) < 0.0196
}
/*
M1_4a {
@ Area when all of the M1 edge length < 0.17um is >= 0.055um2. 
@ This rule is not applicable for (DNSRAM OR LRSRAM) OR D2SRAM) OR RFSRAM) covered region.
  M1_ignore = M1_all WITH EDGE (length M1_all >= 0.17)
  (AREA (M1_all NOT M1_ignore) < 0.055) NOT SRAM
}
*/
SRM1_4 {
@ M1 minimum area is 0.0168
 X = AREA M1 < 0.0168 
 X NOT OUTSIDE INST
}
M1_5 {
@ M1 minimum enclosed area is 0.2
  AREA ((HOLES M1_all INNER) NOT M1_all) < 0.2
}  

M1_6 {
@ Minimum space between two run length > 0.3 parallel metal lines 
@ with both metal line width is > 0.22 is 0.08
   CMACRO Mn_6 M1i_all 0.3 0.22 0.08
}
M1_6_R_OFF {
@ Minimum space between two (run length > 0.3m) parallel metal lines is 0.12um.
@ with one or both metal line width is > 0.22m.
  CMACRO Mn_6a M1i 0.3 0.22 0.12
}
M1_6a {
@ Minimum space between two length > 0.6 parallel metal lines 
@ with one or both metal line width is > 0.7 is 0.12
  CMACRO Mn_6a M1i_all 0.6 0.7 0.12
}
M1_6b {
@ Minimum space between two length > 0.6 parallel metal lines with one metal
@ line width is > 0.22 and other metal line width is >0.7um is 0.14
  CMACRO Mn_6b M1i_all 0.6 0.22 0.7 0.14
}

M1_6c {
@ Minimum space between two length > 1.5 parallel metal lines with
@ one or both metal line width is >1.5um is 0.3
  CMACRO Mn_6c M1i_all 1.5 1.5 0.3
}

M1_7a {
@ CT must be within M1.
@ This rule is not applied for OCOVL covered region.
 ((CT NOT M1) OUTSIDE INST) NOT OCOVL
}
M1_7a_R_OFF {
@ CT enclosed by M1	is >= 0.025um.
  ENC CT M1 < 0.025 ABUT<90 SINGULAR REGION OUTSIDE ALSO
}
M1_7bc_AA {
@  per (AA NOT GT) and M1 intersection containing a CT must meet rule M1.7b or M1.7c
@ M1 minimum overlap past CT for two opposite sides with the other two sides >=0um is 0.025
@ Or all 4 sides with enlcosure of 0.015 is also correct.
 AAandM1 = ((AA NOT GT) AND M1) INTERACT (CT OUTSIDE INST)
 BadCT = RECTANGLE ENCLOSURE (CT OUTSIDE INST)  M1 SINGULAR OUTSIDE ALSO
 GOOD 0 0.025 0 0.025
 GOOD 0.015 OPPOSITE 0.015 OPPOSITE 0.015 OPPOSITE 0.015 OPPOSITE
 BadCT INTERACT AAandM1
}
M1_7bc_GT {
@  per Poly and M1 intersection containing a CT must meet rule M1.7b or M1.7c
@ M1 minimum overlap past CT for two opposite sides with the other two sides >=0um is 0.025
@ Or all 4 sides with enlcosure of 0.015 is also correct.
 GTandM1 = (GT AND M1) INTERACT (CT OUTSIDE INST)
 BadCT = RECTANGLE ENCLOSURE (CT OUTSIDE INST)  M1 SINGULAR OUTSIDE ALSO
 GOOD 0 0.025 0 0.025
 GOOD 0.015 OPPOSITE 0.015 OPPOSITE 0.015 OPPOSITE 0.015 OPPOSITE
 BadCT INTERACT GTandM1
}
M1_7e {
@ CT minimum enclosure by M1 (M1 width > 0.7um) is 0.03um.
 WM1 = M1 WITH WIDTH > 0.7
 X = ENC CT WM1 < 0.03 OPPOSITE REGION
 Y =  CT INTERACT X
 ENC Y M1 <0.03 OPPOSITE REGION
}

SRM1_7ab {
@ CT minimum within M1 is 0
@ M1 minimum overlap past CT for two opposite sides with either side >=0um and <0.015um is 0.012, not applicable to rectangle contact
  ((CT NOT OUTSIDE INST) NOT RECT) NOT INSIDE M1  
  RECTANGLE ENCLOSURE ((CT NOT OUTSIDE INST) NOT RECT) M1 ABUT <90 SINGULAR
  GOOD  0.0  0.012   0.0  0.012
}
M1_8_density {
@ M1 density (%) in 125um * 125um window with step size 62.5um is 10%
  DENSITY_MARK = BORDER NOT MARKS
  CHECK_LAYER = M1i_all NOT MARKS
  CHECK_REGION = COPY DENSITY_MARK
  X = DENSITY CHECK_LAYER CHECK_REGION [area(CHECK_LAYER)/area(CHECK_REGION)] < 0.10 WINDOW 125 STEP 62.5 BACKUP PRINT density_report_M1_8.log RDB density_report_M1_8.db
  X NOT MARKS
}
M1_8a_density {
@ M1maximum density (%) in 125um *125um window with step size 62.5um is 85%
  DENSITY_MARK = BORDER NOT MARKS
  CHECK_LAYER = M1i_all NOT MARKS
  CHECK_REGION = COPY DENSITY_MARK
  X = DENSITY CHECK_LAYER CHECK_REGION [area(CHECK_LAYER)/area(CHECK_REGION)] > 0.85 WINDOW 125 STEP 62.5 BACKUP PRINT density_report_M1_8a.log RDB density_report_M1_8a.db 
  X NOT MARKS
}
M1_8b_density {
@ M1 maximum density difference(%) between any two 200um adjacent window (stepped without overlapping) is 50%
  X = DENSITY (M1i OR M1DUM) >= 0 WINDOW 200 GRADIENT > 0.5 ABSOLUTE BACKUP PRINT density_report_M1_8b.log  RDB density_report_M1_8b.db
  X NOT MARKS
}
M1_8c_density {
@ M1 maximum density(%) with 840um*840um window is 70%
  DENSITY_MARK = BORDER NOT MARKS
  CHECK_LAYER = M1i_all NOT MARKS
  CHECK_REGION = COPY DENSITY_MARK
  X = DENSITY CHECK_LAYER CHECK_REGION [area(CHECK_LAYER)/area(CHECK_REGION)] > 0.7 WINDOW 840 BACKUP PRINT density_report_M1_8c.log RDB density_report_M1_8c.db 
  X NOT MARKS
}

M1_8d_density {
@ M1 density over the whole chip is >=20%
DENSITY_MARK = BORDER NOT MARKS
CHECK_LAYER = M1i_all NOT MARKS
CHECK_REGION = COPY DENSITY_MARK
X = DENSITY CHECK_LAYER CHECK_REGION [area(CHECK_LAYER)/area(CHECK_REGION)] < 0.2  PRINT density_report_M1_8d.log  RDB density_report_M1_8d.db
X NOT MARKS
}
M1_9 {
@ (M1 at 45degree ) minimum width (run length>0um) is 0.17
   M145 = ANGLE M1_all == 45
   INT M145 < 0.17 OPPOSITE REGION
}	
M1_10 {
@ (M1 at 45degree) minimum space to parallel M1 (run length>0um) is 0.17
  M145 = ANGLE M1_all == 45
  EXT M145 M1_all < 0.17 OPPOSITE REGION PARALLEL ONLY
} 
M1END = CONVEX EDGE M1 ANGLE1 ==90 LENGTH1 >=0.08 ANGLE2  ==90 LENGTH2  >=0.08 WITH LENGTH  <=0.11 
/*
M1.11a {
@Minimum space between an M1 line end to an M1 line (the parallel run length >0um) is 0.07
 EXT M1END M1<0.07 OPPOSITE REGION 
}
M1.11b{
@Minimum space between an M1 line end (with (CT or V1)) to an M1 (the parallel run length >0um) is 0.07, when this M1 line end extend Q from (CT or V1),0.03 <= Q <0.05um 
X1 = EXT M1END  M1 <0.07 OPPOSITE REGION
X2 = M1END COIN EDGE X1 
X3 = ENC (CT OR V1) X2 <0.05 OPPOSITE REGION
X4 = ENC (CT OR V1) X2 <0.03 OPPOSITE REGION
X5 = (CT OR V1) INTERACT X3  
X6 = (CT OR V1) INTERACT X4
X7 = X5 NOT X6
X1 TOUCH (X3 INTERACT X7)
}
M1.11c {
@Minimum space between an M1 line end (with  (CT or V1)) to an M1 (the parallel run length >0um) is 0.1, when this M1 line end extend Q from  (CT or V1),  0 <= Q <0.03um 
X1 = EXT M1END  M1 <0.1 OPPOSITE REGION
X2 = M1END COIN EDGE X1 
X3 = ENC (CT OR V1) X2 <0.03 ABUT<90 OPPOSITE REGION
X4 = (CT OR V1) INTERACT X3
X1 TOUCH (X3 INTERACT X4)
}
M1.12 {
@ M1.12	Minimum space between V1 (the V1 distance E to M1[A] line end, E <= 0.08um) to neighbouring metal M1[B] line is 0.14, the parallel run length of the V1 and the metal M1[B] line >0um; 
@ Waive if there is redundant V1 in the M1[A] and M2 intersection. 	
 X1 =ENC V1 M1END <=0.08 ABUT<90 REGION
 X2 = V1 INTERACT X1 
 X3 = X2 INSIDE (M1 AND M2) 
 X4 = EXT X3 (M1 NOT COIN EDGE M1END) <0.14 ABUT<90 OPPOSITE REGION
 X5 = V1 INTERACT X4
 X6 = V1 NOT X5
 X7 = ((M1 AND M2) ENCLOSE X5) ENCLOSE X6
 (X4 NOT INTERACT X7) INTERACT  (X1 AND X4 )
 X8 = X3 TOUCH INSIDE EDGE  M1END
 X9 = EXT X8 (M1 NOT COIN EDGE M1END) <0.14 ABUT<90 OPPOSITE REGION
 X10 = V1 INTERACT X9 
 X11 = V1 NOT X10
 X12 = ((M1 AND M2) ENCLOSE X10) ENCLOSE X11
 X9 NOT INTERACT X12
}
M1_13 {
@ Minimum space CT to M1 is 0.14, when the M1 and adjacent M1 meet the following conditions:
@ 1.	M1(enclosed CT) width >=0.11um
@ 2.	M1(enclosed CT) to adjacent M1 space <=0.08um
@ 3.	The projection parallel run length of M1(enclosed CT) and adjacent M1 >=0.27um.  For metal extrusion E < 0.12, the portion is treated as same flat metal.
@ Waive if there is redundant CT in the same [(M1 and AA intersection) or (M1 and GT) intersection]
 X0 = EXT M1  X1 <= 0.08 ABUT <90 opposite REGION
 X1 = (M1 ENCLOSE CT) WITH WIDTH >=0.11	
gaps  = ext X1 M1 < 0.2  opposite region exclude shielded
gaps_edge = gaps COIN EDGE X1
edges_check1 = ext X1 M1 < 0.2  opposite exclude shielded
gap1 = dfm property gaps edges_check1 overlap abut also multi
  [ wmax = max(ew(edges_check1)) ]
  [ wmin = min(ew(edges_check1)) ]
  [ l    = sum(ec(edges_check1)) ]>=0.27
  [ -= max(ew(edges_check1)) - min(ew(edges_check1)) ]  <= 0.12
gap = gap1  OR ( X0 with edge (length X0 >=0.27 ))
X2 = (gap INTERACT X1) INTERACT X0
X3 = CT INSIDE ((M1 AND AA) OR (M1 AND GT))
X4 = EXT (X3 INSIDE X1) (M1 INTERACT X2) < 0.14 ABUT <90 OPPOSITE REGION measure all 
X6 = X3  INTERACT X4 
X7 = X3 NOT X6    
X8 = ( ((M1 AND AA) OR (M1 AND GT)) ENCLOSE X6) ENCLOSE X7 
X5 =((((X4 INTERACT M1) INTERACT (X2 AND X4) ) INTERACT X1) INTERACT (X0 AND X4)) NOT INTERACT  X8
X5 OUTSIDE INST 
}
*/
M1_13 {
@ Minimum space CT to M1 is 0.085, when the M1 and adjacent M1 meet the following conditions:
@ 1.	M1(enclosed CT) width >0.12um
@ 2.	M1(enclosed CT) to adjacent M1 space <=0.08um
@ 3.	The projected parallel run length R of M1[A] to M1[B]. R >= 0.27um
@ Waive if there is redundant CT in the same {(M1[A] and AA intersection) or (M1[A] and GT intersection) } 
X = EXT  M1 [X1] <= 0.08  ABUT <90 OPPOSITE  
X0 = EXT M1 X1 <= 0.08 ABUT <90 OPPOSITE REGION 
X01= M1 ENCLOSE CT ==1
X1 = X01 WITH WIDTH >0.12
gap =  X0 with edge (length X >0.27 )
X2 = (gap INTERACT X1) INTERACT X0
X3 = CT INSIDE ((M1 AND AA) OR (M1 AND GT))
X4 = EXT (X3 INSIDE X1) (M1 INTERACT X2) < 0.085 ABUT <90 OPPOSITE REGION measure all
Y = EXPAND EDGE (length X >0.27 ) OUTSIDE BY 0.001
X5 =((((X4 INTERACT M1) INTERACT (X2 AND X4) ) INTERACT X1) INTERACT (X0 AND X4) ) INTERACT (Y AND X4)
X5 OUTSIDE INST
}  
M1_14 {
@ Minimum M1 to M1 space S at M1 line-end. Width W < W0. The minimum space can be line end head to other M1 or line end side to other M1.  Rule check:
@ S >= (Dh or Ds ).  E1 =0.02, K1=0.065, W0=0.09um, Dh=Ds=0.08 in the illustration.
@Schematics Extension 1, Extension 2, and Extension 3:
@1 Three extensions overlaps with other M1=> NG
@2. When Extension 1 and one of the (extension 2 or extension 3) overlap with other M1.  
@The remaining side extension's Ds need to size up from 0.08 to 0.11um. If this remaining extension interact with other M1(include touch edge), NG.
@ Outside of SRAM(INST) area.
@ Waive extrusion F < 0.07.
@Only Highlight either one of the situations:
@1) There is only one CT in the same {(M1[A] and AA intersection) or (M1[A] and GT intersection) } and CT space to M1[B] Sh <0.10um.
@2) there is only one V1 in the M1[A] and M2 intersection, and V1 space to M1[B] Sh<0.10um
INTER_MA= ((M1_all AND GT) OR (M1_all AND AA )) ENCLOSE CT==1
CT_INTER = CT INSIDE INTER_MA
CT_EDGE = ENC  [CT_INTER] LINE_END <0.1 ABUT<90 OPPOSITE
CT_EDGE1 =EXT [CT_EDGE] M1_all <0.1 ABUT<90  OPPOSITE  measure all  
CT_SING =CT_INTER  WITH EDGE CT_EDGE1

INTER_MT= (M1_all AND M2)  ENCLOSE V1==1
V1_INTER = V1 INSIDE INTER_MT
V1_EDGE = ENC  [V1_INTER] LINE_END <0.1 ABUT<90 OPPOSITE
V1_EDGE1 =EXT [V1_EDGE] M1_all <0.1 ABUT<90  OPPOSITE  measure all  
V1_SING =V1_INTER  WITH EDGE V1_EDGE1

LINE_END = CONVEX EDGE (M1_all INTERACT (INTER_MA OR INTER_MT)) ANGLE1 ==90 LENGTH1 >=0.07 ANGLE2  ==90 LENGTH2  >=0.07 WITH LENGTH  < 0.09
LINE_END_SHAPE = EXPAND EDGE LINE_END INSIDE BY 0.044
LINE_SIDE = (M1_all COIN EDGE LINE_END_SHAPE ) NOT COIN EDGE LINE_END
LINE_END_EXP = EXPAND EDGE LINE_END INSIDE BY 0.001 EXTEND BY 0.021
LINE_SIDE_EXP = EXPAND EDGE LINE_SIDE INSIDE BY 0.001 EXTEND BY 0.021
LINE_END_1 = LINE_END_EXP TOUCH EDGE LINE_END
LINE_SIDE_1 = LINE_SIDE_EXP TOUCH EDGE LINE_SIDE
E1 = EXT [LINE_END_1] M1_all < 0.08 OPPOSITE PERP ALSO OBTUSE ALSO
E2 = EXT [LINE_SIDE_1] M1_all < 0.08  OPPOSITE PERP ALSO OBTUSE ALSO
E3 = EXT [LINE_SIDE_1] M1_all <= 0.11  OPPOSITE PERP ALSO OBTUSE ALSO
LINE_END_E1 = LINE_END_1 TOUCH EDGE E1
LINE_SIDE_E2 = LINE_SIDE_1 TOUCH EDGE E2
LINE_SIDE_E3 = LINE_SIDE_1 TOUCH EDGE E3
M1_CORNER = INT LINE_END_E1 LINE_SIDE_E2 <= 0.002 ABUT==90 REGION
M2_CORNER = INT LINE_END_E1 LINE_SIDE_E3 <= 0.002 ABUT==90 REGION
M_CORNER2 = (EXPAND EDGE LINE_END OUTSIDE BY 0.001) INTERACT  M1_CORNER ==2  // 0.08
M_CORNER3 = ((EXPAND EDGE LINE_END OUTSIDE BY 0.001) INTERACT (M2_CORNER NOT M1_CORNER)) INTERACT M1_CORNER   // 0.08 0.11
((LINE_END_SHAPE INTERACT (M_CORNER2 OR M_CORNER3)) INTERACT (CT_SING OR V1_SING) ) OUTSIDE INST
}
M1_15_density {
@ M1 density (including dummy) is >= 1%.
@ Density check window size:  80um*80um, step size 40um
@ DRC only check the region with width of checking window >= 40um 
  DENSITY_MARK = WITH WIDTH (BORDER NOT MARKS) >= 40
  CHECK_LAYER = M1i_all AND DENSITY_MARK
  CHECK_REGION = COPY DENSITY_MARK
  X = DENSITY CHECK_LAYER CHECK_REGION [area(CHECK_LAYER)/area(CHECK_REGION)] < 0.01 WINDOW 80 STEP 40 BACKUP PRINT density_report_M1_15.log RDB density_report_M1_15.db
  (X NOT MARKS) WITH WIDTH >= 40
}
M1_16 {
    @ Maximum M1 area of merged low density windows must follow item (1) and (2).
    @ The definition of low density window: window size 10um*10um, step size: 5um, density <1%
    @ (1) Maximum area of merged low density window <= 6500um2, except merged low density windows width ? 30um.
    @ (2) Maximum area of merged low density window <= 18500um2.
    @ DRC don?t check:
    @ DRC only check the region with width of (checking window NOT above excluding region) >= 5um
    X = DENSITY M1i_all < 0.01 WINDOW 10 STEP 5 BACKUP PRINT density_report_M1_23.log RDB density_report_M1_23.rdb
    Y = X NOT MARKS
    (AREA Y > 6500) WITH WIDTH > 30
    (AREA Y > 18500) WITH WIDTH >= 5
}

DMACRO V67D VLAY M_WIDE M_OTHER {
 X0_M_W = M_WIDE WITH WIDTH > 0.14
 X0_M_AND = ENCLOSE RECTANGLE (M_WIDE AND M_OTHER) 0.07 0.27
 X0_M_AND_W = X0_M_AND INTERACT X0_M_W
 X0_M_AND_W INTERACT VLAY  == 1
}

//========================
//  V1 - Via 1 DRC
//========================

GROUP GV1 V1_?

V1_1 {
@ Fixed V1 size is 0.07
  NOT RECTANGLE V1 == 0.07 BY == 0.07
}
V1_2 {
@ Space between two V1 is 0.07
  EXT V1_all < 0.07 ABUT<90 SINGULAR REGION
}
V1_array = SIZE (SIZE V1 BY 0.05 OVERUNDER) BY 0.150 UNDEROVER
V1_GAP1 = V1_array NOT M1
V1_GAP2 = V1_array NOT M2
V1_3 {
@ Min Space between two V1 regions is 0.09 (with run length>=0) at least in two sides, in case V1 array is larger than or equal to 3x3.
@ Two via areas whose space is within 0.1 um are considered to be in the same array.
  X = EXT (V1 INTERACT V1_array) V1< 0.090 OPPOSITE EXTENDED  0.001  REGION 
   Y =SIZE V1 BY 0.001
  (Y INTERACT  V1_array)  INTERACT (X NOT Y) >2
}
/*
V1_4 {
@ V1_array not touching MOMDMY maximum width is 0.85
  (WITH WIDTH V1_array > 0.85) NOT INTERACT MOMDMY
}
*/
V1_5 {
@ V1 (different net)(outside of SRAM)  minimum space for run length > 0um is 0.1
 X = EXT V1 < 0.1 NOT CONNECTED OPPOSITE REGION
 X OUTSIDE INST
 (EXT V1DUM < 0.1 ABUT<90 SINGULAR OPPOSITE REGION) OUTSIDE INST
 (EXT V1DUM V1 < 0.1 ABUT<90 SINGULAR OPPOSITE REGION) OUTSIDE INST
}
V1_5_R_OFF {
@ V1 (different net) (outside of SRAM) space for run length > 0?m is >= 0.11um.
 X =EXT V1 < 0.11 NOT CONNECTED OPPOSITE REGION
 X OUTSIDE INST
}
V1_5a {
@ V1 (different net) minimum space is 0.09
  EXT V1 < 0.09 NOT CONNECTED REGION 
  EXT V1DUM < 0.09 ABUT<90 SINGULAR REGION
  EXT V1DUM V1 < 0.09 ABUT<90 SINGULAR REGION
}

/*V1.5b {
@ V1 minimum space in different net inside of SRAM is 0.09
   EXT (V1 NOT OUTSIDE INST)< 0.09 NOT CONNECTED REGION
}*/

V1_6abc {
@ V1 must be within M1
@ per M1 and M2 intersection containing a V1, must meet rule V1.6a, V1.6b or V1.6c
@ V1.6a, V1 minimum within M1 is 0.015
@ V1.6b, M1 minimum overlap past V1 for two opposite sides with the other two sides >= 0.01um is 0.02
@ V1.6c, M1 minimum overlap past V1 for two opposite sides with the other two sides >= 0um is 0.03
  V1_all NOT INSIDE M1_all
  M1andM2 = (M1_all AND M2_all) INTERACT (V1_all OUTSIDE INST) 
  BadV1 = RECTANGLE ENCLOSURE (V1_all OUTSIDE INST) M1_all OUTSIDE ALSO
  GOOD 0.015 OPPOSITE 0.015  OPPOSITE 0.015 OPPOSITE 0.015 OPPOSITE
  GOOD 0.02 OPPOSITE 0.01 OPPOSITE  0.02 OPPOSITE 0.01 OPPOSITE
  GOOD 0.03  0  0.03  0 
  BadV1 INTERACT M1andM2
}

SRV1_6ac {
@ M1 minimum overlap past V1 for two opposite sides with the other two sides >= 0um is 0.015
  RECTANGLE ENCLOSURE (V1 NOT OUTSIDE INST) M1 ABUT <90 SINGULAR
  GOOD 0.015 OPPOSITE 0.0 0.015 OPPOSITE 0.0
}
/*V1_6d {
@ V1 touching M1 with width > 0.14um, with at least one redundant V1.
@ This rule only applies to that M1/M2 intersection area can enclose a rectangle of 0.07*0.27.
 CMACRO V67D V1 M1 M2
}*/
V1_7abc {
@ V1 must be within M2
@ M1 and M2 intersection containing a V1, must meet rule V1.7a, V1.7b or V1.7c
@ V1.7a, V1 minimum within M2 is 0.015
@ V1.7b, M2 minimum overlap past V1 for two opposite sides with the other two sides >= 0.01um is 0.02
@ V1.7c, M2 minimum overlap past V1 for two opposite sides with the other two sides >= 0um is 0.03
  V1_all NOT M2_all
  M1andM2 = (M1_all AND M2_all) INTERACT V1_all
  BadV1 = RECTANGLE ENCLOSURE V1_all  M2_all  OUTSIDE ALSO
  GOOD 0.015 OPPOSITE  0.015 OPPOSITE  0.015 OPPOSITE 0.015 OPPOSITE
  GOOD 0.02 OPPOSITE 0.01 OPPOSITE  0.02 OPPOSITE 0.01 OPPOSITE
  GOOD 0.03 0  0.03 0 
  BadV1 INTERACT M1andM2
}
/*SRV1_7 {
@ M2 minimum overlap past V1 for two opposite sides with the other two sides >=0 is 0.025
  RECTANGLE ENCLOSURE (V1 NOT OUTSIDE INST) M2 ABUT <90 SINGULAR
  GOOD 0.025 0.0 0.025 0.0
}
V1_7d {
@ V1 touching M2 with width > 0.14um, with at least one redundant V1.
@ This rule only applies to that M1/M2 intersection area can enclose a rectangle of 0.07*0.27.
 CMACRO V67D V1 M2 M1
}

V1_8 {
@ At least two V1 vias must connect M1 to M2 when the M1 or M2 width is > 0.26um  
  WM1 = WITH WIDTH M1 > 0.260
  WM2 = WITH WIDTH M2 > 0.260
  (M1 AND WM2) INTERACT V1 >0<2
  (WM1 AND M2) INTERACT V1 >0<2
}
*/
V1_8 {
@ At least two V1 vias must connect M1 to M2 when the M1 or M2 width is > 0.26um.
@ This rule is not applied for (DNSRAM OR LRSRAM) OR D2SRAM) OR RFSRAM) covered region
  mx_wide =  WITH WIDTH M1 > 0.260
  my_wide =  WITH WIDTH M2 > 0.260
  mx_my_wide = mx_wide OR my_wide
  vx_612 = (V1 OUTSIDE SRAM) INTERACT mx_my_wide
  mx_my_612 = ((M1 AND M2) OUTSIDE SRAM) ENCLOSE vx_612
  mx_my_612 ENCLOSE V1 < 2
}
V1_9 {
@ At least three V1 vias must connect M1 to M2 when the M1 or M2 width is > 0.55um
  WM1 = WITH WIDTH M1 > 0.550
  WM2 = WITH WIDTH M2 > 0.550
  encVia = V1 INTERACT (WM1 OR WM2)
  ((M1 AND M2) ENCLOSE encVia) ENCLOSE V1 < 3
}
V1_10 {
@ At least four V1 vias must connect M1 to M2 when the M1 or M2 width is > 0.645um
  WM1 = WITH WIDTH M1 > 0.645
  WM2 = WITH WIDTH M2 > 0.645
  encVia = V1 INTERACT (WM1 OR WM2)
  ((M1 AND M2) ENCLOSE encVia) ENCLOSE V1 < 4
}
V1_square = RECTANGLE V1 ASPECT ==1
LAYER MAP 999 DATATYPE 1111 4321
LAYER EMPTY 4321
V1_EMPTY = EMPTY  OR (V1 INSIDE (M1 AND M2) ) 
INTER_EMPTY =EMPTY OR (M1 AND M2)  
CONNECT  V1_EMPTY INTER_EMPTY

V1_16 {
@ At least two V1s with space <=0.16um or three V1s with space <= 0.65um when one of  M1 or M2 with both length and width>0.24um. (exclude SRAM area to check)
X1a = WITH WIDTH M1  >0.24
X1b = WITH WIDTH M2  >0.24
WIDE = X1a OR X1b
X2 = (M1 AND M2) ENCLOSE V1
X3 =  V1 INSIDE X2 
X5c = EXT (V1_EMPTY INSIDE WIDE) V1_EMPTY <=0.16 ABUT<90 REGION CONNECTED   // space of via <= 0.16 
X6c = X2 ENCLOSE X5c   // good intersection with space of Via <= 0.16
X7= ((SIZE X3 BY 0.325) AND X2) ENCLOSE V1 >2
X7c= X2 ENCLOSE X7
X = ((X2 NOT X6c) NOT X7c) ENCLOSE (V1 INSIDE WIDE) // Via_16
X  OUTSIDE INST
}

CONNECT V1 M1
WM1 = M1 WITH WIDTH > 0.24
WM1_EDGE = LENGTH WM1 > 0
WM1_EXP = EXPAND EDGE WM1_EDGE OUTSIDE BY 1.1  
V1_A = V1_square INTERACT WM1_EXP 
CONNECT V1_A M1
CONNECT WM1 M1

WM2 = M2 WITH WIDTH > 0.24
WM2_EDGE = LENGTH WM2 > 0
WM2_EXP = EXPAND EDGE WM2_EDGE OUTSIDE BY 1.1
WM2_L1 = ( M2 not WM2 ) TOUCH WM2
V1_A2 = V1_square INTERACT WM2_EXP
CONNECT V1 M2
V1_A2_EMPTY = EMPTY  OR V1_A2 
M2_EMPTY  =EMPTY OR M2
WM2_EMPTY =EMPTY OR WM2 
CONNECT V1_A2_EMPTY  M2_EMPTY
CONNECT WM2_EMPTY M2_EMPTY

V1_17 {
@ At least two V1s  when either wide metal of M1 or M2 with both length L>0.24um and width W>0.24um, and the distance D<=1.1um away from this wide metal.Exclude non-square Vn and SRAM area.
WM1_L1 = ( M1 NOT WM1 ) TOUCH WM1
M1_ENCWM = (M1 INTERACT WM1) INTERACT V1_A
WM1_VEDGE = EXT [M1_ENCWM]  <1.1 ABUT<90 OPPOSITE NOTCH
WM1_EXT1 = EXT (WM1 COIN EDGE WM1_VEDGE) [V1_A] < 1.1 ABUT>=0 <90  OPPOSITE CONNECTED 
WM1_EXT2 = (EXT WM1 V1_A < 1.1 ABUT>=0 <90  OPPOSITE REGION CONNECTED ) INSIDE M1  
V1_B = V1_square WITH EDGE WM1_EXT1
X1 =(M1 AND M2) ENCLOSE V1_square >1
X2 = ((M1 AND M2)  AND ( WM1_L1 AND WM1_EXP )) NOT X1 
Y0=(M1 AND M2) ENCLOSE V1_square ==1 
Y1 = SIZE (V1_square INTERACT Y0) BY 1.1 INSIDE OF M1 STEP 0.005  
Y2= Y1 INTERACT (Y1 AND WM1)
VSING1= ((X2 INTERACT V1_B ==1) INTERACT Y2) OR ((X2 INTERACT WM1_EXT2) INTERACT V1_A)
VSING1 OUTSIDE INST 


M2_ENCWM = (M2 INTERACT WM2) INTERACT V1_A2
WM2_VEDGE = EXT [M2_ENCWM]  <1.1 ABUT<90 OPPOSITE NOTCH
WM2_EXT1 = EXT (WM2_EMPTY COIN EDGE WM2_VEDGE) [V1_A2_EMPTY] < 1.1 ABUT>=0 <90  OPPOSITE CONNECTED 
WM2_EXT2 = (EXT WM2_EMPTY V1_A2_EMPTY < 1.1 ABUT>=0 <90  OPPOSITE REGION CONNECTED ) INSIDE M2  
V1_B2 = V1_square WITH EDGE WM2_EXT1
X3 = ((M1 AND M2)  AND ( WM2_L1 AND WM2_EXP )) NOT X1 
Y3 = SIZE (V1_square INTERACT Y0) BY 1.1 INSIDE OF M2 STEP 0.005  
Y4= Y3 INTERACT (Y3 AND WM2)
VSING2= ((X3 INTERACT V1_B2 ==1) INTERACT Y4) OR (( X3 INTERACT WM2_EXT2) INTERACT V1_A2)
VSING2 OUTSIDE INST
}

WM1_a = M1 WITH WIDTH > 1.4
WM1_EDGE_a = LENGTH WM1_a > 0
WM1_EXP_a = EXPAND EDGE WM1_EDGE_a OUTSIDE BY 2.8  
V1_A_a = V1_square INTERACT WM1_EXP_a
CONNECT V1_A_a M1
CONNECT WM1_a M1

WM2_a = M2 WITH WIDTH > 1.4
WM2_EDGE_a = LENGTH WM2_a > 0
WM2_EXP_a = EXPAND EDGE WM2_EDGE_a OUTSIDE BY 2.8
WM2_L1_a = ( M2 not WM2_a ) TOUCH WM2_a
V1_A2_a = V1_square INTERACT WM2_EXP_a

V1_A2_EMPTY_a = EMPTY  OR V1_A2_a 
WM2_EMPTY_a =EMPTY OR WM2_a 
CONNECT V1_A2_EMPTY_a  M2_EMPTY
CONNECT WM2_EMPTY_a M2_EMPTY
V1_17a {
@ At least two V1s  when either wide metal of M1 or M2 with both length L>1.4um and width W>1.4um, and the distance D<=2.8um away from this wide metal.Exclude non-square Vn and SRAM area.
WM1_L1_a = ( M1 NOT WM1_a ) TOUCH WM1_a
//M1_ENCWM = (M1 INTERACT WM1_a) INTERACT V1_A_a
//WM1_VEDGE = EXT [M1_ENCWM]  <2.8 ABUT<90 OPPOSITE NOTCH
//WM1_EXT1 = EXT (WM1_a COIN EDGE WM1_VEDGE) [V1_A_a] < 2.8 ABUT>=0 <90  OPPOSITE CONNECTED 
//WM1_EXT2 = (EXT WM1_a V1_A_a < 2.8 ABUT>=0 <90  OPPOSITE REGION CONNECTED ) INSIDE M1  
V1_B = COPY V1_square 
X1 =(M1 AND M2) ENCLOSE V1_square >1
X2 = ((M1 AND M2)  AND ( WM1_L1_a AND WM1_EXP_a )) NOT X1 
Y0=(M1 AND M2) ENCLOSE V1_square ==1 
Y1 = SIZE (V1_square INTERACT Y0) BY 2.8 INSIDE OF M1 STEP 0.005  
Y2= Y1 INTERACT (Y1 AND WM1_a)
VSING1= (X2 INTERACT V1_B ==1) INTERACT Y2
VSING1 OUTSIDE INST 


//M2_ENCWM = (M2 INTERACT WM2_a) INTERACT V1_A2_a
//WM2_VEDGE = EXT [M2_ENCWM]  <2.8 ABUT<90 OPPOSITE NOTCH
//WM2_EXT1 = EXT (WM2_EMPTY_a COIN EDGE WM2_VEDGE) [V1_A2_EMPTY_a] < 2.8 ABUT>=0 <90  OPPOSITE CONNECTED 
//WM2_EXT2 = (EXT WM2_EMPTY_a V1_A2_EMPTY_a < 2.8 ABUT>=0 <90  OPPOSITE REGION CONNECTED ) INSIDE M2  
V1_B2 = COPY V1_square 
X3 = ((M1 AND M2)  AND ( WM2_L1_a AND WM2_EXP_a )) NOT X1 
Y3 = SIZE (V1_square INTERACT Y0) BY 2.8 INSIDE OF M2 STEP 0.005  
Y4= Y3 INTERACT (Y3 AND WM2_a)
VSING2= (X3 INTERACT V1_B2 ==1) INTERACT Y4
VSING2 OUTSIDE INST
}

WM1_b = (M1 WITH WIDTH > 2.1) WITH EDGE (LENGTH (M1 WITH WIDTH > 2.1) > 7)
WM1_EDGE_b = LENGTH WM1_b > 0
WM1_EXP_b = EXPAND EDGE WM1_EDGE_b OUTSIDE BY 7.1  
V1_A_b = V1_square INTERACT WM1_EXP_b
CONNECT V1_A_b M1
CONNECT WM1_b M1

WM2_b = (M2 WITH WIDTH > 2.1) WITH EDGE (LENGTH (M2 WITH WIDTH > 2.1) > 7)
WM2_EDGE_b = LENGTH WM2_b > 0
WM2_EXP_b = EXPAND EDGE WM2_EDGE_b OUTSIDE BY 7.1
WM2_L1_b = ( M2 not WM2_b ) TOUCH WM2_b
V1_A2_b = V1_square INTERACT WM2_EXP_b

V1_A2_EMPTY_b = EMPTY  OR V1_A2_b 
WM2_EMPTY_b =EMPTY OR WM2_b 
CONNECT V1_A2_EMPTY_b  M2_EMPTY
CONNECT WM2_EMPTY_b M2_EMPTY
V1_17b {
@ At least two V1s  when either wide metal of M1 or M2 with both length L>1.4um and width W>1.4um, and the distance D<=2.8um away from this wide metal.Exclude non-square Vn and SRAM area.
WM1_L1_b = ( M1 NOT WM1_b ) TOUCH WM1_b
//M1_ENCWM = (M1 INTERACT WM1_b) INTERACT V1_A_b
//WM1_VEDGE = EXT [M1_ENCWM]  <7.1 ABUT<90 OPPOSITE NOTCH
//WM1_EXT1 = EXT (WM1_b COIN EDGE WM1_VEDGE) [V1_A_b] < 7.1 ABUT>=0 <90  OPPOSITE CONNECTED 
//WM1_EXT2 = (EXT WM1_b V1_A_b < 7.1 ABUT>=0 <90  OPPOSITE REGION CONNECTED ) INSIDE M1  
V1_B = COPY V1_square 
X1 =(M1 AND M2) ENCLOSE V1_square >1
X2 = ((M1 AND M2)  AND ( WM1_L1_b AND WM1_EXP_b )) NOT X1 
Y0=(M1 AND M2) ENCLOSE V1_square ==1 
Y1 = SIZE (V1_square INTERACT Y0) BY 7.1 INSIDE OF M1 STEP 0.005  
Y2= Y1 INTERACT (Y1 AND WM1_b)
VSING1= (X2 INTERACT V1_B ==1) INTERACT Y2
VSING1 OUTSIDE INST 


//M2_ENCWM = (M2 INTERACT WM2_b) INTERACT V1_A2_b
//WM2_VEDGE = EXT [M2_ENCWM]  <7.1 ABUT<90 OPPOSITE NOTCH
//WM2_EXT1 = EXT (WM2_EMPTY_b COIN EDGE WM2_VEDGE) [V1_A2_EMPTY_b] < 7.1 ABUT>=0 <90  OPPOSITE CONNECTED 
//WM2_EXT2 = (EXT WM2_EMPTY_b V1_A2_EMPTY_b < 7.1 ABUT>=0 <90  OPPOSITE REGION CONNECTED ) INSIDE M2  
V1_B2 = COPY V1_square 
X3 = ((M1 AND M2)  AND ( WM2_L1_b AND WM2_EXP_b )) NOT X1 
Y3 = SIZE (V1_square INTERACT Y0) BY 7.1 INSIDE OF M2 STEP 0.005  
Y4= Y3 INTERACT (Y3 AND WM2_b)
VSING2= (X3 INTERACT V1_B2 ==1) INTERACT Y4
VSING2 OUTSIDE INST
}

V1_18 {
@ 45-degree rotated V1 is not allowed.
  (ANGLE V1_all >= 44.9 <= 45.1) NOT INSIDE EDGE MARKS
}
V1_19 {
@ Single V1 is not allowed in "H-shape" M2 when:
@ 1. The M2 has "H-shape" interact with two metal holes: both two metal holes length ? 4.5um(L2) and two metal hole area ? 4.5um2.
@ 2. The V1 overlaps on the center metal bar of this "H-shape" M2.
@ 3. The center metal bar length ? 1um(L) and the metal bar width ? 0.2um.
    M2_hole = RECTANGLE (AREA (HOLES M2 INNER) <= 4.5)    
    X = M2 COIN EDGE M2_hole
    Y = INT X <= 0.2 OPPOSITE REGION
    M2_bar_edge = LENGTH (M2_hole TOUCH EDGE Y) <= 1
    M2_hole_tar = M2_hole NOT WITH EDGE (LENGTH (M2_hole WITH EDGE M2_bar_edge) > 4.5)
    Z = Y INTERACT M2_hole_tar == 2
    H = V1 NOT OUTSIDE Z
//    (Z INTERACT H == 1) NOT MARKS
    ERR = ((M1 AND M2) INTERACT H) NOT INTERACT (V1 NOT H) 
    ((Z INTERACT H == 1) INTERACT ERR) NOT MARKS
}
V1_20 {
@ V1 connected to M1DUM, M2DUM is not allowed.
@ This rule is not applied for LOGO covered region.
  (V1 INTERACT (M1DUM OR M2DUM)) NOT LOGO
}
V1_21 {
@ V1 must be fully covered by M1 and M2.
  V1_all NOT (M1_all AND M2_all)
}
V1_22 {
@ It?s not allowed V1 overlap with M1 and M2 resistor.
  V1 AND (M1 AND M1R)
  V1 AND (M2 AND M2R)
}

//=====================
//  M2 - Metal 2 DRC
//=====================

GROUP GM2 M2_?

M2_1 {
@ M2 minimum width is 0.07
  INT M2_all < 0.07 ABUT<90 SINGULAR REGION
}
M2_1_R_OFF {
@ M2 minimum width is 0.08um.
  INT M2 < 0.08 ABUT<90 SINGULAR REGION
}
M2_2 {
@ M2 maximum width is 4.5
  M2_all WITH WIDTH > 4.50
}
M2_3 {
@ M2 minimum space is 0.07
  X = EXT M2_all  < 0.07 ABUT<90 SINGULAR REGION
  X OUTSIDE INST
}
M2_3_R_OFF {
@ M2 minimum space is 0.08um.
  X = EXT M2  < 0.08 ABUT<90 SINGULAR REGION
  X OUTSIDE INST 
}
SRM2_3 {
@ M2 minimum space is 0.065
  X =EXT M2 < 0.065 ABUT<90 SINGULAR REGION
  X NOT OUTSIDE INST
}
M2_4 {
@ M2 minimum area(The INST connected area apply SRAM design rule) is 0.0196
  AREA (M2_all OUT INST) < 0.0196
}
/*
M2_4a {
@ Area when all of the M2 edge length < 0.17m is >= 0.06um2.
@ This rule is not applicable for SRAM region.
  M2_ignore = M2_all WITH EDGE (LENGTH M2_all >= 0.17)
  (AREA (M2_all NOT M2_ignore) < 0.06) NOT INST
}
*/
SRM2_4 {
@ M2 minimum area is 0.0192
  X =AREA M2 < 0.0192 
  X  NOT OUTSIDE INST
}
M2_5 {
@ M2 minimum enclosed area is 0.2
  AREA ((HOLES M2_all INNER) NOT M2_all) < 0.2
}

M2_6 {
@ Minimum space between two run length > 0.3 parallel metal lines
@ with  both metal line width is > 0.22 is 0.10
   CMACRO Mn_6 M2i_all 0.3 0.22 0.1
}
M2_6_R_OFF {
@ Minimum space between two length > 0.3 parallel metal lines
@ with  both metal line width is > 0.22 is 0.10
   CMACRO Mn_6a M2i 0.3 0.22 0.12
}

M2_6a {
@ Minimum space between two length > 0.6 parallel metal lines
@ with one or both metal line width is > 0.7 is 0.12
   CMACRO Mn_6a M2i_all 0.6 0.7 0.12
}
M2_6b {
@ Minimum space between two length > 0.6 parallel metal lines with one metal
@ line width is > 0.22 and other metal line width is >0.7um is 0.14
   CMACRO Mn_6b M2i_all 0.6 0.22 0.7 0.14
}

M2_6c {
@ Minimum space between two length > 1.5 parallel metal lines
@ with one or both metal line width is > 1.5 is 0.30
   CMACRO Mn_6c M2i_all 1.5 1.5 0.3
}
M2_7_density {
@ Mn density (%) in 125um x 125um window with step size 62.5um is 10%
  DENSITY_MARK = BORDER NOT MARKS
  CHECK_LAYER = M2i_all NOT MARKS
  CHECK_REGION = COPY DENSITY_MARK
  X = DENSITY CHECK_LAYER CHECK_REGION [area(CHECK_LAYER)/area(CHECK_REGION)] < 0.10 WINDOW 125 STEP 62.5 BACKUP PRINT density_report_M2_7.log RDB density_report_M2_7.db
  X NOT MARKS
}
M2_7a_density {
@ Mn density (%) in 125um x 125um window with step size 62.5um is 85%
  DENSITY_MARK = BORDER NOT MARKS
  CHECK_LAYER = M2i_all NOT MARKS
  CHECK_REGION = COPY DENSITY_MARK
  X = DENSITY CHECK_LAYER CHECK_REGION [area(CHECK_LAYER)/area(CHECK_REGION)] > 0.85 WINDOW 125 STEP 62.5 BACKUP PRINT density_report_M2_7a.log RDB density_report_M2_7a.db 
  X NOT MARKS
}
M2_7b_density {
@ M2 maximum density difference(%) between any two 200um adjacent window (stepped without overlapping) is 50%
  X = DENSITY (M2i OR M2DUM) >= 0 WINDOW 200 GRADIENT > 0.5 ABSOLUTE BACKUP PRINT density_report_M2_7b.log RDB density_report_M2_7b.db
  X NOT MARKS
}
M2_7c_density {
@ M2 maximum density(%) with 840um*840um window is 70%
  DENSITY_MARK = BORDER NOT MARKS
  CHECK_LAYER = M2i_all NOT MARKS
  CHECK_REGION = COPY DENSITY_MARK
  X = DENSITY CHECK_LAYER CHECK_REGION [area(CHECK_LAYER)/area(CHECK_REGION)] > 0.7 WINDOW 840 BACKUP PRINT density_report_M2_7c.log RDB density_report_M2_7c.db 
  X NOT MARKS
}
M2_7d_R_density_ON {
@ [(M2 with width > 2.8um) over M1] maximum density(%) with 200um*200um step size 100um is 70%
 DENSITY_MARK = BORDER NOT MARKS
 CHECK_LAYER = (((M2i WITH WIDTH > 2.800) OR (M2DUM WITH WIDTH > 2.800)) AND (M1i OR M1DUM)) NOT MARKS
 CHECK_REGION = COPY DENSITY_MARK
 X = DENSITY CHECK_LAYER CHECK_REGION [area(CHECK_LAYER)/area(CHECK_REGION)] > 0.7 WINDOW 200 STEP 100 BACKUP PRINT density_report_M2_7d.log RDB density_report_M2_7d.db
 X NOT MARKS
}
M2_7e_R_density_ON {
@ [(M1 with width > 2.8um) over M2] maximum density(%) with 200um*200um step size 100um is 70%
  DENSITY_MARK = BORDER NOT MARKS
  CHECK_LAYER = ((M2i OR M2DUM) AND ((M1i WITH WIDTH > 2.80) OR (M1DUM WITH WIDTH > 2.80))) NOT MARKS
  CHECK_REGION = COPY DENSITY_MARK
  X = DENSITY CHECK_LAYER CHECK_REGION [area(CHECK_LAYER)/area(CHECK_REGION)] > 0.7 WINDOW 200 STEP 100 BACKUP PRINT density_report_M2_7e.log RDB density_report_M2_7e.db
  X NOT MARKS
}
M2_7f_density {
@ Mn density over the whole chip is >=20%
DENSITY_MARK = BORDER NOT MARKS
CHECK_LAYER = M2i_all NOT MARKS
CHECK_REGION = COPY DENSITY_MARK
X =DENSITY CHECK_LAYER CHECK_REGION [area(CHECK_LAYER)/area(CHECK_REGION)] < 0.2 PRINT density_report_M2_7f.log RDB density_report_M2_7f.db
X NOT MARKS
}
M2_8 {
@ (M2 at 45degree ) minimum width (run length>0um) is 0.17
   M245 = ANGLE M2_all == 45
   INT M245 < 0.17 OPPOSITE REGION
}
M2_9 {
@ (M2 at 45degree) minimum space to parallel M2 (run length>0um) is 0.17
  M245 = ANGLE M2_all == 45
  EXT M245  < 0.17 OPPOSITE REGION
}
M2END = CONVEX EDGE M2 ANGLE1 ==90 LENGTH1 >=0.08 ANGLE2  ==90 LENGTH2  >=0.08 WITH LENGTH  <=0.11 
/*
M2.10a {
@ Space between a Mn line end to a Mn (the parallel run length >0m)
@ Excluding checking SRAM area
X =EXT M2END M2<0.07 OPPOSITE REGION
X  OUTSIDE INST 
}
M2.10b{
@ Minimum space between an Mn line end (with Vn) to an Mn (the parallel run length >0um) is 0.07. The Mn line end extend Q from Vn, 0.03 <= Q <0.05um 
X1 = EXT M2END  M2 <0.07 OPPOSITE REGION
X2 = M2END COIN EDGE X1 
X3 = ENC  V2 X2 <0.05 OPPOSITE REGION
X4 = ENC V2 X2 <0.03 OPPOSITE REGION
X5 = V2 INTERACT X3  
X6 = V2 INTERACT X4
X7 = X5 NOT X6
X =X1 TOUCH (X3 INTERACT X7)
X OUTSIDE INST
}
*/
/*M2.10c{
@ Minimum space between an Mn line end (with Vn) to an Mn (the parallel run length >0um ) is 0.1. The Mn line end extend Q from Vn, 0 <= Q <0.03um 
X1 = EXT M2END  M2 <0.1 OPPOSITE REGION
X2 = M2END COIN EDGE X1 
X3 = ENC  V2 X2 <0.03 ABUT<90 OPPOSITE REGION
X4 = V2 INTERACT X3
X1 TOUCH (X3 INTERACT X4)
}*/

M2_11 {
@ Space between Vn-1 (Vn-1 is enclosed by Mn[A]) to neighbouring metal line Mn[B], when the layout structures meet the following conditions:
@ 1.	Mn[A] line end definition: line width W <0.1m. 
@ 2.	Vn-1 enclosure by Mn[A] line end: E < 0.05m
@ 3.	The parallel run length of Mn[A] and Mn[B]:E1 >=-0.03m
@ 4.	Space between Mn[A] to the neighbouring parallel metal line: Ds<0.08m;
@ 5.	Any one edge distance from the corner of the two edges of Mn[A]: K1 <0.095m
@ At least one Vn-1 in the Mn[A] and Mn-1 intersection meet this rule is ok.
@ This rule is not applicable for SRAM region DRC check.		0.12
LINE_END = CONVEX EDGE M2 ANGLE1 ==90 LENGTH1 >=0.08 ANGLE2  ==90 LENGTH2  >=0.08 WITH LENGTH  <0.1
 X1 =ENC V1  LINE_END<0.05 ABUT<90 REGION OPPOSITE
 X2 = V1 INTERACT X1 
 X3 = X2 INSIDE (M1 AND M2)
 X8 =X3 TOUCH EDGE X1
LINE_END_SHAPE = EXPAND EDGE LINE_END INSIDE BY 0.095
LINE_SIDE = (M2 COIN EDGE LINE_END_SHAPE ) NOT COIN EDGE LINE_END
LINE_SIDE1 = ENC X3 LINE_SIDE<0.03 REGION ABUT<90 OPPOSITE
V1_EDGE =(LINE_SIDE1 OR X3) TOUCH EDGE X8
LINE_END_EXP = EXPAND EDGE V1_EDGE INSIDE BY 0.001 EXTEND BY 0.031
LINE_SIDE_EXP = EXPAND EDGE LINE_SIDE INSIDE BY 0.001 
LINE_END_1 = LINE_END_EXP TOUCH EDGE V1_EDGE 
LINE_SIDE_1 = LINE_SIDE_EXP  TOUCH EDGE  LINE_SIDE
E1 = EXT [LINE_END_1] M2 < 0.12 OPPOSITE PERP ALSO OBTUSE ALSO 
E2 = EXT [LINE_SIDE_1] M2 < 0.08  OPPOSITE PERP ALSO OBTUSE ALSO
LINE_END_E1 = LINE_END_1 TOUCH EDGE E1
LINE_SIDE_E2 = LINE_SIDE_1 TOUCH EDGE E2
V42 =X3 WITH EDGE (X8 TOUCH EDGE LINE_END_E1)   
X5 = V1 INTERACT V42
X6 = V1 NOT X5
X7 = ((M1 AND M2) ENCLOSE X5) ENCLOSE X6
M2_CORNER1 = INT LINE_END_E1 LINE_SIDE_E2 <= 0.002 ABUT==90 REGION
(M2_CORNER1 NOT INTERACT X7) OUTSIDE INST
}



M2_12_R_OFF {
@ Minimum Mn to Mn space S at Mn line-end 0.1. Width W < 0.1um . The minimum space can be line end head to other Mn or line end side to other M1.  Rule check:
@ S >= (Dh or Ds ).  E1 =0.03, K1=0.095 , Dh=Ds=0.1 in the illustration. 
@ Outside of SRAM(INST) area.
@ Waive extrusion F < 0.07.
@ Waive the violation for MOM (within MOMDMY).
LINE_END = CONVEX EDGE M2_all ANGLE1 ==90 LENGTH1 >=0.07 ANGLE2  ==90 LENGTH2  >=0.07 WITH LENGTH  < 0.1
LINE_END_SHAPE = EXPAND EDGE LINE_END INSIDE BY 0.064
LINE_SIDE = (M2_all COIN EDGE LINE_END_SHAPE ) NOT COIN EDGE LINE_END
LINE_END_EXP = EXPAND EDGE LINE_END INSIDE BY 0.001 EXTEND BY 0.031
LINE_SIDE_EXP = EXPAND EDGE LINE_SIDE INSIDE BY 0.001 EXTEND BY 0.031
LINE_END_1 = LINE_END_EXP TOUCH EDGE LINE_END
LINE_SIDE_1 = LINE_SIDE_EXP TOUCH EDGE LINE_SIDE
E1 = EXT [LINE_END_1] M2_all < 0.1 OPPOSITE PERP ALSO OBTUSE ALSO
E2 = EXT [LINE_SIDE_1] M2_all < 0.1  OPPOSITE PERP ALSO OBTUSE ALSO
LINE_END_E1 = LINE_END_1 TOUCH EDGE E1
LINE_SIDE_E2 = LINE_SIDE_1 TOUCH EDGE E2
M2_CORNER = INT LINE_END_E1 LINE_SIDE_E2 <= 0.002 ABUT==90 REGION
MOM =((M1 OR M2) OR M3) INTERACT ( MnPIN INTERACT (SIZE MOMDMY BY 0.114))
((LINE_END_SHAPE INTERACT M2_CORNER) OUTSIDE INST) NOT (MOM OR MOMDMY)
}
M2_14_density {
@ M2 density (including dummy) is >= 1%.Density check window size: 80um*80um, step size 40um.
@ DRC only check the region with width of (checking window NOT above excluding region) >= 40um.
  DENSITY_MARK = WITH WIDTH (BORDER NOT MARKS) >= 40
  CHECK_LAYER = M2i_all AND DENSITY_MARK
  CHECK_REGION = COPY DENSITY_MARK
  X = DENSITY CHECK_LAYER CHECK_REGION [area(CHECK_LAYER)/area(CHECK_REGION)] < 0.01 WINDOW 80 STEP 40 BACKUP PRINT density_report_M2_14.log RDB density_report_M2_14.db
  (X NOT MARKS) WITH WIDTH >= 40
}
M2_15 {
    @ Maximum M2 area of merged low density windows must follow item (1) and (2).
    @ The definition of low density window: window size 10um*10um, step size: 5um, density <1%
    @ (1) Maximum area of merged low density window ? 6500um2, except merged low density windows width ? 30um.
    @ (2) Maximum area of merged low density window ? 18500um2.
    @ DRC only check the region with width of (checking window NOT above excluding region) ? 5um
    X = DENSITY M2i_all < 0.01 WINDOW 10 STEP 5 BACKUP PRINT density_report_M2_15.log RDB density_report_M2_15.rdb
    Y = X NOT MARKS
    (AREA Y > 6500) WITH WIDTH > 30
    (AREA Y > 16000) WITH WIDTH >= 5
}

//=====================
//  M3 - Metal 3 DRC
//=====================

GROUP GM3 M3_?

M3_1 {
@ M3 minimum width is 0.07
  INT M3_all < 0.07 ABUT<90 SINGULAR REGION
}
M3_1_R_OFF {
@ M3 minimum width is 0.08um.
  INT M3 < 0.08 ABUT<90 SINGULAR REGION
} 
#IFDEF TOPMETAL 4
M3_2 {
@ M3 maximum width is 4.5.
@ When M3 used for TM-1,DRC waive the (M3 AND DUPMK1) region.
  (M3_all WITH WIDTH > 4.50) NOT (M3_all AND DUPMK1)
}
#ELSE
M3_2 {
@ M3 maximum width is 4.5
  M3_all WITH WIDTH > 4.50
}
#ENDIF
M3_3 {
@ M3 minimum space is 0.07
  EXT M3_all < 0.07 ABUT<90 SINGULAR REGION
}
M3_3_R_OFF {
@ M3 minimum space is 0.08um.
  EXT M3 < 0.08 ABUT<90 SINGULAR REGION
}
M3_4 {
@ M3 minimum area is 0.0196
  AREA M3_all < 0.0196
}
/*
M3_4a {
@ Area when all of the M3 edge length < 0.17 m is >= 0.06um2. 
@ This rule is not applicable for SRAM region.
  M3_ignore = M3_all WITH EDGE (LENGTH M3_all >= 0.17)
  (AREA (M3_all NOT M3_ignore) < 0.06) NOT INST
}  
*/
M3_5 {
@ M3 minimum enclosed area is 0.2
  AREA ((HOLES M3_all INNER) NOT M3_all) < 0.2
}

M3_6 {
@ Minimum space between two run length > 0.3 parallel metal lines
@ with  both metal line width is > 0.22 is 0.10
   CMACRO Mn_6 M3i_all 0.3 0.22 0.1
}
M3_6_R_OFF {
@ Minimum space between two length > 0.3 parallel metal lines
@ with  both metal line width is > 0.22 is 0.12
   CMACRO Mn_6a M3i 0.3 0.22 0.12
}
M3_6a {
@ Minimum space between two length > 0.6 parallel metal lines
@ with one or both metal line width is > 0.7 is 0.12
   CMACRO Mn_6a M3i_all 0.6 0.7 0.12
}
M3_6b {
@ Minimum space between two length > 0.6 parallel metal lines with one metal
@ line width is > 0.22 and other metal line width is >0.7um is 0.14
   CMACRO Mn_6b M3i_all 0.6 0.22 0.7 0.14
}

M3_6c {
@ Minimum space between two length > 1.5 parallel metal lines
@ with one or both metal line width is > 1.5 is 0.30
   CMACRO Mn_6c M3i_all 1.5 1.5 0.3
}
M3_7_density {
@ M3 minimum density(%) in 125um*125um window with step size 62.5um is 10%
  DENSITY_MARK = BORDER NOT MARKS
  CHECK_LAYER = M3i_all NOT MARKS
  CHECK_REGION = COPY DENSITY_MARK
  X = DENSITY CHECK_LAYER CHECK_REGION [area(CHECK_LAYER)/area(CHECK_REGION)] < 0.10 WINDOW 125 STEP 62.5 BACKUP PRINT density_report_M3_7.log RDB density_report_M3_7.db
  X NOT MARKS
}
M3_7a_density {
@ M3 maximum density(%) in 125um*125um window with step size 62.5um is 85%
  DENSITY_MARK = BORDER NOT MARKS
  CHECK_LAYER = M3i_all NOT MARKS
  CHECK_REGION = COPY DENSITY_MARK
  X = DENSITY CHECK_LAYER CHECK_REGION [area(CHECK_LAYER)/area(CHECK_REGION)] > 0.85 WINDOW 125 STEP 62.5 BACKUP PRINT density_report_M3_7a.log RDB density_report_M3_7a.db 
  X NOT MARKS
}
M3_7b_density {
@ M3 maximum density difference(%) between any two 200um adjacent window (stepped without overlapping) is 50%
  X = DENSITY (M3i OR M3DUM) >= 0 WINDOW 200 GRADIENT > 0.5 ABSOLUTE BACKUP PRINT density_report_M3_7b.log RDB density_report_M3_7b.db
  X NOT MARKS
}
M3_7c_density {
@ M3 maximum density(%) with 840um*840um window is 70%
  DENSITY_MARK = BORDER NOT MARKS
  CHECK_LAYER = M3i_all NOT MARKS
  CHECK_REGION = COPY DENSITY_MARK
  X = DENSITY CHECK_LAYER CHECK_REGION [area(CHECK_LAYER)/area(CHECK_REGION)] > 0.7 WINDOW 840 BACKUP PRINT density_report_M3_7c.log RDB density_report_M3_7c.db 
  X NOT MARKS
}
M3_7d_R_density_ON {
@ [(M3 with width > 2.8um) over M2] maximum density(%) with 200um*200um step size 100um is 70%
 DENSITY_MARK = BORDER NOT MARKS
 CHECK_LAYER = (((M3i WITH WIDTH > 2.800) OR (M3DUM WITH WIDTH > 2.800)) AND (M2i OR M2DUM)) NOT MARKS
 CHECK_REGION = COPY DENSITY_MARK
 X = DENSITY CHECK_LAYER CHECK_REGION [area(CHECK_LAYER)/area(CHECK_REGION)] > 0.7 WINDOW 200 STEP 100 BACKUP PRINT density_report_M3_7d.log RDB density_report_M3_7d.db
 X NOT MARKS
}
M3_7e_R_density_ON {
@ [(M2 with width > 2.8um) over M3] maximum density(%) with 200um*200um step size 100um is 70%
  DENSITY_MARK = BORDER NOT MARKS
  CHECK_LAYER = ((M3i OR M3DUM) AND ((M2i WITH WIDTH > 2.80) OR (M2DUM WITH WIDTH > 2.80))) NOT MARKS
  CHECK_REGION = COPY DENSITY_MARK
  X = DENSITY CHECK_LAYER CHECK_REGION [area(CHECK_LAYER)/area(CHECK_REGION)] > 0.7 WINDOW 200 STEP 100 BACKUP PRINT density_report_M3_7e.log RDB density_report_M3_7e.db
  X NOT MARKS
}
M3_7f_density {
@ M3 density over the whole chip is >=20%
DENSITY_MARK = BORDER NOT MARKS
CHECK_LAYER = M3i_all NOT MARKS
CHECK_REGION = COPY DENSITY_MARK
X =DENSITY CHECK_LAYER CHECK_REGION [area(CHECK_LAYER)/area(CHECK_REGION)] < 0.2 PRINT density_report_M3_7f.log RDB density_report_M3_7f.db
X NOT MARKS
}

M3_8 {
@ (M3 at 45degree ) minimum width (run length>0um) is 0.17
   M345 = ANGLE M3_all == 45
   INT M345 < 0.17 OPPOSITE REGION
}
M3_9 {
@ (M3 at 45degree) minimum space to parallel M3 (run length>0um) is 0.17
  M345 = ANGLE M3_all == 45
  EXT M345 < 0.17 OPPOSITE REGION
}
M3END = CONVEX EDGE M3 ANGLE1 ==90 LENGTH1 >=0.08 ANGLE2  ==90 LENGTH2  >=0.08 WITH LENGTH  <=0.11 
/*
M3.10a {
@Minimum space between an Mn line end to an Mn (the parallel run length >0um) is 0.07.Excluding checking SRAM area
X =EXT M3END M3<0.07 OPPOSITE REGION
 X OUTSIDE INST
}
M3.10b{
@ Minimum space between an Mn line end (with Vn) to an Mn (the parallel run length >0um) is 0.07. The Mn line end extend Q from Vn, 0.03 <= Q <0.05um Excluding checking SRAM area
X1 = EXT M3END  M3 <0.07 OPPOSITE REGION
X2 = M3END COIN EDGE X1 
X3 = ENC  V3 X2 <0.05 OPPOSITE REGION
X4 = ENC V3 X2 <0.03 OPPOSITE REGION
X5 = V3 INTERACT X3  
X6 = V3 INTERACT X4
X7 = X5 NOT X6
X= X1 TOUCH (X3 INTERACT X7)
X OUTSIDE INST
}
*/
/*M3.10c{
@ Minimum space between an Mn line end (with Vn) to an Mn (the parallel run length >0um ) is 0.1. The Mn line end extend Q from Vn, 0 <= Q <0.03um 
X1 = EXT M3END  M3 <0.1 OPPOSITE REGION
X2 = M3END COIN EDGE X1 
X3 = ENC  V3 X2 <0.03 ABUT<90 OPPOSITE REGION
X4 = V3 INTERACT X3
X1 TOUCH (X3 INTERACT X4)
}*/
M3_11 {
@ Space between Vn-1 (Vn-1 is enclosed by Mn[A]) to neighbouring metal line Mn[B], when the layout structures meet the following conditions:
@ 1.	Mn[A] line end definition: line width W <0.1um. 
@ 2.	Vn-1 enclosure by Mn[A] line end: E < 0.05um
@ 3.	The parallel run length of Mn[A] and Mn[B]:E1 >=-0.03um
@ 4.	Space between Mn[A] to the neighbouring parallel metal line: Ds<0.08um;
@ 5.	Any one edge distance from the corner of the two edges of Mn[A]: K1 <0.095um
@ At least one Vn-1 in the Mn[A] and Mn-1 intersection meet this rule is ok.
@ This rule is not applicable for SRAM region DRC check.		0.12
LINE_END = CONVEX EDGE M3 ANGLE1 ==90 LENGTH1 >=0.08 ANGLE2  ==90 LENGTH2  >=0.08 WITH LENGTH  <0.1
 X1 =ENC V2  LINE_END<0.05 ABUT<90 REGION OPPOSITE
 X2 = V2 INTERACT X1 
 X3 = X2 INSIDE (M3 AND M2)
 X8 =X3 TOUCH EDGE X1
LINE_END_SHAPE = EXPAND EDGE LINE_END INSIDE BY 0.095
LINE_SIDE = (M3 COIN EDGE LINE_END_SHAPE ) NOT COIN EDGE LINE_END
LINE_SIDE1 = ENC X3 LINE_SIDE<0.03 REGION ABUT<90 OPPOSITE
V2_EDGE =(LINE_SIDE1 OR X3) TOUCH EDGE X8
LINE_END_EXP = EXPAND EDGE V2_EDGE INSIDE BY 0.001 EXTEND BY 0.031
LINE_SIDE_EXP = EXPAND EDGE LINE_SIDE INSIDE BY 0.001 
LINE_END_1 = LINE_END_EXP TOUCH EDGE V2_EDGE 
LINE_SIDE_1 = LINE_SIDE_EXP  TOUCH EDGE  LINE_SIDE
E1 = EXT [LINE_END_1] M3 < 0.12 OPPOSITE PERP ALSO OBTUSE ALSO 
E2 = EXT [LINE_SIDE_1] M3 < 0.08  OPPOSITE PERP ALSO OBTUSE ALSO
LINE_END_E1 = LINE_END_1 TOUCH EDGE E1
LINE_SIDE_E2 = LINE_SIDE_1 TOUCH EDGE E2
V42 =X3 WITH EDGE (X8 TOUCH EDGE LINE_END_E1)   
X5 = V2 INTERACT V42
X6 = V2 NOT X5
X7 = ((M3 AND M2) ENCLOSE X5) ENCLOSE X6
M2_CORNER1 = INT LINE_END_E1 LINE_SIDE_E2 <= 0.002 ABUT==90 REGION
(M2_CORNER1 NOT INTERACT X7) OUTSIDE INST
}

M3_12_R_OFF {
@ Minimum Mn to Mn space S at Mn line-end 0.1. Width W < 0.1um . The minimum space can be line end head to other Mn or line end side to other M1.  Rule check:
@ S >= (Dh or Ds ).  E1 =0.03, K1=0.095 , Dh=Ds=0.1 in the illustration. 
@ Outside of SRAM(INST) area.
@ Waive extrusion F < 0.07.
@ Waive the violation for MOM (within MOMDMY).
LINE_END = CONVEX EDGE M3_all ANGLE1 ==90 LENGTH1 >=0.07 ANGLE2  ==90 LENGTH2  >=0.07 WITH LENGTH  < 0.1
LINE_END_SHAPE = EXPAND EDGE LINE_END INSIDE BY 0.064
LINE_SIDE = (M3_all COIN EDGE LINE_END_SHAPE ) NOT COIN EDGE LINE_END
LINE_END_EXP = EXPAND EDGE LINE_END INSIDE BY 0.001 EXTEND BY 0.031
LINE_SIDE_EXP = EXPAND EDGE LINE_SIDE INSIDE BY 0.001 EXTEND BY 0.031
LINE_END_1 = LINE_END_EXP TOUCH EDGE LINE_END
LINE_SIDE_1 = LINE_SIDE_EXP TOUCH EDGE LINE_SIDE
E1 = EXT [LINE_END_1] M3_all < 0.1 OPPOSITE PERP ALSO OBTUSE ALSO
E2 = EXT [LINE_SIDE_1] M3_all < 0.1  OPPOSITE PERP ALSO OBTUSE ALSO
LINE_END_E1 = LINE_END_1 TOUCH EDGE E1
LINE_SIDE_E2 = LINE_SIDE_1 TOUCH EDGE E2
M3_CORNER = INT LINE_END_E1 LINE_SIDE_E2 <= 0.002 ABUT==90 REGION
MOM =((M2 OR M3) OR M4) INTERACT ( MnPIN INTERACT (SIZE MOMDMY BY 0.114))
((LINE_END_SHAPE INTERACT M3_CORNER) OUTSIDE INST) NOT (MOM OR MOMDMY)
}

M3_13_M1M2M3_density_R_OFF {
    @ It is not allowed to havel local density > 85% of all 3 consecutive metal (1xMn, 1xMn+1 and 1xMn+2) over any window size 62.5*62.5um (stepping size 31.25um).
    @ The metal layers include M1/1xMn and dummy metals.
    @ DRC doesn't check: DUMBM, MARKS and (TM2 and PA) region
	DENSITY_MARK = BORDER NOT (OR DUMBM MARKS (TM2i AND PA))
	M2_TAR = M2i_all NOT (OR DUMBM MARKS (TM2i AND PA))
	M3_TAR = M3i_all NOT (OR DUMBM MARKS (TM2i AND PA))
	M1_TAR = M1i_all NOT (OR DUMBM MARKS (TM2i AND PA))
    CHECK_REGION = COPY DENSITY_MARK
    DENSITY M2_TAR M3_TAR M1_TAR CHECK_REGION > 0 WINDOW 62.5 STEP 31.25 BACKUP PRINT density_report_M2_13_M1M2M3.log RDB density_report_M2_13_M1M2M3.rdb [(~~(AREA(M2_TAR)/AREA(CHECK_REGION) -0.85))&&(~~(AREA(M3_TAR)/AREA(CHECK_REGION) -0.85))&&(~~(AREA(M1_TAR)/AREA(CHECK_REGION) -0.85))]
}

M3_14_density {
@ M3 density (including dummy) is >= 1%.Density check window size: 80um*80um, step size 40um.
@ DRC only check the region with width of (checking window NOT above excluding region) >= 40um.
  DENSITY_MARK = WITH WIDTH (BORDER NOT MARKS) >= 40
  CHECK_LAYER = M3i_all AND DENSITY_MARK 
  CHECK_REGION = COPY DENSITY_MARK
  X = DENSITY CHECK_LAYER CHECK_REGION [area(CHECK_LAYER)/area(CHECK_REGION)] < 0.01 WINDOW 80 STEP 40 BACKUP PRINT density_report_M3_14.log RDB density_report_M3_14.db
  (X NOT MARKS) WITH WIDTH >= 40
}
M3_15 {
    @ Maximum M3 area of merged low density windows must follow item (1) and (2).
    @ The definition of low density window: window size 10um*10um, step size: 5um, density <1%
    @ (1) Maximum area of merged low density window <= 6500um2, except merged low density windows width <= 30um.
    @ (2) Maximum area of merged low density window <= 18500um2.
    @ DRC only check the region with width of (checking window NOT above excluding region) >= 5um
    X = DENSITY M3i_all < 0.01 WINDOW 10 STEP 5 BACKUP PRINT density_report_M3_15.log RDB density_report_M3_15.rdb
    Y = X NOT MARKS
    (AREA Y > 6500) WITH WIDTH > 30
    (AREA Y > 16000) WITH WIDTH >= 5
}

M3_16_M1M2M3_density {
    @ It is not allowed to havel local density < 5% of all 3 consecutive metal (Mn, Mn+1 and Mn+2) over any window 30*30um (stepping 15um).
    @ The metal layers include M1/1xMn and dummy metals.
    @ DRC only check the region with width of (checking window NOT above excluding region) >= 15um
    DENSITY_MARK = WITH WIDTH (BORDER NOT MARKS) >= 15
	M2_TAR = M2i_all AND DENSITY_MARK
	M3_TAR = M3i_all AND DENSITY_MARK
	M1_TAR = M1i_all AND DENSITY_MARK
    CHECK_REGION = COPY DENSITY_MARK
    DENSITY M2_TAR M3_TAR M1_TAR CHECK_REGION > 0 WINDOW 30 STEP 15 BACKUP PRINT density_report_M2_16_M1M2M3.log RDB density_report_M2_16_M1M2M3.rdb [(~~(0.05 -AREA(M2_TAR)/AREA(CHECK_REGION) ))&&(~~(0.05 -AREA(M3_TAR)/AREA(CHECK_REGION) ))&&(~~(0.05 -AREA(M1_TAR)/AREA(CHECK_REGION) ))]
}

#IFDEF M4_CHECK YES
//=====================
//  M4 - Metal 4 DRC
//=====================

GROUP GM4 M4_?

M4_1 {
@ M4 minimum width is 0.07
  INT M4_all < 0.07 ABUT<90 SINGULAR REGION
}
M4_1_R_OFF {
@ M4 minimum width is 0.08um
  INT M4 < 0.08 ABUT<90 SINGULAR REGION
}
#IFDEF TOPMETAL 5
M4_2 {
@ M4 maximum width is 4.5
@ When M4 used for TM-1,DRC waive the (M4 AND DUPMK1) region.
  (M4_all WITH WIDTH > 4.50) NOT (M4_all AND DUPMK1)
}
#ELSE
M4_2 {
@ M4 maximum width is 4.5
  M4_all WITH WIDTH > 4.50
}
#ENDIF
M4_3 {
@ M4 minimum space is 0.07
  EXT M4_all < 0.07 ABUT<90 SINGULAR REGION
}
M4_3_R_OFF {
@ M4 minimum space is 0.08um.
  EXT M4 < 0.08 ABUT<90 SINGULAR REGION
}
M4_4 {
@ M4 minimum area is 0.0196
  AREA M4_all < 0.0196
}
/*
M4_4a {
@ Area when all of the M4 edge length < 0.17 m is >= 0.06um2. 
@ This rule is not applicable for SRAM region.
  M4_ignore = M4_all WITH EDGE (LENGTH M4_all >= 0.17)
  (AREA (M4_all NOT M4_ignore) < 0.06) NOT INST
}  
*/
M4_5 {
@ M4 minimum enclosed area is 0.2
  AREA ((HOLES M4_all INNER) NOT M4_all) < 0.2
}

M4_6 {
@ Minimum space between two run length > 0.3 parallel metal lines
@ with both metal line width is > 0.22 is 0.10
   CMACRO Mn_6 M4i_all 0.3 0.22 0.1
}
M4_6_R_OFF {
@ Minimum space between two length > 0.3 parallel metal lines
@ with both metal line width is > 0.22 is 0.12um.
   CMACRO Mn_6a M4i 0.3 0.22 0.12
}
M4_6a {
@ Minimum space between two length > 0.6 parallel metal lines
@ with one or both metal line width is > 0.7 is 0.12
   CMACRO Mn_6a M4i_all 0.6 0.7 0.12
}
M4_6b {
@ Minimum space between two length > 0.6 parallel metal lines with one metal
@ line width is > 0.22 and other metal line width is >0.7um is 0.14
   CMACRO Mn_6b M4i_all 0.6 0.22 0.7 0.14
}
M4_6c {
@ Minimum space between two length > 1.5 parallel metal lines
@ with one or both metal line width is > 1.5 is 0.30
   CMACRO Mn_6c M4i_all 1.5 1.5 0.3
}

#IFDEF TOPMETAL 9
M4_7_density {
@ M4 minimum density(%) in 125um*125um window with step size 62.5um is 10%
  DENSITY_MARK = BORDER NOT MARKS
  CHECK_LAYER = M4i_all NOT MARKS
  CHECK_REGION = COPY DENSITY_MARK
  X = DENSITY CHECK_LAYER CHECK_REGION [area(CHECK_LAYER)/area(CHECK_REGION)] < 0.10 WINDOW 125 STEP 62.5 BACKUP PRINT density_report_M4_7.log RDB density_report_M4_7.db
  X NOT MARKS
}
M4_7f_density {
@ M4 density over the whole chip is >=20%
DENSITY_MARK = BORDER NOT MARKS
CHECK_LAYER = M4i_all NOT MARKS
CHECK_REGION = COPY DENSITY_MARK
X =DENSITY CHECK_LAYER CHECK_REGION [area(CHECK_LAYER)/area(CHECK_REGION)] < 0.2 PRINT density_report_M4_7f.log RDB density_report_M4_7f.db
X NOT MARKS
}
#ENDIF
#IFDEF TOPMETAL 8
M4_7_density {
@ M4 minimum density(%) in 125um*125um window with step size 62.5um is 10%
  DENSITY_MARK = BORDER NOT MARKS
  CHECK_LAYER = M4i_all NOT MARKS
  CHECK_REGION = COPY DENSITY_MARK
  X = DENSITY CHECK_LAYER CHECK_REGION [area(CHECK_LAYER)/area(CHECK_REGION)] < 0.10 WINDOW 125 STEP 62.5 BACKUP PRINT density_report_M4_7.log RDB density_report_M4_7.db
  X NOT MARKS
}
M4_7f_density {
@ Mn density over the whole chip is >=20%
DENSITY_MARK = BORDER NOT MARKS
CHECK_LAYER = M4i_all NOT MARKS
CHECK_REGION = COPY DENSITY_MARK
X =DENSITY CHECK_LAYER CHECK_REGION [area(CHECK_LAYER)/area(CHECK_REGION)] < 0.2 PRINT density_report_M4_7f.log RDB density_report_M4_7f.db
X NOT MARKS
}
#ENDIF
#IFDEF TOPMETAL 7
M4_7_density {
@ M4 minimum density(%) in 125um*125um window with step size 62.5um is 10%
  DENSITY_MARK = BORDER NOT MARKS
  CHECK_LAYER = M4i_all NOT MARKS
  CHECK_REGION = COPY DENSITY_MARK
  X = DENSITY CHECK_LAYER CHECK_REGION [area(CHECK_LAYER)/area(CHECK_REGION)] < 0.10 WINDOW 125 STEP 62.5 BACKUP PRINT density_report_M4_7.log RDB density_report_M4_7.db
  X NOT MARKS
}
M4_7f_density {
@ Mn density over the whole chip is >=20%
DENSITY_MARK = BORDER NOT MARKS
CHECK_LAYER = M4i_all NOT MARKS
CHECK_REGION = COPY DENSITY_MARK
X =DENSITY CHECK_LAYER CHECK_REGION [area(CHECK_LAYER)/area(CHECK_REGION)] < 0.2 PRINT density_report_M4_7f.log RDB density_report_M4_7f.db
X NOT MARKS
}
#ENDIF
#IFDEF TOPMETAL 6
M4_7_density {
@ M4 minimum density(%) in 125um*125um window with step size 62.5um is 10%
  DENSITY_MARK = BORDER NOT MARKS
  CHECK_LAYER = M4i_all NOT MARKS
  CHECK_REGION = COPY DENSITY_MARK
  X = DENSITY CHECK_LAYER CHECK_REGION [area(CHECK_LAYER)/area(CHECK_REGION)] < 0.10 WINDOW 125 STEP 62.5 BACKUP PRINT density_report_M4_7.log RDB density_report_M4_7.db
  X NOT MARKS
}
M4_7f_density {
@ Mn density over the whole chip is >=20%
DENSITY_MARK = BORDER NOT MARKS
CHECK_LAYER = M4i_all NOT MARKS
CHECK_REGION = COPY DENSITY_MARK
X =DENSITY CHECK_LAYER CHECK_REGION [area(CHECK_LAYER)/area(CHECK_REGION)] < 0.2 PRINT density_report_M4_7f.log RDB density_report_M4_7f.db
X NOT MARKS
}
#ENDIF
#IFDEF TOPMETAL 5
M4_7_density {
@ M4 minimum density(%) in 125um*125um window with step size 62.5um is 10%
  DENSITY_MARK = BORDER NOT MARKS
  CHECK_LAYER = M4i_all NOT MARKS
  CHECK_REGION = COPY DENSITY_MARK
  X = DENSITY CHECK_LAYER CHECK_REGION [area(CHECK_LAYER)/area(CHECK_REGION)] < 0.10 WINDOW 125 STEP 62.5 BACKUP PRINT density_report_M4_7.log RDB density_report_M4_7.db
  X NOT MARKS
}
M4_7f_density {
@ Mn density over the whole chip is >=20%
DENSITY_MARK = BORDER NOT MARKS
CHECK_LAYER = M4i_all NOT MARKS
CHECK_REGION = COPY DENSITY_MARK
X =DENSITY CHECK_LAYER CHECK_REGION [area(CHECK_LAYER)/area(CHECK_REGION)] < 0.2 PRINT density_report_M4_7f.log RDB density_report_M4_7f.db
X NOT MARKS
}
#ENDIF

M4_7a_density {
@ M4 maximum density(%) in 125um*125um window with step size 62.5um is 85%
  DENSITY_MARK = BORDER NOT MARKS
  CHECK_LAYER = M4i_all NOT MARKS
  CHECK_REGION = COPY DENSITY_MARK
  X = DENSITY CHECK_LAYER CHECK_REGION [area(CHECK_LAYER)/area(CHECK_REGION)] > 0.85 WINDOW 125 STEP 62.5 BACKUP PRINT density_report_M4_7a.log RDB density_report_M4_7a.db 
  X NOT MARKS
}
M4_7b_density {
@ M4 maximum density difference(%) between any two 200um adjacent window (stepped without overlapping) is 50%
  X = DENSITY (M4i OR M4DUM) >= 0 WINDOW 200 GRADIENT > 0.5 ABSOLUTE BACKUP PRINT density_report_M4_7b.log RDB density_report_M4_7b.db 
  X NOT MARKS
}
M4_7c_density {
@ M4 maximum density(%) with 840um*840um window is 70%
  DENSITY_MARK = BORDER NOT MARKS
  CHECK_LAYER = M4i_all NOT MARKS
  CHECK_REGION = COPY DENSITY_MARK
  X = DENSITY CHECK_LAYER CHECK_REGION [area(CHECK_LAYER)/area(CHECK_REGION)] > 0.7 WINDOW 840 BACKUP PRINT density_report_M4_7c.log RDB density_report_M4_7c.db 
  X NOT MARKS
}
M4_7d_R_density_ON {
@ [(M4 with width > 2.8um) over M3] maximum density(%) with 200um*200um step size 100um is 70%
 DENSITY_MARK = BORDER NOT MARKS
 CHECK_LAYER = (((M4i WITH WIDTH > 2.800) OR (M4DUM WITH WIDTH > 2.800)) AND (M3i OR M3DUM)) NOT MARKS
 CHECK_REGION = COPY DENSITY_MARK
 X = DENSITY CHECK_LAYER CHECK_REGION [area(CHECK_LAYER)/area(CHECK_REGION)] > 0.7 WINDOW 200 STEP 100 BACKUP PRINT density_report_M4_7d.log RDB density_report_M4_7d.db
 X NOT MARKS
}
M4_7e_R_density_ON {
@ [(M3 with width > 2.8um) over M4] maximum density(%) with 200um*200um step size 100um is 70%
  DENSITY_MARK = BORDER NOT MARKS
  CHECK_LAYER = ((M4i OR M4DUM) AND ((M3i WITH WIDTH > 2.80) OR (M3DUM WITH WIDTH > 2.80))) NOT MARKS
  CHECK_REGION = COPY DENSITY_MARK
  X = DENSITY CHECK_LAYER CHECK_REGION [area(CHECK_LAYER)/area(CHECK_REGION)] > 0.7 WINDOW 200 STEP 100 BACKUP PRINT density_report_M4_7e.log RDB density_report_M4_7e.db
  X NOT MARKS
}

M4_8 {
@ (M4 at 45degree ) minimum width (run length>0um) is 0.17
   M445 = ANGLE M4_all == 45
   INT M445 < 0.17 OPPOSITE REGION
}
M4_9 {
@ (M4 at 45degree) minimum space to parallel M4 (run length>0um) is 0.17
  M445 = ANGLE M4_all == 45
  EXT M445 < 0.17 OPPOSITE REGION
}
M4END = CONVEX EDGE M4 ANGLE1 ==90 LENGTH1 >=0.08 ANGLE2  ==90 LENGTH2  >=0.08 WITH LENGTH  <=0.11 
/*
M4.10a {
@Minimum space between an Mn line end to an Mn (the parallel run length >0um) is 0.07.Excluding checking SRAM area
X =EXT M4END M4<0.07 OPPOSITE REGION
X OUTSIDE INST
}
M4.10b{
@ Minimum space between an Mn line end (with Vn) to an Mn (the parallel run length >0um) is 0.07. The Mn line end extend Q from Vn, 0.03 <= Q <0.05um Excluding checking SRAM area
X1 = EXT M4END  M4 <0.07 OPPOSITE REGION
X2 = M4END COIN EDGE X1 
X3 = ENC  V4 X2 <0.05 OPPOSITE REGION
X4 = ENC V4 X2 <0.03 OPPOSITE REGION
X5 = V4 INTERACT X3  
X6 = V4 INTERACT X4
X7 = X5 NOT X6
X=X1 TOUCH (X3 INTERACT X7)
X OUTSIDE INST
}
*/
/*M4.10c{
@ Minimum space between an Mn line end (with Vn) to an Mn (the parallel run length >0um ) is 0.1. The Mn line end extend Q from Vn, 0 <= Q <0.03um 
X1 = EXT M4END  M4 <0.1 OPPOSITE REGION
X2 = M4END COIN EDGE X1 
X3 = ENC  V4 X2 <0.03 ABUT<90 OPPOSITE REGION
X4 = V4 INTERACT X3
X1 TOUCH (X3 INTERACT X4)
}*/
M4_11 {
@ Space between Vn-1 (Vn-1 is enclosed by Mn[A]) to neighbouring metal line Mn[B], when the layout structures meet the following conditions:
@ 1.	Mn[A] line end definition: line width W <0.1um. 
@ 2.	Vn-1 enclosure by Mn[A] line end: E < 0.05um
@ 3.	The parallel run length of Mn[A] and Mn[B]:E1 >=-0.03um
@ 4.	Space between Mn[A] to the neighbouring parallel metal line: Ds<0.08um;
@ 5.	Any one edge distance from the corner of the two edges of Mn[A]: K1 <0.095um
@ At least one Vn-1 in the Mn[A] and Mn-1 intersection meet this rule is ok.
@ This rule is not applicable for SRAM region DRC check.		0.12
LINE_END = CONVEX EDGE M4 ANGLE1 ==90 LENGTH1 >=0.08 ANGLE2  ==90 LENGTH2  >=0.08 WITH LENGTH  <0.1
 X1 =ENC V3  LINE_END<0.05 ABUT<90 REGION OPPOSITE
 X2 = V3 INTERACT X1 
 X3 = X2 INSIDE (M3 AND M4)
 X8 =X3 TOUCH EDGE X1
LINE_END_SHAPE = EXPAND EDGE LINE_END INSIDE BY 0.095
LINE_SIDE = (M4 COIN EDGE LINE_END_SHAPE ) NOT COIN EDGE LINE_END
LINE_SIDE1 = ENC X3 LINE_SIDE<0.03 REGION ABUT<90 OPPOSITE
V3_EDGE =(LINE_SIDE1 OR X3) TOUCH EDGE X8
LINE_END_EXP = EXPAND EDGE V3_EDGE INSIDE BY 0.001 EXTEND BY 0.031
LINE_SIDE_EXP = EXPAND EDGE LINE_SIDE INSIDE BY 0.001 
LINE_END_1 = LINE_END_EXP TOUCH EDGE V3_EDGE 
LINE_SIDE_1 = LINE_SIDE_EXP  TOUCH EDGE  LINE_SIDE
E1 = EXT [LINE_END_1] M4 < 0.12 OPPOSITE PERP ALSO OBTUSE ALSO 
E2 = EXT [LINE_SIDE_1] M4< 0.08  OPPOSITE PERP ALSO OBTUSE ALSO
LINE_END_E1 = LINE_END_1 TOUCH EDGE E1
LINE_SIDE_E2 = LINE_SIDE_1 TOUCH EDGE E2
V42 =X3 WITH EDGE (X8 TOUCH EDGE LINE_END_E1)   
X5 = V3 INTERACT V42
X6 = V3 NOT X5
X7 = ((M3 AND M4) ENCLOSE X5) ENCLOSE X6
M2_CORNER1 = INT LINE_END_E1 LINE_SIDE_E2 <= 0.002 ABUT==90 REGION
(M2_CORNER1 NOT INTERACT X7) OUTSIDE INST

}

M4_12_R_OFF {
@ Minimum Mn to Mn space S at Mn line-end 0.1. Width W < 0.1um . The minimum space can be line end head to other Mn or line end side to other M1.  Rule check:
@ S >= (Dh or Ds ).  E1 =0.03, K1=0.095 , Dh=Ds=0.1 in the illustration. 
@ Outside of SRAM(INST) area.
@ Waive extrusion F < 0.07.
@ Waive the violation for MOM (within MOMDMY).
LINE_END = CONVEX EDGE M4_all ANGLE1 ==90 LENGTH1 >=0.07 ANGLE2  ==90 LENGTH2  >=0.07 WITH LENGTH  < 0.1
LINE_END_SHAPE = EXPAND EDGE LINE_END INSIDE BY 0.064
LINE_SIDE = (M4_all COIN EDGE LINE_END_SHAPE ) NOT COIN EDGE LINE_END
LINE_END_EXP = EXPAND EDGE LINE_END INSIDE BY 0.001 EXTEND BY 0.031
LINE_SIDE_EXP = EXPAND EDGE LINE_SIDE INSIDE BY 0.001 EXTEND BY 0.031
LINE_END_1 = LINE_END_EXP TOUCH EDGE LINE_END
LINE_SIDE_1 = LINE_SIDE_EXP TOUCH EDGE LINE_SIDE
E1 = EXT [LINE_END_1] M4_all < 0.1 OPPOSITE PERP ALSO OBTUSE ALSO
E2 = EXT [LINE_SIDE_1] M4_all < 0.1  OPPOSITE PERP ALSO OBTUSE ALSO
LINE_END_E1 = LINE_END_1 TOUCH EDGE E1
LINE_SIDE_E2 = LINE_SIDE_1 TOUCH EDGE E2
M4_CORNER = INT LINE_END_E1 LINE_SIDE_E2 <= 0.002 ABUT==90 REGION
MOM =((M3 OR M4) OR M5) INTERACT ( MnPIN INTERACT (SIZE MOMDMY BY 0.114))
((LINE_END_SHAPE INTERACT M4_CORNER) OUTSIDE INST) NOT (MOM OR MOMDMY)
}

M4_13_M2M3M4_density_R_OFF {
    @ It is not allowed to havel local density > 85% of all 3 consecutive metal (1xMn, 1xMn+1 and 1xMn+2) over any window size 62.5*62.5um (stepping size 31.25um).
    @ The metal layers include M1/1xMn and dummy metals.
    @ DRC doesn't check: DUMBM, MARKS and (TM2 and PA) region
	DENSITY_MARK = BORDER NOT (OR DUMBM MARKS (TM2i AND PA))
	M2_TAR = M2i_all NOT (OR DUMBM MARKS (TM2i AND PA))
	M3_TAR = M3i_all NOT (OR DUMBM MARKS (TM2i AND PA))
	M4_TAR = M4i_all NOT (OR DUMBM MARKS (TM2i AND PA))
    CHECK_REGION = COPY DENSITY_MARK
    DENSITY M2_TAR M3_TAR M4_TAR CHECK_REGION > 0 WINDOW 62.5 STEP 31.25 BACKUP PRINT density_report_M2_13_M2M3M4.log RDB density_report_M2_13_M2M3M4.rdb [(~~(AREA(M2_TAR)/AREA(CHECK_REGION) -0.85))&&(~~(AREA(M3_TAR)/AREA(CHECK_REGION) -0.85))&&(~~(AREA(M4_TAR)/AREA(CHECK_REGION) -0.85))]	
}

M4_14_density {
@ M4 density (including dummy) is >= 1%.Density check window size: 80um*80um, step size 40um.
@ DRC only check the region with width of (checking window NOT above excluding region) >= 40um.
  DENSITY_MARK = WITH WIDTH (BORDER NOT MARKS) >= 40
  CHECK_LAYER = M4i_all AND DENSITY_MARK
  CHECK_REGION = COPY DENSITY_MARK
  X = DENSITY CHECK_LAYER CHECK_REGION [area(CHECK_LAYER)/area(CHECK_REGION)] < 0.01 WINDOW 80 STEP 40 BACKUP PRINT density_report_M4_14.log RDB density_report_M4_14.db
  (X NOT MARKS) WITH WIDTH >= 40
}
M4_15 {
    @ Maximum M4 area of merged low density windows must follow item (1) and (2).
    @ The definition of low density window: window size 10um*10um, step size: 5um, density <1%
    @ (1) Maximum area of merged low density window <= 6500um2, except merged low density windows width <= 30um.
    @ (2) Maximum area of merged low density window <= 18500um2.
    @ DRC only check the region with width of (checking window NOT above excluding region) >= 5um
    X = DENSITY M4i_all < 0.01 WINDOW 10 STEP 5 BACKUP PRINT density_report_M4_15.log RDB density_report_M4_15.rdb
    Y = X NOT MARKS
    (AREA Y > 6500) WITH WIDTH > 30
    (AREA Y > 16000) WITH WIDTH >= 5
}

M4_16_M2M3M4_density {
    @ It is not allowed to havel local density < 5% of all 3 consecutive metal (Mn, Mn+1 and Mn+2) over any window 30*30um (stepping 15um).
    @ The metal layers include M1/1xMn and dummy metals.
    @ DRC only check the region with width of (checking window NOT above excluding region) >= 15um
	DENSITY_MARK = WITH WIDTH (BORDER NOT MARKS) >= 15
	M2_TAR = M2i_all AND DENSITY_MARK
	M3_TAR = M3i_all AND DENSITY_MARK
	M4_TAR = M4i_all AND DENSITY_MARK
    CHECK_REGION = COPY DENSITY_MARK
    DENSITY M2_TAR M3_TAR M4_TAR CHECK_REGION > 0 WINDOW 30 STEP 15 BACKUP PRINT density_report_M2_16_M2M3M4.log RDB density_report_M2_16_M2M3M4.rdb [(~~(0.05 -AREA(M2_TAR)/AREA(CHECK_REGION) ))&&(~~(0.05 -AREA(M3_TAR)/AREA(CHECK_REGION) ))&&(~~(0.05 -AREA(M4_TAR)/AREA(CHECK_REGION) ))]
}

#ENDIF

#IFDEF M5_CHECK YES
//=====================
//  M5 - Metal 5 DRC
//=====================

GROUP GM5 M5_?

M5_1 {
@ M5 minimum width is 0.07
  INT M5_all < 0.07 ABUT<90 SINGULAR REGION
}
M5_1_R_OFF {
@ M5 minimum width is 0.08um.
  INT M5 < 0.08 ABUT<90 SINGULAR REGION
}
#IFDEF TOPMETAL 6
M5_2 {
@ M5 maximum width is 4.5.
@ When M5 used for TM-1,DRC waive the (M5 AND DUPMK1) region
  (M5_all WITH WIDTH > 4.50) NOT (M5_all AND DUPMK1)
}
#ELSE
M5_2 {
@ M5 maximum width is 4.5
  M5_all WITH WIDTH > 4.50
}
#ENDIF
M5_3 {
@ M5 minimum space is 0.07
  EXT M5_all < 0.07 ABUT<90 SINGULAR REGION
}
M5_3_R_OFF {
@ M5 minimum space is 0.08um.
  EXT M5 < 0.08 ABUT<90 SINGULAR REGION
}
M5_4 {
@ M5 minimum area is 0.0196
  AREA M5_all < 0.0196
}
/*
M5_4a {
@ Area when all of the M5 edge length < 0.17 m is >= 0.06um2. 
@ This rule is not applicable for SRAM region.
  M5_ignore = M5_all WITH EDGE (LENGTH M5_all >= 0.17)
  (AREA (M5_all NOT M5_ignore) < 0.06) NOT INST
}  
*/
M5_5 {
@ M5 minimum enclosed area is 0.2
  AREA ((HOLES M5_all INNER) NOT M5_all) < 0.2
}

M5_6 {
@ Minimum space between two run length > 0.3 parallel metal lines
@ with  both metal line width is > 0.22 is 0.10
  CMACRO Mn_6 M5i_all 0.3 0.22 0.1
}
M5_6_R_OFF {
@ Minimum space between two length > 0.3 parallel metal lines
@ with  both metal line width is > 0.22 is 0.12um.
  CMACRO Mn_6a M5i 0.3 0.22 0.12
}
M5_6a {
@ Minimum space between two length > 0.6 parallel metal lines
@ with one or both metal line width is > 0.7 is 0.12
  CMACRO Mn_6a M5i_all 0.6 0.7 0.12
}
M5_6b {
@ Minimum space between two length > 0.6 parallel metal lines with one metal
@ line width is > 0.22 and other metal line width is >0.7um is 0.14
   CMACRO Mn_6b M5i_all 0.6 0.22 0.7 0.14
}
M5_6c {
@ Minimum space between two length > 1.5 parallel metal lines
@ with one or both metal line width is > 1.5 is 0.30
  CMACRO Mn_6c M5i_all 1.5 1.5 0.3
}

#IFDEF TOPMETAL 9
M5_7_density {
@ M5 minimum density(%) in 125um*125um window with step size 62.5um is 10%
  DENSITY_MARK = BORDER NOT MARKS
  CHECK_LAYER = M5i_all NOT MARKS
  CHECK_REGION = COPY DENSITY_MARK
  X = DENSITY CHECK_LAYER CHECK_REGION [area(CHECK_LAYER)/area(CHECK_REGION)] < 0.10 WINDOW 125 STEP 62.5 BACKUP PRINT density_report_M5_7.log RDB density_report_M5_7.db
  X NOT MARKS
}
M5_7f_density {
@ M5 density over the whole chip is >=20%
DENSITY_MARK = BORDER NOT MARKS
CHECK_LAYER = M5i_all NOT MARKS
CHECK_REGION = COPY DENSITY_MARK
X =DENSITY CHECK_LAYER CHECK_REGION [area(CHECK_LAYER)/area(CHECK_REGION)] < 0.2 PRINT density_report_M5_7f.log RDB density_report_M5_7f.db
X NOT MARKS
}

#ENDIF
#IFDEF TOPMETAL 8
M5_7_density {
@ M5 minimum density(%) in 125um*125um window with step size 62.5um is 10%
  DENSITY_MARK = BORDER NOT MARKS
  CHECK_LAYER = M5i_all NOT MARKS
  CHECK_REGION = COPY DENSITY_MARK
  X = DENSITY CHECK_LAYER CHECK_REGION [area(CHECK_LAYER)/area(CHECK_REGION)] < 0.10 WINDOW 125 STEP 62.5 BACKUP PRINT density_report_M5_7.log RDB density_report_M5_7.db
  X NOT MARKS
}
M5_7f_density {
@ M5 density over the whole chip is >=20%
DENSITY_MARK = BORDER NOT MARKS
CHECK_LAYER = M5i_all NOT MARKS
CHECK_REGION = COPY DENSITY_MARK
X =DENSITY CHECK_LAYER CHECK_REGION [area(CHECK_LAYER)/area(CHECK_REGION)] < 0.2 PRINT density_report_M5_7f.log RDB density_report_M5_7f.db
X NOT MARKS
}

#ENDIF
#IFDEF TOPMETAL 7
M5_7_density {
@ M5 minimum density(%) in 125um*125um window with step size 62.5um is 10%
  DENSITY_MARK = BORDER NOT MARKS
  CHECK_LAYER = M5i_all NOT MARKS
  CHECK_REGION = COPY DENSITY_MARK
  X = DENSITY CHECK_LAYER CHECK_REGION [area(CHECK_LAYER)/area(CHECK_REGION)] < 0.10 WINDOW 125 STEP 62.5 BACKUP PRINT density_report_M5_7.log RDB density_report_M5_7.db
  X NOT MARKS
}
M5_7f_density {
@ M5 density over the whole chip is >=20%
DENSITY_MARK = BORDER NOT MARKS
CHECK_LAYER = M5i_all NOT MARKS
CHECK_REGION = COPY DENSITY_MARK
X =DENSITY CHECK_LAYER CHECK_REGION [area(CHECK_LAYER)/area(CHECK_REGION)] < 0.2 PRINT density_report_M5_7f.log RDB density_report_M5_7f.db
X NOT MARKS
}

#ENDIF
#IFDEF TOPMETAL 6
M5_7_density {
@ M5 minimum density(%) in 125um*125um window with step size 62.5um is 10%
  DENSITY_MARK = BORDER NOT MARKS
  CHECK_LAYER = M5i_all NOT MARKS
  CHECK_REGION = COPY DENSITY_MARK
  X = DENSITY CHECK_LAYER CHECK_REGION [area(CHECK_LAYER)/area(CHECK_REGION)] < 0.10 WINDOW 125 STEP 62.5 BACKUP PRINT density_report_M5_7.log RDB density_report_M5_7.db
  X NOT MARKS
}
M5_7f_density {
@ M5 density over the whole chip is >=20%
DENSITY_MARK = BORDER NOT MARKS
CHECK_LAYER = M5i_all NOT MARKS
CHECK_REGION = COPY DENSITY_MARK
X =DENSITY CHECK_LAYER CHECK_REGION [area(CHECK_LAYER)/area(CHECK_REGION)] < 0.2 PRINT density_report_M5_7f.log RDB density_report_M5_7f.db
X NOT MARKS
}

#ENDIF

M5_7a_density {
@ M5 maximum density(%) in 125um*125um window with step size 62.5um is 85%
  DENSITY_MARK = BORDER NOT MARKS
  CHECK_LAYER = M5i_all NOT MARKS
  CHECK_REGION = COPY DENSITY_MARK
  X = DENSITY CHECK_LAYER CHECK_REGION [area(CHECK_LAYER)/area(CHECK_REGION)] > 0.85 WINDOW 125 STEP 62.5 BACKUP PRINT density_report_M5_7a.log RDB density_report_M5_7a.db 
  X NOT MARKS
}
M5_7b_density {
@ M5 maximum density difference(%) between any two 200um adjacent window (stepped without overlapping) is 50%
  X = DENSITY (M5i OR M5DUM) >= 0 WINDOW 200 GRADIENT > 0.5 ABSOLUTE BACKUP PRINT density_report_M5_7b.log RDB density_report_M5_7b.db
  X NOT MARKS
}
M5_7c_density {
@ M5 maximum density(%) with 840um*840um window is 70%
  DENSITY_MARK = BORDER NOT MARKS
  CHECK_LAYER = M5i_all NOT MARKS
  CHECK_REGION = COPY DENSITY_MARK
  X = DENSITY CHECK_LAYER CHECK_REGION [area(CHECK_LAYER)/area(CHECK_REGION)] > 0.7 WINDOW 840 BACKUP PRINT density_report_M5_7c.log RDB density_report_M5_7c.db 
  X NOT MARKS
}
M5_7d_R_density_ON {
@ [(M5 with width > 2.8um) over M4] maximum density(%) with 200um*200um step size 100um is 70%
 DENSITY_MARK = BORDER NOT MARKS
 CHECK_LAYER = (((M5i WITH WIDTH > 2.800) OR (M5DUM WITH WIDTH > 2.800)) AND (M4i OR M4DUM)) NOT MARKS
 CHECK_REGION = COPY DENSITY_MARK
 X = DENSITY CHECK_LAYER CHECK_REGION [area(CHECK_LAYER)/area(CHECK_REGION)] > 0.7 WINDOW 200 STEP 100 BACKUP PRINT density_report_M5_7d.log RDB density_report_M5_7d.db
 X NOT MARKS
}
M5_7e_R_density_ON {
@ [(M4 with width > 2.8um) over M5] maximum density(%) with 200um*200um step size 100um is 70%
  DENSITY_MARK = BORDER NOT MARKS
  CHECK_LAYER = ((M5i OR M5DUM) AND ((M4i WITH WIDTH > 2.80) OR (M4DUM WITH WIDTH > 2.80))) NOT MARKS
  CHECK_REGION = COPY DENSITY_MARK
  X = DENSITY CHECK_LAYER CHECK_REGION [area(CHECK_LAYER)/area(CHECK_REGION)] > 0.7 WINDOW 200 STEP 100 BACKUP PRINT density_report_M5_7e.log RDB density_report_M5_7e.db
  X NOT MARKS
}

M5_8 {
@ (M5 at 45degree ) minimum width (run length>0um) is 0.17
   M545 = ANGLE M5_all == 45
   INT M545 < 0.17 OPPOSITE REGION
}
M5_9 {
@ (M5 at 45degree) minimum space to parallel M5 (run length>0um) is 0.17
  M545 = ANGLE M5_all == 45
  EXT M545 < 0.17 OPPOSITE REGION
}
M5END = CONVEX EDGE M5 ANGLE1 ==90 LENGTH1 >=0.08 ANGLE2  ==90 LENGTH2  >=0.08 WITH LENGTH  <=0.11 
/*
M5.10a {
@Minimum space between an Mn line end to an Mn (the parallel run length >0um) is 0.07 Excluding checking SRAM area
X=EXT M5END M5<0.07 OPPOSITE REGION
X OUTSIDE INST
}
M5.10b{
@ Minimum space between an Mn line end (with Vn) to an Mn (the parallel run length >0um) is 0.07. The Mn line end extend Q from Vn, 0.03 <= Q <0.05um. Excluding checking SRAM area
X1 = EXT M5END  M5 <0.07 OPPOSITE REGION
X2 = M5END COIN EDGE X1 
X3 = ENC  V5 X2 <0.05 OPPOSITE REGION
X4 = ENC V5 X2 <0.03 OPPOSITE REGION
X5 = V5 INTERACT X3  
X6 = V5 INTERACT X4
X7 = X5 NOT X6
X =X1 TOUCH (X3 INTERACT X7)
X OUTSIDE INST
}
*/
/*M5.10c{
@ Minimum space between an Mn line end (with Vn) to an Mn (the parallel run length >0um ) is 0.1. The Mn line end extend Q from Vn, 0 <= Q <0.03um 
X1 = EXT M5END  M5 <0.1 OPPOSITE REGION
X2 = M5END COIN EDGE X1 
X3 = ENC  V5 X2 <0.03 ABUT<90 OPPOSITE REGION
X4 = V5 INTERACT X3
X1 TOUCH (X3 INTERACT X4)
}*/
M5_11 {
@ Space between Vn-1 (Vn-1 is enclosed by Mn[A]) to neighbouring metal line Mn[B], when the layout structures meet the following conditions:
@ 1.	Mn[A] line end definition: line width W <0.1um. 
@ 2.	Vn-1 enclosure by Mn[A] line end: E < 0.05um
@ 3.	The parallel run length of Mn[A] and Mn[B]:E1 >=-0.03um
@ 4.	Space between Mn[A] to the neighbouring parallel metal line: Ds<0.08um;
@ 5.	Any one edge distance from the corner of the two edges of Mn[A]: K1 <0.095um
@ At least one Vn-1 in the Mn[A] and Mn-1 intersection meet this rule is ok.
@ This rule is not applicable for SRAM region DRC check.		0.12
LINE_END = CONVEX EDGE M5 ANGLE1 ==90 LENGTH1 >=0.08 ANGLE2  ==90 LENGTH2  >=0.08 WITH LENGTH  <0.1
 X1 =ENC V4  LINE_END<0.05 ABUT<90 REGION OPPOSITE
 X2 = V4 INTERACT X1 
 X3 = X2 INSIDE (M5 AND M4)
 X8 =X3 TOUCH EDGE X1
LINE_END_SHAPE = EXPAND EDGE LINE_END INSIDE BY 0.095
LINE_SIDE = (M5 COIN EDGE LINE_END_SHAPE ) NOT COIN EDGE LINE_END
LINE_SIDE1 = ENC X3 LINE_SIDE<0.03 REGION ABUT<90 OPPOSITE
V4_EDGE =(LINE_SIDE1 OR X3) TOUCH EDGE X8
LINE_END_EXP = EXPAND EDGE V4_EDGE INSIDE BY 0.001 EXTEND BY 0.031
LINE_SIDE_EXP = EXPAND EDGE LINE_SIDE INSIDE BY 0.001 
LINE_END_1 = LINE_END_EXP TOUCH EDGE V4_EDGE 
LINE_SIDE_1 = LINE_SIDE_EXP  TOUCH EDGE  LINE_SIDE
E1 = EXT [LINE_END_1] M5 < 0.12 OPPOSITE PERP ALSO OBTUSE ALSO 
E2 = EXT [LINE_SIDE_1] M5< 0.08  OPPOSITE PERP ALSO OBTUSE ALSO
LINE_END_E1 = LINE_END_1 TOUCH EDGE E1
LINE_SIDE_E2 = LINE_SIDE_1 TOUCH EDGE E2
V42 =X3 WITH EDGE (X8 TOUCH EDGE LINE_END_E1)   
X5 = V4 INTERACT V42
X6 = V4 NOT X5
X7 = ((M5 AND M4) ENCLOSE X5) ENCLOSE X6
M2_CORNER1 = INT LINE_END_E1 LINE_SIDE_E2 <= 0.002 ABUT==90 REGION
(M2_CORNER1 NOT INTERACT X7) OUTSIDE INST


}

M5_12_R_OFF {
@ Minimum Mn to Mn space S at Mn line-end 0.1. Width W < 0.1um . The minimum space can be line end head to other Mn or line end side to other M1.  Rule check:
@ S >= (Dh or Ds ).  E1 =0.03, K1=0.095 , Dh=Ds=0.1 in the illustration. 
@ Outside of SRAM(INST) area.
@ Waive extrusion F < 0.07.
@ Waive the violation for MOM (within MOMDMY).
LINE_END = CONVEX EDGE M5_all ANGLE1 ==90 LENGTH1 >=0.07 ANGLE2  ==90 LENGTH2  >=0.07 WITH LENGTH  < 0.1
LINE_END_SHAPE = EXPAND EDGE LINE_END INSIDE BY 0.064
LINE_SIDE = (M5_all COIN EDGE LINE_END_SHAPE ) NOT COIN EDGE LINE_END
LINE_END_EXP = EXPAND EDGE LINE_END INSIDE BY 0.001 EXTEND BY 0.031
LINE_SIDE_EXP = EXPAND EDGE LINE_SIDE INSIDE BY 0.001 EXTEND BY 0.031
LINE_END_1 = LINE_END_EXP TOUCH EDGE LINE_END
LINE_SIDE_1 = LINE_SIDE_EXP TOUCH EDGE LINE_SIDE
E1 = EXT [LINE_END_1] M5_all < 0.1 OPPOSITE PERP ALSO OBTUSE ALSO
E2 = EXT [LINE_SIDE_1] M5_all < 0.1  OPPOSITE PERP ALSO OBTUSE ALSO
LINE_END_E1 = LINE_END_1 TOUCH EDGE E1
LINE_SIDE_E2 = LINE_SIDE_1 TOUCH EDGE E2
M5_CORNER = INT LINE_END_E1 LINE_SIDE_E2 <= 0.002 ABUT==90 REGION
MOM =((M4 OR M5) OR M6) INTERACT ( MnPIN INTERACT (SIZE MOMDMY BY 0.114))
((LINE_END_SHAPE INTERACT M5_CORNER) OUTSIDE INST) NOT (MOM OR MOMDMY)
}

M5_13_M3M4M5_density_R_OFF {
    @ It is not allowed to havel local density > 85% of all 3 consecutive metal (1xMn, 1xMn+1 and 1xMn+2) over any window size 62.5*62.5um (stepping size 31.25um).
    @ The metal layers include M1/1xMn and dummy metals.
    @ DRC doesn't check: DUMBM, MARKS and (TM2 and PA) region
    DENSITY_MARK = BORDER NOT (OR DUMBM MARKS (TM2i AND PA))
	M3_TAR = M3i_all NOT (OR DUMBM MARKS (TM2i AND PA))
	M4_TAR = M4i_all NOT (OR DUMBM MARKS (TM2i AND PA))
	M5_TAR = M5i_all NOT (OR DUMBM MARKS (TM2i AND PA))
    CHECK_REGION = COPY DENSITY_MARK
    DENSITY M3_TAR M4_TAR M5_TAR CHECK_REGION > 0 WINDOW 62.5 STEP 31.25 BACKUP PRINT density_report_M3_13_M3M4M5.log RDB density_report_M3_13_M3M4M5.rdb [(~~(AREA(M3_TAR)/AREA(CHECK_REGION) -0.85))&&(~~(AREA(M4_TAR)/AREA(CHECK_REGION) -0.85))&&(~~(AREA(M5_TAR)/AREA(CHECK_REGION) -0.85))]   
}

M5_14_density {
@ M5 density (including dummy) is >= 1%.Density check window size: 80um*80um, step size 40um.
@ DRC only check the region with width of (checking window NOT above excluding region) >= 40um.
  DENSITY_MARK = WITH WIDTH (BORDER NOT MARKS) >= 40
  CHECK_LAYER = M5i_all AND DENSITY_MARK  
  CHECK_REGION = COPY DENSITY_MARK
  X = DENSITY CHECK_LAYER CHECK_REGION [area(CHECK_LAYER)/area(CHECK_REGION)] < 0.01 WINDOW 80 STEP 40 BACKUP PRINT density_report_M5_14.log RDB density_report_M5_14.db
  (X NOT MARKS) WITH WIDTH >= 40
}
M5_15 {
    @ Maximum M5 area of merged low density windows must follow item (1) and (2).
    @ The definition of low density window: window size 10um*10um, step size: 5um, density <1%
    @ (1) Maximum area of merged low density window <= 6500um2, except merged low density windows width <= 30um.
    @ (2) Maximum area of merged low density window <= 18500um2.
    @ DRC only check the region with width of (checking window NOT above excluding region) >= 5um
    X = DENSITY M5i_all < 0.01 WINDOW 10 STEP 5 BACKUP PRINT density_report_M5_15.log RDB density_report_M5_15.rdb
    Y = X NOT MARKS
    (AREA Y > 6500) WITH WIDTH > 30
    (AREA Y > 16000) WITH WIDTH >= 5
}
M5_16_M3M4M5_density {
    @ It is not allowed to havel local density < 5% of all 3 consecutive metal (Mn, Mn+1 and Mn+2) over any window 30*30um (stepping 15um).
    @ The metal layers include M1/1xMn and dummy metals.
    @ DRC only check the region with width of (checking window NOT above excluding region) >= 15um
	DENSITY_MARK = WITH WIDTH (BORDER NOT MARKS) >= 15
	M3_TAR = M3i_all AND DENSITY_MARK
	M4_TAR = M4i_all AND DENSITY_MARK
	M5_TAR = M5i_all AND DENSITY_MARK
    CHECK_REGION = COPY DENSITY_MARK
    DENSITY M3_TAR M4_TAR M5_TAR CHECK_REGION > 0 WINDOW 30 STEP 15 BACKUP PRINT density_report_M3_16_M3M4M5.log RDB density_report_M3_16_M3M4M5.rdb [(~~(0.05 -AREA(M3_TAR)/AREA(CHECK_REGION) ))&&(~~(0.05 -AREA(M4_TAR)/AREA(CHECK_REGION) ))&&(~~(0.05 -AREA(M5_TAR)/AREA(CHECK_REGION) ))]
}

#ENDIF

#IFDEF M6_CHECK YES
//=====================
//  M6 - Metal 6 DRC
//=====================

GROUP GM6 M6_?

M6_1 {
@ M6 minimum width is 0.07
  INT M6_all < 0.07 ABUT<90 SINGULAR REGION
}
M6_1_R_OFF {
@ M6 minimum width is 0.08um.
  INT M6 < 0.08 ABUT<90 SINGULAR REGION
}
#IFDEF TOPMETAL 7
M6_2 {
@ M6 maximum width is 4.5.
@ When M6 used for TM-1,DRC waive the (M6 AND DUPMK1) region.
  (M6_all WITH WIDTH > 4.50) NOT (M6_all AND DUPMK1)
}
#ELSE
M6_2 {
@ M6 maximum width is 4.5
  M6_all WITH WIDTH > 4.50
}
#ENDIF
M6_3 {
@ M6 minimum space is 0.07
  EXT M6_all < 0.07 ABUT<90 SINGULAR REGION
}
M6_3_R_OFF {
@ M6 minimum space is 0.08
  EXT M6 < 0.08 ABUT<90 SINGULAR REGION
}
M6_4 {
@ M6 minimum area is 0.0196
  AREA M6_all < 0.0196
}
/*
M6_4a {
@ Area when all of the M6 edge length < 0.17 m is >= 0.06um2. 
@ This rule is not applicable for SRAM region.
  M6_ignore = M6_all WITH EDGE (LENGTH M6_all >= 0.17)
  (AREA (M6_all NOT M6_ignore) < 0.06) NOT INST
}  
*/
M6_5 {
@ M6 minimum enclosed area is 0.2
  AREA ((HOLES M6_all INNER) NOT M6_all) < 0.2
}

M6_6 {
@ Minimum space between two run length > 0.3 parallel metal lines
@ with both metal line width is > 0.22 is 0.10
  CMACRO Mn_6 M6i_all 0.3 0.22 0.1
}
M6_6_R_OFF {
@ Minimum space between two length > 0.3 parallel metal lines
@ with both metal line width is > 0.22 is 0.12um.
  CMACRO Mn_6a M6i 0.3 0.22 0.12
}
M6_6a {
@ Minimum space between two length > 0.6 parallel metal lines
@ with one or both metal line width is > 0.7 is 0.12
  CMACRO Mn_6a M6i_all 0.6 0.7 0.12
}
M6_6b {
@ Minimum space between two length > 0.6 parallel metal lines with one metal
@ line width is > 0.22 and other metal line width is >0.7um is 0.14
  CMACRO Mn_6b M6i_all 0.6 0.22 0.7 0.14
}
M6_6c {
@ Minimum space between two length > 1.5 parallel metal lines
@ with both metal line width is > 1.5 is 0.30
  CMACRO Mn_6c M6i_all 1.5 1.5 0.3
}

#IFDEF TOPMETAL 9
M6_7_density {
@ M6 minimum density(%) in 125um*125um window with step size 62.5um is 10%
  DENSITY_MARK = BORDER NOT MARKS
  CHECK_LAYER = M6i_all NOT MARKS
  CHECK_REGION = COPY DENSITY_MARK
  X = DENSITY CHECK_LAYER CHECK_REGION [area(CHECK_LAYER)/area(CHECK_REGION)] < 0.10 WINDOW 125 STEP 62.5 BACKUP PRINT density_report_M6_7.log RDB density_report_M6_7.db
  X NOT MARKS
}
M6_7f_density {
@ M6 density over the whole chip is >=20%
DENSITY_MARK = BORDER NOT MARKS
CHECK_LAYER = M6i_all NOT MARKS
CHECK_REGION = COPY DENSITY_MARK
X =DENSITY CHECK_LAYER CHECK_REGION [area(CHECK_LAYER)/area(CHECK_REGION)] < 0.2 PRINT density_report_M6_7f.log RDB density_report_M6_7f.db
X NOT MARKS
}

#ENDIF
#IFDEF TOPMETAL 8
M6_7_density {
@ M6 minimum density(%) in 125um*125um window with step size 62.5um is 10%
  DENSITY_MARK = BORDER NOT MARKS
  CHECK_LAYER = M6i_all NOT MARKS
  CHECK_REGION = COPY DENSITY_MARK
  X = DENSITY CHECK_LAYER CHECK_REGION [area(CHECK_LAYER)/area(CHECK_REGION)] < 0.10 WINDOW 125 STEP 62.5 BACKUP PRINT density_report_M6_7.log RDB density_report_M6_7.db
  X NOT MARKS
}
M6_7f_density {
@ M6 density over the whole chip is >=20%
DENSITY_MARK = BORDER NOT MARKS
CHECK_LAYER = M6i_all NOT MARKS
CHECK_REGION = COPY DENSITY_MARK
X =DENSITY CHECK_LAYER CHECK_REGION [area(CHECK_LAYER)/area(CHECK_REGION)] < 0.2 PRINT density_report_M6_7f.log RDB density_report_M6_7f.db
X NOT MARKS
}

#ENDIF
#IFDEF TOPMETAL 7
M6_7_density {
@ M6 minimum density(%) in 125um*125um window with step size 62.5um is 10%
  DENSITY_MARK = BORDER NOT MARKS
  CHECK_LAYER = M6i_all NOT MARKS
  CHECK_REGION = COPY DENSITY_MARK
  X = DENSITY CHECK_LAYER CHECK_REGION [area(CHECK_LAYER)/area(CHECK_REGION)] < 0.10 WINDOW 125 STEP 62.5 BACKUP PRINT density_report_M6_7.log RDB density_report_M6_7.db
  X NOT MARKS
}
M6_7f_density {
@ M6 density over the whole chip is >=20%
DENSITY_MARK = BORDER NOT MARKS
CHECK_LAYER = M6i_all NOT MARKS
CHECK_REGION = COPY DENSITY_MARK
X =DENSITY CHECK_LAYER CHECK_REGION [area(CHECK_LAYER)/area(CHECK_REGION)] < 0.2 PRINT density_report_M6_7f.log RDB density_report_M6_7f.db
X NOT MARKS
}

#ENDIF

M6_7a_density {
@ M6 maximum density(%) in 125um*125um window with step size 62.5um is 85%
  DENSITY_MARK = BORDER NOT MARKS
  CHECK_LAYER = M6i_all NOT MARKS
  CHECK_REGION = COPY DENSITY_MARK
  X = DENSITY CHECK_LAYER CHECK_REGION [area(CHECK_LAYER)/area(CHECK_REGION)] > 0.85 WINDOW 125 STEP 62.5 BACKUP PRINT density_report_M6_7a.log RDB density_report_M6_7a.db 
  X NOT MARKS
}
M6_7b_density {
@ M6 maximum density difference(%) between any two 200um adjacent window (stepped without overlapping) is 50%
  X = DENSITY (M6i OR M6DUM) >= 0 WINDOW 200 GRADIENT > 0.5 ABSOLUTE BACKUP PRINT density_report_M6_7b.log RDB density_report_M6_7b.db
  X NOT MARKS
}
M6_7c_density {
@ M6 maximum density(%) with 840um*840um window is 70%
  DENSITY_MARK = BORDER NOT MARKS
  CHECK_LAYER = M6i_all NOT MARKS
  CHECK_REGION = COPY DENSITY_MARK
  X = DENSITY CHECK_LAYER CHECK_REGION [area(CHECK_LAYER)/area(CHECK_REGION)] > 0.7 WINDOW 840 BACKUP PRINT density_report_M6_7c.log RDB density_report_M6_7c.db 
  X NOT MARKS
}
M6_7d_R_density_ON {
@ [(M6 with width > 2.8um) over M5] maximum density(%) with 200um*200um step size 100um is 70%
 DENSITY_MARK = BORDER NOT MARKS
 CHECK_LAYER = (((M6i WITH WIDTH > 2.800) OR (M6DUM WITH WIDTH > 2.800)) AND (M5i OR M5DUM)) NOT MARKS
 CHECK_REGION = COPY DENSITY_MARK
 X = DENSITY CHECK_LAYER CHECK_REGION [area(CHECK_LAYER)/area(CHECK_REGION)] > 0.7 WINDOW 200 STEP 100 BACKUP PRINT density_report_M6_7d.log RDB density_report_M6_7d.db
 X NOT MARKS
}
M6_7e_R_density_ON {
@ [(M5 with width > 2.8um) over M6] maximum density(%) with 200um*200um step size 100um is 70%
  DENSITY_MARK = BORDER NOT MARKS
  CHECK_LAYER = ((M6i OR M6DUM) AND ((M5i WITH WIDTH > 2.80) OR (M5DUM WITH WIDTH > 2.80))) NOT MARKS
  CHECK_REGION = COPY DENSITY_MARK
  X = DENSITY CHECK_LAYER CHECK_REGION [area(CHECK_LAYER)/area(CHECK_REGION)] > 0.7 WINDOW 200 STEP 100 BACKUP PRINT density_report_M6_7e.log RDB density_report_M6_7e.db
  X NOT MARKS
}

M6_8 {
@ (M6 at 45degree ) minimum width (run length>0um) is 0.17
   M645 = ANGLE M6_all == 45
   INT M645 < 0.17 OPPOSITE REGION
}
M6_9 {
@ (M6 at 45degree) minimum space to parallel M6 (run length>0um) is 0.17
  M645 = ANGLE M6_all == 45
  EXT M645 < 0.17 OPPOSITE REGION
}
M6END = CONVEX EDGE M6 ANGLE1 ==90 LENGTH1 >=0.08 ANGLE2  ==90 LENGTH2  >=0.08 WITH LENGTH  <=0.11 
/*
M6.10a {
@Minimum space between an Mn line end to an Mn (the parallel run length >0um) is 0.07.Excluding checking SRAM area
X =EXT M6END M6<0.07 OPPOSITE REGION
X OUTSIDE INST
}
M6.10b{
@ Minimum space between an Mn line end (with Vn) to an Mn (the parallel run length >0um) is 0.07. The Mn line end extend Q from Vn, 0.03 <= Q <0.05um.Excluding checking SRAM area
X1 = EXT M6END  M6 <0.07 OPPOSITE REGION
X2 = M6END COIN EDGE X1 
X3 = ENC  V6 X2 <0.05 OPPOSITE REGION
X4 = ENC V6 X2 <0.03 OPPOSITE REGION
X5 = V6 INTERACT X3  
X6 = V6 INTERACT X4
X7 = X5 NOT X6
X =X1 TOUCH (X3 INTERACT X7)
X OUT INST
}
*/
/*M6.10c{
@ Minimum space between an Mn line end (with Vn) to an Mn (the parallel run length >0um ) is 0.1. The Mn line end extend Q from Vn, 0 <= Q <0.03um 
X1 = EXT M6END  M6 <0.1 OPPOSITE REGION
X2 = M6END COIN EDGE X1 
X3 = ENC  V6 X2 <0.03 ABUT<90 OPPOSITE REGION
X4 = V6 INTERACT X3
X1 TOUCH (X3 INTERACT X4)
}*/
M6_11 {
@ Space between Vn-1 (Vn-1 is enclosed by Mn[A]) to neighbouring metal line Mn[B], when the layout structures meet the following conditions:
@ 1.	Mn[A] line end definition: line width W <0.1um. 
@ 2.	Vn-1 enclosure by Mn[A] line end: E < 0.05um
@ 3.	The parallel run length of Mn[A] and Mn[B]:E1 >=-0.03um
@ 4.	Space between Mn[A] to the neighbouring parallel metal line: Ds<0.08um;
@ 5.	Any one edge distance from the corner of the two edges of Mn[A]: K1 <0.095um
@ At least one Vn-1 in the Mn[A] and Mn-1 intersection meet this rule is ok.
@ This rule is not applicable for SRAM region DRC check.		0.12
LINE_END = CONVEX EDGE M6 ANGLE1 ==90 LENGTH1 >=0.08 ANGLE2  ==90 LENGTH2  >=0.08 WITH LENGTH  <0.1
  X1 =ENC V5  LINE_END<0.05 ABUT<90 REGION OPPOSITE
 X2 = V5 INTERACT X1 
 X3 = X2 INSIDE (M5 AND M6)
 X8 =X3 TOUCH EDGE X1
LINE_END_SHAPE = EXPAND EDGE LINE_END INSIDE BY 0.095
LINE_SIDE = (M6 COIN EDGE LINE_END_SHAPE ) NOT COIN EDGE LINE_END
LINE_SIDE1 = ENC X3 LINE_SIDE<0.03 REGION ABUT<90 OPPOSITE
V5_EDGE =(LINE_SIDE1 OR X3) TOUCH EDGE X8
LINE_END_EXP = EXPAND EDGE V5_EDGE INSIDE BY 0.001 EXTEND BY 0.031
LINE_SIDE_EXP = EXPAND EDGE LINE_SIDE INSIDE BY 0.001 
LINE_END_1 = LINE_END_EXP TOUCH EDGE V5_EDGE 
LINE_SIDE_1 = LINE_SIDE_EXP  TOUCH EDGE  LINE_SIDE
E1 = EXT [LINE_END_1] M6 < 0.12 OPPOSITE PERP ALSO OBTUSE ALSO 
E2 = EXT [LINE_SIDE_1] M6< 0.08  OPPOSITE PERP ALSO OBTUSE ALSO
LINE_END_E1 = LINE_END_1 TOUCH EDGE E1
LINE_SIDE_E2 = LINE_SIDE_1 TOUCH EDGE E2
V42 =X3 WITH EDGE (X8 TOUCH EDGE LINE_END_E1)   
X5 = V5 INTERACT V42
X6 = V5 NOT X5
X7 = ((M5 AND M6) ENCLOSE X5) ENCLOSE X6
M2_CORNER1 = INT LINE_END_E1 LINE_SIDE_E2 <= 0.002 ABUT==90 REGION
(M2_CORNER1 NOT INTERACT X7) OUTSIDE INST


}

M6_12_R_OFF {
@ Minimum Mn to Mn space S at Mn line-end 0.1. Width W < 0.1um . The minimum space can be line end head to other Mn or line end side to other M1.  Rule check:
@ S >= (Dh or Ds ).  E1 =0.03, K1=0.095 , Dh=Ds=0.1 in the illustration. 
@ Outside of SRAM(INST) area.
@ Waive extrusion F < 0.07.
@ Waive the violation for MOM (within MOMDMY).
LINE_END = CONVEX EDGE M6_all ANGLE1 ==90 LENGTH1 >=0.07 ANGLE2  ==90 LENGTH2  >=0.07 WITH LENGTH  < 0.1
LINE_END_SHAPE = EXPAND EDGE LINE_END INSIDE BY 0.064
LINE_SIDE = (M6_all COIN EDGE LINE_END_SHAPE ) NOT COIN EDGE LINE_END
LINE_END_EXP = EXPAND EDGE LINE_END INSIDE BY 0.001 EXTEND BY 0.031
LINE_SIDE_EXP = EXPAND EDGE LINE_SIDE INSIDE BY 0.001 EXTEND BY 0.031
LINE_END_1 = LINE_END_EXP TOUCH EDGE LINE_END
LINE_SIDE_1 = LINE_SIDE_EXP TOUCH EDGE LINE_SIDE
E1 = EXT [LINE_END_1] M6_all < 0.1 OPPOSITE PERP ALSO OBTUSE ALSO
E2 = EXT [LINE_SIDE_1] M6_all < 0.1  OPPOSITE PERP ALSO OBTUSE ALSO
LINE_END_E1 = LINE_END_1 TOUCH EDGE E1
LINE_SIDE_E2 = LINE_SIDE_1 TOUCH EDGE E2
M6_CORNER = INT LINE_END_E1 LINE_SIDE_E2 <= 0.002 ABUT==90 REGION
MOM =((M5 OR M6) OR M7) INTERACT ( MnPIN INTERACT (SIZE MOMDMY BY 0.114))
((LINE_END_SHAPE INTERACT M6_CORNER) OUTSIDE INST) NOT (MOM OR MOMDMY)
}
M6_13_M4M5M6_density_R_OFF {
    @ It is not allowed to havel local density > 85% of all 3 consecutive metal (1xMn, 1xMn+1 and 1xMn+2) over any window size 62.5*62.5um (stepping size 31.25um).
    @ The metal layers include M1/1xMn and dummy metals.
    @ DRC doesn't check: DUMBM, MARKS and (TM2 and PA) region
    DENSITY_MARK = BORDER NOT (OR DUMBM MARKS (TM2i AND PA))
	M4_TAR = M4i_all NOT (OR DUMBM MARKS (TM2i AND PA))
	M5_TAR = M5i_all NOT (OR DUMBM MARKS (TM2i AND PA))
	M6_TAR = M6i_all NOT (OR DUMBM MARKS (TM2i AND PA))
    CHECK_REGION = COPY DENSITY_MARK
    DENSITY M4_TAR M5_TAR M6_TAR CHECK_REGION > 0 WINDOW 62.5 STEP 31.25 BACKUP PRINT density_report_M4_13_M4M5M6.log RDB density_report_M4_13_M4M5M6.rdb [(~~(AREA(M4_TAR)/AREA(CHECK_REGION) -0.85))&&(~~(AREA(M5_TAR)/AREA(CHECK_REGION) -0.85))&&(~~(AREA(M6_TAR)/AREA(CHECK_REGION) -0.85))]   
}
M6_14_density {
@ M6 density (including dummy) is >= 1%.Density check window size: 80um*80um, step size 40um.
@ DRC only check the region with width of (checking window NOT above excluding region) >= 40um.
  DENSITY_MARK = WITH WIDTH (BORDER NOT MARKS) >= 40
  CHECK_LAYER = M6i_all AND DENSITY_MARK
  CHECK_REGION = COPY DENSITY_MARK
  X = DENSITY CHECK_LAYER CHECK_REGION [area(CHECK_LAYER)/area(CHECK_REGION)] < 0.01 WINDOW 80 STEP 40 BACKUP PRINT density_report_M6_14.log RDB density_report_M6_14.db
  (X NOT MARKS) WITH WIDTH >= 40
}
M6_15 {
    @ Maximum M6 area of merged low density windows must follow item (1) and (2).
    @ The definition of low density window: window size 10um*10um, step size: 5um, density <1%
    @ (1) Maximum area of merged low density window <= 6500um2, except merged low density windows width <= 30um.
    @ (2) Maximum area of merged low density window <= 18500um2.
    @ DRC only check the region with width of (checking window NOT above excluding region) >= 5um
    X = DENSITY M6i_all < 0.01 WINDOW 10 STEP 5 BACKUP PRINT density_report_M6_15.log RDB density_report_M6_15.rdb
    Y = X NOT MARKS
    (AREA Y > 6500) WITH WIDTH > 30
    (AREA Y > 16000) WITH WIDTH >= 5
}
M6_16_M4M5M6_density {
    @ It is not allowed to havel local density < 5% of all 3 consecutive metal (Mn, Mn+1 and Mn+2) over any window 30*30um (stepping 15um).
    @ The metal layers include M1/1xMn and dummy metals.
    @ DRC only check the region with width of (checking window NOT above excluding region) >= 15um
	DENSITY_MARK = WITH WIDTH (BORDER NOT MARKS) >= 15
	M4_TAR = M4i_all AND DENSITY_MARK
	M5_TAR = M5i_all AND DENSITY_MARK
	M6_TAR = M6i_all AND DENSITY_MARK
    CHECK_REGION = COPY DENSITY_MARK
    DENSITY M4_TAR M5_TAR M6_TAR CHECK_REGION > 0 WINDOW 30 STEP 15 BACKUP PRINT density_report_M4_16_M4M5M6.log RDB density_report_M4_16_M4M5M6.rdb [(~~(0.05 -AREA(M4_TAR)/AREA(CHECK_REGION) ))&&(~~(0.05 -AREA(M5_TAR)/AREA(CHECK_REGION) ))&&(~~(0.05 -AREA(M6_TAR)/AREA(CHECK_REGION) ))]
}

#ENDIF

#IFDEF M7_CHECK YES
//=====================
//  M7 - Metal 7 DRC
//=====================

GROUP GM7 M7_?

M7_1 {
@ M7 minimum width is 0.07
  INT M7_all < 0.07 ABUT<90 SINGULAR REGION
}
M7_1_R_OFF {
@ M7 minimum width is 0.08um.
  INT M7 < 0.08 ABUT<90 SINGULAR REGION
}
#IFDEF TOPMETAL 8
M7_2 {
@ M7 maximum width is 4.5.
@ When M7 used for TM-1,DRC waive the (M7 AND DUPMK1) region.
  (M7_all WITH WIDTH > 4.50) NOT (M7_all AND DUPMK1)
}
#ELSE
M7_2 {
@ M7 maximum width is 4.5
  M7_all WITH WIDTH > 4.50
}
#ENDIF
M7_3 {
@ M7 minimum space is 0.07
  EXT M7_all < 0.07 ABUT<90 SINGULAR REGION
}
M7_3_R_OFF {
@ M7 minimum space is 0.08um.
  EXT M7 < 0.08 ABUT<90 SINGULAR REGION
}
M7_4 {
@ M7 minimum area is 0.0196
  AREA M7_all < 0.0196
}
/*
M7_4a {
@ Area when all of the M7 edge length < 0.17 m is >= 0.06um2. 
@ This rule is not applicable for SRAM region.
  M7_ignore = M7_all WITH EDGE (LENGTH M7_all >= 0.17)
  (AREA (M7_all NOT M7_ignore) < 0.06) NOT INST
}  
*/
M7_5 {
@ M7 minimum enclosed area is 0.2
  AREA ((HOLES M7_all INNER) NOT M7_all) < 0.2
}

M7_6 {
@ Minimum space between two run length > 0.3 parallel metal lines
@ with  both metal line width is > 0.22 is 0.10
  CMACRO Mn_6 M7i_all 0.3 0.22 0.1
}
M7_6_R_OFF {
@ Minimum space between two length > 0.3 parallel metal lines
@ with both metal line width is > 0.22 is 0.12um.
  CMACRO Mn_6a M7i 0.3 0.22 0.12
}
M7_6a {
@ Minimum space between two length > 0.6 parallel metal lines
@ with one or both metal line width is > 0.7 is 0.12
  CMACRO Mn_6a M7i_all 0.6 0.7 0.12
}
M7_6b {
@ Minimum space between two length > 0.6 parallel metal lines with one metal
@ line width is > 0.22 and other metal line width is >0.7um is 0.14
  CMACRO Mn_6b M7i_all 0.6 0.22 0.7 0.14
}

M7_6c {
@ Minimum space between two length > 1.5 parallel metal lines
@ with one or both metal line width is > 1.5 is 0.30
  CMACRO Mn_6c M7i_all 1.5 1.5 0.3
}

#IFDEF TOPMETAL 9
M7_7_density {
@ M7 minimum density(%) in 125um*125um window with step size 62.5um is 10%
  DENSITY_MARK = BORDER NOT MARKS
  CHECK_LAYER = M7i_all NOT MARKS
  CHECK_REGION = COPY DENSITY_MARK
  X = DENSITY CHECK_LAYER CHECK_REGION [area(CHECK_LAYER)/area(CHECK_REGION)] < 0.10 WINDOW 125 STEP 62.5 BACKUP PRINT density_report_M7_7.log RDB density_report_M7_7.db
  X NOT MARKS
}
M7_7f_density {
@ M7 density over the whole chip is >=20%
DENSITY_MARK = BORDER NOT MARKS
CHECK_LAYER = M7i_all NOT MARKS
CHECK_REGION = COPY DENSITY_MARK
X =DENSITY CHECK_LAYER CHECK_REGION [area(CHECK_LAYER)/area(CHECK_REGION)] < 0.2 PRINT density_report_M7_7f.log RDB density_report_M7_7f.db
X NOT MARKS
}

#ENDIF
#IFDEF TOPMETAL 8
M7_7_density {
@ M7 minimum density(%) in 125um*125um window with step size 62.5um is 10%
  DENSITY_MARK = BORDER NOT MARKS
  CHECK_LAYER = M7i_all NOT MARKS
  CHECK_REGION = COPY DENSITY_MARK
  X = DENSITY CHECK_LAYER CHECK_REGION [area(CHECK_LAYER)/area(CHECK_REGION)] < 0.10 WINDOW 125 STEP 62.5 BACKUP PRINT density_report_M7_7.log RDB density_report_M7_7.db
  X NOT MARKS
}
M7_7f_density {
@ M7 density over the whole chip is >=20%
DENSITY_MARK = BORDER NOT MARKS
CHECK_LAYER = M7i_all NOT MARKS
CHECK_REGION = COPY DENSITY_MARK
X =DENSITY CHECK_LAYER CHECK_REGION [area(CHECK_LAYER)/area(CHECK_REGION)] < 0.2 PRINT density_report_M7_7f.log RDB density_report_M7_7f.db
X NOT MARKS
}

#ENDIF

M7_7a_density {
@ M7 maximum density(%) in 125um*125um window with step size 62.5um is 85%
  DENSITY_MARK = BORDER NOT MARKS
  CHECK_LAYER = M7i_all NOT MARKS
  CHECK_REGION = COPY DENSITY_MARK
  X = DENSITY CHECK_LAYER CHECK_REGION [area(CHECK_LAYER)/area(CHECK_REGION)] > 0.85 WINDOW 125 STEP 62.5 BACKUP PRINT density_report_M7_7a.log RDB density_report_M7_7a.db 
  X NOT MARKS
}
M7_7b_density {
@ M7 maximum density difference(%) between any two 200um adjacent window (stepped without overlapping) is 50%
  X = DENSITY (M7i OR M7DUM) >= 0 WINDOW 200 GRADIENT > 0.5 ABSOLUTE BACKUP PRINT density_report_M7_7b.log RDB density_report_M7_7b.db
  X NOT MARKS
}
M7_7c_density {
@ M7 maximum density(%) with 840um*840um window is 70%
  DENSITY_MARK = BORDER NOT MARKS
  CHECK_LAYER = M7i_all NOT MARKS
  CHECK_REGION = COPY DENSITY_MARK
  X = DENSITY CHECK_LAYER CHECK_REGION [area(CHECK_LAYER)/area(CHECK_REGION)] > 0.7 WINDOW 840 BACKUP PRINT density_report_M7_7c.log RDB density_report_M7_7c.db 
  X NOT MARKS
}
M7_7d_R_density_ON {
@ [(M7 with width > 2.8um) over M6] maximum density(%) with 200um*200um step size 100um is 70%
 DENSITY_MARK = BORDER NOT MARKS
 CHECK_LAYER = (((M7i WITH WIDTH > 2.800) OR (M7DUM WITH WIDTH > 2.800)) AND (M6i OR M6DUM)) NOT MARKS
 CHECK_REGION = COPY DENSITY_MARK
 X = DENSITY CHECK_LAYER CHECK_REGION [area(CHECK_LAYER)/area(CHECK_REGION)] > 0.7 WINDOW 200 STEP 100 BACKUP PRINT density_report_M7_7d.log RDB density_report_M7_7d.db
 X NOT MARKS
}
M7_7e_R_density_ON {
@ [(M6 with width > 2.8um) over M7] maximum density(%) with 200um*200um step size 100um is 70%
  DENSITY_MARK = BORDER NOT MARKS
  CHECK_LAYER = ((M7i OR M7DUM) AND ((M6i WITH WIDTH > 2.80) OR (M6DUM WITH WIDTH > 2.80))) NOT MARKS
  CHECK_REGION = COPY DENSITY_MARK
  X = DENSITY CHECK_LAYER CHECK_REGION [area(CHECK_LAYER)/area(CHECK_REGION)] > 0.7 WINDOW 200 STEP 100 BACKUP PRINT density_report_M7_7e.log RDB density_report_M7_7e.db
  X NOT MARKS
}

M7_8 {
@ (M7 at 45degree ) minimum width (run length>0um) is 0.17
   M745 = ANGLE M7_all == 45
   INT M745 < 0.17 OPPOSITE REGION
}
M7_9 {
@ (M7 at 45degree) minimum space to parallel M7 (run length>0um) is 0.17
  M745 = ANGLE M7_all == 45
  EXT M745 < 0.17 OPPOSITE REGION
}
M7END = CONVEX EDGE M7 ANGLE1 ==90 LENGTH1 >=0.08 ANGLE2  ==90 LENGTH2  >=0.08 WITH LENGTH  <=0.11 
/*
M7.10a {
@Minimum space between an Mn line end to an Mn (the parallel run length >0um) is 0.07.Excluding checking SRAM area
X= EXT M7END M7<0.07 OPPOSITE REGION
X OUT INST
}
M7.10b{
@ Minimum space between an Mn line end (with Vn) to an Mn (the parallel run length >0um) is 0.07 The Mn line end extend Q from Vn, 0.03 <= Q <0.05um.Excluding checking SRAM area 
X1 = EXT M7END  M7 <0.07 OPPOSITE REGION
X2 = M7END COIN EDGE X1 
X3 = ENC  V7 X2 <0.05 OPPOSITE REGION
X4 = ENC V7 X2 <0.03 OPPOSITE REGION
X5 = V7 INTERACT X3  
X6 = V7 INTERACT X4
X7 = X5 NOT X6
X =X1 TOUCH (X3 INTERACT X7)
X OUTSIDE INST
}
*/
/*M7.10c{
@ Minimum space between an Mn line end (with Vn) to an Mn (the parallel run length >0um ) is 0.1. The Mn line end extend Q from Vn, 0 <= Q <0.03um 
X1 = EXT M7END  M7 <0.1 OPPOSITE REGION
X2 = M7END COIN EDGE X1 
X3 = ENC  V7 X2 <0.03 ABUT<90 OPPOSITE REGION
X4 = V7 INTERACT X3
X1 TOUCH (X3 INTERACT X4)
}*/
M7_11 {
@ Space between Vn-1 (Vn-1 is enclosed by Mn[A]) to neighbouring metal line Mn[B], when the layout structures meet the following conditions:
@ 1.	Mn[A] line end definition: line width W <0.1um. 
@ 2.	Vn-1 enclosure by Mn[A] line end: E < 0.05um
@ 3.	The parallel run length of Mn[A] and Mn[B]:E1 >=-0.03um
@ 4.	Space between Mn[A] to the neighbouring parallel metal line: Ds<0.08um;
@ 5.	Any one edge distance from the corner of the two edges of Mn[A]: K1 <0.095um
@ At least one Vn-1 in the Mn[A] and Mn-1 intersection meet this rule is ok.
@ This rule is not applicable for SRAM region DRC check.		0.12
LINE_END = CONVEX EDGE M7 ANGLE1 ==90 LENGTH1 >=0.08 ANGLE2  ==90 LENGTH2  >=0.08 WITH LENGTH  <0.1
 X1 =ENC V6  LINE_END<0.05 ABUT<90 REGION OPPOSITE
 X2 = V6 INTERACT X1 
 X3 = X2 INSIDE (M7 AND M6)
 X8 =X3 TOUCH EDGE X1
LINE_END_SHAPE = EXPAND EDGE LINE_END INSIDE BY 0.095
LINE_SIDE = (M7 COIN EDGE LINE_END_SHAPE ) NOT COIN EDGE LINE_END
LINE_SIDE1 = ENC X3 LINE_SIDE<0.03 REGION ABUT<90 OPPOSITE
V6_EDGE =(LINE_SIDE1 OR X3) TOUCH EDGE X8
LINE_END_EXP = EXPAND EDGE V6_EDGE INSIDE BY 0.001 EXTEND BY 0.031
LINE_SIDE_EXP = EXPAND EDGE LINE_SIDE INSIDE BY 0.001 
LINE_END_1 = LINE_END_EXP TOUCH EDGE V6_EDGE 
LINE_SIDE_1 = LINE_SIDE_EXP  TOUCH EDGE  LINE_SIDE
E1 = EXT [LINE_END_1] M7 < 0.12 OPPOSITE PERP ALSO OBTUSE ALSO 
E2 = EXT [LINE_SIDE_1] M7< 0.08  OPPOSITE PERP ALSO OBTUSE ALSO
LINE_END_E1 = LINE_END_1 TOUCH EDGE E1
LINE_SIDE_E2 = LINE_SIDE_1 TOUCH EDGE E2
V42 =X3 WITH EDGE (X8 TOUCH EDGE LINE_END_E1)   
X5 = V6 INTERACT V42
X6 = V6 NOT X5
X7 = ((M7 AND M6) ENCLOSE X5) ENCLOSE X6
M2_CORNER1 = INT LINE_END_E1 LINE_SIDE_E2 <= 0.002 ABUT==90 REGION
(M2_CORNER1 NOT INTERACT X7) OUTSIDE INST

}

M7_12_R_OFF {
@ Minimum Mn to Mn space S at Mn line-end 0.1. Width W < 0.1um . The minimum space can be line end head to other Mn or line end side to other M1.  Rule check:
@ S >= (Dh or Ds ).  E1 =0.03, K1=0.095 , Dh=Ds=0.1 in the illustration. 
@ Outside of SRAM(INST) area.
@ Waive extrusion F < 0.07.
@ Waive the violation for MOM (within MOMDMY).
LINE_END = CONVEX EDGE M7_all ANGLE1 ==90 LENGTH1 >=0.07 ANGLE2  ==90 LENGTH2  >=0.07 WITH LENGTH  < 0.1
LINE_END_SHAPE = EXPAND EDGE LINE_END INSIDE BY 0.064
LINE_SIDE = (M7_all COIN EDGE LINE_END_SHAPE ) NOT COIN EDGE LINE_END
LINE_END_EXP = EXPAND EDGE LINE_END INSIDE BY 0.001 EXTEND BY 0.031
LINE_SIDE_EXP = EXPAND EDGE LINE_SIDE INSIDE BY 0.001 EXTEND BY 0.031
LINE_END_1 = LINE_END_EXP TOUCH EDGE LINE_END
LINE_SIDE_1 = LINE_SIDE_EXP TOUCH EDGE LINE_SIDE
E1 = EXT [LINE_END_1] M7_all < 0.1 OPPOSITE PERP ALSO OBTUSE ALSO
E2 = EXT [LINE_SIDE_1] M7_all < 0.1  OPPOSITE PERP ALSO OBTUSE ALSO
LINE_END_E1 = LINE_END_1 TOUCH EDGE E1
LINE_SIDE_E2 = LINE_SIDE_1 TOUCH EDGE E2
M7_CORNER = INT LINE_END_E1 LINE_SIDE_E2 <= 0.002 ABUT==90 REGION
MOM =((M6 OR M7) OR M8) INTERACT ( MnPIN INTERACT (SIZE MOMDMY BY 0.114))
((LINE_END_SHAPE INTERACT M7_CORNER) OUTSIDE INST) NOT (MOM OR MOMDMY)
}

M7_13_M5M6M7_density_R_OFF {
    @ It is not allowed to havel local density > 85% of all 3 consecutive metal (1xMn, 1xMn+1 and 1xMn+2) over any window size 62.5*62.5um (stepping size 31.25um).
    @ The metal layers include M1/1xMn and dummy metals.
    @ DRC doesn't check: DUMBM, MARKS and (TM2 and PA) region
    DENSITY_MARK = BORDER NOT (OR DUMBM MARKS (TM2i AND PA))
	M5_TAR = M5i_all NOT (OR DUMBM MARKS (TM2i AND PA))
	M6_TAR = M6i_all NOT (OR DUMBM MARKS (TM2i AND PA))
	M7_TAR = M7i_all NOT (OR DUMBM MARKS (TM2i AND PA))
    CHECK_REGION = COPY DENSITY_MARK
    DENSITY M5_TAR M6_TAR M7_TAR CHECK_REGION > 0 WINDOW 62.5 STEP 31.25 BACKUP PRINT density_report_M5_13_M5M6M7.log RDB density_report_M5_13_M5M6M7.rdb [(~~(AREA(M5_TAR)/AREA(CHECK_REGION) -0.85))&&(~~(AREA(M6_TAR)/AREA(CHECK_REGION) -0.85))&&(~~(AREA(M7_TAR)/AREA(CHECK_REGION) -0.85))]   
}

M7_14_density {
@ M7 density (including dummy) is >= 1%.Density check window size: 80um*80um, step size 40um.
@ DRC only check the region with width of (checking window NOT above excluding region) >= 40um.
  DENSITY_MARK = WITH WIDTH (BORDER NOT MARKS) >= 40
  CHECK_LAYER = M7i_all AND DENSITY_MARK
  CHECK_REGION = COPY DENSITY_MARK
  X = DENSITY CHECK_LAYER CHECK_REGION [area(CHECK_LAYER)/area(CHECK_REGION)] < 0.01 WINDOW 80 STEP 40 BACKUP PRINT density_report_M7_14.log RDB density_report_M7_14.db
  (X NOT MARKS) WITH WIDTH >= 40
}
M7_15 {
    @ Maximum M7 area of merged low density windows must follow item (1) and (2).
    @ The definition of low density window: window size 10um*10um, step size: 5um, density <1%
    @ (1) Maximum area of merged low density window <= 6500um2, except merged low density windows width <= 30um.
    @ (2) Maximum area of merged low density window <= 18500um2.
    @ DRC only check the region with width of (checking window NOT above excluding region) >= 5um
    X = DENSITY M7i_all < 0.01 WINDOW 10 STEP 5 BACKUP PRINT density_report_M7_15.log RDB density_report_M7_15.rdb
    Y = X NOT MARKS
    (AREA Y > 6500) WITH WIDTH > 30
    (AREA Y > 16000) WITH WIDTH >= 5
}

M7_16_M5M6M7_density {
    @ It is not allowed to havel local density < 5% of all 3 consecutive metal (Mn, Mn+1 and Mn+2) over any window 30*30um (stepping 15um).
    @ The metal layers include M1/1xMn and dummy metals.
    @ DRC only check the region with width of (checking window NOT above excluding region) >= 15um
	DENSITY_MARK = WITH WIDTH (BORDER NOT MARKS) >= 15
	M5_TAR = M5i_all AND DENSITY_MARK
	M6_TAR = M6i_all AND DENSITY_MARK
	M7_TAR = M7i_all AND DENSITY_MARK
    CHECK_REGION = COPY DENSITY_MARK
    DENSITY M5_TAR M6_TAR M7_TAR CHECK_REGION > 0 WINDOW 30 STEP 15 BACKUP PRINT density_report_M5_16_M5M6M7.log RDB density_report_M5_16_M5M6M7.rdb [(~~(0.05 -AREA(M5_TAR)/AREA(CHECK_REGION) ))&&(~~(0.05 -AREA(M6_TAR)/AREA(CHECK_REGION) ))&&(~~(0.05 -AREA(M7_TAR)/AREA(CHECK_REGION) ))]
}

#ENDIF

#IFDEF M8_CHECK YES
//=====================
//  M8 - Metal 8 DRC
//=====================

GROUP GM8 M8_?

M8_1 {
@ M8 minimum width is 0.07
  INT M8_all < 0.07 ABUT<90 SINGULAR REGION
}
M8_1_R_OFF {
@ M8 minimum width is 0.08um.
  INT M8 < 0.08 ABUT<90 SINGULAR REGION
}
#IFDEF TOPMETAL 9
M8_2 {
@ M8 maximum width is 4.5.
@ When M8 used for TM-1,DRC waive the (M8 AND DUPMK1) region.
  (M8_all WITH WIDTH > 4.50) NOT (M8_all AND DUPMK1)
}
#ELSE
M8_2 {
@ M8 maximum width is 4.5
  M8_all WITH WIDTH > 4.50
}
#ENDIF
M8_3 {
@ M8 minimum space is 0.07
  EXT M8_all < 0.07 ABUT<90 SINGULAR REGION
}
M8_3_R_OFF {
@ M8 minimum space is 0.08um.
  EXT M8 < 0.08 ABUT<90 SINGULAR REGION
}
M8_4 {
@ M8 minimum area is 0.0196
  AREA M8_all < 0.0196
}
/*
M8_4a {
@ Area when all of the M8 edge length < 0.17 m is >= 0.06um2. 
@ This rule is not applicable for SRAM region.
  M8_ignore = M8_all WITH EDGE (LENGTH M8_all >= 0.17)
  (AREA (M8_all NOT M8_ignore) < 0.06) NOT INST
}  
*/
M8_5 {
@ M8 minimum enclosed area is 0.2
  AREA ((HOLES M8_all INNER) NOT M8_all) < 0.2
}

M8_6 {
@ Minimum space between two run length > 0.3 parallel metal lines
@ with both metal line width is > 0.22 is 0.10
  CMACRO Mn_6 M8i_all 0.3 0.22 0.1
}
M8_6_R_OFF {
@ Minimum space between two length > 0.3 parallel metal lines
@ with both metal line width is > 0.22 is 0.12um.
  CMACRO Mn_6a M8i 0.3 0.22 0.12
}
M8_6a {
@ Minimum space between two length > 0.6 parallel metal lines
@ with one or both metal line width is > 0.7 is 0.12
  CMACRO Mn_6a M8i_all 0.6 0.7 0.12
}
M8_6b {
@ Minimum space between two length > 0.6 parallel metal lines with one metal
@ line width is > 0.22 and other metal line width is >0.7um is 0.14
  CMACRO Mn_6b M8i_all 0.6 0.22 0.7 0.14
}
M8_6c {
@ Minimum space between two length > 1.5 parallel metal lines
@ with one or both metal line width is > 1.5 is 0.30
  CMACRO Mn_6c M8i_all 1.5 1.5 0.3
}

#IFDEF TOPMETAL 9
M8_7_density {
@ M8 minimum density(%) in 125um*125um window with step size 62.5um is 10%
  DENSITY_MARK = BORDER NOT MARKS
  CHECK_LAYER = M8i_all NOT MARKS
  CHECK_REGION = COPY DENSITY_MARK
  X = DENSITY CHECK_LAYER CHECK_REGION [area(CHECK_LAYER)/area(CHECK_REGION)] < 0.10 WINDOW 125 STEP 62.5 BACKUP PRINT density_report_M8_7.log RDB density_report_M8_7.db
  X NOT MARKS
}
M8_7f_density {
@ M8 density over the whole chip is >=20%
DENSITY_MARK = BORDER NOT MARKS
CHECK_LAYER = M8i_all NOT MARKS
CHECK_REGION = COPY DENSITY_MARK
X =DENSITY CHECK_LAYER CHECK_REGION [area(CHECK_LAYER)/area(CHECK_REGION)] < 0.2 PRINT density_report_M8_7f.log RDB density_report_M8_7f.db
X NOT MARKS
}

#ENDIF

M8_7a_density {
@ M8 maximum density(%) in 125um*125um window with step size 62.5um is 85%
  DENSITY_MARK = BORDER NOT MARKS
  CHECK_LAYER = M8i_all NOT MARKS
  CHECK_REGION = COPY DENSITY_MARK
  X = DENSITY CHECK_LAYER CHECK_REGION [area(CHECK_LAYER)/area(CHECK_REGION)] > 0.85 WINDOW 125 STEP 62.5 BACKUP PRINT density_report_M8_7a.log RDB density_report_M8_7a.db 
  X NOT MARKS
}
M8_7b_density {
@ M8 maximum density difference(%) between any two 200um adjacent window (stepped without overlapping) is 50%
  X = DENSITY (M8i OR M8DUM) >= 0 WINDOW 200 GRADIENT > 0.5 ABSOLUTE BACKUP PRINT density_report_M8_7b.log RDB density_report_M8_7b.db
  X NOT MARKS
}
M8_7c_density {
@ M8 maximum density(%) with 840um*840um window is 70%
  DENSITY_MARK = BORDER NOT MARKS
  CHECK_LAYER = M8i_all NOT MARKS
  CHECK_REGION = COPY DENSITY_MARK
  X = DENSITY CHECK_LAYER CHECK_REGION [area(CHECK_LAYER)/area(CHECK_REGION)] > 0.7 WINDOW 840 BACKUP PRINT density_report_M8_7c.log RDB density_report_M8_7c.db 
  X NOT MARKS
}
M8_7d_R_density_ON {
@ [(M8 with width > 2.8um) over M7] maximum density(%) with 200um*200um step size 100um is 70%
 DENSITY_MARK = BORDER NOT MARKS
 CHECK_LAYER = (((M8i WITH WIDTH > 2.800) OR (M8DUM WITH WIDTH > 2.800)) AND (M7i OR M7DUM)) NOT MARKS
 CHECK_REGION = COPY DENSITY_MARK
 X = DENSITY CHECK_LAYER CHECK_REGION [area(CHECK_LAYER)/area(CHECK_REGION)] > 0.7 WINDOW 200 STEP 100 BACKUP PRINT density_report_M8_7d.log RDB density_report_M8_7d.db
 X NOT MARKS
}
M8_7e_R_density_ON {
@ [(M7 with width > 2.8um) over M8] maximum density(%) with 200um*200um step size 100um is 70%
  DENSITY_MARK = BORDER NOT MARKS
  CHECK_LAYER = ((M8i OR M8DUM) AND ((M7i WITH WIDTH > 2.80) OR (M7DUM WITH WIDTH > 2.80))) NOT MARKS
  CHECK_REGION = COPY DENSITY_MARK
  X = DENSITY CHECK_LAYER CHECK_REGION [area(CHECK_LAYER)/area(CHECK_REGION)] > 0.7 WINDOW 200 STEP 100 BACKUP PRINT density_report_M8_7e.log RDB density_report_M8_7e.db
  X NOT MARKS
}

M8_8 {
@ (M8 at 45degree ) minimum width (run length>0um) is 0.17
   M845 = ANGLE M8_all == 45
   INT M845 < 0.17 OPPOSITE REGION
}
M8_9 {
@ (M8 at 45degree) minimum space to parallel M8 (run length>0um) is 0.17
  M845 = ANGLE M8_all == 45
  EXT M845 < 0.17 OPPOSITE REGION
}
M8END = CONVEX EDGE M8 ANGLE1 ==90 LENGTH1 >=0.08 ANGLE2  ==90 LENGTH2  >=0.08 WITH LENGTH  <=0.11
/*
M8.10a {
@Minimum space between an Mn line end to an Mn (the parallel run length >0um) is 0.07.Excluding checking SRAM area
X= EXT M8END M8<0.07 OPPOSITE REGION
X OUT INST
}
*/
M8_11 {
@ Space between Vn-1 (Vn-1 is enclosed by Mn[A]) to neighbouring metal line Mn[B], when the layout structures meet the following conditions:
@ 1.	Mn[A] line end definition: line width W <0.1um. 
@ 2.	Vn-1 enclosure by Mn[A] line end: E < 0.05um
@ 3.	The parallel run length of Mn[A] and Mn[B]:E1 >=-0.03um
@ 4.	Space between Mn[A] to the neighbouring parallel metal line: Ds<0.08um;
@ 5.	Any one edge distance from the corner of the two edges of Mn[A]: K1 <0.095um
@ At least one Vn-1 in the Mn[A] and Mn-1 intersection meet this rule is ok.
@ This rule is not applicable for SRAM region DRC check.		0.12
LINE_END = CONVEX EDGE M8 ANGLE1 ==90 LENGTH1 >=0.08 ANGLE2  ==90 LENGTH2  >=0.08 WITH LENGTH  <0.1
 X1 =ENC V7  LINE_END<0.05 ABUT<90 REGION OPPOSITE
 X2 = V7 INTERACT X1 
 X3 = X2 INSIDE (M7 AND M8)
 X8 =X3 TOUCH EDGE X1
LINE_END_SHAPE = EXPAND EDGE LINE_END INSIDE BY 0.095
LINE_SIDE = (M8 COIN EDGE LINE_END_SHAPE ) NOT COIN EDGE LINE_END
LINE_SIDE1 = ENC X3 LINE_SIDE<0.03 REGION ABUT<90 OPPOSITE
V7_EDGE =(LINE_SIDE1 OR X3) TOUCH EDGE X8
LINE_END_EXP = EXPAND EDGE V7_EDGE INSIDE BY 0.001 EXTEND BY 0.031
LINE_SIDE_EXP = EXPAND EDGE LINE_SIDE INSIDE BY 0.001 
LINE_END_1 = LINE_END_EXP TOUCH EDGE V7_EDGE 
LINE_SIDE_1 = LINE_SIDE_EXP  TOUCH EDGE  LINE_SIDE
E1 = EXT [LINE_END_1] M8 < 0.12 OPPOSITE PERP ALSO OBTUSE ALSO 
E2 = EXT [LINE_SIDE_1] M8< 0.08  OPPOSITE PERP ALSO OBTUSE ALSO
LINE_END_E1 = LINE_END_1 TOUCH EDGE E1
LINE_SIDE_E2 = LINE_SIDE_1 TOUCH EDGE E2
V42 =X3 WITH EDGE (X8 TOUCH EDGE LINE_END_E1)   
X5 = V7 INTERACT V42
X6 = V7 NOT X5
X7 = ((M7 AND M8) ENCLOSE X5) ENCLOSE X6
M2_CORNER1 = INT LINE_END_E1 LINE_SIDE_E2 <= 0.002 ABUT==90 REGION
(M2_CORNER1 NOT INTERACT X7) OUTSIDE INST

}


M8_12_R_OFF {
@ Minimum Mn to Mn space S at Mn line-end 0.1. Width W < 0.1um . The minimum space can be line end head to other Mn or line end side to other M1.  Rule check:
@ S >= (Dh or Ds ).  E1 =0.03, K1=0.095 , Dh=Ds=0.1 in the illustration. 
@ Outside of SRAM(INST) area.
@ Waive extrusion F < 0.07.
@ Waive the violation for MOM (within MOMDMY).
LINE_END = CONVEX EDGE M8_all ANGLE1 ==90 LENGTH1 >=0.07 ANGLE2  ==90 LENGTH2  >=0.07 WITH LENGTH  < 0.1
LINE_END_SHAPE = EXPAND EDGE LINE_END INSIDE BY 0.064
LINE_SIDE = (M8_all COIN EDGE LINE_END_SHAPE ) NOT COIN EDGE LINE_END
LINE_END_EXP = EXPAND EDGE LINE_END INSIDE BY 0.001 EXTEND BY 0.031
LINE_SIDE_EXP = EXPAND EDGE LINE_SIDE INSIDE BY 0.001 EXTEND BY 0.031
LINE_END_1 = LINE_END_EXP TOUCH EDGE LINE_END
LINE_SIDE_1 = LINE_SIDE_EXP TOUCH EDGE LINE_SIDE
E1 = EXT [LINE_END_1] M8_all < 0.1 OPPOSITE PERP ALSO OBTUSE ALSO
E2 = EXT [LINE_SIDE_1] M8_all < 0.1  OPPOSITE PERP ALSO OBTUSE ALSO
LINE_END_E1 = LINE_END_1 TOUCH EDGE E1
LINE_SIDE_E2 = LINE_SIDE_1 TOUCH EDGE E2
M8_CORNER = INT LINE_END_E1 LINE_SIDE_E2 <= 0.002 ABUT==90 REGION
MOM =(M7 OR M8) INTERACT ( MnPIN INTERACT (SIZE MOMDMY BY 0.114))
((LINE_END_SHAPE INTERACT M8_CORNER) OUTSIDE INST ) NOT (MOM OR MOMDMY)
}
M8_13_M6M7M8_density_R_OFF {
    @ It is not allowed to havel local density > 85% of all 3 consecutive metal (1xMn, 1xMn+1 and 1xMn+2) over any window size 62.5*62.5um (stepping size 31.25um).
    @ The metal layers include M1/1xMn and dummy metals.
    @ DRC doesn't check: DUMBM, MARKS and (TM2 and PA) region
    DENSITY_MARK = BORDER NOT (OR DUMBM MARKS (TM2i AND PA))
	M6_TAR = M6i_all NOT (OR DUMBM MARKS (TM2i AND PA))
	M7_TAR = M7i_all NOT (OR DUMBM MARKS (TM2i AND PA))
	M8_TAR = M8i_all NOT (OR DUMBM MARKS (TM2i AND PA))
    CHECK_REGION = COPY DENSITY_MARK
    DENSITY M6_TAR M7_TAR M8_TAR CHECK_REGION > 0 WINDOW 62.5 STEP 31.25 BACKUP PRINT density_report_M6_13_M6M7M8.log RDB density_report_M6_13_M6M7M8.rdb [(~~(AREA(M6_TAR)/AREA(CHECK_REGION) -0.85))&&(~~(AREA(M7_TAR)/AREA(CHECK_REGION) -0.85))&&(~~(AREA(M8_TAR)/AREA(CHECK_REGION) -0.85))]   
}
M8_14_density {
@ M8 density (including dummy) is >= 1%.Density check window size: 80um*80um, step size 40um.
@ DRC only check the region with width of (checking window NOT above excluding region) >= 40um.
  DENSITY_MARK = WITH WIDTH (BORDER NOT MARKS) >= 40
  CHECK_LAYER = M8i_all AND DENSITY_MARK
  CHECK_REGION = COPY DENSITY_MARK
  X = DENSITY CHECK_LAYER CHECK_REGION [area(CHECK_LAYER)/area(CHECK_REGION)] < 0.01 WINDOW 80 STEP 40 BACKUP PRINT density_report_M8_14.log RDB density_report_M8_14.db
  (X NOT MARKS) WITH WIDTH >= 40
}
M8_15 {
    @ Maximum M8 area of merged low density windows must follow item (1) and (2).
    @ The definition of low density window: window size 10um*10um, step size: 5um, density <1%
    @ (1) Maximum area of merged low density window <= 6500um2, except merged low density windows width <= 30um.
    @ (2) Maximum area of merged low density window <= 18500um2.
    @ DRC only check the region with width of (checking window NOT above excluding region) >= 5um
    X = DENSITY M8i_all < 0.01 WINDOW 10 STEP 5 BACKUP PRINT density_report_M8_15.log RDB density_report_M8_15.rdb
    Y = X NOT MARKS
    (AREA Y > 6500) WITH WIDTH > 30
    (AREA Y > 16000) WITH WIDTH >= 5
}
M8_16_M6M7M8_density {
    @ It is not allowed to havel local density < 5% of all 3 consecutive metal (Mn, Mn+1 and Mn+2) over any window 30*30um (stepping 15um).
    @ The metal layers include M1/1xMn and dummy metals.
    @ DRC only check the region with width of (checking window NOT above excluding region) >= 15um
	DENSITY_MARK = WITH WIDTH (BORDER NOT MARKS) >= 15
	M6_TAR = M6i_all AND DENSITY_MARK
	M7_TAR = M7i_all AND DENSITY_MARK
	M8_TAR = M8i_all AND DENSITY_MARK
    CHECK_REGION = COPY DENSITY_MARK
    DENSITY M6_TAR M7_TAR M8_TAR CHECK_REGION > 0 WINDOW 30 STEP 15 BACKUP PRINT density_report_M6_16_M6M7M8.log RDB density_report_M6_16_M6M7M8.rdb [(~~(0.05 -AREA(M6_TAR)/AREA(CHECK_REGION) ))&&(~~(0.05 -AREA(M7_TAR)/AREA(CHECK_REGION) ))&&(~~(0.05 -AREA(M8_TAR)/AREA(CHECK_REGION) ))]
}

#ENDIF

//========================
//  V2 - Via 2 DRC
//========================

GROUP GV2 V2_?

V2_1 {
@ Fixed V2 size is 0.07
  NOT RECTANGLE V2 == 0.07 BY == 0.07
}
V2_2 {
@ Space between two V2 is 0.07
  EXT V2_all < 0.07 ABUT<90 SINGULAR REGION
}
V2_array = SIZE (SIZE V2 BY 0.05 OVERUNDER) BY 0.150 UNDEROVER
V2_GAP2 = V2_array NOT M2
V2_GAP3 = V2_array NOT M3
V2_3 {
@Space between Vns (with run length>=0um) at least two least two sides is 0.09, when array equal to or greater than 3x3. 
@Two Via areas whose space is within 0.10um are considered to be in the same array. An array does
@ not have both row and column greater than or equal to 3 can apply smaller spacing Vn.2 instead of Vn.3
    X = EXT (V2 INTERACT V2_array) V2< 0.090 OPPOSITE EXTENDED  0.001  REGION 
   Y =SIZE V2 BY 0.001
  (Y INTERACT  V2_array)  INTERACT (X NOT Y) >2 
}
/*
V2_4 {
@ V2_array not touching MOMDMY maximum width is 0.85
  (WITH WIDTH V2_array > 0.85) NOT INTERACT MOMDMY
}
*/
V2_5 {
@ V2 (different net) minimum space for run length > 0um is 0.1 (outside of SRAM)
 X = EXT V2 < 0.1 NOT CONNECTED OPPOSITE REGION
 X OUTSIDE INST
 (EXT V2DUM < 0.1 ABUT<90 SINGULAR OPPOSITE REGION) OUTSIDE INST
 (EXT V2DUM V2 < 0.1 ABUT<90 SINGULAR OPPOSITE REGION) OUTSIDE INST
}
V2_5_R_OFF {
@ V2 (different net) minimum space for run length > 0um is 0.11um. (outside of SRAM)
 X = EXT V2 < 0.11 NOT CONNECTED OPPOSITE REGION
 X OUTSIDE INST
}
V2_5a {
@ V2 (different net) minimum space is 0.09
 EXT V2 < 0.09 NOT CONNECTED REGION
 EXT V2DUM < 0.09 ABUT<90 SINGULAR REGION
 EXT V2DUM V2 < 0.09 ABUT<90 SINGULAR REGION
}
/*
V2.5b {
@ Vn minimum space in different net inside of SRAM is 0.09
  EXT (V2 NOT OUTSIDE INST) < 0.09 NOT CONNECTED REGION
}
*/
V2_6abc {
@ V2 must within M2
@  per Mn and Mn+1 intersection containing a Vn, must meet rule Vn.6a, Vn.6b or Vn.6c
@ V2.6a, V2 minimum within M2 is 0.015
@ Vn.6b	Mn overlap past Vn for two opposite sides with either side  >=0.01um, and < 0.015um  0.02
@ Vn.6c	Mn overlap past Vn for two opposite sides with either side >= 0um, and < 0.01um 0.03
  V2_all NOT M2_all
  M2andM3 = (M2_all AND M3_all) INTERACT (V2_all OUTSIDE INST)
  BadV2 = RECTANGLE ENCLOSURE (V2_all OUTSIDE INST) M2_all  OUTSIDE ALSO
  GOOD 0.015 OPPOSITE 0.015 OPPOSITE 0.015 OPPOSITE 0.015 OPPOSITE
  GOOD 0.02 OPPOSITE 0.01 OPPOSITE 0.02 OPPOSITE 0.01 OPPOSITE
  GOOD 0.03 0.0 0.03 0.0 
  BadV2 INTERACT M2andM3
}
SRV2_6 {
@ Vn minimum within Mn is 0.0
 (V2 NOT OUTSIDE INST) NOT INSIDE M2 
}
/*V2_6d {
@ V2 inside M2 with width > 0.14um, with at least one redundant V2.
@ This rule only applies to that M2/M3 intersection area can enclose a rectangle of 0.07*0.27.
 CMACRO V67D V2 M2 M3
}*/
V2_7abc {
@ V2 must within M3
@  per Mn and Mn+1 intersection containing a Vn, must meet rule Vn.7a, Vn.7b or Vn.7c
@ V2.7a, V2 minimum within M3 is 0.015
@ V2.7b, M3 minimum overlap past V2 for two opposite sides with either side >=0.01um, and < 0.015m  is 0.02
@ V2.7c, M3 minimum overlap past V2 for two opposite sides with the either side >=0um, and < 0.01m is 0.03
  V2_all NOT M3_all
  M2andM3 = (M2_all AND M3_all) INTERACT V2_all
  BadV2 = RECTANGLE ENCLOSURE V2_all M3_all OUTSIDE ALSO
  GOOD 0.015 OPPOSITE 0.015  OPPOSITE 0.015 OPPOSITE 0.015 OPPOSITE
  GOOD 0.02 OPPOSITE 0.01 OPPOSITE 0.02 OPPOSITE 0.01 OPPOSITE
  GOOD 0.03 0.0  0.03 0.0 
  BadV2 INTERACT M2andM3
}
/*V2_7d {
@ V2 inside M3 with width > 0.14um, with at least one redundant V2.
@ This rule only applies to that M2/M3 intersection area can enclose a rectangle of 0.07*0.27.
 CMACRO V67D V2 M3 M2
}*/
V2_8 {
@ At least two Vn vias must connect Mn to Mn+1 when the Mn or Mn+1 width is > 0.26um
  WM2 = WITH WIDTH M2 > 0.260
  WM3 = WITH WIDTH M3 > 0.260
  encVia = V2 INTERACT (WM2 OR WM3)
  ((M2 AND M3) ENCLOSE encVia) ENCLOSE V2 < 2
}
V2_9 {
@ At least three Vn vias must connect Mn to Mn+1 when the Mn or Mn+1 width is > 0.55um
  WM2 = WITH WIDTH M2 > 0.550
  WM3 = WITH WIDTH M3 > 0.550
  encVia = V2 INTERACT (WM2 OR WM3)
  ((M2 AND M3) ENCLOSE encVia) ENCLOSE V2 < 3
}
V2_10 {
@ At least four Vn vias must connect Mn to Mn+1 when the Mn or Mn+1 width is > 0.645um
  WM2 = WITH WIDTH M2 > 0.645
  WM3 = WITH WIDTH M3 > 0.645
  encVia = V2 INTERACT (WM2 OR WM3)
  ((M2 AND M3) ENCLOSE encVia) ENCLOSE V2 < 4
}
V2_square = RECTANGLE V2 ASPECT ==1
V2_EMPTY = EMPTY OR (V2_square INSIDE (M2 AND M3) )  
INTER_EMPTY2 =EMPTY OR (M2 AND M3) 
CONNECT  V2_EMPTY INTER_EMPTY2

V2_16 {
@At least two Vns with space <=0.16m when one of Mn or Mn+1 with both length and width >0.24um.
@Exclude non-square Vn and SRAM area.
X1a = WITH WIDTH M2  >0.24
X1b = WITH WIDTH M3  >0.24
WIDE = X1a OR X1b
X2 = (M3 AND M2) ENCLOSE V2_square
X3 =  V2_square INSIDE X2
X5c = EXT (V2_EMPTY INSIDE WIDE ) V2_EMPTY <=0.16 ABUT<90 REGION CONNECTED // space of via <= 0.16 
X6c = X2 ENCLOSE X5c  // good intersection with space of Via <= 0.16
X7= ((SIZE X3 BY 0.325) AND X2) ENCLOSE V2 >2
X7c=X2 ENCLOSE X7
X =((X2 NOT X6c) NOT X7c) ENCLOSE ( V2_square INSIDE WIDE ) // Via_16
X OUTSIDE INST
//COPY X5c
}
//WM2 = M2 WITH WIDTH > 0.24
V2_A = V2_square INTERACT WM2_EXP 

CONNECT V2 M2
CONNECT V2 M3
CONNECT V2_A M2
CONNECT WM2 M2
//M3_fake = area M3 >0
WM3 = M3 WITH WIDTH > 0.24
WM3_EDGE = LENGTH WM3 > 0
WM3_EXP = EXPAND EDGE WM3_EDGE OUTSIDE BY 1.1
WM3_L1 = ( M3 NOT WM3 ) TOUCH WM3
V2_A2 = V2_square INTERACT WM3_EXP
V2_A2_EMPTY = EMPTY OR V2_A2
M3_EMPTY = EMPTY OR M3
 WM3_EMPTY = EMPTY OR WM3 
CONNECT V2_A2_EMPTY M3_EMPTY
CONNECT WM3_EMPTY M3_EMPTY
V2_17 {
@ At least two Vns  when either wide metal of Mn or Mn+1 with both length L>0.24um and width W>0.24um, and the distance D<=1.1um away from this wide metal.
@ Exclude non-square Vn
WM2_L1 = ( M2 NOT WM2 ) TOUCH WM2
M2_ENCWM = (M2 INTERACT WM2) INTERACT V2_A
WM2_VEDGE = EXT [M2_ENCWM]  <1.1 ABUT<90 OPPOSITE NOTCH
WM2_EXT1 = EXT (WM2 COIN EDGE WM2_VEDGE) [V2_A] < 1.1 ABUT>=0 <90  OPPOSITE CONNECTED 
WM2_EXT2 = (EXT WM2 V2_A < 1.1 ABUT>=0 <90  OPPOSITE REGION CONNECTED ) INSIDE M2  
V2_B = V2_square WITH EDGE WM2_EXT1
X1 =(M2 AND M3) ENCLOSE V2_square >1
X2 = ((M2 AND M3)  AND ( WM2_L1 AND WM2_EXP )) NOT X1

Y0=(M2 AND M3) ENCLOSE V2_square ==1 
Y1 = SIZE (V2_square INTERACT Y0) BY 1.1 INSIDE OF M2 STEP 0.005  
Y2= Y1 INTERACT (Y1 AND WM2)

VSING1= ((X2 INTERACT V2_B ==1) INTERACT Y2) OR ((X2 INTERACT WM2_EXT2) INTERACT V2_A)
VSING1 OUTSIDE INST 

M3_ENCWM = (M3 INTERACT WM3) INTERACT V2_A2
WM3_VEDGE = EXT [M3_ENCWM]  <1.1 ABUT<90 OPPOSITE NOTCH
WM3_EXT1 = EXT (WM3_EMPTY COIN EDGE WM3_VEDGE) [V2_A2_EMPTY] < 1.1 ABUT>=0 <90  OPPOSITE CONNECTED 
WM3_EXT2 = (EXT WM3_EMPTY V2_A2_EMPTY < 1.1 ABUT>=0 <90  OPPOSITE REGION CONNECTED ) INSIDE M3  
V2_B2 = V2_square WITH EDGE WM3_EXT1
X3 = ((M2 AND M3)  AND ( WM3_L1 AND WM3_EXP )) NOT X1  
Y3 = SIZE (V2_square INTERACT Y0) BY 1.1 INSIDE OF M3 STEP 0.005  
Y4 = Y3 INTERACT (Y3 AND WM3)

VSING2= ((X3 INTERACT V2_B2 ==1) INTERACT Y4) OR (( X3 INTERACT WM3_EXT2) INTERACT V2_A2)
VSING2 OUTSIDE INST

}

V2_A_a = V2_square INTERACT WM2_EXP_a 

CONNECT V2_A_a M2
CONNECT WM2_a M2
//M3_fake = area M3 >0
WM3_a = M3 WITH WIDTH > 1.4
WM3_EDGE_a = LENGTH WM3_a > 0
WM3_EXP_a = EXPAND EDGE WM3_EDGE_a OUTSIDE BY 2.8
WM3_L1_a = ( M3 NOT WM3_a ) TOUCH WM3_a
V2_A2_a = V2_square INTERACT WM3_EXP_a
V2_A2_EMPTY_a = EMPTY OR V2_A2_a
 WM3_EMPTY_a = EMPTY OR WM3_a 
CONNECT V2_A2_EMPTY_a M3_EMPTY
CONNECT WM3_EMPTY_a M3_EMPTY
V2_17a {
@ At least two Vns  when either wide metal of Mn or Mn+1 with both length L>1.4um and width W>1.4um, and the distance D<=2.8um away from this wide metal.
@ Exclude non-square Vn
WM2_L1_a = ( M2 NOT WM2_a ) TOUCH WM2_a
//M2_ENCWM = (M2 INTERACT WM2_a) INTERACT V2_A_a
//WM2_VEDGE = EXT [M2_ENCWM]  <2.8 ABUT<90 OPPOSITE NOTCH
//WM2_EXT1 = EXT (WM2_a COIN EDGE WM2_VEDGE) [V2_A_a] < 2.8 ABUT>=0 <90  OPPOSITE CONNECTED 
//WM2_EXT2 = (EXT WM2_a V2_A_a < 2.8 ABUT>=0 <90  OPPOSITE REGION CONNECTED ) INSIDE M2  
V2_B = COPY V2_square
X1 =(M2 AND M3) ENCLOSE V2_square >1
X2 = ((M2 AND M3)  AND ( WM2_L1_a AND WM2_EXP_a )) NOT X1

Y0=(M2 AND M3) ENCLOSE V2_square ==1 
Y1 = SIZE (V2_square INTERACT Y0) BY 2.8 INSIDE OF M2 STEP 0.005  
Y2= Y1 INTERACT (Y1 AND WM2_a)

VSING1= (X2 INTERACT V2_B ==1) INTERACT Y2
VSING1 OUTSIDE INST 

//M3_ENCWM = (M3 INTERACT WM3_a) INTERACT V2_A2_a
//WM3_VEDGE = EXT [M3_ENCWM]  <2.8 ABUT<90 OPPOSITE NOTCH
//WM3_EXT1 = EXT (WM3_EMPTY_a COIN EDGE WM3_VEDGE) [V2_A2_EMPTY_a] < 2.8 ABUT>=0 <90  OPPOSITE CONNECTED 
//WM3_EXT2 = (EXT WM3_EMPTY_a V2_A2_EMPTY_a < 2.8 ABUT>=0 <90  OPPOSITE REGION CONNECTED ) INSIDE M3  
V2_B2 = COPY V2_square
X3 = ((M2 AND M3)  AND ( WM3_L1_a AND WM3_EXP_a )) NOT X1  
Y3 = SIZE (V2_square INTERACT Y0) BY 2.8 INSIDE OF M3 STEP 0.005  
Y4 = Y3 INTERACT (Y3 AND WM3_a)

VSING2= (X3 INTERACT V2_B2 ==1) INTERACT Y4
VSING2 OUTSIDE INST

}

V2_A_b = V2_square INTERACT WM2_EXP_b 

CONNECT V2_A_b M2
CONNECT WM2_b M2
//M3_fake = area M3 >0
WM3_b = (M3 WITH WIDTH > 2.1) WITH EDGE (LENGTH (M3 WITH WIDTH > 2.1) > 7)
WM3_EDGE_b = LENGTH WM3_b > 0
WM3_EXP_b = EXPAND EDGE WM3_EDGE_b OUTSIDE BY 7.1
WM3_L1_b = ( M3 NOT WM3_b ) TOUCH WM3_b
V2_A2_b = V2_square INTERACT WM3_EXP_b
V2_A2_EMPTY_b = EMPTY OR V2_A2_b
 WM3_EMPTY_b = EMPTY OR WM3_b 
CONNECT V2_A2_EMPTY_b M3_EMPTY
CONNECT WM3_EMPTY_b M3_EMPTY
V2_17b {
@ At least two Vns  when either wide metal of Mn or Mn+1 with both length L>7um and width W>2.1um, and the distance D<=7.1um away from this wide metal.
@ Exclude non-square Vn
WM2_L1_b = ( M2 NOT WM2_b ) TOUCH WM2_b
//M2_ENCWM = (M2 INTERACT WM2_b) INTERACT V2_A_b
//WM2_VEDGE = EXT [M2_ENCWM]  <7.1 ABUT<90 OPPOSITE NOTCH
//WM2_EXT1 = EXT (WM2_b COIN EDGE WM2_VEDGE) [V2_A_b] < 7.1 ABUT>=0 <90  OPPOSITE CONNECTED 
//WM2_EXT2 = (EXT WM2_b V2_A_b < 7.1 ABUT>=0 <90  OPPOSITE REGION CONNECTED ) INSIDE M2  
V2_B = COPY V2_square 
X1 =(M2 AND M3) ENCLOSE V2_square >1
X2 = ((M2 AND M3)  AND ( WM2_L1_b AND WM2_EXP_b )) NOT X1

Y0=(M2 AND M3) ENCLOSE V2_square ==1 
Y1 = SIZE (V2_square INTERACT Y0) BY 7.1 INSIDE OF M2 STEP 0.005  
Y2= Y1 INTERACT (Y1 AND WM2_b)

VSING1= (X2 INTERACT V2_B ==1) INTERACT Y2
VSING1 OUTSIDE INST 

//M3_ENCWM = (M3 INTERACT WM3_b) INTERACT V2_A2_b
//WM3_VEDGE = EXT [M3_ENCWM]  <7.1 ABUT<90 OPPOSITE NOTCH
//WM3_EXT1 = EXT (WM3_EMPTY_b COIN EDGE WM3_VEDGE) [V2_A2_EMPTY_b] < 7.1 ABUT>=0 <90  OPPOSITE CONNECTED 
//WM3_EXT2 = (EXT WM3_EMPTY_b V2_A2_EMPTY_b < 7.1 ABUT>=0 <90  OPPOSITE REGION CONNECTED ) INSIDE M3  
V2_B2 = COPY V2_square
X3 = ((M2 AND M3)  AND ( WM3_L1_b AND WM3_EXP_b )) NOT X1  
Y3 = SIZE (V2_square INTERACT Y0) BY 7.1 INSIDE OF M3 STEP 0.005  
Y4 = Y3 INTERACT (Y3 AND WM3_b)

VSING2= (X3 INTERACT V2_B2 ==1) INTERACT Y4
VSING2 OUTSIDE INST
}

V2_18 {
@ 45-degree rotated V2 is not allowed.
  (ANGLE V2_all >= 44.9 <= 45.1) NOT INSIDE EDGE MARKS
}
V2_19 {
@ Single V2 is not allowed in "H-shape" M3 when:
@ 1. The M3 has "H-shape" interact with two metal holes: both two metal holes length <= 4.5um(L2) and two metal hole area <= 4.5um2.
@ 2. The V2 overlaps on the center metal bar of this "H-shape" M3.
@ 3. The center metal bar length <= 1um(L) and the metal bar width <= 0.2um.
    M3_hole = RECTANGLE (AREA (HOLES M3 INNER) <= 4.5)    
    X = M3 COIN EDGE M3_hole
    Y = INT X <= 0.2 OPPOSITE REGION
    M3_bar_edge = LENGTH (M3_hole TOUCH EDGE Y) <= 1
    M3_hole_tar = M3_hole NOT WITH EDGE (LENGTH (M3_hole WITH EDGE M3_bar_edge) > 4.5)
    Z = Y INTERACT M3_hole_tar == 2
    H = V2 NOT OUTSIDE Z
//    (Z INTERACT H == 1) NOT MARKS
    ERR = ((M2 AND M3) INTERACT H) NOT INTERACT (V2 NOT H) 
    ((Z INTERACT H == 1) INTERACT ERR) NOT MARKS    
}
V2_20 {
@ V2 connected to M2DUM, M3DUM is not allowed.
@ This rule is not applied for LOGO covered region.
  (V2 INTERACT (M2DUM OR M3DUM)) NOT LOGO
}
V2_21 {
@ V2 must be fully covered by M2 and M3.
  V2_all NOT (M2_all AND M3_all)
}
V2_22_R_OFF {
@ Insert one V2 if single V2 and (W2 >= 5W3, or W3 >= 5W2) at enclosure.
 CMACRO DFM4 M2 M3 V2
}
V2_23_R_OFF {
@ At least two vias (Vn, TV1, TV2, n=1~7) in Mn and Mn+1 (M1, Mn, n=2~8, TM1, TM2) intersection area. 
@ (This rule is not applicable for SRAM region, 
@ but SRAM region should follow main rule: V1.17, Vn.17, TV1.13, TV2.13, TV2.14)
  V2_INTER= V2 INSIDE (M2 AND M3) 
  X = (M2 AND M3) INTERACT V2_INTER  <2
  X OUTSIDE INST
}
V2_24 {
@ It?s not allowed V2 overlap with M2 and M3 resistor.
  V2 AND (M2 AND M2R)
  V2 AND (M3 AND M3R)
}

#IFDEF V3_CHECK YES
//========================
//  V3 - Via 3 DRC
//========================

GROUP GV3 V3_?

V3_1 {
@ Fixed V3 size is 0.07
  NOT RECTANGLE V3 == 0.07 BY == 0.07
}
V3_2 {
@ Space between two V3 is 0.07
  EXT V3_all < 0.07 ABUT<90 SINGULAR REGION
}
V3_array = SIZE (SIZE V3 BY 0.05 OVERUNDER) BY 0.150 UNDEROVER
V3_GAP3 = V3_array NOT M3
V3_GAP4 = V3_array NOT M4
V3_3 {
@Space between Vns (with run length>=0) at least two least two sides is 0.09, when array equal to or greater than 3x3. 
@Two Via areas whose space is within 0.10um are considered to be in the same array. An array does
@ not have both row and column greater than or equal to 3 can apply smaller spacing Vn.2 instead of Vn.3
  X = EXT (V3 INTERACT V3_array) V3< 0.090 OPPOSITE EXTENDED  0.001  REGION 
   Y =SIZE V3 BY 0.001
  (Y INTERACT  V3_array)  INTERACT (X NOT Y) >2
}
/*
V3_4 {
@ V3_array not touching MOMDMY maximum width is 0.85
  (WITH WIDTH V3_array > 0.85) NOT INTERACT MOMDMY
}
*/
#IFDEF TOPMETAL 9
V3_5 {
@ V3 (different net) minimum space for run length > 0um is 0.1(outside of SRAM)
  X = EXT V3 < 0.1 NOT CONNECTED OPPOSITE REGION
  X OUTSIDE INST 
  (EXT V3DUM < 0.1 ABUT<90 SINGULAR OPPOSITE REGION) OUTSIDE INST
  (EXT V3DUM V3 < 0.1 ABUT<90 SINGULAR OPPOSITE REGION) OUTSIDE INST
}
V3_5_R_OFF {
@ Vn space in different net for run length>0um (outside of SRAM) is >= 0.11um.
  X = EXT V3 < 0.11 NOT CONNECTED OPPOSITE REGION
  X OUTSIDE INST 
}
V3_5a {
@ V3 (different net) minimum space is 0.09
  EXT V3 < 0.09 NOT CONNECTED REGION
  EXT V3DUM < 0.09 ABUT<90 SINGULAR REGION
  EXT V3DUM V3 < 0.09 ABUT<90 SINGULAR REGION
}
/*V3_5b {
@ Vn minimum space in different net inside of SRAM is 0.09
  EXT (V3 NOT OUTSIDE INST) < 0.09 NOT CONNECTED REGION
}*/
#ENDIF
#IFDEF TOPMETAL 8
V3_5 {
@ V3 (different net) minimum space for run length > 0um is 0.1(outside of SRAM)
  X = EXT V3 < 0.1 NOT CONNECTED OPPOSITE REGION
  X OUTSIDE INST
  (EXT V3DUM < 0.1 ABUT<90 SINGULAR OPPOSITE REGION) OUTSIDE INST
  (EXT V3DUM V3 < 0.1 ABUT<90 SINGULAR OPPOSITE REGION) OUTSIDE INST
}
V3_5_R_OFF {
@ Vn space in different net for run length>0um (outside of SRAM) is >= 0.11um.
  X = EXT V3 < 0.11 NOT CONNECTED OPPOSITE REGION
  X OUTSIDE INST 
}
V3_5a {
@ V3 (different net) minimum space is 0.09
  EXT V3 < 0.09 NOT CONNECTED REGION 
  EXT V3DUM < 0.09 ABUT<90 SINGULAR REGION
  EXT V3DUM V3 < 0.09 ABUT<90 SINGULAR REGION
}
/*V3_5b {
@ Vn minimum space in different net inside of SRAM is 0.09
 X = EXT (V3 AND INST) < 0.09 NOT CONNECTED REGION
 X NOT OUTSIDE INST
}*/
#ENDIF
#IFDEF TOPMETAL 7
V3_5 {
@ V3 (different net) minimum space for run length > 0um is 0.1(outside of SRAM)
 X = EXT V3 < 0.1 NOT CONNECTED OPPOSITE REGION
 X OUTSIDE INST
 (EXT V3DUM < 0.1 ABUT<90 SINGULAR OPPOSITE REGION) OUTSIDE INST
 (EXT V3DUM V3 < 0.1 ABUT<90 SINGULAR OPPOSITE REGION) OUTSIDE INST
}
V3_5_R_OFF {
@ Vn space in different net for run length>0um (outside of SRAM) is >= 0.11um.
  X = EXT V3 < 0.11 NOT CONNECTED OPPOSITE REGION
  X OUTSIDE INST 
}
V3_5a {
@ V3 (different net) minimum space is 0.09
  EXT V3 < 0.09 NOT CONNECTED REGION
  EXT V3DUM < 0.09 ABUT<90 SINGULAR REGION
  EXT V3DUM V3 < 0.09 ABUT<90 SINGULAR REGION
}
/*V3_5b {
@ Vn minimum space in different net inside of SRAM is 0.09
  EXT (V3 NOT OUTSIDE INST) < 0.09 NOT CONNECTED REGION
}*/
#ENDIF
#IFDEF TOPMETAL 6
V3_5 {
@ V3 (different net) minimum space for run length > 0um is 0.1(outside of SRAM)
 X = EXT V3 < 0.1 NOT CONNECTED OPPOSITE REGION
 X OUTSIDE INST
 (EXT V3DUM < 0.1 ABUT<90 SINGULAR OPPOSITE REGION) OUTSIDE INST
 (EXT V3DUM V3 < 0.1 ABUT<90 SINGULAR OPPOSITE REGION) OUTSIDE INST
}
V3_5_R_OFF {
@ Vn space in different net for run length>0um (outside of SRAM) is >= 0.11um.
  X = EXT V3 < 0.11 NOT CONNECTED OPPOSITE REGION
  X OUTSIDE INST 
}
V3_5a {
@ V3 (different net) minimum space is 0.09
  EXT V3 < 0.09 NOT CONNECTED REGION
  EXT V3DUM < 0.09 ABUT<90 SINGULAR REGION
  EXT V3DUM V3 < 0.09 ABUT<90 SINGULAR REGION
}
/*V3_5b {
@ Vn minimum space in different net inside of SRAM is 0.09
  EXT (V3 NOT OUTSIDE INST) < 0.09 NOT CONNECTED REGION
}*/
#ENDIF
#IFDEF TOPMETAL 5
V3_5 {
@ V3 (different net) minimum space for run length > 0um is 0.1(outside of SRAM)
 X = EXT V3 < 0.1 NOT CONNECTED OPPOSITE REGION
 X OUTSIDE INST
 (EXT V3DUM < 0.1 ABUT<90 SINGULAR OPPOSITE REGION) OUTSIDE INST
 (EXT V3DUM V3 < 0.1 ABUT<90 SINGULAR OPPOSITE REGION) OUTSIDE INST
}
V3_5_R_OFF {
@ Vn space in different net for run length>0um (outside of SRAM) is >= 0.11um.
  X = EXT V3 < 0.11 NOT CONNECTED OPPOSITE REGION
  X OUTSIDE INST 
}
V3_5a {
@ V3 (different net) minimum space is 0.09
  EXT V3 < 0.09 NOT CONNECTED REGION
  EXT V3DUM < 0.09 ABUT<90 SINGULAR REGION
  EXT V3DUM V3 < 0.09 ABUT<90 SINGULAR REGION
}
/*V3_5b {
@ Vn minimum space in different net inside of SRAM is 0.09
  EXT (V3 NOT OUTSIDE INST) < 0.09 NOT CONNECTED REGION
}*/
#ENDIF
V3_6abc {
@ V2 must within M2
@  per Mn and Mn+1 intersection containing a Vn, must meet rule Vn.6a, Vn.6b or Vn.6c
@ V2.6a, V2 minimum within M2 is 0.015
@ Vn.6b	Mn overlap past Vn for two opposite sides with either side  >=0.01um, and < 0.015m  0.02
@ Vn.6c	Mn overlap past Vn for two opposite sides with either side >= 0um, and < 0.01m 0.03
  V3_all NOT M3_all
  M3andM4 = (M3_all AND M4_all) INTERACT V3_all
  BadV3 = RECTANGLE ENCLOSURE V3_all M3_all OUTSIDE ALSO
  GOOD 0.015 OPPOSITE 0.015 OPPOSITE  0.015 OPPOSITE 0.015 OPPOSITE
  GOOD 0.02 OPPOSITE 0.01 OPPOSITE  0.02 OPPOSITE 0.01 OPPOSITE
  GOOD 0.03 0.0  0.03 0.0 
  BadV3 INTERACT M3andM4
}
/*V3_6d {
@ Vn inside Mn with width > 0.14um, with at least one redundant Vn.
@ This rule only applies to that M3/M4 intersection area can enclose a rectangle of 0.07*0.27.
 CMACRO V67D V3 M3 M4
}*/
V3_7abc {
@ V2 must within M3
@  per Mn and Mn+1 intersection containing a Vn, must meet rule Vn.7a, Vn.7b or Vn.7c
@ V2.7a, V2 minimum within M3 is 0.015
@ V2.7b, M3 minimum overlap past V2 for two opposite sides with either side >=0.01um, and < 0.015m  is 0.02
@ V2.7c, M3 minimum overlap past V2 for two opposite sides with the either side >=0um, and < 0.01m is 0.03
  V3_all NOT M4_all
  M3andM4 = (M3_all AND M4_all) INTERACT V3_all
  BadV3 = RECTANGLE ENCLOSURE V3_all M4_all  OUTSIDE ALSO
  GOOD 0.015 OPPOSITE 0.015 OPPOSITE  0.015 OPPOSITE  0.015 OPPOSITE
  GOOD 0.02 OPPOSITE 0.01 OPPOSITE 0.02 OPPOSITE 0.01 OPPOSITE
  GOOD 0.03 0.0  0.03 0.0 
  BadV3 INTERACT M3andM4
}
/*V3_7d {
@ Vn inside Mn+1 with width > 0.14um, with at least one redundant Vn.
@ This rule only applies to that M3/M4 intersection area can enclose a rectangle of 0.07*0.27.
 CMACRO V67D V3 M4 M3
}*/
V3_8 {
@ At least two Vn vias must connect Mn to Mn+1 when the Mn or Mn+1 width is > 0.26um
  WM3 = WITH WIDTH M3 > 0.260
  WM4 = WITH WIDTH M4 > 0.260
  encVia = V3 INTERACT (WM3 OR WM4)
  ((M3 AND M4) ENCLOSE encVia) ENCLOSE V3 < 2
}
V3_9 {
@ At least three Vn vias must connect Mn to Mn+1 when the Mn or Mn+1 width is > 0.55um
  WM3 = WITH WIDTH M3 > 0.550
  WM4 = WITH WIDTH M4 > 0.550
  encVia = V3 INTERACT (WM3 OR WM4)
  ((M3 AND M4) ENCLOSE encVia) ENCLOSE V3 < 3
}
V3_10 {
@ At least four Vn vias must connect Mn to Mn+1 when the Mn or Mn+1 width is > 0.645um
  WM3 = WITH WIDTH M3 > 0.645
  WM4 = WITH WIDTH M4 > 0.645
  encVia = V3 INTERACT (WM3 OR WM4)
  ((M3 AND M4) ENCLOSE encVia) ENCLOSE V3 < 4
}
V3_square = RECTANGLE V3 ASPECT ==1
V3_EMPTY = EMPTY OR (V3_square INSIDE (M3 AND M4) )  
INTER_EMPTY3 = EMPTY OR (M3 AND M4)
CONNECT  V3_EMPTY INTER_EMPTY3

V3_16 {
@At least two Vns with space <=0.16um when one of Mn or Mn+1 with both length and width >0.24um.
@Exclude non-square Vn and SRAM area.
X1a = WITH WIDTH M3  >0.24
X1b = WITH WIDTH M4  >0.24
WIDE = X1a OR X1b
X2 = (M3 AND M4) ENCLOSE V3_square
X3 =  V3_square INSIDE X2
X5c = EXT (V3_EMPTY INSIDE WIDE ) V3_EMPTY<=0.16 ABUT<90 REGION CONNECTED  // space of via <= 0.16 
X6c = X2 ENCLOSE X5c  // good intersection with space of Via <= 0.16
X7= ((SIZE X3 BY 0.325) AND X2) ENCLOSE V3 >2
X7c=X2 ENCLOSE X7
X=((X2 NOT X6c) NOT X7c) ENCLOSE (V3_square INSIDE WIDE) // Via_16
X OUTSIDE INST
}
V3_A = V3_square INTERACT WM3_EXP 
CONNECT V3_A M3
CONNECT V3 M3
CONNECT WM3 M3

//M4_fake = COPY M4
WM4 = M4 WITH WIDTH > 0.24
WM4_EDGE = LENGTH WM4 > 0
WM4_EXP = EXPAND EDGE WM4_EDGE OUTSIDE BY 1.1
WM4_L1 = ( M4 NOT WM4 ) TOUCH WM4
V3_A2 = V3_square INTERACT WM4_EXP

CONNECT V3 M4
V3_A2_EMPTY = EMPTY OR V3_A2
M4_EMPTY = EMPTY OR M4
WM4_EMPTY = EMPTY OR WM4 
CONNECT V3_A2_EMPTY M4_EMPTY
CONNECT WM4_EMPTY M4_EMPTY


V3_17 {
@ At least two Vns  when either wide metal of Mn or Mn+1 with both length L>0.24um and width W>0.24um, and the distance D<=1.1um away from this wide metal.
@ Exclude non-square Vn
WM3_L1 = ( M3 NOT WM3 ) TOUCH WM3
M3_ENCWM = (M3 INTERACT WM3) INTERACT V3_A
WM3_VEDGE = EXT [M3_ENCWM]  <1.1 ABUT<90 OPPOSITE NOTCH
WM3_EXT1 = EXT (WM3 COIN EDGE WM3_VEDGE) [V3_A] < 1.1 ABUT>=0 <90  OPPOSITE CONNECTED 
WM3_EXT2 = (EXT WM3 V3_A < 1.1 ABUT>=0 <90  OPPOSITE REGION CONNECTED ) INSIDE M3  
V3_B = V3_square WITH EDGE WM3_EXT1
X1 =(M3 AND M4) ENCLOSE V3_square >1
X2 = ((M3 AND M4)  AND ( WM3_L1 AND WM3_EXP )) NOT X1 

Y0=(M3 AND M4) ENCLOSE V3_square ==1 
Y1 = SIZE (V3_square INTERACT Y0) BY 1.1 INSIDE OF M3 STEP 0.005  
Y2= Y1 INTERACT (Y1 AND WM3)

VSING1= ((X2 INTERACT V3_B ==1) INTERACT Y2) OR ((X2 INTERACT WM3_EXT2) INTERACT V3_A)
VSING1 OUTSIDE INST 

M4_ENCWM = (M4 INTERACT WM4) INTERACT V3_A2
WM4_VEDGE = EXT [M4_ENCWM]  <1.1 ABUT<90 OPPOSITE NOTCH
WM4_EXT1 = EXT (WM4_EMPTY COIN EDGE WM4_VEDGE) [V3_A2_EMPTY] < 1.1 ABUT>=0 <90  OPPOSITE CONNECTED 
WM4_EXT2 = (EXT WM4_EMPTY V3_A2_EMPTY < 1.1 ABUT>=0 <90  OPPOSITE REGION CONNECTED ) INSIDE M4  
V3_B2 = V3_square WITH EDGE WM4_EXT1
X3 = ((M3 AND M4)  AND ( WM4_L1 AND WM4_EXP )) NOT X1
Y3 = SIZE (V3_square INTERACT Y0) BY 1.1 INSIDE OF M4 STEP 0.005  
Y4= Y3 INTERACT (Y3 AND WM4)
 
VSING2= ((X3 INTERACT V3_B2 ==1) INTERACT Y4) OR (( X3 INTERACT WM4_EXT2) INTERACT V3_A2)
VSING2 OUTSIDE INST
}

V3_A_a = V3_square INTERACT WM3_EXP_a 

CONNECT V3_A_a M3
CONNECT WM3_a M3
//M4_fake = area M4 >0
WM4_a = M4 WITH WIDTH > 1.4
WM4_EDGE_a = LENGTH WM4_a > 0
WM4_EXP_a = EXPAND EDGE WM4_EDGE_a OUTSIDE BY 2.8
WM4_L1_a = ( M4 NOT WM4_a ) TOUCH WM4_a
V3_A2_a = V3_square INTERACT WM4_EXP_a
V3_A2_EMPTY_a = EMPTY OR V3_A2_a
 WM4_EMPTY_a = EMPTY OR WM4_a 
CONNECT V3_A2_EMPTY_a M4_EMPTY
CONNECT WM4_EMPTY_a M4_EMPTY
V3_17a {
@ At least two Vns  when either wide metal of Mn or Mn+1 with both length L>1.4um and width W>1.4um, and the distance D<=2.8um away from this wide metal.
@ Exclude non-square Vn
WM3_L1_a = ( M3 NOT WM3_a ) TOUCH WM3_a
//M3_ENCWM = (M3 INTERACT WM3_a) INTERACT V3_A_a
//WM3_VEDGE = EXT [M3_ENCWM]  <2.8 ABUT<90 OPPOSITE NOTCH
//WM3_EXT1 = EXT (WM3_a COIN EDGE WM3_VEDGE) [V3_A_a] < 2.8 ABUT>=0 <90  OPPOSITE CONNECTED 
//WM3_EXT2 = (EXT WM3_a V3_A_a < 2.8 ABUT>=0 <90  OPPOSITE REGION CONNECTED ) INSIDE M3  
V3_B = COPY V3_square 
X1 =(M3 AND M4) ENCLOSE V3_square >1
X2 = ((M3 AND M4)  AND ( WM3_L1_a AND WM3_EXP_a )) NOT X1

Y0=(M3 AND M4) ENCLOSE V3_square ==1 
Y1 = SIZE (V3_square INTERACT Y0) BY 2.8 INSIDE OF M3 STEP 0.005  
Y2= Y1 INTERACT (Y1 AND WM3_a)

VSING1= (X2 INTERACT V3_B ==1) INTERACT Y2
VSING1 OUTSIDE INST 

//M4_ENCWM = (M4 INTERACT WM4_a) INTERACT V3_A2_a
//WM4_VEDGE = EXT [M4_ENCWM]  <2.8 ABUT<90 OPPOSITE NOTCH
//WM4_EXT1 = EXT (WM4_EMPTY_a COIN EDGE WM4_VEDGE) [V3_A2_EMPTY_a] < 2.8 ABUT>=0 <90  OPPOSITE CONNECTED 
//WM4_EXT2 = (EXT WM4_EMPTY_a V3_A2_EMPTY_a < 2.8 ABUT>=0 <90  OPPOSITE REGION CONNECTED ) INSIDE M4  
V3_B2 = COPY V3_square 
X3 = ((M3 AND M4)  AND ( WM4_L1_a AND WM4_EXP_a )) NOT X1  
Y3 = SIZE (V3_square INTERACT Y0) BY 2.8 INSIDE OF M4 STEP 0.005  
Y4 = Y3 INTERACT (Y3 AND WM4_a)

VSING2= (X3 INTERACT V3_B2 ==1) INTERACT Y4
VSING2 OUTSIDE INST
}

V3_A_b = V3_square INTERACT WM3_EXP_b 

CONNECT V3_A_b M3
CONNECT WM3_b M3
//M4_fake = area M4 >0
WM4_b = (M4 WITH WIDTH > 2.1) WITH EDGE (LENGTH (M4 WITH WIDTH > 2.1) > 7)
WM4_EDGE_b = LENGTH WM4_b > 0
WM4_EXP_b = EXPAND EDGE WM4_EDGE_b OUTSIDE BY 7.1
WM4_L1_b = ( M4 NOT WM4_b ) TOUCH WM4_b
V3_A2_b = V3_square INTERACT WM4_EXP_b
V3_A2_EMPTY_b = EMPTY OR V3_A2_b
 WM4_EMPTY_b = EMPTY OR WM4_b 
CONNECT V3_A2_EMPTY_b M4_EMPTY
CONNECT WM4_EMPTY_b M4_EMPTY
V3_17b {
@ At least two Vns  when either wide metal of Mn or Mn+1 with both length L>7um and width W>2.1um, and the distance D<=7.1um away from this wide metal.
@ Exclude non-square Vn
WM3_L1_b = ( M3 NOT WM3_b ) TOUCH WM3_b
//M3_ENCWM = (M3 INTERACT WM3_b) INTERACT V3_A_b
//WM3_VEDGE = EXT [M3_ENCWM]  <7.1 ABUT<90 OPPOSITE NOTCH
//WM3_EXT1 = EXT (WM3_b COIN EDGE WM3_VEDGE) [V3_A_b] < 7.1 ABUT>=0 <90  OPPOSITE CONNECTED 
//WM3_EXT2 = (EXT WM3_b V3_A_b < 7.1 ABUT>=0 <90  OPPOSITE REGION CONNECTED ) INSIDE M3  
V3_B = COPY V3_square 
X1 =(M3 AND M4) ENCLOSE V3_square >1
X2 = ((M3 AND M4)  AND ( WM3_L1_b AND WM3_EXP_b )) NOT X1

Y0=(M3 AND M4) ENCLOSE V3_square ==1 
Y1 = SIZE (V3_square INTERACT Y0) BY 7.1 INSIDE OF M3 STEP 0.005  
Y2= Y1 INTERACT (Y1 AND WM3_b)

VSING1= (X2 INTERACT V3_B ==1) INTERACT Y2
VSING1 OUTSIDE INST 

//M4_ENCWM = (M4 INTERACT WM4_b) INTERACT V3_A2_b
//WM4_VEDGE = EXT [M4_ENCWM]  <7.1 ABUT<90 OPPOSITE NOTCH
//WM4_EXT1 = EXT (WM4_EMPTY_b COIN EDGE WM4_VEDGE) [V3_A2_EMPTY_b] < 7.1 ABUT>=0 <90  OPPOSITE CONNECTED 
//WM4_EXT2 = (EXT WM4_EMPTY_b V3_A2_EMPTY_b < 7.1 ABUT>=0 <90  OPPOSITE REGION CONNECTED ) INSIDE M4
V3_B2 = COPY V3_square 
X3 = ((M3 AND M4)  AND ( WM4_L1_b AND WM4_EXP_b )) NOT X1  
Y3 = SIZE (V3_square INTERACT Y0) BY 7.1 INSIDE OF M4 STEP 0.005  
Y4 = Y3 INTERACT (Y3 AND WM4_b)

VSING2= (X3 INTERACT V3_B2 ==1) INTERACT Y4
VSING2 OUTSIDE INST
}

V3_18 {
@ 45-degree rotated V3 is not allowed.
  (ANGLE V3_all >= 44.9 <= 45.1) NOT INSIDE EDGE MARKS
}
V3_19 {
    @ Single V3 is not allowed in "H-shape" M4 when:
    @ 1. The M4 has "H-shape" interact with two metal holes: both two metal holes length <= 4.5um(L2) and two metal hole area <= 4.5um2.
    @ 2. The V3 overlaps on the center metal bar of this "H-shape" M4.
    @ 3. The center metal bar length <= 1um(L) and the metal bar width <= 0.2um.
    X0 = AREA (HOLES M4 INNER) <= 4.5
    X1 = (X0 NOT ENCLOSE RECTANGLE 1+0.001 4.5) NOT ENCLOSE RECTANGLE 1 4.5+0.001
    Y = M4 COIN EDGE X1
    Z = INT Y <= 0.2 OPPOSITE REGION
    H = V3 NOT OUTSIDE (Z INTERACT X1 == 2)
//    (Z INTERACT H == 1) NOT MARKS
    ERR = ((M3 AND M4) INTERACT H) NOT INTERACT (V3 NOT H) 
    ((Z INTERACT H == 1) INTERACT ERR) NOT MARKS    
}
V3_20 {
@ V3 connected to M4DUM, M3DUM is not allowed.
@ This rule is not applied for LOGO covered region.
  (V3 INTERACT (M4DUM OR M3DUM)) NOT LOGO
}
V3_21 {
@ V3 must be fully covered by M3 and M4.
  V3_all NOT (M3_all AND M4_all)
}
V3_22_R_OFF {
@ Insert one V3 if single V3 and (W3 >= 5W4, or W4 >= 5W3) at enclosure.
 CMACRO DFM4 M3 M4 V3
}
V3_23_R_OFF {
@ At least two vias (Vn, TV1, TV2, n=1~7) in Mn and Mn+1 (M1, Mn, n=2~8, TM1, TM2) intersection area. 
@ (This rule is not applicable for SRAM region, 
@ but SRAM region should follow main rule: V1.17, Vn.17, TV1.13, TV2.13, TV2.14)
  V3_INTER= V3 INSIDE (M3 AND M4) 
  X = (M3 AND M4) INTERACT V3_INTER  <2
  X OUTSIDE INST
}
V3_24 {
@ It?s not allowed V3 overlap with M3 and M4 resistor.
  V3 AND (M3 AND M3R)
  V3 AND (M4 AND M4R)
}
#ENDIF

#IFDEF V4_CHECK YES
//========================
//  V4 - Via 4 DRC
//========================

GROUP GV4 V4_?

V4_1 {
@ Fixed V4 size is 0.07
  NOT RECTANGLE V4 == 0.07 BY == 0.07
}
V4_2 {
@ Space between two V4 is 0.07
  EXT V4_all < 0.07 ABUT<90 SINGULAR REGION
}
V4_array = SIZE (SIZE V4 BY 0.05 OVERUNDER) BY 0.150 UNDEROVER
V4_GAP4 = V4_array NOT M4
V4_GAP5 = V4_array NOT M5
V4_3 {
@Space between Vns (with run length>=0) at least two least two sides is 0.09, when array equal to or greater than 3x3. 
@Two Via areas whose space is within 0.10um are considered to be in the same array. An array does
@ not have both row and column greater than or equal to 3 can apply smaller spacing Vn.2 instead of Vn.3
 X = EXT (V4 INTERACT V4_array) V4< 0.090 OPPOSITE EXTENDED  0.001  REGION 
   Y =SIZE V4 BY 0.001
  (Y INTERACT  V4_array)  INTERACT (X NOT Y) >2
}
/*
V4_4 {
@ V4_array not touching MOMDMY maximum width is 0.85
  (WITH WIDTH V4_array > 0.85) NOT INTERACT MOMDMY
}
*/
#IFDEF TOPMETAL 9
V4_5 {
@ V4 (different net) minimum space for run length > 0um is 0.1 (outside of SRAM)
 X = EXT V4 < 0.1 NOT CONNECTED OPPOSITE REGION
 X OUTSIDE INST
 (EXT V4DUM < 0.1 ABUT<90 SINGULAR OPPOSITE REGION) OUTSIDE INST
 (EXT V4DUM V4 < 0.1 ABUT<90 SINGULAR OPPOSITE REGION) OUTSIDE INST
}
V4_5_R_OFF {
@ V4 (different net) minimum space for run length > 0um is 0.11 (outside of SRAM)
 X = EXT V4 < 0.11 NOT CONNECTED OPPOSITE REGION
 X OUTSIDE INST
}
V4_5a {
@ V4 (different net) minimum space is 0.09
 EXT V4 < 0.09 NOT CONNECTED REGION
 EXT V4DUM < 0.09 ABUT<90 SINGULAR REGION
 EXT V4DUM V4 < 0.09 ABUT<90 SINGULAR REGION
}
/*V4_5b {
@ Vn minimum space in different net inside of SRAM is 0.09
  EXT (V4 NOT OUTSIDE INST) < 0.09 NOT CONNECTED REGION
}*/
#ENDIF
#IFDEF TOPMETAL 8
V4_5 {
@ V4 (different net) minimum space for run length > 0um is 0.1 (outside of SRAM)
 X = EXT V4 < 0.1 NOT CONNECTED OPPOSITE REGION
 X OUTSIDE INST
 (EXT V4DUM < 0.1 ABUT<90 SINGULAR OPPOSITE REGION) OUTSIDE INST
 (EXT V4DUM V4 < 0.1 ABUT<90 SINGULAR OPPOSITE REGION) OUTSIDE INST
}
V4_5_R_OFF {
@ V4 (different net) minimum space for run length > 0um is 0.11 (outside of SRAM)
 X = EXT V4 < 0.11 NOT CONNECTED OPPOSITE REGION
 X OUTSIDE INST
}
V4_5a {
@ V4 (different net) minimum space is 0.09
  EXT V4 < 0.09 NOT CONNECTED REGION
  EXT V4DUM < 0.09 ABUT<90 SINGULAR REGION
  EXT V4DUM V4 < 0.09 ABUT<90 SINGULAR REGION
}
/*V4_5b {
@ Vn minimum space in different net inside of SRAM is 0.09
  EXT (V4 NOT OUTSIDE INST) < 0.09 NOT CONNECTED REGION
}*/
#ENDIF
#IFDEF TOPMETAL 7
V4_5 {
@ V4 (different net) minimum space for run length > 0um is 0.1 (outside of SRAM)
 X = EXT V4 < 0.1 NOT CONNECTED OPPOSITE REGION
 X OUTSIDE INST
 (EXT V4DUM < 0.1 ABUT<90 SINGULAR OPPOSITE REGION) OUTSIDE INST
 (EXT V4DUM V4 < 0.1 ABUT<90 SINGULAR OPPOSITE REGION) OUTSIDE INST
}
V4_5_R_OFF {
@ V4 (different net) minimum space for run length > 0um is 0.11 (outside of SRAM)
 X = EXT V4 < 0.11 NOT CONNECTED OPPOSITE REGION
 X OUTSIDE INST
}
V4_5a {
@ V4 (different net) minimum space is 0.09
  EXT V4 < 0.09 NOT CONNECTED REGION
  EXT V4DUM < 0.09 ABUT<90 SINGULAR REGION
  EXT V4DUM V4 < 0.09 ABUT<90 SINGULAR REGION
}
/*V4_5b {
@ Vn minimum space in different net inside of SRAM is 0.09
  EXT (V4 NOT OUTSIDE INST) < 0.09 NOT CONNECTED REGION
}*/
#ENDIF
#IFDEF TOPMETAL 6
V4_5 {
@ V4 (different net) minimum space for run length > 0um is 0.1 (outside of SRAM)
  X =EXT V4 < 0.1 NOT CONNECTED OPPOSITE REGION
  X OUTSIDE INST
  (EXT V4DUM < 0.1 ABUT<90 SINGULAR OPPOSITE REGION) OUTSIDE INST
  (EXT V4DUM V4 < 0.1 ABUT<90 SINGULAR OPPOSITE REGION) OUTSIDE INST
}
V4_5_R_OFF {
@ V4 (different net) minimum space for run length > 0um is 0.11 (outside of SRAM)
 X = EXT V4 < 0.11 NOT CONNECTED OPPOSITE REGION
 X OUTSIDE INST
}
V4_5a {
@ V4 (different net) minimum space is 0.09
 EXT V4 < 0.09 NOT CONNECTED REGION
 EXT V4DUM < 0.09 ABUT<90 SINGULAR REGION
 EXT V4DUM V4 < 0.09 ABUT<90 SINGULAR REGION
}
/*V4_5b {
@ Vn minimum space in different net inside of SRAM is 0.09
  EXT (V4 NOT OUTSIDE INST) < 0.09 NOT CONNECTED REGION
}*/
#ENDIF
V4_6abc {
@ V2 must within M2
@  per Mn and Mn+1 intersection containing a Vn, must meet rule Vn.6a, Vn.6b or Vn.6c
@ V2.6a, V2 minimum within M2 is 0.015
@ Vn.6b	Mn overlap past Vn for two opposite sides with either side  >=0.01um, and < 0.015um  0.02
@ Vn.6c	Mn overlap past Vn for two opposite sides with either side >= 0um, and < 0.01um 0.03
  V4_all NOT M4_all
  M4andM5 = (M4_all AND M5_all) INTERACT V4_all
  BadV4 = RECTANGLE ENCLOSURE V4_all M4_all OUTSIDE ALSO
  GOOD 0.015 OPPOSITE 0.015 OPPOSITE  0.015 OPPOSITE 0.015 OPPOSITE
  GOOD 0.02 OPPOSITE 0.01 OPPOSITE  0.02 OPPOSITE 0.01 OPPOSITE
  GOOD 0.03 0.0  0.03 0.0
  BadV4 INTERACT M4andM5
}
/*V4_6d {
@ Vn touching Mn with width > 0.14um, with at least one redundant Vn.
@ This rule only applies to that M4/M5 intersection area can enclose a rectangle of 0.07*0.27.
 CMACRO V67D V4 M4 M5
}*/
V4_7abc {
@ V2 must within M3
@  per Mn and Mn+1 intersection containing a Vn, must meet rule Vn.7a, Vn.7b or Vn.7c
@ V2.7a, V2 minimum within M3 is 0.015
@ V2.7b, M3 minimum overlap past V2 for two opposite sides with either side >=0.01um, and < 0.015um  is 0.02
@ V2.7c, M3 minimum overlap past V2 for two opposite sides with the either side >=0um, and < 0.01um is 0.03
  V4_all NOT M5_all
  M4andM5 = (M4_all AND M5_all) INTERACT V4_all
  BadV4 = RECTANGLE ENCLOSURE V4_all M5_all OUTSIDE ALSO
  GOOD 0.015 OPPOSITE 0.015 OPPOSITE  0.015 OPPOSITE 0.015 OPPOSITE
  GOOD 0.02 OPPOSITE 0.01 OPPOSITE 0.02 OPPOSITE 0.01 OPPOSITE
  GOOD 0.03 0.0  0.03 0.0 
  BadV4 INTERACT M4andM5
}
/*V4_7d {
@ Vn+1 touching Mn with width > 0.14um, with at least one redundant Vn.
@ This rule only applies to that M4/M5 intersection area can enclose a rectangle of 0.07*0.27.
 CMACRO V67D V4 M5 M4
}*/
V4_8 {
@ At least two Vn vias must connect Mn to Mn+1 when the Mn or Mn+1 width is > 0.26um
  WM4 = WITH WIDTH M4 > 0.260
  WM5 = WITH WIDTH M5 > 0.260
  encVia = V4 INTERACT (WM4 OR WM5)
  ((M4 AND M5) ENCLOSE encVia) ENCLOSE V4 < 2
}
V4_9 {
@ At least three Vn vias must connect Mn to Mn+1 when the Mn or Mn+1 width is > 0.55um
  WM4 = WITH WIDTH M4 > 0.550
  WM5 = WITH WIDTH M5 > 0.550
  encVia = V4 INTERACT (WM4 OR WM5)
  ((M4 AND M5) ENCLOSE encVia) ENCLOSE V4 < 3
}
V4_10 {
@ At least four Vn vias must connect Mn to Mn+1 when the Mn or Mn+1 width is > 0.645um
  WM4 = WITH WIDTH M4 > 0.645
  WM5 = WITH WIDTH M5 > 0.645
  encVia = V4 INTERACT (WM4 OR WM5)
  ((M4 AND M5) ENCLOSE encVia) ENCLOSE V4 < 4
}
V4_square = RECTANGLE V4 ASPECT ==1
V4_EMPTY = EMPTY OR (V4_square INSIDE (M4 AND M5) )
INTER_EMPTY4 = EMPTY OR (M4 AND M5) 
CONNECT  V4_EMPTY INTER_EMPTY4

V4_16 {
@At least two Vns with space <=0.16um when one of Mn or Mn+1 with both length and width >0.24um.
@Exclude non-square Vn and SRAM area.
X1a = WITH WIDTH M4  >0.24
X1b = WITH WIDTH M5  >0.24
WIDE = X1a OR X1b
X2 = (M5 AND M4) ENCLOSE V4_square
X3 =  V4_square INSIDE X2
X5c = EXT (V4_EMPTY INSIDE WIDE ) V4_EMPTY<=0.16 ABUT<90 REGION CONNECTED // space of via <= 0.14 
X6c = X2 ENCLOSE X5c  // good intersection with space of Via <= 0.14
X7= ((SIZE X3 BY 0.325) AND X2) ENCLOSE V4 >2
X7c=X2 ENCLOSE X7
X =((X2 NOT X6c) NOT X7c) ENCLOSE ( V4_square INSIDE WIDE) // Via_16
X OUTSIDE INST
}
//WM4 = M4 WITH WIDTH > 0.24
CONNECT V4 M4
CONNECT V4 M5
V4_A = V4_square INTERACT WM4_EXP
CONNECT V4_A M4
CONNECT WM4 M4
WM5 = M5 WITH WIDTH > 0.24
WM5_EDGE = LENGTH WM5 > 0
WM5_EXP = EXPAND EDGE WM5_EDGE OUTSIDE BY 1.1
WM5_L1 = ( M5 NOT WM5 ) TOUCH WM5
V4_A2 = V4_square INTERACT WM5_EXP
V4_A2_EMPTY = EMPTY OR V4_A2
M5_EMPTY = EMPTY OR M5
 WM5_EMPTY = EMPTY OR WM5 
CONNECT V4_A2_EMPTY M5_EMPTY
CONNECT WM5_EMPTY M5_EMPTY




V4_17 {
@ At least two Vns when either wide metal of Mn or Mn+1 with both length L>0.24um and width W>0.24um, and the distance D<=1.1um away from this wide metal.
@ Exclude non-square Vn
 
WM4_L1 = ( M4 NOT WM4 ) TOUCH WM4
M4_ENCWM = (M4 INTERACT WM4) INTERACT V4_A
WM4_VEDGE = EXT [M4_ENCWM]  <1.1 ABUT<90 OPPOSITE NOTCH
WM4_EXT1 = EXT (WM4 COIN EDGE WM4_VEDGE) [V4_A] < 1.1 ABUT>=0 <90  OPPOSITE CONNECTED 
WM4_EXT2 = (EXT WM4 V4_A < 1.1 ABUT>=0 <90  OPPOSITE REGION CONNECTED ) INSIDE M4  
V4_B = V4_square WITH EDGE WM4_EXT1
X1 =(M4 AND M5) ENCLOSE V4_square >1
X2 = ((M4 AND M5)  AND ( WM4_L1 AND WM4_EXP )) NOT X1  
Y0=(M4 AND M5) ENCLOSE V4_square ==1 
Y1 = SIZE (V4_square INTERACT Y0) BY 1.1 INSIDE OF M4 STEP 0.005  
Y2= Y1 INTERACT (Y1 AND WM4)
VSING1= ((X2 INTERACT V4_B ==1) INTERACT Y2) OR ((X2 INTERACT WM4_EXT2) INTERACT V4_A)
VSING1 OUTSIDE INST 

M5_ENCWM = (M5 INTERACT WM5) INTERACT V4_A2
WM5_VEDGE = EXT [M5_ENCWM]  <1.1 ABUT<90 OPPOSITE NOTCH
WM5_EXT1 = EXT (WM5_EMPTY COIN EDGE WM5_VEDGE) [V4_A2_EMPTY] < 1.1 ABUT>=0 <90  OPPOSITE CONNECTED 
WM5_EXT2 = (EXT WM5_EMPTY V4_A2_EMPTY < 1.1 ABUT>=0 <90  OPPOSITE REGION CONNECTED ) INSIDE M5  
V4_B2 = V4_square WITH EDGE WM5_EXT1
X3 = ((M4 AND M5)  AND ( WM5_L1 AND WM5_EXP )) NOT X1  
Y3 = SIZE (V4_square INTERACT Y0) BY 1.1 INSIDE OF M5 STEP 0.005  
Y4= Y3 INTERACT (Y3 AND WM5)
VSING2= ((X3 INTERACT V4_B2 ==1) INTERACT Y4) OR (( X3 INTERACT WM5_EXT2) INTERACT V4_A2)
VSING2 OUTSIDE INST

}

V4_A_a = V4_square INTERACT WM4_EXP_a 

CONNECT V4_A_a M4
CONNECT WM4_a M4
//M5_fake = area M5 >0
WM5_a = M5 WITH WIDTH > 1.4
WM5_EDGE_a = LENGTH WM5_a > 0
WM5_EXP_a = EXPAND EDGE WM5_EDGE_a OUTSIDE BY 2.8
WM5_L1_a = ( M5 NOT WM5_a ) TOUCH WM5_a
V4_A2_a = V4_square INTERACT WM5_EXP_a
V4_A2_EMPTY_a = EMPTY OR V4_A2_a
 WM5_EMPTY_a = EMPTY OR WM5_a 
CONNECT V4_A2_EMPTY_a M5_EMPTY
CONNECT WM5_EMPTY_a M5_EMPTY
V4_17a {
@ At least two Vns  when either wide metal of Mn or Mn+1 with both length L>1.4um and width W>1.4um, and the distance D<=2.8um away from this wide metal.
@ Exclude non-square Vn
WM4_L1_a = ( M4 NOT WM4_a ) TOUCH WM4_a
//M4_ENCWM = (M4 INTERACT WM4_a) INTERACT V4_A_a
//WM4_VEDGE = EXT [M4_ENCWM]  <2.8 ABUT<90 OPPOSITE NOTCH
//WM4_EXT1 = EXT (WM4_a COIN EDGE WM4_VEDGE) [V4_A_a] < 2.8 ABUT>=0 <90  OPPOSITE CONNECTED 
//WM4_EXT2 = (EXT WM4_a V4_A_a < 2.8 ABUT>=0 <90  OPPOSITE REGION CONNECTED ) INSIDE M4  
V4_B = COPY V4_square
X1 =(M4 AND M5) ENCLOSE V4_square >1
X2 = ((M4 AND M5)  AND ( WM4_L1_a AND WM4_EXP_a )) NOT X1

Y0=(M4 AND M5) ENCLOSE V4_square ==1 
Y1 = SIZE (V4_square INTERACT Y0) BY 2.8 INSIDE OF M4 STEP 0.005  
Y2= Y1 INTERACT (Y1 AND WM4_a)

VSING1= (X2 INTERACT V4_B ==1) INTERACT Y2
VSING1 OUTSIDE INST 

//M5_ENCWM = (M5 INTERACT WM5_a) INTERACT V4_A2_a
//WM5_VEDGE = EXT [M5_ENCWM]  <2.8 ABUT<90 OPPOSITE NOTCH
//WM5_EXT1 = EXT (WM5_EMPTY_a COIN EDGE WM5_VEDGE) [V4_A2_EMPTY_a] < 2.8 ABUT>=0 <90  OPPOSITE CONNECTED 
//WM5_EXT2 = (EXT WM5_EMPTY_a V4_A2_EMPTY_a < 2.8 ABUT>=0 <90  OPPOSITE REGION CONNECTED ) INSIDE M5  
V4_B2 = COPY V4_square 
X3 = ((M4 AND M5)  AND ( WM5_L1_a AND WM5_EXP_a )) NOT X1  
Y3 = SIZE (V4_square INTERACT Y0) BY 2.8 INSIDE OF M5 STEP 0.005  
Y4 = Y3 INTERACT (Y3 AND WM5_a)

VSING2= (X3 INTERACT V4_B2 ==1) INTERACT Y4
VSING2 OUTSIDE INST
}

V4_A_b = V4_square INTERACT WM4_EXP_b 

CONNECT V4_A_b M4
CONNECT WM4_b M4
//M5_fake = area M5 >0
WM5_b = (M5 WITH WIDTH > 2.1) WITH EDGE (LENGTH (M5 WITH WIDTH > 2.1) > 7)
WM5_EDGE_b = LENGTH WM5_b > 0
WM5_EXP_b = EXPAND EDGE WM5_EDGE_b OUTSIDE BY 7.1
WM5_L1_b = ( M5 NOT WM5_b ) TOUCH WM5_b
V4_A2_b = V4_square INTERACT WM5_EXP_b
V4_A2_EMPTY_b = EMPTY OR V4_A2_b
 WM5_EMPTY_b = EMPTY OR WM5_b 
CONNECT V4_A2_EMPTY_b M5_EMPTY
CONNECT WM5_EMPTY_b M5_EMPTY
V4_17b {
@ At least two Vns  when either wide metal of Mn or Mn+1 with both length L>7um and width W>2.1um, and the distance D<=7.1um away from this wide metal.
@ Exclude non-square Vn
WM4_L1_b = ( M4 NOT WM4_b ) TOUCH WM4_b
//M4_ENCWM = (M4 INTERACT WM4_b) INTERACT V4_A_b
//WM4_VEDGE = EXT [M4_ENCWM]  <7.1 ABUT<90 OPPOSITE NOTCH
//WM4_EXT1 = EXT (WM4_b COIN EDGE WM4_VEDGE) [V4_A_b] < 7.1 ABUT>=0 <90  OPPOSITE CONNECTED 
//WM4_EXT2 = (EXT WM4_b V4_A_b < 7.1 ABUT>=0 <90  OPPOSITE REGION CONNECTED ) INSIDE M4 
V4_B = COPY V4_square 
X1 =(M4 AND M5) ENCLOSE V4_square >1
X2 = ((M4 AND M5)  AND ( WM4_L1_b AND WM4_EXP_b )) NOT X1

Y0=(M4 AND M5) ENCLOSE V4_square ==1 
Y1 = SIZE (V4_square INTERACT Y0) BY 7.1 INSIDE OF M4 STEP 0.005  
Y2= Y1 INTERACT (Y1 AND WM4_b)

VSING1= (X2 INTERACT V4_B ==1) INTERACT Y2
VSING1 OUTSIDE INST 

//M5_ENCWM = (M5 INTERACT WM5_b) INTERACT V4_A2_b
//WM5_VEDGE = EXT [M5_ENCWM]  <7.1 ABUT<90 OPPOSITE NOTCH
//WM5_EXT1 = EXT (WM5_EMPTY_b COIN EDGE WM5_VEDGE) [V4_A2_EMPTY_b] < 7.1 ABUT>=0 <90  OPPOSITE CONNECTED 
//WM5_EXT2 = (EXT WM5_EMPTY_b V4_A2_EMPTY_b < 7.1 ABUT>=0 <90  OPPOSITE REGION CONNECTED ) INSIDE M5
V4_B2 = COPY V4_square 
X3 = ((M4 AND M5)  AND ( WM5_L1_b AND WM5_EXP_b )) NOT X1  
Y3 = SIZE (V4_square INTERACT Y0) BY 7.1 INSIDE OF M5 STEP 0.005  
Y4 = Y3 INTERACT (Y3 AND WM5_b)

VSING2= (X3 INTERACT V4_B2 ==1) INTERACT Y4
VSING2 OUTSIDE INST
}

V4_18 {
@ 45-degree rotated V4 is not allowed.
  (ANGLE V4_all >= 44.9 <= 45.1) NOT INSIDE EDGE MARKS
}
V4_19 {
    @ Single V4 is not allowed in "H-shape" M5 when:
    @ 1. The M5 has "H-shape" interact with two metal holes: both two metal holes length <= 4.5um(L2) and two metal hole area <= 4.5um2.
    @ 2. The V4 overlaps on the center metal bar of this "H-shape" M5.
    @ 3. The center metal bar length <= 1um(L) and the metal bar width <= 0.2um.
    X0 = AREA (HOLES M5 INNER) <= 4.5
    X1 = (X0 NOT ENCLOSE RECTANGLE 1+0.001 4.5) NOT ENCLOSE RECTANGLE 1 4.5+0.001
    Y = M5 COIN EDGE X1
    Z = INT Y <= 0.2 OPPOSITE REGION
    H = V4 NOT OUTSIDE (Z INTERACT X1 == 2)
//    (Z INTERACT H == 1) NOT MARKS
    ERR = ((M4 AND M5) INTERACT H) NOT INTERACT (V4 NOT H) 
    ((Z INTERACT H == 1) INTERACT ERR) NOT MARKS
}
V4_20 {
@ V4 connected to M5DUM, M4DUM is not allowed.
@ This rule is not applied for LOGO covered region.
  (V4 INTERACT (M5DUM OR M4DUM)) NOT LOGO
}
V4_21 {
@ V4 must be fully covered by M4 and M5.
  V4_all NOT (M4_all AND M5_all)
}
V4_22_R_OFF {
@ Insert one V4 if single V4 and (W4 >= 5W5, or W5 >= 5W4) at enclosure.
 CMACRO DFM4 M4 M5 V4
}
V4_23_R_OFF {
@ At least two vias (Vn, TV1, TV2, n=1~7) in Mn and Mn+1 (M1, Mn, n=2~8, TM1, TM2) intersection area. 
@ (This rule is not applicable for SRAM region, 
@ but SRAM region should follow main rule: V1.17, Vn.17, TV1.13, TV2.13, TV2.14)
  V4_INTER= V4 INSIDE (M4 AND M5) 
  X = (M4 AND M5) INTERACT V4_INTER  <2
  X OUTSIDE INST
}
V4_24 {
@ It?s not allowed V4 overlap with M4 and M5 resistor.
  V4 AND (M4 AND M4R)
  V4 AND (M5 AND M5R)
}
#ENDIF

#IFDEF V5_CHECK YES
//========================
//  V5 - Via 5 DRC
//========================

GROUP GV5 V5_?

V5_1 {
@ Fixed V5 size is 0.07
  NOT RECTANGLE V5 == 0.07 BY == 0.07
}
V5_2 {
@ Space between two V5 is 0.07
  EXT V5_all < 0.07 ABUT<90 SINGULAR REGION
}
V5_array = SIZE (SIZE V5 BY 0.05 OVERUNDER) BY 0.150 UNDEROVER
V5_GAP5 = V5_array NOT M5
V5_GAP6 = V5_array NOT M6
V5_3 {
@Space between Vns (with run length>=0) at least two least two sides is 0.09, when array equal to or greater than 3x3. 
@Two Via areas whose space is within 0.10um are considered to be in the same array. An array does
@ not have both row and column greater than or equal to 3 can apply smaller spacing Vn.2 instead of Vn.3
   X = EXT (V5 INTERACT V5_array) V5< 0.090 OPPOSITE EXTENDED  0.001  REGION 
   Y =SIZE V5 BY 0.001
  (Y INTERACT  V5_array)  INTERACT (X NOT Y) >2
}
/*
V5_4 {
@ V5_array not touching MOMDMY maximum width is 0.85
  (WITH WIDTH V5_array > 0.85) NOT INTERACT MOMDMY
}
*/
#IFDEF TOPMETAL 9
V5_5 {
@ V5 (different net) minimum space for run length > 0um is 0.1(outside of SRAM)
  X = EXT V5 < 0.1 NOT CONNECTED OPPOSITE REGION
  X OUTSIDE INST 
  (EXT V5DUM < 0.1 ABUT<90 SINGULAR OPPOSITE REGION) OUTSIDE INST
  (EXT V5DUM V5 < 0.1 ABUT<90 SINGULAR OPPOSITE REGION) OUTSIDE INST
}
V5_5_R_OFF {
@ V5 (different net) minimum space for run length > 0um is 0.11(outside of SRAM)
  X = EXT V5 < 0.11 NOT CONNECTED OPPOSITE REGION
  X OUTSIDE INST 
}
V5_5a {
@ V5 (different net) minimum space is 0.09
 EXT V5 < 0.09 NOT CONNECTED REGION
 EXT V5DUM < 0.09 ABUT<90 SINGULAR REGION
 EXT V5DUM V5 < 0.09 ABUT<90 SINGULAR REGION
}
/*V5_5b {
@ Vn minimum space in different net inside of SRAM is 0.09
  EXT (V5 NOT OUTSIDE INST) < 0.09 NOT CONNECTED REGION
}*/
#ENDIF
#IFDEF TOPMETAL 8
V5_5 {
@ V5 (different net) minimum space for run length > 0um is 0.1(outside of SRAM)
  X =EXT V5 < 0.1 NOT CONNECTED OPPOSITE REGION
  X OUTSIDE INST
  (EXT V5DUM < 0.1 ABUT<90 SINGULAR OPPOSITE REGION) OUTSIDE INST
  (EXT V5DUM V5 < 0.1 ABUT<90 SINGULAR OPPOSITE REGION) OUTSIDE INST
}
V5_5_R_OFF {
@ V5 (different net) minimum space for run length > 0um is 0.11(outside of SRAM)
  X = EXT V5 < 0.11 NOT CONNECTED OPPOSITE REGION
  X OUTSIDE INST 
}
V5_5a {
@ V5 (different net) minimum space is 0.09
  EXT V5 < 0.09 NOT CONNECTED REGION
  EXT V5DUM < 0.09 ABUT<90 SINGULAR REGION
  EXT V5DUM V5 < 0.09 ABUT<90 SINGULAR REGION
}
/*V5_5b {
@ Vn minimum space in different net inside of SRAM is 0.09
  EXT (V5 NOT OUTSIDE INST) < 0.09 NOT CONNECTED REGION
}*/
#ENDIF
#IFDEF TOPMETAL 7
V5_5 {
@ V5 (different net) minimum space for run length > 0um is 0.1(outside of SRAM)
  X =EXT V5 < 0.1 NOT CONNECTED OPPOSITE REGION
  X OUTSIDE INST
  (EXT V5DUM < 0.1 ABUT<90 SINGULAR OPPOSITE REGION) OUTSIDE INST
  (EXT V5DUM V5 < 0.1 ABUT<90 SINGULAR OPPOSITE REGION) OUTSIDE INST
}
V5_5_R_OFF {
@ V5 (different net) minimum space for run length > 0um is 0.11(outside of SRAM)
  X = EXT V5 < 0.11 NOT CONNECTED OPPOSITE REGION
  X OUTSIDE INST 
}
V5_5a {
@ V5 (different net) minimum space is 0.09
  EXT V5 < 0.09 NOT CONNECTED REGION
  EXT V5DUM < 0.09 ABUT<90 SINGULAR REGION
  EXT V5DUM V5 < 0.09 ABUT<90 SINGULAR REGION
}
/*V5_5b {
@ Vn minimum space in different net inside of SRAM is 0.09
  EXT (V5 NOT OUTSIDE INST) < 0.09 NOT CONNECTED REGION
}*/
#ENDIF
V5_6abc {
@ V2 must within M2
@  per Mn and Mn+1 intersection containing a Vn, must meet rule Vn.6a, Vn.6b or Vn.6c
@ V2.6a, V2 minimum within M2 is 0.015
@ Vn.6b	Mn overlap past Vn for two opposite sides with either side  >=0.01um, and < 0.015um  0.02
@ Vn.6c	Mn overlap past Vn for two opposite sides with either side >= 0um, and < 0.01um 0.03
  V5_all NOT M5_all
  M5andM6 = (M5_all AND M6_all) INTERACT V5_all
  Badv5 = RECTANGLE ENCLOSURE V5_all M5_all OUTSIDE ALSO
  GOOD 0.015 OPPOSITE 0.015 OPPOSITE  0.015 OPPOSITE 0.015 OPPOSITE
  GOOD 0.02 OPPOSITE 0.01 OPPOSITE  0.02 OPPOSITE 0.01 OPPOSITE
  GOOD 0.03 0.0  0.03 0.0
  BadV5 INTERACT M5andM6
}
/*V5_6d {
@ Vn touching Mn with width > 0.14um, with at least one redundant Vn.
@ This rule only applies to that M5/M6 intersection area can enclose a rectangle of 0.07*0.27.
 CMACRO V67D V5 M5 M6
}*/
V5_7abc {
@ V2 must within M2
@  per Mn and Mn+1 intersection containing a Vn, must meet rule Vn.6a, Vn.6b or Vn.6c
@ V2.6a, V2 minimum within M2 is 0.015
@ Vn.6b	Mn overlap past Vn for two opposite sides with either side  >=0.01um, and < 0.015um  0.02
@ Vn.6c	Mn overlap past Vn for two opposite sides with either side >= 0um, and < 0.01um 0.03
  V5_all NOT M6_all
  M5andM6 = (M5_all AND M6_all) INTERACT V5_all
  BadV5 = RECTANGLE ENCLOSURE V5_all M6_all OUTSIDE ALSO
  GOOD 0.015 OPPOSITE 0.015  OPPOSITE 0.015 OPPOSITE 0.015 OPPOSITE
  GOOD 0.02 OPPOSITE 0.01 OPPOSITE 0.02 OPPOSITE 0.01 OPPOSITE
  GOOD 0.03 0.0  0.03 0.0 
  BadV5 INTERACT M5andM6
}
/*V5_7d {
@ Vn+1 touching Mn with width > 0.14um, with at least one redundant Vn.
@ This rule only applies to that M5/M6 intersection area can enclose a rectangle of 0.07*0.27.
 CMACRO V67D V5 M6 M5
}*/
V5_8 {
@ At least two Vn vias must connect Mn to Mn+1 when the Mn or Mn+1 width is > 0.26um
  WM5 = WITH WIDTH M5 > 0.260
  WM6 = WITH WIDTH M6 > 0.260
  encVia = V5 INTERACT (WM5 OR WM6)
  ((M5 AND M6) ENCLOSE encVia) ENCLOSE V5 < 2
}
V5_9 {
@ At least three Vn vias must connect Mn to Mn+1 when the Mn or Mn+1 width is > 0.55um
  WM5 = WITH WIDTH M5 > 0.550
  WM6 = WITH WIDTH M6 > 0.550
  encVia = V5 INTERACT (WM5 OR WM6)
  ((M5 AND M6) ENCLOSE encVia) ENCLOSE V5 < 3
}
V5_10 {
@ At least four Vn vias must connect Mn to Mn+1 when the Mn or Mn+1 width is > 0.645um
  WM5 = WITH WIDTH M5 > 0.645
  WM6 = WITH WIDTH M6 > 0.645
  encVia = V5 INTERACT (WM5 OR WM6)
  ((M5 AND M6) ENCLOSE encVia) ENCLOSE V5 < 4
}
V5_square = RECTANGLE V5 ASPECT ==1
V5_EMPTY = EMPTY  OR (V5_square INSIDE (M5 AND M6) )
INTER_EMPTY5 = EMPTY OR (M5 AND M6) 
CONNECT  V5_EMPTY INTER_EMPTY5

V5_16 {
@At least two Vns with space <=0.16um when one of Mn or Mn+1 with both length and width >0.24um.
@Exclude non-square Vn and SRAM area.
X1a = WITH WIDTH M5  >0.24
X1b = WITH WIDTH M6  >0.24
WIDE = X1a OR X1b
X2 = (M5 AND M6) ENCLOSE V5_square
X3 =  V5_square INSIDE X2
X5c = EXT (V5_EMPTY INSIDE WIDE ) V5_EMPTY<=0.16 ABUT<90 REGION OPPOSITE // space of via <= 0.16 
X6c = X2 ENCLOSE X5c  // good intersection with space of Via <= 0.16
X7= ((SIZE X3 BY 0.325) AND X2) ENCLOSE V5 >2
X7c=X2 ENCLOSE X7

X =((X2 NOT X6c)NOT X7c) ENCLOSE (V5_square INSIDE WIDE ) // Via_16
X OUTSIDE INST
}
//WM5 = M5 WITH WIDTH > 0.24
CONNECT V5 M5
V5_A = V5_square INTERACT WM5_EXP
CONNECT V5_A M5
CONNECT WM5 M5

WM6 = M6 WITH WIDTH > 0.24
WM6_EDGE = LENGTH WM6 > 0
WM6_EXP = EXPAND EDGE WM6_EDGE OUTSIDE BY 1.1
WM6_L1 = ( M6 NOT WM6 ) TOUCH WM6
V5_A2 = V5_square INTERACT WM6_EXP
CONNECT V5 M6
V5_A2_EMPTY = EMPTY OR V5_A2
M6_EMPTY = EMPTY OR M6
 WM6_EMPTY = EMPTY OR WM6 
CONNECT V5_A2_EMPTY M6_EMPTY
CONNECT WM6_EMPTY M6_EMPTY
V5_17 {
@ At least two Vns when either wide metal of Mn or Mn+1 with both length L>0.24um and width W>0.24um, and the distance D<=1.1um away from this wide metal.
@ Exclude non-square Vn
WM5_L1 = ( M5 NOT WM5 ) TOUCH WM5
M5_ENCWM = (M5 INTERACT WM5) INTERACT V5_A
WM5_VEDGE = EXT [M5_ENCWM]  <1.1 ABUT<90 OPPOSITE NOTCH
WM5_EXT1 = EXT (WM5 COIN EDGE WM5_VEDGE) [V5_A] < 1.1 ABUT>=0 <90  OPPOSITE CONNECTED 
WM5_EXT2 = (EXT WM5 V5_A < 1.1 ABUT>=0 <90  OPPOSITE REGION CONNECTED ) INSIDE M5  
V5_B = V5_square WITH EDGE WM5_EXT1
X1 =(M5 AND M6) ENCLOSE V5_square >1
X2 = ((M5 AND M6)  AND ( WM5_L1 AND WM5_EXP )) NOT X1 

Y0=(M5 AND M6) ENCLOSE V5_square ==1 
Y1 = SIZE (V5_square INTERACT Y0) BY 1.1 INSIDE OF M5 STEP 0.005  
Y2= Y1 INTERACT (Y1 AND WM5)

VSING1= ((X2 INTERACT V5_B ==1) INTERACT Y2)  OR ((X2 INTERACT WM5_EXT2) INTERACT V5_A)
VSING1 OUTSIDE INST 

M6_ENCWM = (M6 INTERACT WM6) INTERACT V5_A2
WM6_VEDGE = EXT [M6_ENCWM]  <1.1 ABUT<90 OPPOSITE NOTCH
WM6_EXT1 = EXT (WM6_EMPTY COIN EDGE WM6_VEDGE) [V5_A2_EMPTY] < 1.1 ABUT>=0 <90  OPPOSITE CONNECTED 
WM6_EXT2 = (EXT WM6_EMPTY V5_A2_EMPTY < 1.1 ABUT>=0 <90  OPPOSITE REGION CONNECTED ) INSIDE M6  
V5_B2 = V5_square WITH EDGE WM6_EXT1
X3 = ((M5 AND M6)  AND ( WM6_L1 AND WM6_EXP )) NOT X1 
Y3 = SIZE (V5_square INTERACT Y0) BY 1.1 INSIDE OF M6 STEP 0.005  
Y4= Y3 INTERACT (Y3 AND WM6)
VSING2= ((X3 INTERACT V5_B2 ==1) INTERACT Y4) OR (( X3 INTERACT WM6_EXT2) INTERACT V5_A2)
VSING2 OUTSIDE INST
}

V5_A_a = V5_square INTERACT WM5_EXP_a 

CONNECT V5_A_a M5
CONNECT WM5_a M5
//M6_fake = area M6 >0
WM6_a = M6 WITH WIDTH > 1.4
WM6_EDGE_a = LENGTH WM6_a > 0
WM6_EXP_a = EXPAND EDGE WM6_EDGE_a OUTSIDE BY 2.8
WM6_L1_a = ( M6 NOT WM6_a ) TOUCH WM6_a
V5_A2_a = V5_square INTERACT WM6_EXP_a
V5_A2_EMPTY_a = EMPTY OR V5_A2_a
 WM6_EMPTY_a = EMPTY OR WM6_a 
CONNECT V5_A2_EMPTY_a M6_EMPTY
CONNECT WM6_EMPTY_a M6_EMPTY
V5_17a {
@ At least two Vns  when either wide metal of Mn or Mn+1 with both length L>1.4um and width W>1.4um, and the distance D<=2.8um away from this wide metal.
@ Exclude non-square Vn
WM5_L1_a = ( M5 NOT WM5_a ) TOUCH WM5_a
//M5_ENCWM = (M5 INTERACT WM5_a) INTERACT V5_A_a
//WM5_VEDGE = EXT [M5_ENCWM]  <2.8 ABUT<90 OPPOSITE NOTCH
//WM5_EXT1 = EXT (WM5_a COIN EDGE WM5_VEDGE) [V5_A_a] < 2.8 ABUT>=0 <90  OPPOSITE CONNECTED 
//WM5_EXT2 = (EXT WM5_a V5_A_a < 2.8 ABUT>=0 <90  OPPOSITE REGION CONNECTED ) INSIDE M5  
V5_B = COPY V5_square 
X1 =(M5 AND M6) ENCLOSE V5_square >1
X2 = ((M5 AND M6)  AND ( WM5_L1_a AND WM5_EXP_a )) NOT X1

Y0=(M5 AND M6) ENCLOSE V5_square ==1 
Y1 = SIZE (V5_square INTERACT Y0) BY 2.8 INSIDE OF M5 STEP 0.005  
Y2= Y1 INTERACT (Y1 AND WM5_a)

VSING1= (X2 INTERACT V5_B ==1) INTERACT Y2
VSING1 OUTSIDE INST 

//M6_ENCWM = (M6 INTERACT WM6_a) INTERACT V5_A2_a
//WM6_VEDGE = EXT [M6_ENCWM]  <2.8 ABUT<90 OPPOSITE NOTCH
//WM6_EXT1 = EXT (WM6_EMPTY_a COIN EDGE WM6_VEDGE) [V5_A2_EMPTY_a] < 2.8 ABUT>=0 <90  OPPOSITE CONNECTED 
//WM6_EXT2 = (EXT WM6_EMPTY_a V5_A2_EMPTY_a < 2.8 ABUT>=0 <90  OPPOSITE REGION CONNECTED ) INSIDE M6  
V5_B2 = COPY V5_square 
X3 = ((M5 AND M6)  AND ( WM6_L1_a AND WM6_EXP_a )) NOT X1  
Y3 = SIZE (V5_square INTERACT Y0) BY 2.8 INSIDE OF M6 STEP 0.005  
Y4 = Y3 INTERACT (Y3 AND WM6_a)

VSING2= (X3 INTERACT V5_B2 ==1) INTERACT Y4
VSING2 OUTSIDE INST
}

V5_A_b = V5_square INTERACT WM5_EXP_b 

CONNECT V5_A_b M5
CONNECT WM5_b M5
//M6_fake = area M6 >0
WM6_b = (M6 WITH WIDTH > 2.1) WITH EDGE (LENGTH (M6 WITH WIDTH > 2.1) > 7)
WM6_EDGE_b = LENGTH WM6_b > 0
WM6_EXP_b = EXPAND EDGE WM6_EDGE_b OUTSIDE BY 7.1
WM6_L1_b = ( M6 NOT WM6_b ) TOUCH WM6_b
V5_A2_b = V5_square INTERACT WM6_EXP_b
V5_A2_EMPTY_b = EMPTY OR V5_A2_b
 WM6_EMPTY_b = EMPTY OR WM6_b 
CONNECT V5_A2_EMPTY_b M6_EMPTY
CONNECT WM6_EMPTY_b M6_EMPTY
V5_17b {
@ At least two Vns  when either wide metal of Mn or Mn+1 with both length L>7um and width W>2.1um, and the distance D<=7.1um away from this wide metal.
@ Exclude non-square Vn
WM5_L1_b = ( M5 NOT WM5_b ) TOUCH WM5_b
//M5_ENCWM = (M5 INTERACT WM5_b) INTERACT V5_A_b
//WM5_VEDGE = EXT [M5_ENCWM]  <7.1 ABUT<90 OPPOSITE NOTCH
//WM5_EXT1 = EXT (WM5_b COIN EDGE WM5_VEDGE) [V5_A_b] < 7.1 ABUT>=0 <90  OPPOSITE CONNECTED 
//WM5_EXT2 = (EXT WM5_b V5_A_b < 7.1 ABUT>=0 <90  OPPOSITE REGION CONNECTED ) INSIDE M5
V5_B = COPY V5_square 
X1 =(M5 AND M6) ENCLOSE V5_square >1
X2 = ((M5 AND M6)  AND ( WM5_L1_b AND WM5_EXP_b )) NOT X1

Y0=(M5 AND M6) ENCLOSE V5_square ==1 
Y1 = SIZE (V5_square INTERACT Y0) BY 7.1 INSIDE OF M5 STEP 0.005  
Y2= Y1 INTERACT (Y1 AND WM5_b)

VSING1= (X2 INTERACT V5_B ==1) INTERACT Y2
VSING1 OUTSIDE INST 

//M6_ENCWM = (M6 INTERACT WM6_b) INTERACT V5_A2_b
//WM6_VEDGE = EXT [M6_ENCWM]  <7.1 ABUT<90 OPPOSITE NOTCH
//WM6_EXT1 = EXT (WM6_EMPTY_b COIN EDGE WM6_VEDGE) [V5_A2_EMPTY_b] < 7.1 ABUT>=0 <90  OPPOSITE CONNECTED 
//WM6_EXT2 = (EXT WM6_EMPTY_b V5_A2_EMPTY_b < 7.1 ABUT>=0 <90  OPPOSITE REGION CONNECTED ) INSIDE M6
V5_B2 = COPY V5_square 
X3 = ((M5 AND M6)  AND ( WM6_L1_b AND WM6_EXP_b )) NOT X1  
Y3 = SIZE (V5_square INTERACT Y0) BY 7.1 INSIDE OF M6 STEP 0.005  
Y4 = Y3 INTERACT (Y3 AND WM6_b)

VSING2= (X3 INTERACT V5_B2 ==1) INTERACT Y4
VSING2 OUTSIDE INST
}

V5_18 {
@ 45-degree rotated V5 is not allowed.
  (ANGLE V5_all >= 44.9 <= 45.1) NOT INSIDE EDGE MARKS
}
V5_19 {
    @ Single V5 is not allowed in "H-shape" M6 when:
    @ 1. The M6 has "H-shape" interact with two metal holes: both two metal holes length <= 4.5um(L2) and two metal hole area <= 4.5um2.
    @ 2. The V5 overlaps on the center metal bar of this "H-shape" M6.
    @ 3. The center metal bar length <= 1um(L) and the metal bar width <= 0.2um.
    X0 = AREA (HOLES M6 INNER) <= 4.5
    X1 = (X0 NOT ENCLOSE RECTANGLE 1+0.001 4.5) NOT ENCLOSE RECTANGLE 1 4.5+0.001
    Y = M6 COIN EDGE X1
    Z = INT Y <= 0.2 OPPOSITE REGION
    H = V5 NOT OUTSIDE (Z INTERACT X1 == 2)
//    (Z INTERACT H == 1) NOT MARKS
    ERR = ((M5 AND M6) INTERACT H) NOT INTERACT (V5 NOT H) 
    ((Z INTERACT H == 1) INTERACT ERR) NOT MARKS
}
V5_20 {
@ V5 connected to M6DUM, M5DUM is not allowed.
@ This rule is not applied for LOGO covered region.
  (V5 INTERACT (M6DUM OR M5DUM)) NOT LOGO
}
V5_21 {
@ V5 must be fully covered by M5 and M6.
  V5_all NOT (M5_all AND M6_all)
}
V5_22_R_OFF {
@ Insert one V5 if single V5 and (W5 >= 5W6, or W6 >= 5W5) at enclosure.
 CMACRO DFM4 M5 M6 V5
}
V5_23_R_OFF {
@ At least two vias (Vn, TV1, TV2, n=1~7) in Mn and Mn+1 (M1, Mn, n=2~8, TM1, TM2) intersection area. 
@ (This rule is not applicable for SRAM region, 
@ but SRAM region should follow main rule: V1.17, Vn.17, TV1.13, TV2.13, TV2.14)
  V5_INTER= V5 INSIDE (M5 AND M6) 
  X = (M5 AND M6) INTERACT V5_INTER  <2
  X OUTSIDE INST
}
V5_24 {
@ It?s not allowed V5 overlap with M5 and M6 resistor.
  V5 AND (M5 AND M5R)
  V5 AND (M6 AND M6R)
}
#ENDIF

#IFDEF V6_CHECK YES
//========================
//  V6 - Via 6 DRC
//========================

GROUP GV6 V6_?

V6_1 {
@ Fixed V6 size is 0.07
  NOT RECTANGLE V6 == 0.07 BY == 0.07
}
V6_2 {
@ Space between two V6 is 0.07
  EXT V6_all < 0.07 ABUT<90 SINGULAR REGION
}
V6_array = SIZE (SIZE V6 BY 0.05 OVERUNDER) BY 0.150 UNDEROVER
V6_GAP6 = V6_array NOT M6
V6_GAP7 = V6_array NOT M7
V6_3 {
@Space between Vns (with run length>=0) at least two least two sides is 0.09, when array equal to or greater than 3x3. 
@Two Via areas whose space is within 0.10um are considered to be in the same array. An array does
@ not have both row and column greater than or equal to 3 can apply smaller spacing Vn.2 instead of Vn.3
 X = EXT (V6 INTERACT V6_array) V6< 0.090 OPPOSITE EXTENDED  0.001  REGION 
   Y =SIZE V6 BY 0.001
  (Y INTERACT  V6_array)  INTERACT (X NOT Y) >2
}
/*
V6_4 {
@ V6_array not touching MOMDMY maximum width is 0.85
  (WITH WIDTH V6_array > 0.85) NOT INTERACT MOMDMY
}
*/
#IFDEF TOPMETAL 9
V6_5 {
@ V6 (different net) minimum space for run length > 0um is 0.1(outside of SRAM)
 X = EXT V6 < 0.1 NOT CONNECTED OPPOSITE REGION
 X OUTSIDE INST
 (EXT V6DUM < 0.1 ABUT<90 SINGULAR OPPOSITE REGION) OUTSIDE INST
 (EXT V6DUM V6 < 0.1 ABUT<90 SINGULAR OPPOSITE REGION) OUTSIDE INST
}
V6_5_R_OFF {
@ V6 (different net) minimum space for run length > 0um is 0.11(outside of SRAM)
 X = EXT V6 < 0.11 NOT CONNECTED OPPOSITE REGION
 X OUTSIDE INST 
}
V6_5a {
@ V6 (different net) minimum space is 0.09
  EXT V6 < 0.09 NOT CONNECTED REGION
  EXT V6DUM < 0.09 ABUT<90 SINGULAR REGION
  EXT V6DUM V6 < 0.09 ABUT<90 SINGULAR REGION
}
/*V6_5b {
@ Vn minimum space in different net inside of SRAM is 0.09
  EXT (V6 NOT OUTSIDE INST) < 0.09 NOT CONNECTED REGION
}*/
#ENDIF
#IFDEF TOPMETAL 8
V6_5 {
@ V6 (different net) minimum space for run length > 0um is 0.1(outside of SRAM)
 X = EXT V6 < 0.1 NOT CONNECTED OPPOSITE REGION
 X OUTSIDE INST
 (EXT V6DUM < 0.1 ABUT<90 SINGULAR OPPOSITE REGION) OUTSIDE INST
 (EXT V6DUM V6 < 0.1 ABUT<90 SINGULAR OPPOSITE REGION) OUTSIDE INST
}
V6_5_R_OFF {
@ V6 (different net) minimum space for run length > 0um is 0.11(outside of SRAM)
 X = EXT V6 < 0.11 NOT CONNECTED OPPOSITE REGION
 X OUTSIDE INST 
}
V6_5a {
@ V6 (different net) minimum space is 0.09
  EXT V6 < 0.09 NOT CONNECTED REGION
  EXT V6DUM < 0.09 ABUT<90 SINGULAR REGION
  EXT V6DUM V6 < 0.09 ABUT<90 SINGULAR REGION
}
/*V6_5b {
@ Vn minimum space in different net inside of SRAM is 0.09
  EXT (V6 NOT OUTSIDE INST) < 0.09 NOT CONNECTED REGION
}*/
#ENDIF
V6_6abc {
@ V2 must within M2
@  per Mn and Mn+1 intersection containing a Vn, must meet rule Vn.6a, Vn.6b or Vn.6c
@ V2.6a, V2 minimum within M2 is 0.015
@ Vn.6b	Mn overlap past Vn for two opposite sides with either side  >=0.01um, and < 0.015um  0.02
@ Vn.6c	Mn overlap past Vn for two opposite sides with either side >= 0um, and < 0.01um 0.03
  V6_all NOT M6_all
  M6andM7 = (M6_all AND M7_all) INTERACT V6_all
  BadV6 = RECTANGLE ENCLOSURE V6_all M6_all OUTSIDE ALSO
  GOOD 0.015 OPPOSITE 0.015 OPPOSITE  0.015 OPPOSITE 0.015 OPPOSITE
  GOOD 0.02 OPPOSITE 0.01 OPPOSITE 0.02 OPPOSITE 0.01 OPPOSITE
  GOOD 0.03 0.0  0.03 0.0
  BadV6 INTERACT M6andM7
}
/*V6_6d {
@ Vn touching Mn with width > 0.14um, with at least one redundant Vn.
@ This rule only applies to that M6/M7 intersection area can enclose a rectangle of 0.07*0.27.
 CMACRO V67D V6 M6 M7
}*/
V6_7abc {
@ V2 must within M3
@  per Mn and Mn+1 intersection containing a Vn, must meet rule Vn.7a, Vn.7b or Vn.7c
@ V6.7a, V2 minimum within M3 is 0.015
@ V6.7b, M3 minimum overlap past V2 for two opposite sides with either side >=0.01um, and < 0.015um  is 0.02
@ V6.7c, M3 minimum overlap past V2 for two opposite sides with the either side >=0um, and < 0.01um is 0.03
  V6_all NOT M7_all
  M6andM7 = (M6_all AND M7_all) INTERACT V6_all
  BadV6 = RECTANGLE ENCLOSURE V6_all M7_all  OUTSIDE ALSO
  GOOD 0.015 OPPOSITE 0.015 OPPOSITE  0.015 OPPOSITE 0.015 OPPOSITE
  GOOD 0.02 OPPOSITE 0.01 OPPOSITE 0.02 OPPOSITE 0.01 OPPOSITE
  GOOD 0.03 0.0  0.03 0.0 
  BadV6 INTERACT M6andM7
}
/*V6_7d {
@ Vn+1 touching Mn with width > 0.14um, with at least one redundant Vn.
@ This rule only applies to that M6/M7 intersection area can enclose a rectangle of 0.07*0.27.
 CMACRO V67D V6 M7 M6
}*/
V6_8 {
@ At least two Vn vias must connect Mn to Mn+1 when the Mn or Mn+1 width is > 0.26um
  WM6 = WITH WIDTH M6 > 0.260
  WM7 = WITH WIDTH M7 > 0.260
  encVia = V6 INTERACT (WM6 OR WM7)
  ((M6 AND M7) ENCLOSE encVia) ENCLOSE V6 < 2
}
V6_9 {
@ At least three Vn vias must connect Mn to Mn+1 when the Mn or Mn+1 width is > 0.55um
  WM6 = WITH WIDTH M6 > 0.550
  WM7 = WITH WIDTH M7 > 0.550
  encVia = V6 INTERACT (WM6 OR WM7)
  ((M6 AND M7) ENCLOSE encVia) ENCLOSE V6 < 3
}
V6_10 {
@ At least four Vn vias must connect Mn to Mn+1 when the Mn or Mn+1 width is > 0.645um
  WM6 = WITH WIDTH M6 > 0.645
  WM7 = WITH WIDTH M7 > 0.645
  encVia = V6 INTERACT (WM6 OR WM7)
  ((M6 AND M7) ENCLOSE encVia) ENCLOSE V6 < 4
}
V6_square = RECTANGLE V6 ASPECT ==1
V6_EMPTY =EMPTY OR  (V6_square INSIDE (M6 AND M7) ) 
INTER_EMPTY6 =EMPTY OR (M6 AND M7)
CONNECT  V6_EMPTY INTER_EMPTY6

V6_16 {
@At least two Vns with space <=0.16um when one of Mn or Mn+1 with both length and width >0.24um.
@Exclude non-square Vn and SRAM area.
X1a = WITH WIDTH M6  >0.24
X1b = WITH WIDTH M7  >0.24
WIDE = X1a OR X1b
X2 = (M7 AND M6) ENCLOSE V6_square
X3 =  V6_square INSIDE X2
X5c = EXT (V6_EMPTY INSIDE WIDE ) V6_EMPTY<=0.16 ABUT<90 REGION CONNECTED // space of via <= 0.16 
X6c = X2 ENCLOSE X5c  // good intersection with space of Via <= 0.16
X7= ((SIZE X3 BY 0.325) AND X2) ENCLOSE V6 >2
X7c=X2 ENCLOSE X7
X =((X2 NOT X6c) NOT X7c) ENCLOSE (V6_square INSIDE  WIDE ) // Via_16
X OUTSIDE INST
}
//WM6 = M6 WITH WIDTH > 0.24
CONNECT V6 M6
V6_A = V6_square INTERACT WM6_EXP
CONNECT V6_A M6
CONNECT WM6 M6
WM7 = M7 WITH WIDTH > 0.24
WM7_EDGE = LENGTH WM7 > 0
WM7_EXP = EXPAND EDGE WM7_EDGE OUTSIDE BY 1.1
WM7_L1 = ( M7 NOT WM7 ) TOUCH WM7
V6_A2 = V6_square INTERACT WM7_EXP
CONNECT V6 M7
V6_A2_EMPTY = EMPTY OR V6_A2
M7_EMPTY = EMPTY OR M7
 WM7_EMPTY = EMPTY OR WM7 
CONNECT V6_A2_EMPTY M7_EMPTY
CONNECT WM7_EMPTY M7_EMPTY

V6_17 {
@ At least two Vns when either wide metal of Mn or Mn+1 with both length L>0.24um and width W>0.24um, and the distance D<=1.1um away from this wide metal.
@ Exclude non-square Vn
WM6_L1 = ( M6 NOT WM6 ) TOUCH WM6
M6_ENCWM = (M6 INTERACT WM6) INTERACT V6_A
WM6_VEDGE = EXT [M6_ENCWM]  <1.1 ABUT<90 OPPOSITE NOTCH
WM6_EXT1 = EXT (WM6 COIN EDGE WM6_VEDGE) [V6_A] < 1.1 ABUT>=0 <90  OPPOSITE CONNECTED 
WM6_EXT2 = (EXT WM6 V6_A < 1.1 ABUT>=0 <90  OPPOSITE REGION CONNECTED ) INSIDE M6  
V6_B = V6_square WITH EDGE WM6_EXT1
X1 =(M6 AND M7) ENCLOSE V6_square >1
X2 = ((M6 AND M7)  AND ( WM6_L1 AND WM6_EXP )) NOT X1  
Y0=(M6 AND M7) ENCLOSE V6_square ==1 
Y1 = SIZE (V6_square INTERACT Y0) BY 1.1 INSIDE OF M6 STEP 0.005  
Y2= Y1 INTERACT (Y1 AND WM6)

VSING1= ((X2 INTERACT V6_B ==1) INTERACT Y2) OR ((X2 INTERACT WM6_EXT2) INTERACT V6_A)
VSING1 OUTSIDE INST 

M7_ENCWM = (M7 INTERACT WM7) INTERACT V6_A2
WM7_VEDGE = EXT [M7_ENCWM]  <1.1 ABUT<90 OPPOSITE NOTCH
WM7_EXT1 = EXT (WM7_EMPTY COIN EDGE WM7_VEDGE) [V6_A2_EMPTY] < 1.1 ABUT>=0 <90  OPPOSITE CONNECTED 
WM7_EXT2 = (EXT WM7_EMPTY V6_A2_EMPTY < 1.1 ABUT>=0 <90  OPPOSITE REGION CONNECTED ) INSIDE M7  
V6_B2 = V6_square WITH EDGE WM7_EXT1
X3 = ((M6 AND M7)  AND ( WM7_L1 AND WM7_EXP )) NOT X1  
Y3 = SIZE (V6_square INTERACT Y0) BY 1.1 INSIDE OF M7 STEP 0.005  
Y4= Y3 INTERACT (Y3 AND WM7)

VSING2=((X3 INTERACT V6_B2 ==1) INTERACT Y4) OR (( X3 INTERACT WM7_EXT2) INTERACT V6_A2)
VSING2 OUTSIDE INST
}

V6_A_a = V6_square INTERACT WM6_EXP_a 

CONNECT V6_A_a M6
CONNECT WM6_a M6
//M7_fake = area M7 >0
WM7_a = M7 WITH WIDTH > 1.4
WM7_EDGE_a = LENGTH WM7_a > 0
WM7_EXP_a = EXPAND EDGE WM7_EDGE_a OUTSIDE BY 2.8
WM7_L1_a = ( M7 NOT WM7_a ) TOUCH WM7_a
V6_A2_a = V6_square INTERACT WM7_EXP_a
V6_A2_EMPTY_a = EMPTY OR V6_A2_a
 WM7_EMPTY_a = EMPTY OR WM7_a 
CONNECT V6_A2_EMPTY_a M7_EMPTY
CONNECT WM7_EMPTY_a M7_EMPTY
V6_17a {
@ At least two Vns  when either wide metal of Mn or Mn+1 with both length L>1.4um and width W>1.4um, and the distance D<=2.8um away from this wide metal.
@ Exclude non-square Vn
WM6_L1_a = ( M6 NOT WM6_a ) TOUCH WM6_a
//M6_ENCWM = (M6 INTERACT WM6_a) INTERACT V6_A_a
//WM6_VEDGE = EXT [M6_ENCWM]  <2.8 ABUT<90 OPPOSITE NOTCH
//WM6_EXT1 = EXT (WM6_a COIN EDGE WM6_VEDGE) [V6_A_a] < 2.8 ABUT>=0 <90  OPPOSITE CONNECTED 
//WM6_EXT2 = (EXT WM6_a V6_A_a < 2.8 ABUT>=0 <90  OPPOSITE REGION CONNECTED ) INSIDE M6
V6_B = COPY V6_square 
X1 =(M6 AND M7) ENCLOSE V6_square >1
X2 = ((M6 AND M7)  AND ( WM6_L1_a AND WM6_EXP_a )) NOT X1

Y0=(M6 AND M7) ENCLOSE V6_square ==1 
Y1 = SIZE (V6_square INTERACT Y0) BY 2.8 INSIDE OF M6 STEP 0.005  
Y2= Y1 INTERACT (Y1 AND WM6_a)

VSING1= (X2 INTERACT V6_B ==1) INTERACT Y2
VSING1 OUTSIDE INST 

//M7_ENCWM = (M7 INTERACT WM7_a) INTERACT V6_A2_a
//WM7_VEDGE = EXT [M7_ENCWM]  <2.8 ABUT<90 OPPOSITE NOTCH
//WM7_EXT1 = EXT (WM7_EMPTY_a COIN EDGE WM7_VEDGE) [V6_A2_EMPTY_a] < 2.8 ABUT>=0 <90  OPPOSITE CONNECTED 
//WM7_EXT2 = (EXT WM7_EMPTY_a V6_A2_EMPTY_a < 2.8 ABUT>=0 <90  OPPOSITE REGION CONNECTED ) INSIDE M7  
V6_B2 = COPY V6_square 
X3 = ((M6 AND M7)  AND ( WM7_L1_a AND WM7_EXP_a )) NOT X1  
Y3 = SIZE (V6_square INTERACT Y0) BY 2.8 INSIDE OF M7 STEP 0.005  
Y4 = Y3 INTERACT (Y3 AND WM7_a)

VSING2= (X3 INTERACT V6_B2 ==1) INTERACT Y4
VSING2 OUTSIDE INST
}

V6_A_b = V6_square INTERACT WM6_EXP_b 

CONNECT V6_A_b M6
CONNECT WM6_b M6
//M7_fake = area M7 >0
WM7_b = (M7 WITH WIDTH > 2.1) WITH EDGE (LENGTH (M7 WITH WIDTH > 2.1) > 7)
WM7_EDGE_b = LENGTH WM7_b > 0
WM7_EXP_b = EXPAND EDGE WM7_EDGE_b OUTSIDE BY 7.1
WM7_L1_b = ( M7 NOT WM7_b ) TOUCH WM7_b
V6_A2_b = V6_square INTERACT WM7_EXP_b
V6_A2_EMPTY_b = EMPTY OR V6_A2_b
 WM7_EMPTY_b = EMPTY OR WM7_b 
CONNECT V6_A2_EMPTY_b M7_EMPTY
CONNECT WM7_EMPTY_b M7_EMPTY
V6_17b {
@ At least two Vns  when either wide metal of Mn or Mn+1 with both length L>7um and width W>2.1um, and the distance D<=7.1um away from this wide metal.
@ Exclude non-square Vn
WM6_L1_b = ( M6 NOT WM6_b ) TOUCH WM6_b
//M6_ENCWM = (M6 INTERACT WM6_b) INTERACT V6_A_b
//WM6_VEDGE = EXT [M6_ENCWM]  <7.1 ABUT<90 OPPOSITE NOTCH
//WM6_EXT1 = EXT (WM6_b COIN EDGE WM6_VEDGE) [V6_A_b] < 7.1 ABUT>=0 <90  OPPOSITE CONNECTED 
//WM6_EXT2 = (EXT WM6_b V6_A_b < 7.1 ABUT>=0 <90  OPPOSITE REGION CONNECTED ) INSIDE M6
V6_B = COPY V6_square 
X1 =(M6 AND M7) ENCLOSE V6_square >1
X2 = ((M6 AND M7)  AND ( WM6_L1_b AND WM6_EXP_b )) NOT X1

Y0=(M6 AND M7) ENCLOSE V6_square ==1 
Y1 = SIZE (V6_square INTERACT Y0) BY 7.1 INSIDE OF M6 STEP 0.005  
Y2= Y1 INTERACT (Y1 AND WM6_b)

VSING1= (X2 INTERACT V6_B ==1) INTERACT Y2
VSING1 OUTSIDE INST 

//M7_ENCWM = (M7 INTERACT WM7_b) INTERACT V6_A2_b
//WM7_VEDGE = EXT [M7_ENCWM]  <7.1 ABUT<90 OPPOSITE NOTCH
//WM7_EXT1 = EXT (WM7_EMPTY_b COIN EDGE WM7_VEDGE) [V6_A2_EMPTY_b] < 7.1 ABUT>=0 <90  OPPOSITE CONNECTED 
//WM7_EXT2 = (EXT WM7_EMPTY_b V6_A2_EMPTY_b < 7.1 ABUT>=0 <90  OPPOSITE REGION CONNECTED ) INSIDE M7
V6_B2 = COPY V6_square 
X3 = ((M6 AND M7)  AND ( WM7_L1_b AND WM7_EXP_b )) NOT X1  
Y3 = SIZE (V6_square INTERACT Y0) BY 7.1 INSIDE OF M7 STEP 0.005  
Y4 = Y3 INTERACT (Y3 AND WM7_b)

VSING2= (X3 INTERACT V6_B2 ==1) INTERACT Y4
VSING2 OUTSIDE INST
}

V6_18 {
@ 45-degree rotated V6 is not allowed.
  (ANGLE V6_all >= 44.9 <= 45.1) NOT INSIDE EDGE MARKS
}
V6_19 {
    @ Single V6 is not allowed in "H-shape" M7 when:
    @ 1. The M7 has "H-shape" interact with two metal holes: both two metal holes length <= 4.5um(L2) and two metal hole area <= 4.5um2.
    @ 2. The V6 overlaps on the center metal bar of this "H-shape" M7.
    @ 3. The center metal bar length <= 1um(L) and the metal bar width <= 0.2um.
    X0 = AREA (HOLES M7 INNER) <= 4.5
    X1 = (X0 NOT ENCLOSE RECTANGLE 1+0.001 4.5) NOT ENCLOSE RECTANGLE 1 4.5+0.001
    Y = M7 COIN EDGE X1
    Z = INT Y <= 0.2 OPPOSITE REGION
    H = V6 NOT OUTSIDE (Z INTERACT X1 == 2)
//    (Z INTERACT H == 1) NOT MARKS
    ERR = ((M6 AND M7) INTERACT H) NOT INTERACT (V6 NOT H) 
    ((Z INTERACT H == 1) INTERACT ERR) NOT MARKS
}
V6_20 {
@ V6 connected to M7DUM, M6DUM is not allowed.
@ This rule is not applied for LOGO covered region.
  (V6 INTERACT (M7DUM OR M6DUM)) NOT LOGO
}
V6_21 {
@ V6 must be fully covered by M6 and M7.
  V6_all NOT (M6_all AND M7_all)
}
V6_22_R_OFF {
@ Insert one V6 if single V6 and (W6 >= 5W7, or W7 >= 5W6) at enclosure.
 CMACRO DFM4 M6 M7 V6
}
V6_23_R_OFF {
@ At least two vias (Vn, TV1, TV2, n=1~7) in Mn and Mn+1 (M1, Mn, n=2~8, TM1, TM2) intersection area. 
@ (This rule is not applicable for SRAM region, 
@ but SRAM region should follow main rule: V1.17, Vn.17, TV1.13, TV2.13, TV2.14)
  V6_INTER= V6 INSIDE (M6 AND M7) 
  X = (M6 AND M7) INTERACT V6_INTER  <2
  X OUTSIDE INST
}
V6_24 {
@ It?s not allowed V6 overlap with M6 and M7 resistor.
  V6 AND (M6 AND M6R)
  V6 AND (M7 AND M7R)
}
#ENDIF

#IFDEF V7_CHECK YES
//========================
//  V7 - Via 7 DRC
//========================

GROUP GV7 V7_?

V7_1 {
@ Fixed V7 size is 0.07
  NOT RECTANGLE V7 == 0.07 BY == 0.07
}
V7_2 {
@ Space between two V7 is 0.07
  EXT V7_all < 0.07 ABUT<90 SINGULAR REGION
}
V7_array = SIZE (SIZE V7 BY 0.05 OVERUNDER) BY 0.150 UNDEROVER
V7_GAP7 = V7_array NOT M7
V7_GAP8 = V7_array NOT M8
V7_3 {
@Space between Vns (with run length>=0) at least two least two sides is 0.09, when array equal to or greater than 3x3. 
@Two Via areas whose space is within 0.10um are considered to be in the same array. An array does
@ not have both row and column greater than or equal to 3 can apply smaller spacing Vn.2 instead of Vn.3
 X = EXT (V7 INTERACT V7_array) V7< 0.090 OPPOSITE EXTENDED  0.001  REGION 
   Y =SIZE V7 BY 0.001
  (Y INTERACT  V7_array)  INTERACT (X NOT Y) >2
}
/*
V7_4 {
@ V7_array not touching MOMDMY maximum width is 0.85
  (WITH WIDTH V7_array > 0.85) NOT INTERACT MOMDMY
}
*/
#IFDEF TOPMETAL 9
V7_5 {
@ V7 (different net) minimum space for run length > 0um is 0.1 (outside of SRAM)
  X = EXT V7 < 0.1 NOT CONNECTED OPPOSITE REGION
  X OUTSIDE INST
  (EXT V7DUM < 0.1 ABUT<90 SINGULAR OPPOSITE REGION) OUTSIDE INST
  (EXT V7DUM V7 < 0.1 ABUT<90 SINGULAR OPPOSITE REGION) OUTSIDE INST 
}
V7_5_R_OFF {
@ V7 (different net) minimum space for run length > 0um is 0.11 (outside of SRAM)
 X = EXT V7 < 0.11 NOT CONNECTED OPPOSITE REGION
  X OUTSIDE INST
}
V7_5a {
@ V7 (different net) minimum space is 0.09
  EXT V7 < 0.09 NOT CONNECTED REGION
  EXT V7DUM < 0.09 ABUT<90 SINGULAR REGION
  EXT V7DUM V7 < 0.09 ABUT<90 SINGULAR REGION
}
/*V7_5b {
@ Vn minimum space in different net inside of SRAM is 0.09
  EXT (V7 NOT OUTSIDE INST) < 0.09 NOT CONNECTED REGION
}*/
#ENDIF
V7_6abc {
@ V2 must within M2
@  per Mn and Mn+1 intersection containing a Vn, must meet rule Vn.6a, Vn.6b or Vn.6c
@ V2.6a, V2 minimum within M2 is 0.015
@ Vn.6b	Mn overlap past Vn for two opposite sides with either side  >=0.01um, and < 0.015um  0.02
@ Vn.6c	Mn overlap past Vn for two opposite sides with either side >= 0um, and < 0.01um 0.03
  V7_all NOT M7_all
  M7andM8 = (M7_all AND M8_all) INTERACT V7_all
  BadV7 = RECTANGLE ENCLOSURE V7_all M7_all  OUTSIDE ALSO
  GOOD 0.015 OPPOSITE 0.015 OPPOSITE  0.015 OPPOSITE  0.015 OPPOSITE
  GOOD 0.02 OPPOSITE 0.01 OPPOSITE 0.02 OPPOSITE 0.01  OPPOSITE
  GOOD 0.03 0.0  0.03 0.0 
  BadV7 INTERACT M7andM8
}
/*V7_6d {
@ Vn inside Mn with width > 0.14um, with at least one redundant Vn.
@ This rule only applies to that M7/M8 intersection area can enclose a rectangle of 0.07*0.27.
 CMACRO V67D V7 M7 M8
}*/
V7_7abc {
@ V2 must within M3
@  per Mn and Mn+1 intersection containing a Vn, must meet rule Vn.7a, Vn.7b or Vn.7c
@ V6.7a, V2 minimum within M3 is 0.015
@ V6.7b, M3 minimum overlap past V2 for two opposite sides with either side >=0.01um, and < 0.015um  is 0.02
@ V6.7c, M3 minimum overlap past V2 for two opposite sides with the either side >=0um, and < 0.01um is 0.03
  V7_all NOT M8_all
  M7andM8 = (M7_all AND M8_all) INTERACT V7_all
  BadV7 = RECTANGLE ENCLOSURE V7_all M8_all  OUTSIDE ALSO
  GOOD 0.015 OPPOSITE 0.015 OPPOSITE  0.015 OPPOSITE 0.015 OPPOSITE
  GOOD 0.02 OPPOSITE 0.01 OPPOSITE 0.02 OPPOSITE 0.01 OPPOSITE 
  GOOD 0.03 0.0  0.03 0.0 
  BadV7 INTERACT M7andM8
}
/*V7_7d {
@ Vn inside Mn+1 with width > 0.14um, with at least one redundant Vn.
@ This rule only applies to that M7/M8 intersection area can enclose a rectangle of 0.07*0.27.
 CMACRO V67D V7 M8 M7
}*/
V7_8 {
@ At least two Vn vias must connect Mn to Mn+1 when the Mn or Mn+1 width is > 0.26um
  WM7 = WITH WIDTH M7 > 0.260
  WM8 = WITH WIDTH M8 > 0.260
  encVia = V7 INTERACT (WM7 OR WM8)
  ((M7 AND M8) ENCLOSE encVia) ENCLOSE V7 < 2
}
V7_9 {
@ At least three Vn vias must connect Mn to Mn+1 when the Mn or Mn+1 width is > 0.55um
  WM7 = WITH WIDTH M7 > 0.550
  WM8 = WITH WIDTH M8 > 0.550
  encVia = V7 INTERACT (WM7 OR WM8)
  ((M7 AND M8) ENCLOSE encVia) ENCLOSE V7 < 3
}
V7_10 {
@ At least four Vn vias must connect Mn to Mn+1 when the Mn or Mn+1 width is > 0.645um
  WM7 = WITH WIDTH M7 > 0.645
  WM8 = WITH WIDTH M8 > 0.645
  encVia = V7 INTERACT (WM7 OR WM8)
  ((M7 AND M8) ENCLOSE encVia) ENCLOSE V7 < 4
}
V7_square = RECTANGLE V7 ASPECT ==1
V7_EMPTY = EMPTY OR (V7_square INSIDE (M7 AND M8) ) 
INTER_EMPTY7 = EMPTY OR (M7 AND M8) 
CONNECT  V7_EMPTY INTER_EMPTY7
V7_16 {
@ At least two Vns with space <=0.16um when one of Mn or Mn+1 with both length and width >0.24um.
@ Exclude non-square Vn and SRAM area.
X1a = WITH WIDTH M7  >0.24
X1b = WITH WIDTH M8  >0.24
WIDE = X1a OR X1b
X2 = (M7 AND M8) ENCLOSE V7_square
X3 =  V7_square INSIDE X2
X5c = EXT (V7_EMPTY INSIDE WIDE ) V7_EMPTY <=0.16 ABUT<90 REGION CONNECTED // space of via <= 0.16 
X6c = X2 ENCLOSE X5c  // good intersection with space of Via <= 0.16
X7= ((SIZE X3 BY 0.325) AND X2) ENCLOSE V7 >2
X7c=X2 ENCLOSE X7
X =((X2 NOT X6c) NOT X7c) ENCLOSE (V7_square INSIDE WIDE ) // Via_16
X OUTSIDE INST
}
//WM7 = M7 WITH WIDTH > 0.24
CONNECT V7 M7
V7_A = V7_square INTERACT WM7_EXP
CONNECT V7_A M7
CONNECT WM7 M7
WM8 = M8 WITH WIDTH > 0.24
WM8_EDGE = LENGTH WM8 > 0
WM8_EXP = EXPAND EDGE WM8_EDGE OUTSIDE BY 1.1
WM8_L1 = ( M8 NOT WM8 ) TOUCH WM8
V7_A2 = V7_square INTERACT WM8_EXP
CONNECT V7 M8
V7_A2_EMPTY = EMPTY OR V7_A2
M8_EMPTY = EMPTY OR M8
WM8_EMPTY = EMPTY OR WM8 
CONNECT V7_A2_EMPTY M8_EMPTY
CONNECT WM8_EMPTY M8_EMPTY


V7_17 {
@ At least two Vns  when either wide metal of Mn or Mn+1 with both length L>0.24um and width W>0.24um, and the distance D<=1.1um away from this wide metal.
@ Exclude non-square Vn
WM7_L1 = ( M7 NOT WM7 ) TOUCH WM7
M7_ENCWM = (M7 INTERACT WM7) INTERACT V7_A
WM7_VEDGE = EXT [M7_ENCWM]  <1.1 ABUT<90 OPPOSITE NOTCH
WM7_EXT1 = EXT (WM7 COIN EDGE WM7_VEDGE) [V7_A] < 1.1 ABUT>=0 <90  OPPOSITE CONNECTED 
WM7_EXT2 = (EXT WM7 V7_A < 1.1 ABUT>=0 <90  OPPOSITE REGION CONNECTED ) INSIDE M7  
V7_B = V7_square WITH EDGE WM7_EXT1
X1 =(M7 AND M8) ENCLOSE V7_square >1
X2 = ((M7 AND M8)  AND ( WM7_L1 AND WM7_EXP )) NOT X1  

Y0=(M7 AND M8) ENCLOSE V7_square ==1 
Y1 = SIZE (V7_square INTERACT Y0) BY 1.1 INSIDE OF M7 STEP 0.005  
Y2= Y1 INTERACT (Y1 AND WM7)

VSING1= ((X2 INTERACT V7_B ==1) INTERACT Y2) OR ((X2 INTERACT WM7_EXT2) INTERACT V7_A)
VSING1 OUTSIDE INST 

M8_ENCWM = (M8 INTERACT WM8) INTERACT V7_A2
WM8_VEDGE = EXT [M8_ENCWM]  <1.1 ABUT<90 OPPOSITE NOTCH
WM8_EXT1 = EXT (WM8_EMPTY COIN EDGE WM8_VEDGE) [V7_A2_EMPTY] < 1.1 ABUT>=0 <90  OPPOSITE CONNECTED 
WM8_EXT2 = (EXT WM8_EMPTY V7_A2_EMPTY < 1.1 ABUT>=0 <90  OPPOSITE REGION CONNECTED ) INSIDE M8  
V7_B2 = V7_square WITH EDGE WM8_EXT1
X3 = ((M7 AND M8)  AND ( WM8_L1 AND WM8_EXP )) NOT X1  
Y3 = SIZE (V7_square INTERACT Y0) BY 1.1 INSIDE OF M8 STEP 0.005  
Y4= Y3 INTERACT (Y3 AND WM8)

VSING2= ((X3 INTERACT V7_B2 ==1) INTERACT Y4) OR (( X3 INTERACT WM8_EXT2) INTERACT V7_A2)
VSING2 OUTSIDE INST
}

V7_A_a = V7_square INTERACT WM7_EXP_a 

CONNECT V7_A_a M7
CONNECT WM7_a M7
//M8_fake = area M8 >0
WM8_a = M8 WITH WIDTH > 1.4
WM8_EDGE_a = LENGTH WM8_a > 0
WM8_EXP_a = EXPAND EDGE WM8_EDGE_a OUTSIDE BY 2.8
WM8_L1_a = ( M8 NOT WM8_a ) TOUCH WM8_a
V7_A2_a = V7_square INTERACT WM8_EXP_a
V7_A2_EMPTY_a = EMPTY OR V7_A2_a
 WM8_EMPTY_a = EMPTY OR WM8_a 
CONNECT V7_A2_EMPTY_a M8_EMPTY
CONNECT WM8_EMPTY_a M8_EMPTY
V7_17a {
@ At least two Vns  when either wide metal of Mn or Mn+1 with both length L>1.4um and width W>1.4um, and the distance D<=2.8um away from this wide metal.
@ Exclude non-square Vn
WM7_L1_a = ( M7 NOT WM7_a ) TOUCH WM7_a
//M7_ENCWM = (M7 INTERACT WM7_a) INTERACT V7_A_a
//WM7_VEDGE = EXT [M7_ENCWM]  <2.8 ABUT<90 OPPOSITE NOTCH
//WM7_EXT1 = EXT (WM7_a COIN EDGE WM7_VEDGE) [V7_A_a] < 2.8 ABUT>=0 <90  OPPOSITE CONNECTED 
//WM7_EXT2 = (EXT WM7_a V7_A_a < 2.8 ABUT>=0 <90  OPPOSITE REGION CONNECTED ) INSIDE M7
V7_B = COPY V7_square 
X1 =(M7 AND M8) ENCLOSE V7_square >1
X2 = ((M7 AND M8)  AND ( WM7_L1_a AND WM7_EXP_a )) NOT X1

Y0=(M7 AND M8) ENCLOSE V7_square ==1 
Y1 = SIZE (V7_square INTERACT Y0) BY 2.8 INSIDE OF M7 STEP 0.005  
Y2= Y1 INTERACT (Y1 AND WM7_a)

VSING1= (X2 INTERACT V7_B ==1) INTERACT Y2
VSING1 OUTSIDE INST 

//M8_ENCWM = (M8 INTERACT WM8_a) INTERACT V7_A2_a
//WM8_VEDGE = EXT [M8_ENCWM]  <2.8 ABUT<90 OPPOSITE NOTCH
//WM8_EXT1 = EXT (WM8_EMPTY_a COIN EDGE WM8_VEDGE) [V7_A2_EMPTY_a] < 2.8 ABUT>=0 <90  OPPOSITE CONNECTED 
//WM8_EXT2 = (EXT WM8_EMPTY_a V7_A2_EMPTY_a < 2.8 ABUT>=0 <90  OPPOSITE REGION CONNECTED ) INSIDE M8 
V7_B2 = COPY V7_square 
X3 = ((M7 AND M8)  AND ( WM8_L1_a AND WM8_EXP_a )) NOT X1  
Y3 = SIZE (V7_square INTERACT Y0) BY 2.8 INSIDE OF M8 STEP 0.005  
Y4 = Y3 INTERACT (Y3 AND WM8_a)

VSING2= (X3 INTERACT V7_B2 ==1) INTERACT Y4
VSING2 OUTSIDE INST
}

V7_A_b = V7_square INTERACT WM7_EXP_b 

CONNECT V7_A_b M7
CONNECT WM7_b M7
//M8_fake = area M8 >0
WM8_b = (M8 WITH WIDTH > 2.1) WITH EDGE (LENGTH (M8 WITH WIDTH > 2.1) > 7)
WM8_EDGE_b = LENGTH WM8_b > 0
WM8_EXP_b = EXPAND EDGE WM8_EDGE_b OUTSIDE BY 7.1
WM8_L1_b = ( M8 NOT WM8_b ) TOUCH WM8_b
V7_A2_b = V7_square INTERACT WM8_EXP_b
V7_A2_EMPTY_b = EMPTY OR V7_A2_b
 WM8_EMPTY_b = EMPTY OR WM8_b 
CONNECT V7_A2_EMPTY_b M8_EMPTY
CONNECT WM8_EMPTY_b M8_EMPTY
V7_17b {
@ At least two Vns  when either wide metal of Mn or Mn+1 with both length L>7um and width W>2.1um, and the distance D<=7.1um away from this wide metal.
@ Exclude non-square Vn
WM7_L1_b = ( M7 NOT WM7_b ) TOUCH WM7_b
//M7_ENCWM = (M7 INTERACT WM7_b) INTERACT V7_A_b
//WM7_VEDGE = EXT [M7_ENCWM]  <7.1 ABUT<90 OPPOSITE NOTCH
//WM7_EXT1 = EXT (WM7_b COIN EDGE WM7_VEDGE) [V7_A_b] < 7.1 ABUT>=0 <90  OPPOSITE CONNECTED 
//WM7_EXT2 = (EXT WM7_b V7_A_b < 7.1 ABUT>=0 <90  OPPOSITE REGION CONNECTED ) INSIDE M7
V7_B = COPY V7_square 
X1 =(M7 AND M8) ENCLOSE V7_square >1
X2 = ((M7 AND M8)  AND ( WM7_L1_b AND WM7_EXP_b )) NOT X1

Y0=(M7 AND M8) ENCLOSE V7_square ==1 
Y1 = SIZE (V7_square INTERACT Y0) BY 7.1 INSIDE OF M7 STEP 0.005  
Y2= Y1 INTERACT (Y1 AND WM7_b)

VSING1= (X2 INTERACT V7_B ==1) INTERACT Y2
VSING1 OUTSIDE INST 

//M8_ENCWM = (M8 INTERACT WM8_b) INTERACT V7_A2_b
//WM8_VEDGE = EXT [M8_ENCWM]  <7.1 ABUT<90 OPPOSITE NOTCH
//WM8_EXT1 = EXT (WM8_EMPTY_b COIN EDGE WM8_VEDGE) [V7_A2_EMPTY_b] < 7.1 ABUT>=0 <90  OPPOSITE CONNECTED 
//WM8_EXT2 = (EXT WM8_EMPTY_b V7_A2_EMPTY_b < 7.1 ABUT>=0 <90  OPPOSITE REGION CONNECTED ) INSIDE M8
V7_B2 = COPY V7_square 
X3 = ((M7 AND M8)  AND ( WM8_L1_b AND WM8_EXP_b )) NOT X1  
Y3 = SIZE (V7_square INTERACT Y0) BY 7.1 INSIDE OF M8 STEP 0.005  
Y4 = Y3 INTERACT (Y3 AND WM8_b)

VSING2= (X3 INTERACT V7_B2 ==1) INTERACT Y4
VSING2 OUTSIDE INST
}

V7_18 {
@ 45-degree rotated V7 is not allowed.
  (ANGLE V7_all >= 44.9 <= 45.1) NOT INSIDE EDGE MARKS
}
V7_19 {
    @ Single V7 is not allowed in "H-shape" M8 when:
    @ 1. The M8 has "H-shape" interact with two metal holes: both two metal holes length <= 4.5um(L2) and two metal hole area <= 4.5um2.
    @ 2. The V7 overlaps on the center metal bar of this "H-shape" M8.
    @ 3. The center metal bar length <= 1um(L) and the metal bar width <= 0.2um.
    X0 = AREA (HOLES M8 INNER) <= 4.5
    X1 = (X0 NOT ENCLOSE RECTANGLE 1+0.001 4.5) NOT ENCLOSE RECTANGLE 1 4.5+0.001
    Y = M8 COIN EDGE X1
    Z = INT Y <= 0.2 OPPOSITE REGION
    H = V7 NOT OUTSIDE (Z INTERACT X1 == 2)
//    (Z INTERACT H == 1) NOT MARKS
    ERR = ((M7 AND M8) INTERACT H) NOT INTERACT (V7 NOT H) 
    ((Z INTERACT H == 1) INTERACT ERR) NOT MARKS
}
V7_20 {
@ V7 connected to M8DUM, M7DUM is not allowed.
@ This rule is not applied for LOGO covered region.
  (V7 INTERACT (M8DUM OR M7DUM)) NOT LOGO
}
V7_21 {
@ V7 must be fully covered by M7 and M8.
  V7_all NOT (M7_all AND M8_all)
}
V7_22_R_OFF {
@ Insert one V7 if single V7 and (W7 >= 5W8, or W8 >= 5W7) at enclosure.
 CMACRO DFM4 M7 M8 V7
}
V7_23_R_OFF {
@ At least two vias (Vn, TV1, TV2, n=1~7) in Mn and Mn+1 (M1, Mn, n=2~8, TM1, TM2) intersection area. 
@ (This rule is not applicable for SRAM region, 
@ but SRAM region should follow main rule: V1.17, Vn.17, TV1.13, TV2.13, TV2.14)
  V7_INTER= V7 INSIDE (M7 AND M8) 
  X = (M7 AND M8) INTERACT V7_INTER  <2
  X OUTSIDE INST
}
V7_24 {
@ It?s not allowed V7 overlap with M7 and M8 resistor.
  V7 AND (M7 AND M7R)
  V7 AND (M8 AND M8R)
}
#ENDIF

//========================
//  TV2 - Top Via 2 DRC
//========================

GROUP GTV2 TV2_?

TV2_1 {
@ Fixed TV2 size is 0.36
  NOT RECTANGLE TV2 == 0.36 BY == 0.36
}
TV2_2 {
@ Space between two TV2 is 0.34
  EXT TV2 < 0.34 ABUT<90 SINGULAR REGION
}
TV2_3 {
@ Space between two TV2s is 0.50, in case TV2 array is larger than or equal to 3x3.
@ Two Via areas whose space is within 0.56um are considered to be in the same array.
  TV2array = SIZE (SIZE TV2 BY 0.28 OVERUNDER) BY 0.85 UNDEROVER
  EXT (TV2 IN TV2array) < 0.50 ABUT<90 SINGULAR REGION
}
#IFDEF TOPMETAL 9
TV2_4_5 {
@ TV2 enclosure by Mn is >= 0.01um.
@ TV2 enclosure by Mn at least two opposite sides is >= 0.05
@ Mn is the metal layer directly underneath TV2.
  RECTANGLE ENC TV2 M8 ABUT<90 OUTSIDE ALSO
  GOOD 0.01 OPPOSITE 0.05 OPPOSITE 0.01 OPPOSITE 0.05 OPPOSITE
}
TV2_13_14{
@ At least 2 TV2 within M8 and TM2 intersection area.  One of the M8 and TM2 width > 1.8 um. 
X1 = M8 WITH WIDTH >1.8
X2 = TM2 WITH WIDTH >1.8
Y1 = (M8 AND TM2) INTERACT X1
Y2 = (M8 AND TM2) INTERACT X2
(Y1 OR Y2) INTERACT TV2 < 2
}
TV2_17 {
@ TV2 connected to M8DUM, TM2DUM is not allowed.
@ This rule is not applied for LOGO covered region.
  (TV2 INTERACT ((M8DUM OR TM2DUM) OR MTT2DM)) NOT LOGO
}
TV2_18 {
@ TV2 must be fully covered by M8 and TM2.
  TV2 NOT (M8 AND TM)
}
#ENDIF
#IFDEF TOPMETAL 8
TV2_4_5 {
@ TV2 enclosure by Mn is 0.01um.
@ TV2 enclosure by Mn at least two opposite sides is >= 0.05um.
@ Mn is the metal layer directly underneath TV2.
  RECTANGLE ENC TV2 M7 ABUT<90 OUTSIDE ALSO
  GOOD 0.01 OPPOSITE 0.05 OPPOSITE 0.01 OPPOSITE 0.05 OPPOSITE
}
TV2_13_14 {
@ At least 2 TV2 within M7 and TM2 intersection area.  One of the M7 and TM2 width > 1.8 um. 
X1 = M7 WITH WIDTH >1.8
X2 = TM2 WITH WIDTH >1.8
Y1 = (M7 AND TM2) INTERACT X1
Y2 = (M7 AND TM2) INTERACT X2
(Y1 OR Y2) INTERACT TV2 < 2
}
TV2_17 {
@ TV2 connected to M7DUM, TM2DUM is not allowed.
@ This rule is not applied for LOGO covered region.
  (TV2 INTERACT ((M7DUM OR TM2DUM) OR MTT2DM)) NOT LOGO
}
TV2_18 {
@ TV2 must be fully covered by M7 and TM2.
  TV2 NOT (M7 AND TM)
}
#ENDIF
#IFDEF TOPMETAL 7
TV2_4_5 {
@ TV2 enclosure by Mn is 0.01um.
@ TV2 enclosure by Mn at least two opposite sides is >= 0.05um.
@ Mn is the metal layer directly underneath TV2.
  RECTANGLE ENC TV2 M6 ABUT<90 OUTSIDE ALSO
  GOOD 0.01 OPPOSITE 0.05 OPPOSITE 0.01 OPPOSITE 0.05 OPPOSITE
}
TV2_13_14 {
@ At least 2 TV2 within M6 and TM2 intersection area.  One of the M6 and TM2 width > 1.8 um. 
X1 = M6 WITH WIDTH >1.8
X2 = TM2 WITH WIDTH >1.8
Y1 = (M6 AND TM2) INTERACT X1
Y2 = (M6 AND TM2) INTERACT X2
(Y1 OR Y2) INTERACT TV2 < 2
}
TV2_17 {
@ TV2 connected to M6DUM, TM2DUM is not allowed.
@ This rule is not applied for LOGO covered region.
  (TV2 INTERACT ((M6DUM OR TM2DUM) OR MTT2DM)) NOT LOGO
}
TV2_18 {
@ TV2 must be fully covered by M8 and TM2.
  TV2 NOT (M6 AND TM)
}
#ENDIF
#IFDEF TOPMETAL 6
TV2_4_5 {
@ TV2 enclosure by Mn is 0.01um.
@ TV2 enclosure by Mn at least two opposite sides is >= 0.05um.
@ Mn is the metal layer directly underneath TV2.
  RECTANGLE ENC TV2 M5 ABUT<90 OUTSIDE ALSO
  GOOD 0.01 OPPOSITE 0.05 OPPOSITE 0.01 OPPOSITE 0.05 OPPOSITE
}
TV2_13_14	{
@ At least 2 TV2 within M5 and TM2 intersection area.  One of the M5 and TM2 width > 1.8 um. 
X1 = M5 WITH WIDTH >1.8
X2 = TM2 WITH WIDTH >1.8
Y1 = (M5 AND TM2) INTERACT X1
Y2 = (M5 AND TM2) INTERACT X2
(Y1 OR Y2) INTERACT TV2 < 2
}
TV2_17 {
@ TV2 connected to M5DUM, TM2DUM is not allowed.
@ This rule is not applied for LOGO covered region.
  (TV2 INTERACT ((M5DUM OR TM2DUM) OR MTT2DM)) NOT LOGO
}
TV2_18 {
@ TV2 must be fully covered by M5 and TM2.
  TV2 NOT (M5 AND TM)
}
#ENDIF
#IFDEF TOPMETAL 5
TV2_4_5 {
@ TV2 enclosure by Mn is 0.01um.
@ TV2 enclosure by Mn at least two opposite sides is >= 0.05um.
@ Mn is the metal layer directly underneath TV2.
  RECTANGLE ENC TV2 M4 ABUT<90 OUTSIDE ALSO
  GOOD 0.01 OPPOSITE 0.05 OPPOSITE 0.01 OPPOSITE 0.05 OPPOSITE
}
TV2_13_14 {
@ At least 2 TV2 within M4 and TM2 intersection area.  One of the M4 and TM2 width > 1.8 um. 
X1 = M4 WITH WIDTH >1.8
X2 = TM2 WITH WIDTH >1.8
Y1 = (M4 AND TM2) INTERACT X1
Y2 = (TM2 AND M4) INTERACT X2
(Y1 OR Y2) INTERACT TV2 < 2
}
TV2_17 {
@ TV2 connected to M4DUM, TM2DUM is not allowed.
@ This rule is not applied for LOGO covered region.
  (TV2 INTERACT ((M4DUM OR TM2DUM) OR MTT2DM)) NOT LOGO
}
TV2_18 {
@ TV2 must be fully covered by M4 and TM2.
  TV2 NOT (M4 AND TM)
}
#ENDIF
#IFDEF TOPMETAL 4
TV2_4_5 {
@ TV2 enclosure by Mn is 0.01um.
@ TV2 enclosure by Mn at least two opposite sides is >= 0.05um.
@ Mn is the metal layer directly underneath TV2.
  RECTANGLE ENC TV2 M3 ABUT<90 OUTSIDE ALSO
  GOOD 0.01 OPPOSITE 0.05 OPPOSITE 0.01 OPPOSITE 0.05 OPPOSITE
}
TV2_13_14	{
@ At least 2 TV2 within M3 and TM2 intersection area.  One of the M3 and TM2 width > 1.8 um. 
X1 = M3 WITH WIDTH >1.8
X2 = TM2 WITH WIDTH >1.8
Y1 =( M3 AND TM2) INTERACT X1 
Y2 = ( M3 AND TM2) INTERACT X2
(Y1 OR Y2) INTERACT TV2 < 2
}
TV2_17 {
@ TV2 connected to M3DUM, TM2DUM is not allowed.
@ This rule is not applied for LOGO covered region.
  (TV2 INTERACT ((M3DUM OR TM2DUM) OR MTT2DM)) NOT LOGO
}
TV2_18 {
@ TV2 must be fully covered by M3 and TM2.
  TV2 NOT (M3 AND TM)
}
#ENDIF

TV2_square = RECTANGLE TV2 ASPECT ==1
WUTM_b = (UTM WITH WIDTH > 3) WITH EDGE (LENGTH (UTM WITH WIDTH > 3) > 10)
WUTM_EDGE_b = LENGTH WUTM_b > 0
WUTM_EXP_b = EXPAND EDGE WUTM_EDGE_b OUTSIDE BY 5
TV2_A_b = TV2_square INTERACT WUTM_EXP_b
CONNECT TV2_A_b UTM
CONNECT WUTM_b UTM

WTM2_b = (TM2 WITH WIDTH > 3) WITH EDGE (LENGTH (TM2 WITH WIDTH > 3) > 10)
WTM2_EDGE_b = LENGTH WTM2_b > 0
WTM2_EXP_b = EXPAND EDGE WTM2_EDGE_b OUTSIDE BY 5
WTM2_L1_b = ( TM2 not WTM2_b ) TOUCH WTM2_b
TV2_A2_b = TV2_square INTERACT WTM2_EXP_b

TM2_EMPTY = EMPTY OR TM2
TV2_A2_EMPTY_b = EMPTY  OR TV2_A2_b 
WTM2_EMPTY_b =EMPTY OR WTM2_b 
CONNECT TV2_A2_EMPTY_b  TM2_EMPTY
CONNECT WTM2_EMPTY_b TM2_EMPTY
TV2_15 {
@ At least two TV2s  when either wide metal of Mn or TM2 with both length L>10um and width W>3um, and the distance D<=5um away from this wide metal.Exclude non-square Vn and SRAM area.
WUTM_L1_b = ( UTM NOT WUTM_b ) TOUCH WUTM_b
//UTM_ENCWM = (UTM INTERACT WUTM_b) INTERACT TV2_A_b
//WUTM_VEDGE = EXT [UTM_ENCWM]  <5 ABUT<90 OPPOSITE NOTCH
//WUTM_EXT1 = EXT (WUTM_b COIN EDGE WUTM_VEDGE) [TV2_A_b] < 5 ABUT>=0 <90  OPPOSITE CONNECTED 
//WUTM_EXT2 = (EXT WUTM_b TV2_A_b < 5 ABUT>=0 <90  OPPOSITE REGION CONNECTED ) INSIDE UTM  
TV2_B = COPY TV2_square 
X1 =(UTM AND TM2) ENCLOSE TV2_square >1
X2 = ((UTM AND TM2)  AND ( WUTM_L1_b AND WUTM_EXP_b )) NOT X1 
Y0=(UTM AND TM2) ENCLOSE TV2_square ==1 
Y1 = SIZE (TV2_square INTERACT Y0) BY 5 INSIDE OF UTM STEP 0.005  
Y2= Y1 INTERACT (Y1 AND WUTM_b)
VSING1= (X2 INTERACT TV2_B ==1) INTERACT Y2
VSING1 OUTSIDE INST 


//TM2_ENCWM = (TM2 INTERACT WTM2_b) INTERACT TV2_A2_b
//WTM2_VEDGE = EXT [TM2_ENCWM]  <5 ABUT<90 OPPOSITE NOTCH
//WTM2_EXT1 = EXT (WTM2_EMPTY_b COIN EDGE WTM2_VEDGE) [TV2_A2_EMPTY_b] < 5 ABUT>=0 <90  OPPOSITE CONNECTED 
//WTM2_EXT2 = (EXT WTM2_EMPTY_b TV2_A2_EMPTY_b < 5 ABUT>=0 <90  OPPOSITE REGION CONNECTED ) INSIDE TM2
TV2_B2 = COPY TV2_square 
X3 = ((UTM AND TM2)  AND ( WTM2_L1_b AND WTM2_EXP_b )) NOT X1 
Y3 = SIZE (TV2_square INTERACT Y0) BY 5 INSIDE OF TM2 STEP 0.005  
Y4= Y3 INTERACT (Y3 AND WTM2_b)
VSING2= (X3 INTERACT TV2_B2 ==1) INTERACT Y4
VSING2 OUTSIDE INST
}

TV2_16 {
@ 45-degree rotated TV2 is not allowed.
  (ANGLE TV2 >= 44.9 <= 45.1) NOT INSIDE EDGE MARKS
}
TV2_19 {
@ It?s not allowed TV2 overlap with Mn/TM1 resistor when Mn/TM1 directly underneath TV2. 
@ It?s not allowed TV2 overlap with TM2/MTT2 resistor when TM2/MTT2 directly above TV2 .
  TV2 AND (UTM AND UTMR)
  TV2 AND (TM2 AND TM2R)
  TV2 AND (MTT2 AND TM2R)
}

//========================
//  TM2 - Top Metal 2 DRC
//========================

#IFDEF UTM NO

GROUP GTM2 TM2_?

TM2_1 {
@ TM2 width is 0.40
  INT TM2_all < 0.40 ABUT<90 SINGULAR REGION
}
TM2_2 {
@ Space between two TM2s is 0.40
  EXT TM2_all < 0.40 ABUT<90 SINGULAR REGION
}
TM2_3_4 {
@ TV2 enclosure by TM2 is 0.020
@ Extension of TM2 line end outside of TV2 is 0.03
  RECTANGLE ENC TV2 TM2 ABUT<90 OUTSIDE ALSO
  GOOD 0.02 OPPOSITE 0.03 OPPOSITE 0.02 OPPOSITE 0.03 OPPOSITE
}

TM2_5 {
@ Minimum space between two length > 1.5um parallel metal
@ lines with one or both metal line width is > 2um is 0.50
  CMACRO TM56 TM2i_all 1.501 2.001 0.5
}

/*TM2_6 {
@ Minimum space between two length > 1.5um parallel metal
@ lines with one or both metal line width is > 4um is 1.0
  CMACRO TM56 TM2i 1.501 4.001 1
}*/
TM2_7 {
@ Space between two length > 4.5m parallel metal lines with one or both metal line width is > 4.5m is 1.2.
  CMACRO TM56 TM2i_all 4.501 4.501 1.2
}
TM2_8 {
@ TM2 area is 0.56
  AREA TM2_all < 0.56
}
TM2_9 {
@ Dielectric area(um2) enclosed by TM2 is 0.780
  AREA ((HOLES TM2_all INNER) NOT TM2_all) < 0.780
}
TM2_10_a_density {
@ Dummy pattern is required in case TM2 density is less than 15%.(INDMY or MARKG or MARKS) are excluded for this rule check
  DENSITY_MARK = BORDER NOT (OR INDMY MARKG MARKS)
  CHECK_LAYER = TM2i_all NOT (OR INDMY MARKG MARKS)
  CHECK_REGION = COPY DENSITY_MARK
  DENSITY CHECK_LAYER CHECK_REGION [area(CHECK_LAYER)/area(CHECK_REGION)] < 0.15 WINDOW 200 STEP 100 BACKUP PRINT density_report_TM2_10_a.log RDB density_report_TM2_10_a.db
}
TM2_10_b_density {
@ Max. density is 85%
  DENSITY_MARK = BORDER NOT (OR INDMY MARKG MARKS)
  CHECK_LAYER = TM2i_all NOT (OR INDMY MARKG MARKS)
  CHECK_REGION = COPY DENSITY_MARK
  DENSITY CHECK_LAYER CHECK_REGION [area(CHECK_LAYER)/area(CHECK_REGION)] > 0.85 WINDOW 200 STEP 100 BACKUP PRINT density_report_TM2_10_b.log RDB density_report_TM2_10_b.db
}
TM2_10a_density {
@ TM2 density  over the whole chip is >=20%
  DENSITY_MARK = BORDER NOT MARKS
  CHECK_LAYER = TM2i_all NOT MARKS
  CHECK_REGION = COPY DENSITY_MARK
  DENSITY CHECK_LAYER CHECK_REGION [area(CHECK_LAYER)/area(CHECK_REGION)] < 0.2 PRINT density_report_TM2_10a.log RDB density_report_TM2_10a.db
}
TM2_11_density {
@ MAX difference(%) between 2 adjacent 200um*200um area is 50%
  X = DENSITY (TM2i OR TM2DUMi) >= 0 WINDOW 200 GRADIENT > 0.5 ABSOLUTE BACKUP PRINT density_report_TM2_11.log RDB density_report_TM2_11.db
  X NOT MARKS
}
TM2_12 {
@ Maximum line width is 12um.
@ This rule is not applicable for TM2 underneath of MD opening region.
  X = TM2_all WITH WIDTH > 12
  X NOT INTERACT MD
}

#ENDIF


//============================
//  ALPA DRC
//============================

GROUP GALPA  ALPA_?

ALPA_ALL = ALPAi NOT   MARKS
ALPad = ALPA_ALL WITH WIDTH > 35
ALRDL = ALPA_ALL NOT ALPad 

ALPA_1 {
@ ALPA width. DRC waive check >86 and <90 degree angel width in INDMY covered region	≥	2µm
@ ALPA.1 allow 0.002um tolerance on 45-degree bent ALPA in INDMY.
  (INT ALPA_ALL < 2 ABUT<90 SINGULAR REGION) NOT INDMY
  (INT ALPA_ALL < 2 ABUT<86 SINGULAR ANGLED==0 REGION) AND INDMY
  (INT ALPA_ALL < 1.998 ABUT<86 SINGULAR ANGLED>0 REGION) AND INDMY 
}
ALPA_2 {
@ Minimum ALPA space is 2.
@ ALPA.2 allow 0.002um tolerance on 45-degree bent ALPA in INDMY.
  (EXT ALPA_ALL < 2 ABUT<89.9 SINGULAR REGION) NOT INDMY
  (EXT ALPA_ALL < 2 ABUT<89.9 SINGULAR ANGLED==0 REGION) AND INDMY
  (EXT ALPA_ALL < 1.998 ABUT<89.9 SINGULAR ANGLED>0 REGION) AND INDMY
}
/*
ALPA_5 {
@ Alpa minimum density with 100um*100um window is 10%, with exemption of touching inductor  
  checkregion = BORDER NOT INDMY
  X = DENSITY (ALPAi OR ALDUM) < 0.10 WINDOW 100  BACKUP RDB density_report_ALPA_5.db
  (X AND checkregion) NOT MARKS
}
ALPA_7 {
@ Space between ALRDL and Lmark window is 10
  (EXT ALRDL LOGO < 10 ABUT<90 SINGULAR REGION) NOT MARKS
}
*/
ALPA_9_density {
@ ALPA min density is 10%
  DENSITY_MARK = BORDER NOT MARKS
  CHECK_LAYER = (ALPAi OR ALDUM) NOT MARKS
  CHECK_REGION = COPY DENSITY_MARK
  DENSITY CHECK_LAYER CHECK_REGION [area(CHECK_LAYER)/area(CHECK_REGION)] < 0.1 PRINT density_report_ALPA_9.log RDB density_report_ALPA_9.db
}
ALPA_10_density {
@ ALPA max density is 70%
  DENSITY_MARK = BORDER NOT MARKS
  CHECK_LAYER = (ALPAi OR ALDUM) NOT MARKS
  CHECK_REGION = COPY DENSITY_MARK
  DENSITY CHECK_LAYER CHECK_REGION [area(CHECK_LAYER)/area(CHECK_REGION)] > 0.7 PRINT density_report_ALPA_10.log RDB density_report_ALPA_10.db
}
/*
#IFDEF BUMPING YES
ALPA_11 {
@ Space between ALRDL and Alpa pad for bumping process is 10um
  (EXT ALRDL ALPad < 10 ABUT>0<90 SINGULAR REGION) NOT MARKS
}
#ENDIF
*/
ALPA_12 {
@ ALPA must be drawn layer.
 DRC:1 NOT INTERACT ALPA_ALL
}

//=============================
//  PA (passivation-1) DRC
//=============================

GROUP GPA PA_?

PA_1 {
@ PA minimum size is 2um
@ PA.1 allow 0.002um tolerance on 45-degree rotated PA in INDMY.
  (INT PA < 2 ABUT<90 SINGULAR REGION) NOT (INDMY OR MARKS)
  ((INT PA < 2 ABUT<90 SINGULAR ANGLED==0 REGION) AND INDMY) NOT MARKS
  ((INT PA < 1.998 ABUT<90 SINGULAR ANGLED>0 REGION) AND INDMY) NOT MARKS 
}
PA_2 {
@ Minimum space between two PAs is 2um
@ PA.2 allow 0.002um tolerance on 45-degree rotated PA in INDMY.
  (EXT PA < 2 ABUT<90 SINGULAR REGION) NOT (INDMY OR MARKS)
  ((EXT PA < 2 ABUT<90 SINGULAR ANGLED==0 REGION) AND INDMY) NOT MARKS
  ((EXT PA < 1.998 ABUT<90 SINGULAR ANGLED>0 REGION) AND INDMY) NOT MARKS
}
PA_3 {
@ PA enclosed by ALPA is 0.5um,outside is not allowed
  X = ENC (PA INTERACT ALPAi ) ALPAi < 0.5 ABUT<90 SINGULAR REGION OUTSIDE ALSO
  X NOT MARKS
}
#IFDEF UTM NO
PA_4 {
@ PA enclosed by TM2 is 0.5um,outside is not allowed
@ PA.4 allow 0.002um tolerance on 45-degree rotated PA in INDMY.
  (ENC PA TM2 < 0.5 ABUT<90 SINGULAR REGION) NOT (INDMY OR MARKS)
  ((ENC PA TM2 < 0.5 ABUT<90 SINGULAR ANGLED==0 REGION) AND INDMY) NOT MARKS
  ((ENC PA TM2 < 0.498 ABUT<90 SINGULAR ANGLED>0 REGION) AND INDMY) NOT MARKS
  (PA NOT MARKS) OUT EDGE TM2
}
#ENDIF
#IFDEF UTM YES
PA_4 {
@ PA enclosed by MTT2 is 0.5um,outside is not allowed
@ PA.4 allow 0.002um tolerance on 45-degree rotated PA in INDMY.
  (ENC PA MTT2 < 0.5 ABUT<90 SINGULAR REGION) NOT (INDMY OR MARKS)
  ((ENC PA MTT2 < 0.5 ABUT<90 SINGULAR ANGLED==0 REGION) AND INDMY) NOT MARKS
  ((ENC PA MTT2 < 0.498 ABUT<90 SINGULAR ANGLED>0 REGION) AND INDMY) NOT MARKS
  (PA NOT MARKS) OUT EDGE MTT2
}
#ENDIF
PA_10 {
@ PA opening without ALPA above it is not allowed.
  X = PA NOT ALPAi
  X NOT MARKS
}
PA_11 {
@ 45-degree rotated PA is not allowed.
@ This rule is not applicable for INDMY region.
  EDGE_45 = ANGLE PA >= 44.9 <= 45.1
  EDGE_0 = ANGLE PA == 0
  EDGE_90 = ANGLE PA == 90
  PA_oct = ((PA WITH EDGE EDGE_45 == 4) WITH EDGE EDGE_0 == 2) WITH EDGE EDGE_90 == 2
  ((EDGE_45 NOT COIN EDGE PA_oct) NOT INSIDE EDGE INDMY) NOT INSIDE EDGE MARKS
}

//===========================
//  MD (passivation-2) DRC
//===========================

GROUP GMD MD_?

MD_1 {
@ MD(PA2) enclosured by Alpa is 1um
  ENC MD  ALPAi < 1.0 ABUT<90 SINGULAR REGION OUTSIDE ALSO
}
MD_2 {
@ MD(PA2) minimum width is 14um
  INT MD < 14.0 ABUT<90 SINGULAR REGION
}
MD_3 {
@ MD (PA2) minimum space is 6um
  EXT MD < 6.0 ABUT<90 SINGULAR REGION
}
MD_4_R_OFF {
@ MD (PA2) must be within BORDER(CHIPEDGE) is 8um
  ENC MD BORDER < 8 ABUT<90 SINGULAR REGION OUTSIDE ALSO
}
MD_5 {
@ MD (PA2) minimum space to PA is 1.7um,if MD not touch with PA
  EXT MD PA < 1.7 ABUT>0<90 SINGULAR REGION
}
MD_6_R_OFF {
@ MD (PA2) wire-bond pad opening maximum to CHIPEDGE is 200um
  X = SIZE BD_WITHHOLE BY -200
  X AND MD
}
/*MD_7 {
@ TM2 is prohibited over MD (PA2) wire-bond pad opening
  MD AND TM2
}*/
MD_8 {
@ Inductor is prohibited under MD (PA2) wire-bond pad opening
  INDMY AND MD
}
/*MD_9 {
@ [MD (PA2) pad opening not over seal ring] must be an orthogonal rectangle
  ANGLE (MD OUTSIDE MARKS) >0 <90
}*/
MD_10 {
@ MD (passivation 2) must be a drawn layer.
 DRC:1 NOT INTERACT (MD NOT MARKS)
}
MD_11 {
@ MD(PA2) is prohibited to overlap or touch with PA(PA size <3um)
  X = PA INTERACT MD
  INT X < 3 ABUT<90 SINGULAR REGION
}

//=====================
//   ESD1 rule
//=====================

GROUP GESD1 ESD_?

ESD_1 {
@ ESD1 minimum width is 0.33um.
 INT ESD1 < 0.33 ABUT<90 SINGULAR REGION
}
ESD_2 {
@ ESD1 minimum space is 0.33um.
 EXT ESD1 < 0.33 ABUT<90 SINGULAR REGION
}
ESD_3 {
@ ESD1 minimum area is 0.7 square um.
 AREA ESD1 < 0.7
}
ESD_4 {
@ Minimum enclosed area of ESD1 is 0.7 square um.
 ESD1HOLE = HOLES ESD1 INNER
 AREA (ESD1HOLE NOT ESD1) < 0.7
}
ESD_5 {
@ Minimum space between an ESD1 implant to an N-channel Real gate is 0.2um. Touching is not allowed.
 X = EXT ESD1 Real_NGATE < 0.2 ABUT<90 SINGULAR REGION
 Y = Real_NGATE INTERACT ESD1
 X OR Y
}
ESD_6 {
@ ESD1 must be enclosed by AA at least 0.2um.
 ENC (ESD1 NOT MARKS) AA < 0.2 ABUT<90 SINGULAR REGION OUTSIDE ALSO
}
ESD_7 {
@ ESD1 is not allowed to overlap with SP.
 ESD1 AND SP
}
/*
ESD_8 {
@ ESD1 should be drawn directly at the location to have ESD implant. It should not interact with GT.
 ESD1 INTERACT GT
}
*/
ESD_9{
@ CT enclosure by ESD1 >=0.2
ENC CT  ESD1 <0.2  ABUT<90 REGION SINGULAR 

}
ESD_9a_R_OFF {
@ Recommended CT enclosure by ESD1 >=0.4
ENC CT  ESD1 <0.4  ABUT<90 REGION SINGULAR
}

//=====================
//   HRP rule
//=====================

GROUP GHRP HRP_?

/*HRP_1{
@ It is strongly suggested that the resistor square number > 1 for precision Rs.
  X = (GT INTERACT HRP) INTERACT CT
  Y =  HRPR AND HRPDMY
  L = GT INSIDE EDGE HRPDMY 
  W = INSIDE EDGE HRPDMY GT
 DFM PROPERTY Y L W OVERLAP ABUT ALSO MULTI [WIDTH = LENGTH(W)] >0 [SQUARES = LENGTH(L)/LENGTH(W)] < 1
}*/
HRP_2 {
@ Minimum extension from HRP region beyond a poly resistor region is 0.22
 ENC HRPR HRP < 0.22 ABUT<90 SINGULAR REGION
}
HRP_3_4 {
@ Minimum clearance from HRP region to Polygate of NMOS/PMOS is 0.20
 GT_MOS = GT INTERACT GATE
 EXT HRP GT_MOS < 0.20 ABUT SINGULAR REGION
}
HRP_5 {
@ Minimum and maximum P+ implant for pickup overlap with SAB is 0.30
 SP_HRP = SP INTERACT HRP
 SAB_HRP = SAB INTERACT HRP
 X = SP_HRP AND SAB_HRP
 INT X < 0.30 ABUT<90 SINGULAR REGION
 SIZE X BY 0.15 UNDEROVER
}
HRP_7 {
@ Minimum width of Poly region for high resistance poly resistor is 2.00
 X = HR_GT INSIDE EDGE SAB
 INT X < 2.0 OPPOSITE REGION
}
/*HRP_8 {
@ Dummy layer "HRPDMY" is needed for DRC for high resistance Poly region
 SAB_HRP = SAB INTERACT (HRP INTERACT CT)
 SAB_HRP NOT INTERACT HRPDMY
}*/
HRP_9 {
@ SN SP not allowed in HRPDMY. When check this rule, size down HRPDMY by 0.3um along current direction.
/*
 HRP_END = SIZE ((GT INTERACT HRPDMY) NOT HRPDMY) BY 0.3
 HRP_MID = (GT INTERACT HRPDMY) NOT HRP_END
 (SN OR SP) AND HRP_MID
*/
 HRP_END = EXPAND EDGE (HRPDMY TOUCH EDGE (HRPDMY INSIDE EDGE GT)) INSIDE BY 0.3
 HRP_MID = (HRPDMY INTERACT HRPR) NOT HRP_END
 (SN OR SP) AND HRP_MID
}
HRP_11 {
@ HRP minimum space is 0.18um
 EXT HRP < 0.18 SINGULAR REGION
}
HRP_12 {
@ Inside HRP resistor GT area, HRPDMY and SAB must be exactly coincident.
 SAB_AND_HRP = (SAB INTERACT (HRP AND HRPDMY)) AND GT
 DMY_AND_HRP = HRPDMY AND GT
 SAB_AND_HRP XOR DMY_AND_HRP
}
HRP_13 {
@ HRP minimum width is 0.18um
 INT HRP < 0.18 SINGULAR REGION
}

//======================
//  MTT2 Rules
//======================

#IFDEF UTM YES

GROUP GMTT MTT2_?

MTT2_1 {
@ Minimum width of MTT is 1.5.
 INT MTT2_all < 1.5 ABUT<90 SINGULAR REGION
}
MTT2_2 {
@ Minimum space of MTT is 1.0.
 EXT MTT2_all < 1.0 ABUT<89.9  SINGULAR REGION
}
MTT2_2a_R_ON {
@ Minimum space between two MTTs having parallel segments >2um with one or both MTT width >=16um is 2um.
 X = MTT2 WITH WIDTH >= 16
 Y = EXT MTT2 X < 2 OPPOSITE REGION PARA ONLY
 Z = COPY Y 
 Z WITH EDGE (LENGTH Z > 2)
}
MTT2_3 {
@ Minimum extension of MTT beyond top via is 0.30.
 ENC TV2 MTT2 < 0.30 ABUT<90 SINGULAR REGION OUTSIDE ALSO
}
MTT_IN = MTT2 AND INDMY 

MTT2_5_R_ON {
@ Minimum space from MTT used as inductor to other MTT region is 30um.
 EXT MTT_IN (MTT2 NOT INTERACT MTT_IN) < 30 ABUT<90 SINGULAR REGION 
}
MTT2_6 {
@ Minimum area of MTT region is 9 square um.
 AREA MTT2_all < 9
}
MTT2_6a {
@ Minimum enclosed area of MTT is 9 square um.
 AREA ((HOLES MTT2_all INNER) NOT MTT2_all) < 9
}
MTT2_7_l_density {
@ Minimum density of MTT is 15%, with check window 200um*200um, and step 100um.
  DENSITY_MARK = BORDER NOT MARKS
  CHECK_LAYER = MTT2i_all NOT MARKS
  CHECK_REGION = COPY DENSITY_MARK
  X = DENSITY CHECK_LAYER CHECK_REGION [area(CHECK_LAYER)/area(CHECK_REGION)] < 0.15 WINDOW 200 STEP 100 BACKUP PRINT density_report_MTT2_7_l.log RDB density_report_MTT2_7_l.db
  X NOT MARKS
}
MTT2_7_h_density {
@ Minimum density of MTT is 85%, with check window 200um*200um, and step 100um.
  DENSITY_MARK = BORDER NOT MARKS
  CHECK_LAYER = MTT2i_all NOT MARKS
  CHECK_REGION = COPY DENSITY_MARK
  X = DENSITY CHECK_LAYER CHECK_REGION [area(CHECK_LAYER)/area(CHECK_REGION)] > 0.85 WINDOW 200 STEP 100 BACKUP PRINT density_report_MTT2_7_h.log RDB density_report_MTT2_7_h.db
  X NOT MARKS
}
MTT2_7a_density {
@ MTT2 density  over the whole chip	is >=20%
  DENSITY_MARK = BORDER NOT MARKS
  CHECK_LAYER = MTT2i_all NOT MARKS
  CHECK_REGION = COPY DENSITY_MARK
  X= DENSITY CHECK_LAYER CHECK_REGION [area(CHECK_LAYER)/area(CHECK_REGION)] < 0.2 PRINT density_report_MTT2_7a.log RDB density_report_MTT2_7a.db
  X  NOT MARKS
}
MTT2_7b_R_density_ON {
@ INDMY area density in window size 840um*840um with step 420um is <=20%
DENSITY_MARK = BORDER NOT MARKS
CHECK_LAYER = INDMY NOT MARKS
CHECK_REGION = COPY DENSITY_MARK
X= DENSITY CHECK_LAYER CHECK_REGION [area(CHECK_LAYER)/area(CHECK_REGION)] > 0.20 WINDOW 840 STEP 420 BACKUP PRINT density_report_MTT2_7b.log RDB density_report_MTT2_7b.db
X NOT MARKS
}
MTT2_8 {
@ All devices listed in device table inside inductor region are prohibited.
 X = GATE INTERACT CT 
 (GATE NOT X) AND INDMY
 RESAA AND INDMY
 RESNW AND INDMY
 RESP1 AND INDMY
 PLRES AND INDMY
 DIFRES AND INDMY
 DSTR AND INDMY
 BIPOLA AND INDMY
 HRPDMY AND INDMY
 MOMDMY AND INDMY
 M1R AND INDMY
 M2R AND INDMY
 M3R AND INDMY
 M4R AND INDMY
 M5R AND INDMY
 M6R AND INDMY
 M7R AND INDMY
 M8R AND INDMY
 TM2R AND INDMY
}
MTT2_9_R_ON {
@ Minimum extension of dummy layer INDMY beyond MTT region used as inductor is 15um.
 X = MTT2 INTERACT INDMY
 ENC X INDMY < 15 ABUT<90 SINGULAR REGION
}
MTT2_11 {
@ Maximum MTT width is 17um.
@ MTT2 underneath of MD does not follow this rule.
 X = MTT2_all WITH WIDTH > 17
 X NOT INTERACT MD
}
MTT2_12_density {
@ Maximum MTT density on the whole chip including dummy is 55%.
DENSITY_MARK = BORDER NOT MARKS
CHECK_LAYER = MTT2i_all NOT MARKS
CHECK_REGION = COPY DENSITY_MARK
X =DENSITY CHECK_LAYER CHECK_REGION [area(CHECK_LAYER)/area(CHECK_REGION)] > 0.55 PRINT density_report_MTT2_12.log RDB density_report_MTT2_12.log
X NOT MARKS
}

#IFDEF TOPMETAL 9
TV2_EMPTY = EMPTY OR (TV2 INSIDE (M8 AND MTT2)) 
INTER_EMPTY_TM2 =EMPTY OR (M8 AND MTT2)  
CONNECT  TV2_EMPTY INTER_EMPTY_TM2
MTT2_13_R_OFF {
@ At least 2 TVs with space <=1.7 m are required to connect MTT2. 
@ (Please add vias as many as possible which is for reliability concern and RF application).
  X = EXT TV2_EMPTY <= 1.7 ABUT<90 SINGULAR REGION CONNECTED
  ((MTT2 AND M8) INTERACT TV2) NOT INTERACT X
}
#ENDIF
#IFDEF TOPMETAL 8
TV2_EMPTY = EMPTY OR (TV2 INSIDE (M7 AND MTT2)) 
INTER_EMPTY_TM2 =EMPTY OR (M7 AND MTT2)  
CONNECT  TV2_EMPTY INTER_EMPTY_TM2
MTT2_13_R_OFF {
@ At least 2 TVs with space ? 1.7 m are required to connect MTT2. 
@ (Please add vias as many as possible which is for reliability concern and RF application).
  X = EXT TV2_EMPTY <= 1.7 ABUT<90 SINGULAR REGION CONNECTED
  ((MTT2 AND M7) INTERACT TV2) NOT INTERACT X
}
#ENDIF
#IFDEF TOPMETAL 7
TV2_EMPTY = EMPTY OR (TV2 INSIDE (M6 AND MTT2)) 
INTER_EMPTY_TM2 =EMPTY OR (M6 AND MTT2)  
CONNECT  TV2_EMPTY INTER_EMPTY_TM2
MTT2_13_R_OFF {
@ At least 2 TVs with space ? 1.7 m are required to connect MTT2. 
@ (Please add vias as many as possible which is for reliability concern and RF application).
  X = EXT TV2_EMPTY <= 1.7 ABUT<90 SINGULAR REGION CONNECTED
  ((MTT2 AND M6) INTERACT TV2) NOT INTERACT X
}
#ENDIF
#IFDEF TOPMETAL 6
TV2_EMPTY = EMPTY OR (TV2 INSIDE (M5 AND MTT2)) 
INTER_EMPTY_TM2 =EMPTY OR (M5 AND MTT2)  
CONNECT  TV2_EMPTY INTER_EMPTY_TM2
MTT2_13_R_OFF {
@ At least 2 TVs with space ? 1.7 m are required to connect MTT2. 
@ (Please add vias as many as possible which is for reliability concern and RF application).
  X = EXT TV2_EMPTY <= 1.7 ABUT<90 SINGULAR REGION CONNECTED
  ((MTT2 AND M5) INTERACT TV2) NOT INTERACT X
}
#ENDIF
#IFDEF TOPMETAL 5
TV2_EMPTY = EMPTY OR (TV2 INSIDE (M4 AND MTT2)) 
INTER_EMPTY_TM2 =EMPTY OR (M4 AND MTT2)  
CONNECT  TV2_EMPTY INTER_EMPTY_TM2
MTT2_13_R_OFF {
@ At least 2 TVs with space ? 1.7 m are required to connect MTT2. 
@ (Please add vias as many as possible which is for reliability concern and RF application).
  X = EXT TV2_EMPTY <= 1.7 ABUT<90 SINGULAR REGION CONNECTED
  ((MTT2 AND M4) INTERACT TV2) NOT INTERACT X
}
#ENDIF
#IFDEF TOPMETAL 4
TV2_EMPTY = EMPTY OR (TV2 INSIDE (M3 AND MTT2)) 
INTER_EMPTY_TM2 =EMPTY OR (M3 AND MTT2)  
CONNECT  TV2_EMPTY INTER_EMPTY_TM2
MTT2_13_R_OFF {
@ At least 2 TVs with space ? 1.7 m are required to connect MTT2. 
@ (Please add vias as many as possible which is for reliability concern and RF application).
  X = EXT TV2_EMPTY <= 1.7 ABUT<90 SINGULAR REGION CONNECTED
  ((MTT2 AND M3) INTERACT TV2) NOT INTERACT X
}
#ENDIF

#ENDIF
//===============================================================
// E fuse dimension rule
//===============================================================

/*
EFU_1_2 {
@ (GT AND GTFUSE) width (vertical to current flow)=0.045
@ (GT AND GTFUSE) length (parallel to current flow) is	=0.222
  EXT ((GTFUSE NOT GT) TOUCH OUTSIDE EDGE GT)<0.222 ABUT<90 REGION
  NOT RECTANGLE (GT AND GTFUSE) ==0.045 BY ==0.222    
}
EFU_3{
@ Only SP implant is allowed in EFUSE area (NW is not allowed in EFUSE area)
@ Highlight part: (EFUSE AND GT) NOT (SP NOT NW)
(EFUSE AND GT) NOT (SP NOT NW)
}
EFU_4{
@ GTFUSE(81;1) should be within EFUSE area to identify EFUSE function area.
GTFUSE NOT INSIDE EFUSE
}
*/
EFU_1b_G {
@ FUSEMK1 (81;152) must interact with EFUSE (81;2) region.
  (FUSEMK1 NOT INTERACT EFUSE) NOT MARKS
}

EFU_1c_G {
@ FUSEMK1 (81;152) must fully cover EFUSE (81;2) region.
  (EFUSE NOT FUSEMK1) NOT MARKS
}

EFU_2b_G {
@ EFUSE (81;2) must interact with GTFUSE(81;1).
  (EFUSE NOT INTERACT GTFUSE) NOT MARKS
}

EFU_2c_G {
@ EFUSE (81;2) must fully cover GTFUSE(81;1).
  (GTFUSE NOT EFUSE) NOT MARKS
}

#IFDEF LDMOS YES

//===============================================================
// LDMOS design Guideline for IO 2.5V gate OX device
//===============================================================

GROUP GLD LD_?

LDMOS = LDBK AND TG
GATE_LD = GATE AND LDMOS
PGATE_LD = PGATE AND LDMOS
NGATE_LD = NGATE AND LDMOS

PGATE_LDE = PGATE_LD AND NW
NGATE_LDE = NGATE_LD NOT NW

STI_1 = (GATE_LD INSIDE EDGE AA) COIN EDGE GT
STI_2 = INT STI_1 GATE_LD < 0.005 ABUT INTERSECTING ONLY REGION
STI_3 = GATE_LD NOT TOUCH EDGE STI_2
STI = EXPAND EDGE STI_3 OUTSIDE BY 0.15  //refer to rule LD.3



LD_1a_G {
@ Min Effective Channel length for NLDMOS transistors is 0.28
  INT NGATE_LDE < 0.28 ABUT < 90 SINGULAR REGION
}

LD_1b_G {
@ Min Effective Channel length for PLDMOS transistors is 0.26
  INT PGATE_LDE < 0.26 ABUT < 90 SINGULAR REGION
}

LD_2_G {
@ Min Drain AA width along source/drain direction for LDMOS transistors is 0.2
  X = (AA NOT GATE_LD) COIN EDGE STI
  INT X < 0.2 OPPOSITE REGION
}

LD_3_G {
@ Fixed STI width along source/drain direction is 0.15
  STI NOT TOUCH (AA NOT GATE_LD) == 1
}

LD_4_G {
@ Min Overlap of GT and STI along source/drain direction is 0.05
  ENC STI_3 GT < 0.05 ABUT < 90 REGION OPPOSITE
}

LD_5_G {
@ Fixed N LDMOS gate overlaps with NW in source/drain direction length is 0.22.
@ Fixed P LDMOS gate not in NW in source/drain direction length is 0.22
  X = NGATE_LD AND NW
  SIZE X BY 0.11 UNDEROVER
  INT X < 0.22 SINGULAR REGION

  Y = PGATE_LD NOT NW
  SIZE Y BY 0.11 UNDEROVER
  INT Y < 0.22 SINGULAR REGION
}

LD_6_G {
@ Min LDMOS channel width is 2
  X = GATE_LD COIN EDGE GT
  LENGTH X < 2
}

LD_7a_G {
@ Min Space between LDMOS source side AA and pickup AA along source/drain direction is 0.6
  X = AA ENCLOSE GATE_LD
  Y = X INSIDE EDGE GT
  Z = X NOT TOUCH EDGE Y
  EXT Z TAP < 0.6 ABUT < 90 REGION
}

LD_7b_G {
@ Min Space between LDMOS source side AA and pickup AA along gate poly direction is 0.9
  X = GATE_LD COIN EDGE GT
  Y = INT X GATE_LD < 0.005 ABUT INTERSECTING ONLY REGION
  Z = ((AA ENCLOSE GATE_LD) TOUCH EDGE Y) NOT TOUCH EDGE GT
  EXT Z (TAP NOT COIN EDGE GATE) < 0.9 ABUT < 90 REGION
}

LD_8_G {
@ Min NW extension outside of N LDMOS AA along gate poly direction is 0.25.
@ Min NW space to P LDMOS AA along gate poly direction is 0.25
  X = AA TOUCH EDGE STI
  Y = INT X AA < 0.005 ABUT INTERSECTING ONLY REGION
  Z = AA TOUCH EDGE Y
  M = Z NOT TOUCH EDGE X

  ENC M NW < 0.25 ABUT < 90 REGION
  EXT M NW < 0.25 ABUT < 90 REGION
}

LD_9_G { 
@ LDMOS block layer (LDBK) is used to identify LDMOS function area.
@ Min LDBK extension outside of (gate, source, drain)'s AA is 0.4
  X = HOLES (NW INTERACT PGATE_LD)
  Y = NW INTERACT NGATE_LD
  Z = AA INTERACT (X OR Y)
  ENC Z LDBK < 0.4 ABUT < 90 REGION
}

LD_10_G {
@ "One LDMOS unit must has two polys and a common drain. 
@ Single poly structure is not allowed."
(AA NOT GATE_LD) TOUCH STI < 2
}

GT_EM8 = OR EMPTY8 GT0 
CT_EM8 = OR EMPTY8 CTi
NGATE_EM8 = OR EMPTY8 NGATE_LD  
PGATE_EM8 = OR EMPTY8 PGATE_LD
NS_EM8 = OR EMPTY8 ((NACT NOT GATE_LD) TOUCH GATE_LD)
ND_EM8 = OR EMPTY8 ((NTAP NOT GATE_LD) TOUCH STI)
PS_EM8 = OR EMPTY8 ((PACT NOT GATE_LD) TOUCH GATE_LD)
PD_EM8 = OR EMPTY8 ((PTAP NOT GATE_LD) TOUCH STI)
NACT_EM8 = OR EMPTY8 (NSD_NOT_R NOT NS_EM8) 
NTAP_EM8 = OR EMPTY8 (NTAPi NOT ND_EM8) 
PACT_EM8 = OR EMPTY8 (PSD_NOT_R NOT PS_EM8) 
PTAP_EM8 = OR EMPTY8 (PTAPi NOT PD_EM8)
ALPA_EM8 = OR EMPTY8 ALPAi
PA_EM8 = OR EMPTY8 PA
MD_EM8 = OR EMPTY8 MD
mark_e1 = OR EMPTY8 LDBK 
mark_e2 = OR LDBK mark_e1
mark_e3 = OR LDBK mark_e2


sconnect NS_EM8 mark_e1
sconnect ND_EM8 mark_e2
sconnect NGATE_EM8 mark_e3

sconnect PS_EM8 mark_e1
sconnect PD_EM8 mark_e2
sconnect PGATE_EM8 mark_e3

M1_EM8 = EMPTY8 OR M1i
V1_EM8 = EMPTY8 OR V1i
M2_EM8 = EMPTY8 OR M2i
V2_EM8 = EMPTY8 OR V2i
M3_EM8 = EMPTY8 OR M3i
V3_EM8 = EMPTY8 OR V3i
M4_EM8 = EMPTY8 OR M4i
V4_EM8 = EMPTY8 OR V4i
M5_EM8 = EMPTY8 OR M5i
V5_EM8 = EMPTY8 OR V5i
M6_EM8 = EMPTY8 OR M6i
V6_EM8 = EMPTY8 OR V6i
M7_EM8 = EMPTY8 OR M7i
V7_EM8 = EMPTY8 OR V7i
M8_EM8 = EMPTY8 OR M8i
TV2_EM8 = EMPTY8 OR TV2i
TM2_EM8 = EMPTY8 OR TM2i

CONNECT M1_EM8 M2_EM8 BY V1_EM8
CONNECT M2_EM8 M3_EM8 BY V2_EM8

#IFDEF TOPMETAL 4
CONNECT M3_EM8 TM2_EM8 BY TV2_EM8
#ENDIF

#IFDEF TOPMETAL 5
CONNECT M3_EM8 M4_EM8 BY V3_EM8
CONNECT M4_EM8 TM2_EM8 BY TV2_EM8
#ENDIF

#IFDEF TOPMETAL 6
CONNECT M3_EM8 M4_EM8 BY V3_EM8
CONNECT M4_EM8 M5_EM8 BY V4_EM8
CONNECT M5_EM8 TM2_EM8 BY TV2_EM8
#ENDIF

#IFDEF TOPMETAL 7
CONNECT M3_EM8 M4_EM8 BY V3_EM8
CONNECT M4_EM8 M5_EM8 BY V4_EM8
CONNECT M5_EM8 M6_EM8 BY V5_EM8
CONNECT M6_EM8 TM2_EM8 BY TV2_EM8
#ENDIF

#IFDEF TOPMETAL 8
CONNECT M3_EM8 M4_EM8 BY V3_EM8
CONNECT M4_EM8 M5_EM8 BY V4_EM8
CONNECT M5_EM8 M6_EM8 BY V5_EM8
CONNECT M6_EM8 M7_EM8 BY V6_EM8
CONNECT M7_EM8 TM2_EM8 BY TV2_EM8
#ENDIF

#IFDEF TOPMETAL 9
CONNECT M3_EM8 M4_EM8 BY V3_EM8
CONNECT M4_EM8 M5_EM8 BY V4_EM8
CONNECT M5_EM8 M6_EM8 BY V5_EM8
CONNECT M6_EM8 M7_EM8 BY V6_EM8
CONNECT M7_EM8 M8_EM8 BY V7_EM8
CONNECT M8_EM8 TM2_EM8 BY TV2_EM8
#ENDIF

CONNECT M1_EM8 NS_EM8 ND_EM8 PS_EM8 PD_EM8 GT_EM8 BY CT_EM8  
CONNECT M1_EM8 NACT_EM8 NTAP_EM8 PACT_EM8 PTAP_EM8 BY CT_EM8 
CONNECT GT_EM8 NGATE_EM8 
CONNECT GT_EM8 PGATE_EM8
CONNECT ALPA_EM8 TM2_EM8 BY PA_EM8
CONNECT ALPA_EM8 MD_EM8 

LD_11_G {
@ Common source is allowed only for multi-finger LDMOS structure in LDBK region.(Drain/Source/GATE is connected together respectively.)
Ns_error = net area ratio NS_EM8 mark_e1 == 0 
Nd_error = net area ratio ND_EM8 mark_e2 == 0 
Ng_error = net area ratio NGATE_EM8 mark_e3 == 0 
Ps_error = net area ratio PS_EM8 mark_e1 == 0 
Pd_error = net area ratio PD_EM8 mark_e2 == 0 
Pg_error = net area ratio PGATE_EM8 mark_e3 == 0
X = ((AA TOUCH STI) OR STI) ENCLOSE ((AA NOT GATE_LD) TOUCH GATE_LD ==2  )
((X INTERACT Ns_error) OR (X INTERACT Nd_error)) OR (X INTERACT Ng_error)
((X INTERACT Ps_error) OR (X INTERACT Pd_error)) OR (X INTERACT Pg_error)
}
#ENDIF

//=================
//  DFM rules
//=================

M1W = M1i WITH WIDTH > 0.22
M2W = M2i WITH WIDTH > 0.22
M3W = M3i WITH WIDTH > 0.22
M4W = M4i WITH WIDTH > 0.22
M5W = M5i WITH WIDTH > 0.22
M6W = M6i WITH WIDTH > 0.22
M7W = M7i WITH WIDTH > 0.22
M8W = M8i WITH WIDTH > 0.22



DMACRO DFM4 LOWMT HIGHMT VIA {
A_1 = LOWMT AND HIGHMT
W_LOWMT = LOWMT WITH WIDTH >= 0.35
W_HIGHMT = HIGHMT WITH WIDTH >= 0.35
A = ( A_1 INTERACT W_LOWMT ) OR (A_1 INTERACT W_HIGHMT )
B = A INTERACT VIA == 1
B1 = B TOUCH ( W_LOWMT NOT B ) == 2
B2 = B TOUCH ( W_HIGHMT NOT B ) == 2
B3 = B NOT (B1 OR B2 )
B4 = SIZE B3 BY 2
BALL = ((( B4 AND W_LOWMT ) OR (B4  AND W_HIGHMT ) ) ENCLOSE B3) OR ( B1 OR B2 )
LOWMT_1 = LOWMT INTERACT B
HIGHMT_1 = HIGHMT INTERACT B
LOWMT_INT = INT LOWMT_1 < 15 OPPOSITE EXCLUDE SHIELDED
HIGHMT_INT = INT HIGHMT_1 < 15 OPPOSITE EXCLUDE SHIELDED
LOWMT_2 = DFM PROPERTY BALL LOWMT_INT OVERLAP ABUT ALSO MULTI [WIDTH = MIN(EW(LOWMT_INT))]
HIGHMT_2 = DFM PROPERTY BALL HIGHMT_INT OVERLAP ABUT ALSO MULTI [WIDTH = MIN(EW(HIGHMT_INT))]
ERR1 = DFM PROPERTY BALL LOWMT_2 HIGHMT_2 OVERLAP ABUT ALSO MULTI [ratio = property(LOWMT_2,WIDTH)/property(HIGHMT_2,WIDTH)]>=5
ERR2 = DFM PROPERTY BALL LOWMT_2 HIGHMT_2 OVERLAP ABUT ALSO MULTI [ratio = property(HIGHMT_2,WIDTH)/property(LOWMT_2,WIDTH)]>=5
B INTERACT (ERR1 OR ERR2)
}


//============================
//  Dummy insert check Rules
//============================

GROUP GDUMC DUMC_?

LP = LOGO OR PTCT
LPM = LP OR MARKS
LP_BM = LP OR DUMBM
LPM_BM = LPM OR DUMBM
/*
DUMC_1 {
@ Dummy AA should comply with AA.1, AA.4a rules
@ Min Dummy AA width is 0.06 (AA.1)
@ Min Dummy AA space is 0.08 (AA.4a)
  INT AADUM < 0.06 ABUT < 90 SINGULAR REGION
  EXT AADUM < 0.08 ABUT < 90 SINGULAR REGION
}
*/
DUMC_2 {
@ Dummy AA must not touch (AA GT CT LOGO PTCT MARKS RESP1 RESNW PLRES HRPDMY).
  X = (AA OR (GT OR CT)) OR ((LPM OR HRPDMY) OR ((RESP1 OR PLRES) OR RESNW))
  AADUM INTERACT X
}
/*
DUMC_3 {
@ Dummy AA cannot straddle N-Well boundaries.
  AADUM CUT NW
}
*/
DUMC_5 {
@ Dummy AA space to AA >=0.710
  EXT AADUM AA < 0.71 ABUT < 90 SINGULAR REGION
}

DUMC_6 {
@ Dummy AA space to (GT, PTCT, RESP1, RESNW,  PLRES, HRPDMY) >=0.220
  EXT AADUM GT < 0.22 ABUT < 90 SINGULAR REGION
  EXT AADUM PTCT < 0.22 ABUT < 90 SINGULAR REGION
  EXT AADUM RESP1 < 0.22 ABUT < 90 SINGULAR REGION
  EXT AADUM RESNW < 0.22 ABUT < 90 SINGULAR REGION
  EXT AADUM PLRES < 0.22 ABUT < 90 SINGULAR REGION
  EXT AADUM HRPDMY < 0.22 ABUT < 90 SINGULAR REGION
}

DUMC_7 {
@ Dummy AA space to GTFUSE >=3.330
  EXT AADUM GTFUSE < 3.33 ABUT < 90 SINGULAR REGION
}

DUMC_8 {
@ Dummy AA space to NW >=0.260
  EXT AADUM NW < 0.26 ABUT < 90 SINGULAR REGION
}

/*DUMC_9 {
@ Dummy AA space to DNW >=0.260
  EXT AADUM DNW < 0.26 ABUT < 90 SINGULAR REGION
}*/

DUMC_10 {
@ Dummy AA cannot insert at RESNW area
  AADUM AND RESNW
}

DUMC_11 {
@ Dummy AA should not be larger than 20x20um
  ENCLOSE RECTANGLE AADUM 20.001 20.001
}

DUMC_12 {
@ Dummy GT must not touch (GT, AA, CT, LOGO, PTCT, MARKS, RESAA, RESNW, DIFRES)
  GTDUM INTERACT GT
  GTDUM INTERACT AA
  GTDUM INTERACT CT
  GTDUM INTERACT LPM
  GTDUM INTERACT RESAA
  GTDUM INTERACT RESNW
  GTDUM INTERACT DIFRES
}

DUMC_13 {
@ Dummy GT minimum width >=0.044
  INT GTDUM < 0.044 ABUT <90 SINGULAR REGION
}

DUMC_14 {
@ Dummy GT minimum space >=0.110
  EXT GTDUM < 0.11 ABUT <90 SINGULAR REGION
}

DUMC_15 {
@ Dummy GT space to GT on AA >= 0.150
  EXT GTDUM (GT INTERACT AA) < 0.15 ABUT <90 SINGULAR REGION
}

DUMC_15a {
@ Dummy GT space to GT on field OX >= 0.110
  EXT GTDUM (GT NOT INTERACT AA) < 0.11 ABUT <90 SINGULAR REGION
}

DUMC_16 {
@ Dummy GT space to (AA,PTCT, RESAA, RESNW, DIFRES, HRPDMY). >=0.220
  EXT GTDUM AA < 0.22 ABUT <90 SINGULAR REGION
  EXT GTDUM PTCT< 0.22 ABUT <90 SINGULAR REGION
  EXT GTDUM RESAA < 0.22 ABUT <90 SINGULAR REGION
  EXT GTDUM RESNW < 0.22 ABUT <90 SINGULAR REGION
  EXT GTDUM DIFRES < 0.22 ABUT <90 SINGULAR REGION
  EXT GTDUM HRPDMY < 0.22 ABUT <90 SINGULAR REGION
}

DUMC_17 {
@ Dummy GT space to GTFUSE >=3.330
  EXT GTDUM GTFUSE < 3.33 ABUT <90 SINGULAR REGION
}
#IFDEF TOPMETAL 9
DUMC_18 {
@ Mx Dummy must not touch (CT, Mx, Vx, Vx-1, TV2, LOGO, PTCT, MARKS), where Mx=M1-M8, TM1, TM2,MTT2. x=1~8. V8 and V-1 are not applicable
  INTERACT M1DUMi ((M1i OR LPM) OR (V1i OR CTi)) 
  INTERACT M2DUMi ((M2i OR LPM)  OR (V1i OR V2i))
  INTERACT M3DUMi ((M3i OR LPM)  OR (V2i OR V3i))
  INTERACT M4DUMi ((M4i OR LPM)  OR (V3i OR V4i))
  INTERACT M5DUMi ((M5i OR LPM)  OR (V4i OR V5i))
  INTERACT M6DUMi ((M6i OR LPM)  OR (V5i OR V6i))
  INTERACT M7DUMi ((M7i OR LPM)  OR (V6i OR V7i))
  INTERACT M8DUMi ((M8i OR LPM)  OR (V7i OR TV2i)) 
  INTERACT TM2DUMi ((TM2i OR LPM) OR TV2i) 
  INTERACT MTT2DMi ((MTT2i OR LPM) OR TV2i)
}
#ENDIF
#IFDEF TOPMETAL 8
DUMC_18 {
@ Mx Dummy must not touch (CT, Mx, Vx, Vx-1, TV2, LOGO, PTCT, MARKS), where Mx=M1-M8, TM1, TM2,MTT2. x=1~8. V8 and V-1 are not applicable
  INTERACT M1DUMi ((M1i OR LPM) OR (V1i OR CTi)) 
  INTERACT M2DUMi ((M2i OR LPM)  OR (V1i OR V2i))
  INTERACT M3DUMi ((M3i OR LPM)  OR (V2i OR V3i))
  INTERACT M4DUMi ((M4i OR LPM)  OR (V3i OR V4i))
  INTERACT M5DUMi ((M5i OR LPM)  OR (V4i OR V5i))
  INTERACT M6DUMi ((M6i OR LPM)  OR (V5i OR V6i))
  INTERACT M7DUMi ((M7i OR LPM)  OR (V6i OR TV2i))
  INTERACT TM2DUMi ((TM2i OR LPM) OR TV2i) 
  INTERACT MTT2DMi ((MTT2i OR LPM) OR TV2i)
}
#ENDIF
#IFDEF TOPMETAL 7
DUMC_18 {
@ Mx Dummy must not touch (CT, Mx, Vx, Vx-1, TV2, LOGO, PTCT, MARKS), where Mx=M1-M8, TM1, TM2,MTT2. x=1~8. V8 and V-1 are not applicable
  INTERACT M1DUMi ((M1i OR LPM) OR (V1i OR CTi)) 
  INTERACT M2DUMi ((M2i OR LPM)  OR (V1i OR V2i))
  INTERACT M3DUMi ((M3i OR LPM)  OR (V2i OR V3i))
  INTERACT M4DUMi ((M4i OR LPM)  OR (V3i OR V4i))
  INTERACT M5DUMi ((M5i OR LPM)  OR (V4i OR V5i))
  INTERACT M6DUMi ((M6i OR LPM)  OR (V5i OR TV2i))
  INTERACT TM2DUMi ((TM2i OR LPM) OR TV2i) 
  INTERACT MTT2DMi ((MTT2i OR LPM) OR TV2i)
}
#ENDIF
#IFDEF TOPMETAL 6
DUMC_18 {
@ Mx Dummy must not touch (CT, Mx, Vx, Vx-1, TV2, LOGO, PTCT, MARKS), where Mx=M1-M8, TM1, TM2,MTT2. x=1~8. V8 and V-1 are not applicable
  INTERACT M1DUMi ((M1i OR LPM) OR (V1i OR CTi)) 
  INTERACT M2DUMi ((M2i OR LPM)  OR (V1i OR V2i))
  INTERACT M3DUMi ((M3i OR LPM)  OR (V2i OR V3i))
  INTERACT M4DUMi ((M4i OR LPM)  OR (V3i OR V4i))
  INTERACT M5DUMi ((M5i OR LPM)  OR (V4i OR TV2i))
  INTERACT TM2DUMi ((TM2i OR LPM) OR TV2i) 
  INTERACT MTT2DMi ((MTT2i OR LPM) OR TV2i)
}
#ENDIF
#IFDEF TOPMETAL 5
DUMC_18 {
@ Mx Dummy must not touch (CT, Mx, Vx, Vx-1, TV2, LOGO, PTCT, MARKS), where Mx=M1-M8, TM1, TM2,MTT2. x=1~8. V8 and V-1 are not applicable
  INTERACT M1DUMi ((M1i OR LPM) OR (V1i OR CTi)) 
  INTERACT M2DUMi ((M2i OR LPM)  OR (V1i OR V2i))
  INTERACT M3DUMi ((M3i OR LPM)  OR (V2i OR V3i))
  INTERACT M4DUMi ((M4i OR LPM)  OR (V3i OR TV2i))
  INTERACT TM2DUMi ((TM2i OR LPM) OR TV2i) 
  INTERACT MTT2DMi ((MTT2i OR LPM) OR TV2i)
}
#ENDIF
#IFDEF TOPMETAL 4
DUMC_18 {
@ Mx Dummy must not touch (CT, Mx, Vx, Vx-1, TV2, LOGO, PTCT, MARKS), where Mx=M1-M8, TM1, TM2,MTT2. x=1~8. V8 and V-1 are not applicable
  INTERACT M1DUMi ((M1i OR LPM) OR (V1i OR CTi)) 
  INTERACT M2DUMi ((M2i OR LPM)  OR (V1i OR V2i))
  INTERACT M3DUMi ((M3i OR LPM)  OR (V2i OR TV2i))
  INTERACT TM2DUMi ((TM2i OR LPM) OR TV2i) 
  INTERACT MTT2DMi ((MTT2i OR LPM) OR TV2i)
}
#ENDIF
DUMC_19 {
@ Mx Dummy space to GTFUSE with touching prohibited, where Mx=M1, M2   >=3.33
  EXT M1DUM GTFUSE < 3.33 ABUT <90 SINGULAR REGION
  EXT M2DUM GTFUSE < 3.33 ABUT <90 SINGULAR REGION
  INTERACT M1DUM GTFUSE
  INTERACT M2DUM GTFUSE
}
PT_BM = DUMBM OR PTCT
DUMC_20_M1 {
@ Mx Dummy space to (MxDUB, DUMBM, PTCT), where Mx=M1-M8.   >=0.6
  EXT M1DUM (M1DUB OR PT_BM) < 0.6 ABUT < 90 SINGULAR REGION
}

DUMC_20_M2 {
  EXT M2DUM (M2DUB OR PT_BM) < 0.6 ABUT < 90 SINGULAR REGION
}

DUMC_20_M3 {
  EXT M3DUM (M3DUB OR PT_BM) < 0.6 ABUT < 90 SINGULAR REGION
}

DUMC_20_M4 {
  EXT M4DUM (M4DUB OR PT_BM) < 0.6 ABUT < 90 SINGULAR REGION
}

DUMC_20_M5 {
  EXT M5DUM (M5DUB OR PT_BM) < 0.6 ABUT < 90 SINGULAR REGION
}

DUMC_20_M6 {
  EXT M6DUM (M6DUB OR PT_BM) < 0.6 ABUT < 90 SINGULAR REGION
}

DUMC_20_M7 {
  EXT M7DUM (M7DUB OR PT_BM) < 0.6 ABUT < 90 SINGULAR REGION
}

DUMC_20_M8 {
  EXT M8DUM (M8DUB OR PT_BM) < 0.6 ABUT < 90 SINGULAR REGION
}

DUMC_21_M1 {
@ Mx Dummy space to Mx(when Mx Dummy not touching INDMY), where Mx=M1-M8. >=0.6
  EXT (M1DUM  NOT INTERACT INDMY) M1 < 0.6 ABUT < 90 SINGULAR REGION
}

DUMC_21_M2 {
@ Mx Dummy space to Mx(when Mx Dummy not touching INDMY), where Mx=M1-M8. >=0.6
  EXT (M2DUM NOT INTERACT INDMY) M2 < 0.6 ABUT < 90 SINGULAR REGION
}

DUMC_21_M3 {
@ Mx Dummy space to Mx(when Mx Dummy not touching INDMY), where Mx=M1-M8. >=0.6
  EXT (M3DUM  NOT INTERACT INDMY) M3  < 0.6 ABUT < 90 SINGULAR REGION
}

DUMC_21_M4 {
@ Mx Dummy space to Mx(when Mx Dummy not touching INDMY), where Mx=M1-M8. >=0.6
  EXT (M4DUM NOT INTERACT INDMY) M4  < 0.6 ABUT < 90 SINGULAR REGION
}

DUMC_21_M5 {
@ Mx Dummy space to Mx(when Mx Dummy not touching INDMY), where Mx=M1-M8. >=0.6
  EXT (M5DUM  NOT INTERACT INDMY) M5  < 0.6 ABUT < 90 SINGULAR REGION
}

DUMC_21_M6 {
@ Mx Dummy space to Mx(when Mx Dummy not touching INDMY), where Mx=M1-M8. >=0.6
  EXT (M6DUM NOT INTERACT INDMY) M6  < 0.6 ABUT < 90 SINGULAR REGION
}

DUMC_21_M7 {
@ Mx Dummy space to Mx(when Mx Dummy not touching INDMY), where Mx=M1-M8. >=0.6
  EXT (M7DUM NOT INTERACT INDMY) M7  < 0.6 ABUT < 90 SINGULAR REGION
}

DUMC_21_M8 {
@ Mx Dummy space to Mx(when Mx Dummy not touching INDMY), where Mx=M1-M8. >=0.6
  EXT (M8DUM NOT INTERACT INDMY) M8 < 0.6 ABUT < 90 SINGULAR REGION
}

DUMC_21a_M1{
@ Mx Dummy space to Mx (when Mx Dummy touching INDMY), where Mx=M1-M8.0.53
EXT (M1DUM INTERACT INDMY) M1  <0.53 ABUT < 90 SINGULAR REGION
}
DUMC_21a_M2 {
  EXT (M2DUM INTERACT INDMY) M2  < 0.53 ABUT < 90 SINGULAR REGION
}

DUMC_21a_M3 {
  EXT (M3DUM INTERACT INDMY) M3  < 0.53 ABUT < 90 SINGULAR REGION
}

DUMC_21a_M4 {
  EXT (M4DUM INTERACT INDMY) M4  < 0.53 ABUT < 90 SINGULAR REGION
}

DUMC_21a_M5 {
  EXT (M5DUM INTERACT INDMY) M5 < 0.53 ABUT < 90 SINGULAR REGION
}

DUMC_21a_M6 {
  EXT (M6DUM INTERACT INDMY) M6  < 0.53 ABUT < 90 SINGULAR REGION
}

DUMC_21a_M7 {
  EXT ( M7DUM INTERACT INDMY) M7  < 0.53 ABUT < 90 SINGULAR REGION
}

DUMC_21a_M8 {
  EXT (M8DUM INTERACT INDMY) M8 < 0.53 ABUT < 90 SINGULAR REGION
}

DUMC_22 {
@ Vx Dummy must not touch (Vx, Mx, Mx+1, LOGO, PTCT, INDMY ,MARKS), where Vx=V1-V7, x=1-7
  LPI = (LP OR INDMY) OR MARKS
  V1DUMi INTERACT ((V1 OR LPI)  OR (M1 OR M2))
  V2DUMi INTERACT ((V2 OR LPI) OR (M2 OR M3))
  V3DUMi INTERACT ((V3 OR LPI)  OR (M3 OR M4))
  V4DUMi INTERACT ((V4 OR LPI)  OR (M4 OR M5))
  V5DUMi INTERACT ((V5 OR LPI)  OR (M5 OR M6))
  V6DUMi INTERACT ((V6 OR LPI)  OR (M6 OR M7))
  V7DUMi INTERACT ((V7 OR LPI) OR (M7 OR M8))
}

DMACRO DUMC_23_24 DMLAY {
X1 = RECTANGLE DMLAY == 0.07 BY == 0.07
X2 = RECTANGLE DMLAY == 0.077 BY == 0.077
X3 = RECTANGLE DMLAY == 0.12 BY == 0.12
Y = (X1 OR X2) OR X3
DMLAY NOT Y
}

DUMC_23_24_V1 {
@ Vx Dummy exact width is 0.07,0.077 or 0.12, where Vx=V1-V7.
@ xx Dummy must be square, where xx=V1-V7
CMACRO DUMC_23_24 V1DUM
}
DUMC_23_24_V2 {
@ Vx Dummy exact width is 0.07,0.077 or 0.12, where Vx=V1-V7.
@ xx Dummy must be square, where xx=V1-V7
CMACRO DUMC_23_24 V2DUM
}
DUMC_23_24_V3 {
@ Vx Dummy exact width is 0.07,0.077 or 0.12, where Vx=V1-V7.
@ xx Dummy must be square, where xx=V1-V7
CMACRO DUMC_23_24 V3DUM
}
DUMC_23_24_V4 {
@ Vx Dummy exact width is 0.07,0.077 or 0.12, where Vx=V1-V7.
@ xx Dummy must be square, where xx=V1-V7
CMACRO DUMC_23_24 V4DUM
}
DUMC_23_24_V5 {
@ Vx Dummy exact width is 0.07,0.077 or 0.12, where Vx=V1-V7.
@ xx Dummy must be square, where xx=V1-V7
CMACRO DUMC_23_24 V5DUM
}
DUMC_23_24_V6 {
@ Vx Dummy exact width is 0.07,0.077 or 0.12, where Vx=V1-V7.
@ xx Dummy must be square, where xx=V1-V7
CMACRO DUMC_23_24 V6DUM
}
DUMC_23_24_V7 {
@ Vx Dummy exact width is 0.07,0.077 or 0.12, where Vx=V1-V7.
@ xx Dummy must be square, where xx=V1-V7
CMACRO DUMC_23_24 V7DUM
}
DUMC_25_a_b_V1 {
@ Vx Dummy must be within Mx Dummy, where Vx=V1-V7 and Mx= metal level below Vx. >=0.06
@ Vx Dummy must be within My Dummy, where Vx=V1-V7 and My= metal level above Vx. >=0.06
  M1D_AND_M2D = M1DUM AND M2DUM
  ENC V1DUM M1D_AND_M2D < 0.06 ABUT < 90 SINGULAR REGION
  V1DUM NOT M1D_AND_M2D
}

DUMC_25_a_b_V2 {
@ Vx Dummy must be within Mx Dummy, where Vx=V1-V7 and Mx= metal level below Vx. >=0.06
@ Vx Dummy must be within My Dummy, where Vx=V1-V7 and My= metal level above Vx. >=0.06
  M2D_AND_M3D = M2DUM AND M3DUM
  ENC V2DUM M2D_AND_M3D < 0.06 ABUT < 90  SINGULAR REGION
  V2DUM NOT M2D_AND_M3D
}

DUMC_25_a_b_V3 {
@ Vx Dummy must be within Mx Dummy, where Vx=V1-V7 and Mx= metal level below Vx. >=0.06
@ Vx Dummy must be within My Dummy, where Vx=V1-V7 and My= metal level above Vx. >=0.06
  M3D_AND_M4D = M3DUM AND M4DUM
  ENC V3DUM M3D_AND_M4D < 0.06 ABUT < 90  SINGULAR REGION
  V3DUM NOT M3D_AND_M4D
}

DUMC_25_a_b_V4 {
@ Vx Dummy must be within Mx Dummy, where Vx=V1-V7 and Mx= metal level below Vx. >=0.06
@ Vx Dummy must be within My Dummy, where Vx=V1-V7 and My= metal level above Vx. >=0.06
  M4D_AND_M5D = M4DUM AND M5DUM
  ENC V4DUM M4D_AND_M5D < 0.06 ABUT < 90  SINGULAR REGION
  V4DUM NOT M4D_AND_M5D
}

DUMC_25_a_b_V5 {
@ Vx Dummy must be within Mx Dummy, where Vx=V1-V7 and Mx= metal level below Vx. >=0.06
@ Vx Dummy must be within My Dummy, where Vx=V1-V7 and My= metal level above Vx. >=0.06
  M5D_AND_M6D = M5DUM AND M6DUM
  ENC V5DUM M5D_AND_M6D < 0.06 ABUT < 90  SINGULAR REGION
  V5DUM NOT M5D_AND_M6D
}

DUMC_25_a_b_V6 {
@ Vx Dummy must be within Mx Dummy, where Vx=V1-V7 and Mx= metal level below Vx. >=0.06
@ Vx Dummy must be within My Dummy, where Vx=V1-V7 and My= metal level above Vx. >=0.06
  M6D_AND_M7D = M6DUM AND M7DUM
  ENC V6DUM M6D_AND_M7D < 0.06 ABUT < 90  SINGULAR REGION
  V6DUM NOT M6D_AND_M7D
}

DUMC_25_a_b_V7 {
@ Vx Dummy must be within Mx Dummy, where Vx=V1-V7 and Mx= metal level below Vx. >=0.06
@ Vx Dummy must be within My Dummy, where Vx=V1-V7 and My= metal level above Vx. >=0.06
  M7D_AND_M8D = M7DUM AND M8DUM
  ENC V7DUM M7D_AND_M8D < 0.06 ABUT < 90  SINGULAR REGION
  V7DUM NOT M7D_AND_M8D
}

DUMC_26 {
@ TMx Dummy space to (TMx, TMxDUB,PTCT), where TMx=TM1, TM2, >=0.6
  EXT TM2DUM TM2 < 0.6 ABUT < 90 SINGULAR REGION
  EXT TM2DUM TM2DUB < 0.6 ABUT < 90 SINGULAR REGION
  EXT TM2DUM PTCT < 0.6 ABUT < 90 SINGULAR REGION
}
DUMC_26a {
@ MTT2 Dummy(MTT2DM) space to (MTT2, MTT2DB,PTCT)	>=1.77
 EXT MTT2DM MTT2 < 1.77 ABUT < 90 SINGULAR REGION
 EXT MTT2DM MTT2DB < 1.77 ABUT < 90 SINGULAR REGION
 EXT MTT2DM PTCT < 1.77 ABUT < 90 SINGULAR REGION
}
DUMC_27 {
@ ALPA Dummy must not touch (ALPA, LOGO, PTCT,MARKS)
  ALDUM INTERACT (ALPAi OR LPM) 
}

DUMC_28 {
@ ALPA Dummy space to (ALPA, ALDUB,PTCT).>=2.84
  EXT ALDUM ALPAi < 2.84 ABUT < 90 SINGULAR REGION
  EXT ALDUM ALDUB < 2.84 ABUT < 90 SINGULAR REGION
  EXT ALDUM PTCT < 2.84 ABUT < 90 SINGULAR REGION
}

DUMC_29 {
@ ALPA Dummy space to INDMY with touching prohibited. >=2.84
  EXT ALDUM INDMY < 2.84 ABUT < 90 SINGULAR REGION
  ALDUM AND INDMY
}

DUMC_30_M1_density {
@ Maximum M1 Dummy density within INDMY.(Only check dummy metal density) <= 12%
 DENSITY_MARK = INDMY NOT MARKS
 CHECK_LAYER = (M1DUM AND INDMY) NOT MARKS
 CHECK_REGION = COPY DENSITY_MARK
 DENSITY CHECK_LAYER CHECK_REGION [AREA(CHECK_LAYER)/AREA(CHECK_REGION)] > 0.12 INSIDE OF LAYER DENSITY_MARK PRINT density_report_DUMC_30_M1.log RDB density_report_DUMC_30_M1.db
}

DUMC_30_M2_density {
@ Maximum M2 Dummy density within INDMY.(Only check dummy metal density) <= 12%
 DENSITY_MARK = INDMY NOT MARKS
 CHECK_LAYER = (M2DUM AND INDMY) NOT MARKS
 CHECK_REGION = COPY DENSITY_MARK
 DENSITY CHECK_LAYER CHECK_REGION [AREA(CHECK_LAYER)/AREA(CHECK_REGION)] > 0.12 INSIDE OF LAYER DENSITY_MARK PRINT density_report_DUMC_30_M2.log RDB density_report_DUMC_30_M2.db
}

DUMC_30_M3_density {
@ Maximum M3 Dummy density within INDMY.(Only check dummy metal density) <= 12%
 DENSITY_MARK = INDMY NOT MARKS
 CHECK_LAYER = (M3DUM AND INDMY) NOT MARKS
 CHECK_REGION = COPY DENSITY_MARK
 DENSITY CHECK_LAYER CHECK_REGION [AREA(CHECK_LAYER)/AREA(CHECK_REGION)] > 0.12 INSIDE OF LAYER DENSITY_MARK PRINT density_report_DUMC_30_M3.log RDB density_report_DUMC_30_M3.db
}

DUMC_30_M4_density {
@ Maximum M4 Dummy density within INDMY.(Only check dummy metal density) <= 12%
 DENSITY_MARK = INDMY NOT MARKS
 CHECK_LAYER = (M4DUM AND INDMY) NOT MARKS
 CHECK_REGION = COPY DENSITY_MARK
 DENSITY CHECK_LAYER CHECK_REGION [AREA(CHECK_LAYER)/AREA(CHECK_REGION)] > 0.12 INSIDE OF LAYER DENSITY_MARK PRINT density_report_DUMC_30_M4.log RDB density_report_DUMC_30_M4.db
}

DUMC_30_M5_density {
@ Maximum M5 Dummy density within INDMY.(Only check dummy metal density) <= 12%
 DENSITY_MARK = INDMY NOT MARKS
 CHECK_LAYER = (M5DUM AND INDMY) NOT MARKS
 CHECK_REGION = COPY DENSITY_MARK
 DENSITY CHECK_LAYER CHECK_REGION [AREA(CHECK_LAYER)/AREA(CHECK_REGION)] > 0.12 INSIDE OF LAYER DENSITY_MARK PRINT density_report_DUMC_30_M5.log RDB density_report_DUMC_30_M5.db
}

DUMC_30_M6_density {
@ Maximum M6 Dummy density within INDMY.(Only check dummy metal density) <= 12%
 DENSITY_MARK = INDMY NOT MARKS
 CHECK_LAYER = (M6DUM AND INDMY) NOT MARKS
 CHECK_REGION = COPY DENSITY_MARK
 DENSITY CHECK_LAYER CHECK_REGION [AREA(CHECK_LAYER)/AREA(CHECK_REGION)] > 0.12 INSIDE OF LAYER DENSITY_MARK PRINT density_report_DUMC_30_M6.log RDB density_report_DUMC_30_M6.db
}

DUMC_30_M7_density {
@ Maximum M7 Dummy density within INDMY.(Only check dummy metal density) <= 12%
 DENSITY_MARK = INDMY NOT MARKS
 CHECK_LAYER = (M7DUM AND INDMY) NOT MARKS
 CHECK_REGION = COPY DENSITY_MARK
 DENSITY CHECK_LAYER CHECK_REGION [AREA(CHECK_LAYER)/AREA(CHECK_REGION)] > 0.12 INSIDE OF LAYER DENSITY_MARK PRINT density_report_DUMC_30_M7.log RDB density_report_DUMC_30_M7.db
}

DUMC_30_M8_density {
@ Maximum M8 Dummy density within INDMY.(Only check dummy metal density) <= 12%
 DENSITY_MARK = INDMY NOT MARKS
 CHECK_LAYER = (M8DUM AND INDMY) NOT MARKS
 CHECK_REGION = COPY DENSITY_MARK
 DENSITY CHECK_LAYER CHECK_REGION [AREA(CHECK_LAYER)/AREA(CHECK_REGION)] > 0.12 INSIDE OF LAYER DENSITY_MARK PRINT density_report_DUMC_30_M8.log RDB density_report_DUMC_30_M8.db
}


#IFDEF UTM NO

DUMC_30_TM2_density {
@ Maximum TM2 Dummy density within INDMY.(Only check dummy metal density) <= 12%
 DENSITY_MARK = INDMY NOT MARKS
 CHECK_LAYER = (TM2DUM AND INDMY) NOT MARKS
 CHECK_REGION = COPY DENSITY_MARK
 DENSITY CHECK_LAYER CHECK_REGION [AREA(CHECK_LAYER)/AREA(CHECK_REGION)] > 0.12 INSIDE OF LAYER DENSITY_MARK PRINT density_report_DUMC_30_TM2.log RDB density_report_DUMC_30_TM2.db
}

#ENDIF

#IFDEF UTM YES

DUMC_30_MTT2_density {
@ Maximum MTT2 Dummy density within INDMY.(Only check dummy metal density) <= 12%
 DENSITY_MARK = INDMY NOT MARKS
 CHECK_LAYER = (MTT2DM AND INDMY) NOT MARKS
 CHECK_REGION = COPY DENSITY_MARK
 DENSITY CHECK_LAYER CHECK_REGION [AREA(CHECK_LAYER)/AREA(CHECK_REGION)] > 0.12 INSIDE OF LAYER DENSITY_MARK PRINT density_report_DUMC_30_MTT2.log RDB density_report_DUMC_30_MTT2.db
}

#ENDIF

DUMC_31 {
@ xx Dummy must be within BORDER, where xx=all metal and via levels, AA, GT.
  M1DUM NOT BD_WITHHOLE
  M2DUM NOT BD_WITHHOLE
  M3DUM NOT BD_WITHHOLE
  M4DUM NOT BD_WITHHOLE
  M5DUM NOT BD_WITHHOLE
  M6DUM NOT BD_WITHHOLE
  M7DUM NOT BD_WITHHOLE
  M8DUM NOT BD_WITHHOLE
  TM2DUM NOT BD_WITHHOLE
  MTT2DM NOT BD_WITHHOLE
  ALDUM NOT BD_WITHHOLE
  V1DUM NOT BD_WITHHOLE
  V2DUM NOT BD_WITHHOLE
  V3DUM NOT BD_WITHHOLE
  V4DUM NOT BD_WITHHOLE
  V5DUM NOT BD_WITHHOLE
  V6DUM NOT BD_WITHHOLE
  V7DUM NOT BD_WITHHOLE
  AADUM NOT BD_WITHHOLE
  GTDUM NOT BD_WITHHOLE
}

DUMC_32 {
@ Min. width of Mx Dummy, where Mx=M1-M8. >=0.22
  INT M1DUM < 0.22 ABUT < 90 SINGULAR REGION
  INT M2DUM < 0.22 ABUT < 90 SINGULAR REGION
  INT M3DUM < 0.22 ABUT < 90 SINGULAR REGION
  INT M4DUM < 0.22 ABUT < 90 SINGULAR REGION
  INT M5DUM < 0.22 ABUT < 90 SINGULAR REGION
  INT M6DUM < 0.22 ABUT < 90 SINGULAR REGION
  INT M7DUM < 0.22 ABUT < 90 SINGULAR REGION
  INT M8DUM < 0.22 ABUT < 90 SINGULAR REGION
}

DUMC_33_M1 {
@ Min. space of Mx Dummy, where Mx=M1-M8. >=0.22
  EXT M1DUM < 0.22 ABUT < 90 SINGULAR REGION
}

DUMC_33_M2 {
  EXT M2DUM < 0.22 ABUT < 90 SINGULAR REGION
}

DUMC_33_M3 {
  EXT M3DUM < 0.22 ABUT < 90 SINGULAR REGION
}

DUMC_33_M4 {
  EXT M4DUM < 0.22 ABUT < 90 SINGULAR REGION
}

DUMC_33_M5 {
  EXT M5DUM < 0.22 ABUT < 90 SINGULAR REGION
}

DUMC_33_M6 {
  EXT M6DUM < 0.22 ABUT < 90 SINGULAR REGION
}

DUMC_33_M7 {
  EXT M7DUM < 0.22 ABUT < 90 SINGULAR REGION
}

DUMC_33_M8 {
  EXT M8DUM < 0.22 ABUT < 90 SINGULAR REGION
}

DUMC_34 {
@ Min. width of TMx Dummy, where TMx=TM1-TM2. >=0.44
  INT TM2DUM < 0.44 ABUT < 90 SINGULAR REGION
}

DUMC_34a {
@ Min width of MTT2 Dummy is 1.5um.
  INT MTT2DM < 1.5 ABUT < 90 SINGULAR REGION
}

DUMC_35 {
@ Min. space of TMx Dummy, where TMx=TM1-TM2. >=0.6
  EXT TM2DUM < 0.6 ABUT < 90 SINGULAR REGION
}

DUMC_35a {
@ Min space of MTT2 Dummy is 1.0um.
  EXT MTT2DM < 1.0 ABUT < 90 SINGULAR REGION
}

DUMC_36 {
@ Min. width of ALPA Dummy. >=4.44
  INT ALDUM < 4.44 ABUT < 90 SINGULAR REGION
}

DUMC_37 {
@ Min. space of ALPA Dummy. >=2.84
  EXT ALDUM < 2.84 ABUT < 90 SINGULAR REGION
}
DUMC_40 {
@ Vx Dummy to Vx Dummy space is >= 0.13um.
  EXT V1DUM < 0.13 ABUT<90 SINGULAR REGION
  EXT V2DUM < 0.13 ABUT<90 SINGULAR REGION
  EXT V3DUM < 0.13 ABUT<90 SINGULAR REGION
  EXT V4DUM < 0.13 ABUT<90 SINGULAR REGION
  EXT V5DUM < 0.13 ABUT<90 SINGULAR REGION
  EXT V6DUM < 0.13 ABUT<90 SINGULAR REGION
  EXT V7DUM < 0.13 ABUT<90 SINGULAR REGION
}


//==================================
//  ULVT: Ultra Low Vt devices Rules
//==================================


ULVT_1{
@ ULVT width (Parallel side to side width) is >=0.33
INT ULVT <0.33 PARA ONLY  REGION  
}
ULVT_2{
@ Space between two ULVTs (with run length>0) is >=0.33
EXT ULVT< 0.33   ABUT<90 REGION OPPOSITE  

}
/*
ULVT_3{
@ AA with transistor enclosure by ULVT(include AA area not under poly) is >=0.19
ENC  MOS ULVT <0.19 ABUT<90 SINGULAR REGION
}
*/
ULVT_4{	
@ Gate enclosure by ULVT is > =0.14
ENC GATE ULVT < 0.14 ABUT<90 SINGULAR REGION
}
/*
ULVT_5{	
@ Space between ULVT and AA with device (include all the devices described in the design truth table 7.1.9) is >=0.19. Prohibit overlap of ULVT and other voltage AA with transistor.
  X_MOS = AA INTERACT GT
  X_RES = AA INTERACT (OR DIFRES RESAA RESNW)
  X_DIO1 = AA INTERACT (SIZE (DSTR NOT INTERACT PSUB) BY 0.3)
  X_DIO2 = AA INTERACT (SIZE (DSTR INTERACT PSUB) BY 0.4)
  X_NPN_PNP = AA INTERACT DMPNP
  X_ALL = (((X_MOS OR X_RES) OR (X_DIO1 OR X_DIO2)) OR X_NPN_PNP) NOT INST 
  EXT ULVT X_ALL < 0.19 ABUT<90 SINGULAR REGION
  (X_MOS CUT ULVT) AND ULVT
}
*/
ULVT_6{
@ Space between ULVT and Real gate  is >=0.14
EXT ULVT Real_GATE < 0.14 ABUT<90 SINGULAR REGION
}
ULVT_7{
@ ULVT area is >=0.463
AREA ULVT <0.463 
}
ULVT_8{
@ULVT enclosed area  > =0.463
 AREA ((HOLES ULVT INNER) NOT ULVT) < 0.463
}
ULVT_9{
@ Space between ULVT and (DG or TG) >=0.33
EXT ULVT (DG OR TG)<0.33 ABUT<90 SINGULAR REGION
}
/*
ULVT_10 {
@ 45-degree edge length is >= 0.5.
  ULVT_45 = ANGLE ULVT >= 44.9 <= 45.1
  LENGTH ULVT_45 < 0.5
}
*/
//=======================
//  Seal Ring Check
//=======================

GROUP GGRC  GRC_?

CT_SEAL = CTi AND MARKS
V1_SEAL = V1i AND MARKS
V2_SEAL = V2i AND MARKS
V3_SEAL = V3i AND MARKS
V4_SEAL = V4i AND MARKS
V5_SEAL = V5i AND MARKS
V6_SEAL = V6i AND MARKS
V7_SEAL = V7i AND MARKS
TV2_SEAL = TV2i AND MARKS
M1_SEAL = M1i AND MARKS
M2_SEAL = M2i AND MARKS
M3_SEAL = M3i AND MARKS
M4_SEAL = M4i AND MARKS
M5_SEAL = M5i AND MARKS
M6_SEAL = M6i AND MARKS
M7_SEAL = M7i AND MARKS
M8_SEAL = M8i AND MARKS
TM2_SEAL = TM2i AND MARKS
MTT2_SEAL = MTT2i AND MARKS
M1S_CORNER = M1_SEAL TOUCH (HOLES M1_SEAL) > 10
M2S_CORNER = M2_SEAL TOUCH (HOLES M2_SEAL) > 10
M3S_CORNER = M3_SEAL TOUCH (HOLES M3_SEAL) > 10
M4S_CORNER = M4_SEAL TOUCH (HOLES M4_SEAL) > 10
M5S_CORNER = M5_SEAL TOUCH (HOLES M5_SEAL) > 10
M6S_CORNER = M6_SEAL TOUCH (HOLES M6_SEAL) > 10
M7S_CORNER = M7_SEAL TOUCH (HOLES M7_SEAL) > 10
M8S_CORNER = M8_SEAL TOUCH (HOLES M8_SEAL) > 10
TM2S_CORNER = TM2_SEAL TOUCH (HOLES TM2_SEAL) > 10
MTT2S_CORNER = MTT2_SEAL TOUCH (HOLES MTT2_SEAL) > 10
M1S = M1_SEAL NOT M1S_CORNER
M2S = M2_SEAL NOT M2S_CORNER
M3S = M3_SEAL NOT M3S_CORNER
M4S = M4_SEAL NOT M4S_CORNER
M5S = M5_SEAL NOT M5S_CORNER
M6S = M6_SEAL NOT M6S_CORNER
M7S = M7_SEAL NOT M7S_CORNER
M8S = M8_SEAL NOT M8S_CORNER
TM2S = TM2_SEAL NOT TM2S_CORNER
MTT2S = MTT2_SEAL NOT MTT2S_CORNER

GRC_1 {
@ Contact slot width is fixed value 0.06um.
@ 45 degree part can have tolerance up to sqrt(2) times this value.
 CT_SEAL_SQ = RECTANGLE CT_SEAL
 CT_SEAL_LN = CT_SEAL NOT CT_SEAL_SQ
 CT_V_edge = ANGLE CT_SEAL_LN == 90
 CT_H_edge = ANGLE CT_SEAL_LN == 0
 CT_D_edge = ANGLE CT_SEAL_LN >44.9 <45.1
 X_V = INT CT_V_edge < 10 ABUT<90 OPPOSITE REGION
 X_H = INT CT_H_edge < 10 ABUT<90 OPPOSITE REGION
 X_D = INT CT_D_edge < 10 ABUT<90 OPPOSITE REGION
 INT CT_SEAL_LN < 0.059 ABUT<90 SINGULAR REGION
 X_V WITH WIDTH > 0.061
 X_H WITH WIDTH > 0.061
 X_D WITH WIDTH > 0.085
}
DMACRO SEAL2 VLAY {
 V_SEAL_SQ = RECTANGLE VLAY
 V_SEAL_LN = VLAY NOT V_SEAL_SQ
 V_V_edge = ANGLE V_SEAL_LN == 90
 V_H_edge = ANGLE V_SEAL_LN == 0
 V_D_edge = ANGLE V_SEAL_LN >44.9 <45.1
 X_V = INT V_V_edge < 10 ABUT<90 OPPOSITE REGION
 X_H = INT V_H_edge < 10 ABUT<90 OPPOSITE REGION
 X_D = INT V_D_edge < 10 ABUT<90 OPPOSITE REGION
 INT V_SEAL_LN < 0.069 ABUT<90 SINGULAR REGION
 X_V WITH WIDTH > 0.071
 X_H WITH WIDTH > 0.071
 X_D WITH WIDTH > 0.099
}
GRC_2_V1 {
@ V1 slot width is fixed value 0.07um.
@ 45 degree part can have tolerance up to sqrt(2) times this value.
 CMACRO SEAL2 V1_SEAL
}
GRC_2_V2 {
@ V2 slot width is fixed value 0.07um.
@ 45 degree part can have tolerance up to sqrt(2) times this value.
 CMACRO SEAL2 V2_SEAL
}
GRC_2_V3 {
@ V3 slot width is fixed value 0.07um.
@ 45 degree part can have tolerance up to sqrt(2) times this value.
 CMACRO SEAL2 V3_SEAL
}
GRC_2_V4 {
@ V4 slot width is fixed value 0.07um.
@ 45 degree part can have tolerance up to sqrt(2) times this value.
 CMACRO SEAL2 V4_SEAL
}
GRC_2_V5 {
@ V5 slot width is fixed value 0.07um.
@ 45 degree part can have tolerance up to sqrt(2) times this value.
 CMACRO SEAL2 V5_SEAL
}
GRC_2_V6 {
@ V6 slot width is fixed value 0.07um.
@ 45 degree part can have tolerance up to sqrt(2) times this value.
 CMACRO SEAL2 V6_SEAL
}
GRC_2_V7 {
@ V7 slot width is fixed value 0.07um.
@ 45 degree part can have tolerance up to sqrt(2) times this value.
 CMACRO SEAL2 V7_SEAL
}
GRC_3_TV2 {
@ TV2 slot width is fixed value 0.36um.
@ 45 degree part can have tolerance up to sqrt(2) times this value.
 TV2_SEAL_SQ = RECTANGLE TV2_SEAL
 TV2_SEAL_LN = TV2_SEAL NOT TV2_SEAL_SQ
 TV2_V_edge = ANGLE TV2_SEAL_LN == 90
 TV2_H_edge = ANGLE TV2_SEAL_LN == 0
 TV2_D_edge = ANGLE TV2_SEAL_LN >44.9 <45.1
 X_V = INT TV2_V_edge < 10 ABUT<90 OPPOSITE REGION
 X_H = INT TV2_H_edge < 10 ABUT<90 OPPOSITE REGION
 X_D = INT TV2_D_edge < 10 ABUT<90 OPPOSITE REGION
 INT TV2_SEAL_LN < 0.359 ABUT<90 SINGULAR REGION
 X_V WITH WIDTH > 0.361
 X_H WITH WIDTH > 0.361
 X_D WITH WIDTH > 0.510
}
GRC_4 {
@ Square contact size in seal ring must be 0.06um * 0.06um.
 X = RECTANGLE CT_SEAL
 NOT RECTANGLE X == 0.06 BY == 0.06
}
GRC_5 {
@ Square V1-V7 size in seal ring must be 0.07um * 0.07um.
 X1 = RECTANGLE V1_SEAL
 X2 = RECTANGLE V2_SEAL
 X3 = RECTANGLE V3_SEAL
 X4 = RECTANGLE V4_SEAL
 X5 = RECTANGLE V5_SEAL
 X6 = RECTANGLE V6_SEAL
 X7 = RECTANGLE V7_SEAL
 NOT RECTANGLE X1 == 0.07 BY == 0.07
 NOT RECTANGLE X2 == 0.07 BY == 0.07
 NOT RECTANGLE X3 == 0.07 BY == 0.07
 NOT RECTANGLE X4 == 0.07 BY == 0.07
 NOT RECTANGLE X5 == 0.07 BY == 0.07
 NOT RECTANGLE X6 == 0.07 BY == 0.07
 NOT RECTANGLE X7 == 0.07 BY == 0.07
}
GRC_6 {
@ Square TV size in seal ring must be 0.36um * 0.36um.
 X2 = RECTANGLE TV2_SEAL
 NOT RECTANGLE X2 == 0.36 BY == 0.36
}
GRC_7_M1 {
@ M1 width of ring4 is >= 5.556um.
  M1_RING4 = M1S TOUCH (HOLES M1S INNER)
  INT M1_RING4 < 5.555 ABUT<90 SINGULAR REGION
}
GRC_7_M2 {
@ M2 width of ring4 is >= 5.556um.
  M2_RING4 = M2S TOUCH (HOLES M2S INNER)
  INT M2_RING4 < 5.555 ABUT<90 SINGULAR REGION
}
GRC_7_M3 {
@ M3 width of ring4 is >= 5.556um.
  M3_RING4 = M3S TOUCH (HOLES M3S INNER)
  INT M3_RING4 < 5.555 ABUT<90 SINGULAR REGION
}
GRC_7_M4 {
@ M4 width of ring4 is >= 5.556um.
  M4_RING4 = M4S TOUCH (HOLES M4S INNER)
  INT M4_RING4 < 5.555 ABUT<90 SINGULAR REGION
}
GRC_7_M5 {
@ M5 width of ring4 is >= 5.556um.
  M5_RING4 = M5S TOUCH (HOLES M5S INNER)
  INT M5_RING4 < 5.555 ABUT<90 SINGULAR REGION
}
GRC_7_M6 {
@ M6 width of ring4 is >= 5.556um.
  M6_RING4 = M6S TOUCH (HOLES M6S INNER)
  INT M6_RING4 < 5.555 ABUT<90 SINGULAR REGION
}
GRC_7_M7 {
@ M7 width of ring4 is >= 5.556um.
  M7_RING4 = M7S TOUCH (HOLES M7S INNER)
  INT M7_RING4 < 5.555 ABUT<90 SINGULAR REGION
}
GRC_7_M8 {
@ M8 width of ring4 is >= 5.556um.
  M8_RING4 = M8S TOUCH (HOLES M8S INNER)
  INT M8_RING4 < 5.555 ABUT<90 SINGULAR REGION
}

DMACRO SEAL8a MLAY {
  M_RING4 = MLAY TOUCH (HOLES MLAY INNER)
  M_RING3 = MLAY TOUCH (HOLES (MLAY NOT M_RING4) INNER) 
  M_RING2 = MLAY TOUCH (HOLES (MLAY NOT (M_RING3 OR M_RING4)) INNER)
  M_RING1 = MLAY TOUCH (HOLES MLAY)
  INT M_RING1 < 1.665 ABUT<90 SINGULAR REGION
  INT M_RING2 < 1.665 ABUT<90 SINGULAR REGION
  INT M_RING3 < 1.665 ABUT<90 SINGULAR REGION
}  

GRC_8a_M1 {
@ M1 width of ring1,ring2,ring3 is >= 1.666um.
 CMACRO SEAL8a M1S
}
GRC_8a_M2 {
@ M2 width of ring1,ring2,ring3 is >= 1.666um.
 CMACRO SEAL8a M2S
}  
GRC_8a_M3 {
@ M3 width of ring1,ring2,ring3 is >= 1.666um.
 CMACRO SEAL8a M3S
}
GRC_8a_M4 {
@ M4 width of ring1,ring2,ring3 is >= 1.666um.
 CMACRO SEAL8a M4S
}
GRC_8a_M5 {
@ M5 width of ring1,ring2,ring3 is >= 1.666um.
 CMACRO SEAL8a M5S
}
GRC_8a_M6 {
@ M6 width of ring1,ring2,ring3 is >= 1.666um.
 CMACRO SEAL8a M6S
}
GRC_8a_M7 {
@ M7 width of ring1,ring2,ring3 is >= 1.666um.
 CMACRO SEAL8a M7S
}
GRC_8a_M8 {
@ M8 width of ring1,ring2,ring3 is >= 1.666um.
 CMACRO SEAL8a M8S
}
GRC_8b_TM2 {
@ TM2 width of ring1 is >= 4.445um.
  TM2_RING1 = TM2S TOUCH (HOLES TM2S)
  INT TM2_RING1 < 4.444 ABUT<90 SINGULAR REGION
}
GRC_8b_MTT2 {
@ MTT2 width of ring1 is >= 4.445um.
  MTT2_RING1 = MTT2S TOUCH (HOLES MTT2S)
  INT MTT2_RING1 < 4.444 ABUT<90 SINGULAR REGION
}
GRC_8c_TM2 {
@ TM1 width of ring2 and ring3 is >= 1.666um.
  TM2_RING1 = TM2S TOUCH (HOLES TM2S)
  TM2_RING3 = TM2S TOUCH (HOLES TM2S INNER)
  TM2_RING2 = TM2S TOUCH (HOLES (TM2S NOT (TM2_RING1 OR TM2_RING3)))
  INT TM2_RING2 < 1.665 ABUT<90 SINGULAR REGION
  INT TM2_RING3 < 1.665 ABUT<90 SINGULAR REGION
}
GRC_8c_MTT2 {
@ MTT2 width of ring2 and ring3 is >= 1.666um.
  MTT2_RING1 = MTT2S TOUCH (HOLES MTT2S)
  MTT2_RING3 = MTT2S TOUCH (HOLES MTT2S INNER)
  MTT2_RING2 = MTT2S TOUCH (HOLES (MTT2S NOT (MTT2_RING1 OR MTT2_RING3)))
  INT MTT2_RING2 < 1.665 ABUT<90 SINGULAR REGION
  INT MTT2_RING3 < 1.665 ABUT<90 SINGULAR REGION
}
GRC_9_M1 {
@ M1 width of in the dummy relief area is >= 0.444
  INT M1S_CORNER < 0.444 ABUT<90 SINGULAR REGION
}
GRC_9_M2 {
@ M2 width of in the dummy relief area is >= 0.444
  INT M2S_CORNER < 0.444 ABUT<90 SINGULAR REGION
}
GRC_9_M3 {
@ M3 width of in the dummy relief area is >= 0.444
  INT M3S_CORNER < 0.444 ABUT<90 SINGULAR REGION
}
GRC_9_M4 {
@ M4 width of in the dummy relief area is >= 0.444
  INT M4S_CORNER < 0.444 ABUT<90 SINGULAR REGION
}
GRC_9_M5 {
@ M5 width of in the dummy relief area is >= 0.444
  INT M5S_CORNER < 0.444 ABUT<90 SINGULAR REGION
}
GRC_9_M6 {
@ M6 width of in the dummy relief area is >= 0.444
  INT M6S_CORNER < 0.444 ABUT<90 SINGULAR REGION
}
GRC_9_M7 {
@ M7 width of in the dummy relief area is >= 0.444
  INT M7S_CORNER < 0.444 ABUT<90 SINGULAR REGION
}
GRC_9_M8 {
@ M8 width of in the dummy relief area is >= 0.444
  INT M8S_CORNER < 0.444 ABUT<90 SINGULAR REGION
}
GRC_9_TM2 {
@ TM2 width of in the dummy relief area is >= 0.444
  INT TM2S_CORNER < 0.444 ABUT<90 SINGULAR REGION
}
GRC_10 {
@ MTT2 width of in the dummy relief area is >= 1.666
  INT MTT2S_CORNER < 1.666 ABUT<90 SINGULAR REGION
}
GRC_11_M1 {
@ Space between metal for die corner dummy pattern for M1 in the die corner dummy relief area is >= 0.666um.
  EXT M1S_CORNER < 0.666 ABUT<90 SINGULAR REGION
}
GRC_11_M2 {
@ Space between metal for die corner dummy pattern for M2 in the die corner dummy relief area is >= 0.666um.
  EXT M2S_CORNER < 0.666 ABUT<90 SINGULAR REGION
}
GRC_11_M3 {
@ Space between metal for die corner dummy pattern for M3 in the die corner dummy relief area is >= 0.666um.
  EXT M3S_CORNER < 0.666 ABUT<90 SINGULAR REGION
}
GRC_11_M4 {
@ Space between metal for die corner dummy pattern for M4 in the die corner dummy relief area is >= 0.666um.
  EXT M4S_CORNER < 0.666 ABUT<90 SINGULAR REGION
}
GRC_11_M5 {
@ Space between metal for die corner dummy pattern for M5 in the die corner dummy relief area is >= 0.666um.
  EXT M5S_CORNER < 0.666 ABUT<90 SINGULAR REGION
}
GRC_11_M6 {
@ Space between metal for die corner dummy pattern for M6 in the die corner dummy relief area is >= 0.666um.
  EXT M6S_CORNER < 0.666 ABUT<90 SINGULAR REGION
}
GRC_11_M7 {
@ Space between metal for die corner dummy pattern for M7 in the die corner dummy relief area is >= 0.666um.
  EXT M7S_CORNER < 0.666 ABUT<90 SINGULAR REGION
}
GRC_11_M8 {
@ Space between metal for die corner dummy pattern for M8 in the die corner dummy relief area is >= 0.666um.
  EXT M8S_CORNER < 0.666 ABUT<90 SINGULAR REGION
}
GRC_12_TM2 {
@ Space between metal for die corner dummy pattern for TM2 in the die corner dummy relief area is >= 1.777um.
  DFM SPACE TM2S_CORNER < 1.777 BY EXT VERTICAL
}
GRC_12_MTT2 {
@ Space between metal for die corner dummy pattern for MTT2 in the die corner dummy relief area is >= 1.777um.
  DFM SPACE MTT2S_CORNER < 1.777 BY EXT VERTICAL
}

//============================
// SRAM Device Dimension Check 
//============================
GATE_INST = GATE INSIDE (SIZE INST by -1.5)
GATE_INST_PD = ((GATE_INST OUTSIDE NW) OUTSIDE SDOP) AND Real_GATE
GATE_INST_PG = ((GATE_INST OUTSIDE NW) INSIDE SDOP) AND Real_GATE
GATE_INST_PU =  (GATE_INST INSIDE NW) AND Real_GATE

SRDevice_1{
@ All Gates inside INST must be inside DNSRAM (SP299), LRSRAM (SP374), D2SRAM (DP589) or RFSRAM (DP741).
GATE_INST NOT INSIDE (((DNSRAM OR LRSRAM) OR D2SRAM) OR RFSRAM)
}
SRDEV_SP299_PD_W {
@ SP299 PD gate channel width FIX is 0.142 
LENGTH (GT COIN EDGE (GATE_INST_PD INSIDE DNSRAM)) != 0.142   
}
SRDEV_SP299_PD_L{
@ SP299 PD gate channel length is 0.055
LENGTH (AA COIN EDGE (GATE_INST_PD INSIDE DNSRAM)) != 0.055
}
SRDEV_SP299_PG_W {
@ SP299 PG gate channel width is 0.11
LENGTH (GT COIN EDGE (GATE_INST_PG INSIDE DNSRAM)) != 0.11
}
SRDEV_SP299_PG_L {
@ SP299 PG gate channel length is 0.059
LENGTH (AA COIN EDGE (GATE_INST_PG INSIDE DNSRAM)) != 0.059
}
SRDEV_SP299_PU_W {
@ SP299 PU gate channel width is 0.06
LENGTH (GT COIN EDGE (GATE_INST_PU INSIDE DNSRAM)) != 0.06
}
SRDEV_SP299_PU_L {
@  SP299 PU gate channel length	0.055
LENGTH (AA COIN EDGE (GATE_INST_PU INSIDE DNSRAM)) !=0.055
}
SRDEV_SP374_PD_W {
@ SP374 PD gate channel width is 0.233
 LENGTH (GT COIN EDGE (GATE_INST_PD INSIDE LRSRAM)) != 0.233
}
SRDEV_SP374_PD_L {
@ SP374 PD gate channel length fix is 0.055
LENGTH (AA COIN EDGE (GATE_INST_PD INSIDE LRSRAM)) != 0.055
}

SRDEV_SP374_PG_W {
@ SP374 PG gate channel width fix is 0.183
LENGTH (GT COIN EDGE (GATE_INST_PG INSIDE LRSRAM)) != 0.183
}
SRDEV_SP374_PG_L{
@ SP374 PG gate channel length fix is 0.063
LENGTH (AA COIN EDGE (GATE_INST_PG INSIDE LRSRAM)) != 0.063
}

SRDEV_SP374_PU_W {
@ SP374 PU gate channel width fix is 0.07
LENGTH (GT COIN EDGE (GATE_INST_PU INSIDE LRSRAM)) !=0.07
}
SRDEV_SP374_PU_L{
@ SP374 PU gate channel length fix is 0.055
LENGTH (AA COIN EDGE (GATE_INST_PU INSIDE LRSRAM)) != 0.055
}

SRDEV_DP589_PD_W {
@ DP589 PD gate channel width fix is 0.305
LENGTH (GT COIN EDGE (GATE_INST_PD INSIDE D2SRAM)) !=0.305
}
SRDEV_DP589_PD_L { 
@ DP589 PD gate channel length fix is 0.055
LENGTH (AA COIN EDGE (GATE_INST_PD INSIDE D2SRAM)) !=0.055
}
SRDEV_DP589_PG_W {
@ DP589 PG gate channel width fix is 0.154
LENGTH (GT COIN EDGE (GATE_INST_PG INSIDE D2SRAM)) !=0.154
}
SRDEV_DP589_PG_L {
@ DP589 PG gate channel length fix is 0.067
LENGTH (AA COIN EDGE (GATE_INST_PG INSIDE D2SRAM)) !=0.067
}
SRDEV_DP589_PU_W {
@ DP589 PU gate channel width fix is 0.06
LENGTH (GT COIN EDGE (GATE_INST_PU INSIDE D2SRAM)) !=0.06
}
SRDEV_DP589_PU_L{
@ DP589 PU gate channel length fix is 0.055
LENGTH (AA COIN EDGE (GATE_INST_PU INSIDE D2SRAM)) !=0.055
}

SRDEV_DP741_PD_W{
@ DP741 PD gate channel width fix is 0.438
LENGTH (GT COIN EDGE (GATE_INST_PD INSIDE RFSRAM)) !=0.438
}
SRDEV_DP741_PD_L{
@ DP741 PD gate channel length fix is 0.055
LENGTH (AA COIN EDGE (GATE_INST_PD INSIDE RFSRAM)) !=0.055
}
SRDEV_DP741_PG_W{
@ DP741 PG gate channel width fix is 0.168
LENGTH (GT COIN EDGE (GATE_INST_PG INSIDE RFSRAM)) !=0.168
}
SRDEV_DP741_PG_L {
@ DP741 PG gate channel length fix is 0.063
LENGTH (AA COIN EDGE (GATE_INST_PG INSIDE RFSRAM)) !=0.063
}
SRDEV_DP741_PU_W {
@ DP741 PU gate channel width fix is 0.08
LENGTH (GT COIN EDGE (GATE_INST_PU INSIDE RFSRAM)) !=0.08
}
SRDEV_DP741_PU_L {
@ DP741 PU gate channel length fix is 0.055
LENGTH (AA COIN EDGE (GATE_INST_PU INSIDE RFSRAM)) !=0.055
}

//============================
//  SRAM Marker Layer Check
//============================
GROUP GSRMarker SRMarker_?

SRMarker_4{
@ Marker layer DNSRAM, LRSRAM, D2SRAM, RFSRAM must be within SRAM marker INST.
(((DNSRAM OR LRSRAM) OR D2SRAM) OR RFSRAM) NOT INST 
}
SRMarker_5 {
@ For high performance SRAM bit cell(LRSRAM (SP374),  RFSRAM (DP741)), there must be high performance marker layer HPBL overlapped.
(LRSRAM OR RFSRAM) OUTSIDE  HPBL
}
SRMarker_6 {
@ No hole or slot is permitted in one SRAM marker layer(DNSRAM, LRSRAM, D2SRAM, RFSRAM, INST).
 HOLES INST
 HOLES DNSRAM
 HOLES LRSRAM
 HOLES D2SRAM
 HOLES RFSRAM
}
SRMarker_8 {
@ DNSRAM, LRSRAM, D2SRAM, RFSRAM should not overlap with each other(touch is permitted)
(((( (DNSRAM INTERACT LRSRAM) OR (DNSRAM INTERACT D2SRAM)) OR (DNSRAM INTERACT RFSRAM))OR (LRSRAM  INTERACT D2SRAM)) OR (LRSRAM  INTERACT RFSRAM))OR ( D2SRAM INTERACT RFSRAM)
}
SRMarker_9 {
@ No Overlap of (DNSRAM(SP299) or D2SRAM(DP589)) with HPBL is permitted.
(DNSRAM OR D2SRAM) AND  HPBL
}

#IFDEF BUMP YES
//==============================
// BUMP UBM pad design guideline 
//==============================
GROUP GBUMP BUMP_?

BUMP_1_G{
@ BUMP Pitch (center to center space) >=166.67	
X = EXTENTS BUMP CENTERS 0.01
EXT X<166.66  REGION
}

BUMP_2_G{
@ MD width(parallel edge to edge) inside BUMP  >=61.11
INT (MD INSIDE BUMP) <61.11  PARA ONLY  REGION 
}
BUMP_3_G {
@ BUMP width (parallel edge to edge) is >=88.89
INT BUMP < 88.89 ABUT<90 SINGULAR REGION OPPOSITE  SYMMETRIC
X = CONVEX EDGE BUMP < 2
INT X < 88.89 REGION
}
BUMP_4_G {
@ MD enclosed by BUMP >=15.56
ENC MD BUMP< 15.56 ABUT<90 SINGULAR REGION
}
BUMP_5_G{
@ BUMP enclosure by ALPA >=6.67
ENC BUMP ALPA_ALL < 6.67 ABUT<90 SINGULAR REGION OUTSIDE ALSO
}
BUMP_7_G{
@ BUMP space is >=77.78
 EXT BUMP <77.78 ABUT<90 SINGULAR REGION 
}
#ENDIF

#IFDEF INDUCTOR YES
//===================================
//  Inductor device layout guideline
//===================================

IND_R_6_G_density {
@ Maximum density of INDMY in whole chip is <= 5%.
  DENSITY_MARK = BORDER NOT MARKS
  CHECK_LAYER = INDMY NOT MARKS
  CHECK_REGION = COPY DENSITY_MARK
  DENSITY CHECK_LAYER CHECK_REGION [area(CHECK_LAYER)/area(CHECK_REGION)] > 0.05 PRINT density_report_IND_R_6_G.log RDB density_report_IND_R_6_G.db
}

Metal_density_IND = SIZE INDMY BY 16
IND_R_7_G_M1_density {
@ Maximum M1 density within (INDDMY SIZING 16 m) in window 125 m x 125 m, stepping 62.5 m is <= 85%.
  DENSITY_MARK = Metal_density_IND NOT MARKS
  CHECK_LAYER = M1i_all NOT MARKS
  CHECK_REGION = COPY DENSITY_MARK
  X = DENSITY CHECK_LAYER CHECK_REGION [area(CHECK_LAYER)/area(CHECK_REGION)] > 0.85 WINDOW 125 STEP 62.5 INSIDE OF LAYER DENSITY_MARK BACKUP PRINT density_report_IND_R_7_G_M1.log RDB density_report_IND_R_7_G_M1.db
  X NOT MARKS
}
IND_R_7_G_M2_density {
@ Maximum M2 density within (INDDMY SIZING 16 m) in window 125 m x 125 m, stepping 62.5 m is <= 85%.
  DENSITY_MARK = Metal_density_IND NOT MARKS
  CHECK_LAYER = M2i_all NOT MARKS
  CHECK_REGION = COPY DENSITY_MARK
  X = DENSITY CHECK_LAYER CHECK_REGION [area(CHECK_LAYER)/area(CHECK_REGION)] > 0.85 WINDOW 125 STEP 62.5 INSIDE OF LAYER DENSITY_MARK BACKUP PRINT density_report_IND_R_7_G_M2.log RDB density_report_IND_R_7_G_M2.db
  X NOT MARKS
}
IND_R_7_G_M3_density {
@ Maximum M3 density within (INDDMY SIZING 16 m) in window 125 m x 125 m, stepping 62.5 m is <= 85%.
  DENSITY_MARK = Metal_density_IND NOT MARKS
  CHECK_LAYER = M3i_all NOT MARKS
  CHECK_REGION = COPY DENSITY_MARK
  X = DENSITY CHECK_LAYER CHECK_REGION [area(CHECK_LAYER)/area(CHECK_REGION)] > 0.85 WINDOW 125 STEP 62.5 INSIDE OF LAYER DENSITY_MARK BACKUP PRINT density_report_IND_R_7_G_M3.log RDB density_report_IND_R_7_G_M3.db
  X NOT MARKS
}
IND_R_7_G_M4_density {
@ Maximum M4 density within (INDDMY SIZING 16 m) in window 125 m x 125 m, stepping 62.5 m is <= 85%.
  DENSITY_MARK = Metal_density_IND NOT MARKS
  CHECK_LAYER = M4i_all NOT MARKS
  CHECK_REGION = COPY DENSITY_MARK
  X = DENSITY CHECK_LAYER CHECK_REGION [area(CHECK_LAYER)/area(CHECK_REGION)] > 0.85 WINDOW 125 STEP 62.5 INSIDE OF LAYER DENSITY_MARK BACKUP PRINT density_report_IND_R_7_G_M4.log RDB density_report_IND_R_7_G_M4.db
  X NOT MARKS
}
IND_R_7_G_M5_density {
@ Maximum M5 density within (INDDMY SIZING 16 m) in window 125 m x 125 m, stepping 62.5 m is <= 85%.
  DENSITY_MARK = Metal_density_IND NOT MARKS
  CHECK_LAYER = M5i_all NOT MARKS
  CHECK_REGION = COPY DENSITY_MARK
  X = DENSITY CHECK_LAYER CHECK_REGION [area(CHECK_LAYER)/area(CHECK_REGION)] > 0.85 WINDOW 125 STEP 62.5 INSIDE OF LAYER DENSITY_MARK BACKUP PRINT density_report_IND_R_7_G_M5.log RDB density_report_IND_R_7_G_M5.db
  X NOT MARKS
}
IND_R_7_G_M6_density {
@ Maximum M6 density within (INDDMY SIZING 16 m) in window 125 m x 125 m, stepping 62.5 m is <= 85%.
  DENSITY_MARK = Metal_density_IND NOT MARKS
  CHECK_LAYER = M6i_all NOT MARKS
  CHECK_REGION = COPY DENSITY_MARK
  X = DENSITY CHECK_LAYER CHECK_REGION [area(CHECK_LAYER)/area(CHECK_REGION)] > 0.85 WINDOW 125 STEP 62.5 INSIDE OF LAYER DENSITY_MARK BACKUP PRINT density_report_IND_R_7_G_M6.log RDB density_report_IND_R_7_G_M6.db
  X NOT MARKS
}
IND_R_7_G_M7_density {
@ Maximum M7 density within (INDDMY SIZING 16 m) in window 125 m x 125 m, stepping 62.5 m is <= 85%.
  DENSITY_MARK = Metal_density_IND NOT MARKS
  CHECK_LAYER = M7i_all NOT MARKS
  CHECK_REGION = COPY DENSITY_MARK
  X = DENSITY CHECK_LAYER CHECK_REGION [area(CHECK_LAYER)/area(CHECK_REGION)] > 0.85 WINDOW 125 STEP 62.5 INSIDE OF LAYER DENSITY_MARK BACKUP PRINT density_report_IND_R_7_G_M7.log RDB density_report_IND_R_7_G_M7.db
  X NOT MARKS
}
IND_R_7_G_M8_density {
@ Maximum M8 density within (INDDMY SIZING 16 m) in window 125 m x 125 m, stepping 62.5 m is <= 85%.
  DENSITY_MARK = Metal_density_IND NOT MARKS
  CHECK_LAYER = M8i_all NOT MARKS
  CHECK_REGION = COPY DENSITY_MARK
  X = DENSITY CHECK_LAYER CHECK_REGION [area(CHECK_LAYER)/area(CHECK_REGION)] > 0.85 WINDOW 125 STEP 62.5 INSIDE OF LAYER DENSITY_MARK BACKUP PRINT density_report_IND_R_7_G_M8.log RDB density_report_IND_R_7_G_M8.db
  X NOT MARKS
}

IND_R_8_G_M1_density {
@ M1 metal density over the whole chip (include INDDMY) is >= 20%.
  DENSITY_MARK = BORDER NOT MARKS
  CHECK_LAYER = M1i_all NOT MARKS
  CHECK_REGION = COPY DENSITY_MARK
  X =DENSITY CHECK_LAYER CHECK_REGION [area(CHECK_LAYER)/area(CHECK_REGION)] < 0.2 PRINT density_report_IND_R_8_G_M1.log RDB density_report_IND_R_8_G_M1.db
  X NOT MARKS
}
IND_R_8_G_M2_density {
@ M2 metal density over the whole chip (include INDDMY) is >= 20%.
  DENSITY_MARK = BORDER NOT MARKS
  CHECK_LAYER = M2i_all NOT MARKS
  CHECK_REGION = COPY DENSITY_MARK
  X =DENSITY CHECK_LAYER CHECK_REGION [area(CHECK_LAYER)/area(CHECK_REGION)] < 0.2 PRINT density_report_IND_R_8_G_M2.log RDB density_report_IND_R_8_G_M2.db
  X NOT MARKS
}
IND_R_8_G_M3_density {
@ M3 metal density over the whole chip (include INDDMY) is >= 20%.
  DENSITY_MARK = BORDER NOT MARKS
  CHECK_LAYER = M3i_all NOT MARKS
  CHECK_REGION = COPY DENSITY_MARK
  X =DENSITY CHECK_LAYER CHECK_REGION [area(CHECK_LAYER)/area(CHECK_REGION)] < 0.2 PRINT density_report_IND_R_8_G_M3.log RDB density_report_IND_R_8_G_M3.db
  X NOT MARKS
}
IND_R_8_G_M4_density {
@ M4 metal density over the whole chip (include INDDMY) is >= 20%.
  DENSITY_MARK = BORDER NOT MARKS
  CHECK_LAYER = M4i_all NOT MARKS
  CHECK_REGION = COPY DENSITY_MARK
  X =DENSITY CHECK_LAYER CHECK_REGION [area(CHECK_LAYER)/area(CHECK_REGION)] < 0.2 PRINT density_report_IND_R_8_G_M4.log RDB density_report_IND_R_8_G_M4.db
  X NOT MARKS
}
IND_R_8_G_M5_density {
@ M5 metal density over the whole chip (include INDDMY) is >= 20%.
  DENSITY_MARK = BORDER NOT MARKS
  CHECK_LAYER = M5i_all NOT MARKS
  CHECK_REGION = COPY DENSITY_MARK
  X =DENSITY CHECK_LAYER CHECK_REGION [area(CHECK_LAYER)/area(CHECK_REGION)] < 0.2 PRINT density_report_IND_R_8_G_M5.log RDB density_report_IND_R_8_G_M5.db
  X NOT MARKS
}
IND_R_8_G_M6_density {
@ M6 metal density over the whole chip (include INDDMY) is >= 20%.
  DENSITY_MARK = BORDER NOT MARKS
  CHECK_LAYER = M6i_all NOT MARKS
  CHECK_REGION = COPY DENSITY_MARK
  X =DENSITY CHECK_LAYER CHECK_REGION [area(CHECK_LAYER)/area(CHECK_REGION)] < 0.2 PRINT density_report_IND_R_8_G_M6.log RDB density_report_IND_R_8_G_M6.db
  X NOT MARKS
}
IND_R_8_G_M7_density {
@ M7 metal density over the whole chip (include INDDMY) is >= 20%.
  DENSITY_MARK = BORDER NOT MARKS
  CHECK_LAYER = M7i_all NOT MARKS
  CHECK_REGION = COPY DENSITY_MARK
  X =DENSITY CHECK_LAYER CHECK_REGION [area(CHECK_LAYER)/area(CHECK_REGION)] < 0.2 PRINT density_report_IND_R_8_G_M7.log RDB density_report_IND_R_8_G_M7.db
  X NOT MARKS
}
IND_R_8_G_M8_density {
@ M8 metal density over the whole chip (include INDDMY) is >= 20%.
  DENSITY_MARK = BORDER NOT MARKS
  CHECK_LAYER = M8i_all NOT MARKS
  CHECK_REGION = COPY DENSITY_MARK
  X =DENSITY CHECK_LAYER CHECK_REGION [area(CHECK_LAYER)/area(CHECK_REGION)] < 0.2 PRINT density_report_IND_R_8_G_M8.log RDB density_report_IND_R_8_G_M8.db
  X NOT MARKS
}

#IFDEF UTM NO
IND_R_8_G_TM2_density {
@ TM2 metal density over the whole chip (include INDDMY) is >= 20%.
  DENSITY_MARK = BORDER NOT MARKS
  CHECK_LAYER = TM2i_all NOT MARKS
  CHECK_REGION = COPY DENSITY_MARK
  X =DENSITY CHECK_LAYER CHECK_REGION [area(CHECK_LAYER)/area(CHECK_REGION)] < 0.2 PRINT density_report_IND_R_8_G_TM2.log RDB density_report_IND_R_8_G_TM2.db
  X NOT MARKS
}
IND_R_9_G_l_TM2_density {
@ TM2 density range in window 200um x 200um, stepping 100um. is >=15% 
@ The following special regions are excluded while the density checking: PA,MARKS, LOGO,INDMY 
@ This rule is only applied while the width of (checking window NOT excluded region) >=50um.
  DENSITY_MARK = ((((BORDER NOT PA) NOT MARKS) NOT LOGO) NOT INDMY) WITH WIDTH >= 50
  CHECK_LAYER = TM2i_all AND DENSITY_MARK
  CHECK_REGION = COPY DENSITY_MARK
  DENSITY CHECK_LAYER CHECK_REGION [area(CHECK_LAYER)/area(CHECK_REGION)] < 0.15 WINDOW 200 STEP 100 BACKUP PRINT density_report_IND_R_9_G_l_TM2.log RDB density_report_IND_R_9_G_l_TM2.db
}
IND_R_9_G_h_TM2_density {
@ TM2 density range in window 200um x 200um, stepping 100um. is <=85% 
@ The following special regions are excluded while the density checking: PA,MARKS, LOGO,INDMY 
@ This rule is only applied while the width of (checking window NOT excluded region) >=50um.
  DENSITY_MARK = ((((BORDER NOT PA) NOT MARKS) NOT LOGO) NOT INDMY) WITH WIDTH >= 50
  CHECK_LAYER = TM2i_all AND DENSITY_MARK
  CHECK_REGION = COPY DENSITY_MARK  
  DENSITY CHECK_LAYER CHECK_REGION [area(CHECK_LAYER)/area(CHECK_REGION)] > 0.85 WINDOW 200 STEP 100 BACKUP PRINT density_report_IND_R_9_G_h_TM2.log RDB density_report_IND_R_9_G_h_TM2.db
}
#ENDIF

#IFDEF UTM YES
IND_R_8_G_MTT2_density {
@ MTT2 metal density over the whole chip (include INDDMY) is >= 20%.
  DENSITY_MARK = BORDER NOT MARKS
  CHECK_LAYER = MTT2i_all NOT MARKS
  CHECK_REGION = COPY DENSITY_MARK
  X =DENSITY CHECK_LAYER CHECK_REGION [area(CHECK_LAYER)/area(CHECK_REGION)] < 0.2 PRINT density_report_IND_R_8_G_MTT2.log RDB density_report_IND_R_8_G_MTT2.db
  X NOT MARKS
}
IND_R_9_G_l_MTT2_density {
@ MTT2 density range in window 200um x 200um, stepping 100um. is >=15% 
@ The following special regions are excluded while the density checking: PA,MARKS, LOGO,INDMY 
@ This rule is only applied while the width of (checking window NOT excluded region) >=50um.
  DENSITY_MARK = ((((BORDER NOT PA) NOT MARKS) NOT LOGO) NOT INDMY) WITH WIDTH >= 50
  CHECK_LAYER = MTT2i_all AND DENSITY_MARK
  CHECK_REGION = COPY DENSITY_MARK
  DENSITY CHECK_LAYER CHECK_REGION [area(CHECK_LAYER)/area(CHECK_REGION)] < 0.15 WINDOW 200 STEP 100 BACKUP PRINT density_report_IND_R_9_G_l_MTT2.log RDB density_report_IND_R_9_G_l_MTT2.db
}
IND_R_9_G_h_MTT2_density {
@ MTT2 density range in window 200um x 200um, stepping 100um. is <=85% 
@ The following special regions are excluded while the density checking: PA,MARKS, LOGO,INDMY 
@ This rule is only applied while the width of (checking window NOT excluded region) >=50um.
  DENSITY_MARK = ((((BORDER NOT PA) NOT MARKS) NOT LOGO) NOT INDMY) WITH WIDTH >= 50
  CHECK_LAYER = MTT2i_all AND DENSITY_MARK
  CHECK_REGION = COPY DENSITY_MARK  
  DENSITY CHECK_LAYER CHECK_REGION [area(CHECK_LAYER)/area(CHECK_REGION)] > 0.85 WINDOW 200 STEP 100 BACKUP PRINT density_report_IND_R_9_G_h_MTT2.log RDB density_report_IND_R_9_G_h_MTT2.db
}
#ENDIF

IND_R_10_G_density {
@ Maximum density of INDMY in window 1600 m x 1600 m, stepping 800 m is <= 14%.
  DENSITY_MARK = BORDER NOT MARKS
  CHECK_LAYER = INDMY NOT MARKS
  CHECK_REGION = COPY DENSITY_MARK
  X = DENSITY CHECK_LAYER CHECK_REGION [area(CHECK_LAYER)/area(CHECK_REGION)] > 0.14 WINDOW 1600 STEP 800 BACKUP PRINT density_report_IND_R_10_G.log RDB density_report_IND_R_10_G.db
  X NOT MARKS
}
#ENDIF

//=====================================
//  MOM device layout guideline
//=====================================
}

VERBATIM {
#IFDEF MOM_4_CHECK YES
}


RULECHECK MOM_4_G {
@ MOMDMY and MOMMKn  layers are must for MOM device

set MOMMK_list { MOMMK1, MOMMK2, MOMMK3, MOMMK4, MOMMK5, MOMMK6, MOMMK7, MOMMK8 }
set momcap_list { 12 13 14 15 16 17 18 23 24 25 26 27 28 34 35 36 37 38 45 46 47 48 56 57 58 67 68 78 }

foreach k $momcap_list {
SETLAYER  MOMMK1_${k} = MOMMK1 INTERACT (MOMDMY WITH TEXT \"momcap${k}\" MOMDMY)
SETLAYER  MOMMK2_${k} = MOMMK2 INTERACT (MOMDMY WITH TEXT \"momcap${k}\" MOMDMY)
SETLAYER  MOMMK3_${k} = MOMMK3 INTERACT (MOMDMY WITH TEXT \"momcap${k}\" MOMDMY)
SETLAYER  MOMMK4_${k} = MOMMK4 INTERACT (MOMDMY WITH TEXT \"momcap${k}\" MOMDMY)
SETLAYER  MOMMK5_${k} = MOMMK5 INTERACT (MOMDMY WITH TEXT \"momcap${k}\" MOMDMY)
SETLAYER  MOMMK6_${k} = MOMMK6 INTERACT (MOMDMY WITH TEXT \"momcap${k}\" MOMDMY)
SETLAYER  MOMMK7_${k} = MOMMK7 INTERACT (MOMDMY WITH TEXT \"momcap${k}\" MOMDMY)
SETLAYER  MOMMK8_${k} = MOMMK8 INTERACT (MOMDMY WITH TEXT \"momcap${k}\" MOMDMY)
}

foreach k $momcap_list {
SETLAYER  MOMMK1_${k}_no = MOMMK1 INTERACT (MOMDMY NOT WITH TEXT \"momcap${k}\" MOMDMY)
SETLAYER  MOMMK2_${k}_no = MOMMK2 INTERACT (MOMDMY NOT WITH TEXT \"momcap${k}\" MOMDMY)
SETLAYER  MOMMK3_${k}_no = MOMMK3 INTERACT (MOMDMY NOT WITH TEXT \"momcap${k}\" MOMDMY)
SETLAYER  MOMMK4_${k}_no = MOMMK4 INTERACT (MOMDMY NOT WITH TEXT \"momcap${k}\" MOMDMY)
SETLAYER  MOMMK5_${k}_no = MOMMK5 INTERACT (MOMDMY NOT WITH TEXT \"momcap${k}\" MOMDMY)
SETLAYER  MOMMK6_${k}_no = MOMMK6 INTERACT (MOMDMY NOT WITH TEXT \"momcap${k}\" MOMDMY)
SETLAYER  MOMMK7_${k}_no = MOMMK7 INTERACT (MOMDMY NOT WITH TEXT \"momcap${k}\" MOMDMY)
SETLAYER  MOMMK8_${k}_no = MOMMK8 INTERACT (MOMDMY NOT WITH TEXT \"momcap${k}\" MOMDMY)
}

foreach k $momcap_list {
SETLAYER  MOMDMY_${k} = MOMDMY WITH TEXT \"momcap${k}\" MOMDMY
SETLAYER  MOMDMY_${k}_no = MOMDMY NOT WITH TEXT \"momcap${k}\" MOMDMY
}

########## can't be marked with MOMMK1
  set momcap_list1 [lrange $momcap_list 7 end]
#RULECHECK T1 {
foreach k $momcap_list1 {
OUTLAYER  (MOMMK1 AND MOMMK1_${k}) NOT MARKS
}
#}

########## can't be marked with MOMMK2
  set momcap_list2 [lrange $momcap_list 13 end]
#RULECHECK T2 {
foreach k $momcap_list2 {
OUTLAYER  (MOMMK2 AND MOMMK2_${k}) NOT MARKS
}
#}

########## can't be marked with MOMMK3
  set momcap_list3 [lrange $momcap_list 18 end]
#RULECHECK T3 {
OUTLAYER  (MOMMK3 AND MOMMK3_12) NOT MARKS
foreach k $momcap_list3 {
OUTLAYER  (MOMMK3 AND MOMMK3_${k}) NOT MARKS
}
#}

########## can't be marked with MOMMK4
set momcap_list4 [lrange $momcap_list 22 end]
#RULECHECK T4 {
OUTLAYER  (MOMMK4 AND MOMMK4_12) NOT MARKS 
OUTLAYER  (MOMMK4 AND MOMMK4_13) NOT MARKS 
OUTLAYER  (MOMMK4 AND MOMMK4_23) NOT MARKS 
foreach k $momcap_list4 {
OUTLAYER  (MOMMK4 AND MOMMK4_${k}) NOT MARKS
}
#}

########## can't be marked with MOMMK5
set momcap_list5 [lrange $momcap_list 25 end]
#RULECHECK T5 {
OUTLAYER  (MOMMK5 AND MOMMK5_12) NOT MARKS 
OUTLAYER  (MOMMK5 AND MOMMK5_13) NOT MARKS 
OUTLAYER  (MOMMK5 AND MOMMK5_14) NOT MARKS 
OUTLAYER  (MOMMK5 AND MOMMK5_23) NOT MARKS 
OUTLAYER  (MOMMK5 AND MOMMK5_24) NOT MARKS 
OUTLAYER  (MOMMK5 AND MOMMK5_34) NOT MARKS 
foreach k $momcap_list5 {
OUTLAYER  (MOMMK5 AND MOMMK5_${k}) NOT MARKS
}
#}

########## can't be marked with MOMMK6
set momcap_list6 { 12 13 14 15 23 24 25 34 35 45 78 }
#RULECHECK T6 {
foreach k $momcap_list6 {
OUTLAYER  (MOMMK6 AND MOMMK6_${k}) NOT MARKS
}
#}

########## can't be marked with MOMMK7
set momcap_list7 { 12 13 14 15 16 23 24 25 26 34 35 36 45 46 56 }
#RULECHECK T7 {
foreach k $momcap_list7 {
OUTLAYER  (MOMMK7 AND MOMMK7_${k}) NOT MARKS
}
#}

########## can't be marked with MOMMK8
set momcap_list8 { 12 13 14 15 16 17 23 24 25 26 27 34 35 36 37 45 46 47 56 57 67 }
#RULECHECK T8 {
foreach k $momcap_list8 {
OUTLAYER  (MOMMK8 AND MOMMK8_${k}) NOT MARKS
}
#}
#############################################################################################


########## should be but not be marked with MOMMK1
#RULECHECK Y12 {
SETLAYER  X12 = (MOMDMY_12 INTERACT MOMMK1) INTERACT MOMMK2
OUTLAYER  (MOMDMY_12 NOT X12) NOT MARKS
#}

#RULECHECK Y13 {
SETLAYER  X13 = ((MOMDMY_13 INTERACT MOMMK1) INTERACT MOMMK2) INTERACT MOMMK3
OUTLAYER  (MOMDMY_13 NOT X13) NOT MARKS
#}

#RULECHECK Y14 {
SETLAYER  X14 = (((MOMDMY_14 INTERACT MOMMK1) INTERACT MOMMK2) INTERACT MOMMK3) INTERACT MOMMK4
OUTLAYER  (MOMDMY_14 NOT X14) NOT MARKS
#}

#RULECHECK Y15 {
SETLAYER  X15 = ((((MOMDMY_15 INTERACT MOMMK1) INTERACT MOMMK2) INTERACT MOMMK3) INTERACT MOMMK4) INTERACT MOMMK5
OUTLAYER  (MOMDMY_15 NOT X15) NOT MARKS
#}

#RULECHECK Y16 {
SETLAYER  X16 = (((((MOMDMY_16 INTERACT MOMMK1) INTERACT MOMMK2) INTERACT MOMMK3) INTERACT MOMMK4) INTERACT MOMMK5) INTERACT MOMMK6
OUTLAYER  (MOMDMY_16 NOT X16) NOT MARKS
#}

#RULECHECK Y17 {
SETLAYER  X17 = ((((((MOMDMY_17 INTERACT MOMMK1) INTERACT MOMMK2) INTERACT MOMMK3) INTERACT MOMMK4) INTERACT MOMMK5) INTERACT MOMMK6) INTERACT MOMMK7
OUTLAYER  (MOMDMY_17 NOT X17) NOT MARKS
#}

#RULECHECK Y18 {
SETLAYER  X18 = (((((((MOMDMY_18 INTERACT MOMMK1) INTERACT MOMMK2) INTERACT MOMMK3) INTERACT MOMMK4) INTERACT MOMMK5) INTERACT MOMMK6) INTERACT MOMMK7) INTERACT MOMMK8
OUTLAYER  (MOMDMY_18 NOT X18) NOT MARKS
#}

#RULECHECK Y23 {
SETLAYER  X23 = (MOMDMY_23 INTERACT MOMMK2) INTERACT MOMMK3 
OUTLAYER  (MOMDMY_23 NOT X23) NOT MARKS
#}

#RULECHECK Y24 {
SETLAYER  X24 = ((MOMDMY_24 INTERACT MOMMK2) INTERACT MOMMK3) INTERACT MOMMK4
OUTLAYER  (MOMDMY_24 NOT X24) NOT MARKS
#}

#RULECHECK Y25 {
SETLAYER  X25 = (((MOMDMY_25 INTERACT MOMMK2) INTERACT MOMMK3) INTERACT MOMMK4) INTERACT MOMMK5
OUTLAYER  (MOMDMY_25 NOT X25) NOT MARKS
#}

#RULECHECK Y26 {
SETLAYER  X26 = ((((MOMDMY_26 INTERACT MOMMK2) INTERACT MOMMK3) INTERACT MOMMK4) INTERACT MOMMK5) INTERACT MOMMK6
OUTLAYER  (MOMDMY_26 NOT X26) NOT MARKS
#}

#RULECHECK Y27 {
SETLAYER  X27 = (((((MOMDMY_27 INTERACT MOMMK2) INTERACT MOMMK3) INTERACT MOMMK4) INTERACT MOMMK5) INTERACT MOMMK6) INTERACT MOMMK7
OUTLAYER  (MOMDMY_27 NOT X27) NOT MARKS
#}

#RULECHECK Y28 {
SETLAYER  X28 = ((((((MOMDMY_28 INTERACT MOMMK2) INTERACT MOMMK3) INTERACT MOMMK4) INTERACT MOMMK5) INTERACT MOMMK6) INTERACT MOMMK7) INTERACT MOMMK8
OUTLAYER  (MOMDMY_28 NOT X28) NOT MARKS
#}

#RULECHECK Y34 {
SETLAYER  X34 = (MOMDMY_34 INTERACT MOMMK3) INTERACT MOMMK4
OUTLAYER  (MOMDMY_34 NOT X34) NOT MARKS
#}

#RULECHECK Y35 {
SETLAYER  X35 = ((MOMDMY_35 INTERACT MOMMK3) INTERACT MOMMK4) INTERACT MOMMK5
OUTLAYER  (MOMDMY_35 NOT X35) NOT MARKS
#}

#RULECHECK Y36 {
SETLAYER  X36 = (((MOMDMY_36 INTERACT MOMMK3) INTERACT MOMMK4) INTERACT MOMMK5) INTERACT MOMMK6
OUTLAYER  (MOMDMY_36 NOT X36) NOT MARKS
#}

#RULECHECK Y37 {
SETLAYER  X37 = ((((MOMDMY_37 INTERACT MOMMK3) INTERACT MOMMK4) INTERACT MOMMK5) INTERACT MOMMK6) INTERACT MOMMK7
OUTLAYER  (MOMDMY_37 NOT X37) NOT MARKS
#}

#RULECHECK Y38 {
SETLAYER  X38 = (((((MOMDMY_38 INTERACT MOMMK3) INTERACT MOMMK4) INTERACT MOMMK5) INTERACT MOMMK6) INTERACT MOMMK7) INTERACT MOMMK8
OUTLAYER  (MOMDMY_38 NOT X38) NOT MARKS
#}

#RULECHECK Y45 {
SETLAYER  X45 = (MOMDMY_45 INTERACT MOMMK4) INTERACT MOMMK5
OUTLAYER  (MOMDMY_45 NOT X45) NOT MARKS
#}

#RULECHECK Y46 {
SETLAYER  X46 = ((MOMDMY_46 INTERACT MOMMK4) INTERACT MOMMK5) INTERACT MOMMK6
OUTLAYER  (MOMDMY_46 NOT X46) NOT MARKS
#}

#RULECHECK Y47 {
SETLAYER  X47 = (((MOMDMY_47 INTERACT MOMMK4) INTERACT MOMMK5) INTERACT MOMMK6) INTERACT MOMMK7
OUTLAYER  (MOMDMY_47 NOT X47) NOT MARKS
#}

#RULECHECK Y48 {
SETLAYER  X48 = ((((MOMDMY_48 INTERACT MOMMK4) INTERACT MOMMK5) INTERACT MOMMK6) INTERACT MOMMK7) INTERACT MOMMK8
OUTLAYER  (MOMDMY_48 NOT X48) NOT MARKS
#}

#RULECHECK Y56 {
SETLAYER  X56 = (MOMDMY_56 INTERACT MOMMK5) INTERACT MOMMK6
OUTLAYER  (MOMDMY_56 NOT X56) NOT MARKS
#}

#RULECHECK Y57 {
SETLAYER  X57 = ((MOMDMY_57 INTERACT MOMMK5) INTERACT MOMMK6) INTERACT MOMMK7
OUTLAYER  (MOMDMY_57 NOT X57) NOT MARKS
#}

#RULECHECK Y58 {
SETLAYER  X58 = (((MOMDMY_58 INTERACT MOMMK5) INTERACT MOMMK6) INTERACT MOMMK7) INTERACT MOMMK8
OUTLAYER  (MOMDMY_58 NOT X58) NOT MARKS
#}

#RULECHECK Y67 {
SETLAYER  X67 = (MOMDMY_67 INTERACT MOMMK6) INTERACT MOMMK7
OUTLAYER  (MOMDMY_67 NOT X67) NOT MARKS
#}

#RULECHECK Y68 {
SETLAYER  X68 = ((MOMDMY_68 INTERACT MOMMK6) INTERACT MOMMK7) INTERACT MOMMK8
OUTLAYER  (MOMDMY_68 NOT X68) NOT MARKS
#}

#RULECHECK Y78 {
SETLAYER  X78 = (MOMDMY_78 INTERACT MOMMK7) INTERACT MOMMK8
OUTLAYER  (MOMDMY_78 NOT X78) NOT MARKS
#}

######################################################################################

#########MOMDMY not with correspond text

SETLAYER  Z12 = ((MOMDMY INTERACT MOMMK1) INTERACT MOMMK2) NOT INTERACT (OR MOMMK3 MOMMK4 MOMMK5 MOMMK6 MOMMK7 MOMMK8)
OUTLAYER  (Z12 NOT WITH TEXT \"momcap12\" MOMDMY) NOT MARKS

SETLAYER  Z13 = (((MOMDMY INTERACT MOMMK1) INTERACT MOMMK2) INTERACT MOMMK3) NOT INTERACT (OR MOMMK4 MOMMK5 MOMMK6 MOMMK7 MOMMK8)
OUTLAYER  (Z13 NOT WITH TEXT \"momcap13\" MOMDMY) NOT MARKS 

SETLAYER  Z14 = ((((MOMDMY INTERACT MOMMK1) INTERACT MOMMK2) INTERACT MOMMK3) INTERACT MOMMK4) NOT INTERACT (OR MOMMK5 MOMMK6 MOMMK7 MOMMK8)
OUTLAYER  (Z14 NOT WITH TEXT \"momcap14\" MOMDMY) NOT MARKS 

SETLAYER  Z15 = (((((MOMDMY INTERACT MOMMK1) INTERACT MOMMK2) INTERACT MOMMK3) INTERACT MOMMK4) INTERACT MOMMK5) NOT INTERACT (OR MOMMK6 MOMMK7 MOMMK8)
OUTLAYER  (Z15 NOT WITH TEXT \"momcap15\" MOMDMY) NOT MARKS  

SETLAYER  Z16 = ((((((MOMDMY INTERACT MOMMK1) INTERACT MOMMK2) INTERACT MOMMK3) INTERACT MOMMK4) INTERACT MOMMK5) INTERACT MOMMK6) NOT INTERACT (OR MOMMK7 MOMMK8)
OUTLAYER  (Z16 NOT WITH TEXT \"momcap16\" MOMDMY) NOT MARKS

SETLAYER  Z17 = (((((((MOMDMY INTERACT MOMMK1) INTERACT MOMMK2) INTERACT MOMMK3) INTERACT MOMMK4) INTERACT MOMMK5) INTERACT MOMMK6) INTERACT MOMMK7) NOT INTERACT MOMMK8
OUTLAYER  (Z17 NOT WITH TEXT \"momcap17\" MOMDMY) NOT MARKS

SETLAYER  Z18 = (((((((MOMDMY INTERACT MOMMK1) INTERACT MOMMK2) INTERACT MOMMK3) INTERACT MOMMK4) INTERACT MOMMK5) INTERACT MOMMK6) INTERACT MOMMK7) INTERACT MOMMK8
OUTLAYER  (Z18 NOT WITH TEXT \"momcap18\" MOMDMY) NOT MARKS

SETLAYER  Z23 = ((MOMDMY INTERACT MOMMK2) INTERACT MOMMK3) NOT INTERACT (OR MOMMK1 MOMMK4 MOMMK5 MOMMK6 MOMMK7 MOMMK8)
OUTLAYER  (Z23 NOT WITH TEXT \"momcap23\" MOMDMY) NOT MARKS

SETLAYER  Z24 = (((MOMDMY INTERACT MOMMK2) INTERACT MOMMK3) INTERACT MOMMK4) NOT INTERACT (OR MOMMK1 MOMMK5 MOMMK6 MOMMK7 MOMMK8)
OUTLAYER  (Z24 NOT WITH TEXT \"momcap24\" MOMDMY) NOT MARKS

SETLAYER  Z25 = ((((MOMDMY INTERACT MOMMK2) INTERACT MOMMK3) INTERACT MOMMK4) INTERACT MOMMK5) NOT INTERACT (OR MOMMK1 MOMMK6 MOMMK7 MOMMK8)
OUTLAYER  (Z25 NOT WITH TEXT \"momcap25\" MOMDMY) NOT MARKS

SETLAYER  Z26 = (((((MOMDMY INTERACT MOMMK2) INTERACT MOMMK3) INTERACT MOMMK4) INTERACT MOMMK5) INTERACT MOMMK6) NOT INTERACT (OR MOMMK1 MOMMK7 MOMMK8)
OUTLAYER  (Z26 NOT WITH TEXT \"momcap26\" MOMDMY) NOT MARKS

SETLAYER  Z27 = ((((((MOMDMY INTERACT MOMMK2) INTERACT MOMMK3) INTERACT MOMMK4) INTERACT MOMMK5) INTERACT MOMMK6) INTERACT MOMMK7) NOT INTERACT (OR MOMMK1 MOMMK8)
OUTLAYER  (Z27 NOT WITH TEXT \"momcap27\" MOMDMY) NOT MARKS

SETLAYER  Z28 = (((((((MOMDMY INTERACT MOMMK2) INTERACT MOMMK3) INTERACT MOMMK4) INTERACT MOMMK5) INTERACT MOMMK6) INTERACT MOMMK7) INTERACT MOMMK8) NOT INTERACT MOMMK1
OUTLAYER  (Z28 NOT WITH TEXT \"momcap28\" MOMDMY) NOT MARKS

SETLAYER  Z34 = ((MOMDMY INTERACT MOMMK3) INTERACT MOMMK4) NOT INTERACT (OR MOMMK1 MOMMK2 MOMMK5 MOMMK6 MOMMK7 MOMMK8)
OUTLAYER  (Z34 NOT WITH TEXT \"momcap34\" MOMDMY) NOT MARKS

SETLAYER  Z35 = (((MOMDMY INTERACT MOMMK3) INTERACT MOMMK4) INTERACT MOMMK5) NOT INTERACT (OR MOMMK1 MOMMK2 MOMMK6 MOMMK7 MOMMK8)
OUTLAYER  (Z35 NOT WITH TEXT \"momcap35\" MOMDMY) NOT MARKS

SETLAYER  Z36 = ((((MOMDMY INTERACT MOMMK3) INTERACT MOMMK4) INTERACT MOMMK5) INTERACT MOMMK6) NOT INTERACT (OR MOMMK1 MOMMK2 MOMMK7 MOMMK8)
OUTLAYER  (Z36 NOT WITH TEXT \"momcap36\" MOMDMY) NOT MARKS

SETLAYER  Z37 = (((((MOMDMY INTERACT MOMMK3) INTERACT MOMMK4) INTERACT MOMMK5) INTERACT MOMMK6) INTERACT MOMMK7) NOT INTERACT (OR MOMMK1 MOMMK2 MOMMK8)
OUTLAYER  (Z37 NOT WITH TEXT \"momcap37\" MOMDMY) NOT MARKS

SETLAYER  Z38 = ((((((MOMDMY INTERACT MOMMK3) INTERACT MOMMK4) INTERACT MOMMK5) INTERACT MOMMK6) INTERACT MOMMK7) INTERACT MOMMK8) NOT INTERACT (OR MOMMK1 MOMMK2)
OUTLAYER  (Z38 NOT WITH TEXT \"momcap38\" MOMDMY) NOT MARKS

SETLAYER  Z45 = ((MOMDMY INTERACT MOMMK4) INTERACT MOMMK5) NOT INTERACT (OR MOMMK1 MOMMK2 MOMMK3 MOMMK6 MOMMK7 MOMMK8)
OUTLAYER  (Z45 NOT WITH TEXT \"momcap45\" MOMDMY) NOT MARKS

SETLAYER  Z46 = (((MOMDMY INTERACT MOMMK4) INTERACT MOMMK5) INTERACT MOMMK6) NOT INTERACT (OR MOMMK1 MOMMK2 MOMMK3 MOMMK7 MOMMK8)
OUTLAYER  (Z46 NOT WITH TEXT \"momcap46\" MOMDMY) NOT MARKS

SETLAYER  Z47 = ((((MOMDMY INTERACT MOMMK4) INTERACT MOMMK5) INTERACT MOMMK6) INTERACT MOMMK7) NOT INTERACT (OR MOMMK1 MOMMK2 MOMMK3 MOMMK8)
OUTLAYER  (Z47 NOT WITH TEXT \"momcap47\" MOMDMY) NOT MARKS

SETLAYER  Z48 = (((((MOMDMY INTERACT MOMMK4) INTERACT MOMMK5) INTERACT MOMMK6) INTERACT MOMMK7) INTERACT MOMMK8) NOT INTERACT (OR MOMMK1 MOMMK2 MOMMK3)
OUTLAYER  (Z48 NOT WITH TEXT \"momcap48\" MOMDMY) NOT MARKS

SETLAYER  Z56 = ((MOMDMY INTERACT MOMMK5) INTERACT MOMMK6) NOT INTERACT (OR MOMMK1 MOMMK2 MOMMK3 MOMMK4 MOMMK7 MOMMK8)
OUTLAYER  (Z56 NOT WITH TEXT \"momcap56\" MOMDMY) NOT MARKS

SETLAYER  Z57 = (((MOMDMY INTERACT MOMMK5) INTERACT MOMMK6) INTERACT MOMMK7) NOT INTERACT (OR MOMMK1 MOMMK2 MOMMK3 MOMMK4 MOMMK8)
OUTLAYER  (Z57 NOT WITH TEXT \"momcap57\" MOMDMY) NOT MARKS

SETLAYER  Z58 = ((((MOMDMY INTERACT MOMMK5) INTERACT MOMMK6) INTERACT MOMMK7) INTERACT MOMMK8) NOT INTERACT (OR MOMMK1 MOMMK2 MOMMK3 MOMMK4)
OUTLAYER  (Z58 NOT WITH TEXT \"momcap58\" MOMDMY) NOT MARKS

SETLAYER  Z67 = ((MOMDMY INTERACT MOMMK6) INTERACT MOMMK7) NOT INTERACT (OR MOMMK1 MOMMK2 MOMMK3 MOMMK4 MOMMK5 MOMMK8)
OUTLAYER  (Z67 NOT WITH TEXT \"momcap67\" MOMDMY) NOT MARKS

SETLAYER  Z68 = (((MOMDMY INTERACT MOMMK6) INTERACT MOMMK7) INTERACT MOMMK8) NOT INTERACT (OR MOMMK1 MOMMK2 MOMMK3 MOMMK4 MOMMK5)
OUTLAYER  (Z68 NOT WITH TEXT \"momcap68\" MOMDMY) NOT MARKS

SETLAYER  Z78 = ((MOMDMY INTERACT MOMMK7) INTERACT MOMMK8) NOT INTERACT (OR MOMMK1 MOMMK2 MOMMK3 MOMMK4 MOMMK5 MOMMK6)
OUTLAYER  (Z78 NOT WITH TEXT \"momcap78\" MOMDMY) NOT MARKS
}

VERBATIM {
#ENDIF
}

VERBATIM {
#IFDEF MOM_5_6_CHECK YES
}

VERBATIM {
#IFDEF TOPMETAL 9
}
RULECHECK MOM_5_G {
@ It is not allowed:
@ 1)V1 in MOMMK1 
@ 2)Vn/Vn-1 in MOMMKn (n=2~8), whereVn-1 is the via underneath Mn, and Vn is the via above Mn. Vn can be inter-via or TV1 or TV2.

for { set j 1 } { $j <= 7 } { incr j } {
OUTLAYER (V${j}i AND MOMMK${j}) NOT MARKS
OUTLAYER (V${j}i AND MOMMK[expr $j +1]) NOT MARKS
}
OUTLAYER (TV2i AND MOMMK8) NOT MARKS
}
VERBATIM {
#ENDIF
}

VERBATIM {
#IFDEF TOPMETAL 8
}
RULECHECK MOM_5_G {
@ It is not allowed:
@ 1)V1 in MOMMK1 
@ 2)Vn/Vn-1 in MOMMKn (n=2~8), whereVn-1 is the via underneath Mn, and Vn is the via above Mn. Vn can be inter-via or TV1 or TV2.

for { set j 1 } { $j <= 6 } { incr j } {
OUTLAYER (V${j}i AND MOMMK${j}) NOT MARKS
OUTLAYER (V${j}i AND MOMMK[expr $j +1]) NOT MARKS
}
OUTLAYER (TV2i AND MOMMK7) NOT MARKS
}
VERBATIM {
#ENDIF
}

VERBATIM {
#IFDEF TOPMETAL 7
}
RULECHECK MOM_5_G {
@ It is not allowed:
@ 1)V1 in MOMMK1 
@ 2)Vn/Vn-1 in MOMMKn (n=2~8), whereVn-1 is the via underneath Mn, and Vn is the via above Mn. Vn can be inter-via or TV1 or TV2.

for { set j 1 } { $j <= 5 } { incr j } {
OUTLAYER (V${j}i AND MOMMK${j}) NOT MARKS
OUTLAYER (V${j}i AND MOMMK[expr $j +1]) NOT MARKS
}
OUTLAYER (TV2i AND MOMMK6) NOT MARKS
}
VERBATIM {
#ENDIF
}

VERBATIM {
#IFDEF TOPMETAL 6
}
RULECHECK MOM_5_G {
@ It is not allowed:
@ 1)V1 in MOMMK1 
@ 2)Vn/Vn-1 in MOMMKn (n=2~8), whereVn-1 is the via underneath Mn, and Vn is the via above Mn. Vn can be inter-via or TV1 or TV2.

for { set j 1 } { $j <= 4 } { incr j } {
OUTLAYER (V${j}i AND MOMMK${j}) NOT MARKS
OUTLAYER (V${j}i AND MOMMK[expr $j +1]) NOT MARKS
}
OUTLAYER (TV2i AND MOMMK5) NOT MARKS
}
VERBATIM {
#ENDIF
}

VERBATIM {
#IFDEF TOPMETAL 5
}
RULECHECK MOM_5_G {
@ It is not allowed:
@ 1)V1 in MOMMK1 
@ 2)Vn/Vn-1 in MOMMKn (n=2~8), whereVn-1 is the via underneath Mn, and Vn is the via above Mn. Vn can be inter-via or TV1 or TV2.

for { set j 1 } { $j <= 3 } { incr j } {
OUTLAYER (V${j}i AND MOMMK${j}) NOT MARKS
OUTLAYER (V${j}i AND MOMMK[expr $j +1]) NOT MARKS
}
OUTLAYER (TV2i AND MOMMK4) NOT MARKS
}
VERBATIM {
#ENDIF
}

VERBATIM {
#IFDEF TOPMETAL 4
}
RULECHECK MOM_5_G {
@ It is not allowed:
@ 1)V1 in MOMMK1 
@ 2)Vn/Vn-1 in MOMMKn (n=2~8), whereVn-1 is the via underneath Mn, and Vn is the via above Mn. Vn can be inter-via or TV1 or TV2.

for { set j 1 } { $j <= 2 } { incr j } {
OUTLAYER (V${j}i AND MOMMK${j}) NOT MARKS
OUTLAYER (V${j}i AND MOMMK[expr $j +1]) NOT MARKS
}
OUTLAYER (TV2i AND MOMMK3) NOT MARKS
}
VERBATIM {
#ENDIF
}

VERBATIM {
#IFDEF TOPMETAL 9
}
RULECHECK MOM_6_G {
@ The space between (Mn AND MOMMKn AND MOMDMY) and Vn /Vn-1 (n=1~8) outside of MOMDMY, 
@ whereVn-1 is the via underneath Mn, and Vn is the via above Mn. Vn can be inter-via or TV1 or TV2.	≥	0.08	um

set j 1
for { } { $j <= 7 } { incr j } {
SETLAYER M${j}_MOM = M${j}i AND (MOMMK${j} AND MOMDMY)
SETLAYER V${j}_NOMOM = V${j}i OUTSIDE MOMDMY
OUTLAYER (EXT M${j}_MOM V${j}_NOMOM < 0.08 ABUT < 90 SINGULAR REGION MEASURE ALL) NOT MARKS
OUTLAYER (EXT M[expr $j +1]_MOM V${j}_NOMOM < 0.08 ABUT < 90 SINGULAR REGION MEASURE ALL) NOT MARKS
}
SETLAYER M${j}_MOM = M${j}i AND (MOMMK${j} AND MOMDMY)
OUTLAYER (EXT M${j}_MOM (TV2i OUTSIDE MOMDMY) < 0.08 ABUT < 90 SINGULAR REGION MEASURE ALL) NOT MARKS
}
VERBATIM {
#ENDIF
}

VERBATIM {
#IFDEF TOPMETAL 8
}
RULECHECK MOM_6_G {
@ The space between (Mn AND MOMMKn AND MOMDMY) and Vn /Vn-1 (n=1~8) outside of MOMDMY, 
@ whereVn-1 is the via underneath Mn, and Vn is the via above Mn. Vn can be inter-via or TV1 or TV2.	≥	0.08	um

set j 1
for { } { $j <= 6 } { incr j } {
SETLAYER M${j}_MOM = M${j}i AND (MOMMK${j} AND MOMDMY)
SETLAYER V${j}_NOMOM = V${j}i OUTSIDE MOMDMY
OUTLAYER (EXT M${j}_MOM V${j}_NOMOM < 0.08 ABUT < 90 SINGULAR REGION MEASURE ALL) NOT MARKS
OUTLAYER (EXT M[expr $j +1]_MOM V${j}_NOMOM < 0.08 ABUT < 90 SINGULAR REGION MEASURE ALL) NOT MARKS
}
SETLAYER M${j}_MOM = M${j}i AND (MOMMK${j} AND MOMDMY)
OUTLAYER (EXT M${j}_MOM (TV2i OUTSIDE MOMDMY) < 0.08 ABUT < 90 SINGULAR REGION MEASURE ALL) NOT MARKS
}
VERBATIM {
#ENDIF
}

VERBATIM {
#IFDEF TOPMETAL 7
}
RULECHECK MOM_6_G {
@ The space between (Mn AND MOMMKn AND MOMDMY) and Vn /Vn-1 (n=1~8) outside of MOMDMY, 
@ whereVn-1 is the via underneath Mn, and Vn is the via above Mn. Vn can be inter-via or TV1 or TV2.	≥	0.08	um

set j 1
for { } { $j <= 5 } { incr j } {
SETLAYER M${j}_MOM = M${j}i AND (MOMMK${j} AND MOMDMY)
SETLAYER V${j}_NOMOM = V${j}i OUTSIDE MOMDMY
OUTLAYER (EXT M${j}_MOM V${j}_NOMOM < 0.08 ABUT < 90 SINGULAR REGION MEASURE ALL) NOT MARKS
OUTLAYER (EXT M[expr $j +1]_MOM V${j}_NOMOM < 0.08 ABUT < 90 SINGULAR REGION MEASURE ALL) NOT MARKS
}
SETLAYER M${j}_MOM = M${j}i AND (MOMMK${j} AND MOMDMY)
OUTLAYER (EXT M${j}_MOM (TV2i OUTSIDE MOMDMY) < 0.08 ABUT < 90 SINGULAR REGION MEASURE ALL) NOT MARKS
}
VERBATIM {
#ENDIF
}

VERBATIM {
#IFDEF TOPMETAL 6
}
RULECHECK MOM_6_G {
@ The space between (Mn AND MOMMKn AND MOMDMY) and Vn /Vn-1 (n=1~8) outside of MOMDMY, 
@ whereVn-1 is the via underneath Mn, and Vn is the via above Mn. Vn can be inter-via or TV1 or TV2.	≥	0.08	um

set j 1
for { } { $j <= 4 } { incr j } {
SETLAYER M${j}_MOM = M${j}i AND (MOMMK${j} AND MOMDMY)
SETLAYER V${j}_NOMOM = V${j}i OUTSIDE MOMDMY
OUTLAYER (EXT M${j}_MOM V${j}_NOMOM < 0.08 ABUT < 90 SINGULAR REGION MEASURE ALL) NOT MARKS
OUTLAYER (EXT M[expr $j +1]_MOM V${j}_NOMOM < 0.08 ABUT < 90 SINGULAR REGION MEASURE ALL) NOT MARKS
}
SETLAYER M${j}_MOM = M${j}i AND (MOMMK${j} AND MOMDMY)
OUTLAYER (EXT M${j}_MOM (TV2i OUTSIDE MOMDMY) < 0.08 ABUT < 90 SINGULAR REGION MEASURE ALL) NOT MARKS
}
VERBATIM {
#ENDIF
}

VERBATIM {
#IFDEF TOPMETAL 5
}
RULECHECK MOM_6_G {
@ The space between (Mn AND MOMMKn AND MOMDMY) and Vn /Vn-1 (n=1~8) outside of MOMDMY, 
@ whereVn-1 is the via underneath Mn, and Vn is the via above Mn. Vn can be inter-via or TV1 or TV2.	≥	0.08	um

set j 1
for { } { $j <= 3 } { incr j } {
SETLAYER M${j}_MOM = M${j}i AND (MOMMK${j} AND MOMDMY)
SETLAYER V${j}_NOMOM = V${j}i OUTSIDE MOMDMY
OUTLAYER (EXT M${j}_MOM V${j}_NOMOM < 0.08 ABUT < 90 SINGULAR REGION MEASURE ALL) NOT MARKS
OUTLAYER (EXT M[expr $j +1]_MOM V${j}_NOMOM < 0.08 ABUT < 90 SINGULAR REGION MEASURE ALL) NOT MARKS
}
SETLAYER M${j}_MOM = M${j}i AND (MOMMK${j} AND MOMDMY)
OUTLAYER (EXT M${j}_MOM (TV2i OUTSIDE MOMDMY) < 0.08 ABUT < 90 SINGULAR REGION MEASURE ALL) NOT MARKS
}
VERBATIM {
#ENDIF
}

VERBATIM {
#IFDEF TOPMETAL 4
}
RULECHECK MOM_6_G {
@ The space between (Mn AND MOMMKn AND MOMDMY) and Vn /Vn-1 (n=1~8) outside of MOMDMY, 
@ whereVn-1 is the via underneath Mn, and Vn is the via above Mn. Vn can be inter-via or TV1 or TV2.	≥	0.08	um

set j 1
for { } { $j <= 2 } { incr j } {
SETLAYER M${j}_MOM = M${j}i AND (MOMMK${j} AND MOMDMY)
SETLAYER V${j}_NOMOM = V${j}i OUTSIDE MOMDMY
OUTLAYER (EXT M${j}_MOM V${j}_NOMOM < 0.08 ABUT < 90 SINGULAR REGION MEASURE ALL) NOT MARKS
OUTLAYER (EXT M[expr $j +1]_MOM V${j}_NOMOM < 0.08 ABUT < 90 SINGULAR REGION MEASURE ALL) NOT MARKS
}
SETLAYER M${j}_MOM = M${j}i AND (MOMMK${j} AND MOMDMY)
OUTLAYER (EXT M${j}_MOM (TV2i OUTSIDE MOMDMY) < 0.08 ABUT < 90 SINGULAR REGION MEASURE ALL) NOT MARKS
}
VERBATIM {
#ENDIF
}

VERBATIM {
#ENDIF
}

VERBATIM {
#IFDEF DUP YES
//=====================================
//DUP (Device Under Pad) Pad Guidelines
//=====================================

GROUP GDUP DUP_?
DUP_area = DUPMK1 AND MD
DUP_1_G {
@ For MD that interacts with DUPMK1, this piece of MD must be fully covered by DUPMK1.
 (MD INTERACT DUPMK1) NOT DUPMK1
}
#IFDEF TOPMETAL 4

DUP_2_G_M3 {
@ Two metal layers (TM and TM-1) are needed in DUP pad area, these two metal layers design must be solid.
DUP_area ENCLOSE (DUP_area NOT M3)
}
DUP_3a_G{
@ ALPAR, MOMDMY, INDMY, TM2R, TM-1R(TM-1 resistor mark layer) must be outside of DUP pad area.
((((ALPAR OR MOMDMY) OR INDMY) OR TM2R) OR M3R ) AND DUP_area

}
DUP_4_G{
@ TV-1 pattern must be outside of DUP pad area
V2 AND DUP_area
}

#ENDIF

#IFDEF TOPMETAL 5

DUP_2_G_M4 {
@ Two metal layers (TM and TM-1) are needed in DUP pad area, these two metal layers design must be solid.
DUP_area ENCLOSE (DUP_area NOT M4)
}
DUP_3a_G{
@ ALPAR, MOMDMY, INDMY, TM2R, TM-1R(TM-1 resistor mark layer) must be outside of DUP pad area.
((((ALPAR OR MOMDMY) OR INDMY) OR TM2R) OR M4R ) AND DUP_area

}
DUP_4_G{
@ TV-1 pattern must be outside of DUP pad area
V3 AND DUP_area
}

#ENDIF
#IFDEF TOPMETAL 6
DUP_2_G_M5 {
@ Two metal layers (TM and TM-1) are needed in DUP pad area, these two metal layers design must be solid.
DUP_area ENCLOSE (DUP_area NOT M5)
}
DUP_3a_G{
@ ALPAR, MOMDMY, INDMY, TM2R, TM-1R(TM-1 resistor mark layer) must be outside of DUP pad area.
((((ALPAR OR MOMDMY) OR INDMY) OR TM2R) OR M5R ) AND DUP_area

}
DUP_4_G{
@ TV-1 pattern must be outside of DUP pad area
V4 AND DUP_area
}

#ENDIF
#IFDEF TOPMETAL 7
DUP_2_G_M6 {
@ Two metal layers (TM and TM-1) are needed in DUP pad area, these two metal layers design must be solid.
DUP_area ENCLOSE (DUP_area NOT M6)
}
DUP_3a_G{
@ ALPAR, MOMDMY, INDMY, TM2R, TM-1R(TM-1 resistor mark layer) must be outside of DUP pad area.
((((ALPAR OR MOMDMY) OR INDMY) OR TM2R) OR M6R ) AND DUP_area

}
DUP_4_G{
@ TV-1 pattern must be outside of DUP pad area
V5 AND DUP_area
}


#ENDIF
#IFDEF TOPMETAL 8
DUP_2_G_M7 {
@ Two metal layers (TM and TM-1) are needed in DUP pad area, these two metal layers design must be solid.
DUP_area ENCLOSE (DUP_area NOT M7)
}
DUP_3a_G{
@ ALPAR, MOMDMY, INDMY, TM2R, TM-1R(TM-1 resistor mark layer) must be outside of DUP pad area.
((((ALPAR OR MOMDMY) OR INDMY) OR TM2R) OR M7R ) AND DUP_area

}
DUP_4_G{
@ TV-1 pattern must be outside of DUP pad area
V6 AND DUP_area
}


#ENDIF
#IFDEF TOPMETAL 9
DUP_2_G_M8 {
@ Two metal layers (TM and TM-1) are needed in DUP pad area, these two metal layers design must be solid.
DUP_area ENCLOSE (DUP_area NOT M8)
}
DUP_3a_G{
@ ALPAR, MOMDMY, INDMY, TM2R, TM-1R(TM-1 resistor mark layer) must be outside of DUP pad area.
((((ALPAR OR MOMDMY) OR INDMY) OR TM2R) OR M8R ) AND DUP_area

}
DUP_4_G{
@ TV-1 pattern must be outside of DUP pad area
V7 AND DUP_area
}

#ENDIF
#IFDEF UTM NO

DUP_2_G_TM2 {
@ Two metal layers (TM and TM-1) are needed in DUP pad area, these two metal layers design must be solid.
DUP_area ENCLOSE (DUP_area NOT TM2 )
  
}
#ENDIF
#IFDEF UTM YES
DUP_2_G_MTT2 {
@ Two metal layers (TM and TM-1) are needed in DUP pad area, these two metal layers design must be solid.
DUP_area ENCLOSE (DUP_area NOT  MTT2) 
}
#ENDIF

DUP_5_G{
@ DUP pad area must have TV array between TM and TM-1.
@ Two Via areas whose space is within 0.56um are considered to be in the same array.
@ TV space within array in DUP pad opening area should follow TV2.3.
TV2array = SIZE (SIZE (TV2 INSIDE DUP_area)  BY 0.28 OVERUNDER) BY 0.85 UNDEROVER 
DUP_area NOT ENCLOSE TV2array
}
#ENDIF

//============================
//  Logo Design Guideline
//============================

GROUP GLOGO LOGO_?

LOGO_1_G_AA {
@ Space between LOGO and AA, GT or Metal is >= 10um.
@ DRC doesn't check dummy AA, dummy GT, dummy metal.
  EXT LOGO (AA NOT INTERACT LOGO) < 10 ABUT<90 SINGULAR REGION
}
LOGO_1_G_GT {
@ Space between LOGO and AA, GT or Metal is >= 10um.
@ DRC doesn't check dummy AA, dummy GT, dummy metal.
  EXT LOGO (GT NOT INTERACT LOGO) < 10 ABUT<90 SINGULAR REGION
}
LOGO_1_G_M1 {
@ Space between LOGO and AA, GT or Metal is >= 10um.
@ DRC doesn't check dummy AA, dummy GT, dummy metal.
  EXT LOGO (M1 NOT INTERACT LOGO) < 10 ABUT<90 SINGULAR REGION
}
LOGO_1_G_M2 {
@ Space between LOGO and AA, GT or Metal is >= 10um.
@ DRC doesn't check dummy AA, dummy GT, dummy metal.
  EXT LOGO (M2 NOT INTERACT LOGO) < 10 ABUT<90 SINGULAR REGION
}
LOGO_1_G_M3 {
@ Space between LOGO and AA, GT or Metal is >= 10um.
@ DRC doesn't check dummy AA, dummy GT, dummy metal.
  EXT LOGO (M3 NOT INTERACT LOGO) < 10 ABUT<90 SINGULAR REGION
}
LOGO_1_G_M4 {
@ Space between LOGO and AA, GT or Metal is >= 10um.
@ DRC doesn't check dummy AA, dummy GT, dummy metal.
  EXT LOGO (M4 NOT INTERACT LOGO) < 10 ABUT<90 SINGULAR REGION
}
LOGO_1_G_M5 {
@ Space between LOGO and AA, GT or Metal is >= 10um.
@ DRC doesn't check dummy AA, dummy GT, dummy metal.
  EXT LOGO (M5 NOT INTERACT LOGO) < 10 ABUT<90 SINGULAR REGION
}
LOGO_1_G_M6 {
@ Space between LOGO and AA, GT or Metal is >= 10um.
@ DRC doesn't check dummy AA, dummy GT, dummy metal.
  EXT LOGO (M6 NOT INTERACT LOGO) < 10 ABUT<90 SINGULAR REGION
}
LOGO_1_G_M7 {
@ Space between LOGO and AA, GT or Metal is >= 10um.
@ DRC doesn't check dummy AA, dummy GT, dummy metal.
  EXT LOGO (M7 NOT INTERACT LOGO) < 10 ABUT<90 SINGULAR REGION
}
LOGO_1_G_M8 {
@ Space between LOGO and AA, GT or Metal is >= 10um.
@ DRC doesn't check dummy AA, dummy GT, dummy metal.
  EXT LOGO (M8 NOT INTERACT LOGO) < 10 ABUT<90 SINGULAR REGION
}
LOGO_1_G_TM2 {
@ Space between LOGO and AA, GT or Metal is >= 10um.
@ DRC doesn't check dummy AA, dummy GT, dummy metal.
  EXT LOGO (TM2 NOT INTERACT LOGO) < 10 ABUT<90 SINGULAR REGION
}
LOGO_2_G {
@ LOGO overlap with PA, ALPA is not allowed.
  LOGO AND PA
  LOGO AND ALPA
}

//============================
//  Conventional Check
//============================

GROUP GConvention Convention_?

Convention_1 {
@ NW without N+ pick up is not allowed.
  NW NOT INTERACT NTAPi
}
Convention_2 {
@ (SP AND (AA AND GT)) in PW is not allowed, except LDMOS,VARMOS and OCCD region.
  X = PW AND ((SPi AND AAi) AND GTi)
  X NOT ((LDBK OR VARMOS) OR OCCD)
}
Convention_3 {
@ (SN AND (AA AND GT)) in NW is not allowed, except LDMOS and VARMOS region.
@ This rule is not applied for (DNSRAM OR LRSRAM) OR D2SRAM) OR RFSRAM) covered region.
  X = NW AND ((SNi AND AAi) AND GTi)
  X NOT ((LDBK OR VARMOS) OR SRAM)
}


//*******************************************************************************************************************************
//          ESD Design Rules and Guideline
//*******************************************************************************************************************************


ESD = ESD1 AND ESDIO2

ENACT = NACT AND ESDIO2
EPACT = PACT AND ESDIO2
ENTAP = ENACT AND NW
EPTAP = EPACT NOT NW

EGATE = Real_GATE AND ESDIO2
ENGATE = EGATE AND ENACT
EPGATE = EGATE AND EPACT

//SETLAYER EGATEHV = (EGATE AND DG) AND DGOD               //2.5V
//SETLAYER EGATEMV = (EGATE AND DG) NOT DGOD               //1.8V or 1.5V
EGATEHV = EGATE AND TG 
ENGATEHV = ENGATE AND TG
EPGATEHV = EPGATE AND TG
EGATEMV = EGATE AND DG                          //1.8V or 1.5V
EGATELV = EGATE NOT INSIDE (DG OR TG)                          //1.05V


EGATE_CASCODED = (EGATE AND ESDIO2) AND ESDHV   //Cascoded 1.8V/2.5V NMOS

EGATE_CASCODED_OVLAP = EGATE_CASCODED CUT ESAB
EGATE_CASCODED_INSID = EGATE_CASCODED INSIDE ESAB

EGATE_W = EGATE COIN EDGE GATE_WE
EGATE_L = EGATE COIN EDGE GATE_LE

EGATE_POLY = GT ENCLOSE EGATE
ENGATE_POLY = GT ENCLOSE ENGATE
EPGATE_POLY = GT ENCLOSE EPGATE

ECT = CT AND ESDIO2
ESAB = SAB AND ESDIO2
ESAB_HO = HOLES ESAB INNER EMPTY
ECT_S = ECT INSIDE EMOS_S
ECT_D = ECT INSIDE EMOS_D

ENMOS = ENACT ENCLOSE EGATE
EPMOS = EPACT ENCLOSE EGATE
ENMOS_SD = ENMOS NOT EGATE
EPMOS_SD = EPMOS NOT EGATE

//ENMOS_S = ENMOS_SD ENCLOSE ECT_S
ENMOS_S = (ENMOS_SD NOT ESAB) TOUCH EGATE
//ENMOS_D = ENMOS_SD ENCLOSE ECT_D
ENMOS_D = (ENMOS_SD NOT ESAB) NOT TOUCH EGATE
//EPMOS_S = EPMOS_SD ENCLOSE ECT_S
EPMOS_S = (EPMOS_SD NOT ESAB) TOUCH EGATE
//EPMOS_D = EPMOS_SD ENCLOSE ECT_D
EPMOS_D = (EPMOS_SD NOT ESAB) NOT TOUCH EGATE
EMOS_D = ENMOS_D OR EPMOS_D
EMOS_S = ENMOS_S OR EPMOS_S


ENGUARDRING = HOLES ENTAP INNER
EPGUARDRING = HOLES EPTAP INNER
ENGUARDHOLE_2 = (HOLES ENTAP INNER) ENCLOSE EPGUARDRING
EPGUARDHOLE_2 = (HOLES EPTAP INNER) ENCLOSE ENGUARDRING

ESD3C_1 = EXPAND EDGE ((EGATE NOT EGATE_CASCODED) INSIDE EDGE AA) INSIDE BY 0.001
ESD3C_2 = EXPAND EDGE ((EGATE_CASCODED NOT INSIDE SAB) INSIDE EDGE AA) INSIDE BY 0.001
ESD3C = ESD3C_1 OR ESD3C_2


LAYER MAP 9998 DATATYPE 1234 5432
LAYER EMPTY1 5432
ENGATE_D_EMPTY = EMPTY1 OR (ESDIO2 AND ENMOS_D)
EPGATE_D_EMPTY = EMPTY1 OR (ESDIO2 AND EPMOS_D)
ESD3C_EMPTY = EMPTY1 OR ESD3C

EM1_EMPTY = EMPTY1 OR M1
EV1_EMPTY = EMPTY1 OR V1
EM2_EMPTY = EMPTY1 OR M2
EV2_EMPTY = EMPTY1 OR V2
EM3_EMPTY = EMPTY1 OR M3
EV3_EMPTY = EMPTY1 OR V3
EM4_EMPTY = EMPTY1 OR M4
EV4_EMPTY = EMPTY1 OR V4
EM5_EMPTY = EMPTY1 OR M5
EV5_EMPTY = EMPTY1 OR V5
EM6_EMPTY = EMPTY1 OR M6
EV6_EMPTY = EMPTY1 OR V6
EM7_EMPTY = EMPTY1 OR M7
EV7_EMPTY = EMPTY1 OR V7
EM8_EMPTY = EMPTY1 OR M8
ETV2_EMPTY = EMPTY1 OR TV2
ETM2_EMPTY = EMPTY1 OR TM2
ECT_EMPTY = EMPTY1 OR (ESDIO2 AND ECT)
EALPA_EMPTY = EMPTY1 OR ALPA
EPA_EMPTY = EMPTY1 OR PA
EMD_EMPTY = EMPTY1 OR MD


CONNECT ENGATE_D_EMPTY ESD3C_EMPTY
CONNECT EPGATE_D_EMPTY ESD3C_EMPTY
CONNECT ENGATE_D_EMPTY EM1_EMPTY BY ECT_EMPTY
CONNECT EPGATE_D_EMPTY EM1_EMPTY BY ECT_EMPTY
CONNECT EM1_EMPTY EM2_EMPTY BY EV1_EMPTY

#IFDEF TOPMETAL 4
CONNECT EM2_EMPTY EM3_EMPTY BY EV2_EMPTY
CONNECT EM3_EMPTY ETM2_EMPTY BY ETV2_EMPTY
#ENDIF

#IFDEF TOPMETAL 5
CONNECT EM2_EMPTY EM3_EMPTY BY EV2_EMPTY
CONNECT EM3_EMPTY EM4_EMPTY BY EV3_EMPTY
CONNECT EM4_EMPTY ETM2_EMPTY BY ETV2_EMPTY
#ENDIF

#IFDEF TOPMETAL 6
CONNECT EM2_EMPTY EM3_EMPTY BY EV2_EMPTY
CONNECT EM3_EMPTY EM4_EMPTY BY EV3_EMPTY
CONNECT EM4_EMPTY EM5_EMPTY BY EV4_EMPTY
CONNECT EM5_EMPTY ETM2_EMPTY BY ETV2_EMPTY
#ENDIF

#IFDEF TOPMETAL 7
CONNECT EM2_EMPTY EM3_EMPTY BY EV2_EMPTY
CONNECT EM3_EMPTY EM4_EMPTY BY EV3_EMPTY
CONNECT EM4_EMPTY EM5_EMPTY BY EV4_EMPTY
CONNECT EM5_EMPTY EM6_EMPTY BY EV5_EMPTY
CONNECT EM6_EMPTY ETM2_EMPTY BY ETV2_EMPTY
#ENDIF

#IFDEF TOPMETAL 8
CONNECT EM2_EMPTY EM3_EMPTY BY EV2_EMPTY
CONNECT EM3_EMPTY EM4_EMPTY BY EV3_EMPTY
CONNECT EM4_EMPTY EM5_EMPTY BY EV4_EMPTY
CONNECT EM5_EMPTY EM6_EMPTY BY EV5_EMPTY
CONNECT EM6_EMPTY EM7_EMPTY BY EV6_EMPTY
CONNECT EM7_EMPTY ETM2_EMPTY BY ETV2_EMPTY
#ENDIF

#IFDEF TOPMETAL 9
CONNECT EM2_EMPTY EM3_EMPTY BY EV2_EMPTY
CONNECT EM3_EMPTY EM4_EMPTY BY EV3_EMPTY
CONNECT EM4_EMPTY EM5_EMPTY BY EV4_EMPTY
CONNECT EM5_EMPTY EM6_EMPTY BY EV5_EMPTY
CONNECT EM6_EMPTY EM7_EMPTY BY EV6_EMPTY
CONNECT EM7_EMPTY EM8_EMPTY BY EV7_EMPTY
CONNECT EM8_EMPTY ETM2_EMPTY BY ETV2_EMPTY
#ENDIF

CONNECT ETM2_EMPTY EALPA_EMPTY BY EPA_EMPTY
CONNECT EALPA_EMPTY EMD_EMPTY

#IFDEF ESD YES
//==============================================
//  ESD design and layout guideline
//==============================================

GROUP GESD ESD_?

ESDLO_2_G {
@ Unit finger width (F) of NMOS and PMOS for ESD protection device (Fig.2). >= 10um and <= 60um
 (LENGTH EGATE_W < 10) NOT INSIDE EDGE MARKS
 (LENGTH EGATE_W > 60) NOT INSIDE EDGE MARKS
}
ESDLO_3a_G {
    @ Channel width (W) of NMOS for ESD protection device (Channel width = Finger width x Finger No.). >= 300um
    @ Note: The total channel width is calculated by the ESD MOS in the same Drain connection. The connectivity is not broken by resistor for this check.
    @ SAB is used for drain recognition in DRC runset.
    X = NET AREA RATIO ENGATE_D_EMPTY ESD3C_EMPTY [AREA(ESD3C_EMPTY)/0.001] < 300
    (X INTERACT ENGATE) NOT MARKS
}
ESDLO_3b_G {
    @ Channel width (W) of PMOS for ESD protection device (Channel width=Finger width x Finger No.)
    @ Note: The total channel width is calculated by the ESD MOS in the same Drain connection. The connectivity is not broken by resistor for this check.
    @ SAB is used for drain recognition in DRC runset. ? 450 um
    X = NET AREA RATIO EPGATE_D_EMPTY ESD3C_EMPTY [AREA(ESD3C_EMPTY)/0.001] < 450
    (X INTERACT EPGATE) NOT MARKS
}
ESDLO_4a_G {
    @ Channel length of 2.5V I/O N/PMOS for protection device is >= 0.27
    X = (EGATEHV NOT (OVERDR OR TGV)) COIN EDGE GATE_LE
    (LENGTH X < 0.27) NOT INSIDE EDGE MARKS
}
ESDLO_4b_N_G {
    @ Channel length of 2.5V I/O overdrive 3.3V NMOS for protection device is >= 0.55
    X = (ENGATEHV AND OVERDR) COIN EDGE GATE_LE
    (LENGTH X < 0.55) NOT INSIDE EDGE MARKS
}
ESDLO_4b_P_G {
    @ Channel length of 2.5V I/O overdrive 3.3V PMOS for protection device is >= 0.44
    X = (EPGATEHV AND OVERDR) COIN EDGE GATE_LE
    (LENGTH X < 0.44) NOT INSIDE EDGE MARKS
}
ESDLO_4c_G {
    @ Channel length of 2.5V I/O underdrive 1.8V N/PMOS for protection device >= 0.24
    X = (EGATEHV AND TGV) COIN EDGE GATE_LE
    (LENGTH X < 0.24) NOT INSIDE EDGE MARKS
}
ESDLO_4d_G {
    @ Channel length of 1.8V I/O N/PMOS for protection device >= 0.2
    X = EGATEMV COIN EDGE GATE_LE
    (LENGTH X < 0.2) NOT INSIDE EDGE MARKS
}
ESDLO_4e_G {
    @ Channel length of 1.1V N/PMOS for protection device >= 0.07
    X = EGATELV COIN EDGE GATE_LE
    (LENGTH X < 0.07) NOT INSIDE EDGE MARKS
}
ESDLO_5_G {
    @ Space from poly edge to CT edge on source side (SCP) for NMOS and PMOS >= 0.2um
    (EXT EGATE_W ECT_S < 0.2 ABUT< 90 REGION) NOT MARKS
}
/*
ESDLO_6_G {
    @ Space from poly edge to CT edge on drain side (DCP) >= 1.3um
    (EXT EGATE_W ECT_D < 1.3 ABUT< 90 REGION) NOT MARKS
}
*/
ESDLO_7_G {
    @ SAB should block on drain side of NMOS and PMOS (contact region should be kept silicided.)
    @ SAB drawn on source side is not necessary.
    (EGATE NOT INTERACT ESAB) NOT MARKS
    (ECT AND ESAB) NOT MARKS
    (EMOS_S AND ESAB) NOT MARKS
}
ESDLO_8a_G {
    @ Width of SAB on the drain side (A) for NMOS, note: A does not include the overlap of SAB area and GT >= 1.0um
    (EXT (ENMOS_D NOT ESAB) EGATE_W < 1.0 ABUT < 90 REGION) NOT MARKS
}
ESDLO_8b_G {
    @ Width of SAB on the drain side (A) for PMOS, note: A does not include the overlap of SAB area and GT >= 0.6um
    (EXT (EPMOS_D NOT ESAB) EGATE_W < 0.6 ABUT < 90 REGION) NOT MARKS
}
ESDLO_9_G {
    @ ESD protection devices should be surrounded by guard ring, this guard ring also can be designed as the pickup of the ESD device.
    (NOT EPGATE ENGUARDRING) NOT MARKS
    (NOT ENGATE EPGUARDRING) NOT MARKS
}
ESDLO_14a_G {
    @ The overlap (Sd) of SAB and poly for 1.8V/2.5V I/O ESD N/PMOS >= 0.05um
    (INT EGATEHV ESAB < 0.05 ABUT < 90 SINGULAR REGION) NOT MARKS
    (INT EGATEMV ESAB < 0.05 ABUT < 90 SINGULAR REGION) NOT MARKS
}
ESDLO_14b_G {
    @ The overlap (Sd) of the SAB and poly for 1.1V I/O ESD N/PMOS. >= 0.02um
    (INT EGATELV ESAB < 0.02 ABUT < 90 SINGULAR REGION) NOT MARKS
}
ESDLO_15_G {
    @ For high voltage tolerant I/O using Cascoded 1.8V/2.5V NMOS, (ESDIO2 AND ESDHV) must overlap with ESD1.
    ((ESDIO2 AND ESDHV) NOT ENCLOSE ((ESDIO2 AND ESDHV) AND ESD1)) NOT MARKS
}
ESDLO_16_G {
    @ The space (S) between active poly gate and inactive poly gate of cascoded NMOS should be <= 0.3um
    (DFM COPY (DFM SPACE EGATE_CASCODED_OVLAP EGATE_CASCODED_INSID > 0.3 <10 BY EXT) REGION) NOT MARKS
    (EGATE_CASCODED_OVLAP COIN OUTSIDE EDGE EGATE_CASCODED_INSID) NOT INSIDE EDGE MARKS
}
ESDLO_17_G {
    @ For high voltage tolerant I/O designed by 1.8V/2.5V N/PMOS, SAB should cover all top poly gates and extend to overlap the second poly gate by >= 0.05um
    X = EGATE_CASCODED INTERACT ESAB
    (INT X ESAB < 0.05 ABUT < 90 SINGULAR REGION) NOT MARKS
    (EGATE_CASCODED OUTSIDE ESAB) NOT MARKS
}
#ENDIF

#IFDEF LATCH_UP YES
//===========================================
//  Latch-Up Prevention Layout Guidelines
//===========================================
GROUP GLU LU_?

ENMOS_OV = SIZE ENMOS BY 5.000
EPMOS_OV = SIZE EPMOS BY 5.000

LU_1_N_G{
@ Additional guard-ring* is recommended if no conflict with circuit and layout constrains.
ENGATE NOT ENGUARDHOLE_2
}
LU_1_P_G{
@ Additional guard-ring* is recommended if no conflict with circuit and layout constrains.
EPGATE NOT EPGUARDHOLE_2
}

LU_2_G {
@ Minimum guard-ring width is 0.3um
INT ENTAP < 0.3 ABUT<90 SINGULAR REGION
INT EPTAP < 0.3 ABUT<90 SINGULAR REGION
}

PMOS1 = ((PACT ENCLOSE Real_PGATE) NOT INTERACT CAPBP) NOT INTERACT RESP1



ENMOS_SD_PAD = NET AREA RATIO ENMOS_SD MD > 0
EPMOS_SD_PAD = NET AREA RATIO EPMOS_SD MD > 0
CONNECT M1i ENMOS_SD BY ECT
CONNECT M1i EPMOS_SD BY ECT

LU_3a_G {
@ For core N/PMOS connected to an I/O pad
@ Spacing between NMOS and PMOS is S1>= 2um
 EXT ((EPACT INTERACT EPMOS_SD_PAD) NOT (DG OR TG)) ((ENACT INTERACT ENMOS_SD_PAD) NOT (DG OR TG)) < 2 ABUT<90 SINGULAR REGION
}
LU_3b_G {
@For 1.8V N/PMOS connected to an I/O pad
@Spacing between 1.8V NMOS and 1.8V/Core PMOS and 
@Spacing between 1.8V PMOS and 1.8V/Core NMOS S1>= 2.3um
 EXT ((ENACT INTERACT ENMOS_SD_PAD) AND (DG NOT TG)) ((EPACT INTERACT EPMOS_SD_PAD) NOT TG) < 2.3  ABUT<90 SINGULAR REGION  
 EXT ((EPACT INTERACT EPMOS_SD_PAD) AND (DG NOT TG)) ((ENACT INTERACT ENMOS_SD_PAD) NOT TG) < 2.3  ABUT<90 SINGULAR REGION
}

 
LU_3c_G {
@For 2.5V N/PMOS connected to an I/O pad
@Spacing between 2.5V NMOS and 2.5V/Core PMOS and 
@Spacing between 2.5V PMOS and 2.5V/Core NMOS	S1>= 3.2um
EXT ((ENACT INTERACT ENMOS_SD_PAD) AND TG) ((EPACT INTERACT EPMOS_SD_PAD) NOT (DG NOT TG)) < 3.2  ABUT<90 SINGULAR REGION
EXT ((EPACT INTERACT EPMOS_SD_PAD) AND TG) ((ENACT INTERACT ENMOS_SD_PAD) NOT (DG NOT TG)) < 3.2  ABUT<90 SINGULAR REGION

}


LU_4a_G {
@ Maximum space from any point within Source/Drain region to the nearest pickup AA region inside the same well for I/O and internal circuits is 35um.
@ DRC doesn’t check OCCD region.
  A = INT NTAP < 0.005 ABUT INTERSECTING ONLY REGION
  B = (NTAP INTERACT A) NOT A
  C = INT B < 0.001 ABUT INTERSECTING ONLY REGION
  D = (B INTERACT C) NOT C
//  NW_MINUS_NTAP = SIZE D BY 35 INSIDE OF NW STEP 0.33
//  X = PMOS1 AND NW
  NW_MINUS_NTAP_0 = SIZE D BY 15 INSIDE OF NW STEP 0.33
  MAYBE_BAD_a = NW NOT NW_MINUS_NTAP_0
  NW_FILTER = NW INTERACT MAYBE_BAD_a
  NW_MINUS_NTAP_1 = NW_MINUS_NTAP_0 AND NW_FILTER
  NW_MINUS_NTAP = SIZE NW_MINUS_NTAP_1 BY 20 INSIDE OF NW_FILTER STEP 0.33
  X = PMOS1 AND NW_FILTER
  (OUTSIDE EDGE X NW_MINUS_NTAP) NOT INSIDE EDGE (MARKS OR OCCD)
}

NMOS1 = ((NACT ENCLOSE Real_NGATE) NOT INTERACT CAPBP) NOT INTERACT RESP1

LU_4b_G {
@ Maximum space from any point within Source/Drain region to the nearest pickup AA region inside the same well for I/O and internal circuits is 35um.
@ DRC doesn’t check OCCD region.
  A = INT PTAP < 0.005 ABUT INTERSECTING ONLY REGION
  B = (PTAP INTERACT A) NOT A
  C = INT B < 0.001 ABUT INTERSECTING ONLY REGION
  D = (B INTERACT C) NOT C
//  PW_MINUS_PTAP = SIZE D BY 35 INSIDE OF PW STEP 0.33
//  X = NMOS1 AND PW
  PW_MINUS_PTAP_0 = SIZE D BY 15 INSIDE OF PW STEP 0.33
  MAYBE_BAD_b = PW NOT PW_MINUS_PTAP_0
  PW_FILTER = PW INTERACT MAYBE_BAD_b
  PW_MINUS_PTAP_1 = PW_MINUS_PTAP_0 AND PW_FILTER
  PW_MINUS_PTAP = SIZE PW_MINUS_PTAP_1 BY 20 INSIDE OF PW_FILTER STEP 0.33
  X = NMOS1 AND PW_FILTER
  (OUTSIDE EDGE X PW_MINUS_PTAP) NOT INSIDE EDGE (MARKS OR OCCD)
}
#ENDIF

#ENDCRYPT
}
